[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "base-compat"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative.Compat",
          "name": "Compat",
          "package": "base-compat",
          "source": "src/Control-Applicative-Compat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Applicative Compat",
          "module": "Control.Applicative.Compat",
          "name": "Compat",
          "package": "base-compat",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Control-Applicative-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative.Compat",
          "name": "Const",
          "package": "base-compat",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Applicative Compat",
          "module": "Control.Applicative.Compat",
          "name": "Const",
          "package": "base-compat",
          "partial": "Const",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Control-Applicative-Compat.html#t:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative.Compat",
          "name": "WrappedMonad",
          "package": "base-compat",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Applicative Compat",
          "module": "Control.Applicative.Compat",
          "name": "WrappedMonad",
          "package": "base-compat",
          "partial": "Wrapped Monad",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Control-Applicative-Compat.html#t:WrappedMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative.Compat",
          "name": "Const",
          "package": "base-compat",
          "signature": "Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Applicative Compat",
          "module": "Control.Applicative.Compat",
          "name": "Const",
          "package": "base-compat",
          "partial": "Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Control-Applicative-Compat.html#v:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative.Compat",
          "name": "WrapMonad",
          "package": "base-compat",
          "signature": "WrapMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Applicative Compat",
          "module": "Control.Applicative.Compat",
          "name": "WrapMonad",
          "package": "base-compat",
          "partial": "Wrap Monad",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Control-Applicative-Compat.html#v:WrapMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative.Compat",
          "name": "getConst",
          "package": "base-compat",
          "signature": "a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Applicative Compat",
          "module": "Control.Applicative.Compat",
          "name": "getConst",
          "package": "base-compat",
          "partial": "Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Control-Applicative-Compat.html#v:getConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative.Compat",
          "name": "unwrapMonad",
          "package": "base-compat",
          "signature": "m a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Applicative Compat",
          "module": "Control.Applicative.Compat",
          "name": "unwrapMonad",
          "package": "base-compat",
          "partial": "Monad",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Control-Applicative-Compat.html#v:unwrapMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Base.Compat",
          "name": "Compat",
          "package": "base-compat",
          "source": "src/Control-Exception-Base-Compat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Exception Base Compat",
          "module": "Control.Exception.Base.Compat",
          "name": "Compat",
          "package": "base-compat",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Control-Exception-Base-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Compat",
          "name": "Compat",
          "package": "base-compat",
          "source": "src/Control-Exception-Compat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Exception Compat",
          "module": "Control.Exception.Compat",
          "name": "Compat",
          "package": "base-compat",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Control-Exception-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Compat",
          "name": "Compat",
          "package": "base-compat",
          "source": "src/Control-Monad-Compat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Monad Compat",
          "module": "Control.Monad.Compat",
          "name": "Compat",
          "package": "base-compat",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Control-Monad-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003evoid\u003c/a\u003e\u003c/code\u003e value\u003c/code\u003e discards or ignores the result of evaluation, such as the return value of an \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e action.\n\u003c/p\u003e",
          "module": "[\"Control.Monad.Compat\",\"Data.Functor.Compat\"]",
          "name": "void",
          "package": "base-compat",
          "signature": "f a -\u003e f ()",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base-compat/docs/Control-Monad-Compat.html#v:void\",\"http://hackage.haskell.org/package/base-compat/docs/Data-Functor-Compat.html#v:void\"]"
        },
        "index": {
          "description": "void value discards or ignores the result of evaluation such as the return value of an IO action",
          "hierarchy": "Control Monad Compat",
          "module": "Control.Monad.Compat",
          "name": "void",
          "normalized": "a b-\u003ea()",
          "package": "base-compat",
          "signature": "f a-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Control-Monad-Compat.html#v:void"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Bool.Compat",
          "name": "Compat",
          "package": "base-compat",
          "source": "src/Data-Bool-Compat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Bool Compat",
          "module": "Data.Bool.Compat",
          "name": "Compat",
          "package": "base-compat",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Bool-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCase analysis for the \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e type.\n \u003ccode\u003ebool a b p\u003c/code\u003e evaluates to \u003ccode\u003ea\u003c/code\u003e when \u003ccode\u003ep\u003c/code\u003e is \u003ccode\u003eFalse\u003c/code\u003e, and evaluates to \u003ccode\u003eb\u003c/code\u003e\n when \u003ccode\u003ep\u003c/code\u003e is \u003ccode\u003eTrue\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eSince: 4.7.0.0\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Data.Bool.Compat",
          "name": "bool",
          "package": "base-compat",
          "signature": "a -\u003e a -\u003e Bool -\u003e a",
          "source": "src/Data-Bool-Compat.html#bool",
          "type": "function"
        },
        "index": {
          "description": "Case analysis for the Bool type bool evaluates to when is False and evaluates to when is True Since",
          "hierarchy": "Data Bool Compat",
          "module": "Data.Bool.Compat",
          "name": "bool",
          "normalized": "a-\u003ea-\u003eBool-\u003ea",
          "package": "base-compat",
          "signature": "a-\u003ea-\u003eBool-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Bool-Compat.html#v:bool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Either.Compat",
          "name": "Compat",
          "package": "base-compat",
          "source": "src/Data-Either-Compat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Either Compat",
          "module": "Data.Either.Compat",
          "name": "Compat",
          "package": "base-compat",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Either-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the given value is a \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e-value, \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eSince: 4.7.0.0\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Data.Either.Compat",
          "name": "isLeft",
          "package": "base-compat",
          "signature": "Either a b -\u003e Bool",
          "source": "src/Data-Either-Compat.html#isLeft",
          "type": "function"
        },
        "index": {
          "description": "Return True if the given value is Left value False otherwise Since",
          "hierarchy": "Data Either Compat",
          "module": "Data.Either.Compat",
          "name": "isLeft",
          "normalized": "Either a b-\u003eBool",
          "package": "base-compat",
          "partial": "Left",
          "signature": "Either a b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Either-Compat.html#v:isLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the given value is a \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e-value, \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eSince: 4.7.0.0\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Data.Either.Compat",
          "name": "isRight",
          "package": "base-compat",
          "signature": "Either a b -\u003e Bool",
          "source": "src/Data-Either-Compat.html#isRight",
          "type": "function"
        },
        "index": {
          "description": "Return True if the given value is Right value False otherwise Since",
          "hierarchy": "Data Either Compat",
          "module": "Data.Either.Compat",
          "name": "isRight",
          "normalized": "Either a b-\u003eBool",
          "package": "base-compat",
          "partial": "Right",
          "signature": "Either a b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Either-Compat.html#v:isRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Foldable.Compat",
          "name": "Compat",
          "package": "base-compat",
          "source": "src/Data-Foldable-Compat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Foldable Compat",
          "module": "Data.Foldable.Compat",
          "name": "Compat",
          "package": "base-compat",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Foldable-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData structures that can be folded.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003efoldMap\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example, given a data type\n\u003c/p\u003e\u003cpre\u003e data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)\n\u003c/pre\u003e\u003cp\u003ea suitable instance would be\n\u003c/p\u003e\u003cpre\u003e instance Foldable Tree where\n    foldMap f Empty = mempty\n    foldMap f (Leaf x) = f x\n    foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r\n\u003c/pre\u003e\u003cp\u003eThis is suitable even for abstract types, as the monoid is assumed\n to satisfy the monoid laws.  Alternatively, one could define \u003ccode\u003efoldr\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e instance Foldable Tree where\n    foldr f z Empty = z\n    foldr f z (Leaf x) = f x z\n    foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l\n\u003c/pre\u003e",
          "module": "Data.Foldable.Compat",
          "name": "Foldable",
          "package": "base-compat",
          "type": "class"
        },
        "index": {
          "description": "Data structures that can be folded Minimal complete definition foldMap or foldr For example given data type data Tree Empty Leaf Node Tree Tree suitable instance would be instance Foldable Tree where foldMap Empty mempty foldMap Leaf foldMap Node foldMap mappend mappend foldMap This is suitable even for abstract types as the monoid is assumed to satisfy the monoid laws Alternatively one could define foldr instance Foldable Tree where foldr Empty foldr Leaf foldr Node foldr foldr",
          "hierarchy": "Data Foldable Compat",
          "module": "Data.Foldable.Compat",
          "name": "Foldable",
          "package": "base-compat",
          "partial": "Foldable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Foldable-Compat.html#t:Foldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine the elements of a structure using a monoid.\n\u003c/p\u003e",
          "module": "Data.Foldable.Compat",
          "name": "fold",
          "package": "base-compat",
          "signature": "t m -\u003e m",
          "type": "method"
        },
        "index": {
          "description": "Combine the elements of structure using monoid",
          "hierarchy": "Data Foldable Compat",
          "module": "Data.Foldable.Compat",
          "name": "fold",
          "normalized": "a b-\u003eb",
          "package": "base-compat",
          "signature": "t m-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Foldable-Compat.html#v:fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of the structure to a monoid,\n and combine the results.\n\u003c/p\u003e",
          "module": "Data.Foldable.Compat",
          "name": "foldMap",
          "package": "base-compat",
          "signature": "(a -\u003e m) -\u003e t a -\u003e m",
          "type": "method"
        },
        "index": {
          "description": "Map each element of the structure to monoid and combine the results",
          "hierarchy": "Data Foldable Compat",
          "module": "Data.Foldable.Compat",
          "name": "foldMap",
          "normalized": "(a-\u003eb)-\u003ec a-\u003eb",
          "package": "base-compat",
          "partial": "Map",
          "signature": "(a-\u003em)-\u003et a-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Foldable-Compat.html#v:foldMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft-associative fold of a structure.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e f z = \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e f z . \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Data.Foldable.Compat",
          "name": "foldl",
          "package": "base-compat",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e t b -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "Left-associative fold of structure foldl foldl toList",
          "hierarchy": "Data Foldable Compat",
          "module": "Data.Foldable.Compat",
          "name": "foldl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
          "package": "base-compat",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003et b-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Foldable-Compat.html#v:foldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft-associative fold of a structure.\n but with strict application of the operator.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e f z = \u003ccode\u003e\u003ca\u003efoldl'\u003c/a\u003e\u003c/code\u003e f z . \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Data.Foldable.Compat",
          "name": "foldl'",
          "package": "base-compat",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e t b -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "Left-associative fold of structure but with strict application of the operator foldl foldl toList",
          "hierarchy": "Data Foldable Compat",
          "module": "Data.Foldable.Compat",
          "name": "foldl'",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
          "package": "base-compat",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003et b-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Foldable-Compat.html#v:foldl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e that has no base case,\n and thus may only be applied to non-empty structures.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e f = \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e f . \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Data.Foldable.Compat",
          "name": "foldl1",
          "package": "base-compat",
          "signature": "(a -\u003e a -\u003e a) -\u003e t a -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "variant of foldl that has no base case and thus may only be applied to non-empty structures foldl1 foldl1 toList",
          "hierarchy": "Data Foldable Compat",
          "module": "Data.Foldable.Compat",
          "name": "foldl1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
          "package": "base-compat",
          "signature": "(a-\u003ea-\u003ea)-\u003et a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Foldable-Compat.html#v:foldl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight-associative fold of a structure.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e f z = \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e f z . \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Data.Foldable.Compat",
          "name": "foldr",
          "package": "base-compat",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e t a -\u003e b",
          "type": "method"
        },
        "index": {
          "description": "Right-associative fold of structure foldr foldr toList",
          "hierarchy": "Data Foldable Compat",
          "module": "Data.Foldable.Compat",
          "name": "foldr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
          "package": "base-compat",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003et a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Foldable-Compat.html#v:foldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight-associative fold of a structure, \n but with strict application of the operator.\n\u003c/p\u003e",
          "module": "Data.Foldable.Compat",
          "name": "foldr'",
          "package": "base-compat",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e t a -\u003e b",
          "type": "method"
        },
        "index": {
          "description": "Right-associative fold of structure but with strict application of the operator",
          "hierarchy": "Data Foldable Compat",
          "module": "Data.Foldable.Compat",
          "name": "foldr'",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
          "package": "base-compat",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003et a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Foldable-Compat.html#v:foldr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e that has no base case,\n and thus may only be applied to non-empty structures.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e f = \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e f . \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Data.Foldable.Compat",
          "name": "foldr1",
          "package": "base-compat",
          "signature": "(a -\u003e a -\u003e a) -\u003e t a -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "variant of foldr that has no base case and thus may only be applied to non-empty structures foldr1 foldr1 toList",
          "hierarchy": "Data Foldable Compat",
          "module": "Data.Foldable.Compat",
          "name": "foldr1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
          "package": "base-compat",
          "signature": "(a-\u003ea-\u003ea)-\u003et a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Foldable-Compat.html#v:foldr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Compat",
          "name": "Compat",
          "package": "base-compat",
          "source": "src/Data-Functor-Compat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Functor Compat",
          "module": "Data.Functor.Compat",
          "name": "Compat",
          "package": "base-compat",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Functor-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlipped version of \u003ccode\u003e\u003ca\u003e$\u003e\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eSince: 4.7.0.0\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Data.Functor.Compat",
          "name": "($\u003e)",
          "package": "base-compat",
          "signature": "f a -\u003e b -\u003e f b",
          "source": "src/Data-Functor-Compat.html#%24%3E",
          "type": "function"
        },
        "index": {
          "description": "Flipped version of Since",
          "hierarchy": "Data Functor Compat",
          "module": "Data.Functor.Compat",
          "name": "($\u003e) $\u003e",
          "normalized": "a b-\u003ec-\u003ea c",
          "package": "base-compat",
          "signature": "f a-\u003eb-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Functor-Compat.html#v:-36--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Compat",
          "name": "Compat",
          "package": "base-compat",
          "source": "src/Data-Monoid-Compat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Monoid Compat",
          "module": "Data.Monoid.Compat",
          "name": "Compat",
          "package": "base-compat",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Monoid-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn infix synonym for \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Monoid.Compat",
          "name": "(\u003c\u003e)",
          "package": "base-compat",
          "signature": "m -\u003e m -\u003e m",
          "type": "function"
        },
        "index": {
          "description": "An infix synonym for mappend",
          "hierarchy": "Data Monoid Compat",
          "module": "Data.Monoid.Compat",
          "name": "(\u003c\u003e) \u003c\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base-compat",
          "signature": "m-\u003em-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Monoid-Compat.html#v:-60--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Traversable.Compat",
          "name": "Compat",
          "package": "base-compat",
          "source": "src/Data-Traversable-Compat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Traversable Compat",
          "module": "Data.Traversable.Compat",
          "name": "Compat",
          "package": "base-compat",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Traversable-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunctors representing data structures that can be traversed from\n left to right.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003esequenceA\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eInstances are similar to \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, e.g. given a data type\n\u003c/p\u003e\u003cpre\u003e data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)\n\u003c/pre\u003e\u003cp\u003ea suitable instance would be\n\u003c/p\u003e\u003cpre\u003e instance Traversable Tree where\n    traverse f Empty = pure Empty\n    traverse f (Leaf x) = Leaf \u003c$\u003e f x\n    traverse f (Node l k r) = Node \u003c$\u003e traverse f l \u003c*\u003e f k \u003c*\u003e traverse f r\n\u003c/pre\u003e\u003cp\u003eThis is suitable even for abstract types, as the laws for \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e\n imply a form of associativity.\n\u003c/p\u003e\u003cp\u003eThe superclass instances should satisfy the following:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e In the \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e instance, \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e should be equivalent to traversal\n    with the identity applicative functor (\u003ccode\u003e\u003ca\u003efmapDefault\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003cli\u003e In the \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e instance, \u003ccode\u003e\u003ca\u003efoldMap\u003c/a\u003e\u003c/code\u003e should be\n    equivalent to traversal with a constant applicative functor\n    (\u003ccode\u003e\u003ca\u003efoldMapDefault\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Data.Traversable.Compat",
          "name": "Traversable",
          "package": "base-compat",
          "type": "class"
        },
        "index": {
          "description": "Functors representing data structures that can be traversed from left to right Minimal complete definition traverse or sequenceA Instances are similar to Functor e.g given data type data Tree Empty Leaf Node Tree Tree suitable instance would be instance Traversable Tree where traverse Empty pure Empty traverse Leaf Leaf traverse Node Node traverse traverse This is suitable even for abstract types as the laws for imply form of associativity The superclass instances should satisfy the following In the Functor instance fmap should be equivalent to traversal with the identity applicative functor fmapDefault In the Foldable instance foldMap should be equivalent to traversal with constant applicative functor foldMapDefault",
          "hierarchy": "Data Traversable Compat",
          "module": "Data.Traversable.Compat",
          "name": "Traversable",
          "package": "base-compat",
          "partial": "Traversable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Traversable-Compat.html#t:Traversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure to a monadic action, evaluate\n these actions from left to right, and collect the results.\n\u003c/p\u003e",
          "module": "Data.Traversable.Compat",
          "name": "mapM",
          "package": "base-compat",
          "signature": "(a -\u003e m b) -\u003e t a -\u003e m (t b)",
          "type": "method"
        },
        "index": {
          "description": "Map each element of structure to monadic action evaluate these actions from left to right and collect the results",
          "hierarchy": "Data Traversable Compat",
          "module": "Data.Traversable.Compat",
          "name": "mapM",
          "normalized": "(a-\u003eb c)-\u003ed a-\u003eb(d c)",
          "package": "base-compat",
          "signature": "(a-\u003em b)-\u003et a-\u003em(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Traversable-Compat.html#v:mapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate each monadic action in the structure from left to right,\n and collect the results.\n\u003c/p\u003e",
          "module": "Data.Traversable.Compat",
          "name": "sequence",
          "package": "base-compat",
          "signature": "t (m a) -\u003e m (t a)",
          "type": "method"
        },
        "index": {
          "description": "Evaluate each monadic action in the structure from left to right and collect the results",
          "hierarchy": "Data Traversable Compat",
          "module": "Data.Traversable.Compat",
          "name": "sequence",
          "normalized": "a(b c)-\u003eb(a c)",
          "package": "base-compat",
          "signature": "t(m a)-\u003em(t a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Traversable-Compat.html#v:sequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate each action in the structure from left to right,\n and collect the results.\n\u003c/p\u003e",
          "module": "Data.Traversable.Compat",
          "name": "sequenceA",
          "package": "base-compat",
          "signature": "t (f a) -\u003e f (t a)",
          "type": "method"
        },
        "index": {
          "description": "Evaluate each action in the structure from left to right and collect the results",
          "hierarchy": "Data Traversable Compat",
          "module": "Data.Traversable.Compat",
          "name": "sequenceA",
          "normalized": "a(b c)-\u003eb(a c)",
          "package": "base-compat",
          "signature": "t(f a)-\u003ef(t a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Traversable-Compat.html#v:sequenceA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure to an action, evaluate\n these actions from left to right, and collect the results.\n\u003c/p\u003e",
          "module": "Data.Traversable.Compat",
          "name": "traverse",
          "package": "base-compat",
          "signature": "(a -\u003e f b) -\u003e t a -\u003e f (t b)",
          "type": "method"
        },
        "index": {
          "description": "Map each element of structure to an action evaluate these actions from left to right and collect the results",
          "hierarchy": "Data Traversable Compat",
          "module": "Data.Traversable.Compat",
          "name": "traverse",
          "normalized": "(a-\u003eb c)-\u003ed a-\u003eb(d c)",
          "package": "base-compat",
          "signature": "(a-\u003ef b)-\u003et a-\u003ef(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Data-Traversable-Compat.html#v:traverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exception.Compat",
          "name": "Compat",
          "package": "base-compat",
          "source": "src/GHC-Exception-Compat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "GHC Exception Compat",
          "module": "GHC.Exception.Compat",
          "name": "Compat",
          "package": "base-compat",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/GHC-Exception-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Compat",
          "name": "Compat",
          "package": "base-compat",
          "source": "src/Prelude-Compat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Prelude Compat",
          "module": "Prelude.Compat",
          "name": "Compat",
          "package": "base-compat",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Prelude-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Environment.Compat",
          "name": "Compat",
          "package": "base-compat",
          "source": "src/System-Environment-Compat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "System Environment Compat",
          "module": "System.Environment.Compat",
          "name": "Compat",
          "package": "base-compat",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/System-Environment-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the value of the environment variable \u003ccode\u003evar\u003c/code\u003e, or \u003ccode\u003eNothing\u003c/code\u003e if\n there is no such value.\n\u003c/p\u003e\u003cp\u003eFor POSIX users, this is equivalent to \u003ccode\u003e\u003ca\u003egetEnv\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "System.Environment.Compat",
          "name": "lookupEnv",
          "package": "base-compat",
          "signature": "String -\u003e IO (Maybe String)",
          "type": "function"
        },
        "index": {
          "description": "Return the value of the environment variable var or Nothing if there is no such value For POSIX users this is equivalent to getEnv",
          "hierarchy": "System Environment Compat",
          "module": "System.Environment.Compat",
          "name": "lookupEnv",
          "normalized": "String-\u003eIO(Maybe String)",
          "package": "base-compat",
          "partial": "Env",
          "signature": "String-\u003eIO(Maybe String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/System-Environment-Compat.html#v:lookupEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Read.Compat",
          "name": "Compat",
          "package": "base-compat",
          "source": "src/Text-Read-Compat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Read Compat",
          "module": "Text.Read.Compat",
          "name": "Compat",
          "package": "base-compat",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Text-Read-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string using the \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e instance.\n Succeeds if there is exactly one valid result.\n A \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e value indicates a parse error.\n\u003c/p\u003e",
          "module": "Text.Read.Compat",
          "name": "readEither",
          "package": "base-compat",
          "signature": "String -\u003e Either String a",
          "type": "function"
        },
        "index": {
          "description": "Parse string using the Read instance Succeeds if there is exactly one valid result Left value indicates parse error",
          "hierarchy": "Text Read Compat",
          "module": "Text.Read.Compat",
          "name": "readEither",
          "normalized": "String-\u003eEither String a",
          "package": "base-compat",
          "partial": "Either",
          "signature": "String-\u003eEither String a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Text-Read-Compat.html#v:readEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string using the \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e instance.\n Succeeds if there is exactly one valid result.\n\u003c/p\u003e",
          "module": "Text.Read.Compat",
          "name": "readMaybe",
          "package": "base-compat",
          "signature": "String -\u003e Maybe a",
          "type": "function"
        },
        "index": {
          "description": "Parse string using the Read instance Succeeds if there is exactly one valid result",
          "hierarchy": "Text Read Compat",
          "module": "Text.Read.Compat",
          "name": "readMaybe",
          "normalized": "String-\u003eMaybe a",
          "package": "base-compat",
          "partial": "Maybe",
          "signature": "String-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base-compat/docs/Text-Read-Compat.html#v:readMaybe"
      }
    }
  ]
]