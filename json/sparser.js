[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "sparser"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLightweight parsing library based on partial functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Sparser",
          "name": "Sparser",
          "package": "sparser",
          "source": "src/Data-Sparser.html",
          "type": "module"
        },
        "index": {
          "description": "Lightweight parsing library based on partial functions",
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "Sparser",
          "package": "sparser",
          "partial": "Sparser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "Sparser",
          "package": "sparser",
          "source": "src/Data-Sparser.html#Sparser",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "Sparser",
          "package": "sparser",
          "partial": "Sparser",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#t:Sparser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "SparserT",
          "package": "sparser",
          "source": "src/Data-Sparser.html#SparserT",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "SparserT",
          "package": "sparser",
          "partial": "Sparser",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#t:SparserT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "asSparser",
          "package": "sparser",
          "signature": "Sparser a -\u003e Sparser a",
          "source": "src/Data-Sparser.html#asSparser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "asSparser",
          "normalized": "Sparser a-\u003eSparser a",
          "package": "sparser",
          "partial": "Sparser",
          "signature": "Sparser a-\u003eSparser a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:asSparser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "atEnd",
          "package": "sparser",
          "signature": "SparserT s a ()",
          "source": "src/Data-Sparser.html#atEnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "atEnd",
          "normalized": "SparserT a b()",
          "package": "sparser",
          "partial": "End",
          "signature": "SparserT s a()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:atEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "between",
          "package": "sparser",
          "signature": "m a -\u003e m a1 -\u003e m b -\u003e m b",
          "source": "src/Data-Sparser.html#between",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "between",
          "normalized": "a b-\u003ea b-\u003ea c-\u003ea c",
          "package": "sparser",
          "signature": "m a-\u003em a-\u003em b-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:between"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "braces",
          "package": "sparser",
          "signature": "SparserT s Char b -\u003e SparserT s Char b",
          "source": "src/Data-Sparser.html#braces",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "braces",
          "normalized": "SparserT a Char b-\u003eSparserT a Char b",
          "package": "sparser",
          "signature": "SparserT s Char b-\u003eSparserT s Char b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:braces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "brackets",
          "package": "sparser",
          "signature": "SparserT s Char b -\u003e SparserT s Char b",
          "source": "src/Data-Sparser.html#brackets",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "brackets",
          "normalized": "SparserT a Char b-\u003eSparserT a Char b",
          "package": "sparser",
          "signature": "SparserT s Char b-\u003eSparserT s Char b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:brackets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "char",
          "package": "sparser",
          "signature": "a -\u003e SparserT s a a",
          "source": "src/Data-Sparser.html#char",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "char",
          "normalized": "a-\u003eSparserT b a a",
          "package": "sparser",
          "signature": "a-\u003eSparserT s a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "charIf",
          "package": "sparser",
          "signature": "(a -\u003e Bool) -\u003e SparserT s a a",
          "source": "src/Data-Sparser.html#charIf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "charIf",
          "normalized": "(a-\u003eBool)-\u003eSparserT b a a",
          "package": "sparser",
          "partial": "If",
          "signature": "(a-\u003eBool)-\u003eSparserT s a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:charIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "complete",
          "package": "sparser",
          "signature": "SparserT s a b -\u003e SparserT s a b",
          "source": "src/Data-Sparser.html#complete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "complete",
          "normalized": "SparserT a b c-\u003eSparserT a b c",
          "package": "sparser",
          "signature": "SparserT s a b-\u003eSparserT s a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:complete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "count",
          "package": "sparser",
          "signature": "Int -\u003e m a -\u003e m [a]",
          "source": "src/Data-Sparser.html#count",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "count",
          "normalized": "Int-\u003ea b-\u003ea[b]",
          "package": "sparser",
          "signature": "Int-\u003em a-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:count"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "endBy",
          "package": "sparser",
          "signature": "f a -\u003e f a1 -\u003e f [a]",
          "source": "src/Data-Sparser.html#endBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "endBy",
          "normalized": "a b-\u003ea b-\u003ea[b]",
          "package": "sparser",
          "partial": "By",
          "signature": "f a-\u003ef a-\u003ef[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:endBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "endBy1",
          "package": "sparser",
          "signature": "m a -\u003e m a1 -\u003e m [a]",
          "source": "src/Data-Sparser.html#endBy1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "endBy1",
          "normalized": "a b-\u003ea b-\u003ea[b]",
          "package": "sparser",
          "partial": "By",
          "signature": "m a-\u003em a-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:endBy1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSucceed based on predicate, but do not consume input.\n\u003c/p\u003e\u003cp\u003eThe given function receives the \u003cem\u003eentire\u003c/em\u003e remaining input.\n\u003c/p\u003e",
          "module": "Data.Sparser",
          "name": "gateP",
          "package": "sparser",
          "signature": "(s -\u003e [a] -\u003e Bool) -\u003e SparserT s a ()",
          "source": "src/Data-Sparser.html#gateP",
          "type": "function"
        },
        "index": {
          "description": "Succeed based on predicate but do not consume input The given function receives the entire remaining input",
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "gateP",
          "normalized": "(a-\u003e[b]-\u003eBool)-\u003eSparserT a b()",
          "package": "sparser",
          "signature": "(s-\u003e[a]-\u003eBool)-\u003eSparserT s a()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:gateP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConsumes one input element.\n\u003c/p\u003e\u003cp\u003eFails if the predicate fails, or if there is no more input.\n\u003c/p\u003e",
          "module": "Data.Sparser",
          "name": "headP",
          "package": "sparser",
          "signature": "(s -\u003e a -\u003e Bool) -\u003e SparserT s a a",
          "source": "src/Data-Sparser.html#headP",
          "type": "function"
        },
        "index": {
          "description": "Consumes one input element Fails if the predicate fails or if there is no more input",
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "headP",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eSparserT a b b",
          "package": "sparser",
          "signature": "(s-\u003ea-\u003eBool)-\u003eSparserT s a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:headP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "ifState",
          "package": "sparser",
          "signature": "(s -\u003e Bool) -\u003e SparserT s a b -\u003e SparserT s a b",
          "source": "src/Data-Sparser.html#ifState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "ifState",
          "normalized": "(a-\u003eBool)-\u003eSparserT a b c-\u003eSparserT a b c",
          "package": "sparser",
          "partial": "State",
          "signature": "(s-\u003eBool)-\u003eSparserT s a b-\u003eSparserT s a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:ifState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "integer",
          "package": "sparser",
          "signature": "SparserT s Char Integer",
          "source": "src/Data-Sparser.html#integer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "integer",
          "package": "sparser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:integer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "many1",
          "package": "sparser",
          "signature": "m a -\u003e m [a]",
          "source": "src/Data-Sparser.html#many1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "many1",
          "normalized": "a b-\u003ea[b]",
          "package": "sparser",
          "signature": "m a-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:many1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "notChar",
          "package": "sparser",
          "signature": "a -\u003e SparserT s a a",
          "source": "src/Data-Sparser.html#notChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "notChar",
          "normalized": "a-\u003eSparserT b a a",
          "package": "sparser",
          "partial": "Char",
          "signature": "a-\u003eSparserT s a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:notChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e&#160;\n Run a parser, returning the result.\n\u003c/p\u003e",
          "module": "Data.Sparser",
          "name": "runSparser",
          "package": "sparser",
          "signature": "Sparser a -\u003e String -\u003e Maybe a",
          "source": "src/Data-Sparser.html#runSparser",
          "type": "function"
        },
        "index": {
          "description": "Run parser returning the result",
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "runSparser",
          "normalized": "Sparser a-\u003eString-\u003eMaybe a",
          "package": "sparser",
          "partial": "Sparser",
          "signature": "Sparser a-\u003eString-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:runSparser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e&#160;\n Run a parser with a custom state, returning the result.\n\u003c/p\u003e",
          "module": "Data.Sparser",
          "name": "runSparserT",
          "package": "sparser",
          "signature": "SparserT s a b -\u003e s -\u003e [a] -\u003e Maybe b",
          "source": "src/Data-Sparser.html#runSparserT",
          "type": "function"
        },
        "index": {
          "description": "Run parser with custom state returning the result",
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "runSparserT",
          "normalized": "SparserT a b c-\u003ea-\u003e[b]-\u003eMaybe c",
          "package": "sparser",
          "partial": "Sparser",
          "signature": "SparserT s a b-\u003es-\u003e[a]-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:runSparserT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e&#160;\n Run a parser with a custom state.\n\u003c/p\u003e\u003cp\u003eThis is the most general way to run a parser. It returns the final state,\n remaining input and the result.\n\u003c/p\u003e",
          "module": "Data.Sparser",
          "name": "runSparserT'",
          "package": "sparser",
          "signature": "SparserT s a b -\u003e s -\u003e [a] -\u003e Maybe (s, [a], b)",
          "source": "src/Data-Sparser.html#runSparserT%27",
          "type": "function"
        },
        "index": {
          "description": "Run parser with custom state This is the most general way to run parser It returns the final state remaining input and the result",
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "runSparserT'",
          "normalized": "SparserT a b c-\u003ea-\u003e[b]-\u003eMaybe(a,[b],c)",
          "package": "sparser",
          "partial": "Sparser T'",
          "signature": "SparserT s a b-\u003es-\u003e[a]-\u003eMaybe(s,[a],b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:runSparserT-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "sepBy",
          "package": "sparser",
          "signature": "f a1 -\u003e f a -\u003e f [a1]",
          "source": "src/Data-Sparser.html#sepBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "sepBy",
          "normalized": "a b-\u003ea b-\u003ea[b]",
          "package": "sparser",
          "partial": "By",
          "signature": "f a-\u003ef a-\u003ef[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:sepBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "sepBy1",
          "package": "sparser",
          "signature": "m a1 -\u003e m a -\u003e m [a1]",
          "source": "src/Data-Sparser.html#sepBy1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "sepBy1",
          "normalized": "a b-\u003ea b-\u003ea[b]",
          "package": "sparser",
          "partial": "By",
          "signature": "m a-\u003em a-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:sepBy1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "sepEndBy",
          "package": "sparser",
          "signature": "m a1 -\u003e m a -\u003e m [a1]",
          "source": "src/Data-Sparser.html#sepEndBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "sepEndBy",
          "normalized": "a b-\u003ea b-\u003ea[b]",
          "package": "sparser",
          "partial": "End By",
          "signature": "m a-\u003em a-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:sepEndBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "sepEndBy1",
          "package": "sparser",
          "signature": "m a1 -\u003e m a -\u003e m [a1]",
          "source": "src/Data-Sparser.html#sepEndBy1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "sepEndBy1",
          "normalized": "a b-\u003ea b-\u003ea[b]",
          "package": "sparser",
          "partial": "End By",
          "signature": "m a-\u003em a-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:sepEndBy1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "skipMany",
          "package": "sparser",
          "signature": "f a -\u003e f ()",
          "source": "src/Data-Sparser.html#skipMany",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "skipMany",
          "normalized": "a b-\u003ea()",
          "package": "sparser",
          "partial": "Many",
          "signature": "f a-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:skipMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "skipMany1",
          "package": "sparser",
          "signature": "m a -\u003e m ()",
          "source": "src/Data-Sparser.html#skipMany1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "skipMany1",
          "normalized": "a b-\u003ea()",
          "package": "sparser",
          "partial": "Many",
          "signature": "m a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:skipMany1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "space",
          "package": "sparser",
          "signature": "SparserT s Char [Char]",
          "source": "src/Data-Sparser.html#space",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "space",
          "normalized": "SparserT a Char[Char]",
          "package": "sparser",
          "signature": "SparserT s Char[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:space"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConsume one or more input elements.\n\u003c/p\u003e\u003cp\u003eThe given function receives the \u003cem\u003eentire\u003c/em\u003e remaining input, and must return\n   the number of consumed elements.\n\u003c/p\u003e\u003cp\u003eFails if the predicate return 0 or less, or if there is no more input.\n\u003c/p\u003e",
          "module": "Data.Sparser",
          "name": "splitP",
          "package": "sparser",
          "signature": "(s -\u003e [a] -\u003e Int) -\u003e SparserT s a [a]",
          "source": "src/Data-Sparser.html#splitP",
          "type": "function"
        },
        "index": {
          "description": "Consume one or more input elements The given function receives the entire remaining input and must return the number of consumed elements Fails if the predicate return or less or if there is no more input",
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "splitP",
          "normalized": "(a-\u003e[b]-\u003eInt)-\u003eSparserT a b[b]",
          "package": "sparser",
          "signature": "(s-\u003e[a]-\u003eInt)-\u003eSparserT s a[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:splitP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e&#160;Return the state as result.\n\u003c/p\u003e",
          "module": "Data.Sparser",
          "name": "stateP",
          "package": "sparser",
          "signature": "SparserT s a s",
          "source": "src/Data-Sparser.html#stateP",
          "type": "function"
        },
        "index": {
          "description": "Return the state as result",
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "stateP",
          "package": "sparser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:stateP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "string",
          "package": "sparser",
          "signature": "[a] -\u003e SparserT s a [a]",
          "source": "src/Data-Sparser.html#string",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "string",
          "normalized": "[a]-\u003eSparserT b a[a]",
          "package": "sparser",
          "signature": "[a]-\u003eSparserT s a[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:string"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "stringIf",
          "package": "sparser",
          "signature": "Int -\u003e ([a] -\u003e Bool) -\u003e SparserT s a [a]",
          "source": "src/Data-Sparser.html#stringIf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "stringIf",
          "normalized": "Int-\u003e([a]-\u003eBool)-\u003eSparserT b a[a]",
          "package": "sparser",
          "partial": "If",
          "signature": "Int-\u003e([a]-\u003eBool)-\u003eSparserT s a[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:stringIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "stringLiteral",
          "package": "sparser",
          "signature": "SparserT s Char String",
          "source": "src/Data-Sparser.html#stringLiteral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "stringLiteral",
          "package": "sparser",
          "partial": "Literal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:stringLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sparser",
          "name": "withState",
          "package": "sparser",
          "signature": "(s -\u003e t) -\u003e (t -\u003e s) -\u003e SparserT t a b -\u003e SparserT s a b",
          "source": "src/Data-Sparser.html#withState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sparser",
          "module": "Data.Sparser",
          "name": "withState",
          "normalized": "(a-\u003eb)-\u003e(b-\u003ea)-\u003eSparserT b c d-\u003eSparserT a c d",
          "package": "sparser",
          "partial": "State",
          "signature": "(s-\u003et)-\u003e(t-\u003es)-\u003eSparserT t a b-\u003eSparserT s a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:withState"
      }
    }
  ]
]