[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "toysolver"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType classes for lattices and boolean algebras.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Lattice.Boolean",
          "name": "Boolean",
          "package": "toysolver",
          "source": "src/Algebra-Lattice-Boolean.html",
          "type": "module"
        },
        "index": {
          "description": "Type classes for lattices and boolean algebras",
          "hierarchy": "Algebra Lattice Boolean",
          "module": "Algebra.Lattice.Boolean",
          "name": "Boolean",
          "package": "toysolver",
          "partial": "Boolean",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etypes that can be combined with boolean operations.\n\u003c/p\u003e",
          "module": "Algebra.Lattice.Boolean",
          "name": "Boolean",
          "package": "toysolver",
          "source": "src/Algebra-Lattice-Boolean.html#Boolean",
          "type": "class"
        },
        "index": {
          "description": "types that can be combined with boolean operations",
          "hierarchy": "Algebra Lattice Boolean",
          "module": "Algebra.Lattice.Boolean",
          "name": "Boolean",
          "package": "toysolver",
          "partial": "Boolean",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#t:Boolean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etypes that can be negated.\n\u003c/p\u003e",
          "module": "Algebra.Lattice.Boolean",
          "name": "Complement",
          "package": "toysolver",
          "source": "src/Algebra-Lattice-Boolean.html#Complement",
          "type": "class"
        },
        "index": {
          "description": "types that can be negated",
          "hierarchy": "Algebra Lattice Boolean",
          "module": "Algebra.Lattice.Boolean",
          "name": "Complement",
          "package": "toysolver",
          "partial": "Complement",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#t:Complement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ealias of \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Algebra.Lattice.Boolean",
          "name": "(.||.)",
          "package": "toysolver",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Lattice-Boolean.html#.%7C%7C.",
          "type": "function"
        },
        "index": {
          "description": "alias of join",
          "hierarchy": "Algebra Lattice Boolean",
          "module": "Algebra.Lattice.Boolean",
          "name": "(.||.) .||.",
          "normalized": "a-\u003ea-\u003ea",
          "package": "toysolver",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:.-124--124-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ealias of \u003ccode\u003e\u003ca\u003emeet\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Algebra.Lattice.Boolean",
          "name": "(.&&.)",
          "package": "toysolver",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Lattice-Boolean.html#.%26%26.",
          "type": "function"
        },
        "index": {
          "description": "alias of meet",
          "hierarchy": "Algebra Lattice Boolean",
          "module": "Algebra.Lattice.Boolean",
          "name": "(.&&.) .&&.",
          "normalized": "a-\u003ea-\u003ea",
          "package": "toysolver",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:.-38--38-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice.Boolean",
          "name": "(.=\u003e.)",
          "package": "toysolver",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Lattice-Boolean.html#.%3D%3E.",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Lattice Boolean",
          "module": "Algebra.Lattice.Boolean",
          "name": "(.=\u003e.) .=\u003e.",
          "normalized": "a-\u003ea-\u003ea",
          "package": "toysolver",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:.-61--62-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ealias of \u003ccode\u003e\u003ca\u003emeets\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Algebra.Lattice.Boolean",
          "name": "andB",
          "package": "toysolver",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Lattice-Boolean.html#andB",
          "type": "function"
        },
        "index": {
          "description": "alias of meets",
          "hierarchy": "Algebra Lattice Boolean",
          "module": "Algebra.Lattice.Boolean",
          "name": "andB",
          "normalized": "[a]-\u003ea",
          "package": "toysolver",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:andB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ealias of \u003ccode\u003e\u003ca\u003ebottom\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Algebra.Lattice.Boolean",
          "name": "false",
          "package": "toysolver",
          "signature": "a",
          "source": "src/Algebra-Lattice-Boolean.html#false",
          "type": "function"
        },
        "index": {
          "description": "alias of bottom",
          "hierarchy": "Algebra Lattice Boolean",
          "module": "Algebra.Lattice.Boolean",
          "name": "false",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:false"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice.Boolean",
          "name": "notB",
          "package": "toysolver",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Lattice-Boolean.html#notB",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Lattice Boolean",
          "module": "Algebra.Lattice.Boolean",
          "name": "notB",
          "normalized": "a-\u003ea",
          "package": "toysolver",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:notB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ealias of \u003ccode\u003e\u003ca\u003ejoins\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Algebra.Lattice.Boolean",
          "name": "orB",
          "package": "toysolver",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Lattice-Boolean.html#orB",
          "type": "function"
        },
        "index": {
          "description": "alias of joins",
          "hierarchy": "Algebra Lattice Boolean",
          "module": "Algebra.Lattice.Boolean",
          "name": "orB",
          "normalized": "[a]-\u003ea",
          "package": "toysolver",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:orB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ealias of \u003ccode\u003e\u003ca\u003etop\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Algebra.Lattice.Boolean",
          "name": "true",
          "package": "toysolver",
          "signature": "a",
          "source": "src/Algebra-Lattice-Boolean.html#true",
          "type": "function"
        },
        "index": {
          "description": "alias of top",
          "hierarchy": "Algebra Lattice Boolean",
          "module": "Algebra.Lattice.Boolean",
          "name": "true",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:true"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTightening variable bounds by constraint propagation.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algorithm.BoundsInference",
          "name": "BoundsInference",
          "package": "toysolver",
          "source": "src/Algorithm-BoundsInference.html",
          "type": "module"
        },
        "index": {
          "description": "Tightening variable bounds by constraint propagation",
          "hierarchy": "Algorithm BoundsInference",
          "module": "Algorithm.BoundsInference",
          "name": "BoundsInference",
          "package": "toysolver",
          "partial": "Bounds Inference",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-BoundsInference.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.BoundsInference",
          "name": "BoundsEnv",
          "package": "toysolver",
          "source": "src/Data-LA.html#BoundsEnv",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm BoundsInference",
          "module": "Algorithm.BoundsInference",
          "name": "BoundsEnv",
          "package": "toysolver",
          "partial": "Bounds Env",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-BoundsInference.html#t:BoundsEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecompute bounds for a \u003ccode\u003eExpr\u003c/code\u003e with respect to \u003ccode\u003eBoundsEnv\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Algorithm.BoundsInference\",\"Data.LA\"]",
          "name": "computeInterval",
          "package": "toysolver",
          "signature": "BoundsEnv r -\u003e Expr r -\u003e Interval r",
          "source": "src/Data-LA.html#computeInterval",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-BoundsInference.html#v:computeInterval\",\"http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:computeInterval\"]"
        },
        "index": {
          "description": "compute bounds for Expr with respect to BoundsEnv",
          "hierarchy": "Algorithm BoundsInference",
          "module": "Algorithm.BoundsInference",
          "name": "computeInterval",
          "normalized": "BoundsEnv a-\u003eExpr a-\u003eInterval a",
          "package": "toysolver",
          "partial": "Interval",
          "signature": "BoundsEnv r-\u003eExpr r-\u003eInterval r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-BoundsInference.html#v:computeInterval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etightening variable bounds by constraint propagation.\n\u003c/p\u003e",
          "module": "Algorithm.BoundsInference",
          "name": "inferBounds",
          "package": "toysolver",
          "signature": "BoundsEnv r-\u003e [Atom r]-\u003e VarSet-\u003e Int-\u003e BoundsEnv r",
          "type": "function"
        },
        "index": {
          "description": "tightening variable bounds by constraint propagation",
          "hierarchy": "Algorithm BoundsInference",
          "module": "Algorithm.BoundsInference",
          "name": "inferBounds",
          "normalized": "BoundsEnv a-\u003e[Atom a]-\u003eVarSet-\u003eInt-\u003eBoundsEnv a",
          "package": "toysolver",
          "partial": "Bounds",
          "signature": "BoundsEnv r-\u003e[Atom r]-\u003eVarSet-\u003eInt-\u003eBoundsEnv r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-BoundsInference.html#v:inferBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e  Christian Michaux and Adem Ozturk.\n    Quantifier Elimination following Muchnik\n    \u003ca\u003ehttps://math.umons.ac.be/preprints/src/Ozturk020411.pdf\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e  Arnab Bhattacharyya.\n    Something you should know about: Quantifier Elimination (Part I)\n    \u003ca\u003ehttp://cstheory.blogoverflow.com/2011/11/something-you-should-know-about-quantifier-elimination-part-i/\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e  Arnab Bhattacharyya.\n    Something you should know about: Quantifier Elimination (Part II)\n    \u003ca\u003ehttp://cstheory.blogoverflow.com/2012/02/something-you-should-know-about-quantifier-elimination-part-ii/\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Algorithm.CAD",
          "name": "CAD",
          "package": "toysolver",
          "source": "src/Algorithm-CAD.html",
          "type": "module"
        },
        "index": {
          "description": "References Christian Michaux and Adem Ozturk Quantifier Elimination following Muchnik https math.umons.ac.be preprints src Ozturk020411.pdf Arnab Bhattacharyya Something you should know about Quantifier Elimination Part http cstheory.blogoverflow.com something-you-should-know-about-quantifier-elimination-part-i Arnab Bhattacharyya Something you should know about Quantifier Elimination Part II http cstheory.blogoverflow.com something-you-should-know-about-quantifier-elimination-part-ii",
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "CAD",
          "package": "toysolver",
          "partial": "CAD",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CAD",
          "name": "Cell",
          "package": "toysolver",
          "source": "src/Algorithm-CAD.html#Cell",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "Cell",
          "package": "toysolver",
          "partial": "Cell",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#t:Cell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CAD",
          "name": "Model",
          "package": "toysolver",
          "source": "src/Algorithm-CAD.html#Model",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "Model",
          "package": "toysolver",
          "partial": "Model",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#t:Model"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CAD",
          "name": "Point",
          "package": "toysolver",
          "source": "src/Algorithm-CAD.html#Point",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "Point",
          "package": "toysolver",
          "partial": "Point",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#t:Point"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CAD",
          "name": "Interval",
          "package": "toysolver",
          "signature": "Interval (Point c) (Point c)",
          "source": "src/Algorithm-CAD.html#Cell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "Interval",
          "package": "toysolver",
          "partial": "Interval",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:Interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CAD",
          "name": "NegInf",
          "package": "toysolver",
          "signature": "NegInf",
          "source": "src/Algorithm-CAD.html#Point",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "NegInf",
          "package": "toysolver",
          "partial": "Neg Inf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:NegInf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CAD",
          "name": "Point",
          "package": "toysolver",
          "signature": "Point (Point c)",
          "source": "src/Algorithm-CAD.html#Cell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "Point",
          "package": "toysolver",
          "partial": "Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:Point"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CAD",
          "name": "PosInf",
          "package": "toysolver",
          "signature": "PosInf",
          "source": "src/Algorithm-CAD.html#Point",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "PosInf",
          "package": "toysolver",
          "partial": "Pos Inf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:PosInf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CAD",
          "name": "RootOf",
          "package": "toysolver",
          "signature": "RootOf (UPolynomial c) Int",
          "source": "src/Algorithm-CAD.html#Point",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "RootOf",
          "package": "toysolver",
          "partial": "Root Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:RootOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CAD",
          "name": "evalCell",
          "package": "toysolver",
          "signature": "Model v -\u003e Cell (Polynomial Rational v) -\u003e Cell Rational",
          "source": "src/Algorithm-CAD.html#evalCell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "evalCell",
          "normalized": "Model a-\u003eCell(Polynomial Rational a)-\u003eCell Rational",
          "package": "toysolver",
          "partial": "Cell",
          "signature": "Model v-\u003eCell(Polynomial Rational v)-\u003eCell Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:evalCell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CAD",
          "name": "evalPoint",
          "package": "toysolver",
          "signature": "Model v -\u003e Point (Polynomial Rational v) -\u003e Point Rational",
          "source": "src/Algorithm-CAD.html#evalPoint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "evalPoint",
          "normalized": "Model a-\u003ePoint(Polynomial Rational a)-\u003ePoint Rational",
          "package": "toysolver",
          "partial": "Point",
          "signature": "Model v-\u003ePoint(Polynomial Rational v)-\u003ePoint Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:evalPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CAD",
          "name": "findSample",
          "package": "toysolver",
          "signature": "Model v -\u003e Cell (Polynomial Rational v) -\u003e Maybe AReal",
          "source": "src/Algorithm-CAD.html#findSample",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "findSample",
          "normalized": "Model a-\u003eCell(Polynomial Rational a)-\u003eMaybe AReal",
          "package": "toysolver",
          "partial": "Sample",
          "signature": "Model v-\u003eCell(Polynomial Rational v)-\u003eMaybe AReal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:findSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CAD",
          "name": "project",
          "package": "toysolver",
          "signature": "[(UPolynomial (Polynomial Rational v), [Sign])] -\u003e [([(Polynomial Rational v, [Sign])], [Cell (Polynomial Rational v)])]",
          "source": "src/Algorithm-CAD.html#project",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "project",
          "normalized": "[(UPolynomial(Polynomial Rational a),[Sign])]-\u003e[([(Polynomial Rational a,[Sign])],[Cell(Polynomial Rational a)])]",
          "package": "toysolver",
          "signature": "[(UPolynomial(Polynomial Rational v),[Sign])]-\u003e[([(Polynomial Rational v,[Sign])],[Cell(Polynomial Rational v)])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:project"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CAD",
          "name": "solve",
          "package": "toysolver",
          "signature": "Set v -\u003e [Rel (Polynomial Rational v)] -\u003e Maybe (Model v)",
          "source": "src/Algorithm-CAD.html#solve",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "solve",
          "normalized": "Set a-\u003e[Rel(Polynomial Rational a)]-\u003eMaybe(Model a)",
          "package": "toysolver",
          "signature": "Set v-\u003e[Rel(Polynomial Rational v)]-\u003eMaybe(Model v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:solve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CAD",
          "name": "solve'",
          "package": "toysolver",
          "signature": "Set v -\u003e [(Polynomial Rational v, [Sign])] -\u003e Maybe (Model v)",
          "source": "src/Algorithm-CAD.html#solve%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CAD",
          "module": "Algorithm.CAD",
          "name": "solve'",
          "normalized": "Set a-\u003e[(Polynomial Rational a,[Sign])]-\u003eMaybe(Model a)",
          "package": "toysolver",
          "signature": "Set v-\u003e[(Polynomial Rational v,[Sign])]-\u003eMaybe(Model v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:solve-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e R. Nieuwenhuis and A. Oliveras, \u003ca\u003eFast congruence closure and extensions,\u003c/a\u003e\n   Information and Computation, vol. 205, no. 4, pp. 557-580, Apr. 2007.\n   \u003ca\u003ehttp://www.lsi.upc.edu/~oliveras/espai/papers/IC.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Algorithm.CongruenceClosure",
          "name": "CongruenceClosure",
          "package": "toysolver",
          "source": "src/Algorithm-CongruenceClosure.html",
          "type": "module"
        },
        "index": {
          "description": "References Nieuwenhuis and Oliveras Fast congruence closure and extensions Information and Computation vol no pp Apr http www.lsi.upc.edu oliveras espai papers IC.pdf",
          "hierarchy": "Algorithm CongruenceClosure",
          "module": "Algorithm.CongruenceClosure",
          "name": "CongruenceClosure",
          "package": "toysolver",
          "partial": "Congruence Closure",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CongruenceClosure",
          "name": "FlatTerm",
          "package": "toysolver",
          "source": "src/Algorithm-CongruenceClosure.html#FlatTerm",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algorithm CongruenceClosure",
          "module": "Algorithm.CongruenceClosure",
          "name": "FlatTerm",
          "package": "toysolver",
          "partial": "Flat Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#t:FlatTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CongruenceClosure",
          "name": "Solver",
          "package": "toysolver",
          "source": "src/Algorithm-CongruenceClosure.html#Solver",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algorithm CongruenceClosure",
          "module": "Algorithm.CongruenceClosure",
          "name": "Solver",
          "package": "toysolver",
          "partial": "Solver",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#t:Solver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CongruenceClosure",
          "name": "Var",
          "package": "toysolver",
          "source": "src/Algorithm-CongruenceClosure.html#Var",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm CongruenceClosure",
          "module": "Algorithm.CongruenceClosure",
          "name": "Var",
          "package": "toysolver",
          "partial": "Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CongruenceClosure",
          "name": "FTApp",
          "package": "toysolver",
          "signature": "FTApp Var Var",
          "source": "src/Algorithm-CongruenceClosure.html#FlatTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CongruenceClosure",
          "module": "Algorithm.CongruenceClosure",
          "name": "FTApp",
          "package": "toysolver",
          "partial": "FTApp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#v:FTApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CongruenceClosure",
          "name": "FTConst",
          "package": "toysolver",
          "signature": "FTConst Var",
          "source": "src/Algorithm-CongruenceClosure.html#FlatTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CongruenceClosure",
          "module": "Algorithm.CongruenceClosure",
          "name": "FTConst",
          "package": "toysolver",
          "partial": "FTConst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#v:FTConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CongruenceClosure",
          "name": "areCongruent",
          "package": "toysolver",
          "signature": "Solver -\u003e FlatTerm -\u003e FlatTerm -\u003e IO Bool",
          "source": "src/Algorithm-CongruenceClosure.html#areCongruent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CongruenceClosure",
          "module": "Algorithm.CongruenceClosure",
          "name": "areCongruent",
          "normalized": "Solver-\u003eFlatTerm-\u003eFlatTerm-\u003eIO Bool",
          "package": "toysolver",
          "partial": "Congruent",
          "signature": "Solver-\u003eFlatTerm-\u003eFlatTerm-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#v:areCongruent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CongruenceClosure",
          "name": "merge",
          "package": "toysolver",
          "signature": "Solver -\u003e (FlatTerm, Var) -\u003e IO ()",
          "source": "src/Algorithm-CongruenceClosure.html#merge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CongruenceClosure",
          "module": "Algorithm.CongruenceClosure",
          "name": "merge",
          "normalized": "Solver-\u003e(FlatTerm,Var)-\u003eIO()",
          "package": "toysolver",
          "signature": "Solver-\u003e(FlatTerm,Var)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#v:merge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CongruenceClosure",
          "name": "newSolver",
          "package": "toysolver",
          "signature": "IO Solver",
          "source": "src/Algorithm-CongruenceClosure.html#newSolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CongruenceClosure",
          "module": "Algorithm.CongruenceClosure",
          "name": "newSolver",
          "package": "toysolver",
          "partial": "Solver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#v:newSolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.CongruenceClosure",
          "name": "newVar",
          "package": "toysolver",
          "signature": "Solver -\u003e IO Var",
          "source": "src/Algorithm-CongruenceClosure.html#newVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm CongruenceClosure",
          "module": "Algorithm.CongruenceClosure",
          "name": "newVar",
          "normalized": "Solver-\u003eIO Var",
          "package": "toysolver",
          "partial": "Var",
          "signature": "Solver-\u003eIO Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#v:newVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e P. Conti and C. Traverso, \u003ca\u003eBuchberger algorithm and integer programming,\u003c/a\u003e\n   Applied Algebra, Algebraic Algorithms and Error-Correcting Codes,\n   Lecture Notes in Computer Science Volume 539, 1991, pp 130-139\n   \u003ca\u003ehttp://dx.doi.org/10.1007/3-540-54522-0_102\u003c/a\u003e\n   \u003ca\u003ehttp://posso.dm.unipi.it/users/traverso/conti-traverso-ip.ps\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e IKEGAMI Daisuke, \u003ca\u003e&#25968;&#21015;&#12392;&#22810;&#38917;&#24335;&#12398;&#24859;&#12375;&#12356;&#38306;&#20418;,\u003c/a\u003e 2011,\n   \u003ca\u003ehttp://madscientist.jp/~ikegami/articles/IntroSequencePolynomial.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e &#20234;&#34276;&#38597;&#21490;, , &#24179;&#26519; &#38534;&#19968;, \u003ca\u003e&#25972;&#25968;&#35336;&#30011;&#21839;&#38988;&#12398;&#12383;&#12417;&#12398; b-Gr&#246;bner &#22522;&#24213;&#22793;&#25563;&#12450;&#12523;&#12468;&#12522;&#12474;&#12512;,\u003c/a\u003e\n   \u003ca\u003ehttp://www.kurims.kyoto-u.ac.jp/~kyodo/kokyuroku/contents/pdf/1295-27.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Algorithm.ContiTraverso",
          "name": "ContiTraverso",
          "package": "toysolver",
          "source": "src/Algorithm-ContiTraverso.html",
          "type": "module"
        },
        "index": {
          "description": "References Conti and Traverso Buchberger algorithm and integer programming Applied Algebra Algebraic Algorithms and Error-Correcting Codes Lecture Notes in Computer Science Volume pp http dx.doi.org http posso.dm.unipi.it users traverso conti-traverso-ip.ps IKEGAMI Daisuke http madscientist.jp ikegami articles IntroSequencePolynomial.html b-Gr bner http www.kurims.kyoto-u.ac.jp kyodo kokyuroku contents pdf pdf",
          "hierarchy": "Algorithm ContiTraverso",
          "module": "Algorithm.ContiTraverso",
          "name": "ContiTraverso",
          "package": "toysolver",
          "partial": "Conti Traverso",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-ContiTraverso.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.ContiTraverso",
          "name": "solve",
          "package": "toysolver",
          "signature": "MonomialOrder Var -\u003e VarSet -\u003e OptDir -\u003e Expr Rational -\u003e [Atom Rational] -\u003e Maybe (Model Integer)",
          "source": "src/Algorithm-ContiTraverso.html#solve",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm ContiTraverso",
          "module": "Algorithm.ContiTraverso",
          "name": "solve",
          "normalized": "MonomialOrder Var-\u003eVarSet-\u003eOptDir-\u003eExpr Rational-\u003e[Atom Rational]-\u003eMaybe(Model Integer)",
          "package": "toysolver",
          "signature": "MonomialOrder Var-\u003eVarSet-\u003eOptDir-\u003eExpr Rational-\u003e[Atom Rational]-\u003eMaybe(Model Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-ContiTraverso.html#v:solve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.ContiTraverso",
          "name": "solve'",
          "package": "toysolver",
          "signature": "MonomialOrder Var -\u003e VarSet -\u003e Expr Integer -\u003e [(Expr Integer, Integer)] -\u003e Maybe (Model Integer)",
          "source": "src/Algorithm-ContiTraverso.html#solve%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm ContiTraverso",
          "module": "Algorithm.ContiTraverso",
          "name": "solve'",
          "normalized": "MonomialOrder Var-\u003eVarSet-\u003eExpr Integer-\u003e[(Expr Integer,Integer)]-\u003eMaybe(Model Integer)",
          "package": "toysolver",
          "signature": "MonomialOrder Var-\u003eVarSet-\u003eExpr Integer-\u003e[(Expr Integer,Integer)]-\u003eMaybe(Model Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-ContiTraverso.html#v:solve-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNaive implementation of Cooper's algorithm\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://hagi.is.s.u-tokyo.ac.jp/pub/staff/hagiya/kougiroku/ronri/5.txt\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://www.cs.cmu.edu/~emc/spring06/home1_files/Presburger%20Arithmetic.ppt\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSee also:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://hackage.haskell.org/package/presburger\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Algorithm.Cooper.Core",
          "name": "Core",
          "package": "toysolver",
          "source": "src/Algorithm-Cooper-Core.html",
          "type": "module"
        },
        "index": {
          "description": "Naive implementation of Cooper algorithm Reference http hagi.is.s.u-tokyo.ac.jp pub staff hagiya kougiroku ronri txt http www.cs.cmu.edu emc spring06 home1 files Presburger Arithmetic.ppt See also http hackage.haskell.org package presburger",
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "Core",
          "package": "toysolver",
          "partial": "Core",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLinear arithmetic expression over integers.\n\u003c/p\u003e",
          "module": "Algorithm.Cooper.Core",
          "name": "ExprZ",
          "package": "toysolver",
          "source": "src/Algorithm-Cooper-Core.html#ExprZ",
          "type": "type"
        },
        "index": {
          "description": "Linear arithmetic expression over integers",
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "ExprZ",
          "package": "toysolver",
          "partial": "Expr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#t:ExprZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLiteral\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003ePos e\u003c/code\u003e means \u003ccode\u003ee \u003e 0\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eDivisible True d e\u003c/code\u003e means \u003ccode\u003ee\u003c/code\u003e can be divided by \u003ccode\u003ed\u003c/code\u003e (i.e. \u003ccode\u003ed|e\u003c/code\u003e)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eDivisible False d e\u003c/code\u003e means \u003ccode\u003ee\u003c/code\u003e can not be divided by \u003ccode\u003ed\u003c/code\u003e (i.e. \u003ccode\u003e&#172;(d|e)\u003c/code\u003e)\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Algorithm.Cooper.Core",
          "name": "Lit",
          "package": "toysolver",
          "source": "src/Algorithm-Cooper-Core.html#Lit",
          "type": "data"
        },
        "index": {
          "description": "Literal Pos means Divisible True means can be divided by i.e Divisible False means can not be divided by i.e",
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "Lit",
          "package": "toysolver",
          "partial": "Lit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#t:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003equantifier-free negation normal form\n\u003c/p\u003e",
          "module": "Algorithm.Cooper.Core",
          "name": "QFFormula",
          "package": "toysolver",
          "source": "src/Algorithm-Cooper-Core.html#QFFormula",
          "type": "data"
        },
        "index": {
          "description": "quantifier-free negation normal form",
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "QFFormula",
          "package": "toysolver",
          "partial": "QFFormula",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#t:QFFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "(.|.)",
          "package": "toysolver",
          "signature": "Integer -\u003e ExprZ -\u003e QFFormula",
          "source": "src/Algorithm-Cooper-Core.html#.%7C.",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:.-124-.\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:.-124-.\"]"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "(.|.) .|.",
          "normalized": "Integer-\u003eExprZ-\u003eQFFormula",
          "package": "toysolver",
          "signature": "Integer-\u003eExprZ-\u003eQFFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:.-124-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "And'",
          "package": "toysolver",
          "signature": "And' QFFormula QFFormula",
          "source": "src/Algorithm-Cooper-Core.html#QFFormula",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:And-39-\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:And-39-\"]"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "And'",
          "package": "toysolver",
          "partial": "And'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:And-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "Divisible",
          "package": "toysolver",
          "signature": "Divisible Bool Integer ExprZ",
          "source": "src/Algorithm-Cooper-Core.html#Lit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:Divisible\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:Divisible\"]"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "Divisible",
          "package": "toysolver",
          "partial": "Divisible",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:Divisible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "F'",
          "package": "toysolver",
          "signature": "F'",
          "source": "src/Algorithm-Cooper-Core.html#QFFormula",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:F-39-\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:F-39-\"]"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "F'",
          "package": "toysolver",
          "partial": "F'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:F-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "Lit",
          "package": "toysolver",
          "signature": "Lit Lit",
          "source": "src/Algorithm-Cooper-Core.html#QFFormula",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:Lit\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:Lit\"]"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "Lit",
          "package": "toysolver",
          "partial": "Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "Or'",
          "package": "toysolver",
          "signature": "Or' QFFormula QFFormula",
          "source": "src/Algorithm-Cooper-Core.html#QFFormula",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:Or-39-\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:Or-39-\"]"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "Or'",
          "package": "toysolver",
          "partial": "Or'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:Or-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "Pos",
          "package": "toysolver",
          "signature": "Pos ExprZ",
          "source": "src/Algorithm-Cooper-Core.html#Lit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:Pos\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:Pos\"]"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "Pos",
          "package": "toysolver",
          "partial": "Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:Pos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "T'",
          "package": "toysolver",
          "signature": "T'",
          "source": "src/Algorithm-Cooper-Core.html#QFFormula",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:T-39-\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:T-39-\"]"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "T'",
          "package": "toysolver",
          "partial": "T'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:T-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Cooper.Core",
          "name": "evalLit",
          "package": "toysolver",
          "signature": "Model Integer -\u003e Lit -\u003e Bool",
          "source": "src/Algorithm-Cooper-Core.html#evalLit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "evalLit",
          "normalized": "Model Integer-\u003eLit-\u003eBool",
          "package": "toysolver",
          "partial": "Lit",
          "signature": "Model Integer-\u003eLit-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:evalLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Cooper.Core",
          "name": "evalQFFormula",
          "package": "toysolver",
          "signature": "Model Integer -\u003e QFFormula -\u003e Bool",
          "source": "src/Algorithm-Cooper-Core.html#evalQFFormula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "evalQFFormula",
          "normalized": "Model Integer-\u003eQFFormula-\u003eBool",
          "package": "toysolver",
          "partial": "QFFormula",
          "signature": "Model Integer-\u003eQFFormula-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:evalQFFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "fromLAAtom",
          "package": "toysolver",
          "signature": "Atom Rational -\u003e QFFormula",
          "source": "src/Algorithm-Cooper-Core.html#fromLAAtom",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:fromLAAtom\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:fromLAAtom\"]"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "fromLAAtom",
          "normalized": "Atom Rational-\u003eQFFormula",
          "package": "toysolver",
          "partial": "LAAtom",
          "signature": "Atom Rational-\u003eQFFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:fromLAAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "project",
          "package": "toysolver",
          "signature": "Var -\u003e QFFormula -\u003e (QFFormula, Model Integer -\u003e Model Integer)",
          "source": "src/Algorithm-Cooper-Core.html#project",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:project\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:project\"]"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "project",
          "normalized": "Var-\u003eQFFormula-\u003e(QFFormula,Model Integer-\u003eModel Integer)",
          "package": "toysolver",
          "signature": "Var-\u003eQFFormula-\u003e(QFFormula,Model Integer-\u003eModel Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:project"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "projectCases",
          "package": "toysolver",
          "signature": "Var -\u003e QFFormula -\u003e [(QFFormula, Model Integer -\u003e Model Integer)]",
          "source": "src/Algorithm-Cooper-Core.html#projectCases",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:projectCases\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:projectCases\"]"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "projectCases",
          "normalized": "Var-\u003eQFFormula-\u003e[(QFFormula,Model Integer-\u003eModel Integer)]",
          "package": "toysolver",
          "partial": "Cases",
          "signature": "Var-\u003eQFFormula-\u003e[(QFFormula,Model Integer-\u003eModel Integer)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:projectCases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "projectCasesN",
          "package": "toysolver",
          "signature": "VarSet -\u003e QFFormula -\u003e [(QFFormula, Model Integer -\u003e Model Integer)]",
          "source": "src/Algorithm-Cooper-Core.html#projectCasesN",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:projectCasesN\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:projectCasesN\"]"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "projectCasesN",
          "normalized": "VarSet-\u003eQFFormula-\u003e[(QFFormula,Model Integer-\u003eModel Integer)]",
          "package": "toysolver",
          "partial": "Cases",
          "signature": "VarSet-\u003eQFFormula-\u003e[(QFFormula,Model Integer-\u003eModel Integer)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:projectCasesN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Cooper.Core",
          "name": "projectN",
          "package": "toysolver",
          "signature": "VarSet -\u003e QFFormula -\u003e (QFFormula, Model Integer -\u003e Model Integer)",
          "source": "src/Algorithm-Cooper-Core.html#projectN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "projectN",
          "normalized": "VarSet-\u003eQFFormula-\u003e(QFFormula,Model Integer-\u003eModel Integer)",
          "package": "toysolver",
          "signature": "VarSet-\u003eQFFormula-\u003e(QFFormula,Model Integer-\u003eModel Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:projectN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esolve a (open) quantifier-free formula\n\u003c/p\u003e",
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "solve",
          "package": "toysolver",
          "signature": "VarSet -\u003e [Atom Rational] -\u003e Maybe (Model Integer)",
          "source": "src/Algorithm-Cooper-Core.html#solve",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:solve\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:solve\"]"
        },
        "index": {
          "description": "solve open quantifier-free formula",
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "solve",
          "normalized": "VarSet-\u003e[Atom Rational]-\u003eMaybe(Model Integer)",
          "package": "toysolver",
          "signature": "VarSet-\u003e[Atom Rational]-\u003eMaybe(Model Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:solve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "solveQFFormula",
          "package": "toysolver",
          "signature": "VarSet -\u003e QFFormula -\u003e Maybe (Model Integer)",
          "source": "src/Algorithm-Cooper-Core.html#solveQFFormula",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:solveQFFormula\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:solveQFFormula\"]"
        },
        "index": {
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "solveQFFormula",
          "normalized": "VarSet-\u003eQFFormula-\u003eMaybe(Model Integer)",
          "package": "toysolver",
          "partial": "QFFormula",
          "signature": "VarSet-\u003eQFFormula-\u003eMaybe(Model Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:solveQFFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esolve a (open) quantifier-free formula\n\u003c/p\u003e",
          "module": "[\"Algorithm.Cooper.Core\",\"Algorithm.Cooper\"]",
          "name": "solveQFLA",
          "package": "toysolver",
          "signature": "VarSet -\u003e [Atom Rational] -\u003e VarSet -\u003e Maybe (Model Rational)",
          "source": "src/Algorithm-Cooper-Core.html#solveQFLA",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:solveQFLA\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:solveQFLA\"]"
        },
        "index": {
          "description": "solve open quantifier-free formula",
          "hierarchy": "Algorithm Cooper Core",
          "module": "Algorithm.Cooper.Core",
          "name": "solveQFLA",
          "normalized": "VarSet-\u003e[Atom Rational]-\u003eVarSet-\u003eMaybe(Model Rational)",
          "package": "toysolver",
          "partial": "QFLA",
          "signature": "VarSet-\u003e[Atom Rational]-\u003eVarSet-\u003eMaybe(Model Rational)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:solveQFLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Cooper.FOL",
          "name": "FOL",
          "package": "toysolver",
          "source": "src/Algorithm-Cooper-FOL.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algorithm Cooper FOL",
          "module": "Algorithm.Cooper.FOL",
          "name": "FOL",
          "package": "toysolver",
          "partial": "FOL",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-FOL.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eeliminate quantifiers and returns equivalent quantifier-free formula.\n\u003c/p\u003e",
          "module": "[\"Algorithm.Cooper.FOL\",\"Algorithm.Cooper\"]",
          "name": "eliminateQuantifiers",
          "package": "toysolver",
          "signature": "Formula (Atom Rational) -\u003e Maybe QFFormula",
          "source": "src/Algorithm-Cooper-FOL.html#eliminateQuantifiers",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-FOL.html#v:eliminateQuantifiers\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:eliminateQuantifiers\"]"
        },
        "index": {
          "description": "eliminate quantifiers and returns equivalent quantifier-free formula",
          "hierarchy": "Algorithm Cooper FOL",
          "module": "Algorithm.Cooper.FOL",
          "name": "eliminateQuantifiers",
          "normalized": "Formula(Atom Rational)-\u003eMaybe QFFormula",
          "package": "toysolver",
          "partial": "Quantifiers",
          "signature": "Formula(Atom Rational)-\u003eMaybe QFFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-FOL.html#v:eliminateQuantifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Cooper.FOL\",\"Algorithm.Cooper\"]",
          "name": "solveFormula",
          "package": "toysolver",
          "signature": "VarSet -\u003e Formula (Atom Rational) -\u003e SatResult Integer",
          "source": "src/Algorithm-Cooper-FOL.html#solveFormula",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-FOL.html#v:solveFormula\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:solveFormula\"]"
        },
        "index": {
          "hierarchy": "Algorithm Cooper FOL",
          "module": "Algorithm.Cooper.FOL",
          "name": "solveFormula",
          "normalized": "VarSet-\u003eFormula(Atom Rational)-\u003eSatResult Integer",
          "package": "toysolver",
          "partial": "Formula",
          "signature": "VarSet-\u003eFormula(Atom Rational)-\u003eSatResult Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-FOL.html#v:solveFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNaive implementation of Cooper's algorithm\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://hagi.is.s.u-tokyo.ac.jp/pub/staff/hagiya/kougiroku/ronri/5.txt\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://www.cs.cmu.edu/~emc/spring06/home1_files/Presburger%20Arithmetic.ppt\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSee also:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://hackage.haskell.org/package/presburger\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Algorithm.Cooper",
          "name": "Cooper",
          "package": "toysolver",
          "source": "src/Algorithm-Cooper.html",
          "type": "module"
        },
        "index": {
          "description": "Naive implementation of Cooper algorithm Reference http hagi.is.s.u-tokyo.ac.jp pub staff hagiya kougiroku ronri txt http www.cs.cmu.edu emc spring06 home1 files Presburger Arithmetic.ppt See also http hackage.haskell.org package presburger",
          "hierarchy": "Algorithm Cooper",
          "module": "Algorithm.Cooper",
          "name": "Cooper",
          "package": "toysolver",
          "partial": "Cooper",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLinear arithmetic expression over integers.\n\u003c/p\u003e",
          "module": "Algorithm.Cooper",
          "name": "ExprZ",
          "package": "toysolver",
          "source": "src/Algorithm-Cooper-Core.html#ExprZ",
          "type": "type"
        },
        "index": {
          "description": "Linear arithmetic expression over integers",
          "hierarchy": "Algorithm Cooper",
          "module": "Algorithm.Cooper",
          "name": "ExprZ",
          "package": "toysolver",
          "partial": "Expr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#t:ExprZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLiteral\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003ePos e\u003c/code\u003e means \u003ccode\u003ee \u003e 0\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eDivisible True d e\u003c/code\u003e means \u003ccode\u003ee\u003c/code\u003e can be divided by \u003ccode\u003ed\u003c/code\u003e (i.e. \u003ccode\u003ed|e\u003c/code\u003e)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eDivisible False d e\u003c/code\u003e means \u003ccode\u003ee\u003c/code\u003e can not be divided by \u003ccode\u003ed\u003c/code\u003e (i.e. \u003ccode\u003e&#172;(d|e)\u003c/code\u003e)\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Algorithm.Cooper",
          "name": "Lit",
          "package": "toysolver",
          "source": "src/Algorithm-Cooper-Core.html#Lit",
          "type": "data"
        },
        "index": {
          "description": "Literal Pos means Divisible True means can be divided by i.e Divisible False means can not be divided by i.e",
          "hierarchy": "Algorithm Cooper",
          "module": "Algorithm.Cooper",
          "name": "Lit",
          "package": "toysolver",
          "partial": "Lit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#t:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003equantifier-free negation normal form\n\u003c/p\u003e",
          "module": "Algorithm.Cooper",
          "name": "QFFormula",
          "package": "toysolver",
          "source": "src/Algorithm-Cooper-Core.html#QFFormula",
          "type": "data"
        },
        "index": {
          "description": "quantifier-free negation normal form",
          "hierarchy": "Algorithm Cooper",
          "module": "Algorithm.Cooper",
          "name": "QFFormula",
          "package": "toysolver",
          "partial": "QFFormula",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#t:QFFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA simple model finder.\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Koen Claessen and Niklas S&#246;rensson.\n   New Techniques that Improve MACE-style Finite Model Finding.\n   CADE-19. 2003.\n   \u003ca\u003ehttp://www.cs.miami.edu/~geoff/Conferences/CADE/Archive/CADE-19/WS4/04.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Algorithm.FOLModelFinder",
          "name": "FOLModelFinder",
          "package": "toysolver",
          "source": "src/Algorithm-FOLModelFinder.html",
          "type": "module"
        },
        "index": {
          "description": "simple model finder References Koen Claessen and Niklas rensson New Techniques that Improve MACE-style Finite Model Finding CADE-19 http www.cs.miami.edu geoff Conferences CADE Archive CADE-19 WS4 pdf",
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "FOLModelFinder",
          "package": "toysolver",
          "partial": "FOLModel Finder",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Atom",
          "package": "toysolver",
          "source": "src/Algorithm-FOLModelFinder.html#Atom",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Atom",
          "package": "toysolver",
          "partial": "Atom",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Atom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Clause",
          "package": "toysolver",
          "source": "src/Algorithm-FOLModelFinder.html#Clause",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Clause",
          "package": "toysolver",
          "partial": "Clause",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Clause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eElement of model.\n\u003c/p\u003e",
          "module": "Algorithm.FOLModelFinder",
          "name": "Entity",
          "package": "toysolver",
          "source": "src/Algorithm-FOLModelFinder.html#Entity",
          "type": "type"
        },
        "index": {
          "description": "Element of model",
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Entity",
          "package": "toysolver",
          "partial": "Entity",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Entity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction Symbol\n\u003c/p\u003e",
          "module": "Algorithm.FOLModelFinder",
          "name": "FSym",
          "package": "toysolver",
          "source": "src/Algorithm-FOLModelFinder.html#FSym",
          "type": "type"
        },
        "index": {
          "description": "Function Symbol",
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "FSym",
          "package": "toysolver",
          "partial": "FSym",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:FSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Formula",
          "package": "toysolver",
          "source": "src/Algorithm-FOLModelFinder.html#Formula",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Formula",
          "package": "toysolver",
          "partial": "Formula",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Formula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "GenFormula",
          "package": "toysolver",
          "source": "src/Algorithm-FOLModelFinder.html#GenFormula",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "GenFormula",
          "package": "toysolver",
          "partial": "Gen Formula",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:GenFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized literal type parameterized by atom type\n\u003c/p\u003e",
          "module": "Algorithm.FOLModelFinder",
          "name": "GenLit",
          "package": "toysolver",
          "source": "src/Algorithm-FOLModelFinder.html#GenLit",
          "type": "data"
        },
        "index": {
          "description": "Generalized literal type parameterized by atom type",
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "GenLit",
          "package": "toysolver",
          "partial": "Gen Lit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:GenLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Lit",
          "package": "toysolver",
          "source": "src/Algorithm-FOLModelFinder.html#Lit",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Lit",
          "package": "toysolver",
          "partial": "Lit",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Model",
          "package": "toysolver",
          "source": "src/Algorithm-FOLModelFinder.html#Model",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Model",
          "package": "toysolver",
          "partial": "Model",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Model"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePredicate Symbol\n\u003c/p\u003e",
          "module": "Algorithm.FOLModelFinder",
          "name": "PSym",
          "package": "toysolver",
          "source": "src/Algorithm-FOLModelFinder.html#PSym",
          "type": "type"
        },
        "index": {
          "description": "Predicate Symbol",
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "PSym",
          "package": "toysolver",
          "partial": "PSym",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:PSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTerm\n\u003c/p\u003e",
          "module": "Algorithm.FOLModelFinder",
          "name": "Term",
          "package": "toysolver",
          "source": "src/Algorithm-FOLModelFinder.html#Term",
          "type": "data"
        },
        "index": {
          "description": "Term",
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Term",
          "package": "toysolver",
          "partial": "Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariable\n\u003c/p\u003e",
          "module": "Algorithm.FOLModelFinder",
          "name": "Var",
          "package": "toysolver",
          "source": "src/Algorithm-FOLModelFinder.html#Var",
          "type": "type"
        },
        "index": {
          "description": "Variable",
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Var",
          "package": "toysolver",
          "partial": "Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "And",
          "package": "toysolver",
          "signature": "And (GenFormula a) (GenFormula a)",
          "source": "src/Algorithm-FOLModelFinder.html#GenFormula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "And",
          "package": "toysolver",
          "partial": "And",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:And"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Atom",
          "package": "toysolver",
          "signature": "Atom a",
          "source": "src/Algorithm-FOLModelFinder.html#GenFormula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Atom",
          "package": "toysolver",
          "partial": "Atom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Atom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Equiv",
          "package": "toysolver",
          "signature": "Equiv (GenFormula a) (GenFormula a)",
          "source": "src/Algorithm-FOLModelFinder.html#GenFormula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Equiv",
          "package": "toysolver",
          "partial": "Equiv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Equiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Exists",
          "package": "toysolver",
          "signature": "Exists Var (GenFormula a)",
          "source": "src/Algorithm-FOLModelFinder.html#GenFormula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Exists",
          "package": "toysolver",
          "partial": "Exists",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Exists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "F",
          "package": "toysolver",
          "signature": "F",
          "source": "src/Algorithm-FOLModelFinder.html#GenFormula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "F",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:F"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Forall",
          "package": "toysolver",
          "signature": "Forall Var (GenFormula a)",
          "source": "src/Algorithm-FOLModelFinder.html#GenFormula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Forall",
          "package": "toysolver",
          "partial": "Forall",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Forall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Imply",
          "package": "toysolver",
          "signature": "Imply (GenFormula a) (GenFormula a)",
          "source": "src/Algorithm-FOLModelFinder.html#GenFormula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Imply",
          "package": "toysolver",
          "partial": "Imply",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Imply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Model",
          "package": "toysolver",
          "signature": "Model",
          "source": "src/Algorithm-FOLModelFinder.html#Model",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Model",
          "package": "toysolver",
          "partial": "Model",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Model"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Neg",
          "package": "toysolver",
          "signature": "Neg a",
          "source": "src/Algorithm-FOLModelFinder.html#GenLit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Neg",
          "package": "toysolver",
          "partial": "Neg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Neg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Not",
          "package": "toysolver",
          "signature": "Not (GenFormula a)",
          "source": "src/Algorithm-FOLModelFinder.html#GenFormula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Not",
          "package": "toysolver",
          "partial": "Not",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Or",
          "package": "toysolver",
          "signature": "Or (GenFormula a) (GenFormula a)",
          "source": "src/Algorithm-FOLModelFinder.html#GenFormula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Or",
          "package": "toysolver",
          "partial": "Or",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "PApp",
          "package": "toysolver",
          "signature": "PApp PSym [Term]",
          "source": "src/Algorithm-FOLModelFinder.html#Atom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "PApp",
          "normalized": "PApp PSym[Term]",
          "package": "toysolver",
          "partial": "PApp",
          "signature": "PApp PSym[Term]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:PApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "Pos",
          "package": "toysolver",
          "signature": "Pos a",
          "source": "src/Algorithm-FOLModelFinder.html#GenLit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "Pos",
          "package": "toysolver",
          "partial": "Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Pos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "T",
          "package": "toysolver",
          "signature": "T",
          "source": "src/Algorithm-FOLModelFinder.html#GenFormula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "T",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "TmApp",
          "package": "toysolver",
          "signature": "TmApp FSym [Term]",
          "source": "src/Algorithm-FOLModelFinder.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "TmApp",
          "normalized": "TmApp FSym[Term]",
          "package": "toysolver",
          "partial": "Tm App",
          "signature": "TmApp FSym[Term]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:TmApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "TmVar",
          "package": "toysolver",
          "signature": "TmVar Var",
          "source": "src/Algorithm-FOLModelFinder.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "TmVar",
          "package": "toysolver",
          "partial": "Tm Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:TmVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "findModel",
          "package": "toysolver",
          "signature": "Int -\u003e [Clause] -\u003e IO (Maybe Model)",
          "source": "src/Algorithm-FOLModelFinder.html#findModel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "findModel",
          "normalized": "Int-\u003e[Clause]-\u003eIO(Maybe Model)",
          "package": "toysolver",
          "partial": "Model",
          "signature": "Int-\u003e[Clause]-\u003eIO(Maybe Model)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:findModel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "mFunctions",
          "package": "toysolver",
          "signature": "Map FSym [([Entity], Entity)]",
          "source": "src/Algorithm-FOLModelFinder.html#Model",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "mFunctions",
          "normalized": "Map FSym[([Entity],Entity)]",
          "package": "toysolver",
          "partial": "Functions",
          "signature": "Map FSym[([Entity],Entity)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:mFunctions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "mRelations",
          "package": "toysolver",
          "signature": "Map PSym [[Entity]]",
          "source": "src/Algorithm-FOLModelFinder.html#Model",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "mRelations",
          "normalized": "Map PSym[[Entity]]",
          "package": "toysolver",
          "partial": "Relations",
          "signature": "Map PSym[[Entity]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:mRelations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "mUniverse",
          "package": "toysolver",
          "signature": "[Entity]",
          "source": "src/Algorithm-FOLModelFinder.html#Model",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "mUniverse",
          "normalized": "[Entity]",
          "package": "toysolver",
          "partial": "Universe",
          "signature": "[Entity]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:mUniverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eprint entity\n\u003c/p\u003e",
          "module": "Algorithm.FOLModelFinder",
          "name": "showEntity",
          "package": "toysolver",
          "signature": "Entity -\u003e String",
          "source": "src/Algorithm-FOLModelFinder.html#showEntity",
          "type": "function"
        },
        "index": {
          "description": "print entity",
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "showEntity",
          "normalized": "Entity-\u003eString",
          "package": "toysolver",
          "partial": "Entity",
          "signature": "Entity-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:showEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FOLModelFinder",
          "name": "showModel",
          "package": "toysolver",
          "signature": "Model -\u003e [String]",
          "source": "src/Algorithm-FOLModelFinder.html#showModel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "showModel",
          "normalized": "Model-\u003e[String]",
          "package": "toysolver",
          "partial": "Model",
          "signature": "Model-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:showModel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enormalize a formula into a skolem normal form.\n\u003c/p\u003e\u003cp\u003eTODO:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Tseitin encoding\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Algorithm.FOLModelFinder",
          "name": "toSkolemNF",
          "package": "toysolver",
          "signature": "(String -\u003e Int -\u003e m FSym) -\u003e Formula -\u003e m [Clause]",
          "source": "src/Algorithm-FOLModelFinder.html#toSkolemNF",
          "type": "function"
        },
        "index": {
          "description": "normalize formula into skolem normal form TODO Tseitin encoding",
          "hierarchy": "Algorithm FOLModelFinder",
          "module": "Algorithm.FOLModelFinder",
          "name": "toSkolemNF",
          "normalized": "(String-\u003eInt-\u003ea FSym)-\u003eFormula-\u003ea[Clause]",
          "package": "toysolver",
          "partial": "Skolem NF",
          "signature": "(String-\u003eInt-\u003em FSym)-\u003eFormula-\u003em[Clause]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:toSkolemNF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNa&#239;ve implementation of Fourier-Motzkin Variable Elimination\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://users.cecs.anu.edu.au/~michaeln/pubs/arithmetic-dps.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "Core",
          "package": "toysolver",
          "source": "src/Algorithm-FourierMotzkin-Core.html",
          "type": "module"
        },
        "index": {
          "description": "Na ve implementation of Fourier-Motzkin Variable Elimination Reference http users.cecs.anu.edu.au michaeln pubs arithmetic-dps.pdf",
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "Core",
          "package": "toysolver",
          "partial": "Core",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "ExprZ",
          "package": "toysolver",
          "source": "src/Algorithm-FourierMotzkin-Core.html#ExprZ",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "ExprZ",
          "package": "toysolver",
          "partial": "Expr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#t:ExprZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLiteral\n\u003c/p\u003e",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "Lit",
          "package": "toysolver",
          "source": "src/Algorithm-FourierMotzkin-Core.html#Lit",
          "type": "data"
        },
        "index": {
          "description": "Literal",
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "Lit",
          "package": "toysolver",
          "partial": "Lit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#t:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(t,c) represents t/c, and c must be \u003e0.\n\u003c/p\u003e",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "Rat",
          "package": "toysolver",
          "source": "src/Algorithm-FourierMotzkin-Core.html#Rat",
          "type": "type"
        },
        "index": {
          "description": "represents and must be",
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "Rat",
          "package": "toysolver",
          "partial": "Rat",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#t:Rat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.FourierMotzkin.Core\",\"Algorithm.FourierMotzkin\"]",
          "name": "Nonneg",
          "package": "toysolver",
          "signature": "Nonneg ExprZ",
          "source": "src/Algorithm-FourierMotzkin-Core.html#Lit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:Nonneg\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#v:Nonneg\"]"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "Nonneg",
          "package": "toysolver",
          "partial": "Nonneg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:Nonneg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.FourierMotzkin.Core\",\"Algorithm.FourierMotzkin\"]",
          "name": "Pos",
          "package": "toysolver",
          "signature": "Pos ExprZ",
          "source": "src/Algorithm-FourierMotzkin-Core.html#Lit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:Pos\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#v:Pos\"]"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "Pos",
          "package": "toysolver",
          "partial": "Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:Pos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "fromLAAtom",
          "package": "toysolver",
          "signature": "Atom Rational -\u003e DNF Lit",
          "source": "src/Algorithm-FourierMotzkin-Core.html#fromLAAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "fromLAAtom",
          "normalized": "Atom Rational-\u003eDNF Lit",
          "package": "toysolver",
          "partial": "LAAtom",
          "signature": "Atom Rational-\u003eDNF Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:fromLAAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "fromRat",
          "package": "toysolver",
          "signature": "Rat -\u003e Expr Rational",
          "source": "src/Algorithm-FourierMotzkin-Core.html#fromRat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "fromRat",
          "normalized": "Rat-\u003eExpr Rational",
          "package": "toysolver",
          "partial": "Rat",
          "signature": "Rat-\u003eExpr Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:fromRat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.FourierMotzkin.Core\",\"Algorithm.FourierMotzkin\"]",
          "name": "project",
          "package": "toysolver",
          "signature": "Var -\u003e [Atom Rational] -\u003e [([Atom Rational], Model Rational -\u003e Model Rational)]",
          "source": "src/Algorithm-FourierMotzkin-Core.html#project",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:project\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#v:project\"]"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "project",
          "normalized": "Var-\u003e[Atom Rational]-\u003e[([Atom Rational],Model Rational-\u003eModel Rational)]",
          "package": "toysolver",
          "signature": "Var-\u003e[Atom Rational]-\u003e[([Atom Rational],Model Rational-\u003eModel Rational)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:project"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "project'",
          "package": "toysolver",
          "signature": "Var -\u003e [Lit] -\u003e [([Lit], Model Rational -\u003e Model Rational)]",
          "source": "src/Algorithm-FourierMotzkin-Core.html#project%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "project'",
          "normalized": "Var-\u003e[Lit]-\u003e[([Lit],Model Rational-\u003eModel Rational)]",
          "package": "toysolver",
          "signature": "Var-\u003e[Lit]-\u003e[([Lit],Model Rational-\u003eModel Rational)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:project-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.FourierMotzkin.Core\",\"Algorithm.FourierMotzkin\"]",
          "name": "projectN",
          "package": "toysolver",
          "signature": "VarSet -\u003e [Atom Rational] -\u003e [([Atom Rational], Model Rational -\u003e Model Rational)]",
          "source": "src/Algorithm-FourierMotzkin-Core.html#projectN",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:projectN\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#v:projectN\"]"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "projectN",
          "normalized": "VarSet-\u003e[Atom Rational]-\u003e[([Atom Rational],Model Rational-\u003eModel Rational)]",
          "package": "toysolver",
          "signature": "VarSet-\u003e[Atom Rational]-\u003e[([Atom Rational],Model Rational-\u003eModel Rational)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:projectN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "projectN'",
          "package": "toysolver",
          "signature": "VarSet -\u003e [Lit] -\u003e [([Lit], Model Rational -\u003e Model Rational)]",
          "source": "src/Algorithm-FourierMotzkin-Core.html#projectN%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "projectN'",
          "normalized": "VarSet-\u003e[Lit]-\u003e[([Lit],Model Rational-\u003eModel Rational)]",
          "package": "toysolver",
          "partial": "N'",
          "signature": "VarSet-\u003e[Lit]-\u003e[([Lit],Model Rational-\u003eModel Rational)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:projectN-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.FourierMotzkin.Core\",\"Algorithm.FourierMotzkin\"]",
          "name": "solve",
          "package": "toysolver",
          "signature": "VarSet -\u003e [Atom Rational] -\u003e Maybe (Model Rational)",
          "source": "src/Algorithm-FourierMotzkin-Core.html#solve",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:solve\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#v:solve\"]"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "solve",
          "normalized": "VarSet-\u003e[Atom Rational]-\u003eMaybe(Model Rational)",
          "package": "toysolver",
          "signature": "VarSet-\u003e[Atom Rational]-\u003eMaybe(Model Rational)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:solve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "solve'",
          "package": "toysolver",
          "signature": "VarSet -\u003e [Lit] -\u003e Maybe (Model Rational)",
          "source": "src/Algorithm-FourierMotzkin-Core.html#solve%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "solve'",
          "normalized": "VarSet-\u003e[Lit]-\u003eMaybe(Model Rational)",
          "package": "toysolver",
          "signature": "VarSet-\u003e[Lit]-\u003eMaybe(Model Rational)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:solve-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "toLAAtom",
          "package": "toysolver",
          "signature": "Lit -\u003e Atom Rational",
          "source": "src/Algorithm-FourierMotzkin-Core.html#toLAAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "toLAAtom",
          "normalized": "Lit-\u003eAtom Rational",
          "package": "toysolver",
          "partial": "LAAtom",
          "signature": "Lit-\u003eAtom Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:toLAAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "toRat",
          "package": "toysolver",
          "signature": "Expr Rational -\u003e Rat",
          "source": "src/Algorithm-FourierMotzkin-Core.html#toRat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin Core",
          "module": "Algorithm.FourierMotzkin.Core",
          "name": "toRat",
          "normalized": "Expr Rational-\u003eRat",
          "package": "toysolver",
          "partial": "Rat",
          "signature": "Expr Rational-\u003eRat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:toRat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FourierMotzkin.FOL",
          "name": "FOL",
          "package": "toysolver",
          "source": "src/Algorithm-FourierMotzkin-FOL.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin FOL",
          "module": "Algorithm.FourierMotzkin.FOL",
          "name": "FOL",
          "package": "toysolver",
          "partial": "FOL",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-FOL.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.FourierMotzkin.FOL\",\"Algorithm.FourierMotzkin\"]",
          "name": "eliminateQuantifiers",
          "package": "toysolver",
          "signature": "Formula (Atom Rational) -\u003e Maybe (Formula (Atom Rational))",
          "source": "src/Algorithm-FourierMotzkin-FOL.html#eliminateQuantifiers",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-FOL.html#v:eliminateQuantifiers\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#v:eliminateQuantifiers\"]"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin FOL",
          "module": "Algorithm.FourierMotzkin.FOL",
          "name": "eliminateQuantifiers",
          "normalized": "Formula(Atom Rational)-\u003eMaybe(Formula(Atom Rational))",
          "package": "toysolver",
          "partial": "Quantifiers",
          "signature": "Formula(Atom Rational)-\u003eMaybe(Formula(Atom Rational))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-FOL.html#v:eliminateQuantifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.FourierMotzkin.FOL",
          "name": "eliminateQuantifiers'",
          "package": "toysolver",
          "signature": "Formula (Atom Rational) -\u003e Maybe (DNF Lit)",
          "source": "src/Algorithm-FourierMotzkin-FOL.html#eliminateQuantifiers%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin FOL",
          "module": "Algorithm.FourierMotzkin.FOL",
          "name": "eliminateQuantifiers'",
          "normalized": "Formula(Atom Rational)-\u003eMaybe(DNF Lit)",
          "package": "toysolver",
          "partial": "Quantifiers'",
          "signature": "Formula(Atom Rational)-\u003eMaybe(DNF Lit)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-FOL.html#v:eliminateQuantifiers-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.FourierMotzkin.FOL\",\"Algorithm.FourierMotzkin\"]",
          "name": "solveFormula",
          "package": "toysolver",
          "signature": "[Var] -\u003e Formula (Atom Rational) -\u003e SatResult Rational",
          "source": "src/Algorithm-FourierMotzkin-FOL.html#solveFormula",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-FOL.html#v:solveFormula\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#v:solveFormula\"]"
        },
        "index": {
          "hierarchy": "Algorithm FourierMotzkin FOL",
          "module": "Algorithm.FourierMotzkin.FOL",
          "name": "solveFormula",
          "normalized": "[Var]-\u003eFormula(Atom Rational)-\u003eSatResult Rational",
          "package": "toysolver",
          "partial": "Formula",
          "signature": "[Var]-\u003eFormula(Atom Rational)-\u003eSatResult Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-FOL.html#v:solveFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNa&#239;ve implementation of Fourier-Motzkin Variable Elimination\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://users.cecs.anu.edu.au/~michaeln/pubs/arithmetic-dps.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Algorithm.FourierMotzkin",
          "name": "FourierMotzkin",
          "package": "toysolver",
          "source": "src/Algorithm-FourierMotzkin.html",
          "type": "module"
        },
        "index": {
          "description": "Na ve implementation of Fourier-Motzkin Variable Elimination Reference http users.cecs.anu.edu.au michaeln pubs arithmetic-dps.pdf",
          "hierarchy": "Algorithm FourierMotzkin",
          "module": "Algorithm.FourierMotzkin",
          "name": "FourierMotzkin",
          "package": "toysolver",
          "partial": "Fourier Motzkin",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLiteral\n\u003c/p\u003e",
          "module": "Algorithm.FourierMotzkin",
          "name": "Lit",
          "package": "toysolver",
          "source": "src/Algorithm-FourierMotzkin-Core.html#Lit",
          "type": "data"
        },
        "index": {
          "description": "Literal",
          "hierarchy": "Algorithm FourierMotzkin",
          "module": "Algorithm.FourierMotzkin",
          "name": "Lit",
          "package": "toysolver",
          "partial": "Lit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#t:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNa&#239;ve implementation of Simplex method\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.math.cuhk.edu.hk/~wei/lpch3.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Algorithm.LPSolver",
          "name": "LPSolver",
          "package": "toysolver",
          "source": "src/Algorithm-LPSolver.html",
          "type": "module"
        },
        "index": {
          "description": "Na ve implementation of Simplex method Reference http www.math.cuhk.edu.hk wei lpch3.pdf",
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "LPSolver",
          "package": "toysolver",
          "partial": "LPSolver",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "LP",
          "package": "toysolver",
          "source": "src/Algorithm-LPSolver.html#LP",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "LP",
          "package": "toysolver",
          "partial": "LP",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#t:LP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "Solver",
          "package": "toysolver",
          "source": "src/Algorithm-LPSolver.html#Solver",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "Solver",
          "package": "toysolver",
          "partial": "Solver",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#t:Solver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "addArtificialVariable",
          "package": "toysolver",
          "signature": "Var -\u003e LP r ()",
          "source": "src/Algorithm-LPSolver.html#addArtificialVariable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "addArtificialVariable",
          "normalized": "Var-\u003eLP a()",
          "package": "toysolver",
          "partial": "Artificial Variable",
          "signature": "Var-\u003eLP r()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:addArtificialVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "addConstraint",
          "package": "toysolver",
          "signature": "Atom r -\u003e LP r ()",
          "source": "src/Algorithm-LPSolver.html#addConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "addConstraint",
          "normalized": "Atom a-\u003eLP a()",
          "package": "toysolver",
          "partial": "Constraint",
          "signature": "Atom r-\u003eLP r()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:addConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "addConstraint2",
          "package": "toysolver",
          "signature": "Atom r -\u003e LP r ()",
          "source": "src/Algorithm-LPSolver.html#addConstraint2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "addConstraint2",
          "normalized": "Atom a-\u003eLP a()",
          "package": "toysolver",
          "partial": "Constraint",
          "signature": "Atom r-\u003eLP r()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:addConstraint2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "clearArtificialVariables",
          "package": "toysolver",
          "signature": "LP r ()",
          "source": "src/Algorithm-LPSolver.html#clearArtificialVariables",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "clearArtificialVariables",
          "normalized": "LP a()",
          "package": "toysolver",
          "partial": "Artificial Variables",
          "signature": "LP r()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:clearArtificialVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "collectNonnegVars",
          "package": "toysolver",
          "signature": "[Atom r] -\u003e VarSet -\u003e (VarSet, [Atom r])",
          "source": "src/Algorithm-LPSolver.html#collectNonnegVars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "collectNonnegVars",
          "normalized": "[Atom a]-\u003eVarSet-\u003e(VarSet,[Atom a])",
          "package": "toysolver",
          "partial": "Nonneg Vars",
          "signature": "[Atom r]-\u003eVarSet-\u003e(VarSet,[Atom r])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:collectNonnegVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "define",
          "package": "toysolver",
          "signature": "Var -\u003e Expr r -\u003e LP r ()",
          "source": "src/Algorithm-LPSolver.html#define",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "define",
          "normalized": "Var-\u003eExpr a-\u003eLP a()",
          "package": "toysolver",
          "signature": "Var-\u003eExpr r-\u003eLP r()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:define"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "dualSimplex",
          "package": "toysolver",
          "signature": "OptDir -\u003e Expr r -\u003e LP r Bool",
          "source": "src/Algorithm-LPSolver.html#dualSimplex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "dualSimplex",
          "normalized": "OptDir-\u003eExpr a-\u003eLP a Bool",
          "package": "toysolver",
          "partial": "Simplex",
          "signature": "OptDir-\u003eExpr r-\u003eLP r Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:dualSimplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "emptySolver",
          "package": "toysolver",
          "signature": "VarSet -\u003e Solver r",
          "source": "src/Algorithm-LPSolver.html#emptySolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "emptySolver",
          "normalized": "VarSet-\u003eSolver a",
          "package": "toysolver",
          "partial": "Solver",
          "signature": "VarSet-\u003eSolver r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:emptySolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "expandDefs",
          "package": "toysolver",
          "signature": "Expr r -\u003e LP r (Expr r)",
          "source": "src/Algorithm-LPSolver.html#expandDefs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "expandDefs",
          "normalized": "Expr a-\u003eLP a(Expr a)",
          "package": "toysolver",
          "partial": "Defs",
          "signature": "Expr r-\u003eLP r(Expr r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:expandDefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "expandDefs'",
          "package": "toysolver",
          "signature": "Atom r -\u003e LP r (Atom r)",
          "source": "src/Algorithm-LPSolver.html#expandDefs%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "expandDefs'",
          "normalized": "Atom a-\u003eLP a(Atom a)",
          "package": "toysolver",
          "partial": "Defs'",
          "signature": "Atom r-\u003eLP r(Atom r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:expandDefs-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "gensym",
          "package": "toysolver",
          "signature": "LP r Var",
          "source": "src/Algorithm-LPSolver.html#gensym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "gensym",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:gensym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "getArtificialVariables",
          "package": "toysolver",
          "signature": "LP r VarSet",
          "source": "src/Algorithm-LPSolver.html#getArtificialVariables",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "getArtificialVariables",
          "package": "toysolver",
          "partial": "Artificial Variables",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:getArtificialVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "getDefs",
          "package": "toysolver",
          "signature": "LP r (VarMap (Expr r))",
          "source": "src/Algorithm-LPSolver.html#getDefs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "getDefs",
          "package": "toysolver",
          "partial": "Defs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:getDefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "getModel",
          "package": "toysolver",
          "signature": "VarSet -\u003e LP r (Model r)",
          "source": "src/Algorithm-LPSolver.html#getModel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "getModel",
          "normalized": "VarSet-\u003eLP a(Model a)",
          "package": "toysolver",
          "partial": "Model",
          "signature": "VarSet-\u003eLP r(Model r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:getModel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "getTableau",
          "package": "toysolver",
          "signature": "LP r (Tableau r)",
          "source": "src/Algorithm-LPSolver.html#getTableau",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "getTableau",
          "package": "toysolver",
          "partial": "Tableau",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:getTableau"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "normalizeConstraint",
          "package": "toysolver",
          "signature": "Atom r -\u003e (Expr r, RelOp, r)",
          "source": "src/Algorithm-LPSolver.html#normalizeConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "normalizeConstraint",
          "normalized": "Atom a-\u003e(Expr a,RelOp,a)",
          "package": "toysolver",
          "partial": "Constraint",
          "signature": "Atom r-\u003e(Expr r,RelOp,r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:normalizeConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "phaseI",
          "package": "toysolver",
          "signature": "LP r Bool",
          "source": "src/Algorithm-LPSolver.html#phaseI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "phaseI",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:phaseI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "putTableau",
          "package": "toysolver",
          "signature": "Tableau r -\u003e LP r ()",
          "source": "src/Algorithm-LPSolver.html#putTableau",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "putTableau",
          "normalized": "Tableau a-\u003eLP a()",
          "package": "toysolver",
          "partial": "Tableau",
          "signature": "Tableau r-\u003eLP r()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:putTableau"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "simplex",
          "package": "toysolver",
          "signature": "OptDir -\u003e Expr r -\u003e LP r Bool",
          "source": "src/Algorithm-LPSolver.html#simplex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "simplex",
          "normalized": "OptDir-\u003eExpr a-\u003eLP a Bool",
          "package": "toysolver",
          "signature": "OptDir-\u003eExpr r-\u003eLP r Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:simplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolver",
          "name": "tableau",
          "package": "toysolver",
          "signature": "[Atom r] -\u003e LP r ()",
          "source": "src/Algorithm-LPSolver.html#tableau",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolver",
          "module": "Algorithm.LPSolver",
          "name": "tableau",
          "normalized": "[Atom a]-\u003eLP a()",
          "package": "toysolver",
          "signature": "[Atom r]-\u003eLP r()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:tableau"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHigh-Level API for LPSolver.hs\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algorithm.LPSolverHL",
          "name": "LPSolverHL",
          "package": "toysolver",
          "source": "src/Algorithm-LPSolverHL.html",
          "type": "module"
        },
        "index": {
          "description": "High-Level API for LPSolver.hs",
          "hierarchy": "Algorithm LPSolverHL",
          "module": "Algorithm.LPSolverHL",
          "name": "LPSolverHL",
          "package": "toysolver",
          "partial": "LPSolver HL",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eresults of optimization\n\u003c/p\u003e",
          "module": "Algorithm.LPSolverHL",
          "name": "OptResult",
          "package": "toysolver",
          "source": "src/Algorithm-LPSolverHL.html#OptResult",
          "type": "data"
        },
        "index": {
          "description": "results of optimization",
          "hierarchy": "Algorithm LPSolverHL",
          "module": "Algorithm.LPSolverHL",
          "name": "OptResult",
          "package": "toysolver",
          "partial": "Opt Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#t:OptResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.LPSolverHL\",\"Algorithm.MIPSolverHL\"]",
          "name": "OptUnsat",
          "package": "toysolver",
          "signature": "OptUnsat",
          "source": "src/Algorithm-LPSolverHL.html#OptResult",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:OptUnsat\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#v:OptUnsat\"]"
        },
        "index": {
          "hierarchy": "Algorithm LPSolverHL",
          "module": "Algorithm.LPSolverHL",
          "name": "OptUnsat",
          "package": "toysolver",
          "partial": "Opt Unsat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:OptUnsat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.LPSolverHL\",\"Algorithm.MIPSolverHL\"]",
          "name": "Optimum",
          "package": "toysolver",
          "signature": "Optimum r (Model r)",
          "source": "src/Algorithm-LPSolverHL.html#OptResult",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:Optimum\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#v:Optimum\"]"
        },
        "index": {
          "hierarchy": "Algorithm LPSolverHL",
          "module": "Algorithm.LPSolverHL",
          "name": "Optimum",
          "package": "toysolver",
          "partial": "Optimum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:Optimum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.LPSolverHL\",\"Algorithm.MIPSolverHL\"]",
          "name": "Unbounded",
          "package": "toysolver",
          "signature": "Unbounded",
          "source": "src/Algorithm-LPSolverHL.html#OptResult",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:Unbounded\",\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#v:Unbounded\"]"
        },
        "index": {
          "hierarchy": "Algorithm LPSolverHL",
          "module": "Algorithm.LPSolverHL",
          "name": "Unbounded",
          "package": "toysolver",
          "partial": "Unbounded",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:Unbounded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolverHL",
          "name": "maximize",
          "package": "toysolver",
          "signature": "Expr r -\u003e [Atom r] -\u003e OptResult r",
          "source": "src/Algorithm-LPSolverHL.html#maximize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolverHL",
          "module": "Algorithm.LPSolverHL",
          "name": "maximize",
          "normalized": "Expr a-\u003e[Atom a]-\u003eOptResult a",
          "package": "toysolver",
          "signature": "Expr r-\u003e[Atom r]-\u003eOptResult r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:maximize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolverHL",
          "name": "minimize",
          "package": "toysolver",
          "signature": "Expr r -\u003e [Atom r] -\u003e OptResult r",
          "source": "src/Algorithm-LPSolverHL.html#minimize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolverHL",
          "module": "Algorithm.LPSolverHL",
          "name": "minimize",
          "normalized": "Expr a-\u003e[Atom a]-\u003eOptResult a",
          "package": "toysolver",
          "signature": "Expr r-\u003e[Atom r]-\u003eOptResult r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:minimize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolverHL",
          "name": "optimize",
          "package": "toysolver",
          "signature": "OptDir -\u003e Expr r -\u003e [Atom r] -\u003e OptResult r",
          "source": "src/Algorithm-LPSolverHL.html#optimize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolverHL",
          "module": "Algorithm.LPSolverHL",
          "name": "optimize",
          "normalized": "OptDir-\u003eExpr a-\u003e[Atom a]-\u003eOptResult a",
          "package": "toysolver",
          "signature": "OptDir-\u003eExpr r-\u003e[Atom r]-\u003eOptResult r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:optimize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPSolverHL",
          "name": "solve",
          "package": "toysolver",
          "signature": "[Atom r] -\u003e Maybe (Model r)",
          "source": "src/Algorithm-LPSolverHL.html#solve",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPSolverHL",
          "module": "Algorithm.LPSolverHL",
          "name": "solve",
          "normalized": "[Atom a]-\u003eMaybe(Model a)",
          "package": "toysolver",
          "signature": "[Atom r]-\u003eMaybe(Model r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:solve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPUtil",
          "name": "LPUtil",
          "package": "toysolver",
          "source": "src/Algorithm-LPUtil.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algorithm LPUtil",
          "module": "Algorithm.LPUtil",
          "name": "LPUtil",
          "package": "toysolver",
          "partial": "LPUtil",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPUtil.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPUtil",
          "name": "toStandardForm",
          "package": "toysolver",
          "signature": "(Expr Rational, [Rel (Expr Rational)]) -\u003e ((Expr Rational, [(Expr Rational, Rational)]), Model Rational -\u003e Model Rational)",
          "source": "src/Algorithm-LPUtil.html#toStandardForm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPUtil",
          "module": "Algorithm.LPUtil",
          "name": "toStandardForm",
          "normalized": "(Expr Rational,[Rel(Expr Rational)])-\u003e((Expr Rational,[(Expr Rational,Rational)]),Model Rational-\u003eModel Rational)",
          "package": "toysolver",
          "partial": "Standard Form",
          "signature": "(Expr Rational,[Rel(Expr Rational)])-\u003e((Expr Rational,[(Expr Rational,Rational)]),Model Rational-\u003eModel Rational)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPUtil.html#v:toStandardForm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.LPUtil",
          "name": "toStandardForm'",
          "package": "toysolver",
          "signature": "(Expr Rational, [Rel (Expr Rational)]) -\u003e ((Expr Rational, [(Expr Rational, Rational)]), VarMap (Expr Rational))",
          "source": "src/Algorithm-LPUtil.html#toStandardForm%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm LPUtil",
          "module": "Algorithm.LPUtil",
          "name": "toStandardForm'",
          "normalized": "(Expr Rational,[Rel(Expr Rational)])-\u003e((Expr Rational,[(Expr Rational,Rational)]),VarMap(Expr Rational))",
          "package": "toysolver",
          "partial": "Standard Form'",
          "signature": "(Expr Rational,[Rel(Expr Rational)])-\u003e((Expr Rational,[(Expr Rational,Rational)]),VarMap(Expr Rational))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPUtil.html#v:toStandardForm-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNa&#239;ve implementation of MIP solver based on Simplex2 module\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.math.cuhk.edu.hk/~wei/lpch3.pdf\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Ralph E. Gomory.\n   \"An Algorithm for the Mixed Integer Problem\", Technical Report\n   RM-2597, 1960, The Rand Corporation, Santa Monica, CA.\n   \u003ca\u003ehttp://www.rand.org/pubs/research_memoranda/RM2597.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Ralph E. Gomory.\n   \"Outline of an algorithm for integer solutions to linear programs\".\n   Bull. Amer. Math. Soc., Vol. 64, No. 5. (1958), pp. 275-278.\n   \u003ca\u003ehttp://projecteuclid.org/euclid.bams/1183522679\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e R. C. Daniel and Martyn Jeffreys.\n   \"Unboundedness in Integer and Discrete Programming L.P. Relaxations\"\n   The Journal of the Operational Research Society, Vol. 30, No. 12. (1979)\n   \u003ca\u003ehttp://www.jstor.org/stable/3009435\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Algorithm.MIPSolver2",
          "name": "MIPSolver2",
          "package": "toysolver",
          "source": "src/Algorithm-MIPSolver2.html",
          "type": "module"
        },
        "index": {
          "description": "Na ve implementation of MIP solver based on Simplex2 module Reference http www.math.cuhk.edu.hk wei lpch3.pdf Ralph Gomory An Algorithm for the Mixed Integer Problem Technical Report RM-2597 The Rand Corporation Santa Monica CA http www.rand.org pubs research memoranda RM2597.html Ralph Gomory Outline of an algorithm for integer solutions to linear programs Bull Amer Math Soc Vol No pp http projecteuclid.org euclid.bams Daniel and Martyn Jeffreys Unboundedness in Integer and Discrete Programming L.P Relaxations The Journal of the Operational Research Society Vol No http www.jstor.org stable",
          "hierarchy": "Algorithm MIPSolver2",
          "module": "Algorithm.MIPSolver2",
          "name": "MIPSolver2",
          "package": "toysolver",
          "partial": "MIPSolver",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.MIPSolver2",
          "name": "Solver",
          "package": "toysolver",
          "source": "src/Algorithm-MIPSolver2.html#Solver",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algorithm MIPSolver2",
          "module": "Algorithm.MIPSolver2",
          "name": "Solver",
          "package": "toysolver",
          "partial": "Solver",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#t:Solver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.MIPSolver2",
          "name": "getObjValue",
          "package": "toysolver",
          "signature": "Solver -\u003e IO Rational",
          "source": "src/Algorithm-MIPSolver2.html#getObjValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm MIPSolver2",
          "module": "Algorithm.MIPSolver2",
          "name": "getObjValue",
          "normalized": "Solver-\u003eIO Rational",
          "package": "toysolver",
          "partial": "Obj Value",
          "signature": "Solver-\u003eIO Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#v:getObjValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.MIPSolver2",
          "name": "model",
          "package": "toysolver",
          "signature": "Solver -\u003e IO Model",
          "source": "src/Algorithm-MIPSolver2.html#model",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm MIPSolver2",
          "module": "Algorithm.MIPSolver2",
          "name": "model",
          "normalized": "Solver-\u003eIO Model",
          "package": "toysolver",
          "signature": "Solver-\u003eIO Model",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#v:model"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.MIPSolver2",
          "name": "newSolver",
          "package": "toysolver",
          "signature": "Solver -\u003e IntSet -\u003e IO Solver",
          "source": "src/Algorithm-MIPSolver2.html#newSolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm MIPSolver2",
          "module": "Algorithm.MIPSolver2",
          "name": "newSolver",
          "normalized": "Solver-\u003eIntSet-\u003eIO Solver",
          "package": "toysolver",
          "partial": "Solver",
          "signature": "Solver-\u003eIntSet-\u003eIO Solver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#v:newSolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.MIPSolver2",
          "name": "optimize",
          "package": "toysolver",
          "signature": "Solver -\u003e (Model -\u003e Rational -\u003e IO ()) -\u003e IO OptResult",
          "source": "src/Algorithm-MIPSolver2.html#optimize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm MIPSolver2",
          "module": "Algorithm.MIPSolver2",
          "name": "optimize",
          "normalized": "Solver-\u003e(Model-\u003eRational-\u003eIO())-\u003eIO OptResult",
          "package": "toysolver",
          "signature": "Solver-\u003e(Model-\u003eRational-\u003eIO())-\u003eIO OptResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#v:optimize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset callback function for receiving messages.\n\u003c/p\u003e",
          "module": "Algorithm.MIPSolver2",
          "name": "setLogger",
          "package": "toysolver",
          "signature": "Solver -\u003e (String -\u003e IO ()) -\u003e IO ()",
          "source": "src/Algorithm-MIPSolver2.html#setLogger",
          "type": "function"
        },
        "index": {
          "description": "set callback function for receiving messages",
          "hierarchy": "Algorithm MIPSolver2",
          "module": "Algorithm.MIPSolver2",
          "name": "setLogger",
          "normalized": "Solver-\u003e(String-\u003eIO())-\u003eIO()",
          "package": "toysolver",
          "partial": "Logger",
          "signature": "Solver-\u003e(String-\u003eIO())-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#v:setLogger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.MIPSolver2",
          "name": "setNThread",
          "package": "toysolver",
          "signature": "Solver -\u003e Int -\u003e IO ()",
          "source": "src/Algorithm-MIPSolver2.html#setNThread",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm MIPSolver2",
          "module": "Algorithm.MIPSolver2",
          "name": "setNThread",
          "normalized": "Solver-\u003eInt-\u003eIO()",
          "package": "toysolver",
          "partial": "NThread",
          "signature": "Solver-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#v:setNThread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.MIPSolver2",
          "name": "setShowRational",
          "package": "toysolver",
          "signature": "Solver -\u003e Bool -\u003e IO ()",
          "source": "src/Algorithm-MIPSolver2.html#setShowRational",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm MIPSolver2",
          "module": "Algorithm.MIPSolver2",
          "name": "setShowRational",
          "normalized": "Solver-\u003eBool-\u003eIO()",
          "package": "toysolver",
          "partial": "Show Rational",
          "signature": "Solver-\u003eBool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#v:setShowRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e [Gomory1960]\n   Ralph E. Gomory.\n   An Algorithm for the Mixed Integer Problem, Technical Report\n   RM-2597, 1960, The Rand Corporation, Santa Monica, CA.\n   \u003ca\u003ehttp://www.rand.org/pubs/research_memoranda/RM2597.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e [Gomory1958]\n   Ralph E. Gomory.\n   Outline of an algorithm for integer solutions to linear programs.\n   Bull. Amer. Math. Soc., Vol. 64, No. 5. (1958), pp. 275-278.\n   \u003ca\u003ehttp://projecteuclid.org/euclid.bams/1183522679\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Algorithm.MIPSolverHL",
          "name": "MIPSolverHL",
          "package": "toysolver",
          "source": "src/Algorithm-MIPSolverHL.html",
          "type": "module"
        },
        "index": {
          "description": "References Gomory1960 Ralph Gomory An Algorithm for the Mixed Integer Problem Technical Report RM-2597 The Rand Corporation Santa Monica CA http www.rand.org pubs research memoranda RM2597.html Gomory1958 Ralph Gomory Outline of an algorithm for integer solutions to linear programs Bull Amer Math Soc Vol No pp http projecteuclid.org euclid.bams",
          "hierarchy": "Algorithm MIPSolverHL",
          "module": "Algorithm.MIPSolverHL",
          "name": "MIPSolverHL",
          "package": "toysolver",
          "partial": "MIPSolver HL",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eresults of optimization\n\u003c/p\u003e",
          "module": "Algorithm.MIPSolverHL",
          "name": "OptResult",
          "package": "toysolver",
          "source": "src/Algorithm-LPSolverHL.html#OptResult",
          "type": "data"
        },
        "index": {
          "description": "results of optimization",
          "hierarchy": "Algorithm MIPSolverHL",
          "module": "Algorithm.MIPSolverHL",
          "name": "OptResult",
          "package": "toysolver",
          "partial": "Opt Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#t:OptResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.MIPSolverHL",
          "name": "maximize",
          "package": "toysolver",
          "signature": "Expr r -\u003e [Atom r] -\u003e VarSet -\u003e OptResult r",
          "source": "src/Algorithm-MIPSolverHL.html#maximize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm MIPSolverHL",
          "module": "Algorithm.MIPSolverHL",
          "name": "maximize",
          "normalized": "Expr a-\u003e[Atom a]-\u003eVarSet-\u003eOptResult a",
          "package": "toysolver",
          "signature": "Expr r-\u003e[Atom r]-\u003eVarSet-\u003eOptResult r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#v:maximize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.MIPSolverHL",
          "name": "minimize",
          "package": "toysolver",
          "signature": "Expr r -\u003e [Atom r] -\u003e VarSet -\u003e OptResult r",
          "source": "src/Algorithm-MIPSolverHL.html#minimize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm MIPSolverHL",
          "module": "Algorithm.MIPSolverHL",
          "name": "minimize",
          "normalized": "Expr a-\u003e[Atom a]-\u003eVarSet-\u003eOptResult a",
          "package": "toysolver",
          "signature": "Expr r-\u003e[Atom r]-\u003eVarSet-\u003eOptResult r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#v:minimize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.MIPSolverHL",
          "name": "optimize",
          "package": "toysolver",
          "signature": "OptDir -\u003e Expr r -\u003e [Atom r] -\u003e VarSet -\u003e OptResult r",
          "source": "src/Algorithm-MIPSolverHL.html#optimize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm MIPSolverHL",
          "module": "Algorithm.MIPSolverHL",
          "name": "optimize",
          "normalized": "OptDir-\u003eExpr a-\u003e[Atom a]-\u003eVarSet-\u003eOptResult a",
          "package": "toysolver",
          "signature": "OptDir-\u003eExpr r-\u003e[Atom r]-\u003eVarSet-\u003eOptResult r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#v:optimize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.OmegaTest.Misc",
          "name": "Misc",
          "package": "toysolver",
          "source": "src/Algorithm-OmegaTest-Misc.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algorithm OmegaTest Misc",
          "module": "Algorithm.OmegaTest.Misc",
          "name": "Misc",
          "package": "toysolver",
          "partial": "Misc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest-Misc.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.OmegaTest.Misc",
          "name": "checkRealByCAD",
          "package": "toysolver",
          "signature": "VarSet -\u003e [Atom Rational] -\u003e Bool",
          "source": "src/Algorithm-OmegaTest-Misc.html#checkRealByCAD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm OmegaTest Misc",
          "module": "Algorithm.OmegaTest.Misc",
          "name": "checkRealByCAD",
          "normalized": "VarSet-\u003e[Atom Rational]-\u003eBool",
          "package": "toysolver",
          "partial": "Real By CAD",
          "signature": "VarSet-\u003e[Atom Rational]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest-Misc.html#v:checkRealByCAD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.OmegaTest.Misc",
          "name": "checkRealBySimplex",
          "package": "toysolver",
          "signature": "VarSet -\u003e [Atom Rational] -\u003e Bool",
          "source": "src/Algorithm-OmegaTest-Misc.html#checkRealBySimplex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm OmegaTest Misc",
          "module": "Algorithm.OmegaTest.Misc",
          "name": "checkRealBySimplex",
          "normalized": "VarSet-\u003e[Atom Rational]-\u003eBool",
          "package": "toysolver",
          "partial": "Real By Simplex",
          "signature": "VarSet-\u003e[Atom Rational]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest-Misc.html#v:checkRealBySimplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e(incomplete) implementation of Omega Test\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e William Pugh. The Omega test: a fast and practical integer\n   programming algorithm for dependence analysis. In Proceedings of\n   the 1991 ACM/IEEE conference on Supercomputing (1991), pp. 4-13.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://users.cecs.anu.edu.au/~michaeln/pubs/arithmetic-dps.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSee also:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://hackage.haskell.org/package/Omega\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Algorithm.OmegaTest",
          "name": "OmegaTest",
          "package": "toysolver",
          "source": "src/Algorithm-OmegaTest.html",
          "type": "module"
        },
        "index": {
          "description": "incomplete implementation of Omega Test References William Pugh The Omega test fast and practical integer programming algorithm for dependence analysis In Proceedings of the ACM IEEE conference on Supercomputing pp http users.cecs.anu.edu.au michaeln pubs arithmetic-dps.pdf See also http hackage.haskell.org package Omega",
          "hierarchy": "Algorithm OmegaTest",
          "module": "Algorithm.OmegaTest",
          "name": "OmegaTest",
          "package": "toysolver",
          "partial": "Omega Test",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003eModel\u003c/code\u003e is a map from variables to values.\n\u003c/p\u003e",
          "module": "Algorithm.OmegaTest",
          "name": "Model",
          "package": "toysolver",
          "source": "src/Data-Var.html#Model",
          "type": "type"
        },
        "index": {
          "description": "Model is map from variables to values",
          "hierarchy": "Algorithm OmegaTest",
          "module": "Algorithm.OmegaTest",
          "name": "Model",
          "package": "toysolver",
          "partial": "Model",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#t:Model"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.OmegaTest",
          "name": "Options",
          "package": "toysolver",
          "source": "src/Algorithm-OmegaTest.html#Options",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algorithm OmegaTest",
          "module": "Algorithm.OmegaTest",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#t:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.OmegaTest",
          "name": "Options",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/Algorithm-OmegaTest.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm OmegaTest",
          "module": "Algorithm.OmegaTest",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#v:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.OmegaTest",
          "name": "checkRealByFM",
          "package": "toysolver",
          "signature": "VarSet -\u003e [Atom Rational] -\u003e Bool",
          "source": "src/Algorithm-OmegaTest.html#checkRealByFM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm OmegaTest",
          "module": "Algorithm.OmegaTest",
          "name": "checkRealByFM",
          "normalized": "VarSet-\u003e[Atom Rational]-\u003eBool",
          "package": "toysolver",
          "partial": "Real By FM",
          "signature": "VarSet-\u003e[Atom Rational]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#v:checkRealByFM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.OmegaTest",
          "name": "checkRealNoCheck",
          "package": "toysolver",
          "signature": "VarSet -\u003e [Atom Rational] -\u003e Bool",
          "source": "src/Algorithm-OmegaTest.html#checkRealNoCheck",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm OmegaTest",
          "module": "Algorithm.OmegaTest",
          "name": "checkRealNoCheck",
          "normalized": "VarSet-\u003e[Atom Rational]-\u003eBool",
          "package": "toysolver",
          "partial": "Real No Check",
          "signature": "VarSet-\u003e[Atom Rational]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#v:checkRealNoCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.OmegaTest",
          "name": "defaultOptions",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/Algorithm-OmegaTest.html#defaultOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm OmegaTest",
          "module": "Algorithm.OmegaTest",
          "name": "defaultOptions",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#v:defaultOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.OmegaTest",
          "name": "optCheckReal",
          "package": "toysolver",
          "signature": "VarSet -\u003e [Atom Rational] -\u003e Bool",
          "source": "src/Algorithm-OmegaTest.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm OmegaTest",
          "module": "Algorithm.OmegaTest",
          "name": "optCheckReal",
          "normalized": "VarSet-\u003e[Atom Rational]-\u003eBool",
          "package": "toysolver",
          "partial": "Check Real",
          "signature": "VarSet-\u003e[Atom Rational]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#v:optCheckReal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.OmegaTest",
          "name": "solve",
          "package": "toysolver",
          "signature": "Options -\u003e VarSet -\u003e [Atom Rational] -\u003e Maybe (Model Integer)",
          "source": "src/Algorithm-OmegaTest.html#solve",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm OmegaTest",
          "module": "Algorithm.OmegaTest",
          "name": "solve",
          "normalized": "Options-\u003eVarSet-\u003e[Atom Rational]-\u003eMaybe(Model Integer)",
          "package": "toysolver",
          "signature": "Options-\u003eVarSet-\u003e[Atom Rational]-\u003eMaybe(Model Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#v:solve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.OmegaTest",
          "name": "solveQFLA",
          "package": "toysolver",
          "signature": "Options -\u003e VarSet -\u003e [Atom Rational] -\u003e VarSet -\u003e Maybe (Model Rational)",
          "source": "src/Algorithm-OmegaTest.html#solveQFLA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm OmegaTest",
          "module": "Algorithm.OmegaTest",
          "name": "solveQFLA",
          "normalized": "Options-\u003eVarSet-\u003e[Atom Rational]-\u003eVarSet-\u003eMaybe(Model Rational)",
          "package": "toysolver",
          "partial": "QFLA",
          "signature": "Options-\u003eVarSet-\u003e[Atom Rational]-\u003eVarSet-\u003eMaybe(Model Rational)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#v:solveQFLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNa&#239;ve implementation of Simplex method\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.math.cuhk.edu.hk/~wei/lpch3.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Algorithm.Simplex",
          "name": "Simplex",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex.html",
          "type": "module"
        },
        "index": {
          "description": "Na ve implementation of Simplex method Reference http www.math.cuhk.edu.hk wei lpch3.pdf",
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "Simplex",
          "package": "toysolver",
          "partial": "Simplex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "ColIndex",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex.html#ColIndex",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "ColIndex",
          "package": "toysolver",
          "partial": "Col Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#t:ColIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "PivotResult",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex.html#PivotResult",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "PivotResult",
          "package": "toysolver",
          "partial": "Pivot Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#t:PivotResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "Row",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex.html#Row",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "Row",
          "package": "toysolver",
          "partial": "Row",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#t:Row"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "RowIndex",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex.html#RowIndex",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "RowIndex",
          "package": "toysolver",
          "partial": "Row Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#t:RowIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "Tableau",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex.html#Tableau",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "Tableau",
          "package": "toysolver",
          "partial": "Tableau",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#t:Tableau"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "currentObjValue",
          "package": "toysolver",
          "signature": "Tableau r -\u003e r",
          "source": "src/Algorithm-Simplex.html#currentObjValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "currentObjValue",
          "normalized": "Tableau a-\u003ea",
          "package": "toysolver",
          "partial": "Obj Value",
          "signature": "Tableau r-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:currentObjValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "dualSimplex",
          "package": "toysolver",
          "signature": "OptDir -\u003e Tableau r -\u003e (Bool, Tableau r)",
          "source": "src/Algorithm-Simplex.html#dualSimplex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "dualSimplex",
          "normalized": "OptDir-\u003eTableau a-\u003e(Bool,Tableau a)",
          "package": "toysolver",
          "partial": "Simplex",
          "signature": "OptDir-\u003eTableau r-\u003e(Bool,Tableau r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:dualSimplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "lookupRow",
          "package": "toysolver",
          "signature": "RowIndex -\u003e Tableau r -\u003e Row r",
          "source": "src/Algorithm-Simplex.html#lookupRow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "lookupRow",
          "normalized": "RowIndex-\u003eTableau a-\u003eRow a",
          "package": "toysolver",
          "partial": "Row",
          "signature": "RowIndex-\u003eTableau r-\u003eRow r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:lookupRow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "objRow",
          "package": "toysolver",
          "signature": "RowIndex",
          "source": "src/Algorithm-Simplex.html#objRow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "objRow",
          "package": "toysolver",
          "partial": "Row",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:objRow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "phaseI",
          "package": "toysolver",
          "signature": "Tableau r -\u003e VarSet -\u003e (Bool, Tableau r)",
          "source": "src/Algorithm-Simplex.html#phaseI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "phaseI",
          "normalized": "Tableau a-\u003eVarSet-\u003e(Bool,Tableau a)",
          "package": "toysolver",
          "signature": "Tableau r-\u003eVarSet-\u003e(Bool,Tableau r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:phaseI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "pivot",
          "package": "toysolver",
          "signature": "RowIndex -\u003e ColIndex -\u003e Tableau r -\u003e Tableau r",
          "source": "src/Algorithm-Simplex.html#pivot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "pivot",
          "normalized": "RowIndex-\u003eColIndex-\u003eTableau a-\u003eTableau a",
          "package": "toysolver",
          "signature": "RowIndex-\u003eColIndex-\u003eTableau r-\u003eTableau r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:pivot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "setObjFun",
          "package": "toysolver",
          "signature": "Tableau r -\u003e Expr r -\u003e Tableau r",
          "source": "src/Algorithm-Simplex.html#setObjFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "setObjFun",
          "normalized": "Tableau a-\u003eExpr a-\u003eTableau a",
          "package": "toysolver",
          "partial": "Obj Fun",
          "signature": "Tableau r-\u003eExpr r-\u003eTableau r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:setObjFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "setRow",
          "package": "toysolver",
          "signature": "RowIndex -\u003e Tableau r -\u003e Row r -\u003e Tableau r",
          "source": "src/Algorithm-Simplex.html#setRow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "setRow",
          "normalized": "RowIndex-\u003eTableau a-\u003eRow a-\u003eTableau a",
          "package": "toysolver",
          "partial": "Row",
          "signature": "RowIndex-\u003eTableau r-\u003eRow r-\u003eTableau r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:setRow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "simplex",
          "package": "toysolver",
          "signature": "OptDir -\u003e Tableau r -\u003e (Bool, Tableau r)",
          "source": "src/Algorithm-Simplex.html#simplex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "simplex",
          "normalized": "OptDir-\u003eTableau a-\u003e(Bool,Tableau a)",
          "package": "toysolver",
          "signature": "OptDir-\u003eTableau r-\u003e(Bool,Tableau r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:simplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex",
          "name": "toCSV",
          "package": "toysolver",
          "signature": "(r -\u003e String) -\u003e Tableau r -\u003e String",
          "source": "src/Algorithm-Simplex.html#toCSV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex",
          "module": "Algorithm.Simplex",
          "name": "toCSV",
          "normalized": "(a-\u003eString)-\u003eTableau a-\u003eString",
          "package": "toysolver",
          "partial": "CSV",
          "signature": "(r-\u003eString)-\u003eTableau r-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:toCSV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNa&#239;ve implementation of Simplex method\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.math.cuhk.edu.hk/~wei/lpch3.pdf\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Bruno Dutertre and Leonardo de Moura.\n   A Fast Linear-Arithmetic Solver for DPLL(T).\n   Computer Aided Verification In Computer Aided Verification, Vol. 4144 (2006), pp. 81-94.\n   \u003ca\u003ehttp://yices.csl.sri.com/cav06.pdf\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Bruno Dutertre and Leonardo de Moura.\n   Integrating Simplex with DPLL(T).\n   CSL Technical Report SRI-CSL-06-01. 2006.\n   \u003ca\u003ehttp://yices.csl.sri.com/sri-csl-06-01.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Algorithm.Simplex2",
          "name": "Simplex2",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex2.html",
          "type": "module"
        },
        "index": {
          "description": "Na ve implementation of Simplex method Reference http www.math.cuhk.edu.hk wei lpch3.pdf Bruno Dutertre and Leonardo de Moura Fast Linear-Arithmetic Solver for DPLL Computer Aided Verification In Computer Aided Verification Vol pp http yices.csl.sri.com cav06.pdf Bruno Dutertre and Leonardo de Moura Integrating Simplex with DPLL CSL Technical Report SRI-CSL-06-01 http yices.csl.sri.com sri-csl-06-01.pdf",
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Simplex2",
          "package": "toysolver",
          "partial": "Simplex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAtomic Formula of Linear Arithmetics\n\u003c/p\u003e",
          "module": "Algorithm.Simplex2",
          "name": "Atom",
          "package": "toysolver",
          "source": "src/Data-LA.html#Atom",
          "type": "type"
        },
        "index": {
          "description": "Atomic Formula of Linear Arithmetics",
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Atom",
          "package": "toysolver",
          "partial": "Atom",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:Atom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "GenericSolver",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex2.html#GenericSolver",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "GenericSolver",
          "package": "toysolver",
          "partial": "Generic Solver",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:GenericSolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "Model",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex2.html#Model",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Model",
          "package": "toysolver",
          "partial": "Model",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:Model"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eOptDir\u003c/a\u003e\u003c/code\u003e type represents optimization directions.\n\u003c/p\u003e",
          "module": "Algorithm.Simplex2",
          "name": "OptDir",
          "package": "toysolver",
          "type": "data"
        },
        "index": {
          "description": "The OptDir type represents optimization directions",
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "OptDir",
          "package": "toysolver",
          "partial": "Opt Dir",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:OptDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eresults of optimization\n\u003c/p\u003e",
          "module": "Algorithm.Simplex2",
          "name": "OptResult",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex2.html#OptResult",
          "type": "data"
        },
        "index": {
          "description": "results of optimization",
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "OptResult",
          "package": "toysolver",
          "partial": "Opt Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:OptResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "Options",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex2.html#Options",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "PivotStrategy",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex2.html#PivotStrategy",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "PivotStrategy",
          "package": "toysolver",
          "partial": "Pivot Strategy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:PivotStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "RawModel",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex2.html#RawModel",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "RawModel",
          "package": "toysolver",
          "partial": "Raw Model",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:RawModel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erelational operators\n\u003c/p\u003e",
          "module": "Algorithm.Simplex2",
          "name": "RelOp",
          "package": "toysolver",
          "source": "src/Data-ArithRel.html#RelOp",
          "type": "data"
        },
        "index": {
          "description": "relational operators",
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "RelOp",
          "package": "toysolver",
          "partial": "Rel Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:RelOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "Solver",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex2.html#Solver",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Solver",
          "package": "toysolver",
          "partial": "Solver",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:Solver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "SolverValue",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex2.html#SolverValue",
          "type": "class"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "SolverValue",
          "package": "toysolver",
          "partial": "Solver Value",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:SolverValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "Var",
          "package": "toysolver",
          "source": "src/Algorithm-Simplex2.html#Var",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Var",
          "package": "toysolver",
          "partial": "Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
          "module": "[\"Algorithm.Simplex2\",\"Data.ArithRel\"]",
          "name": "(.\u003c=.)",
          "package": "toysolver",
          "signature": "e -\u003e e -\u003e r",
          "source": "src/Data-ArithRel.html#.%3C%3D.",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-60--61-.\",\"http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:.-60--61-.\"]"
        },
        "index": {
          "description": "constructing relational formula",
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "(.\u003c=.) .\u003c=.",
          "normalized": "a-\u003ea-\u003eb",
          "package": "toysolver",
          "signature": "e-\u003ee-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-60--61-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
          "module": "[\"Algorithm.Simplex2\",\"Data.ArithRel\"]",
          "name": "(.\u003c.)",
          "package": "toysolver",
          "signature": "e -\u003e e -\u003e r",
          "source": "src/Data-ArithRel.html#.%3C.",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-60-.\",\"http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:.-60-.\"]"
        },
        "index": {
          "description": "constructing relational formula",
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "(.\u003c.) .\u003c.",
          "normalized": "a-\u003ea-\u003eb",
          "package": "toysolver",
          "signature": "e-\u003ee-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-60-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
          "module": "[\"Algorithm.Simplex2\",\"Data.ArithRel\"]",
          "name": "(.==.)",
          "package": "toysolver",
          "signature": "e -\u003e e -\u003e r",
          "source": "src/Data-ArithRel.html#.%3D%3D.",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-61--61-.\",\"http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:.-61--61-.\"]"
        },
        "index": {
          "description": "constructing relational formula",
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "(.==.) .==.",
          "normalized": "a-\u003ea-\u003eb",
          "package": "toysolver",
          "signature": "e-\u003ee-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-61--61-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
          "module": "[\"Algorithm.Simplex2\",\"Data.ArithRel\"]",
          "name": "(.\u003e=.)",
          "package": "toysolver",
          "signature": "e -\u003e e -\u003e r",
          "source": "src/Data-ArithRel.html#.%3E%3D.",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-62--61-.\",\"http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:.-62--61-.\"]"
        },
        "index": {
          "description": "constructing relational formula",
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "(.\u003e=.) .\u003e=.",
          "normalized": "a-\u003ea-\u003eb",
          "package": "toysolver",
          "signature": "e-\u003ee-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-62--61-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
          "module": "[\"Algorithm.Simplex2\",\"Data.ArithRel\"]",
          "name": "(.\u003e.)",
          "package": "toysolver",
          "signature": "e -\u003e e -\u003e r",
          "source": "src/Data-ArithRel.html#.%3E.",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-62-.\",\"http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:.-62-.\"]"
        },
        "index": {
          "description": "constructing relational formula",
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "(.\u003e.) .\u003e.",
          "normalized": "a-\u003ea-\u003eb",
          "package": "toysolver",
          "signature": "e-\u003ee-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-62-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Simplex2\",\"Data.ArithRel\"]",
          "name": "Eql",
          "package": "toysolver",
          "signature": "Eql",
          "source": "src/Data-ArithRel.html#RelOp",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Eql\",\"http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:Eql\"]"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Eql",
          "package": "toysolver",
          "partial": "Eql",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Eql"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Simplex2\",\"Data.ArithRel\"]",
          "name": "Ge",
          "package": "toysolver",
          "signature": "Ge",
          "source": "src/Data-ArithRel.html#RelOp",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Ge\",\"http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:Ge\"]"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Ge",
          "package": "toysolver",
          "partial": "Ge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Ge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Simplex2\",\"Data.ArithRel\"]",
          "name": "Gt",
          "package": "toysolver",
          "signature": "Gt",
          "source": "src/Data-ArithRel.html#RelOp",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Gt\",\"http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:Gt\"]"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Gt",
          "package": "toysolver",
          "partial": "Gt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Gt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Simplex2\",\"Data.ArithRel\"]",
          "name": "Le",
          "package": "toysolver",
          "signature": "Le",
          "source": "src/Data-ArithRel.html#RelOp",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Le\",\"http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:Le\"]"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Le",
          "package": "toysolver",
          "partial": "Le",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Le"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Simplex2\",\"Data.ArithRel\"]",
          "name": "Lt",
          "package": "toysolver",
          "signature": "Lt",
          "source": "src/Data-ArithRel.html#RelOp",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Lt\",\"http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:Lt\"]"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Lt",
          "package": "toysolver",
          "partial": "Lt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Lt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algorithm.Simplex2\",\"Data.ArithRel\"]",
          "name": "NEq",
          "package": "toysolver",
          "signature": "NEq",
          "source": "src/Data-ArithRel.html#RelOp",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:NEq\",\"http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:NEq\"]"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "NEq",
          "package": "toysolver",
          "partial": "NEq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:NEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "ObjLimit",
          "package": "toysolver",
          "signature": "ObjLimit",
          "source": "src/Algorithm-Simplex2.html#OptResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "ObjLimit",
          "package": "toysolver",
          "partial": "Obj Limit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:ObjLimit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emaximization\n\u003c/p\u003e",
          "module": "[\"Algorithm.Simplex2\",\"Text.LPFile\"]",
          "name": "OptMax",
          "package": "toysolver",
          "signature": "OptMax",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:OptMax\",\"http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:OptMax\"]"
        },
        "index": {
          "description": "maximization",
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "OptMax",
          "package": "toysolver",
          "partial": "Opt Max",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:OptMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eminimization \n\u003c/p\u003e",
          "module": "[\"Algorithm.Simplex2\",\"Text.LPFile\"]",
          "name": "OptMin",
          "package": "toysolver",
          "signature": "OptMin",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:OptMin\",\"http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:OptMin\"]"
        },
        "index": {
          "description": "minimization",
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "OptMin",
          "package": "toysolver",
          "partial": "Opt Min",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:OptMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "Optimum",
          "package": "toysolver",
          "signature": "Optimum",
          "source": "src/Algorithm-Simplex2.html#OptResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Optimum",
          "package": "toysolver",
          "partial": "Optimum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Optimum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "Options",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/Algorithm-Simplex2.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "PivotStrategyBlandRule",
          "package": "toysolver",
          "signature": "PivotStrategyBlandRule",
          "source": "src/Algorithm-Simplex2.html#PivotStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "PivotStrategyBlandRule",
          "package": "toysolver",
          "partial": "Pivot Strategy Bland Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:PivotStrategyBlandRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "PivotStrategyLargestCoefficient",
          "package": "toysolver",
          "signature": "PivotStrategyLargestCoefficient",
          "source": "src/Algorithm-Simplex2.html#PivotStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "PivotStrategyLargestCoefficient",
          "package": "toysolver",
          "partial": "Pivot Strategy Largest Coefficient",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:PivotStrategyLargestCoefficient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "Unbounded",
          "package": "toysolver",
          "signature": "Unbounded",
          "source": "src/Algorithm-Simplex2.html#OptResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Unbounded",
          "package": "toysolver",
          "partial": "Unbounded",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Unbounded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "Unsat",
          "package": "toysolver",
          "signature": "Unsat",
          "source": "src/Algorithm-Simplex2.html#OptResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "Unsat",
          "package": "toysolver",
          "partial": "Unsat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Unsat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "assertAtom",
          "package": "toysolver",
          "signature": "Solver -\u003e Atom Rational -\u003e IO ()",
          "source": "src/Algorithm-Simplex2.html#assertAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "assertAtom",
          "normalized": "Solver-\u003eAtom Rational-\u003eIO()",
          "package": "toysolver",
          "partial": "Atom",
          "signature": "Solver-\u003eAtom Rational-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:assertAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "assertAtomEx",
          "package": "toysolver",
          "signature": "GenericSolver (Delta Rational) -\u003e Atom Rational -\u003e IO ()",
          "source": "src/Algorithm-Simplex2.html#assertAtomEx",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "assertAtomEx",
          "normalized": "GenericSolver(Delta Rational)-\u003eAtom Rational-\u003eIO()",
          "package": "toysolver",
          "partial": "Atom Ex",
          "signature": "GenericSolver(Delta Rational)-\u003eAtom Rational-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:assertAtomEx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "assertLower",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e Var -\u003e v -\u003e IO ()",
          "source": "src/Algorithm-Simplex2.html#assertLower",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "assertLower",
          "normalized": "GenericSolver a-\u003eVar-\u003ea-\u003eIO()",
          "package": "toysolver",
          "partial": "Lower",
          "signature": "GenericSolver v-\u003eVar-\u003ev-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:assertLower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "assertUpper",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e Var -\u003e v -\u003e IO ()",
          "source": "src/Algorithm-Simplex2.html#assertUpper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "assertUpper",
          "normalized": "GenericSolver a-\u003eVar-\u003ea-\u003eIO()",
          "package": "toysolver",
          "partial": "Upper",
          "signature": "GenericSolver v-\u003eVar-\u003ev-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:assertUpper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "check",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e IO Bool",
          "source": "src/Algorithm-Simplex2.html#check",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "check",
          "normalized": "GenericSolver a-\u003eIO Bool",
          "package": "toysolver",
          "signature": "GenericSolver v-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:check"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "clearLogger",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e IO ()",
          "source": "src/Algorithm-Simplex2.html#clearLogger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "clearLogger",
          "normalized": "GenericSolver a-\u003eIO()",
          "package": "toysolver",
          "partial": "Logger",
          "signature": "GenericSolver v-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:clearLogger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "cloneSolver",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e IO (GenericSolver v)",
          "source": "src/Algorithm-Simplex2.html#cloneSolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "cloneSolver",
          "normalized": "GenericSolver a-\u003eIO(GenericSolver a)",
          "package": "toysolver",
          "partial": "Solver",
          "signature": "GenericSolver v-\u003eIO(GenericSolver v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:cloneSolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "defaultOptions",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/Algorithm-Simplex2.html#defaultOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "defaultOptions",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:defaultOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "dualSimplex",
          "package": "toysolver",
          "signature": "Solver -\u003e Options -\u003e IO OptResult",
          "source": "src/Algorithm-Simplex2.html#dualSimplex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "dualSimplex",
          "normalized": "Solver-\u003eOptions-\u003eIO OptResult",
          "package": "toysolver",
          "partial": "Simplex",
          "signature": "Solver-\u003eOptions-\u003eIO OptResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:dualSimplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "dump",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e IO ()",
          "source": "src/Algorithm-Simplex2.html#dump",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "dump",
          "normalized": "GenericSolver a-\u003eIO()",
          "package": "toysolver",
          "signature": "GenericSolver v-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:dump"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "getCoeff",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e Var -\u003e Var -\u003e IO Rational",
          "source": "src/Algorithm-Simplex2.html#getCoeff",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "getCoeff",
          "normalized": "GenericSolver a-\u003eVar-\u003eVar-\u003eIO Rational",
          "package": "toysolver",
          "partial": "Coeff",
          "signature": "GenericSolver v-\u003eVar-\u003eVar-\u003eIO Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getCoeff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "getCol",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e Var -\u003e IO (IntMap Rational)",
          "source": "src/Algorithm-Simplex2.html#getCol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "getCol",
          "normalized": "GenericSolver a-\u003eVar-\u003eIO(IntMap Rational)",
          "package": "toysolver",
          "partial": "Col",
          "signature": "GenericSolver v-\u003eVar-\u003eIO(IntMap Rational)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "getLB",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e Var -\u003e IO (Maybe v)",
          "source": "src/Algorithm-Simplex2.html#getLB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "getLB",
          "normalized": "GenericSolver a-\u003eVar-\u003eIO(Maybe a)",
          "package": "toysolver",
          "partial": "LB",
          "signature": "GenericSolver v-\u003eVar-\u003eIO(Maybe v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getLB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "getObj",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e IO (Expr Rational)",
          "source": "src/Algorithm-Simplex2.html#getObj",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "getObj",
          "normalized": "GenericSolver a-\u003eIO(Expr Rational)",
          "package": "toysolver",
          "partial": "Obj",
          "signature": "GenericSolver v-\u003eIO(Expr Rational)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getObj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "getObjValue",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e IO v",
          "source": "src/Algorithm-Simplex2.html#getObjValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "getObjValue",
          "normalized": "GenericSolver a-\u003eIO a",
          "package": "toysolver",
          "partial": "Obj Value",
          "signature": "GenericSolver v-\u003eIO v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getObjValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "getOptDir",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e IO OptDir",
          "source": "src/Algorithm-Simplex2.html#getOptDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "getOptDir",
          "normalized": "GenericSolver a-\u003eIO OptDir",
          "package": "toysolver",
          "partial": "Opt Dir",
          "signature": "GenericSolver v-\u003eIO OptDir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getOptDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "getRow",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e Var -\u003e IO (Expr Rational)",
          "source": "src/Algorithm-Simplex2.html#getRow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "getRow",
          "normalized": "GenericSolver a-\u003eVar-\u003eIO(Expr Rational)",
          "package": "toysolver",
          "partial": "Row",
          "signature": "GenericSolver v-\u003eVar-\u003eIO(Expr Rational)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getRow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "getTableau",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e IO (IntMap (Expr Rational))",
          "source": "src/Algorithm-Simplex2.html#getTableau",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "getTableau",
          "normalized": "GenericSolver a-\u003eIO(IntMap(Expr Rational))",
          "package": "toysolver",
          "partial": "Tableau",
          "signature": "GenericSolver v-\u003eIO(IntMap(Expr Rational))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getTableau"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "getUB",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e Var -\u003e IO (Maybe v)",
          "source": "src/Algorithm-Simplex2.html#getUB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "getUB",
          "normalized": "GenericSolver a-\u003eVar-\u003eIO(Maybe a)",
          "package": "toysolver",
          "partial": "UB",
          "signature": "GenericSolver v-\u003eVar-\u003eIO(Maybe v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getUB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "getValue",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e Var -\u003e IO v",
          "source": "src/Algorithm-Simplex2.html#getValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "getValue",
          "normalized": "GenericSolver a-\u003eVar-\u003eIO a",
          "package": "toysolver",
          "partial": "Value",
          "signature": "GenericSolver v-\u003eVar-\u003eIO v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "isBasicVariable",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e Var -\u003e IO Bool",
          "source": "src/Algorithm-Simplex2.html#isBasicVariable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "isBasicVariable",
          "normalized": "GenericSolver a-\u003eVar-\u003eIO Bool",
          "package": "toysolver",
          "partial": "Basic Variable",
          "signature": "GenericSolver v-\u003eVar-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:isBasicVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "isFeasible",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e IO Bool",
          "source": "src/Algorithm-Simplex2.html#isFeasible",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "isFeasible",
          "normalized": "GenericSolver a-\u003eIO Bool",
          "package": "toysolver",
          "partial": "Feasible",
          "signature": "GenericSolver v-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:isFeasible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "isNonBasicVariable",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e Var -\u003e IO Bool",
          "source": "src/Algorithm-Simplex2.html#isNonBasicVariable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "isNonBasicVariable",
          "normalized": "GenericSolver a-\u003eVar-\u003eIO Bool",
          "package": "toysolver",
          "partial": "Non Basic Variable",
          "signature": "GenericSolver v-\u003eVar-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:isNonBasicVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "isOptimal",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e IO Bool",
          "source": "src/Algorithm-Simplex2.html#isOptimal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "isOptimal",
          "normalized": "GenericSolver a-\u003eIO Bool",
          "package": "toysolver",
          "partial": "Optimal",
          "signature": "GenericSolver v-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:isOptimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "model",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e IO Model",
          "source": "src/Algorithm-Simplex2.html#model",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "model",
          "normalized": "GenericSolver a-\u003eIO Model",
          "package": "toysolver",
          "signature": "GenericSolver v-\u003eIO Model",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:model"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "nVars",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e IO Int",
          "source": "src/Algorithm-Simplex2.html#nVars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "nVars",
          "normalized": "GenericSolver a-\u003eIO Int",
          "package": "toysolver",
          "partial": "Vars",
          "signature": "GenericSolver v-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:nVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "newSolver",
          "package": "toysolver",
          "signature": "IO (GenericSolver v)",
          "source": "src/Algorithm-Simplex2.html#newSolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "newSolver",
          "package": "toysolver",
          "partial": "Solver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:newSolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "newVar",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e IO Var",
          "source": "src/Algorithm-Simplex2.html#newVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "newVar",
          "normalized": "GenericSolver a-\u003eIO Var",
          "package": "toysolver",
          "partial": "Var",
          "signature": "GenericSolver v-\u003eIO Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:newVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "objLimit",
          "package": "toysolver",
          "signature": "Maybe Rational",
          "source": "src/Algorithm-Simplex2.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "objLimit",
          "package": "toysolver",
          "partial": "Limit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:objLimit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "optimize",
          "package": "toysolver",
          "signature": "Solver -\u003e Options -\u003e IO OptResult",
          "source": "src/Algorithm-Simplex2.html#optimize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "optimize",
          "normalized": "Solver-\u003eOptions-\u003eIO OptResult",
          "package": "toysolver",
          "signature": "Solver-\u003eOptions-\u003eIO OptResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:optimize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "rawModel",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e IO (RawModel v)",
          "source": "src/Algorithm-Simplex2.html#rawModel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "rawModel",
          "normalized": "GenericSolver a-\u003eIO(RawModel a)",
          "package": "toysolver",
          "partial": "Model",
          "signature": "GenericSolver v-\u003eIO(RawModel v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:rawModel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset callback function for receiving messages.\n\u003c/p\u003e",
          "module": "Algorithm.Simplex2",
          "name": "setLogger",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e (String -\u003e IO ()) -\u003e IO ()",
          "source": "src/Algorithm-Simplex2.html#setLogger",
          "type": "function"
        },
        "index": {
          "description": "set callback function for receiving messages",
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "setLogger",
          "normalized": "GenericSolver a-\u003e(String-\u003eIO())-\u003eIO()",
          "package": "toysolver",
          "partial": "Logger",
          "signature": "GenericSolver v-\u003e(String-\u003eIO())-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:setLogger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "setObj",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e Expr Rational -\u003e IO ()",
          "source": "src/Algorithm-Simplex2.html#setObj",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "setObj",
          "normalized": "GenericSolver a-\u003eExpr Rational-\u003eIO()",
          "package": "toysolver",
          "partial": "Obj",
          "signature": "GenericSolver v-\u003eExpr Rational-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:setObj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "setOptDir",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e OptDir -\u003e IO ()",
          "source": "src/Algorithm-Simplex2.html#setOptDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "setOptDir",
          "normalized": "GenericSolver a-\u003eOptDir-\u003eIO()",
          "package": "toysolver",
          "partial": "Opt Dir",
          "signature": "GenericSolver v-\u003eOptDir-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:setOptDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "setPivotStrategy",
          "package": "toysolver",
          "signature": "GenericSolver v -\u003e PivotStrategy -\u003e IO ()",
          "source": "src/Algorithm-Simplex2.html#setPivotStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "setPivotStrategy",
          "normalized": "GenericSolver a-\u003ePivotStrategy-\u003eIO()",
          "package": "toysolver",
          "partial": "Pivot Strategy",
          "signature": "GenericSolver v-\u003ePivotStrategy-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:setPivotStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "showValue",
          "package": "toysolver",
          "signature": "Bool -\u003e v -\u003e String",
          "source": "src/Algorithm-Simplex2.html#showValue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "showValue",
          "normalized": "Bool-\u003ea-\u003eString",
          "package": "toysolver",
          "partial": "Value",
          "signature": "Bool-\u003ev-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:showValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algorithm.Simplex2",
          "name": "toValue",
          "package": "toysolver",
          "signature": "Rational -\u003e v",
          "source": "src/Algorithm-Simplex2.html#toValue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algorithm Simplex2",
          "module": "Algorithm.Simplex2",
          "name": "toValue",
          "normalized": "Rational-\u003ea",
          "package": "toysolver",
          "partial": "Value",
          "signature": "Rational-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:toValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.LP2SMT",
          "name": "LP2SMT",
          "package": "toysolver",
          "source": "src/Converter-LP2SMT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Converter LP2SMT",
          "module": "Converter.LP2SMT",
          "name": "LP2SMT",
          "package": "toysolver",
          "partial": "LP SMT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.LP2SMT",
          "name": "Language",
          "package": "toysolver",
          "source": "src/Converter-LP2SMT.html#Language",
          "type": "data"
        },
        "index": {
          "hierarchy": "Converter LP2SMT",
          "module": "Converter.LP2SMT",
          "name": "Language",
          "package": "toysolver",
          "partial": "Language",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#t:Language"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.LP2SMT",
          "name": "Options",
          "package": "toysolver",
          "source": "src/Converter-LP2SMT.html#Options",
          "type": "data"
        },
        "index": {
          "hierarchy": "Converter LP2SMT",
          "module": "Converter.LP2SMT",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#t:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.LP2SMT",
          "name": "Options",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/Converter-LP2SMT.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter LP2SMT",
          "module": "Converter.LP2SMT",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.LP2SMT",
          "name": "SMTLIB2",
          "package": "toysolver",
          "signature": "SMTLIB2",
          "source": "src/Converter-LP2SMT.html#Language",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter LP2SMT",
          "module": "Converter.LP2SMT",
          "name": "SMTLIB2",
          "package": "toysolver",
          "partial": "SMTLIB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:SMTLIB2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.LP2SMT",
          "name": "YICES",
          "package": "toysolver",
          "signature": "YICES",
          "source": "src/Converter-LP2SMT.html#Language",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter LP2SMT",
          "module": "Converter.LP2SMT",
          "name": "YICES",
          "package": "toysolver",
          "partial": "YICES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:YICES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.LP2SMT",
          "name": "convert",
          "package": "toysolver",
          "signature": "Options -\u003e LP -\u003e ShowS",
          "source": "src/Converter-LP2SMT.html#convert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter LP2SMT",
          "module": "Converter.LP2SMT",
          "name": "convert",
          "normalized": "Options-\u003eLP-\u003eShowS",
          "package": "toysolver",
          "signature": "Options-\u003eLP-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.LP2SMT",
          "name": "defaultOptions",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/Converter-LP2SMT.html#defaultOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter LP2SMT",
          "module": "Converter.LP2SMT",
          "name": "defaultOptions",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:defaultOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.LP2SMT",
          "name": "optCheckSAT",
          "package": "toysolver",
          "signature": "Bool",
          "source": "src/Converter-LP2SMT.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter LP2SMT",
          "module": "Converter.LP2SMT",
          "name": "optCheckSAT",
          "package": "toysolver",
          "partial": "Check SAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:optCheckSAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.LP2SMT",
          "name": "optLanguage",
          "package": "toysolver",
          "signature": "Language",
          "source": "src/Converter-LP2SMT.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter LP2SMT",
          "module": "Converter.LP2SMT",
          "name": "optLanguage",
          "package": "toysolver",
          "partial": "Language",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:optLanguage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.LP2SMT",
          "name": "optOptimize",
          "package": "toysolver",
          "signature": "Bool",
          "source": "src/Converter-LP2SMT.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter LP2SMT",
          "module": "Converter.LP2SMT",
          "name": "optOptimize",
          "package": "toysolver",
          "partial": "Optimize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:optOptimize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.LP2SMT",
          "name": "optProduceModel",
          "package": "toysolver",
          "signature": "Bool",
          "source": "src/Converter-LP2SMT.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter LP2SMT",
          "module": "Converter.LP2SMT",
          "name": "optProduceModel",
          "package": "toysolver",
          "partial": "Produce Model",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:optProduceModel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.MaxSAT2LP",
          "name": "MaxSAT2LP",
          "package": "toysolver",
          "source": "src/Converter-MaxSAT2LP.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Converter MaxSAT2LP",
          "module": "Converter.MaxSAT2LP",
          "name": "MaxSAT2LP",
          "package": "toysolver",
          "partial": "Max SAT LP",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-MaxSAT2LP.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.MaxSAT2LP",
          "name": "convert",
          "package": "toysolver",
          "signature": "Bool -\u003e WCNF -\u003e (LP, Map Var Rational -\u003e Model)",
          "source": "src/Converter-MaxSAT2LP.html#convert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter MaxSAT2LP",
          "module": "Converter.MaxSAT2LP",
          "name": "convert",
          "normalized": "Bool-\u003eWCNF-\u003e(LP,Map Var Rational-\u003eModel)",
          "package": "toysolver",
          "signature": "Bool-\u003eWCNF-\u003e(LP,Map Var Rational-\u003eModel)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-MaxSAT2LP.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.MaxSAT2NLPB",
          "name": "MaxSAT2NLPB",
          "package": "toysolver",
          "source": "src/Converter-MaxSAT2NLPB.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Converter MaxSAT2NLPB",
          "module": "Converter.MaxSAT2NLPB",
          "name": "MaxSAT2NLPB",
          "package": "toysolver",
          "partial": "Max SAT NLPB",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-MaxSAT2NLPB.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.MaxSAT2NLPB",
          "name": "convert",
          "package": "toysolver",
          "signature": "WCNF -\u003e Formula",
          "source": "src/Converter-MaxSAT2NLPB.html#convert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter MaxSAT2NLPB",
          "module": "Converter.MaxSAT2NLPB",
          "name": "convert",
          "normalized": "WCNF-\u003eFormula",
          "package": "toysolver",
          "signature": "WCNF-\u003eFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-MaxSAT2NLPB.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.MaxSAT2WBO",
          "name": "MaxSAT2WBO",
          "package": "toysolver",
          "source": "src/Converter-MaxSAT2WBO.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Converter MaxSAT2WBO",
          "module": "Converter.MaxSAT2WBO",
          "name": "MaxSAT2WBO",
          "package": "toysolver",
          "partial": "Max SAT WBO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-MaxSAT2WBO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.MaxSAT2WBO",
          "name": "convert",
          "package": "toysolver",
          "signature": "WCNF -\u003e SoftFormula",
          "source": "src/Converter-MaxSAT2WBO.html#convert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter MaxSAT2WBO",
          "module": "Converter.MaxSAT2WBO",
          "name": "convert",
          "normalized": "WCNF-\u003eSoftFormula",
          "package": "toysolver",
          "signature": "WCNF-\u003eSoftFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-MaxSAT2WBO.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.ObjType",
          "name": "ObjType",
          "package": "toysolver",
          "source": "src/Converter-ObjType.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Converter ObjType",
          "module": "Converter.ObjType",
          "name": "ObjType",
          "package": "toysolver",
          "partial": "Obj Type",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-ObjType.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.ObjType",
          "name": "ObjType",
          "package": "toysolver",
          "source": "src/Converter-ObjType.html#ObjType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Converter ObjType",
          "module": "Converter.ObjType",
          "name": "ObjType",
          "package": "toysolver",
          "partial": "Obj Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-ObjType.html#t:ObjType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Converter.ObjType\",\"Converter.PBSetObj\"]",
          "name": "ObjMaxOne",
          "package": "toysolver",
          "signature": "ObjMaxOne",
          "source": "src/Converter-ObjType.html#ObjType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Converter-ObjType.html#v:ObjMaxOne\",\"http://hackage.haskell.org/package/toysolver/docs/Converter-PBSetObj.html#v:ObjMaxOne\"]"
        },
        "index": {
          "hierarchy": "Converter ObjType",
          "module": "Converter.ObjType",
          "name": "ObjMaxOne",
          "package": "toysolver",
          "partial": "Obj Max One",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-ObjType.html#v:ObjMaxOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Converter.ObjType\",\"Converter.PBSetObj\"]",
          "name": "ObjMaxZero",
          "package": "toysolver",
          "signature": "ObjMaxZero",
          "source": "src/Converter-ObjType.html#ObjType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Converter-ObjType.html#v:ObjMaxZero\",\"http://hackage.haskell.org/package/toysolver/docs/Converter-PBSetObj.html#v:ObjMaxZero\"]"
        },
        "index": {
          "hierarchy": "Converter ObjType",
          "module": "Converter.ObjType",
          "name": "ObjMaxZero",
          "package": "toysolver",
          "partial": "Obj Max Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-ObjType.html#v:ObjMaxZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Converter.ObjType\",\"Converter.PBSetObj\"]",
          "name": "ObjNone",
          "package": "toysolver",
          "signature": "ObjNone",
          "source": "src/Converter-ObjType.html#ObjType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/Converter-ObjType.html#v:ObjNone\",\"http://hackage.haskell.org/package/toysolver/docs/Converter-PBSetObj.html#v:ObjNone\"]"
        },
        "index": {
          "hierarchy": "Converter ObjType",
          "module": "Converter.ObjType",
          "name": "ObjNone",
          "package": "toysolver",
          "partial": "Obj None",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-ObjType.html#v:ObjNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.PB2LP",
          "name": "PB2LP",
          "package": "toysolver",
          "source": "src/Converter-PB2LP.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Converter PB2LP",
          "module": "Converter.PB2LP",
          "name": "PB2LP",
          "package": "toysolver",
          "partial": "PB LP",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2LP.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.PB2LP",
          "name": "convert",
          "package": "toysolver",
          "signature": "Formula -\u003e (LP, Map Var Rational -\u003e Model)",
          "source": "src/Converter-PB2LP.html#convert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter PB2LP",
          "module": "Converter.PB2LP",
          "name": "convert",
          "normalized": "Formula-\u003e(LP,Map Var Rational-\u003eModel)",
          "package": "toysolver",
          "signature": "Formula-\u003e(LP,Map Var Rational-\u003eModel)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2LP.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.PB2LP",
          "name": "convertWBO",
          "package": "toysolver",
          "signature": "Bool -\u003e SoftFormula -\u003e (LP, Map Var Rational -\u003e Model)",
          "source": "src/Converter-PB2LP.html#convertWBO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter PB2LP",
          "module": "Converter.PB2LP",
          "name": "convertWBO",
          "normalized": "Bool-\u003eSoftFormula-\u003e(LP,Map Var Rational-\u003eModel)",
          "package": "toysolver",
          "partial": "WBO",
          "signature": "Bool-\u003eSoftFormula-\u003e(LP,Map Var Rational-\u003eModel)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2LP.html#v:convertWBO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.PB2LSP",
          "name": "PB2LSP",
          "package": "toysolver",
          "source": "src/Converter-PB2LSP.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Converter PB2LSP",
          "module": "Converter.PB2LSP",
          "name": "PB2LSP",
          "package": "toysolver",
          "partial": "PB LSP",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2LSP.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.PB2LSP",
          "name": "convert",
          "package": "toysolver",
          "signature": "Formula -\u003e ShowS",
          "source": "src/Converter-PB2LSP.html#convert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter PB2LSP",
          "module": "Converter.PB2LSP",
          "name": "convert",
          "normalized": "Formula-\u003eShowS",
          "package": "toysolver",
          "signature": "Formula-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2LSP.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.PB2SMP",
          "name": "PB2SMP",
          "package": "toysolver",
          "source": "src/Converter-PB2SMP.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Converter PB2SMP",
          "module": "Converter.PB2SMP",
          "name": "PB2SMP",
          "package": "toysolver",
          "partial": "PB SMP",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2SMP.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.PB2SMP",
          "name": "convert",
          "package": "toysolver",
          "signature": "Bool -\u003e Formula -\u003e ShowS",
          "source": "src/Converter-PB2SMP.html#convert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter PB2SMP",
          "module": "Converter.PB2SMP",
          "name": "convert",
          "normalized": "Bool-\u003eFormula-\u003eShowS",
          "package": "toysolver",
          "signature": "Bool-\u003eFormula-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2SMP.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Improving Unsatisfiability-based Algorithms for Boolean Optimization\n   \u003ca\u003ehttp://sat.inesc-id.pt/~ruben/talks/sat10-talk.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Converter.PB2WBO",
          "name": "PB2WBO",
          "package": "toysolver",
          "source": "src/Converter-PB2WBO.html",
          "type": "module"
        },
        "index": {
          "description": "References Improving Unsatisfiability-based Algorithms for Boolean Optimization http sat.inesc-id.pt ruben talks sat10-talk.pdf",
          "hierarchy": "Converter PB2WBO",
          "module": "Converter.PB2WBO",
          "name": "PB2WBO",
          "package": "toysolver",
          "partial": "PB WBO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2WBO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.PB2WBO",
          "name": "convert",
          "package": "toysolver",
          "signature": "Formula -\u003e SoftFormula",
          "source": "src/Converter-PB2WBO.html#convert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter PB2WBO",
          "module": "Converter.PB2WBO",
          "name": "convert",
          "normalized": "Formula-\u003eSoftFormula",
          "package": "toysolver",
          "signature": "Formula-\u003eSoftFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2WBO.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.PBSetObj",
          "name": "PBSetObj",
          "package": "toysolver",
          "source": "src/Converter-PBSetObj.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Converter PBSetObj",
          "module": "Converter.PBSetObj",
          "name": "PBSetObj",
          "package": "toysolver",
          "partial": "PBSet Obj",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PBSetObj.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.PBSetObj",
          "name": "ObjType",
          "package": "toysolver",
          "source": "src/Converter-ObjType.html#ObjType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Converter PBSetObj",
          "module": "Converter.PBSetObj",
          "name": "ObjType",
          "package": "toysolver",
          "partial": "Obj Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PBSetObj.html#t:ObjType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.PBSetObj",
          "name": "setObj",
          "package": "toysolver",
          "signature": "ObjType -\u003e Formula -\u003e Formula",
          "source": "src/Converter-PBSetObj.html#setObj",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter PBSetObj",
          "module": "Converter.PBSetObj",
          "name": "setObj",
          "normalized": "ObjType-\u003eFormula-\u003eFormula",
          "package": "toysolver",
          "partial": "Obj",
          "signature": "ObjType-\u003eFormula-\u003eFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PBSetObj.html#v:setObj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.SAT2LP",
          "name": "SAT2LP",
          "package": "toysolver",
          "source": "src/Converter-SAT2LP.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Converter SAT2LP",
          "module": "Converter.SAT2LP",
          "name": "SAT2LP",
          "package": "toysolver",
          "partial": "SAT LP",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-SAT2LP.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.SAT2LP",
          "name": "convert",
          "package": "toysolver",
          "signature": "CNF -\u003e (LP, Map Var Rational -\u003e Model)",
          "source": "src/Converter-SAT2LP.html#convert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter SAT2LP",
          "module": "Converter.SAT2LP",
          "name": "convert",
          "normalized": "CNF-\u003e(LP,Map Var Rational-\u003eModel)",
          "package": "toysolver",
          "signature": "CNF-\u003e(LP,Map Var Rational-\u003eModel)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-SAT2LP.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.SAT2PB",
          "name": "SAT2PB",
          "package": "toysolver",
          "source": "src/Converter-SAT2PB.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Converter SAT2PB",
          "module": "Converter.SAT2PB",
          "name": "SAT2PB",
          "package": "toysolver",
          "partial": "SAT PB",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-SAT2PB.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.SAT2PB",
          "name": "convert",
          "package": "toysolver",
          "signature": "CNF -\u003e Formula",
          "source": "src/Converter-SAT2PB.html#convert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter SAT2PB",
          "module": "Converter.SAT2PB",
          "name": "convert",
          "normalized": "CNF-\u003eFormula",
          "package": "toysolver",
          "signature": "CNF-\u003eFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-SAT2PB.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.WBO2PB",
          "name": "WBO2PB",
          "package": "toysolver",
          "source": "src/Converter-WBO2PB.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Converter WBO2PB",
          "module": "Converter.WBO2PB",
          "name": "WBO2PB",
          "package": "toysolver",
          "partial": "WBO PB",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-WBO2PB.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Converter.WBO2PB",
          "name": "convert",
          "package": "toysolver",
          "signature": "SoftFormula -\u003e (Formula, Model -\u003e Model)",
          "source": "src/Converter-WBO2PB.html#convert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Converter WBO2PB",
          "module": "Converter.WBO2PB",
          "name": "convert",
          "normalized": "SoftFormula-\u003e(Formula,Model-\u003eModel)",
          "package": "toysolver",
          "signature": "SoftFormula-\u003e(Formula,Model-\u003eModel)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-WBO2PB.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAlgebraic reals\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Why the concept of a field extension is a natural one\n   \u003ca\u003ehttp://www.dpmms.cam.ac.uk/~wtg10/galois.html\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Data.AlgebraicNumber.Real",
          "name": "Real",
          "package": "toysolver",
          "source": "src/Data-AlgebraicNumber-Real.html",
          "type": "module"
        },
        "index": {
          "description": "Algebraic reals Reference Why the concept of field extension is natural one http www.dpmms.cam.ac.uk wtg10 galois.html",
          "hierarchy": "Data AlgebraicNumber Real",
          "module": "Data.AlgebraicNumber.Real",
          "name": "Real",
          "package": "toysolver",
          "partial": "Real",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlgebraic real numbers.\n\u003c/p\u003e",
          "module": "Data.AlgebraicNumber.Real",
          "name": "AReal",
          "package": "toysolver",
          "source": "src/Data-AlgebraicNumber-Real.html#AReal",
          "type": "data"
        },
        "index": {
          "description": "Algebraic real numbers",
          "hierarchy": "Data AlgebraicNumber Real",
          "module": "Data.AlgebraicNumber.Real",
          "name": "AReal",
          "package": "toysolver",
          "partial": "AReal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#t:AReal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns approximate rational value such that \u003ccode\u003eabs (a - approx a epsilon) \u003c= epsilon\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.AlgebraicNumber.Real",
          "name": "approx",
          "package": "toysolver",
          "signature": "AReal-\u003e Rational-\u003e Rational",
          "type": "function"
        },
        "index": {
          "description": "Returns approximate rational value such that abs approx epsilon epsilon",
          "hierarchy": "Data AlgebraicNumber Real",
          "module": "Data.AlgebraicNumber.Real",
          "name": "approx",
          "normalized": "AReal-\u003eRational-\u003eRational",
          "package": "toysolver",
          "signature": "AReal-\u003eRational-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:approx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns approximate interval such that \u003ccode\u003ewidth (approxInterval a epsilon) \u003c= epsilon\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.AlgebraicNumber.Real",
          "name": "approxInterval",
          "package": "toysolver",
          "signature": "AReal-\u003e Rational-\u003e Interval Rational",
          "type": "function"
        },
        "index": {
          "description": "Returns approximate interval such that width approxInterval epsilon epsilon",
          "hierarchy": "Data AlgebraicNumber Real",
          "module": "Data.AlgebraicNumber.Real",
          "name": "approxInterval",
          "normalized": "AReal-\u003eRational-\u003eInterval Rational",
          "package": "toysolver",
          "partial": "Interval",
          "signature": "AReal-\u003eRational-\u003eInterval Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:approxInterval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGolden ratio \n\u003c/p\u003e",
          "module": "Data.AlgebraicNumber.Real",
          "name": "goldenRatio",
          "package": "toysolver",
          "signature": "AReal",
          "source": "src/Data-AlgebraicNumber-Real.html#goldenRatio",
          "type": "function"
        },
        "index": {
          "description": "Golden ratio",
          "hierarchy": "Data AlgebraicNumber Real",
          "module": "Data.AlgebraicNumber.Real",
          "name": "goldenRatio",
          "package": "toysolver",
          "partial": "Ratio",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:goldenRatio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHeight of the algebraic number.\n\u003c/p\u003e\u003cp\u003eThe height of an algebraic number is the greatest absolute value of the\n coefficients of the irreducible and primitive polynomial with integral\n rational coefficients.\n\u003c/p\u003e",
          "module": "Data.AlgebraicNumber.Real",
          "name": "height",
          "package": "toysolver",
          "signature": "AReal -\u003e Integer",
          "source": "src/Data-AlgebraicNumber-Real.html#height",
          "type": "function"
        },
        "index": {
          "description": "Height of the algebraic number The height of an algebraic number is the greatest absolute value of the coefficients of the irreducible and primitive polynomial with integral rational coefficients",
          "hierarchy": "Data AlgebraicNumber Real",
          "module": "Data.AlgebraicNumber.Real",
          "name": "height",
          "normalized": "AReal-\u003eInteger",
          "package": "toysolver",
          "signature": "AReal-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:height"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether the algebraic number is a root of a polynomial with integer\n coefficients with leading coefficient \u003ccode\u003e1\u003c/code\u003e (a monic polynomial).\n\u003c/p\u003e",
          "module": "Data.AlgebraicNumber.Real",
          "name": "isAlgebraicInteger",
          "package": "toysolver",
          "signature": "AReal -\u003e Bool",
          "source": "src/Data-AlgebraicNumber-Real.html#isAlgebraicInteger",
          "type": "function"
        },
        "index": {
          "description": "Whether the algebraic number is root of polynomial with integer coefficients with leading coefficient monic polynomial",
          "hierarchy": "Data AlgebraicNumber Real",
          "module": "Data.AlgebraicNumber.Real",
          "name": "isAlgebraicInteger",
          "normalized": "AReal-\u003eBool",
          "package": "toysolver",
          "partial": "Algebraic Integer",
          "signature": "AReal-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:isAlgebraicInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether the algebraic number is a rational.\n\u003c/p\u003e",
          "module": "Data.AlgebraicNumber.Real",
          "name": "isRational",
          "package": "toysolver",
          "signature": "AReal -\u003e Bool",
          "source": "src/Data-AlgebraicNumber-Real.html#isRational",
          "type": "function"
        },
        "index": {
          "description": "Whether the algebraic number is rational",
          "hierarchy": "Data AlgebraicNumber Real",
          "module": "Data.AlgebraicNumber.Real",
          "name": "isRational",
          "normalized": "AReal-\u003eBool",
          "package": "toysolver",
          "partial": "Rational",
          "signature": "AReal-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:isRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe polynomial of which the algebraic number is root.\n\u003c/p\u003e",
          "module": "Data.AlgebraicNumber.Real",
          "name": "minimalPolynomial",
          "package": "toysolver",
          "signature": "AReal -\u003e UPolynomial Rational",
          "source": "src/Data-AlgebraicNumber-Real.html#minimalPolynomial",
          "type": "function"
        },
        "index": {
          "description": "The polynomial of which the algebraic number is root",
          "hierarchy": "Data AlgebraicNumber Real",
          "module": "Data.AlgebraicNumber.Real",
          "name": "minimalPolynomial",
          "normalized": "AReal-\u003eUPolynomial Rational",
          "package": "toysolver",
          "partial": "Polynomial",
          "signature": "AReal-\u003eUPolynomial Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:minimalPolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003en\u003c/code\u003eth root of \u003ccode\u003ea\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.AlgebraicNumber.Real",
          "name": "nthRoot",
          "package": "toysolver",
          "signature": "Integer -\u003e AReal -\u003e AReal",
          "source": "src/Data-AlgebraicNumber-Real.html#nthRoot",
          "type": "function"
        },
        "index": {
          "description": "The th root of",
          "hierarchy": "Data AlgebraicNumber Real",
          "module": "Data.AlgebraicNumber.Real",
          "name": "nthRoot",
          "normalized": "Integer-\u003eAReal-\u003eAReal",
          "package": "toysolver",
          "partial": "Root",
          "signature": "Integer-\u003eAReal-\u003eAReal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:nthRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReal roots of the polynomial in ascending order.\n\u003c/p\u003e",
          "module": "Data.AlgebraicNumber.Real",
          "name": "realRoots",
          "package": "toysolver",
          "signature": "UPolynomial Rational -\u003e [AReal]",
          "source": "src/Data-AlgebraicNumber-Real.html#realRoots",
          "type": "function"
        },
        "index": {
          "description": "Real roots of the polynomial in ascending order",
          "hierarchy": "Data AlgebraicNumber Real",
          "module": "Data.AlgebraicNumber.Real",
          "name": "realRoots",
          "normalized": "UPolynomial Rational-\u003e[AReal]",
          "package": "toysolver",
          "partial": "Roots",
          "signature": "UPolynomial Rational-\u003e[AReal]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:realRoots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReal roots of the polynomial in ascending order.\n\u003c/p\u003e",
          "module": "Data.AlgebraicNumber.Real",
          "name": "realRootsEx",
          "package": "toysolver",
          "signature": "UPolynomial AReal -\u003e [AReal]",
          "source": "src/Data-AlgebraicNumber-Real.html#realRootsEx",
          "type": "function"
        },
        "index": {
          "description": "Real roots of the polynomial in ascending order",
          "hierarchy": "Data AlgebraicNumber Real",
          "module": "Data.AlgebraicNumber.Real",
          "name": "realRootsEx",
          "normalized": "UPolynomial AReal-\u003e[AReal]",
          "package": "toysolver",
          "partial": "Roots Ex",
          "signature": "UPolynomial AReal-\u003e[AReal]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:realRootsEx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eroot index, satisfying\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003erealRoots\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eminimalPolynomial\u003c/a\u003e\u003c/code\u003e a) !! rootIndex a == a\n\u003c/pre\u003e",
          "module": "Data.AlgebraicNumber.Real",
          "name": "rootIndex",
          "package": "toysolver",
          "signature": "AReal -\u003e Int",
          "source": "src/Data-AlgebraicNumber-Real.html#rootIndex",
          "type": "function"
        },
        "index": {
          "description": "root index satisfying realRoots minimalPolynomial rootIndex",
          "hierarchy": "Data AlgebraicNumber Real",
          "module": "Data.AlgebraicNumber.Real",
          "name": "rootIndex",
          "normalized": "AReal-\u003eInt",
          "package": "toysolver",
          "partial": "Index",
          "signature": "AReal-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:rootIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AlgebraicNumber.Real",
          "name": "simpARealPoly",
          "package": "toysolver",
          "signature": "UPolynomial AReal -\u003e UPolynomial Rational",
          "source": "src/Data-AlgebraicNumber-Real.html#simpARealPoly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AlgebraicNumber Real",
          "module": "Data.AlgebraicNumber.Real",
          "name": "simpARealPoly",
          "normalized": "UPolynomial AReal-\u003eUPolynomial Rational",
          "package": "toysolver",
          "partial": "AReal Poly",
          "signature": "UPolynomial AReal-\u003eUPolynomial Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:simpARealPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eManipulating polynomials for corresponding operations for algebraic numbers.\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.dpmms.cam.ac.uk/~wtg10/galois.html\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Data.AlgebraicNumber.Root",
          "name": "Root",
          "package": "toysolver",
          "source": "src/Data-AlgebraicNumber-Root.html",
          "type": "module"
        },
        "index": {
          "description": "Manipulating polynomials for corresponding operations for algebraic numbers Reference http www.dpmms.cam.ac.uk wtg10 galois.html",
          "hierarchy": "Data AlgebraicNumber Root",
          "module": "Data.AlgebraicNumber.Root",
          "name": "Root",
          "package": "toysolver",
          "partial": "Root",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AlgebraicNumber.Root",
          "name": "Var",
          "package": "toysolver",
          "source": "src/Data-AlgebraicNumber-Root.html#Var",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data AlgebraicNumber Root",
          "module": "Data.AlgebraicNumber.Root",
          "name": "Var",
          "package": "toysolver",
          "partial": "Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AlgebraicNumber.Root",
          "name": "findPoly",
          "package": "toysolver",
          "signature": "Polynomial Rational Var -\u003e [Polynomial Rational Var] -\u003e UPolynomial Rational",
          "source": "src/Data-AlgebraicNumber-Root.html#findPoly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AlgebraicNumber Root",
          "module": "Data.AlgebraicNumber.Root",
          "name": "findPoly",
          "normalized": "Polynomial Rational Var-\u003e[Polynomial Rational Var]-\u003eUPolynomial Rational",
          "package": "toysolver",
          "partial": "Poly",
          "signature": "Polynomial Rational Var-\u003e[Polynomial Rational Var]-\u003eUPolynomial Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:findPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AlgebraicNumber.Root",
          "name": "lift2",
          "package": "toysolver",
          "signature": "a -\u003e a -\u003e a) -\u003e UPolynomial Rational -\u003e UPolynomial Rational -\u003e UPolynomial Rational",
          "source": "src/Data-AlgebraicNumber-Root.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AlgebraicNumber Root",
          "module": "Data.AlgebraicNumber.Root",
          "name": "lift2",
          "normalized": "a-\u003ea-\u003ea)-\u003eUPolynomial Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
          "package": "toysolver",
          "signature": "a-\u003ea-\u003ea)-\u003eUPolynomial Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AlgebraicNumber.Root",
          "name": "normalizePoly",
          "package": "toysolver",
          "signature": "UPolynomial Rational -\u003e UPolynomial Rational",
          "source": "src/Data-AlgebraicNumber-Root.html#normalizePoly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AlgebraicNumber Root",
          "module": "Data.AlgebraicNumber.Root",
          "name": "normalizePoly",
          "normalized": "UPolynomial Rational-\u003eUPolynomial Rational",
          "package": "toysolver",
          "partial": "Poly",
          "signature": "UPolynomial Rational-\u003eUPolynomial Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:normalizePoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AlgebraicNumber.Root",
          "name": "rootAdd",
          "package": "toysolver",
          "signature": "UPolynomial Rational -\u003e UPolynomial Rational -\u003e UPolynomial Rational",
          "source": "src/Data-AlgebraicNumber-Root.html#rootAdd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AlgebraicNumber Root",
          "module": "Data.AlgebraicNumber.Root",
          "name": "rootAdd",
          "normalized": "UPolynomial Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
          "package": "toysolver",
          "partial": "Add",
          "signature": "UPolynomial Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:rootAdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AlgebraicNumber.Root",
          "name": "rootMul",
          "package": "toysolver",
          "signature": "UPolynomial Rational -\u003e UPolynomial Rational -\u003e UPolynomial Rational",
          "source": "src/Data-AlgebraicNumber-Root.html#rootMul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AlgebraicNumber Root",
          "module": "Data.AlgebraicNumber.Root",
          "name": "rootMul",
          "normalized": "UPolynomial Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
          "package": "toysolver",
          "partial": "Mul",
          "signature": "UPolynomial Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:rootMul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AlgebraicNumber.Root",
          "name": "rootNthRoot",
          "package": "toysolver",
          "signature": "Integer -\u003e UPolynomial Rational -\u003e UPolynomial Rational",
          "source": "src/Data-AlgebraicNumber-Root.html#rootNthRoot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AlgebraicNumber Root",
          "module": "Data.AlgebraicNumber.Root",
          "name": "rootNthRoot",
          "normalized": "Integer-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
          "package": "toysolver",
          "partial": "Nth Root",
          "signature": "Integer-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:rootNthRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AlgebraicNumber.Root",
          "name": "rootRecip",
          "package": "toysolver",
          "signature": "UPolynomial Rational -\u003e UPolynomial Rational",
          "source": "src/Data-AlgebraicNumber-Root.html#rootRecip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AlgebraicNumber Root",
          "module": "Data.AlgebraicNumber.Root",
          "name": "rootRecip",
          "normalized": "UPolynomial Rational-\u003eUPolynomial Rational",
          "package": "toysolver",
          "partial": "Recip",
          "signature": "UPolynomial Rational-\u003eUPolynomial Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:rootRecip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AlgebraicNumber.Root",
          "name": "rootScale",
          "package": "toysolver",
          "signature": "Rational -\u003e UPolynomial Rational -\u003e UPolynomial Rational",
          "source": "src/Data-AlgebraicNumber-Root.html#rootScale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AlgebraicNumber Root",
          "module": "Data.AlgebraicNumber.Root",
          "name": "rootScale",
          "normalized": "Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
          "package": "toysolver",
          "partial": "Scale",
          "signature": "Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:rootScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AlgebraicNumber.Root",
          "name": "rootShift",
          "package": "toysolver",
          "signature": "Rational -\u003e UPolynomial Rational -\u003e UPolynomial Rational",
          "source": "src/Data-AlgebraicNumber-Root.html#rootShift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AlgebraicNumber Root",
          "module": "Data.AlgebraicNumber.Root",
          "name": "rootShift",
          "normalized": "Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
          "package": "toysolver",
          "partial": "Shift",
          "signature": "Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:rootShift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AlgebraicNumber.Root",
          "name": "rootSimpPoly",
          "package": "toysolver",
          "signature": "(a -\u003e UPolynomial Rational) -\u003e UPolynomial a -\u003e UPolynomial Rational",
          "source": "src/Data-AlgebraicNumber-Root.html#rootSimpPoly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AlgebraicNumber Root",
          "module": "Data.AlgebraicNumber.Root",
          "name": "rootSimpPoly",
          "normalized": "(a-\u003eUPolynomial Rational)-\u003eUPolynomial a-\u003eUPolynomial Rational",
          "package": "toysolver",
          "partial": "Simp Poly",
          "signature": "(a-\u003eUPolynomial Rational)-\u003eUPolynomial a-\u003eUPolynomial Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:rootSimpPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eArithmetic relations\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.ArithRel",
          "name": "ArithRel",
          "package": "toysolver",
          "source": "src/Data-ArithRel.html",
          "type": "module"
        },
        "index": {
          "description": "Arithmetic relations",
          "hierarchy": "Data ArithRel",
          "module": "Data.ArithRel",
          "name": "ArithRel",
          "package": "toysolver",
          "partial": "Arith Rel",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype class for constructing relational formula\n\u003c/p\u003e",
          "module": "Data.ArithRel",
          "name": "IsRel",
          "package": "toysolver",
          "source": "src/Data-ArithRel.html#IsRel",
          "type": "class"
        },
        "index": {
          "description": "type class for constructing relational formula",
          "hierarchy": "Data ArithRel",
          "module": "Data.ArithRel",
          "name": "IsRel",
          "package": "toysolver",
          "partial": "Is Rel",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#t:IsRel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAtomic formula\n\u003c/p\u003e",
          "module": "Data.ArithRel",
          "name": "Rel",
          "package": "toysolver",
          "source": "src/Data-ArithRel.html#Rel",
          "type": "data"
        },
        "index": {
          "description": "Atomic formula",
          "hierarchy": "Data ArithRel",
          "module": "Data.ArithRel",
          "name": "Rel",
          "package": "toysolver",
          "partial": "Rel",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#t:Rel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erelational operators\n\u003c/p\u003e",
          "module": "Data.ArithRel",
          "name": "RelOp",
          "package": "toysolver",
          "source": "src/Data-ArithRel.html#RelOp",
          "type": "data"
        },
        "index": {
          "description": "relational operators",
          "hierarchy": "Data ArithRel",
          "module": "Data.ArithRel",
          "name": "RelOp",
          "package": "toysolver",
          "partial": "Rel Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#t:RelOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
          "module": "Data.ArithRel",
          "name": "(./=.)",
          "package": "toysolver",
          "signature": "e -\u003e e -\u003e r",
          "source": "src/Data-ArithRel.html#.%2F%3D.",
          "type": "function"
        },
        "index": {
          "description": "constructing relational formula",
          "hierarchy": "Data ArithRel",
          "module": "Data.ArithRel",
          "name": "(./=.) ./=.",
          "normalized": "a-\u003ea-\u003eb",
          "package": "toysolver",
          "signature": "e-\u003ee-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:.-47--61-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.ArithRel",
          "name": "Rel",
          "package": "toysolver",
          "signature": "Rel e RelOp e",
          "source": "src/Data-ArithRel.html#Rel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data ArithRel",
          "module": "Data.ArithRel",
          "name": "Rel",
          "package": "toysolver",
          "partial": "Rel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:Rel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eevaluate an operator into a comparision function\n\u003c/p\u003e",
          "module": "Data.ArithRel",
          "name": "evalOp",
          "package": "toysolver",
          "signature": "RelOp -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Data-ArithRel.html#evalOp",
          "type": "function"
        },
        "index": {
          "description": "evaluate an operator into comparision function",
          "hierarchy": "Data ArithRel",
          "module": "Data.ArithRel",
          "name": "evalOp",
          "normalized": "RelOp-\u003ea-\u003ea-\u003eBool",
          "package": "toysolver",
          "partial": "Op",
          "signature": "RelOp-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:evalOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eflipping relational operator\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003erel (flipOp op) a b\u003c/code\u003e is equivalent to \u003ccode\u003erel op b a\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.ArithRel",
          "name": "flipOp",
          "package": "toysolver",
          "signature": "RelOp -\u003e RelOp",
          "source": "src/Data-ArithRel.html#flipOp",
          "type": "function"
        },
        "index": {
          "description": "flipping relational operator rel flipOp op is equivalent to rel op",
          "hierarchy": "Data ArithRel",
          "module": "Data.ArithRel",
          "name": "flipOp",
          "normalized": "RelOp-\u003eRelOp",
          "package": "toysolver",
          "partial": "Op",
          "signature": "RelOp-\u003eRelOp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:flipOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enegating relational operator\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003erel (negOp op) a b\u003c/code\u003e is equivalent to \u003ccode\u003enotB (rel op a b)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.ArithRel",
          "name": "negOp",
          "package": "toysolver",
          "signature": "RelOp -\u003e RelOp",
          "source": "src/Data-ArithRel.html#negOp",
          "type": "function"
        },
        "index": {
          "description": "negating relational operator rel negOp op is equivalent to notB rel op",
          "hierarchy": "Data ArithRel",
          "module": "Data.ArithRel",
          "name": "negOp",
          "normalized": "RelOp-\u003eRelOp",
          "package": "toysolver",
          "partial": "Op",
          "signature": "RelOp-\u003eRelOp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:negOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.ArithRel",
          "name": "rel",
          "package": "toysolver",
          "signature": "RelOp -\u003e e -\u003e e -\u003e r",
          "source": "src/Data-ArithRel.html#rel",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data ArithRel",
          "module": "Data.ArithRel",
          "name": "rel",
          "normalized": "RelOp-\u003ea-\u003ea-\u003eb",
          "package": "toysolver",
          "signature": "RelOp-\u003ee-\u003ee-\u003er",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:rel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoperator symbol\n\u003c/p\u003e",
          "module": "Data.ArithRel",
          "name": "showOp",
          "package": "toysolver",
          "signature": "RelOp -\u003e String",
          "source": "src/Data-ArithRel.html#showOp",
          "type": "function"
        },
        "index": {
          "description": "operator symbol",
          "hierarchy": "Data ArithRel",
          "module": "Data.ArithRel",
          "name": "showOp",
          "normalized": "RelOp-\u003eString",
          "package": "toysolver",
          "partial": "Op",
          "signature": "RelOp-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:showOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDisjunctive Normal Form\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.DNF",
          "name": "DNF",
          "package": "toysolver",
          "source": "src/Data-DNF.html",
          "type": "module"
        },
        "index": {
          "description": "Disjunctive Normal Form",
          "hierarchy": "Data DNF",
          "module": "Data.DNF",
          "name": "DNF",
          "package": "toysolver",
          "partial": "DNF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-DNF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisjunctive normal form\n\u003c/p\u003e",
          "module": "Data.DNF",
          "name": "DNF",
          "package": "toysolver",
          "source": "src/Data-DNF.html#DNF",
          "type": "newtype"
        },
        "index": {
          "description": "Disjunctive normal form",
          "hierarchy": "Data DNF",
          "module": "Data.DNF",
          "name": "DNF",
          "package": "toysolver",
          "partial": "DNF",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-DNF.html#t:DNF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.DNF",
          "name": "DNF",
          "package": "toysolver",
          "signature": "DNF",
          "source": "src/Data-DNF.html#DNF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data DNF",
          "module": "Data.DNF",
          "name": "DNF",
          "package": "toysolver",
          "partial": "DNF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-DNF.html#v:DNF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist of conjunction of literals\n\u003c/p\u003e",
          "module": "Data.DNF",
          "name": "unDNF",
          "package": "toysolver",
          "signature": "[[lit]]",
          "source": "src/Data-DNF.html#DNF",
          "type": "function"
        },
        "index": {
          "description": "list of conjunction of literals",
          "hierarchy": "Data DNF",
          "module": "Data.DNF",
          "name": "unDNF",
          "normalized": "[[a]]",
          "package": "toysolver",
          "partial": "DNF",
          "signature": "[[lit]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-DNF.html#v:unDNF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAugmenting number types with infinitesimal parameter &#948;.\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Bruno Dutertre and Leonardo de Moura,\n   \"\u003cem\u003eA Fast Linear-Arithmetic Solver for DPLL(T)\u003c/em\u003e\",\n   Computer Aided Verification In Computer Aided Verification, Vol. 4144\n   (2006), pp. 81-94.\n   \u003ca\u003ehttp://dx.doi.org/10.1007/11817963_11\u003c/a\u003e\n   \u003ca\u003ehttp://yices.csl.sri.com/cav06.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Data.Delta",
          "name": "Delta",
          "package": "toysolver",
          "source": "src/Data-Delta.html",
          "type": "module"
        },
        "index": {
          "description": "Augmenting number types with infinitesimal parameter Reference Bruno Dutertre and Leonardo de Moura Fast Linear-Arithmetic Solver for DPLL Computer Aided Verification In Computer Aided Verification Vol pp http dx.doi.org http yices.csl.sri.com cav06.pdf",
          "hierarchy": "Data Delta",
          "module": "Data.Delta",
          "name": "Delta",
          "package": "toysolver",
          "partial": "Delta",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eDelta r k\u003c/code\u003e represents r + k&#948; for symbolic infinitesimal parameter &#948;.\n\u003c/p\u003e",
          "module": "Data.Delta",
          "name": "Delta",
          "package": "toysolver",
          "source": "src/Data-Delta.html#Delta",
          "type": "data"
        },
        "index": {
          "description": "Delta represents for symbolic infinitesimal parameter",
          "hierarchy": "Data Delta",
          "module": "Data.Delta",
          "name": "Delta",
          "package": "toysolver",
          "partial": "Delta",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#t:Delta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Delta",
          "name": "Delta",
          "package": "toysolver",
          "signature": "Delta !r !r",
          "source": "src/Data-Delta.html#Delta",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Delta",
          "module": "Data.Delta",
          "name": "Delta",
          "package": "toysolver",
          "partial": "Delta",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:Delta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eDelta\u003c/a\u003e\u003c/code\u003e version of \u003ccode\u003e\u003ca\u003eceiling\u003c/a\u003e\u003c/code\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eceiling'\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e returns the least integer not less than \u003ccode\u003ex\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Delta",
          "name": "ceiling'",
          "package": "toysolver",
          "signature": "Delta r -\u003e a",
          "source": "src/Data-Delta.html#ceiling%27",
          "type": "function"
        },
        "index": {
          "description": "Delta version of ceiling ceiling returns the least integer not less than",
          "hierarchy": "Data Delta",
          "module": "Data.Delta",
          "name": "ceiling'",
          "normalized": "Delta a-\u003eb",
          "package": "toysolver",
          "signature": "Delta r-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:ceiling-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esymbolic infinitesimal parameter &#948;.\n\u003c/p\u003e",
          "module": "Data.Delta",
          "name": "delta",
          "package": "toysolver",
          "signature": "Delta r",
          "source": "src/Data-Delta.html#delta",
          "type": "function"
        },
        "index": {
          "description": "symbolic infinitesimal parameter",
          "hierarchy": "Data Delta",
          "module": "Data.Delta",
          "name": "delta",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:delta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtracts the &#948; part..\n\u003c/p\u003e",
          "module": "Data.Delta",
          "name": "deltaPart",
          "package": "toysolver",
          "signature": "Delta r -\u003e r",
          "source": "src/Data-Delta.html#deltaPart",
          "type": "function"
        },
        "index": {
          "description": "Extracts the part",
          "hierarchy": "Data Delta",
          "module": "Data.Delta",
          "name": "deltaPart",
          "normalized": "Delta a-\u003ea",
          "package": "toysolver",
          "partial": "Part",
          "signature": "Delta r-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:deltaPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eDelta\u003c/a\u003e\u003c/code\u003e version of \u003ccode\u003e\u003ca\u003efloor\u003c/a\u003e\u003c/code\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003efloor'\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e returns the greatest integer not greater than \u003ccode\u003ex\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Delta",
          "name": "floor'",
          "package": "toysolver",
          "signature": "Delta r -\u003e a",
          "source": "src/Data-Delta.html#floor%27",
          "type": "function"
        },
        "index": {
          "description": "Delta version of floor floor returns the greatest integer not greater than",
          "hierarchy": "Data Delta",
          "module": "Data.Delta",
          "name": "floor'",
          "normalized": "Delta a-\u003eb",
          "package": "toysolver",
          "signature": "Delta r-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:floor-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion from a base \u003ccode\u003er\u003c/code\u003e value to \u003ccode\u003eDelta r\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Delta",
          "name": "fromReal",
          "package": "toysolver",
          "signature": "r -\u003e Delta r",
          "source": "src/Data-Delta.html#fromReal",
          "type": "function"
        },
        "index": {
          "description": "Conversion from base value to Delta",
          "hierarchy": "Data Delta",
          "module": "Data.Delta",
          "name": "fromReal",
          "normalized": "a-\u003eDelta a",
          "package": "toysolver",
          "partial": "Real",
          "signature": "r-\u003eDelta r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:fromReal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs this a integer?\n\u003c/p\u003e",
          "module": "Data.Delta",
          "name": "isInteger'",
          "package": "toysolver",
          "signature": "Delta r -\u003e Bool",
          "source": "src/Data-Delta.html#isInteger%27",
          "type": "function"
        },
        "index": {
          "description": "Is this integer",
          "hierarchy": "Data Delta",
          "module": "Data.Delta",
          "name": "isInteger'",
          "normalized": "Delta a-\u003eBool",
          "package": "toysolver",
          "partial": "Integer'",
          "signature": "Delta r-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:isInteger-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtracts the real part..\n\u003c/p\u003e",
          "module": "Data.Delta",
          "name": "realPart",
          "package": "toysolver",
          "signature": "Delta r -\u003e r",
          "source": "src/Data-Delta.html#realPart",
          "type": "function"
        },
        "index": {
          "description": "Extracts the real part",
          "hierarchy": "Data Delta",
          "module": "Data.Delta",
          "name": "realPart",
          "normalized": "Delta a-\u003ea",
          "package": "toysolver",
          "partial": "Part",
          "signature": "Delta r-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:realPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eArithmetic language (not limited to linear ones).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.FOL.Arith",
          "name": "Arith",
          "package": "toysolver",
          "source": "src/Data-FOL-Arith.html",
          "type": "module"
        },
        "index": {
          "description": "Arithmetic language not limited to linear ones",
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": "Arith",
          "package": "toysolver",
          "partial": "Arith",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAtomic formula\n\u003c/p\u003e",
          "module": "Data.FOL.Arith",
          "name": "Atom",
          "package": "toysolver",
          "source": "src/Data-FOL-Arith.html#Atom",
          "type": "type"
        },
        "index": {
          "description": "Atomic formula",
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": "Atom",
          "package": "toysolver",
          "partial": "Atom",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#t:Atom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArithmetic expressions\n\u003c/p\u003e",
          "module": "Data.FOL.Arith",
          "name": "Expr",
          "package": "toysolver",
          "source": "src/Data-FOL-Arith.html#Expr",
          "type": "data"
        },
        "index": {
          "description": "Arithmetic expressions",
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": "Expr",
          "package": "toysolver",
          "partial": "Expr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#t:Expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eresults of satisfiability checking\n\u003c/p\u003e",
          "module": "Data.FOL.Arith",
          "name": "SatResult",
          "package": "toysolver",
          "source": "src/Data-FOL-Arith.html#SatResult",
          "type": "data"
        },
        "index": {
          "description": "results of satisfiability checking",
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": "SatResult",
          "package": "toysolver",
          "partial": "Sat Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#t:SatResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Arith",
          "name": ":*:",
          "package": "toysolver",
          "signature": "(Expr r) :*: (Expr r)",
          "source": "src/Data-FOL-Arith.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": ":*:",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Arith",
          "name": ":+:",
          "package": "toysolver",
          "signature": "(Expr r) :+: (Expr r)",
          "source": "src/Data-FOL-Arith.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": ":+:",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v::-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Arith",
          "name": ":/:",
          "package": "toysolver",
          "signature": "(Expr r) :/: (Expr r)",
          "source": "src/Data-FOL-Arith.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": ":/:",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v::-47-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Arith",
          "name": "Const",
          "package": "toysolver",
          "signature": "Const r",
          "source": "src/Data-FOL-Arith.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": "Const",
          "package": "toysolver",
          "partial": "Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Arith",
          "name": "Sat",
          "package": "toysolver",
          "signature": "Sat (Model r)",
          "source": "src/Data-FOL-Arith.html#SatResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": "Sat",
          "package": "toysolver",
          "partial": "Sat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:Sat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Arith",
          "name": "Unknown",
          "package": "toysolver",
          "signature": "Unknown",
          "source": "src/Data-FOL-Arith.html#SatResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": "Unknown",
          "package": "toysolver",
          "partial": "Unknown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:Unknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Arith",
          "name": "Unsat",
          "package": "toysolver",
          "signature": "Unsat",
          "source": "src/Data-FOL-Arith.html#SatResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": "Unsat",
          "package": "toysolver",
          "partial": "Unsat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:Unsat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Arith",
          "name": "Var",
          "package": "toysolver",
          "signature": "Var Var",
          "source": "src/Data-FOL-Arith.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": "Var",
          "package": "toysolver",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Arith",
          "name": "evalAtom",
          "package": "toysolver",
          "signature": "Model r -\u003e Atom r -\u003e Bool",
          "source": "src/Data-FOL-Arith.html#evalAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": "evalAtom",
          "normalized": "Model a-\u003eAtom a-\u003eBool",
          "package": "toysolver",
          "partial": "Atom",
          "signature": "Model r-\u003eAtom r-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:evalAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eevaluate an \u003ccode\u003e\u003ca\u003eExpr\u003c/a\u003e\u003c/code\u003e with respect to a \u003ccode\u003e\u003ca\u003eModel\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.FOL.Arith",
          "name": "evalExpr",
          "package": "toysolver",
          "signature": "Model r -\u003e Expr r -\u003e r",
          "source": "src/Data-FOL-Arith.html#evalExpr",
          "type": "function"
        },
        "index": {
          "description": "evaluate an Expr with respect to Model",
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": "evalExpr",
          "normalized": "Model a-\u003eExpr a-\u003ea",
          "package": "toysolver",
          "partial": "Expr",
          "signature": "Model r-\u003eExpr r-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:evalExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esingle variable expression\n\u003c/p\u003e",
          "module": "Data.FOL.Arith",
          "name": "var",
          "package": "toysolver",
          "signature": "Var -\u003e Expr r",
          "source": "src/Data-FOL-Arith.html#var",
          "type": "function"
        },
        "index": {
          "description": "single variable expression",
          "hierarchy": "Data FOL Arith",
          "module": "Data.FOL.Arith",
          "name": "var",
          "normalized": "Var-\u003eExpr a",
          "package": "toysolver",
          "signature": "Var-\u003eExpr r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFormula of first order logic.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.FOL.Formula",
          "name": "Formula",
          "package": "toysolver",
          "source": "src/Data-FOL-Formula.html",
          "type": "module"
        },
        "index": {
          "description": "Formula of first order logic",
          "hierarchy": "Data FOL Formula",
          "module": "Data.FOL.Formula",
          "name": "Formula",
          "package": "toysolver",
          "partial": "Formula",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eformulas of first order logic\n\u003c/p\u003e",
          "module": "Data.FOL.Formula",
          "name": "Formula",
          "package": "toysolver",
          "source": "src/Data-FOL-Formula.html#Formula",
          "type": "data"
        },
        "index": {
          "description": "formulas of first order logic",
          "hierarchy": "Data FOL Formula",
          "module": "Data.FOL.Formula",
          "name": "Formula",
          "package": "toysolver",
          "partial": "Formula",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#t:Formula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Formula",
          "name": "And",
          "package": "toysolver",
          "signature": "And (Formula a) (Formula a)",
          "source": "src/Data-FOL-Formula.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Formula",
          "module": "Data.FOL.Formula",
          "name": "And",
          "package": "toysolver",
          "partial": "And",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:And"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Formula",
          "name": "Atom",
          "package": "toysolver",
          "signature": "Atom a",
          "source": "src/Data-FOL-Formula.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Formula",
          "module": "Data.FOL.Formula",
          "name": "Atom",
          "package": "toysolver",
          "partial": "Atom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:Atom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Formula",
          "name": "Equiv",
          "package": "toysolver",
          "signature": "Equiv (Formula a) (Formula a)",
          "source": "src/Data-FOL-Formula.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Formula",
          "module": "Data.FOL.Formula",
          "name": "Equiv",
          "package": "toysolver",
          "partial": "Equiv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:Equiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Formula",
          "name": "Exists",
          "package": "toysolver",
          "signature": "Exists Var (Formula a)",
          "source": "src/Data-FOL-Formula.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Formula",
          "module": "Data.FOL.Formula",
          "name": "Exists",
          "package": "toysolver",
          "partial": "Exists",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:Exists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Formula",
          "name": "F",
          "package": "toysolver",
          "signature": "F",
          "source": "src/Data-FOL-Formula.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Formula",
          "module": "Data.FOL.Formula",
          "name": "F",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:F"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Formula",
          "name": "Forall",
          "package": "toysolver",
          "signature": "Forall Var (Formula a)",
          "source": "src/Data-FOL-Formula.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Formula",
          "module": "Data.FOL.Formula",
          "name": "Forall",
          "package": "toysolver",
          "partial": "Forall",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:Forall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Formula",
          "name": "Imply",
          "package": "toysolver",
          "signature": "Imply (Formula a) (Formula a)",
          "source": "src/Data-FOL-Formula.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Formula",
          "module": "Data.FOL.Formula",
          "name": "Imply",
          "package": "toysolver",
          "partial": "Imply",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:Imply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Formula",
          "name": "Not",
          "package": "toysolver",
          "signature": "Not (Formula a)",
          "source": "src/Data-FOL-Formula.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Formula",
          "module": "Data.FOL.Formula",
          "name": "Not",
          "package": "toysolver",
          "partial": "Not",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:Not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Formula",
          "name": "Or",
          "package": "toysolver",
          "signature": "Or (Formula a) (Formula a)",
          "source": "src/Data-FOL-Formula.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Formula",
          "module": "Data.FOL.Formula",
          "name": "Or",
          "package": "toysolver",
          "partial": "Or",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:Or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FOL.Formula",
          "name": "T",
          "package": "toysolver",
          "signature": "T",
          "source": "src/Data-FOL-Formula.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FOL Formula",
          "module": "Data.FOL.Formula",
          "name": "T",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert a formula into negation normal form\n\u003c/p\u003e",
          "module": "Data.FOL.Formula",
          "name": "pushNot",
          "package": "toysolver",
          "signature": "Formula a -\u003e Formula a",
          "source": "src/Data-FOL-Formula.html#pushNot",
          "type": "function"
        },
        "index": {
          "description": "convert formula into negation normal form",
          "hierarchy": "Data FOL Formula",
          "module": "Data.FOL.Formula",
          "name": "pushNot",
          "normalized": "Formula a-\u003eFormula a",
          "package": "toysolver",
          "partial": "Not",
          "signature": "Formula a-\u003eFormula a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:pushNot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LA.FOL",
          "name": "FOL",
          "package": "toysolver",
          "source": "src/Data-LA-FOL.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data LA FOL",
          "module": "Data.LA.FOL",
          "name": "FOL",
          "package": "toysolver",
          "partial": "FOL",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA-FOL.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LA.FOL",
          "name": "fromFOLAtom",
          "package": "toysolver",
          "signature": "Atom r -\u003e Maybe (Atom r)",
          "source": "src/Data-LA-FOL.html#fromFOLAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LA FOL",
          "module": "Data.LA.FOL",
          "name": "fromFOLAtom",
          "normalized": "Atom a-\u003eMaybe(Atom a)",
          "package": "toysolver",
          "partial": "FOLAtom",
          "signature": "Atom r-\u003eMaybe(Atom r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA-FOL.html#v:fromFOLAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LA.FOL",
          "name": "fromFOLExpr",
          "package": "toysolver",
          "signature": "Expr r -\u003e Maybe (Expr r)",
          "source": "src/Data-LA-FOL.html#fromFOLExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LA FOL",
          "module": "Data.LA.FOL",
          "name": "fromFOLExpr",
          "normalized": "Expr a-\u003eMaybe(Expr a)",
          "package": "toysolver",
          "partial": "FOLExpr",
          "signature": "Expr r-\u003eMaybe(Expr r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA-FOL.html#v:fromFOLExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LA.FOL",
          "name": "toFOLExpr",
          "package": "toysolver",
          "signature": "Expr r -\u003e Expr r",
          "source": "src/Data-LA-FOL.html#toFOLExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LA FOL",
          "module": "Data.LA.FOL",
          "name": "toFOLExpr",
          "normalized": "Expr a-\u003eExpr a",
          "package": "toysolver",
          "partial": "FOLExpr",
          "signature": "Expr r-\u003eExpr r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA-FOL.html#v:toFOLExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LA.FOL",
          "name": "toFOLFormula",
          "package": "toysolver",
          "signature": "Atom r -\u003e Formula (Atom r)",
          "source": "src/Data-LA-FOL.html#toFOLFormula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LA FOL",
          "module": "Data.LA.FOL",
          "name": "toFOLFormula",
          "normalized": "Atom a-\u003eFormula(Atom a)",
          "package": "toysolver",
          "partial": "FOLFormula",
          "signature": "Atom r-\u003eFormula(Atom r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA-FOL.html#v:toFOLFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSome definition for Theory of Linear Arithmetics.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.LA",
          "name": "LA",
          "package": "toysolver",
          "source": "src/Data-LA.html",
          "type": "module"
        },
        "index": {
          "description": "Some definition for Theory of Linear Arithmetics",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "LA",
          "package": "toysolver",
          "partial": "LA",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAtomic Formula of Linear Arithmetics\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "Atom",
          "package": "toysolver",
          "source": "src/Data-LA.html#Atom",
          "type": "type"
        },
        "index": {
          "description": "Atomic Formula of Linear Arithmetics",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "Atom",
          "package": "toysolver",
          "partial": "Atom",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#t:Atom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LA",
          "name": "BoundsEnv",
          "package": "toysolver",
          "source": "src/Data-LA.html#BoundsEnv",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "BoundsEnv",
          "package": "toysolver",
          "partial": "Bounds Env",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#t:BoundsEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLinear combination of variables and constants.\n Non-negative keys are used for variables's coefficients.\n key \u003ccode\u003e\u003ca\u003eunitVar\u003c/a\u003e\u003c/code\u003e is used for constants.\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "Expr",
          "package": "toysolver",
          "source": "src/Data-LA.html#Expr",
          "type": "data"
        },
        "index": {
          "description": "Linear combination of variables and constants Non-negative keys are used for variables coefficients key unitVar is used for constants",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "Expr",
          "package": "toysolver",
          "partial": "Expr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#t:Expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LA",
          "name": "applySubst",
          "package": "toysolver",
          "signature": "VarMap (Expr r) -\u003e Expr r -\u003e Expr r",
          "source": "src/Data-LA.html#applySubst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "applySubst",
          "normalized": "VarMap(Expr a)-\u003eExpr a-\u003eExpr a",
          "package": "toysolver",
          "partial": "Subst",
          "signature": "VarMap(Expr r)-\u003eExpr r-\u003eExpr r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:applySubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapplySubst1 x e e1 == e1[e/x]\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "applySubst1",
          "package": "toysolver",
          "signature": "Var -\u003e Expr r -\u003e Expr r -\u003e Expr r",
          "source": "src/Data-LA.html#applySubst1",
          "type": "function"
        },
        "index": {
          "description": "applySubst1 e1 e1",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "applySubst1",
          "normalized": "Var-\u003eExpr a-\u003eExpr a-\u003eExpr a",
          "package": "toysolver",
          "partial": "Subst",
          "signature": "Var-\u003eExpr r-\u003eExpr r-\u003eExpr r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:applySubst1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LA",
          "name": "asConst",
          "package": "toysolver",
          "signature": "Expr r -\u003e Maybe r",
          "source": "src/Data-LA.html#asConst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "asConst",
          "normalized": "Expr a-\u003eMaybe a",
          "package": "toysolver",
          "partial": "Const",
          "signature": "Expr r-\u003eMaybe r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:asConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elookup a coefficient of the variable.\n \u003ccode\u003e\n   coeff v e == fst (extract v e)\n \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "coeff",
          "package": "toysolver",
          "signature": "Var -\u003e Expr r -\u003e r",
          "source": "src/Data-LA.html#coeff",
          "type": "function"
        },
        "index": {
          "description": "lookup coefficient of the variable coeff fst extract",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "coeff",
          "normalized": "Var-\u003eExpr a-\u003ea",
          "package": "toysolver",
          "signature": "Var-\u003eExpr r-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:coeff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea mapping from variables to coefficients\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "coeffMap",
          "package": "toysolver",
          "signature": "Expr r -\u003e IntMap r",
          "source": "src/Data-LA.html#coeffMap",
          "type": "function"
        },
        "index": {
          "description": "mapping from variables to coefficients",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "coeffMap",
          "normalized": "Expr a-\u003eIntMap a",
          "package": "toysolver",
          "partial": "Map",
          "signature": "Expr r-\u003eIntMap r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:coeffMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "constant",
          "package": "toysolver",
          "signature": "r -\u003e Expr r",
          "source": "src/Data-LA.html#constant",
          "type": "function"
        },
        "index": {
          "description": "constant",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "constant",
          "normalized": "a-\u003eExpr a",
          "package": "toysolver",
          "signature": "r-\u003eExpr r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eevaluate the formula under the model.\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "evalAtom",
          "package": "toysolver",
          "signature": "Model r -\u003e Atom r -\u003e Bool",
          "source": "src/Data-LA.html#evalAtom",
          "type": "function"
        },
        "index": {
          "description": "evaluate the formula under the model",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "evalAtom",
          "normalized": "Model a-\u003eAtom a-\u003eBool",
          "package": "toysolver",
          "partial": "Atom",
          "signature": "Model r-\u003eAtom r-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:evalAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eevaluate the expression under the model.\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "evalExpr",
          "package": "toysolver",
          "signature": "Model r -\u003e Expr r -\u003e r",
          "source": "src/Data-LA.html#evalExpr",
          "type": "function"
        },
        "index": {
          "description": "evaluate the expression under the model",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "evalExpr",
          "normalized": "Model a-\u003eExpr a-\u003ea",
          "package": "toysolver",
          "partial": "Expr",
          "signature": "Model r-\u003eExpr r-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:evalExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eevaluate the expression under the model.\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "evalLinear",
          "package": "toysolver",
          "signature": "Model a -\u003e a -\u003e Expr (Scalar a) -\u003e a",
          "source": "src/Data-LA.html#evalLinear",
          "type": "function"
        },
        "index": {
          "description": "evaluate the expression under the model",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "evalLinear",
          "normalized": "Model a-\u003ea-\u003eExpr(Scalar a)-\u003ea",
          "package": "toysolver",
          "partial": "Linear",
          "signature": "Model a-\u003ea-\u003eExpr(Scalar a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:evalLinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eextract v e\u003c/code\u003e returns \u003ccode\u003e(c, e')\u003c/code\u003e such that \u003ccode\u003ee == c *^ v ^+^ e'\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "extract",
          "package": "toysolver",
          "signature": "Var -\u003e Expr r -\u003e (r, Expr r)",
          "source": "src/Data-LA.html#extract",
          "type": "function"
        },
        "index": {
          "description": "extract returns such that",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "extract",
          "normalized": "Var-\u003eExpr a-\u003e(a,Expr a)",
          "package": "toysolver",
          "signature": "Var-\u003eExpr r-\u003e(r,Expr r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:extract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eextractMaybe v e\u003c/code\u003e returns \u003ccode\u003eJust (c, e')\u003c/code\u003e such that \u003ccode\u003ee == c *^ v ^+^ e'\u003c/code\u003e\n if \u003ccode\u003ee\u003c/code\u003e contains v, and returns \u003ccode\u003eNothing\u003c/code\u003e otherwise.\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "extractMaybe",
          "package": "toysolver",
          "signature": "Var -\u003e Expr r -\u003e Maybe (r, Expr r)",
          "source": "src/Data-LA.html#extractMaybe",
          "type": "function"
        },
        "index": {
          "description": "extractMaybe returns Just such that if contains and returns Nothing otherwise",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "extractMaybe",
          "normalized": "Var-\u003eExpr a-\u003eMaybe(a,Expr a)",
          "package": "toysolver",
          "partial": "Maybe",
          "signature": "Var-\u003eExpr r-\u003eMaybe(r,Expr r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:extractMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a \u003ccode\u003eExpr\u003c/code\u003e from a mapping from variables to coefficients.\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "fromCoeffMap",
          "package": "toysolver",
          "signature": "IntMap r -\u003e Expr r",
          "source": "src/Data-LA.html#fromCoeffMap",
          "type": "function"
        },
        "index": {
          "description": "Create Expr from mapping from variables to coefficients",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "fromCoeffMap",
          "normalized": "IntMap a-\u003eExpr a",
          "package": "toysolver",
          "partial": "Coeff Map",
          "signature": "IntMap r-\u003eExpr r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:fromCoeffMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a \u003ccode\u003eExpr\u003c/code\u003e from a list of terms.\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "fromTerms",
          "package": "toysolver",
          "signature": "[(r, Var)] -\u003e Expr r",
          "source": "src/Data-LA.html#fromTerms",
          "type": "function"
        },
        "index": {
          "description": "Create Expr from list of terms",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "fromTerms",
          "normalized": "[(a,Var)]-\u003eExpr a",
          "package": "toysolver",
          "partial": "Terms",
          "signature": "[(r,Var)]-\u003eExpr r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:fromTerms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LA",
          "name": "lift1",
          "package": "toysolver",
          "signature": "x -\u003e (Var -\u003e x) -\u003e Expr (Scalar x) -\u003e x",
          "source": "src/Data-LA.html#lift1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "lift1",
          "normalized": "a-\u003e(Var-\u003ea)-\u003eExpr(Scalar a)-\u003ea",
          "package": "toysolver",
          "signature": "x-\u003e(Var-\u003ex)-\u003eExpr(Scalar x)-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:lift1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elookup a coefficient of the variable.\n It returns \u003ccode\u003eNothing\u003c/code\u003e if the expression does not contain \u003ccode\u003ev\u003c/code\u003e.\n \u003ccode\u003e\n   lookupCoeff v e == fmap fst (extractMaybe v e)\n \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "lookupCoeff",
          "package": "toysolver",
          "signature": "Var -\u003e Expr r -\u003e Maybe r",
          "source": "src/Data-LA.html#lookupCoeff",
          "type": "function"
        },
        "index": {
          "description": "lookup coefficient of the variable It returns Nothing if the expression does not contain lookupCoeff fmap fst extractMaybe",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "lookupCoeff",
          "normalized": "Var-\u003eExpr a-\u003eMaybe a",
          "package": "toysolver",
          "partial": "Coeff",
          "signature": "Var-\u003eExpr r-\u003eMaybe r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:lookupCoeff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emap coefficients.\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "mapCoeff",
          "package": "toysolver",
          "signature": "(a -\u003e b) -\u003e Expr a -\u003e Expr b",
          "source": "src/Data-LA.html#mapCoeff",
          "type": "function"
        },
        "index": {
          "description": "map coefficients",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "mapCoeff",
          "normalized": "(a-\u003eb)-\u003eExpr a-\u003eExpr b",
          "package": "toysolver",
          "partial": "Coeff",
          "signature": "(a-\u003eb)-\u003eExpr a-\u003eExpr b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:mapCoeff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emap coefficients.\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "mapCoeffWithVar",
          "package": "toysolver",
          "signature": "(a -\u003e Var -\u003e b) -\u003e Expr a -\u003e Expr b",
          "source": "src/Data-LA.html#mapCoeffWithVar",
          "type": "function"
        },
        "index": {
          "description": "map coefficients",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "mapCoeffWithVar",
          "normalized": "(a-\u003eVar-\u003eb)-\u003eExpr a-\u003eExpr b",
          "package": "toysolver",
          "partial": "Coeff With Var",
          "signature": "(a-\u003eVar-\u003eb)-\u003eExpr a-\u003eExpr b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:mapCoeffWithVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LA",
          "name": "showAtom",
          "package": "toysolver",
          "signature": "Atom r -\u003e String",
          "source": "src/Data-LA.html#showAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "showAtom",
          "normalized": "Atom a-\u003eString",
          "package": "toysolver",
          "partial": "Atom",
          "signature": "Atom r-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:showAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LA",
          "name": "showExpr",
          "package": "toysolver",
          "signature": "Expr r -\u003e String",
          "source": "src/Data-LA.html#showExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "showExpr",
          "normalized": "Expr a-\u003eString",
          "package": "toysolver",
          "partial": "Expr",
          "signature": "Expr r-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:showExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve linear (in)equation for the given variable.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003esolveFor a v\u003c/code\u003e returns \u003ccode\u003eJust (op, e)\u003c/code\u003e such that \u003ccode\u003eAtom v op e\u003c/code\u003e\n is equivalent to \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "solveFor",
          "package": "toysolver",
          "signature": "Atom r -\u003e Var -\u003e Maybe (RelOp, Expr r)",
          "source": "src/Data-LA.html#solveFor",
          "type": "function"
        },
        "index": {
          "description": "Solve linear in equation for the given variable solveFor returns Just op such that Atom op is equivalent to",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "solveFor",
          "normalized": "Atom a-\u003eVar-\u003eMaybe(RelOp,Expr a)",
          "package": "toysolver",
          "partial": "For",
          "signature": "Atom r-\u003eVar-\u003eMaybe(RelOp,Expr r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:solveFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eterms contained in the expression.\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "terms",
          "package": "toysolver",
          "signature": "Expr r -\u003e [(r, Var)]",
          "source": "src/Data-LA.html#terms",
          "type": "function"
        },
        "index": {
          "description": "terms contained in the expression",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "terms",
          "normalized": "Expr a-\u003e[(a,Var)]",
          "package": "toysolver",
          "signature": "Expr r-\u003e[(r,Var)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:terms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecial variable that should always be evaluated to 1.\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "unitVar",
          "package": "toysolver",
          "signature": "Var",
          "source": "src/Data-LA.html#unitVar",
          "type": "function"
        },
        "index": {
          "description": "Special variable that should always be evaluated to",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "unitVar",
          "package": "toysolver",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:unitVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable\n\u003c/p\u003e",
          "module": "Data.LA",
          "name": "var",
          "package": "toysolver",
          "signature": "Var -\u003e Expr r",
          "source": "src/Data-LA.html#var",
          "type": "function"
        },
        "index": {
          "description": "variable",
          "hierarchy": "Data LA",
          "module": "Data.LA",
          "name": "var",
          "normalized": "Var-\u003eExpr a",
          "package": "toysolver",
          "signature": "Var-\u003eExpr r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLifted boolean type.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.LBool",
          "name": "LBool",
          "package": "toysolver",
          "source": "src/Data-LBool.html",
          "type": "module"
        },
        "index": {
          "description": "Lifted boolean type",
          "hierarchy": "Data LBool",
          "module": "Data.LBool",
          "name": "LBool",
          "package": "toysolver",
          "partial": "LBool",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLifted Bool type. It has three values \u003ccode\u003e\u003ca\u003elTrue\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003elFalse\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003elUndef\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.LBool",
          "name": "LBool",
          "package": "toysolver",
          "source": "src/Data-LBool.html#LBool",
          "type": "data"
        },
        "index": {
          "description": "Lifted Bool type It has three values lTrue lFalse lUndef",
          "hierarchy": "Data LBool",
          "module": "Data.LBool",
          "name": "LBool",
          "package": "toysolver",
          "partial": "LBool",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#t:LBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elifted false value\n\u003c/p\u003e",
          "module": "Data.LBool",
          "name": "lFalse",
          "package": "toysolver",
          "signature": "LBool",
          "source": "src/Data-LBool.html#lFalse",
          "type": "function"
        },
        "index": {
          "description": "lifted false value",
          "hierarchy": "Data LBool",
          "module": "Data.LBool",
          "name": "lFalse",
          "package": "toysolver",
          "partial": "False",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#v:lFalse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elifted true value\n\u003c/p\u003e",
          "module": "Data.LBool",
          "name": "lTrue",
          "package": "toysolver",
          "signature": "LBool",
          "source": "src/Data-LBool.html#lTrue",
          "type": "function"
        },
        "index": {
          "description": "lifted true value",
          "hierarchy": "Data LBool",
          "module": "Data.LBool",
          "name": "lTrue",
          "package": "toysolver",
          "partial": "True",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#v:lTrue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eundefined truth value\n\u003c/p\u003e",
          "module": "Data.LBool",
          "name": "lUndef",
          "package": "toysolver",
          "signature": "LBool",
          "source": "src/Data-LBool.html#lUndef",
          "type": "function"
        },
        "index": {
          "description": "undefined truth value",
          "hierarchy": "Data LBool",
          "module": "Data.LBool",
          "name": "lUndef",
          "package": "toysolver",
          "partial": "Undef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#v:lUndef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n   liftBool True == lTrue\n   liftBool False == lFalse\n\u003c/pre\u003e",
          "module": "Data.LBool",
          "name": "liftBool",
          "package": "toysolver",
          "signature": "Bool -\u003e LBool",
          "source": "src/Data-LBool.html#liftBool",
          "type": "function"
        },
        "index": {
          "description": "liftBool True lTrue liftBool False lFalse",
          "hierarchy": "Data LBool",
          "module": "Data.LBool",
          "name": "liftBool",
          "normalized": "Bool-\u003eLBool",
          "package": "toysolver",
          "partial": "Bool",
          "signature": "Bool-\u003eLBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#v:liftBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n   lnot lTrue == lFalse\n   lnot lFalse == lTrue\n   lnot lUndef == lUndef\n\u003c/pre\u003e",
          "module": "Data.LBool",
          "name": "lnot",
          "package": "toysolver",
          "signature": "LBool -\u003e LBool",
          "source": "src/Data-LBool.html#lnot",
          "type": "function"
        },
        "index": {
          "description": "lnot lTrue lFalse lnot lFalse lTrue lnot lUndef lUndef",
          "hierarchy": "Data LBool",
          "module": "Data.LBool",
          "name": "lnot",
          "normalized": "LBool-\u003eLBool",
          "package": "toysolver",
          "signature": "LBool-\u003eLBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#v:lnot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n   unliftBool lTrue == Just True\n   unliftBool lFalse == Just False\n   unliftBool lUndef == Nothing\n\u003c/pre\u003e",
          "module": "Data.LBool",
          "name": "unliftBool",
          "package": "toysolver",
          "signature": "LBool -\u003e Maybe Bool",
          "source": "src/Data-LBool.html#unliftBool",
          "type": "function"
        },
        "index": {
          "description": "unliftBool lTrue Just True unliftBool lFalse Just False unliftBool lUndef Nothing",
          "hierarchy": "Data LBool",
          "module": "Data.LBool",
          "name": "unliftBool",
          "normalized": "LBool-\u003eMaybe Bool",
          "package": "toysolver",
          "partial": "Bool",
          "signature": "LBool-\u003eMaybe Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#v:unliftBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFactoriation of polynomial over a finite field.\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://en.wikipedia.org/wiki/Factorization_of_polynomials_over_a_finite_field_and_irreducibility_tests\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://en.wikipedia.org/wiki/Berlekamp%27s_algorithm\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Martin Kreuzer and Lorenzo Robbiano. Computational Commutative Algebra 1. Springer Verlag, 2000.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Data.Polynomial.Factorization.FiniteField",
          "name": "FiniteField",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Factorization-FiniteField.html",
          "type": "module"
        },
        "index": {
          "description": "Factoriation of polynomial over finite field References http en.wikipedia.org wiki Factorization of polynomials over finite field and irreducibility tests http en.wikipedia.org wiki Berlekamp algorithm Martin Kreuzer and Lorenzo Robbiano Computational Commutative Algebra Springer Verlag",
          "hierarchy": "Data Polynomial Factorization FiniteField",
          "module": "Data.Polynomial.Factorization.FiniteField",
          "name": "FiniteField",
          "package": "toysolver",
          "partial": "Finite Field",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-FiniteField.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.Factorization.FiniteField",
          "name": "basisOfBerlekampSubalgebra",
          "package": "toysolver",
          "signature": "UPolynomial k -\u003e [UPolynomial k]",
          "source": "src/Data-Polynomial-Factorization-FiniteField.html#basisOfBerlekampSubalgebra",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial Factorization FiniteField",
          "module": "Data.Polynomial.Factorization.FiniteField",
          "name": "basisOfBerlekampSubalgebra",
          "normalized": "UPolynomial a-\u003e[UPolynomial a]",
          "package": "toysolver",
          "partial": "Of Berlekamp Subalgebra",
          "signature": "UPolynomial k-\u003e[UPolynomial k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-FiniteField.html#v:basisOfBerlekampSubalgebra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBerlekamp algorithm for polynomial factorization.\n\u003c/p\u003e\u003cp\u003eInput polynomial is assumed to be monic and square-free.\n\u003c/p\u003e",
          "module": "Data.Polynomial.Factorization.FiniteField",
          "name": "berlekamp",
          "package": "toysolver",
          "signature": "UPolynomial k -\u003e [UPolynomial k]",
          "source": "src/Data-Polynomial-Factorization-FiniteField.html#berlekamp",
          "type": "function"
        },
        "index": {
          "description": "Berlekamp algorithm for polynomial factorization Input polynomial is assumed to be monic and square-free",
          "hierarchy": "Data Polynomial Factorization FiniteField",
          "module": "Data.Polynomial.Factorization.FiniteField",
          "name": "berlekamp",
          "normalized": "UPolynomial a-\u003e[UPolynomial a]",
          "package": "toysolver",
          "signature": "UPolynomial k-\u003e[UPolynomial k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-FiniteField.html#v:berlekamp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.Factorization.FiniteField",
          "name": "factor",
          "package": "toysolver",
          "signature": "UPolynomial k -\u003e [(UPolynomial k, Integer)]",
          "source": "src/Data-Polynomial-Factorization-FiniteField.html#factor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial Factorization FiniteField",
          "module": "Data.Polynomial.Factorization.FiniteField",
          "name": "factor",
          "normalized": "UPolynomial a-\u003e[(UPolynomial a,Integer)]",
          "package": "toysolver",
          "signature": "UPolynomial k-\u003e[(UPolynomial k,Integer)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-FiniteField.html#v:factor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSquare-free decomposition of univariate polynomials over a finite field.\n\u003c/p\u003e",
          "module": "Data.Polynomial.Factorization.FiniteField",
          "name": "sqfree",
          "package": "toysolver",
          "signature": "UPolynomial k -\u003e [(UPolynomial k, Integer)]",
          "source": "src/Data-Polynomial-Factorization-FiniteField.html#sqfree",
          "type": "function"
        },
        "index": {
          "description": "Square-free decomposition of univariate polynomials over finite field",
          "hierarchy": "Data Polynomial Factorization FiniteField",
          "module": "Data.Polynomial.Factorization.FiniteField",
          "name": "sqfree",
          "normalized": "UPolynomial a-\u003e[(UPolynomial a,Integer)]",
          "package": "toysolver",
          "signature": "UPolynomial k-\u003e[(UPolynomial k,Integer)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-FiniteField.html#v:sqfree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.math.kobe-u.ac.jp/Asir/ca.pdf\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://www14.in.tum.de/konferenzen/Jass07/courses/1/Bulwahn/Buhlwahn_Paper.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Data.Polynomial.Factorization.Hensel",
          "name": "Hensel",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Factorization-Hensel.html",
          "type": "module"
        },
        "index": {
          "description": "References http www.math.kobe-u.ac.jp Asir ca.pdf http www14.in.tum.de konferenzen Jass07 courses Bulwahn Buhlwahn Paper.pdf",
          "hierarchy": "Data Polynomial Factorization Hensel",
          "module": "Data.Polynomial.Factorization.Hensel",
          "name": "Hensel",
          "package": "toysolver",
          "partial": "Hensel",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Hensel.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.Factorization.Hensel",
          "name": "hensel",
          "package": "toysolver",
          "signature": "UPolynomial Integer -\u003e [UPolynomial (PrimeField p)] -\u003e Integer -\u003e [UPolynomial Integer]",
          "source": "src/Data-Polynomial-Factorization-Hensel.html#hensel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial Factorization Hensel",
          "module": "Data.Polynomial.Factorization.Hensel",
          "name": "hensel",
          "normalized": "UPolynomial Integer-\u003e[UPolynomial(PrimeField a)]-\u003eInteger-\u003e[UPolynomial Integer]",
          "package": "toysolver",
          "signature": "UPolynomial Integer-\u003e[UPolynomial(PrimeField p)]-\u003eInteger-\u003e[UPolynomial Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Hensel.html#v:hensel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.Factorization.Integer",
          "name": "Integer",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Factorization-Integer.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Polynomial Factorization Integer",
          "module": "Data.Polynomial.Factorization.Integer",
          "name": "Integer",
          "package": "toysolver",
          "partial": "Integer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Integer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFactoriation of integer-coefficient polynomial using Kronecker's method.\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://en.wikipedia.org/wiki/Polynomial_factorization\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Data.Polynomial.Factorization.Kronecker",
          "name": "Kronecker",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Factorization-Kronecker.html",
          "type": "module"
        },
        "index": {
          "description": "Factoriation of integer-coefficient polynomial using Kronecker method References http en.wikipedia.org wiki Polynomial factorization",
          "hierarchy": "Data Polynomial Factorization Kronecker",
          "module": "Data.Polynomial.Factorization.Kronecker",
          "name": "Kronecker",
          "package": "toysolver",
          "partial": "Kronecker",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Kronecker.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.Factorization.Kronecker",
          "name": "factor",
          "package": "toysolver",
          "signature": "UPolynomial Integer -\u003e [(UPolynomial Integer, Integer)]",
          "source": "src/Data-Polynomial-Factorization-Kronecker.html#factor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial Factorization Kronecker",
          "module": "Data.Polynomial.Factorization.Kronecker",
          "name": "factor",
          "normalized": "UPolynomial Integer-\u003e[(UPolynomial Integer,Integer)]",
          "package": "toysolver",
          "signature": "UPolynomial Integer-\u003e[(UPolynomial Integer,Integer)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Kronecker.html#v:factor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.Factorization.Rational",
          "name": "Rational",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Factorization-Rational.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Polynomial Factorization Rational",
          "module": "Data.Polynomial.Factorization.Rational",
          "name": "Rational",
          "package": "toysolver",
          "partial": "Rational",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Rational.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.math.kobe-u.ac.jp/Asir/ca.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Data.Polynomial.Factorization.SquareFree",
          "name": "SquareFree",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Factorization-SquareFree.html",
          "type": "module"
        },
        "index": {
          "description": "References http www.math.kobe-u.ac.jp Asir ca.pdf",
          "hierarchy": "Data Polynomial Factorization SquareFree",
          "module": "Data.Polynomial.Factorization.SquareFree",
          "name": "SquareFree",
          "package": "toysolver",
          "partial": "Square Free",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-SquareFree.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSquare-free decomposition of univariate polynomials over a field of characteristic 0.\n\u003c/p\u003e",
          "module": "Data.Polynomial.Factorization.SquareFree",
          "name": "sqfreeChar0",
          "package": "toysolver",
          "signature": "UPolynomial k -\u003e [(UPolynomial k, Integer)]",
          "source": "src/Data-Polynomial-Factorization-SquareFree.html#sqfreeChar0",
          "type": "function"
        },
        "index": {
          "description": "Square-free decomposition of univariate polynomials over field of characteristic",
          "hierarchy": "Data Polynomial Factorization SquareFree",
          "module": "Data.Polynomial.Factorization.SquareFree",
          "name": "sqfreeChar0",
          "normalized": "UPolynomial a-\u003e[(UPolynomial a,Integer)]",
          "package": "toysolver",
          "partial": "Char",
          "signature": "UPolynomial k-\u003e[(UPolynomial k,Integer)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-SquareFree.html#v:sqfreeChar0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFactoriation of integer-coefficient polynomial using Zassenhaus algorithm.\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.math.kobe-u.ac.jp/Asir/ca.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Data.Polynomial.Factorization.Zassenhaus",
          "name": "Zassenhaus",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Factorization-Zassenhaus.html",
          "type": "module"
        },
        "index": {
          "description": "Factoriation of integer-coefficient polynomial using Zassenhaus algorithm References http www.math.kobe-u.ac.jp Asir ca.pdf",
          "hierarchy": "Data Polynomial Factorization Zassenhaus",
          "module": "Data.Polynomial.Factorization.Zassenhaus",
          "name": "Zassenhaus",
          "package": "toysolver",
          "partial": "Zassenhaus",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Zassenhaus.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.Factorization.Zassenhaus",
          "name": "factor",
          "package": "toysolver",
          "signature": "UPolynomial Integer -\u003e [(UPolynomial Integer, Integer)]",
          "source": "src/Data-Polynomial-Factorization-Zassenhaus.html#factor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial Factorization Zassenhaus",
          "module": "Data.Polynomial.Factorization.Zassenhaus",
          "name": "factor",
          "normalized": "UPolynomial Integer-\u003e[(UPolynomial Integer,Integer)]",
          "package": "toysolver",
          "signature": "UPolynomial Integer-\u003e[(UPolynomial Integer,Integer)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Zassenhaus.html#v:factor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGr&#246;bner basis\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Monomial order \u003ca\u003ehttp://en.wikipedia.org/wiki/Monomial_order\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Gr&#246;bner basis \u003ca\u003ehttp://en.wikipedia.org/wiki/Gr%C3%B6bner_basis\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e &#12464;&#12524;&#12502;&#12490;&#12540;&#22522;&#24213; \u003ca\u003ehttp://d.hatena.ne.jp/keyword/%A5%B0%A5%EC%A5%D6%A5%CA%A1%BC%B4%F0%C4%EC\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Gr&#246;bner Bases and Buchberger&#8217;s Algorithm \u003ca\u003ehttp://math.rice.edu/~cbruun/vigre/vigreHW6.pdf\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Docon \u003ca\u003ehttp://www.haskell.org/docon/\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "GroebnerBasis",
          "package": "toysolver",
          "source": "src/Data-Polynomial-GroebnerBasis.html",
          "type": "module"
        },
        "index": {
          "description": "Gr bner basis References Monomial order http en.wikipedia.org wiki Monomial order Gr bner basis http en.wikipedia.org wiki Gr C3 B6bner basis http d.hatena.ne.jp keyword A5 B0 A5 EC A5 D6 A5 CA A1 BC B4 F0 C4 EC Gr bner Bases and Buchberger Algorithm http math.rice.edu cbruun vigre vigreHW6.pdf Docon http www.haskell.org docon",
          "hierarchy": "Data Polynomial GroebnerBasis",
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "GroebnerBasis",
          "package": "toysolver",
          "partial": "Groebner Basis",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "Options",
          "package": "toysolver",
          "source": "src/Data-Polynomial-GroebnerBasis.html#Options",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Polynomial GroebnerBasis",
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#t:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "Strategy",
          "package": "toysolver",
          "source": "src/Data-Polynomial-GroebnerBasis.html#Strategy",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Polynomial GroebnerBasis",
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "Strategy",
          "package": "toysolver",
          "partial": "Strategy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#t:Strategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "NormalStrategy",
          "package": "toysolver",
          "signature": "NormalStrategy",
          "source": "src/Data-Polynomial-GroebnerBasis.html#Strategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial GroebnerBasis",
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "NormalStrategy",
          "package": "toysolver",
          "partial": "Normal Strategy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:NormalStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "Options",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/Data-Polynomial-GroebnerBasis.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial GroebnerBasis",
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esugar strategy (not implemented yet)\n\u003c/p\u003e",
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "SugarStrategy",
          "package": "toysolver",
          "signature": "SugarStrategy",
          "source": "src/Data-Polynomial-GroebnerBasis.html#Strategy",
          "type": "function"
        },
        "index": {
          "description": "sugar strategy not implemented yet",
          "hierarchy": "Data Polynomial GroebnerBasis",
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "SugarStrategy",
          "package": "toysolver",
          "partial": "Sugar Strategy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:SugarStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "basis",
          "package": "toysolver",
          "signature": "MonomialOrder v -\u003e [Polynomial k v] -\u003e [Polynomial k v]",
          "source": "src/Data-Polynomial-GroebnerBasis.html#basis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial GroebnerBasis",
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "basis",
          "normalized": "MonomialOrder a-\u003e[Polynomial b a]-\u003e[Polynomial b a]",
          "package": "toysolver",
          "signature": "MonomialOrder v-\u003e[Polynomial k v]-\u003e[Polynomial k v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:basis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "basis'",
          "package": "toysolver",
          "signature": "Options -\u003e MonomialOrder v -\u003e [Polynomial k v] -\u003e [Polynomial k v]",
          "source": "src/Data-Polynomial-GroebnerBasis.html#basis%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial GroebnerBasis",
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "basis'",
          "normalized": "Options-\u003eMonomialOrder a-\u003e[Polynomial b a]-\u003e[Polynomial b a]",
          "package": "toysolver",
          "signature": "Options-\u003eMonomialOrder v-\u003e[Polynomial k v]-\u003e[Polynomial k v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:basis-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "defaultOptions",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/Data-Polynomial-GroebnerBasis.html#defaultOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial GroebnerBasis",
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "defaultOptions",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:defaultOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "optStrategy",
          "package": "toysolver",
          "signature": "Strategy",
          "source": "src/Data-Polynomial-GroebnerBasis.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial GroebnerBasis",
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "optStrategy",
          "package": "toysolver",
          "partial": "Strategy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:optStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "reduceGBasis",
          "package": "toysolver",
          "signature": "MonomialOrder v -\u003e [Polynomial k v] -\u003e [Polynomial k v]",
          "source": "src/Data-Polynomial-GroebnerBasis.html#reduceGBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial GroebnerBasis",
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "reduceGBasis",
          "normalized": "MonomialOrder a-\u003e[Polynomial b a]-\u003e[Polynomial b a]",
          "package": "toysolver",
          "partial": "GBasis",
          "signature": "MonomialOrder v-\u003e[Polynomial k v]-\u003e[Polynomial k v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:reduceGBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "spolynomial",
          "package": "toysolver",
          "signature": "MonomialOrder v -\u003e Polynomial k v -\u003e Polynomial k v -\u003e Polynomial k v",
          "source": "src/Data-Polynomial-GroebnerBasis.html#spolynomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial GroebnerBasis",
          "module": "Data.Polynomial.GroebnerBasis",
          "name": "spolynomial",
          "normalized": "MonomialOrder a-\u003ePolynomial b a-\u003ePolynomial b a-\u003ePolynomial b a",
          "package": "toysolver",
          "signature": "MonomialOrder v-\u003ePolynomial k v-\u003ePolynomial k v-\u003ePolynomial k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:spolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.Interpolation.Lagrange",
          "name": "Lagrange",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Interpolation-Lagrange.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Polynomial Interpolation Lagrange",
          "module": "Data.Polynomial.Interpolation.Lagrange",
          "name": "Lagrange",
          "package": "toysolver",
          "partial": "Lagrange",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Interpolation-Lagrange.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.Interpolation.Lagrange",
          "name": "interpolate",
          "package": "toysolver",
          "signature": "[(k, k)] -\u003e UPolynomial k",
          "source": "src/Data-Polynomial-Interpolation-Lagrange.html#interpolate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial Interpolation Lagrange",
          "module": "Data.Polynomial.Interpolation.Lagrange",
          "name": "interpolate",
          "normalized": "[(a,a)]-\u003eUPolynomial a",
          "package": "toysolver",
          "signature": "[(k,k)]-\u003eUPolynomial k",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Interpolation-Lagrange.html#v:interpolate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGraeffe's Method\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://mathworld.wolfram.com/GraeffesMethod.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://en.wikipedia.org/wiki/Graeffe's_method\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Data.Polynomial.RootSeparation.Graeffe",
          "name": "Graeffe",
          "package": "toysolver",
          "source": "src/Data-Polynomial-RootSeparation-Graeffe.html",
          "type": "module"
        },
        "index": {
          "description": "Graeffe Method Reference http mathworld.wolfram.com GraeffesMethod.html http en.wikipedia.org wiki Graeffe method",
          "hierarchy": "Data Polynomial RootSeparation Graeffe",
          "module": "Data.Polynomial.RootSeparation.Graeffe",
          "name": "Graeffe",
          "package": "toysolver",
          "partial": "Graeffe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Graeffe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.RootSeparation.Graeffe",
          "name": "NthRoot",
          "package": "toysolver",
          "source": "src/Data-Polynomial-RootSeparation-Graeffe.html#NthRoot",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Polynomial RootSeparation Graeffe",
          "module": "Data.Polynomial.RootSeparation.Graeffe",
          "name": "NthRoot",
          "package": "toysolver",
          "partial": "Nth Root",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Graeffe.html#t:NthRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.RootSeparation.Graeffe",
          "name": "NthRoot",
          "package": "toysolver",
          "signature": "NthRoot !Integer !Rational",
          "source": "src/Data-Polynomial-RootSeparation-Graeffe.html#NthRoot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial RootSeparation Graeffe",
          "module": "Data.Polynomial.RootSeparation.Graeffe",
          "name": "NthRoot",
          "package": "toysolver",
          "partial": "Nth Root",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Graeffe.html#v:NthRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.RootSeparation.Graeffe",
          "name": "graeffesMethod",
          "package": "toysolver",
          "signature": "UPolynomial Rational -\u003e Int -\u003e [NthRoot]",
          "source": "src/Data-Polynomial-RootSeparation-Graeffe.html#graeffesMethod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial RootSeparation Graeffe",
          "module": "Data.Polynomial.RootSeparation.Graeffe",
          "name": "graeffesMethod",
          "normalized": "UPolynomial Rational-\u003eInt-\u003e[NthRoot]",
          "package": "toysolver",
          "partial": "Method",
          "signature": "UPolynomial Rational-\u003eInt-\u003e[NthRoot]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Graeffe.html#v:graeffesMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \"\u003cem\u003eSturm's theorem\u003c/em\u003e.\" Wikipedia, The Free Encyclopedia. Wikimedia Foundation, Inc.\n   2012-06-23. \u003ca\u003ehttp://en.wikipedia.org/wiki/Sturm%27s_theorem\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Weisstein, Eric W. \"\u003cem\u003eSturm Function\u003c/em\u003e.\" From MathWorld--A Wolfram Web Resource.\n   \u003ca\u003ehttp://mathworld.wolfram.com/SturmFunction.html\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "Sturm",
          "package": "toysolver",
          "source": "src/Data-Polynomial-RootSeparation-Sturm.html",
          "type": "module"
        },
        "index": {
          "description": "Reference Sturm theorem Wikipedia The Free Encyclopedia Wikimedia Foundation Inc http en.wikipedia.org wiki Sturm theorem Weisstein Eric Sturm Function From MathWorld--A Wolfram Web Resource http mathworld.wolfram.com SturmFunction.html",
          "hierarchy": "Data Polynomial RootSeparation Sturm",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "Sturm",
          "package": "toysolver",
          "partial": "Sturm",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSturm's chain (Sturm's sequence)\n\u003c/p\u003e",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "SturmChain",
          "package": "toysolver",
          "source": "src/Data-Polynomial-RootSeparation-Sturm.html#SturmChain",
          "type": "type"
        },
        "index": {
          "description": "Sturm chain Sturm sequence",
          "hierarchy": "Data Polynomial RootSeparation Sturm",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "SturmChain",
          "package": "toysolver",
          "partial": "Sturm Chain",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#t:SturmChain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "approx",
          "package": "toysolver",
          "signature": "UPolynomial Rational -\u003e Interval Rational -\u003e Rational -\u003e Rational",
          "source": "src/Data-Polynomial-RootSeparation-Sturm.html#approx",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial RootSeparation Sturm",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "approx",
          "normalized": "UPolynomial Rational-\u003eInterval Rational-\u003eRational-\u003eRational",
          "package": "toysolver",
          "signature": "UPolynomial Rational-\u003eInterval Rational-\u003eRational-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:approx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "approx'",
          "package": "toysolver",
          "signature": "SturmChain -\u003e Interval Rational -\u003e Rational -\u003e Rational",
          "source": "src/Data-Polynomial-RootSeparation-Sturm.html#approx%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial RootSeparation Sturm",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "approx'",
          "normalized": "SturmChain-\u003eInterval Rational-\u003eRational-\u003eRational",
          "package": "toysolver",
          "signature": "SturmChain-\u003eInterval Rational-\u003eRational-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:approx-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "halve",
          "package": "toysolver",
          "signature": "UPolynomial Rational -\u003e Interval Rational -\u003e Interval Rational",
          "source": "src/Data-Polynomial-RootSeparation-Sturm.html#halve",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial RootSeparation Sturm",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "halve",
          "normalized": "UPolynomial Rational-\u003eInterval Rational-\u003eInterval Rational",
          "package": "toysolver",
          "signature": "UPolynomial Rational-\u003eInterval Rational-\u003eInterval Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:halve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "halve'",
          "package": "toysolver",
          "signature": "SturmChain -\u003e Interval Rational -\u003e Interval Rational",
          "source": "src/Data-Polynomial-RootSeparation-Sturm.html#halve%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial RootSeparation Sturm",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "halve'",
          "normalized": "SturmChain-\u003eInterval Rational-\u003eInterval Rational",
          "package": "toysolver",
          "signature": "SturmChain-\u003eInterval Rational-\u003eInterval Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:halve-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "narrow",
          "package": "toysolver",
          "signature": "UPolynomial Rational -\u003e Interval Rational -\u003e Rational -\u003e Interval Rational",
          "source": "src/Data-Polynomial-RootSeparation-Sturm.html#narrow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial RootSeparation Sturm",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "narrow",
          "normalized": "UPolynomial Rational-\u003eInterval Rational-\u003eRational-\u003eInterval Rational",
          "package": "toysolver",
          "signature": "UPolynomial Rational-\u003eInterval Rational-\u003eRational-\u003eInterval Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:narrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "narrow'",
          "package": "toysolver",
          "signature": "SturmChain -\u003e Interval Rational -\u003e Rational -\u003e Interval Rational",
          "source": "src/Data-Polynomial-RootSeparation-Sturm.html#narrow%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial RootSeparation Sturm",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "narrow'",
          "normalized": "SturmChain-\u003eInterval Rational-\u003eRational-\u003eInterval Rational",
          "package": "toysolver",
          "signature": "SturmChain-\u003eInterval Rational-\u003eRational-\u003eInterval Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:narrow-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of distinct real roots of \u003ccode\u003ep\u003c/code\u003e in a given interval\n\u003c/p\u003e",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "numRoots",
          "package": "toysolver",
          "signature": "UPolynomial Rational -\u003e Interval Rational -\u003e Int",
          "source": "src/Data-Polynomial-RootSeparation-Sturm.html#numRoots",
          "type": "function"
        },
        "index": {
          "description": "The number of distinct real roots of in given interval",
          "hierarchy": "Data Polynomial RootSeparation Sturm",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "numRoots",
          "normalized": "UPolynomial Rational-\u003eInterval Rational-\u003eInt",
          "package": "toysolver",
          "partial": "Roots",
          "signature": "UPolynomial Rational-\u003eInterval Rational-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:numRoots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of distinct real roots of \u003ccode\u003ep\u003c/code\u003e in a given interval.\n This function takes \u003ccode\u003ep\u003c/code\u003e's sturm chain instead of \u003ccode\u003ep\u003c/code\u003e itself.\n\u003c/p\u003e",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "numRoots'",
          "package": "toysolver",
          "signature": "SturmChain -\u003e Interval Rational -\u003e Int",
          "source": "src/Data-Polynomial-RootSeparation-Sturm.html#numRoots%27",
          "type": "function"
        },
        "index": {
          "description": "The number of distinct real roots of in given interval This function takes sturm chain instead of itself",
          "hierarchy": "Data Polynomial RootSeparation Sturm",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "numRoots'",
          "normalized": "SturmChain-\u003eInterval Rational-\u003eInt",
          "package": "toysolver",
          "partial": "Roots'",
          "signature": "SturmChain-\u003eInterval Rational-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:numRoots-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisjoint intervals each of which contains exactly one real roots of the given polynoimal \u003ccode\u003ep\u003c/code\u003e.\n The intervals can be further narrowed by \u003ccode\u003e\u003ca\u003enarrow\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003enarrow'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "separate",
          "package": "toysolver",
          "signature": "UPolynomial Rational -\u003e [Interval Rational]",
          "source": "src/Data-Polynomial-RootSeparation-Sturm.html#separate",
          "type": "function"
        },
        "index": {
          "description": "Disjoint intervals each of which contains exactly one real roots of the given polynoimal The intervals can be further narrowed by narrow or narrow",
          "hierarchy": "Data Polynomial RootSeparation Sturm",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "separate",
          "normalized": "UPolynomial Rational-\u003e[Interval Rational]",
          "package": "toysolver",
          "signature": "UPolynomial Rational-\u003e[Interval Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:separate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisjoint intervals each of which contains exactly one real roots of the given polynoimal \u003ccode\u003ep\u003c/code\u003e.\n The intervals can be further narrowed by \u003ccode\u003e\u003ca\u003enarrow\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003enarrow'\u003c/a\u003e\u003c/code\u003e.\n This function takes \u003ccode\u003ep\u003c/code\u003e's sturm chain instead of \u003ccode\u003ep\u003c/code\u003e itself.\n\u003c/p\u003e",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "separate'",
          "package": "toysolver",
          "signature": "SturmChain -\u003e [Interval Rational]",
          "source": "src/Data-Polynomial-RootSeparation-Sturm.html#separate%27",
          "type": "function"
        },
        "index": {
          "description": "Disjoint intervals each of which contains exactly one real roots of the given polynoimal The intervals can be further narrowed by narrow or narrow This function takes sturm chain instead of itself",
          "hierarchy": "Data Polynomial RootSeparation Sturm",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "separate'",
          "normalized": "SturmChain-\u003e[Interval Rational]",
          "package": "toysolver",
          "signature": "SturmChain-\u003e[Interval Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:separate-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSturm's sequence of a polynomial\n\u003c/p\u003e",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "sturmChain",
          "package": "toysolver",
          "signature": "UPolynomial Rational -\u003e SturmChain",
          "source": "src/Data-Polynomial-RootSeparation-Sturm.html#sturmChain",
          "type": "function"
        },
        "index": {
          "description": "Sturm sequence of polynomial",
          "hierarchy": "Data Polynomial RootSeparation Sturm",
          "module": "Data.Polynomial.RootSeparation.Sturm",
          "name": "sturmChain",
          "normalized": "UPolynomial Rational-\u003eSturmChain",
          "package": "toysolver",
          "partial": "Chain",
          "signature": "UPolynomial Rational-\u003eSturmChain",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:sturmChain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePolynomials\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Monomial order \u003ca\u003ehttp://en.wikipedia.org/wiki/Monomial_order\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Polynomial class for Ruby \u003ca\u003ehttp://www.math.kobe-u.ac.jp/~kodama/tips-RubyPoly.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e constructive-algebra package \u003ca\u003ehttp://hackage.haskell.org/package/constructive-algebra\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Data.Polynomial",
          "name": "Polynomial",
          "package": "toysolver",
          "source": "src/Data-Polynomial.html",
          "type": "module"
        },
        "index": {
          "description": "Polynomials References Monomial order http en.wikipedia.org wiki Monomial order Polynomial class for Ruby http www.math.kobe-u.ac.jp kodama tips-RubyPoly.html constructive-algebra package http hackage.haskell.org package constructive-algebra",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "Polynomial",
          "package": "toysolver",
          "partial": "Polynomial",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "ContPP",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#ContPP",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "ContPP",
          "package": "toysolver",
          "partial": "Cont PP",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:ContPP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etotal degree of a given polynomial\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "Degree",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#Degree",
          "type": "class"
        },
        "index": {
          "description": "total degree of given polynomial",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "Degree",
          "package": "toysolver",
          "partial": "Degree",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:Degree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFactorization of polynomials\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "Factor",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#Factor",
          "type": "class"
        },
        "index": {
          "description": "Factorization of polynomials",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "Factor",
          "package": "toysolver",
          "partial": "Factor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:Factor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonic monomials\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "Monomial",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#Monomial",
          "type": "data"
        },
        "index": {
          "description": "Monic monomials",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "Monomial",
          "package": "toysolver",
          "partial": "Monomial",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:Monomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "MonomialOrder",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#MonomialOrder",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "MonomialOrder",
          "package": "toysolver",
          "partial": "Monomial Order",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:MonomialOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePolynomial over commutative ring r\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "Polynomial",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#Polynomial",
          "type": "data"
        },
        "index": {
          "description": "Polynomial over commutative ring",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "Polynomial",
          "package": "toysolver",
          "partial": "Polynomial",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:Polynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "PrettyCoeff",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#PrettyCoeff",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "PrettyCoeff",
          "package": "toysolver",
          "partial": "Pretty Coeff",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:PrettyCoeff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "PrettyVar",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#PrettyVar",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "PrettyVar",
          "package": "toysolver",
          "partial": "Pretty Var",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:PrettyVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "PrintOptions",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#PrintOptions",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "PrintOptions",
          "package": "toysolver",
          "partial": "Print Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:PrintOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSquare-free factorization of polynomials\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "SQFree",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#SQFree",
          "type": "class"
        },
        "index": {
          "description": "Square-free factorization of polynomials",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "SQFree",
          "package": "toysolver",
          "partial": "SQFree",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:SQFree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "Term",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#Term",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "Term",
          "package": "toysolver",
          "partial": "Term",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "UMonomial",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#UMonomial",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "UMonomial",
          "package": "toysolver",
          "partial": "UMonomial",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:UMonomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnivariate polynomials over commutative ring r\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "UPolynomial",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#UPolynomial",
          "type": "type"
        },
        "index": {
          "description": "Univariate polynomials over commutative ring",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "UPolynomial",
          "package": "toysolver",
          "partial": "UPolynomial",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:UPolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "UTerm",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#UTerm",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "UTerm",
          "package": "toysolver",
          "partial": "UTerm",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:UTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "Var",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#Var",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "Var",
          "package": "toysolver",
          "partial": "Var",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "Vars",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#Vars",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "Vars",
          "package": "toysolver",
          "partial": "Vars",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:Vars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "X",
          "package": "toysolver",
          "source": "src/Data-Polynomial-Base.html#X",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "X",
          "package": "toysolver",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "PrintOptions",
          "package": "toysolver",
          "signature": "PrintOptions",
          "source": "src/Data-Polynomial-Base.html#PrintOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "PrintOptions",
          "package": "toysolver",
          "partial": "Print Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:PrintOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "X",
          "package": "toysolver",
          "signature": "X",
          "source": "src/Data-Polynomial-Base.html#X",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "X",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "coeff",
          "package": "toysolver",
          "signature": "Monomial v -\u003e Polynomial k v -\u003e k",
          "source": "src/Data-Polynomial-Base.html#coeff",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "coeff",
          "normalized": "Monomial a-\u003ePolynomial b a-\u003eb",
          "package": "toysolver",
          "signature": "Monomial v-\u003ePolynomial k v-\u003ek",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:coeff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "coeffMap",
          "package": "toysolver",
          "signature": "Polynomial r v -\u003e Map (Monomial v) r",
          "source": "src/Data-Polynomial-Base.html#coeffMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "coeffMap",
          "normalized": "Polynomial a b-\u003eMap(Monomial b)a",
          "package": "toysolver",
          "partial": "Map",
          "signature": "Polynomial r v-\u003eMap(Monomial v)r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:coeffMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct a polynomial from a constant\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "constant",
          "package": "toysolver",
          "signature": "k -\u003e Polynomial k v",
          "source": "src/Data-Polynomial-Base.html#constant",
          "type": "function"
        },
        "index": {
          "description": "construct polynomial from constant",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "constant",
          "normalized": "a-\u003ePolynomial a b",
          "package": "toysolver",
          "signature": "k-\u003ePolynomial k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContent of a polynomial  \n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "cont",
          "package": "toysolver",
          "signature": "Polynomial k v -\u003e k",
          "source": "src/Data-Polynomial-Base.html#cont",
          "type": "method"
        },
        "index": {
          "description": "Content of polynomial",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "cont",
          "normalized": "Polynomial a b-\u003ea",
          "package": "toysolver",
          "signature": "Polynomial k v-\u003ek",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:cont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "defaultPrintOptions",
          "package": "toysolver",
          "signature": "PrintOptions k v",
          "source": "src/Data-Polynomial-Base.html#defaultPrintOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "defaultPrintOptions",
          "package": "toysolver",
          "partial": "Print Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:defaultPrintOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "deg",
          "package": "toysolver",
          "signature": "t -\u003e Integer",
          "source": "src/Data-Polynomial-Base.html#deg",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "deg",
          "normalized": "a-\u003eInteger",
          "package": "toysolver",
          "signature": "t-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:deg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal derivative of polynomials\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "deriv",
          "package": "toysolver",
          "signature": "Polynomial k v -\u003e v -\u003e Polynomial k v",
          "source": "src/Data-Polynomial-Base.html#deriv",
          "type": "function"
        },
        "index": {
          "description": "Formal derivative of polynomials",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "deriv",
          "normalized": "Polynomial a b-\u003eb-\u003ePolynomial a b",
          "package": "toysolver",
          "signature": "Polynomial k v-\u003ev-\u003ePolynomial k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:deriv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edivision of univariate polynomials\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "div",
          "package": "toysolver",
          "signature": "UPolynomial k -\u003e UPolynomial k -\u003e UPolynomial k",
          "source": "src/Data-Polynomial-Base.html#div",
          "type": "function"
        },
        "index": {
          "description": "division of univariate polynomials",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "div",
          "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eUPolynomial a",
          "package": "toysolver",
          "signature": "UPolynomial k-\u003eUPolynomial k-\u003eUPolynomial k",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edivision of univariate polynomials\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "divMod",
          "package": "toysolver",
          "signature": "UPolynomial k -\u003e UPolynomial k -\u003e (UPolynomial k, UPolynomial k)",
          "source": "src/Data-Polynomial-Base.html#divMod",
          "type": "function"
        },
        "index": {
          "description": "division of univariate polynomials",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "divMod",
          "normalized": "UPolynomial a-\u003eUPolynomial a-\u003e(UPolynomial a,UPolynomial a)",
          "package": "toysolver",
          "partial": "Mod",
          "signature": "UPolynomial k-\u003eUPolynomial k-\u003e(UPolynomial k,UPolynomial k)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:divMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultivariate division algorithm\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "divModMP",
          "package": "toysolver",
          "signature": "MonomialOrder v -\u003e Polynomial k v -\u003e [Polynomial k v] -\u003e ([Polynomial k v], Polynomial k v)",
          "source": "src/Data-Polynomial-Base.html#divModMP",
          "type": "function"
        },
        "index": {
          "description": "Multivariate division algorithm",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "divModMP",
          "normalized": "MonomialOrder a-\u003ePolynomial b a-\u003e[Polynomial b a]-\u003e([Polynomial b a],Polynomial b a)",
          "package": "toysolver",
          "partial": "Mod MP",
          "signature": "MonomialOrder v-\u003ePolynomial k v-\u003e[Polynomial k v]-\u003e([Polynomial k v],Polynomial k v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:divModMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "divides",
          "package": "toysolver",
          "signature": "UPolynomial k -\u003e UPolynomial k -\u003e Bool",
          "source": "src/Data-Polynomial-Base.html#divides",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "divides",
          "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eBool",
          "package": "toysolver",
          "signature": "UPolynomial k-\u003eUPolynomial k-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:divides"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluation\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "eval",
          "package": "toysolver",
          "signature": "(v -\u003e k) -\u003e Polynomial k v -\u003e k",
          "source": "src/Data-Polynomial-Base.html#eval",
          "type": "function"
        },
        "index": {
          "description": "Evaluation",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "eval",
          "normalized": "(a-\u003eb)-\u003ePolynomial b a-\u003eb",
          "package": "toysolver",
          "signature": "(v-\u003ek)-\u003ePolynomial k v-\u003ek",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:eval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtended GCD algorithm\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "exgcd",
          "package": "toysolver",
          "signature": "UPolynomial k -\u003e UPolynomial k -\u003e (UPolynomial k, UPolynomial k, UPolynomial k)",
          "source": "src/Data-Polynomial-Base.html#exgcd",
          "type": "function"
        },
        "index": {
          "description": "Extended GCD algorithm",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "exgcd",
          "normalized": "UPolynomial a-\u003eUPolynomial a-\u003e(UPolynomial a,UPolynomial a,UPolynomial a)",
          "package": "toysolver",
          "signature": "UPolynomial k-\u003eUPolynomial k-\u003e(UPolynomial k,UPolynomial k,UPolynomial k)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:exgcd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efactor a polynomial \u003ccode\u003ep\u003c/code\u003e into \u003ccode\u003ep1 ^ n1 + p2 ^ n2 + ..\u003c/code\u003e and\n return a list \u003ccode\u003e[(p1,n1), (p2,n2), ..]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "factor",
          "package": "toysolver",
          "signature": "a -\u003e [(a, Integer)]",
          "source": "src/Data-Polynomial-Base.html#factor",
          "type": "method"
        },
        "index": {
          "description": "factor polynomial into p1 n1 p2 n2 and return list p1 n1 p2 n2",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "factor",
          "normalized": "a-\u003e[(a,Integer)]",
          "package": "toysolver",
          "signature": "a-\u003e[(a,Integer)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:factor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "fromCoeffMap",
          "package": "toysolver",
          "signature": "Map (Monomial v) k -\u003e Polynomial k v",
          "source": "src/Data-Polynomial-Base.html#fromCoeffMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "fromCoeffMap",
          "normalized": "Map(Monomial a)b-\u003ePolynomial b a",
          "package": "toysolver",
          "partial": "Coeff Map",
          "signature": "Map(Monomial v)k-\u003ePolynomial k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:fromCoeffMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct a polynomial from a monomial\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "fromTerm",
          "package": "toysolver",
          "signature": "Term k v -\u003e Polynomial k v",
          "source": "src/Data-Polynomial-Base.html#fromTerm",
          "type": "function"
        },
        "index": {
          "description": "construct polynomial from monomial",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "fromTerm",
          "normalized": "Term a b-\u003ePolynomial a b",
          "package": "toysolver",
          "partial": "Term",
          "signature": "Term k v-\u003ePolynomial k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:fromTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct a polynomial from a list of monomials\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "fromTerms",
          "package": "toysolver",
          "signature": "[Term k v] -\u003e Polynomial k v",
          "source": "src/Data-Polynomial-Base.html#fromTerms",
          "type": "function"
        },
        "index": {
          "description": "construct polynomial from list of monomials",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "fromTerms",
          "normalized": "[Term a b]-\u003ePolynomial a b",
          "package": "toysolver",
          "partial": "Terms",
          "signature": "[Term k v]-\u003ePolynomial k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:fromTerms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGCD of univariate polynomials\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "gcd",
          "package": "toysolver",
          "signature": "UPolynomial k -\u003e UPolynomial k -\u003e UPolynomial k",
          "source": "src/Data-Polynomial-Base.html#gcd",
          "type": "function"
        },
        "index": {
          "description": "GCD of univariate polynomials",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "gcd",
          "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eUPolynomial a",
          "package": "toysolver",
          "signature": "UPolynomial k-\u003eUPolynomial k-\u003eUPolynomial k",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:gcd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGCD of univariate polynomials\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "gcd'",
          "package": "toysolver",
          "signature": "UPolynomial r -\u003e UPolynomial r -\u003e UPolynomial r",
          "source": "src/Data-Polynomial-Base.html#gcd%27",
          "type": "function"
        },
        "index": {
          "description": "GCD of univariate polynomials",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "gcd'",
          "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eUPolynomial a",
          "package": "toysolver",
          "signature": "UPolynomial r-\u003eUPolynomial r-\u003eUPolynomial r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:gcd-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraded reverse lexicographic order\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "grevlex",
          "package": "toysolver",
          "signature": "MonomialOrder v",
          "source": "src/Data-Polynomial-Base.html#grevlex",
          "type": "function"
        },
        "index": {
          "description": "Graded reverse lexicographic order",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "grevlex",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:grevlex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraded lexicographic order\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "grlex",
          "package": "toysolver",
          "signature": "MonomialOrder v",
          "source": "src/Data-Polynomial-Base.html#grlex",
          "type": "function"
        },
        "index": {
          "description": "Graded lexicographic order",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "grlex",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:grlex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal integral of polynomials\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "integral",
          "package": "toysolver",
          "signature": "Polynomial k v -\u003e v -\u003e Polynomial k v",
          "source": "src/Data-Polynomial-Base.html#integral",
          "type": "function"
        },
        "index": {
          "description": "Formal integral of polynomials",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "integral",
          "normalized": "Polynomial a b-\u003eb-\u003ePolynomial a b",
          "package": "toysolver",
          "signature": "Polynomial k v-\u003ev-\u003ePolynomial k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:integral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "isNegativeCoeff",
          "package": "toysolver",
          "signature": "a -\u003e Bool",
          "source": "src/Data-Polynomial-Base.html#isNegativeCoeff",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "isNegativeCoeff",
          "normalized": "a-\u003eBool",
          "package": "toysolver",
          "partial": "Negative Coeff",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:isNegativeCoeff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "isPrimitive",
          "package": "toysolver",
          "signature": "Polynomial k v -\u003e Bool",
          "source": "src/Data-Polynomial-Base.html#isPrimitive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "isPrimitive",
          "normalized": "Polynomial a b-\u003eBool",
          "package": "toysolver",
          "partial": "Primitive",
          "signature": "Polynomial k v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:isPrimitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "isRootOf",
          "package": "toysolver",
          "signature": "k -\u003e UPolynomial k -\u003e Bool",
          "source": "src/Data-Polynomial-Base.html#isRootOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "isRootOf",
          "normalized": "a-\u003eUPolynomial a-\u003eBool",
          "package": "toysolver",
          "partial": "Root Of",
          "signature": "k-\u003eUPolynomial k-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:isRootOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "isSquareFree",
          "package": "toysolver",
          "signature": "UPolynomial k -\u003e Bool",
          "source": "src/Data-Polynomial-Base.html#isSquareFree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "isSquareFree",
          "normalized": "UPolynomial a-\u003eBool",
          "package": "toysolver",
          "partial": "Square Free",
          "signature": "UPolynomial k-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:isSquareFree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleading coefficient with respect to a given monomial order\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "lc",
          "package": "toysolver",
          "signature": "MonomialOrder v -\u003e Polynomial k v -\u003e k",
          "source": "src/Data-Polynomial-Base.html#lc",
          "type": "function"
        },
        "index": {
          "description": "leading coefficient with respect to given monomial order",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "lc",
          "normalized": "MonomialOrder a-\u003ePolynomial b a-\u003eb",
          "package": "toysolver",
          "signature": "MonomialOrder v-\u003ePolynomial k v-\u003ek",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:lc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLCM of univariate polynomials\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "lcm",
          "package": "toysolver",
          "signature": "UPolynomial k -\u003e UPolynomial k -\u003e UPolynomial k",
          "source": "src/Data-Polynomial-Base.html#lcm",
          "type": "function"
        },
        "index": {
          "description": "LCM of univariate polynomials",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "lcm",
          "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eUPolynomial a",
          "package": "toysolver",
          "signature": "UPolynomial k-\u003eUPolynomial k-\u003eUPolynomial k",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:lcm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLexicographic order\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "lex",
          "package": "toysolver",
          "signature": "MonomialOrder v",
          "source": "src/Data-Polynomial-Base.html#lex",
          "type": "function"
        },
        "index": {
          "description": "Lexicographic order",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "lex",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:lex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleading monomial with respect to a given monomial order\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "lm",
          "package": "toysolver",
          "signature": "MonomialOrder v -\u003e Polynomial k v -\u003e Monomial v",
          "source": "src/Data-Polynomial-Base.html#lm",
          "type": "function"
        },
        "index": {
          "description": "leading monomial with respect to given monomial order",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "lm",
          "normalized": "MonomialOrder a-\u003ePolynomial b a-\u003eMonomial a",
          "package": "toysolver",
          "signature": "MonomialOrder v-\u003ePolynomial k v-\u003eMonomial v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:lm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "lookupCoeff",
          "package": "toysolver",
          "signature": "Monomial v -\u003e Polynomial k v -\u003e Maybe k",
          "source": "src/Data-Polynomial-Base.html#lookupCoeff",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "lookupCoeff",
          "normalized": "Monomial a-\u003ePolynomial b a-\u003eMaybe b",
          "package": "toysolver",
          "partial": "Coeff",
          "signature": "Monomial v-\u003ePolynomial k v-\u003eMaybe k",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:lookupCoeff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleading term with respect to a given monomial order\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "lt",
          "package": "toysolver",
          "signature": "MonomialOrder v -\u003e Polynomial k v -\u003e Term k v",
          "source": "src/Data-Polynomial-Base.html#lt",
          "type": "function"
        },
        "index": {
          "description": "leading term with respect to given monomial order",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "lt",
          "normalized": "MonomialOrder a-\u003ePolynomial b a-\u003eTerm b a",
          "package": "toysolver",
          "signature": "MonomialOrder v-\u003ePolynomial k v-\u003eTerm k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:lt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mapCoeff",
          "package": "toysolver",
          "signature": "(k -\u003e k1) -\u003e Polynomial k v -\u003e Polynomial k1 v",
          "source": "src/Data-Polynomial-Base.html#mapCoeff",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mapCoeff",
          "normalized": "(a-\u003ea)-\u003ePolynomial a b-\u003ePolynomial a b",
          "package": "toysolver",
          "partial": "Coeff",
          "signature": "(k-\u003ek)-\u003ePolynomial k v-\u003ePolynomial k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mapCoeff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mcoprime",
          "package": "toysolver",
          "signature": "Monomial v -\u003e Monomial v -\u003e Bool",
          "source": "src/Data-Polynomial-Base.html#mcoprime",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mcoprime",
          "normalized": "Monomial a-\u003eMonomial a-\u003eBool",
          "package": "toysolver",
          "signature": "Monomial v-\u003eMonomial v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mcoprime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mderiv",
          "package": "toysolver",
          "signature": "Monomial v -\u003e v -\u003e (Integer, Monomial v)",
          "source": "src/Data-Polynomial-Base.html#mderiv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mderiv",
          "normalized": "Monomial a-\u003ea-\u003e(Integer,Monomial a)",
          "package": "toysolver",
          "signature": "Monomial v-\u003ev-\u003e(Integer,Monomial v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mderiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mdiv",
          "package": "toysolver",
          "signature": "Monomial v -\u003e Monomial v -\u003e Monomial v",
          "source": "src/Data-Polynomial-Base.html#mdiv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mdiv",
          "normalized": "Monomial a-\u003eMonomial a-\u003eMonomial a",
          "package": "toysolver",
          "signature": "Monomial v-\u003eMonomial v-\u003eMonomial v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mdiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mdivides",
          "package": "toysolver",
          "signature": "Monomial v -\u003e Monomial v -\u003e Bool",
          "source": "src/Data-Polynomial-Base.html#mdivides",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mdivides",
          "normalized": "Monomial a-\u003eMonomial a-\u003eBool",
          "package": "toysolver",
          "signature": "Monomial v-\u003eMonomial v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mdivides"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mfromIndices",
          "package": "toysolver",
          "signature": "[(v, Integer)] -\u003e Monomial v",
          "source": "src/Data-Polynomial-Base.html#mfromIndices",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mfromIndices",
          "normalized": "[(a,Integer)]-\u003eMonomial a",
          "package": "toysolver",
          "partial": "Indices",
          "signature": "[(v,Integer)]-\u003eMonomial v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mfromIndices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mfromIndicesMap",
          "package": "toysolver",
          "signature": "Map v Integer -\u003e Monomial v",
          "source": "src/Data-Polynomial-Base.html#mfromIndicesMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mfromIndicesMap",
          "normalized": "Map a Integer-\u003eMonomial a",
          "package": "toysolver",
          "partial": "Indices Map",
          "signature": "Map v Integer-\u003eMonomial v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mfromIndicesMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mgcd",
          "package": "toysolver",
          "signature": "Monomial v -\u003e Monomial v -\u003e Monomial v",
          "source": "src/Data-Polynomial-Base.html#mgcd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mgcd",
          "normalized": "Monomial a-\u003eMonomial a-\u003eMonomial a",
          "package": "toysolver",
          "signature": "Monomial v-\u003eMonomial v-\u003eMonomial v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mgcd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mindices",
          "package": "toysolver",
          "signature": "Monomial v -\u003e [(v, Integer)]",
          "source": "src/Data-Polynomial-Base.html#mindices",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mindices",
          "normalized": "Monomial a-\u003e[(a,Integer)]",
          "package": "toysolver",
          "signature": "Monomial v-\u003e[(v,Integer)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mindices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mindicesMap",
          "package": "toysolver",
          "signature": "Monomial v -\u003e Map v Integer",
          "source": "src/Data-Polynomial-Base.html#mindicesMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mindicesMap",
          "normalized": "Monomial a-\u003eMap a Integer",
          "package": "toysolver",
          "partial": "Map",
          "signature": "Monomial v-\u003eMap v Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mindicesMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mintegral",
          "package": "toysolver",
          "signature": "Monomial v -\u003e v -\u003e (Rational, Monomial v)",
          "source": "src/Data-Polynomial-Base.html#mintegral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mintegral",
          "normalized": "Monomial a-\u003ea-\u003e(Rational,Monomial a)",
          "package": "toysolver",
          "signature": "Monomial v-\u003ev-\u003e(Rational,Monomial v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mintegral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mlcm",
          "package": "toysolver",
          "signature": "Monomial v -\u003e Monomial v -\u003e Monomial v",
          "source": "src/Data-Polynomial-Base.html#mlcm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mlcm",
          "normalized": "Monomial a-\u003eMonomial a-\u003eMonomial a",
          "package": "toysolver",
          "signature": "Monomial v-\u003eMonomial v-\u003eMonomial v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mlcm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mmult",
          "package": "toysolver",
          "signature": "Monomial v -\u003e Monomial v -\u003e Monomial v",
          "source": "src/Data-Polynomial-Base.html#mmult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mmult",
          "normalized": "Monomial a-\u003eMonomial a-\u003eMonomial a",
          "package": "toysolver",
          "signature": "Monomial v-\u003eMonomial v-\u003eMonomial v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mmult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edivision of univariate polynomials\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "mod",
          "package": "toysolver",
          "signature": "UPolynomial k -\u003e UPolynomial k -\u003e UPolynomial k",
          "source": "src/Data-Polynomial-Base.html#mod",
          "type": "function"
        },
        "index": {
          "description": "division of univariate polynomials",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mod",
          "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eUPolynomial a",
          "package": "toysolver",
          "signature": "UPolynomial k-\u003eUPolynomial k-\u003eUPolynomial k",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mone",
          "package": "toysolver",
          "signature": "Monomial v",
          "source": "src/Data-Polynomial-Base.html#mone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mone",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "mpow",
          "package": "toysolver",
          "signature": "Monomial v -\u003e Integer -\u003e Monomial v",
          "source": "src/Data-Polynomial-Base.html#mpow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "mpow",
          "normalized": "Monomial a-\u003eInteger-\u003eMonomial a",
          "package": "toysolver",
          "signature": "Monomial v-\u003eInteger-\u003eMonomial v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mpow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "pOptIsNegativeCoeff",
          "package": "toysolver",
          "signature": "k -\u003e Bool",
          "source": "src/Data-Polynomial-Base.html#PrintOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "pOptIsNegativeCoeff",
          "normalized": "a-\u003eBool",
          "package": "toysolver",
          "partial": "Opt Is Negative Coeff",
          "signature": "k-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pOptIsNegativeCoeff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "pOptMonomialOrder",
          "package": "toysolver",
          "signature": "MonomialOrder v",
          "source": "src/Data-Polynomial-Base.html#PrintOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "pOptMonomialOrder",
          "package": "toysolver",
          "partial": "Opt Monomial Order",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pOptMonomialOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "pOptPrintCoeff",
          "package": "toysolver",
          "signature": "PrettyLevel -\u003e Rational -\u003e k -\u003e Doc",
          "source": "src/Data-Polynomial-Base.html#PrintOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "pOptPrintCoeff",
          "normalized": "PrettyLevel-\u003eRational-\u003ea-\u003eDoc",
          "package": "toysolver",
          "partial": "Opt Print Coeff",
          "signature": "PrettyLevel-\u003eRational-\u003ek-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pOptPrintCoeff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "pOptPrintVar",
          "package": "toysolver",
          "signature": "PrettyLevel -\u003e Rational -\u003e v -\u003e Doc",
          "source": "src/Data-Polynomial-Base.html#PrintOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "pOptPrintVar",
          "normalized": "PrettyLevel-\u003eRational-\u003ea-\u003eDoc",
          "package": "toysolver",
          "partial": "Opt Print Var",
          "signature": "PrettyLevel-\u003eRational-\u003ev-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pOptPrintVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "pPrintCoeff",
          "package": "toysolver",
          "signature": "PrettyLevel -\u003e Rational -\u003e a -\u003e Doc",
          "source": "src/Data-Polynomial-Base.html#pPrintCoeff",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "pPrintCoeff",
          "normalized": "PrettyLevel-\u003eRational-\u003ea-\u003eDoc",
          "package": "toysolver",
          "partial": "Print Coeff",
          "signature": "PrettyLevel-\u003eRational-\u003ea-\u003eDoc",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pPrintCoeff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "pPrintVar",
          "package": "toysolver",
          "signature": "PrettyLevel -\u003e Rational -\u003e a -\u003e Doc",
          "source": "src/Data-Polynomial-Base.html#pPrintVar",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "pPrintVar",
          "normalized": "PrettyLevel-\u003eRational-\u003ea-\u003eDoc",
          "package": "toysolver",
          "partial": "Print Var",
          "signature": "PrettyLevel-\u003eRational-\u003ea-\u003eDoc",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pPrintVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epseudo quotient\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "pdiv",
          "package": "toysolver",
          "signature": "UPolynomial r -\u003e UPolynomial r -\u003e UPolynomial r",
          "source": "src/Data-Polynomial-Base.html#pdiv",
          "type": "function"
        },
        "index": {
          "description": "pseudo quotient",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "pdiv",
          "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eUPolynomial a",
          "package": "toysolver",
          "signature": "UPolynomial r-\u003eUPolynomial r-\u003eUPolynomial r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pdiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epseudo division\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "pdivMod",
          "package": "toysolver",
          "signature": "UPolynomial r -\u003e UPolynomial r -\u003e (r, UPolynomial r, UPolynomial r)",
          "source": "src/Data-Polynomial-Base.html#pdivMod",
          "type": "function"
        },
        "index": {
          "description": "pseudo division",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "pdivMod",
          "normalized": "UPolynomial a-\u003eUPolynomial a-\u003e(a,UPolynomial a,UPolynomial a)",
          "package": "toysolver",
          "partial": "Mod",
          "signature": "UPolynomial r-\u003eUPolynomial r-\u003e(r,UPolynomial r,UPolynomial r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pdivMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epseudo reminder\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "pmod",
          "package": "toysolver",
          "signature": "UPolynomial r -\u003e UPolynomial r -\u003e UPolynomial r",
          "source": "src/Data-Polynomial-Base.html#pmod",
          "type": "function"
        },
        "index": {
          "description": "pseudo reminder",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "pmod",
          "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eUPolynomial a",
          "package": "toysolver",
          "signature": "UPolynomial r-\u003eUPolynomial r-\u003eUPolynomial r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pmod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimitive part of a polynomial\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "pp",
          "package": "toysolver",
          "signature": "Polynomial k v -\u003e Polynomial k v",
          "source": "src/Data-Polynomial-Base.html#pp",
          "type": "method"
        },
        "index": {
          "description": "Primitive part of polynomial",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "pp",
          "normalized": "Polynomial a b-\u003ePolynomial a b",
          "package": "toysolver",
          "signature": "Polynomial k v-\u003ePolynomial k v",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "prettyPrint",
          "package": "toysolver",
          "signature": "PrintOptions k v -\u003e PrettyLevel -\u003e Rational -\u003e Polynomial k v -\u003e Doc",
          "source": "src/Data-Polynomial-Base.html#prettyPrint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "prettyPrint",
          "normalized": "PrintOptions a b-\u003ePrettyLevel-\u003eRational-\u003ePolynomial a b-\u003eDoc",
          "package": "toysolver",
          "partial": "Print",
          "signature": "PrintOptions k v-\u003ePrettyLevel-\u003eRational-\u003ePolynomial k v-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:prettyPrint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultivariate division algorithm\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "reduce",
          "package": "toysolver",
          "signature": "MonomialOrder v -\u003e Polynomial k v -\u003e [Polynomial k v] -\u003e Polynomial k v",
          "source": "src/Data-Polynomial-Base.html#reduce",
          "type": "function"
        },
        "index": {
          "description": "Multivariate division algorithm",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "reduce",
          "normalized": "MonomialOrder a-\u003ePolynomial b a-\u003e[Polynomial b a]-\u003ePolynomial b a",
          "package": "toysolver",
          "signature": "MonomialOrder v-\u003ePolynomial k v-\u003e[Polynomial k v]-\u003ePolynomial k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:reduce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse lexicographic order.\n\u003c/p\u003e\u003cp\u003eNote that revlex is NOT a monomial order.\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "revlex",
          "package": "toysolver",
          "signature": "Monomial v -\u003e Monomial v -\u003e Ordering",
          "source": "src/Data-Polynomial-Base.html#revlex",
          "type": "function"
        },
        "index": {
          "description": "Reverse lexicographic order Note that revlex is NOT monomial order",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "revlex",
          "normalized": "Monomial a-\u003eMonomial a-\u003eOrdering",
          "package": "toysolver",
          "signature": "Monomial v-\u003eMonomial v-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:revlex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efactor a polynomial \u003ccode\u003ep\u003c/code\u003e into \u003ccode\u003ep1 ^ n1 + p2 ^ n2 + ..\u003c/code\u003e and\n return a list \u003ccode\u003e[(p1,n1), (p2,n2), ..]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "sqfree",
          "package": "toysolver",
          "signature": "a -\u003e [(a, Integer)]",
          "source": "src/Data-Polynomial-Base.html#sqfree",
          "type": "method"
        },
        "index": {
          "description": "factor polynomial into p1 n1 p2 n2 and return list p1 n1 p2 n2",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "sqfree",
          "normalized": "a-\u003e[(a,Integer)]",
          "package": "toysolver",
          "signature": "a-\u003e[(a,Integer)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:sqfree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubstitution or bind\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "subst",
          "package": "toysolver",
          "signature": "Polynomial k v1 -\u003e (v1 -\u003e Polynomial k v2) -\u003e Polynomial k v2",
          "source": "src/Data-Polynomial-Base.html#subst",
          "type": "function"
        },
        "index": {
          "description": "Substitution or bind",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "subst",
          "normalized": "Polynomial a b-\u003e(b-\u003ePolynomial a b)-\u003ePolynomial a b",
          "package": "toysolver",
          "signature": "Polynomial k v-\u003e(v-\u003ePolynomial k v)-\u003ePolynomial k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:subst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "tdeg",
          "package": "toysolver",
          "signature": "Term k v -\u003e Integer",
          "source": "src/Data-Polynomial-Base.html#tdeg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "tdeg",
          "normalized": "Term a b-\u003eInteger",
          "package": "toysolver",
          "signature": "Term k v-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:tdeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "tderiv",
          "package": "toysolver",
          "signature": "Term k v -\u003e v -\u003e Term k v",
          "source": "src/Data-Polynomial-Base.html#tderiv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "tderiv",
          "normalized": "Term a b-\u003eb-\u003eTerm a b",
          "package": "toysolver",
          "signature": "Term k v-\u003ev-\u003eTerm k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:tderiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "tdiv",
          "package": "toysolver",
          "signature": "Term k v -\u003e Term k v -\u003e Term k v",
          "source": "src/Data-Polynomial-Base.html#tdiv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "tdiv",
          "normalized": "Term a b-\u003eTerm a b-\u003eTerm a b",
          "package": "toysolver",
          "signature": "Term k v-\u003eTerm k v-\u003eTerm k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:tdiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "tdivides",
          "package": "toysolver",
          "signature": "Term k v -\u003e Term k v -\u003e Bool",
          "source": "src/Data-Polynomial-Base.html#tdivides",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "tdivides",
          "normalized": "Term a b-\u003eTerm a b-\u003eBool",
          "package": "toysolver",
          "signature": "Term k v-\u003eTerm k v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:tdivides"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist of monomials\n\u003c/p\u003e",
          "module": "Data.Polynomial",
          "name": "terms",
          "package": "toysolver",
          "signature": "Polynomial k v -\u003e [Term k v]",
          "source": "src/Data-Polynomial-Base.html#terms",
          "type": "function"
        },
        "index": {
          "description": "list of monomials",
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "terms",
          "normalized": "Polynomial a b-\u003e[Term a b]",
          "package": "toysolver",
          "signature": "Polynomial k v-\u003e[Term k v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:terms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "tintegral",
          "package": "toysolver",
          "signature": "Term k v -\u003e v -\u003e Term k v",
          "source": "src/Data-Polynomial-Base.html#tintegral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "tintegral",
          "normalized": "Term a b-\u003eb-\u003eTerm a b",
          "package": "toysolver",
          "signature": "Term k v-\u003ev-\u003eTerm k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:tintegral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "tmult",
          "package": "toysolver",
          "signature": "Term k v -\u003e Term k v -\u003e Term k v",
          "source": "src/Data-Polynomial-Base.html#tmult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "tmult",
          "normalized": "Term a b-\u003eTerm a b-\u003eTerm a b",
          "package": "toysolver",
          "signature": "Term k v-\u003eTerm k v-\u003eTerm k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:tmult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "toMonic",
          "package": "toysolver",
          "signature": "MonomialOrder v -\u003e Polynomial r v -\u003e Polynomial r v",
          "source": "src/Data-Polynomial-Base.html#toMonic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "toMonic",
          "normalized": "MonomialOrder a-\u003ePolynomial b a-\u003ePolynomial b a",
          "package": "toysolver",
          "partial": "Monic",
          "signature": "MonomialOrder v-\u003ePolynomial r v-\u003ePolynomial r v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:toMonic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "toUPolynomialOf",
          "package": "toysolver",
          "signature": "Polynomial k v -\u003e v -\u003e UPolynomial (Polynomial k v)",
          "source": "src/Data-Polynomial-Base.html#toUPolynomialOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "toUPolynomialOf",
          "normalized": "Polynomial a b-\u003eb-\u003eUPolynomial(Polynomial a b)",
          "package": "toysolver",
          "partial": "UPolynomial Of",
          "signature": "Polynomial k v-\u003ev-\u003eUPolynomial(Polynomial k v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:toUPolynomialOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "var",
          "package": "toysolver",
          "signature": "v -\u003e a",
          "source": "src/Data-Polynomial-Base.html#var",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "var",
          "normalized": "a-\u003eb",
          "package": "toysolver",
          "signature": "v-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Polynomial",
          "name": "vars",
          "package": "toysolver",
          "signature": "a -\u003e Set v",
          "source": "src/Data-Polynomial-Base.html#vars",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Polynomial",
          "module": "Data.Polynomial",
          "name": "vars",
          "normalized": "a-\u003eSet b",
          "package": "toysolver",
          "signature": "a-\u003eSet v",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:vars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAlgebra of Signs.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Sign",
          "name": "Sign",
          "package": "toysolver",
          "source": "src/Data-Sign.html",
          "type": "module"
        },
        "index": {
          "description": "Algebra of Signs",
          "hierarchy": "Data Sign",
          "module": "Data.Sign",
          "name": "Sign",
          "package": "toysolver",
          "partial": "Sign",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sign",
          "name": "Sign",
          "package": "toysolver",
          "source": "src/Data-Sign.html#Sign",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Sign",
          "module": "Data.Sign",
          "name": "Sign",
          "package": "toysolver",
          "partial": "Sign",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#t:Sign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sign",
          "name": "Neg",
          "package": "toysolver",
          "signature": "Neg",
          "source": "src/Data-Sign.html#Sign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sign",
          "module": "Data.Sign",
          "name": "Neg",
          "package": "toysolver",
          "partial": "Neg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:Neg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sign",
          "name": "Pos",
          "package": "toysolver",
          "signature": "Pos",
          "source": "src/Data-Sign.html#Sign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sign",
          "module": "Data.Sign",
          "name": "Pos",
          "package": "toysolver",
          "partial": "Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:Pos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sign",
          "name": "Zero",
          "package": "toysolver",
          "signature": "Zero",
          "source": "src/Data-Sign.html#Sign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sign",
          "module": "Data.Sign",
          "name": "Zero",
          "package": "toysolver",
          "partial": "Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:Zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sign",
          "name": "div",
          "package": "toysolver",
          "signature": "Sign -\u003e Sign -\u003e Sign",
          "source": "src/Data-Sign.html#div",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sign",
          "module": "Data.Sign",
          "name": "div",
          "normalized": "Sign-\u003eSign-\u003eSign",
          "package": "toysolver",
          "signature": "Sign-\u003eSign-\u003eSign",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sign",
          "name": "mult",
          "package": "toysolver",
          "signature": "Sign -\u003e Sign -\u003e Sign",
          "source": "src/Data-Sign.html#mult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sign",
          "module": "Data.Sign",
          "name": "mult",
          "normalized": "Sign-\u003eSign-\u003eSign",
          "package": "toysolver",
          "signature": "Sign-\u003eSign-\u003eSign",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:mult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sign",
          "name": "negate",
          "package": "toysolver",
          "signature": "Sign -\u003e Sign",
          "source": "src/Data-Sign.html#negate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sign",
          "module": "Data.Sign",
          "name": "negate",
          "normalized": "Sign-\u003eSign",
          "package": "toysolver",
          "signature": "Sign-\u003eSign",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sign",
          "name": "pow",
          "package": "toysolver",
          "signature": "Sign -\u003e x -\u003e Sign",
          "source": "src/Data-Sign.html#pow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sign",
          "module": "Data.Sign",
          "name": "pow",
          "normalized": "Sign-\u003ea-\u003eSign",
          "package": "toysolver",
          "signature": "Sign-\u003ex-\u003eSign",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:pow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sign",
          "name": "recip",
          "package": "toysolver",
          "signature": "Sign -\u003e Sign",
          "source": "src/Data-Sign.html#recip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sign",
          "module": "Data.Sign",
          "name": "recip",
          "normalized": "Sign-\u003eSign",
          "package": "toysolver",
          "signature": "Sign-\u003eSign",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sign",
          "name": "signOf",
          "package": "toysolver",
          "signature": "a -\u003e Sign",
          "source": "src/Data-Sign.html#signOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sign",
          "module": "Data.Sign",
          "name": "signOf",
          "normalized": "a-\u003eSign",
          "package": "toysolver",
          "partial": "Of",
          "signature": "a-\u003eSign",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:signOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sign",
          "name": "symbol",
          "package": "toysolver",
          "signature": "Sign -\u003e String",
          "source": "src/Data-Sign.html#symbol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Sign",
          "module": "Data.Sign",
          "name": "symbol",
          "normalized": "Sign-\u003eString",
          "package": "toysolver",
          "signature": "Sign-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Var",
          "name": "Var",
          "package": "toysolver",
          "source": "src/Data-Var.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Var",
          "module": "Data.Var",
          "name": "Var",
          "package": "toysolver",
          "partial": "Var",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Var.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003eModel\u003c/code\u003e is a map from variables to values.\n\u003c/p\u003e",
          "module": "Data.Var",
          "name": "Model",
          "package": "toysolver",
          "source": "src/Data-Var.html#Model",
          "type": "type"
        },
        "index": {
          "description": "Model is map from variables to values",
          "hierarchy": "Data Var",
          "module": "Data.Var",
          "name": "Model",
          "package": "toysolver",
          "partial": "Model",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Var.html#t:Model"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariables are represented as non-negative integers\n\u003c/p\u003e",
          "module": "Data.Var",
          "name": "Var",
          "package": "toysolver",
          "source": "src/Data-Var.html#Var",
          "type": "type"
        },
        "index": {
          "description": "Variables are represented as non-negative integers",
          "hierarchy": "Data Var",
          "module": "Data.Var",
          "name": "Var",
          "package": "toysolver",
          "partial": "Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Var.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap from variables\n\u003c/p\u003e",
          "module": "Data.Var",
          "name": "VarMap",
          "package": "toysolver",
          "source": "src/Data-Var.html#VarMap",
          "type": "type"
        },
        "index": {
          "description": "Map from variables",
          "hierarchy": "Data Var",
          "module": "Data.Var",
          "name": "VarMap",
          "package": "toysolver",
          "partial": "Var Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Var.html#t:VarMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet of variables\n\u003c/p\u003e",
          "module": "Data.Var",
          "name": "VarSet",
          "package": "toysolver",
          "source": "src/Data-Var.html#VarSet",
          "type": "type"
        },
        "index": {
          "description": "Set of variables",
          "hierarchy": "Data Var",
          "module": "Data.Var",
          "name": "VarSet",
          "package": "toysolver",
          "partial": "Var Set",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Var.html#t:VarSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecollecting free variables\n\u003c/p\u003e",
          "module": "Data.Var",
          "name": "Variables",
          "package": "toysolver",
          "source": "src/Data-Var.html#Variables",
          "type": "class"
        },
        "index": {
          "description": "collecting free variables",
          "hierarchy": "Data Var",
          "module": "Data.Var",
          "name": "Variables",
          "package": "toysolver",
          "partial": "Variables",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Var.html#t:Variables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Var",
          "name": "vars",
          "package": "toysolver",
          "signature": "a -\u003e VarSet",
          "source": "src/Data-Var.html#vars",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Var",
          "module": "Data.Var",
          "name": "vars",
          "normalized": "a-\u003eVarSet",
          "package": "toysolver",
          "signature": "a-\u003eVarSet",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Var.html#v:vars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.CAMUS",
          "name": "CAMUS",
          "package": "toysolver",
          "source": "src/SAT-CAMUS.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "SAT CAMUS",
          "module": "SAT.CAMUS",
          "name": "CAMUS",
          "package": "toysolver",
          "partial": "CAMUS",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.CAMUS",
          "name": "MCS",
          "package": "toysolver",
          "source": "src/SAT-CAMUS.html#MCS",
          "type": "type"
        },
        "index": {
          "hierarchy": "SAT CAMUS",
          "module": "SAT.CAMUS",
          "name": "MCS",
          "package": "toysolver",
          "partial": "MCS",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#t:MCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.CAMUS",
          "name": "MUS",
          "package": "toysolver",
          "source": "src/SAT-CAMUS.html#MUS",
          "type": "type"
        },
        "index": {
          "hierarchy": "SAT CAMUS",
          "module": "SAT.CAMUS",
          "name": "MUS",
          "package": "toysolver",
          "partial": "MUS",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#t:MUS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptions for \u003ccode\u003e\u003ca\u003eenumMCSAssumptions\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eallMCSAssumptions\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eallMUSAssumptions\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "SAT.CAMUS",
          "name": "Options",
          "package": "toysolver",
          "source": "src/SAT-CAMUS.html#Options",
          "type": "data"
        },
        "index": {
          "description": "Options for enumMCSAssumptions allMCSAssumptions allMUSAssumptions",
          "hierarchy": "SAT CAMUS",
          "module": "SAT.CAMUS",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#t:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.CAMUS",
          "name": "Options",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/SAT-CAMUS.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT CAMUS",
          "module": "SAT.CAMUS",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.CAMUS",
          "name": "allMCSAssumptions",
          "package": "toysolver",
          "signature": "Solver -\u003e [Lit] -\u003e Options -\u003e IO [MCS]",
          "source": "src/SAT-CAMUS.html#allMCSAssumptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT CAMUS",
          "module": "SAT.CAMUS",
          "name": "allMCSAssumptions",
          "normalized": "Solver-\u003e[Lit]-\u003eOptions-\u003eIO[MCS]",
          "package": "toysolver",
          "partial": "MCSAssumptions",
          "signature": "Solver-\u003e[Lit]-\u003eOptions-\u003eIO[MCS]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:allMCSAssumptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.CAMUS",
          "name": "allMUSAssumptions",
          "package": "toysolver",
          "signature": "Solver -\u003e [Lit] -\u003e Options -\u003e IO [MCS]",
          "source": "src/SAT-CAMUS.html#allMUSAssumptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT CAMUS",
          "module": "SAT.CAMUS",
          "name": "allMUSAssumptions",
          "normalized": "Solver-\u003e[Lit]-\u003eOptions-\u003eIO[MCS]",
          "package": "toysolver",
          "partial": "MUSAssumptions",
          "signature": "Solver-\u003e[Lit]-\u003eOptions-\u003eIO[MCS]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:allMUSAssumptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault \u003ccode\u003e\u003ca\u003eOptions\u003c/a\u003e\u003c/code\u003e value\n\u003c/p\u003e",
          "module": "SAT.CAMUS",
          "name": "defaultOptions",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/SAT-CAMUS.html#defaultOptions",
          "type": "function"
        },
        "index": {
          "description": "default Options value",
          "hierarchy": "SAT CAMUS",
          "module": "SAT.CAMUS",
          "name": "defaultOptions",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:defaultOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.CAMUS",
          "name": "enumMCSAssumptions",
          "package": "toysolver",
          "signature": "Solver -\u003e [Lit] -\u003e Options -\u003e IO ()",
          "source": "src/SAT-CAMUS.html#enumMCSAssumptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT CAMUS",
          "module": "SAT.CAMUS",
          "name": "enumMCSAssumptions",
          "normalized": "Solver-\u003e[Lit]-\u003eOptions-\u003eIO()",
          "package": "toysolver",
          "partial": "MCSAssumptions",
          "signature": "Solver-\u003e[Lit]-\u003eOptions-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:enumMCSAssumptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.CAMUS",
          "name": "hittingSetDual",
          "package": "toysolver",
          "signature": "[MCS] -\u003e [MUS]",
          "source": "src/SAT-CAMUS.html#hittingSetDual",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT CAMUS",
          "module": "SAT.CAMUS",
          "name": "hittingSetDual",
          "normalized": "[MCS]-\u003e[MUS]",
          "package": "toysolver",
          "partial": "Set Dual",
          "signature": "[MCS]-\u003e[MUS]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:hittingSetDual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.CAMUS",
          "name": "optCallback",
          "package": "toysolver",
          "signature": "MCS -\u003e IO ()",
          "source": "src/SAT-CAMUS.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT CAMUS",
          "module": "SAT.CAMUS",
          "name": "optCallback",
          "normalized": "MCS-\u003eIO()",
          "package": "toysolver",
          "partial": "Callback",
          "signature": "MCS-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:optCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.CAMUS",
          "name": "optLogger",
          "package": "toysolver",
          "signature": "String -\u003e IO ()",
          "source": "src/SAT-CAMUS.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT CAMUS",
          "module": "SAT.CAMUS",
          "name": "optLogger",
          "normalized": "String-\u003eIO()",
          "package": "toysolver",
          "partial": "Logger",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:optLogger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Integer",
          "name": "Integer",
          "package": "toysolver",
          "source": "src/SAT-Integer.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "SAT Integer",
          "module": "SAT.Integer",
          "name": "Integer",
          "package": "toysolver",
          "partial": "Integer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Integer",
          "name": "Expr",
          "package": "toysolver",
          "source": "src/SAT-Integer.html#Expr",
          "type": "data"
        },
        "index": {
          "hierarchy": "SAT Integer",
          "module": "SAT.Integer",
          "name": "Expr",
          "package": "toysolver",
          "partial": "Expr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#t:Expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Integer",
          "name": "Expr",
          "package": "toysolver",
          "signature": "Expr [(Integer, [Lit])]",
          "source": "src/SAT-Integer.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Integer",
          "module": "SAT.Integer",
          "name": "Expr",
          "normalized": "Expr[(Integer,[Lit])]",
          "package": "toysolver",
          "partial": "Expr",
          "signature": "Expr[(Integer,[Lit])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#v:Expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Integer",
          "name": "addConstraint",
          "package": "toysolver",
          "signature": "Encoder -\u003e Rel Expr -\u003e IO ()",
          "source": "src/SAT-Integer.html#addConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Integer",
          "module": "SAT.Integer",
          "name": "addConstraint",
          "normalized": "Encoder-\u003eRel Expr-\u003eIO()",
          "package": "toysolver",
          "partial": "Constraint",
          "signature": "Encoder-\u003eRel Expr-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#v:addConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Integer",
          "name": "addConstraintSoft",
          "package": "toysolver",
          "signature": "Encoder -\u003e Lit -\u003e Rel Expr -\u003e IO ()",
          "source": "src/SAT-Integer.html#addConstraintSoft",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Integer",
          "module": "SAT.Integer",
          "name": "addConstraintSoft",
          "normalized": "Encoder-\u003eLit-\u003eRel Expr-\u003eIO()",
          "package": "toysolver",
          "partial": "Constraint Soft",
          "signature": "Encoder-\u003eLit-\u003eRel Expr-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#v:addConstraintSoft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Integer",
          "name": "eval",
          "package": "toysolver",
          "signature": "Model -\u003e Expr -\u003e Integer",
          "source": "src/SAT-Integer.html#eval",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Integer",
          "module": "SAT.Integer",
          "name": "eval",
          "normalized": "Model-\u003eExpr-\u003eInteger",
          "package": "toysolver",
          "signature": "Model-\u003eExpr-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#v:eval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Integer",
          "name": "linearize",
          "package": "toysolver",
          "signature": "Encoder -\u003e Expr -\u003e IO ([(Integer, Lit)], Integer)",
          "source": "src/SAT-Integer.html#linearize",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Integer",
          "module": "SAT.Integer",
          "name": "linearize",
          "normalized": "Encoder-\u003eExpr-\u003eIO([(Integer,Lit)],Integer)",
          "package": "toysolver",
          "signature": "Encoder-\u003eExpr-\u003eIO([(Integer,Lit)],Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#v:linearize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Integer",
          "name": "newVar",
          "package": "toysolver",
          "signature": "Solver -\u003e Integer -\u003e Integer -\u003e IO Expr",
          "source": "src/SAT-Integer.html#newVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Integer",
          "module": "SAT.Integer",
          "name": "newVar",
          "normalized": "Solver-\u003eInteger-\u003eInteger-\u003eIO Expr",
          "package": "toysolver",
          "partial": "Var",
          "signature": "Solver-\u003eInteger-\u003eInteger-\u003eIO Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#v:newVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMinimal Unsatifiable Subset (MUS) Finder\n\u003c/p\u003e\u003c/div\u003e",
          "module": "SAT.MUS",
          "name": "MUS",
          "package": "toysolver",
          "source": "src/SAT-MUS.html",
          "type": "module"
        },
        "index": {
          "description": "Minimal Unsatifiable Subset MUS Finder",
          "hierarchy": "SAT MUS",
          "module": "SAT.MUS",
          "name": "MUS",
          "package": "toysolver",
          "partial": "MUS",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptions for \u003ccode\u003e\u003ca\u003efindMUSAssumptions\u003c/a\u003e\u003c/code\u003e function\n\u003c/p\u003e",
          "module": "SAT.MUS",
          "name": "Options",
          "package": "toysolver",
          "source": "src/SAT-MUS.html#Options",
          "type": "data"
        },
        "index": {
          "description": "Options for findMUSAssumptions function",
          "hierarchy": "SAT MUS",
          "module": "SAT.MUS",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#t:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.MUS",
          "name": "Options",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/SAT-MUS.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT MUS",
          "module": "SAT.MUS",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#v:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault \u003ccode\u003e\u003ca\u003eOptions\u003c/a\u003e\u003c/code\u003e value\n\u003c/p\u003e",
          "module": "SAT.MUS",
          "name": "defaultOptions",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/SAT-MUS.html#defaultOptions",
          "type": "function"
        },
        "index": {
          "description": "default Options value",
          "hierarchy": "SAT MUS",
          "module": "SAT.MUS",
          "name": "defaultOptions",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#v:defaultOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a minimal set of assumptions that causes a conflict.\n Initial set of assumptions is taken from \u003ccode\u003e\u003ca\u003efailedAssumptions\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "SAT.MUS",
          "name": "findMUSAssumptions",
          "package": "toysolver",
          "signature": "Solver -\u003e Options -\u003e IO [Lit]",
          "source": "src/SAT-MUS.html#findMUSAssumptions",
          "type": "function"
        },
        "index": {
          "description": "Find minimal set of assumptions that causes conflict Initial set of assumptions is taken from failedAssumptions",
          "hierarchy": "SAT MUS",
          "module": "SAT.MUS",
          "name": "findMUSAssumptions",
          "normalized": "Solver-\u003eOptions-\u003eIO[Lit]",
          "package": "toysolver",
          "partial": "MUSAssumptions",
          "signature": "Solver-\u003eOptions-\u003eIO[Lit]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#v:findMUSAssumptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.MUS",
          "name": "optLitPrinter",
          "package": "toysolver",
          "signature": "Lit -\u003e String",
          "source": "src/SAT-MUS.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT MUS",
          "module": "SAT.MUS",
          "name": "optLitPrinter",
          "normalized": "Lit-\u003eString",
          "package": "toysolver",
          "partial": "Lit Printer",
          "signature": "Lit-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#v:optLitPrinter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.MUS",
          "name": "optLogger",
          "package": "toysolver",
          "signature": "String -\u003e IO ()",
          "source": "src/SAT-MUS.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT MUS",
          "module": "SAT.MUS",
          "name": "optLogger",
          "normalized": "String-\u003eIO()",
          "package": "toysolver",
          "partial": "Logger",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#v:optLogger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.MUS",
          "name": "optUpdateBest",
          "package": "toysolver",
          "signature": "[Lit] -\u003e IO ()",
          "source": "src/SAT-MUS.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT MUS",
          "module": "SAT.MUS",
          "name": "optUpdateBest",
          "normalized": "[Lit]-\u003eIO()",
          "package": "toysolver",
          "partial": "Update Best",
          "signature": "[Lit]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#v:optUpdateBest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Jo&#227;o P. Marques-Silva and Jordi Planes.\n   Algorithms for Maximum Satisfiability using Unsatisfiable Cores.\n   In Design, Automation and Test in Europe, 2008 (DATE '08). March 2008.\n   pp. 408-413, doi:10.1109/date.2008.4484715.\n   \u003ca\u003ehttp://dx.doi.org/10.1109/date.2008.4484715\u003c/a\u003e\n   \u003ca\u003ehttp://eprints.soton.ac.uk/265000/1/jpms-date08.pdf\u003c/a\u003e\n   \u003ca\u003ehttp://www.csi.ucd.ie/staff/jpms/talks/talksite/jpms-date08.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "SAT.PBO.MSU4",
          "name": "MSU4",
          "package": "toysolver",
          "source": "src/SAT-PBO-MSU4.html",
          "type": "module"
        },
        "index": {
          "description": "Reference Jo Marques-Silva and Jordi Planes Algorithms for Maximum Satisfiability using Unsatisfiable Cores In Design Automation and Test in Europe DATE March pp doi date.2008.4484715 http dx.doi.org date.2008.4484715 http eprints.soton.ac.uk jpms-date08.pdf http www.csi.ucd.ie staff jpms talks talksite jpms-date08.pdf",
          "hierarchy": "SAT PBO MSU4",
          "module": "SAT.PBO.MSU4",
          "name": "MSU4",
          "package": "toysolver",
          "partial": "MSU",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.MSU4",
          "name": "Options",
          "package": "toysolver",
          "source": "src/SAT-PBO-MSU4.html#Options",
          "type": "data"
        },
        "index": {
          "hierarchy": "SAT PBO MSU4",
          "module": "SAT.PBO.MSU4",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#t:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.MSU4",
          "name": "Options",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/SAT-PBO-MSU4.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO MSU4",
          "module": "SAT.PBO.MSU4",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#v:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.MSU4",
          "name": "defaultOptions",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/SAT-PBO-MSU4.html#defaultOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO MSU4",
          "module": "SAT.PBO.MSU4",
          "name": "defaultOptions",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#v:defaultOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.MSU4",
          "name": "optLogger",
          "package": "toysolver",
          "signature": "String -\u003e IO ()",
          "source": "src/SAT-PBO-MSU4.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO MSU4",
          "module": "SAT.PBO.MSU4",
          "name": "optLogger",
          "normalized": "String-\u003eIO()",
          "package": "toysolver",
          "partial": "Logger",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#v:optLogger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.MSU4",
          "name": "optUpdateBest",
          "package": "toysolver",
          "signature": "Model -\u003e Integer -\u003e IO ()",
          "source": "src/SAT-PBO-MSU4.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO MSU4",
          "module": "SAT.PBO.MSU4",
          "name": "optUpdateBest",
          "normalized": "Model-\u003eInteger-\u003eIO()",
          "package": "toysolver",
          "partial": "Update Best",
          "signature": "Model-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#v:optUpdateBest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.MSU4",
          "name": "optUpdateLB",
          "package": "toysolver",
          "signature": "Integer -\u003e IO ()",
          "source": "src/SAT-PBO-MSU4.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO MSU4",
          "module": "SAT.PBO.MSU4",
          "name": "optUpdateLB",
          "normalized": "Integer-\u003eIO()",
          "package": "toysolver",
          "partial": "Update LB",
          "signature": "Integer-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#v:optUpdateLB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.MSU4",
          "name": "solve",
          "package": "toysolver",
          "signature": "Solver -\u003e [(Integer, Lit)] -\u003e Options -\u003e IO (Maybe Model)",
          "source": "src/SAT-PBO-MSU4.html#solve",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO MSU4",
          "module": "SAT.PBO.MSU4",
          "name": "solve",
          "normalized": "Solver-\u003e[(Integer,Lit)]-\u003eOptions-\u003eIO(Maybe Model)",
          "package": "toysolver",
          "signature": "Solver-\u003e[(Integer,Lit)]-\u003eOptions-\u003eIO(Maybe Model)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#v:solve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.MSU4",
          "name": "solveWBO",
          "package": "toysolver",
          "signature": "Solver -\u003e [(Lit, Integer)] -\u003e Options -\u003e IO (Maybe (Model, Integer))",
          "source": "src/SAT-PBO-MSU4.html#solveWBO",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO MSU4",
          "module": "SAT.PBO.MSU4",
          "name": "solveWBO",
          "normalized": "Solver-\u003e[(Lit,Integer)]-\u003eOptions-\u003eIO(Maybe(Model,Integer))",
          "package": "toysolver",
          "partial": "WBO",
          "signature": "Solver-\u003e[(Lit,Integer)]-\u003eOptions-\u003eIO(Maybe(Model,Integer))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#v:solveWBO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.UnsatBased",
          "name": "UnsatBased",
          "package": "toysolver",
          "source": "src/SAT-PBO-UnsatBased.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "SAT PBO UnsatBased",
          "module": "SAT.PBO.UnsatBased",
          "name": "UnsatBased",
          "package": "toysolver",
          "partial": "Unsat Based",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.UnsatBased",
          "name": "Options",
          "package": "toysolver",
          "source": "src/SAT-PBO-UnsatBased.html#Options",
          "type": "data"
        },
        "index": {
          "hierarchy": "SAT PBO UnsatBased",
          "module": "SAT.PBO.UnsatBased",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#t:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.UnsatBased",
          "name": "Options",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/SAT-PBO-UnsatBased.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO UnsatBased",
          "module": "SAT.PBO.UnsatBased",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#v:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.UnsatBased",
          "name": "defaultOptions",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/SAT-PBO-UnsatBased.html#defaultOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO UnsatBased",
          "module": "SAT.PBO.UnsatBased",
          "name": "defaultOptions",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#v:defaultOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.UnsatBased",
          "name": "optLogger",
          "package": "toysolver",
          "signature": "String -\u003e IO ()",
          "source": "src/SAT-PBO-UnsatBased.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO UnsatBased",
          "module": "SAT.PBO.UnsatBased",
          "name": "optLogger",
          "normalized": "String-\u003eIO()",
          "package": "toysolver",
          "partial": "Logger",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#v:optLogger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.UnsatBased",
          "name": "optUpdateBest",
          "package": "toysolver",
          "signature": "Model -\u003e Integer -\u003e IO ()",
          "source": "src/SAT-PBO-UnsatBased.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO UnsatBased",
          "module": "SAT.PBO.UnsatBased",
          "name": "optUpdateBest",
          "normalized": "Model-\u003eInteger-\u003eIO()",
          "package": "toysolver",
          "partial": "Update Best",
          "signature": "Model-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#v:optUpdateBest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.UnsatBased",
          "name": "optUpdateLB",
          "package": "toysolver",
          "signature": "Integer -\u003e IO ()",
          "source": "src/SAT-PBO-UnsatBased.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO UnsatBased",
          "module": "SAT.PBO.UnsatBased",
          "name": "optUpdateLB",
          "normalized": "Integer-\u003eIO()",
          "package": "toysolver",
          "partial": "Update LB",
          "signature": "Integer-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#v:optUpdateLB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.UnsatBased",
          "name": "solve",
          "package": "toysolver",
          "signature": "Solver -\u003e [(Integer, Lit)] -\u003e Options -\u003e IO (Maybe Model)",
          "source": "src/SAT-PBO-UnsatBased.html#solve",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO UnsatBased",
          "module": "SAT.PBO.UnsatBased",
          "name": "solve",
          "normalized": "Solver-\u003e[(Integer,Lit)]-\u003eOptions-\u003eIO(Maybe Model)",
          "package": "toysolver",
          "signature": "Solver-\u003e[(Integer,Lit)]-\u003eOptions-\u003eIO(Maybe Model)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#v:solve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO.UnsatBased",
          "name": "solveWBO",
          "package": "toysolver",
          "signature": "Solver -\u003e [(Lit, Integer)] -\u003e Options -\u003e IO (Maybe (Model, Integer))",
          "source": "src/SAT-PBO-UnsatBased.html#solveWBO",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO UnsatBased",
          "module": "SAT.PBO.UnsatBased",
          "name": "solveWBO",
          "normalized": "Solver-\u003e[(Lit,Integer)]-\u003eOptions-\u003eIO(Maybe(Model,Integer))",
          "package": "toysolver",
          "partial": "WBO",
          "signature": "Solver-\u003e[(Lit,Integer)]-\u003eOptions-\u003eIO(Maybe(Model,Integer))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#v:solveWBO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePseudo-Boolean Optimization (PBO) Solver\n\u003c/p\u003e\u003c/div\u003e",
          "module": "SAT.PBO",
          "name": "PBO",
          "package": "toysolver",
          "source": "src/SAT-PBO.html",
          "type": "module"
        },
        "index": {
          "description": "Pseudo-Boolean Optimization PBO Solver",
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "PBO",
          "package": "toysolver",
          "partial": "PBO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "Options",
          "package": "toysolver",
          "source": "src/SAT-PBO.html#Options",
          "type": "data"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#t:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "SearchStrategy",
          "package": "toysolver",
          "source": "src/SAT-PBO.html#SearchStrategy",
          "type": "data"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "SearchStrategy",
          "package": "toysolver",
          "partial": "Search Strategy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#t:SearchStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "AdaptiveSearch",
          "package": "toysolver",
          "signature": "AdaptiveSearch",
          "source": "src/SAT-PBO.html#SearchStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "AdaptiveSearch",
          "package": "toysolver",
          "partial": "Adaptive Search",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:AdaptiveSearch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "BinarySearch",
          "package": "toysolver",
          "signature": "BinarySearch",
          "source": "src/SAT-PBO.html#SearchStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "BinarySearch",
          "package": "toysolver",
          "partial": "Binary Search",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:BinarySearch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "LinearSearch",
          "package": "toysolver",
          "signature": "LinearSearch",
          "source": "src/SAT-PBO.html#SearchStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "LinearSearch",
          "package": "toysolver",
          "partial": "Linear Search",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:LinearSearch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "MSU4",
          "package": "toysolver",
          "signature": "MSU4",
          "source": "src/SAT-PBO.html#SearchStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "MSU4",
          "package": "toysolver",
          "partial": "MSU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:MSU4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "Options",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/SAT-PBO.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "Options",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "UnsatBased",
          "package": "toysolver",
          "signature": "UnsatBased",
          "source": "src/SAT-PBO.html#SearchStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "UnsatBased",
          "package": "toysolver",
          "partial": "Unsat Based",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:UnsatBased"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "defaultOptions",
          "package": "toysolver",
          "signature": "Options",
          "source": "src/SAT-PBO.html#defaultOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "defaultOptions",
          "package": "toysolver",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:defaultOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "minimize",
          "package": "toysolver",
          "signature": "Solver -\u003e [(Integer, Lit)] -\u003e Options -\u003e IO (Maybe Model)",
          "source": "src/SAT-PBO.html#minimize",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "minimize",
          "normalized": "Solver-\u003e[(Integer,Lit)]-\u003eOptions-\u003eIO(Maybe Model)",
          "package": "toysolver",
          "signature": "Solver-\u003e[(Integer,Lit)]-\u003eOptions-\u003eIO(Maybe Model)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:minimize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "optLogger",
          "package": "toysolver",
          "signature": "String -\u003e IO ()",
          "source": "src/SAT-PBO.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "optLogger",
          "normalized": "String-\u003eIO()",
          "package": "toysolver",
          "partial": "Logger",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:optLogger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "optObjFunVarsHeuristics",
          "package": "toysolver",
          "signature": "Bool",
          "source": "src/SAT-PBO.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "optObjFunVarsHeuristics",
          "package": "toysolver",
          "partial": "Obj Fun Vars Heuristics",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:optObjFunVarsHeuristics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "optSearchStrategy",
          "package": "toysolver",
          "signature": "SearchStrategy",
          "source": "src/SAT-PBO.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "optSearchStrategy",
          "package": "toysolver",
          "partial": "Search Strategy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:optSearchStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "optTrialLimitConf",
          "package": "toysolver",
          "signature": "Int",
          "source": "src/SAT-PBO.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "optTrialLimitConf",
          "package": "toysolver",
          "partial": "Trial Limit Conf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:optTrialLimitConf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "optUpdateBest",
          "package": "toysolver",
          "signature": "Model -\u003e Integer -\u003e IO ()",
          "source": "src/SAT-PBO.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "optUpdateBest",
          "normalized": "Model-\u003eInteger-\u003eIO()",
          "package": "toysolver",
          "partial": "Update Best",
          "signature": "Model-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:optUpdateBest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "optUpdateLB",
          "package": "toysolver",
          "signature": "Integer -\u003e IO ()",
          "source": "src/SAT-PBO.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "optUpdateLB",
          "normalized": "Integer-\u003eIO()",
          "package": "toysolver",
          "partial": "Update LB",
          "signature": "Integer-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:optUpdateLB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.PBO",
          "name": "tweakParams",
          "package": "toysolver",
          "signature": "Solver -\u003e [(Integer, Lit)] -\u003e IO ()",
          "source": "src/SAT-PBO.html#tweakParams",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT PBO",
          "module": "SAT.PBO",
          "name": "tweakParams",
          "normalized": "Solver-\u003e[(Integer,Lit)]-\u003eIO()",
          "package": "toysolver",
          "partial": "Params",
          "signature": "Solver-\u003e[(Integer,Lit)]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:tweakParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePrinting utilities.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "SAT.Printer",
          "name": "Printer",
          "package": "toysolver",
          "source": "src/SAT-Printer.html",
          "type": "module"
        },
        "index": {
          "description": "Printing utilities",
          "hierarchy": "SAT Printer",
          "module": "SAT.Printer",
          "name": "Printer",
          "package": "toysolver",
          "partial": "Printer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Printer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint a \u003ccode\u003e\u003ca\u003eModel\u003c/a\u003e\u003c/code\u003e in a way specified for Max-SAT Evaluation.\n See \u003ca\u003ehttp://maxsat.ia.udl.cat/requirements/\u003c/a\u003e for details.\n\u003c/p\u003e",
          "module": "SAT.Printer",
          "name": "maxsatPrintModel",
          "package": "toysolver",
          "signature": "Handle -\u003e Model -\u003e Int -\u003e IO ()",
          "source": "src/SAT-Printer.html#maxsatPrintModel",
          "type": "function"
        },
        "index": {
          "description": "Print Model in way specified for Max-SAT Evaluation See http maxsat.ia.udl.cat requirements for details",
          "hierarchy": "SAT Printer",
          "module": "SAT.Printer",
          "name": "maxsatPrintModel",
          "normalized": "Handle-\u003eModel-\u003eInt-\u003eIO()",
          "package": "toysolver",
          "partial": "Print Model",
          "signature": "Handle-\u003eModel-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Printer.html#v:maxsatPrintModel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Printer",
          "name": "musPrintSol",
          "package": "toysolver",
          "signature": "Handle -\u003e [Int] -\u003e IO ()",
          "source": "src/SAT-Printer.html#musPrintSol",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Printer",
          "module": "SAT.Printer",
          "name": "musPrintSol",
          "normalized": "Handle-\u003e[Int]-\u003eIO()",
          "package": "toysolver",
          "partial": "Print Sol",
          "signature": "Handle-\u003e[Int]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Printer.html#v:musPrintSol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint a \u003ccode\u003e\u003ca\u003eModel\u003c/a\u003e\u003c/code\u003e in a way specified for Pseudo-Boolean Competition.\n See \u003ca\u003ehttp://www.cril.univ-artois.fr/PB12/format.pdf\u003c/a\u003e for details.\n\u003c/p\u003e",
          "module": "SAT.Printer",
          "name": "pbPrintModel",
          "package": "toysolver",
          "signature": "Handle -\u003e Model -\u003e Int -\u003e IO ()",
          "source": "src/SAT-Printer.html#pbPrintModel",
          "type": "function"
        },
        "index": {
          "description": "Print Model in way specified for Pseudo-Boolean Competition See http www.cril.univ-artois.fr PB12 format.pdf for details",
          "hierarchy": "SAT Printer",
          "module": "SAT.Printer",
          "name": "pbPrintModel",
          "normalized": "Handle-\u003eModel-\u003eInt-\u003eIO()",
          "package": "toysolver",
          "partial": "Print Model",
          "signature": "Handle-\u003eModel-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Printer.html#v:pbPrintModel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint a \u003ccode\u003e\u003ca\u003eModel\u003c/a\u003e\u003c/code\u003e in a way specified for SAT Competition.\n See \u003ca\u003ehttp://www.satcompetition.org/2011/rules.pdf\u003c/a\u003e for details.\n\u003c/p\u003e",
          "module": "SAT.Printer",
          "name": "satPrintModel",
          "package": "toysolver",
          "signature": "Handle -\u003e Model -\u003e Int -\u003e IO ()",
          "source": "src/SAT-Printer.html#satPrintModel",
          "type": "function"
        },
        "index": {
          "description": "Print Model in way specified for SAT Competition See http www.satcompetition.org rules.pdf for details",
          "hierarchy": "SAT Printer",
          "module": "SAT.Printer",
          "name": "satPrintModel",
          "normalized": "Handle-\u003eModel-\u003eInt-\u003eIO()",
          "package": "toysolver",
          "partial": "Print Model",
          "signature": "Handle-\u003eModel-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Printer.html#v:satPrintModel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TheorySolver",
          "name": "TheorySolver",
          "package": "toysolver",
          "source": "src/SAT-TheorySolver.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "SAT TheorySolver",
          "module": "SAT.TheorySolver",
          "name": "TheorySolver",
          "package": "toysolver",
          "partial": "Theory Solver",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TheorySolver",
          "name": "TheorySolver",
          "package": "toysolver",
          "source": "src/SAT-TheorySolver.html#TheorySolver",
          "type": "data"
        },
        "index": {
          "hierarchy": "SAT TheorySolver",
          "module": "SAT.TheorySolver",
          "name": "TheorySolver",
          "package": "toysolver",
          "partial": "Theory Solver",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#t:TheorySolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TheorySolver",
          "name": "TheorySolver",
          "package": "toysolver",
          "signature": "TheorySolver",
          "source": "src/SAT-TheorySolver.html#TheorySolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT TheorySolver",
          "module": "SAT.TheorySolver",
          "name": "TheorySolver",
          "package": "toysolver",
          "partial": "Theory Solver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#v:TheorySolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TheorySolver",
          "name": "emptyTheory",
          "package": "toysolver",
          "signature": "TheorySolver",
          "source": "src/SAT-TheorySolver.html#emptyTheory",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT TheorySolver",
          "module": "SAT.TheorySolver",
          "name": "emptyTheory",
          "package": "toysolver",
          "partial": "Theory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#v:emptyTheory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TheorySolver",
          "name": "thAssertLit",
          "package": "toysolver",
          "signature": "(Lit -\u003e IO Bool) -\u003e Lit -\u003e IO Bool",
          "source": "src/SAT-TheorySolver.html#TheorySolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT TheorySolver",
          "module": "SAT.TheorySolver",
          "name": "thAssertLit",
          "normalized": "(Lit-\u003eIO Bool)-\u003eLit-\u003eIO Bool",
          "package": "toysolver",
          "partial": "Assert Lit",
          "signature": "(Lit-\u003eIO Bool)-\u003eLit-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#v:thAssertLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TheorySolver",
          "name": "thCheck",
          "package": "toysolver",
          "signature": "(Lit -\u003e IO Bool) -\u003e IO Bool",
          "source": "src/SAT-TheorySolver.html#TheorySolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT TheorySolver",
          "module": "SAT.TheorySolver",
          "name": "thCheck",
          "normalized": "(Lit-\u003eIO Bool)-\u003eIO Bool",
          "package": "toysolver",
          "partial": "Check",
          "signature": "(Lit-\u003eIO Bool)-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#v:thCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TheorySolver",
          "name": "thExplain",
          "package": "toysolver",
          "signature": "IO [Lit]",
          "source": "src/SAT-TheorySolver.html#TheorySolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT TheorySolver",
          "module": "SAT.TheorySolver",
          "name": "thExplain",
          "normalized": "IO[Lit]",
          "package": "toysolver",
          "partial": "Explain",
          "signature": "IO[Lit]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#v:thExplain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TheorySolver",
          "name": "thPopBacktrackPoint",
          "package": "toysolver",
          "signature": "IO ()",
          "source": "src/SAT-TheorySolver.html#TheorySolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT TheorySolver",
          "module": "SAT.TheorySolver",
          "name": "thPopBacktrackPoint",
          "normalized": "IO()",
          "package": "toysolver",
          "partial": "Pop Backtrack Point",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#v:thPopBacktrackPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TheorySolver",
          "name": "thPushBacktrackPoint",
          "package": "toysolver",
          "signature": "IO ()",
          "source": "src/SAT-TheorySolver.html#TheorySolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT TheorySolver",
          "module": "SAT.TheorySolver",
          "name": "thPushBacktrackPoint",
          "normalized": "IO()",
          "package": "toysolver",
          "partial": "Push Backtrack Point",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#v:thPushBacktrackPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTseitin encoding\n\u003c/p\u003e\u003cp\u003eTODO:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e reduce variables.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e [Tse83] G. Tseitin. On the complexity of derivation in propositional\n   calculus. Automation of Reasoning: Classical Papers in Computational\n   Logic, 2:466-483, 1983. Springer-Verlag. \n\u003c/li\u003e\u003cli\u003e [For60] R. Fortet. Application de l'alg&#232;bre de Boole en rechercheop\n   op&#233;rationelle. Revue Fran&#231;aise de Recherche Op&#233;rationelle, 4:17-26,\n   1960. \n\u003c/li\u003e\u003cli\u003e [BM84a] E. Balas and J. B. Mazzola. Nonlinear 0-1 programming:\n   I. Linearization techniques. Mathematical Programming, 30(1):1-21,\n   1984.\n\u003c/li\u003e\u003cli\u003e [BM84b] E. Balas and J. B. Mazzola. Nonlinear 0-1 programming:\n   II. Dominance relations and algorithms. Mathematical Programming,\n   30(1):22-45, 1984.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "SAT.TseitinEncoder",
          "name": "TseitinEncoder",
          "package": "toysolver",
          "source": "src/SAT-TseitinEncoder.html",
          "type": "module"
        },
        "index": {
          "description": "Tseitin encoding TODO reduce variables References Tse83 Tseitin On the complexity of derivation in propositional calculus Automation of Reasoning Classical Papers in Computational Logic Springer-Verlag For60 Fortet Application de alg bre de Boole en rechercheop op rationelle Revue Fran aise de Recherche Op rationelle BM84a Balas and Mazzola Nonlinear programming Linearization techniques Mathematical Programming BM84b Balas and Mazzola Nonlinear programming II Dominance relations and algorithms Mathematical Programming",
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "TseitinEncoder",
          "package": "toysolver",
          "partial": "Tseitin Encoder",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncoder instance\n\u003c/p\u003e",
          "module": "SAT.TseitinEncoder",
          "name": "Encoder",
          "package": "toysolver",
          "source": "src/SAT-TseitinEncoder.html#Encoder",
          "type": "data"
        },
        "index": {
          "description": "Encoder instance",
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "Encoder",
          "package": "toysolver",
          "partial": "Encoder",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#t:Encoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArbitrary formula not restricted to CNF\n\u003c/p\u003e",
          "module": "SAT.TseitinEncoder",
          "name": "Formula",
          "package": "toysolver",
          "source": "src/SAT-TseitinEncoder.html#Formula",
          "type": "data"
        },
        "index": {
          "description": "Arbitrary formula not restricted to CNF",
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "Formula",
          "package": "toysolver",
          "partial": "Formula",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#t:Formula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TseitinEncoder",
          "name": "And",
          "package": "toysolver",
          "signature": "And [Formula]",
          "source": "src/SAT-TseitinEncoder.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "And",
          "normalized": "And[Formula]",
          "package": "toysolver",
          "partial": "And",
          "signature": "And[Formula]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:And"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TseitinEncoder",
          "name": "Equiv",
          "package": "toysolver",
          "signature": "Equiv Formula Formula",
          "source": "src/SAT-TseitinEncoder.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "Equiv",
          "package": "toysolver",
          "partial": "Equiv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:Equiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TseitinEncoder",
          "name": "Imply",
          "package": "toysolver",
          "signature": "Imply Formula Formula",
          "source": "src/SAT-TseitinEncoder.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "Imply",
          "package": "toysolver",
          "partial": "Imply",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:Imply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TseitinEncoder",
          "name": "Not",
          "package": "toysolver",
          "signature": "Not Formula",
          "source": "src/SAT-TseitinEncoder.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "Not",
          "package": "toysolver",
          "partial": "Not",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:Not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TseitinEncoder",
          "name": "Or",
          "package": "toysolver",
          "signature": "Or [Formula]",
          "source": "src/SAT-TseitinEncoder.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "Or",
          "normalized": "Or[Formula]",
          "package": "toysolver",
          "partial": "Or",
          "signature": "Or[Formula]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:Or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TseitinEncoder",
          "name": "Var",
          "package": "toysolver",
          "signature": "Var Var",
          "source": "src/SAT-TseitinEncoder.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "Var",
          "package": "toysolver",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAssert a given formula to underlying SAT solver by using\n Tseitin encoding.\n\u003c/p\u003e",
          "module": "SAT.TseitinEncoder",
          "name": "addFormula",
          "package": "toysolver",
          "signature": "Encoder -\u003e Formula -\u003e IO ()",
          "source": "src/SAT-TseitinEncoder.html#addFormula",
          "type": "function"
        },
        "index": {
          "description": "Assert given formula to underlying SAT solver by using Tseitin encoding",
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "addFormula",
          "normalized": "Encoder-\u003eFormula-\u003eIO()",
          "package": "toysolver",
          "partial": "Formula",
          "signature": "Encoder-\u003eFormula-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:addFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.TseitinEncoder",
          "name": "encSolver",
          "package": "toysolver",
          "signature": "Encoder -\u003e Solver",
          "source": "src/SAT-TseitinEncoder.html#encSolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "encSolver",
          "normalized": "Encoder-\u003eSolver",
          "package": "toysolver",
          "partial": "Solver",
          "signature": "Encoder-\u003eSolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:encSolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn an literal which is equivalent to a given conjunction.\n\u003c/p\u003e",
          "module": "SAT.TseitinEncoder",
          "name": "encodeConj",
          "package": "toysolver",
          "signature": "Encoder -\u003e [Lit] -\u003e IO Lit",
          "source": "src/SAT-TseitinEncoder.html#encodeConj",
          "type": "function"
        },
        "index": {
          "description": "Return an literal which is equivalent to given conjunction",
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "encodeConj",
          "normalized": "Encoder-\u003e[Lit]-\u003eIO Lit",
          "package": "toysolver",
          "partial": "Conj",
          "signature": "Encoder-\u003e[Lit]-\u003eIO Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:encodeConj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn an literal which is equivalent to a given disjunction.\n\u003c/p\u003e",
          "module": "SAT.TseitinEncoder",
          "name": "encodeDisj",
          "package": "toysolver",
          "signature": "Encoder -\u003e [Lit] -\u003e IO Lit",
          "source": "src/SAT-TseitinEncoder.html#encodeDisj",
          "type": "function"
        },
        "index": {
          "description": "Return an literal which is equivalent to given disjunction",
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "encodeDisj",
          "normalized": "Encoder-\u003e[Lit]-\u003eIO Lit",
          "package": "toysolver",
          "partial": "Disj",
          "signature": "Encoder-\u003e[Lit]-\u003eIO Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:encodeDisj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a \u003ccode\u003eEncoder\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "SAT.TseitinEncoder",
          "name": "newEncoder",
          "package": "toysolver",
          "signature": "Solver -\u003e IO Encoder",
          "source": "src/SAT-TseitinEncoder.html#newEncoder",
          "type": "function"
        },
        "index": {
          "description": "Create Encoder instance",
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "newEncoder",
          "normalized": "Solver-\u003eIO Encoder",
          "package": "toysolver",
          "partial": "Encoder",
          "signature": "Solver-\u003eIO Encoder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:newEncoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse \u003cem\u003epseudo boolean constraints\u003c/em\u003e or use only \u003cem\u003eclauses\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "SAT.TseitinEncoder",
          "name": "setUsePB",
          "package": "toysolver",
          "signature": "Encoder -\u003e Bool -\u003e IO ()",
          "source": "src/SAT-TseitinEncoder.html#setUsePB",
          "type": "function"
        },
        "index": {
          "description": "Use pseudo boolean constraints or use only clauses",
          "hierarchy": "SAT TseitinEncoder",
          "module": "SAT.TseitinEncoder",
          "name": "setUsePB",
          "normalized": "Encoder-\u003eBool-\u003eIO()",
          "package": "toysolver",
          "partial": "Use PB",
          "signature": "Encoder-\u003eBool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:setUsePB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "Types",
          "package": "toysolver",
          "source": "src/SAT-Types.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "Types",
          "package": "toysolver",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisjunction of \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "SAT.Types",
          "name": "Clause",
          "package": "toysolver",
          "source": "src/SAT-Types.html#Clause",
          "type": "type"
        },
        "index": {
          "description": "Disjunction of Lit",
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "Clause",
          "package": "toysolver",
          "partial": "Clause",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:Clause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePositive (resp. negative) literals are represented as positive (resp.\n negative) integers. (DIMACS format).\n\u003c/p\u003e",
          "module": "SAT.Types",
          "name": "Lit",
          "package": "toysolver",
          "source": "src/SAT-Types.html#Lit",
          "type": "type"
        },
        "index": {
          "description": "Positive resp negative literals are represented as positive resp negative integers DIMACS format",
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "Lit",
          "package": "toysolver",
          "partial": "Lit",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "LitMap",
          "package": "toysolver",
          "source": "src/SAT-Types.html#LitMap",
          "type": "type"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "LitMap",
          "package": "toysolver",
          "partial": "Lit Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:LitMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "LitSet",
          "package": "toysolver",
          "source": "src/SAT-Types.html#LitSet",
          "type": "type"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "LitSet",
          "package": "toysolver",
          "partial": "Lit Set",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:LitSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA model is represented as a mapping from variables to its values.\n\u003c/p\u003e",
          "module": "SAT.Types",
          "name": "Model",
          "package": "toysolver",
          "source": "src/SAT-Types.html#Model",
          "type": "type"
        },
        "index": {
          "description": "model is represented as mapping from variables to its values",
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "Model",
          "package": "toysolver",
          "partial": "Model",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:Model"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariable is represented as positive integers (DIMACS format).\n\u003c/p\u003e",
          "module": "SAT.Types",
          "name": "Var",
          "package": "toysolver",
          "source": "src/SAT-Types.html#Var",
          "type": "type"
        },
        "index": {
          "description": "Variable is represented as positive integers DIMACS format",
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "Var",
          "package": "toysolver",
          "partial": "Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "VarMap",
          "package": "toysolver",
          "source": "src/SAT-Types.html#VarMap",
          "type": "type"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "VarMap",
          "package": "toysolver",
          "partial": "Var Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:VarMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "VarSet",
          "package": "toysolver",
          "source": "src/SAT-Types.html#VarSet",
          "type": "type"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "VarSet",
          "package": "toysolver",
          "partial": "Var Set",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:VarSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "cardinalityReduction",
          "package": "toysolver",
          "signature": "([(Integer, Lit)], Integer) -\u003e ([Lit], Int)",
          "source": "src/SAT-Types.html#cardinalityReduction",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "cardinalityReduction",
          "normalized": "([(Integer,Lit)],Integer)-\u003e([Lit],Int)",
          "package": "toysolver",
          "partial": "Reduction",
          "signature": "([(Integer,Lit)],Integer)-\u003e([Lit],Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:cardinalityReduction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "cutResolve",
          "package": "toysolver",
          "signature": "([(Integer, Lit)], Integer) -\u003e ([(Integer, Lit)], Integer) -\u003e Var -\u003e ([(Integer, Lit)], Integer)",
          "source": "src/SAT-Types.html#cutResolve",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "cutResolve",
          "normalized": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)-\u003eVar-\u003e([(Integer,Lit)],Integer)",
          "package": "toysolver",
          "partial": "Resolve",
          "signature": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)-\u003eVar-\u003e([(Integer,Lit)],Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:cutResolve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "evalLit",
          "package": "toysolver",
          "signature": "Model -\u003e Lit -\u003e Bool",
          "source": "src/SAT-Types.html#evalLit",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "evalLit",
          "normalized": "Model-\u003eLit-\u003eBool",
          "package": "toysolver",
          "partial": "Lit",
          "signature": "Model-\u003eLit-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:evalLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNegation of the \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"SAT.Types\",\"SAT\"]",
          "name": "litNot",
          "package": "toysolver",
          "signature": "Lit -\u003e Lit",
          "source": "src/SAT-Types.html#litNot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:litNot\",\"http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:litNot\"]"
        },
        "index": {
          "description": "Negation of the Lit",
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "litNot",
          "normalized": "Lit-\u003eLit",
          "package": "toysolver",
          "partial": "Not",
          "signature": "Lit-\u003eLit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:litNot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePolarity of the \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e.\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e means positive literal and \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e means negative literal.\n\u003c/p\u003e",
          "module": "[\"SAT.Types\",\"SAT\"]",
          "name": "litPolarity",
          "package": "toysolver",
          "signature": "Lit -\u003e Bool",
          "source": "src/SAT-Types.html#litPolarity",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:litPolarity\",\"http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:litPolarity\"]"
        },
        "index": {
          "description": "Polarity of the Lit True means positive literal and False means negative literal",
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "litPolarity",
          "normalized": "Lit-\u003eBool",
          "package": "toysolver",
          "partial": "Polarity",
          "signature": "Lit-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:litPolarity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "litUndef",
          "package": "toysolver",
          "signature": "Lit",
          "source": "src/SAT-Types.html#litUndef",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "litUndef",
          "package": "toysolver",
          "partial": "Undef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:litUndef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnderlying variable of the \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"SAT.Types\",\"SAT\"]",
          "name": "litVar",
          "package": "toysolver",
          "signature": "Lit -\u003e Var",
          "source": "src/SAT-Types.html#litVar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:litVar\",\"http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:litVar\"]"
        },
        "index": {
          "description": "Underlying variable of the Lit",
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "litVar",
          "normalized": "Lit-\u003eVar",
          "package": "toysolver",
          "partial": "Var",
          "signature": "Lit-\u003eVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:litVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a literal from a variable and its polarity.\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e (resp \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e) means positive (resp. negative) literal.\n\u003c/p\u003e",
          "module": "[\"SAT.Types\",\"SAT\"]",
          "name": "literal",
          "package": "toysolver",
          "signature": "Var-\u003e Bool-\u003e Lit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:literal\",\"http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:literal\"]"
        },
        "index": {
          "description": "Construct literal from variable and its polarity True resp False means positive resp negative literal",
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "literal",
          "normalized": "Var-\u003eBool-\u003eLit",
          "package": "toysolver",
          "signature": "Var-\u003eBool-\u003eLit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:literal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "negatePBAtLeast",
          "package": "toysolver",
          "signature": "([(Integer, Lit)], Integer) -\u003e ([(Integer, Lit)], Integer)",
          "source": "src/SAT-Types.html#negatePBAtLeast",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "negatePBAtLeast",
          "normalized": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)",
          "package": "toysolver",
          "partial": "PBAt Least",
          "signature": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:negatePBAtLeast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "normalizeAtLeast",
          "package": "toysolver",
          "signature": "([Lit], Int) -\u003e ([Lit], Int)",
          "source": "src/SAT-Types.html#normalizeAtLeast",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "normalizeAtLeast",
          "normalized": "([Lit],Int)-\u003e([Lit],Int)",
          "package": "toysolver",
          "partial": "At Least",
          "signature": "([Lit],Int)-\u003e([Lit],Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:normalizeAtLeast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormalizing clause\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the clause is trivially true.\n\u003c/p\u003e",
          "module": "SAT.Types",
          "name": "normalizeClause",
          "package": "toysolver",
          "signature": "Clause -\u003e Maybe Clause",
          "source": "src/SAT-Types.html#normalizeClause",
          "type": "function"
        },
        "index": {
          "description": "Normalizing clause Nothing if the clause is trivially true",
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "normalizeClause",
          "normalized": "Clause-\u003eMaybe Clause",
          "package": "toysolver",
          "partial": "Clause",
          "signature": "Clause-\u003eMaybe Clause",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:normalizeClause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enormalizing PB constraint of the form \u003cem\u003ec1 x1 + c2 cn ... cn xn \u003e= b\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "SAT.Types",
          "name": "normalizePBAtLeast",
          "package": "toysolver",
          "signature": "([(Integer, Lit)], Integer) -\u003e ([(Integer, Lit)], Integer)",
          "source": "src/SAT-Types.html#normalizePBAtLeast",
          "type": "function"
        },
        "index": {
          "description": "normalizing PB constraint of the form c1 x1 c2 cn cn xn",
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "normalizePBAtLeast",
          "normalized": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)",
          "package": "toysolver",
          "partial": "PBAt Least",
          "signature": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:normalizePBAtLeast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enormalizing PB constraint of the form \u003cem\u003ec1 x1 + c2 cn ... cn xn = b\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "SAT.Types",
          "name": "normalizePBExactly",
          "package": "toysolver",
          "signature": "([(Integer, Lit)], Integer) -\u003e ([(Integer, Lit)], Integer)",
          "source": "src/SAT-Types.html#normalizePBExactly",
          "type": "function"
        },
        "index": {
          "description": "normalizing PB constraint of the form c1 x1 c2 cn cn xn",
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "normalizePBExactly",
          "normalized": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)",
          "package": "toysolver",
          "partial": "PBExactly",
          "signature": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:normalizePBExactly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enormalizing PB term of the form \u003cem\u003ec1 x1 + c2 x2 ... cn xn + c\u003c/em\u003e into\n \u003cem\u003ed1 x1 + d2 x2 ... dm xm + d\u003c/em\u003e where d1,...,dm &#8805; 1.\n\u003c/p\u003e",
          "module": "SAT.Types",
          "name": "normalizePBSum",
          "package": "toysolver",
          "signature": "([(Integer, Lit)], Integer) -\u003e ([(Integer, Lit)], Integer)",
          "source": "src/SAT-Types.html#normalizePBSum",
          "type": "function"
        },
        "index": {
          "description": "normalizing PB term of the form c1 x1 c2 x2 cn xn into d1 x1 d2 x2 dm xm where d1 dm",
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "normalizePBSum",
          "normalized": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)",
          "package": "toysolver",
          "partial": "PBSum",
          "signature": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:normalizePBSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "pbEval",
          "package": "toysolver",
          "signature": "Model -\u003e [(Integer, Lit)] -\u003e Integer",
          "source": "src/SAT-Types.html#pbEval",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "pbEval",
          "normalized": "Model-\u003e[(Integer,Lit)]-\u003eInteger",
          "package": "toysolver",
          "partial": "Eval",
          "signature": "Model-\u003e[(Integer,Lit)]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:pbEval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "pbLowerBound",
          "package": "toysolver",
          "signature": "[(Integer, Lit)] -\u003e Integer",
          "source": "src/SAT-Types.html#pbLowerBound",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "pbLowerBound",
          "normalized": "[(Integer,Lit)]-\u003eInteger",
          "package": "toysolver",
          "partial": "Lower Bound",
          "signature": "[(Integer,Lit)]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:pbLowerBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "pbUpperBound",
          "package": "toysolver",
          "signature": "[(Integer, Lit)] -\u003e Integer",
          "source": "src/SAT-Types.html#pbUpperBound",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "pbUpperBound",
          "normalized": "[(Integer,Lit)]-\u003eInteger",
          "package": "toysolver",
          "partial": "Upper Bound",
          "signature": "[(Integer,Lit)]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:pbUpperBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "validLit",
          "package": "toysolver",
          "signature": "Lit -\u003e Bool",
          "source": "src/SAT-Types.html#validLit",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "validLit",
          "normalized": "Lit-\u003eBool",
          "package": "toysolver",
          "partial": "Lit",
          "signature": "Lit-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:validLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT.Types",
          "name": "validVar",
          "package": "toysolver",
          "signature": "Var -\u003e Bool",
          "source": "src/SAT-Types.html#validVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT Types",
          "module": "SAT.Types",
          "name": "validVar",
          "normalized": "Var-\u003eBool",
          "package": "toysolver",
          "partial": "Var",
          "signature": "Var-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:validVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA CDCL SAT solver.\n\u003c/p\u003e\u003cp\u003eIt follows the design of MiniSat and SAT4J.\n\u003c/p\u003e\u003cp\u003eSee also:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://hackage.haskell.org/package/funsat\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://hackage.haskell.org/package/incremental-sat-solver\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "SAT",
          "name": "SAT",
          "package": "toysolver",
          "source": "src/SAT.html",
          "type": "module"
        },
        "index": {
          "description": "CDCL SAT solver It follows the design of MiniSat and SAT4J See also http hackage.haskell.org package funsat http hackage.haskell.org package incremental-sat-solver",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "SAT",
          "package": "toysolver",
          "partial": "SAT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "BudgetExceeded",
          "package": "toysolver",
          "source": "src/SAT.html#BudgetExceeded",
          "type": "data"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "BudgetExceeded",
          "package": "toysolver",
          "partial": "Budget Exceeded",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:BudgetExceeded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisjunction of \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "Clause",
          "package": "toysolver",
          "source": "src/SAT-Types.html#Clause",
          "type": "type"
        },
        "index": {
          "description": "Disjunction of Lit",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "Clause",
          "package": "toysolver",
          "partial": "Clause",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:Clause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "LearningStrategy",
          "package": "toysolver",
          "source": "src/SAT.html#LearningStrategy",
          "type": "data"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "LearningStrategy",
          "package": "toysolver",
          "partial": "Learning Strategy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:LearningStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePositive (resp. negative) literals are represented as positive (resp.\n negative) integers. (DIMACS format).\n\u003c/p\u003e",
          "module": "SAT",
          "name": "Lit",
          "package": "toysolver",
          "source": "src/SAT-Types.html#Lit",
          "type": "type"
        },
        "index": {
          "description": "Positive resp negative literals are represented as positive resp negative integers DIMACS format",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "Lit",
          "package": "toysolver",
          "partial": "Lit",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA model is represented as a mapping from variables to its values.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "Model",
          "package": "toysolver",
          "source": "src/SAT-Types.html#Model",
          "type": "type"
        },
        "index": {
          "description": "model is represented as mapping from variables to its values",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "Model",
          "package": "toysolver",
          "partial": "Model",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:Model"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "RestartStrategy",
          "package": "toysolver",
          "source": "src/SAT.html#RestartStrategy",
          "type": "data"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "RestartStrategy",
          "package": "toysolver",
          "partial": "Restart Strategy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:RestartStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolver instance\n\u003c/p\u003e",
          "module": "SAT",
          "name": "Solver",
          "package": "toysolver",
          "source": "src/SAT.html#Solver",
          "type": "data"
        },
        "index": {
          "description": "Solver instance",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "Solver",
          "package": "toysolver",
          "partial": "Solver",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:Solver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariable is represented as positive integers (DIMACS format).\n\u003c/p\u003e",
          "module": "SAT",
          "name": "Var",
          "package": "toysolver",
          "source": "src/SAT-Types.html#Var",
          "type": "type"
        },
        "index": {
          "description": "Variable is represented as positive integers DIMACS format",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "Var",
          "package": "toysolver",
          "partial": "Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "ArminRestarts",
          "package": "toysolver",
          "signature": "ArminRestarts",
          "source": "src/SAT.html#RestartStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "ArminRestarts",
          "package": "toysolver",
          "partial": "Armin Restarts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:ArminRestarts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "BudgetExceeded",
          "package": "toysolver",
          "signature": "BudgetExceeded",
          "source": "src/SAT.html#BudgetExceeded",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "BudgetExceeded",
          "package": "toysolver",
          "partial": "Budget Exceeded",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:BudgetExceeded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "LearningClause",
          "package": "toysolver",
          "signature": "LearningClause",
          "source": "src/SAT.html#LearningStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "LearningClause",
          "package": "toysolver",
          "partial": "Learning Clause",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:LearningClause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "LearningHybrid",
          "package": "toysolver",
          "signature": "LearningHybrid",
          "source": "src/SAT.html#LearningStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "LearningHybrid",
          "package": "toysolver",
          "partial": "Learning Hybrid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:LearningHybrid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "LubyRestarts",
          "package": "toysolver",
          "signature": "LubyRestarts",
          "source": "src/SAT.html#RestartStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "LubyRestarts",
          "package": "toysolver",
          "partial": "Luby Restarts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:LubyRestarts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "MiniSATRestarts",
          "package": "toysolver",
          "signature": "MiniSATRestarts",
          "source": "src/SAT.html#RestartStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "MiniSATRestarts",
          "package": "toysolver",
          "partial": "Mini SATRestarts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:MiniSATRestarts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a cardinality constraints \u003cem\u003eatleast({l1,l2,..},n)\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "addAtLeast",
          "package": "toysolver",
          "signature": "Solver-\u003e [Lit]-\u003e Int-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Add cardinality constraints atleast l1 l2",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "addAtLeast",
          "normalized": "Solver-\u003e[Lit]-\u003eInt-\u003eIO()",
          "package": "toysolver",
          "partial": "At Least",
          "signature": "Solver-\u003e[Lit]-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addAtLeast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a cardinality constraints \u003cem\u003eatmost({l1,l2,..},n)\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "addAtMost",
          "package": "toysolver",
          "signature": "Solver-\u003e [Lit]-\u003e Int-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Add cardinality constraints atmost l1 l2",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "addAtMost",
          "normalized": "Solver-\u003e[Lit]-\u003eInt-\u003eIO()",
          "package": "toysolver",
          "partial": "At Most",
          "signature": "Solver-\u003e[Lit]-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addAtMost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a clause to the solver.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "addClause",
          "package": "toysolver",
          "signature": "Solver -\u003e Clause -\u003e IO ()",
          "source": "src/SAT.html#addClause",
          "type": "function"
        },
        "index": {
          "description": "Add clause to the solver",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "addClause",
          "normalized": "Solver-\u003eClause-\u003eIO()",
          "package": "toysolver",
          "partial": "Clause",
          "signature": "Solver-\u003eClause-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addClause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a cardinality constraints \u003cem\u003eexactly({l1,l2,..},n)\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "addExactly",
          "package": "toysolver",
          "signature": "Solver-\u003e [Lit]-\u003e Int-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Add cardinality constraints exactly l1 l2",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "addExactly",
          "normalized": "Solver-\u003e[Lit]-\u003eInt-\u003eIO()",
          "package": "toysolver",
          "partial": "Exactly",
          "signature": "Solver-\u003e[Lit]-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addExactly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a pseudo boolean constraints \u003cem\u003ec1*l1 + c2*l2 + &#8230; &#8805; n\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "addPBAtLeast",
          "package": "toysolver",
          "signature": "Solver-\u003e [(Integer, Lit)]-\u003e Integer-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Add pseudo boolean constraints c1 l1 c2 l2",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "addPBAtLeast",
          "normalized": "Solver-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
          "package": "toysolver",
          "partial": "PBAt Least",
          "signature": "Solver-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addPBAtLeast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a soft pseudo boolean constraints \u003cem\u003elit &#8658; c1*l1 + c2*l2 + &#8230; &#8805; n\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "addPBAtLeastSoft",
          "package": "toysolver",
          "signature": "Solver-\u003e Lit-\u003e [(Integer, Lit)]-\u003e Integer-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Add soft pseudo boolean constraints lit c1 l1 c2 l2",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "addPBAtLeastSoft",
          "normalized": "Solver-\u003eLit-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
          "package": "toysolver",
          "partial": "PBAt Least Soft",
          "signature": "Solver-\u003eLit-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addPBAtLeastSoft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a pseudo boolean constraints \u003cem\u003ec1*l1 + c2*l2 + &#8230; &#8804; n\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "addPBAtMost",
          "package": "toysolver",
          "signature": "Solver-\u003e [(Integer, Lit)]-\u003e Integer-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Add pseudo boolean constraints c1 l1 c2 l2",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "addPBAtMost",
          "normalized": "Solver-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
          "package": "toysolver",
          "partial": "PBAt Most",
          "signature": "Solver-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addPBAtMost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a soft pseudo boolean constraints \u003cem\u003elit &#8658; c1*l1 + c2*l2 + &#8230; &#8804; n\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "addPBAtMostSoft",
          "package": "toysolver",
          "signature": "Solver-\u003e Lit-\u003e [(Integer, Lit)]-\u003e Integer-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Add soft pseudo boolean constraints lit c1 l1 c2 l2",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "addPBAtMostSoft",
          "normalized": "Solver-\u003eLit-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
          "package": "toysolver",
          "partial": "PBAt Most Soft",
          "signature": "Solver-\u003eLit-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addPBAtMostSoft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a pseudo boolean constraints \u003cem\u003ec1*l1 + c2*l2 + &#8230; = n\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "addPBExactly",
          "package": "toysolver",
          "signature": "Solver-\u003e [(Integer, Lit)]-\u003e Integer-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Add pseudo boolean constraints c1 l1 c2 l2",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "addPBExactly",
          "normalized": "Solver-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
          "package": "toysolver",
          "partial": "PBExactly",
          "signature": "Solver-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addPBExactly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a soft pseudo boolean constraints \u003cem\u003elit &#8658; c1*l1 + c2*l2 + &#8230; = n\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "addPBExactlySoft",
          "package": "toysolver",
          "signature": "Solver-\u003e Lit-\u003e [(Integer, Lit)]-\u003e Integer-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Add soft pseudo boolean constraints lit c1 l1 c2 l2",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "addPBExactlySoft",
          "normalized": "Solver-\u003eLit-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
          "package": "toysolver",
          "partial": "PBExactly Soft",
          "signature": "Solver-\u003eLit-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addPBExactlySoft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault value for \u003ccode\u003eCCMin\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "defaultCCMin",
          "package": "toysolver",
          "signature": "Int",
          "source": "src/SAT.html#defaultCCMin",
          "type": "function"
        },
        "index": {
          "description": "default value for CCMin",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "defaultCCMin",
          "package": "toysolver",
          "partial": "CCMin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultCCMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "defaultLearningStrategy",
          "package": "toysolver",
          "signature": "LearningStrategy",
          "source": "src/SAT.html#defaultLearningStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "defaultLearningStrategy",
          "package": "toysolver",
          "partial": "Learning Strategy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultLearningStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault value for \u003ccode\u003eLearntSizeFirst\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "defaultLearntSizeFirst",
          "package": "toysolver",
          "signature": "Int",
          "source": "src/SAT.html#defaultLearntSizeFirst",
          "type": "function"
        },
        "index": {
          "description": "default value for LearntSizeFirst",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "defaultLearntSizeFirst",
          "package": "toysolver",
          "partial": "Learnt Size First",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultLearntSizeFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault value for \u003ccode\u003eLearntSizeInc\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "defaultLearntSizeInc",
          "package": "toysolver",
          "signature": "Double",
          "source": "src/SAT.html#defaultLearntSizeInc",
          "type": "function"
        },
        "index": {
          "description": "default value for LearntSizeInc",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "defaultLearntSizeInc",
          "package": "toysolver",
          "partial": "Learnt Size Inc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultLearntSizeInc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "defaultRandomFreq",
          "package": "toysolver",
          "signature": "Double",
          "source": "src/SAT.html#defaultRandomFreq",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "defaultRandomFreq",
          "package": "toysolver",
          "partial": "Random Freq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultRandomFreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault value for \u003ccode\u003eRestartFirst\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "defaultRestartFirst",
          "package": "toysolver",
          "signature": "Int",
          "source": "src/SAT.html#defaultRestartFirst",
          "type": "function"
        },
        "index": {
          "description": "default value for RestartFirst",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "defaultRestartFirst",
          "package": "toysolver",
          "partial": "Restart First",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultRestartFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault value for \u003ccode\u003eRestartInc\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "defaultRestartInc",
          "package": "toysolver",
          "signature": "Double",
          "source": "src/SAT.html#defaultRestartInc",
          "type": "function"
        },
        "index": {
          "description": "default value for RestartInc",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "defaultRestartInc",
          "package": "toysolver",
          "partial": "Restart Inc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultRestartInc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault value for \u003ccode\u003eRestartStrategy\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "defaultRestartStrategy",
          "package": "toysolver",
          "signature": "RestartStrategy",
          "source": "src/SAT.html#defaultRestartStrategy",
          "type": "function"
        },
        "index": {
          "description": "default value for RestartStrategy",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "defaultRestartStrategy",
          "package": "toysolver",
          "partial": "Restart Strategy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultRestartStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAfter \u003ccode\u003e\u003ca\u003esolveWith\u003c/a\u003e\u003c/code\u003e returns False, it returns a set of assumptions\n that leads to contradiction. In particular, if it returns an empty\n set, the problem is unsatisiable without any assumptions.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "failedAssumptions",
          "package": "toysolver",
          "signature": "Solver -\u003e IO [Lit]",
          "source": "src/SAT.html#failedAssumptions",
          "type": "function"
        },
        "index": {
          "description": "After solveWith returns False it returns set of assumptions that leads to contradiction In particular if it returns an empty set the problem is unsatisiable without any assumptions",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "failedAssumptions",
          "normalized": "Solver-\u003eIO[Lit]",
          "package": "toysolver",
          "partial": "Assumptions",
          "signature": "Solver-\u003eIO[Lit]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:failedAssumptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAfter \u003ccode\u003e\u003ca\u003esolve\u003c/a\u003e\u003c/code\u003e returns True, it returns the model.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "model",
          "package": "toysolver",
          "signature": "Solver -\u003e IO Model",
          "source": "src/SAT.html#model",
          "type": "function"
        },
        "index": {
          "description": "After solve returns True it returns the model",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "model",
          "normalized": "Solver-\u003eIO Model",
          "package": "toysolver",
          "signature": "Solver-\u003eIO Model",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:model"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enumber of assigned variables.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "nAssigns",
          "package": "toysolver",
          "signature": "Solver -\u003e IO Int",
          "source": "src/SAT.html#nAssigns",
          "type": "function"
        },
        "index": {
          "description": "number of assigned variables",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "nAssigns",
          "normalized": "Solver-\u003eIO Int",
          "package": "toysolver",
          "partial": "Assigns",
          "signature": "Solver-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:nAssigns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enumber of clauses.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "nClauses",
          "package": "toysolver",
          "signature": "Solver -\u003e IO Int",
          "source": "src/SAT.html#nClauses",
          "type": "function"
        },
        "index": {
          "description": "number of clauses",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "nClauses",
          "normalized": "Solver-\u003eIO Int",
          "package": "toysolver",
          "partial": "Clauses",
          "signature": "Solver-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:nClauses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enumber of learnt constrints.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "nLearnt",
          "package": "toysolver",
          "signature": "Solver -\u003e IO Int",
          "source": "src/SAT.html#nLearnt",
          "type": "function"
        },
        "index": {
          "description": "number of learnt constrints",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "nLearnt",
          "normalized": "Solver-\u003eIO Int",
          "package": "toysolver",
          "partial": "Learnt",
          "signature": "Solver-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:nLearnt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enumber of variables of the problem.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "nVars",
          "package": "toysolver",
          "signature": "Solver -\u003e IO Int",
          "source": "src/SAT.html#nVars",
          "type": "function"
        },
        "index": {
          "description": "number of variables of the problem",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "nVars",
          "normalized": "Solver-\u003eIO Int",
          "package": "toysolver",
          "partial": "Vars",
          "signature": "Solver-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:nVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new Solver instance.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "newSolver",
          "package": "toysolver",
          "signature": "IO Solver",
          "source": "src/SAT.html#newSolver",
          "type": "function"
        },
        "index": {
          "description": "Create new Solver instance",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "newSolver",
          "package": "toysolver",
          "partial": "Solver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:newSolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a new variable\n\u003c/p\u003e",
          "module": "SAT",
          "name": "newVar",
          "package": "toysolver",
          "signature": "Solver -\u003e IO Var",
          "source": "src/SAT.html#newVar",
          "type": "function"
        },
        "index": {
          "description": "Add new variable",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "newVar",
          "normalized": "Solver-\u003eIO Var",
          "package": "toysolver",
          "partial": "Var",
          "signature": "Solver-\u003eIO Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:newVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd variables. \u003ccode\u003enewVars solver n = replicateM n (newVar solver)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "SAT",
          "name": "newVars",
          "package": "toysolver",
          "signature": "Solver -\u003e Int -\u003e IO [Var]",
          "source": "src/SAT.html#newVars",
          "type": "function"
        },
        "index": {
          "description": "Add variables newVars solver replicateM newVar solver",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "newVars",
          "normalized": "Solver-\u003eInt-\u003eIO[Var]",
          "package": "toysolver",
          "partial": "Vars",
          "signature": "Solver-\u003eInt-\u003eIO[Var]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:newVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd variables. \u003ccode\u003enewVars_ solver n \u003e\u003e return () = newVars_ solver n\u003c/code\u003e\n\u003c/p\u003e",
          "module": "SAT",
          "name": "newVars_",
          "package": "toysolver",
          "signature": "Solver -\u003e Int -\u003e IO ()",
          "source": "src/SAT.html#newVars_",
          "type": "function"
        },
        "index": {
          "description": "Add variables newVars solver return newVars solver",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "newVars_",
          "normalized": "Solver-\u003eInt-\u003eIO()",
          "package": "toysolver",
          "partial": "Vars",
          "signature": "Solver-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:newVars_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe limit for learnt clauses is multiplied with this factor each restart. (default 1.1)\n\u003c/p\u003e",
          "module": "SAT",
          "name": "setCCMin",
          "package": "toysolver",
          "signature": "Solver -\u003e Int -\u003e IO ()",
          "source": "src/SAT.html#setCCMin",
          "type": "function"
        },
        "index": {
          "description": "The limit for learnt clauses is multiplied with this factor each restart default",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "setCCMin",
          "normalized": "Solver-\u003eInt-\u003eIO()",
          "package": "toysolver",
          "partial": "CCMin",
          "signature": "Solver-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setCCMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "setCheckModel",
          "package": "toysolver",
          "signature": "Solver -\u003e Bool -\u003e IO ()",
          "source": "src/SAT.html#setCheckModel",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "setCheckModel",
          "normalized": "Solver-\u003eBool-\u003eIO()",
          "package": "toysolver",
          "partial": "Check Model",
          "signature": "Solver-\u003eBool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setCheckModel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "setConfBudget",
          "package": "toysolver",
          "signature": "Solver -\u003e Maybe Int -\u003e IO ()",
          "source": "src/SAT.html#setConfBudget",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "setConfBudget",
          "normalized": "Solver-\u003eMaybe Int-\u003eIO()",
          "package": "toysolver",
          "partial": "Conf Budget",
          "signature": "Solver-\u003eMaybe Int-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setConfBudget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "setLearningStrategy",
          "package": "toysolver",
          "signature": "Solver -\u003e LearningStrategy -\u003e IO ()",
          "source": "src/SAT.html#setLearningStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "setLearningStrategy",
          "normalized": "Solver-\u003eLearningStrategy-\u003eIO()",
          "package": "toysolver",
          "partial": "Learning Strategy",
          "signature": "Solver-\u003eLearningStrategy-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setLearningStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe initial limit for learnt clauses.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "setLearntSizeFirst",
          "package": "toysolver",
          "signature": "Solver -\u003e Int -\u003e IO ()",
          "source": "src/SAT.html#setLearntSizeFirst",
          "type": "function"
        },
        "index": {
          "description": "The initial limit for learnt clauses",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "setLearntSizeFirst",
          "normalized": "Solver-\u003eInt-\u003eIO()",
          "package": "toysolver",
          "partial": "Learnt Size First",
          "signature": "Solver-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setLearntSizeFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe limit for learnt clauses is multiplied with this factor each restart. (default 1.1)\n\u003c/p\u003e",
          "module": "SAT",
          "name": "setLearntSizeInc",
          "package": "toysolver",
          "signature": "Solver -\u003e Double -\u003e IO ()",
          "source": "src/SAT.html#setLearntSizeInc",
          "type": "function"
        },
        "index": {
          "description": "The limit for learnt clauses is multiplied with this factor each restart default",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "setLearntSizeInc",
          "normalized": "Solver-\u003eDouble-\u003eIO()",
          "package": "toysolver",
          "partial": "Learnt Size Inc",
          "signature": "Solver-\u003eDouble-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setLearntSizeInc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset callback function for receiving messages.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "setLogger",
          "package": "toysolver",
          "signature": "Solver -\u003e (String -\u003e IO ()) -\u003e IO ()",
          "source": "src/SAT.html#setLogger",
          "type": "function"
        },
        "index": {
          "description": "set callback function for receiving messages",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "setLogger",
          "normalized": "Solver-\u003e(String-\u003eIO())-\u003eIO()",
          "package": "toysolver",
          "partial": "Logger",
          "signature": "Solver-\u003e(String-\u003eIO())-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setLogger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe frequency with which the decision heuristic tries to choose a random variable\n\u003c/p\u003e",
          "module": "SAT",
          "name": "setRandomFreq",
          "package": "toysolver",
          "signature": "Solver -\u003e Double -\u003e IO ()",
          "source": "src/SAT.html#setRandomFreq",
          "type": "function"
        },
        "index": {
          "description": "The frequency with which the decision heuristic tries to choose random variable",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "setRandomFreq",
          "normalized": "Solver-\u003eDouble-\u003eIO()",
          "package": "toysolver",
          "partial": "Random Freq",
          "signature": "Solver-\u003eDouble-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setRandomFreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed by the random variable selection\n\u003c/p\u003e",
          "module": "SAT",
          "name": "setRandomSeed",
          "package": "toysolver",
          "signature": "Solver -\u003e Int -\u003e IO ()",
          "source": "src/SAT.html#setRandomSeed",
          "type": "function"
        },
        "index": {
          "description": "Used by the random variable selection",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "setRandomSeed",
          "normalized": "Solver-\u003eInt-\u003eIO()",
          "package": "toysolver",
          "partial": "Random Seed",
          "signature": "Solver-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setRandomSeed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe initial restart limit. (default 100)\n Negative value is used to disable restart.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "setRestartFirst",
          "package": "toysolver",
          "signature": "Solver -\u003e Int -\u003e IO ()",
          "source": "src/SAT.html#setRestartFirst",
          "type": "function"
        },
        "index": {
          "description": "The initial restart limit default Negative value is used to disable restart",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "setRestartFirst",
          "normalized": "Solver-\u003eInt-\u003eIO()",
          "package": "toysolver",
          "partial": "Restart First",
          "signature": "Solver-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setRestartFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe factor with which the restart limit is multiplied in each restart. (default 1.5)\n\u003c/p\u003e",
          "module": "SAT",
          "name": "setRestartInc",
          "package": "toysolver",
          "signature": "Solver -\u003e Double -\u003e IO ()",
          "source": "src/SAT.html#setRestartInc",
          "type": "function"
        },
        "index": {
          "description": "The factor with which the restart limit is multiplied in each restart default",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "setRestartInc",
          "normalized": "Solver-\u003eDouble-\u003eIO()",
          "package": "toysolver",
          "partial": "Restart Inc",
          "signature": "Solver-\u003eDouble-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setRestartInc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "setRestartStrategy",
          "package": "toysolver",
          "signature": "Solver -\u003e RestartStrategy -\u003e IO ()",
          "source": "src/SAT.html#setRestartStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "setRestartStrategy",
          "normalized": "Solver-\u003eRestartStrategy-\u003eIO()",
          "package": "toysolver",
          "partial": "Restart Strategy",
          "signature": "Solver-\u003eRestartStrategy-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setRestartStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default polarity of a variable.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "setVarPolarity",
          "package": "toysolver",
          "signature": "Solver -\u003e Var -\u003e Bool -\u003e IO ()",
          "source": "src/SAT.html#setVarPolarity",
          "type": "function"
        },
        "index": {
          "description": "The default polarity of variable",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "setVarPolarity",
          "normalized": "Solver-\u003eVar-\u003eBool-\u003eIO()",
          "package": "toysolver",
          "partial": "Var Polarity",
          "signature": "Solver-\u003eVar-\u003eBool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setVarPolarity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve constraints.\n Returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the problem is SATISFIABLE.\n Returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if the problem is UNSATISFIABLE.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "solve",
          "package": "toysolver",
          "signature": "Solver -\u003e IO Bool",
          "source": "src/SAT.html#solve",
          "type": "function"
        },
        "index": {
          "description": "Solve constraints Returns True if the problem is SATISFIABLE Returns False if the problem is UNSATISFIABLE",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "solve",
          "normalized": "Solver-\u003eIO Bool",
          "package": "toysolver",
          "signature": "Solver-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:solve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve constraints under assuptions.\n Returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the problem is SATISFIABLE.\n Returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if the problem is UNSATISFIABLE.\n\u003c/p\u003e",
          "module": "SAT",
          "name": "solveWith",
          "package": "toysolver",
          "signature": "Solver-\u003e [Lit]-\u003e IO Bool",
          "type": "function"
        },
        "index": {
          "description": "Solve constraints under assuptions Returns True if the problem is SATISFIABLE Returns False if the problem is UNSATISFIABLE",
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "solveWith",
          "normalized": "Solver-\u003e[Lit]-\u003eIO Bool",
          "package": "toysolver",
          "partial": "With",
          "signature": "Solver-\u003e[Lit]-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:solveWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "varBumpActivity",
          "package": "toysolver",
          "signature": "Solver -\u003e Var -\u003e IO ()",
          "source": "src/SAT.html#varBumpActivity",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "varBumpActivity",
          "normalized": "Solver-\u003eVar-\u003eIO()",
          "package": "toysolver",
          "partial": "Bump Activity",
          "signature": "Solver-\u003eVar-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:varBumpActivity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "SAT",
          "name": "varDecayActivity",
          "package": "toysolver",
          "signature": "Solver -\u003e IO ()",
          "source": "src/SAT.html#varDecayActivity",
          "type": "function"
        },
        "index": {
          "hierarchy": "SAT",
          "module": "SAT",
          "name": "varDecayActivity",
          "normalized": "Solver-\u003eIO()",
          "package": "toysolver",
          "partial": "Decay Activity",
          "signature": "Solver-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:varDecayActivity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.satcompetition.org/2011/rules.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Text.GCNF",
          "name": "GCNF",
          "package": "toysolver",
          "source": "src/Text-GCNF.html",
          "type": "module"
        },
        "index": {
          "description": "References http www.satcompetition.org rules.pdf",
          "hierarchy": "Text GCNF",
          "module": "Text.GCNF",
          "name": "GCNF",
          "package": "toysolver",
          "partial": "GCNF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GCNF",
          "name": "GCNF",
          "package": "toysolver",
          "source": "src/Text-GCNF.html#GCNF",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text GCNF",
          "module": "Text.GCNF",
          "name": "GCNF",
          "package": "toysolver",
          "partial": "GCNF",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#t:GCNF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GCNF",
          "name": "GClause",
          "package": "toysolver",
          "source": "src/Text-GCNF.html#GClause",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text GCNF",
          "module": "Text.GCNF",
          "name": "GClause",
          "package": "toysolver",
          "partial": "GClause",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#t:GClause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GCNF",
          "name": "GroupIndex",
          "package": "toysolver",
          "source": "src/Text-GCNF.html#GroupIndex",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text GCNF",
          "module": "Text.GCNF",
          "name": "GroupIndex",
          "package": "toysolver",
          "partial": "Group Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#t:GroupIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GCNF",
          "name": "GCNF",
          "package": "toysolver",
          "signature": "GCNF",
          "source": "src/Text-GCNF.html#GCNF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text GCNF",
          "module": "Text.GCNF",
          "name": "GCNF",
          "package": "toysolver",
          "partial": "GCNF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#v:GCNF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GCNF",
          "name": "clauses",
          "package": "toysolver",
          "signature": "[GClause]",
          "source": "src/Text-GCNF.html#GCNF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text GCNF",
          "module": "Text.GCNF",
          "name": "clauses",
          "normalized": "[GClause]",
          "package": "toysolver",
          "signature": "[GClause]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#v:clauses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GCNF",
          "name": "lastGroupIndex",
          "package": "toysolver",
          "signature": "GroupIndex",
          "source": "src/Text-GCNF.html#GCNF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text GCNF",
          "module": "Text.GCNF",
          "name": "lastGroupIndex",
          "package": "toysolver",
          "partial": "Group Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#v:lastGroupIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GCNF",
          "name": "numClauses",
          "package": "toysolver",
          "signature": "Int",
          "source": "src/Text-GCNF.html#GCNF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text GCNF",
          "module": "Text.GCNF",
          "name": "numClauses",
          "package": "toysolver",
          "partial": "Clauses",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#v:numClauses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GCNF",
          "name": "numVars",
          "package": "toysolver",
          "signature": "Int",
          "source": "src/Text-GCNF.html#GCNF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text GCNF",
          "module": "Text.GCNF",
          "name": "numVars",
          "package": "toysolver",
          "partial": "Vars",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#v:numVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GCNF",
          "name": "parseFile",
          "package": "toysolver",
          "signature": "FilePath -\u003e IO (Either String GCNF)",
          "source": "src/Text-GCNF.html#parseFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text GCNF",
          "module": "Text.GCNF",
          "name": "parseFile",
          "normalized": "FilePath-\u003eIO(Either String GCNF)",
          "package": "toysolver",
          "partial": "File",
          "signature": "FilePath-\u003eIO(Either String GCNF)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#v:parseFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GCNF",
          "name": "parseString",
          "package": "toysolver",
          "signature": "String -\u003e Either String GCNF",
          "source": "src/Text-GCNF.html#parseString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text GCNF",
          "module": "Text.GCNF",
          "name": "parseString",
          "normalized": "String-\u003eEither String GCNF",
          "package": "toysolver",
          "partial": "String",
          "signature": "String-\u003eEither String GCNF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#v:parseString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GurobiSol",
          "name": "GurobiSol",
          "package": "toysolver",
          "source": "src/Text-GurobiSol.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text GurobiSol",
          "module": "Text.GurobiSol",
          "name": "GurobiSol",
          "package": "toysolver",
          "partial": "Gurobi Sol",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GurobiSol.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GurobiSol",
          "name": "Model",
          "package": "toysolver",
          "source": "src/Text-GurobiSol.html#Model",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text GurobiSol",
          "module": "Text.GurobiSol",
          "name": "Model",
          "package": "toysolver",
          "partial": "Model",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GurobiSol.html#t:Model"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GurobiSol",
          "name": "render",
          "package": "toysolver",
          "signature": "Model -\u003e Maybe Double -\u003e String",
          "source": "src/Text-GurobiSol.html#render",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text GurobiSol",
          "module": "Text.GurobiSol",
          "name": "render",
          "normalized": "Model-\u003eMaybe Double-\u003eString",
          "package": "toysolver",
          "signature": "Model-\u003eMaybe Double-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GurobiSol.html#v:render"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA CPLEX .lp format parser library.\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://publib.boulder.ibm.com/infocenter/cosinfoc/v12r2/index.jsp?topic=/ilog.odms.cplex.help/Content/Optimization/Documentation/CPLEX/_pubskel/CPLEX880.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://www.gurobi.com/doc/45/refman/node589.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://lpsolve.sourceforge.net/5.5/CPLEX-format.htm\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Text.LPFile",
          "name": "LPFile",
          "package": "toysolver",
          "source": "src/Text-LPFile.html",
          "type": "module"
        },
        "index": {
          "description": "CPLEX lp format parser library References http publib.boulder.ibm.com infocenter cosinfoc v12r2 index.jsp topic ilog.odms.cplex.help Content Optimization Documentation CPLEX pubskel CPLEX880.html http www.gurobi.com doc refman node589.html http lpsolve.sourceforge.net CPLEX-format.htm",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "LPFile",
          "package": "toysolver",
          "partial": "LPFile",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype for representing lower/upper bound of variables\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "BoundExpr",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#BoundExpr",
          "type": "data"
        },
        "index": {
          "description": "type for representing lower upper bound of variables",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "BoundExpr",
          "package": "toysolver",
          "partial": "Bound Expr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:BoundExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype for representing lower/upper bound of variables\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "Bounds",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#Bounds",
          "type": "type"
        },
        "index": {
          "description": "type for representing lower upper bound of variables",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "Bounds",
          "package": "toysolver",
          "partial": "Bounds",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:Bounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstraint\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "Constraint",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#Constraint",
          "type": "data"
        },
        "index": {
          "description": "constraint",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "Constraint",
          "package": "toysolver",
          "partial": "Constraint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:Constraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "ConstraintType",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#ConstraintType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "ConstraintType",
          "package": "toysolver",
          "partial": "Constraint Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:ConstraintType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexpressions\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "Expr",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#Expr",
          "type": "type"
        },
        "index": {
          "description": "expressions",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "Expr",
          "package": "toysolver",
          "partial": "Expr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:Expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProblem\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "LP",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#LP",
          "type": "data"
        },
        "index": {
          "description": "Problem",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "LP",
          "package": "toysolver",
          "partial": "LP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:LP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elabel\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "Label",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#Label",
          "type": "type"
        },
        "index": {
          "description": "label",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "Label",
          "package": "toysolver",
          "partial": "Label",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:Label"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eobjective function\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "ObjectiveFunction",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#ObjectiveFunction",
          "type": "type"
        },
        "index": {
          "description": "objective function",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "ObjectiveFunction",
          "package": "toysolver",
          "partial": "Objective Function",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:ObjectiveFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eOptDir\u003c/a\u003e\u003c/code\u003e type represents optimization directions.\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "OptDir",
          "package": "toysolver",
          "type": "data"
        },
        "index": {
          "description": "The OptDir type represents optimization directions",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "OptDir",
          "package": "toysolver",
          "partial": "Opt Dir",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:OptDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erelational operators\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "RelOp",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#RelOp",
          "type": "data"
        },
        "index": {
          "description": "relational operators",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "RelOp",
          "package": "toysolver",
          "partial": "Rel Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:RelOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSOS (special ordered sets) constraints\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "SOS",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#SOS",
          "type": "type"
        },
        "index": {
          "description": "SOS special ordered sets constraints",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "SOS",
          "package": "toysolver",
          "partial": "SOS",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:SOS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etypes of SOS (special ordered sets) constraints\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "SOSType",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#SOSType",
          "type": "data"
        },
        "index": {
          "description": "types of SOS special ordered sets constraints",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "SOSType",
          "package": "toysolver",
          "partial": "SOSType",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:SOSType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eterms\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "Term",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#Term",
          "type": "data"
        },
        "index": {
          "description": "terms",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "Term",
          "package": "toysolver",
          "partial": "Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "Var",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#Var",
          "type": "type"
        },
        "index": {
          "description": "variable",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "Var",
          "package": "toysolver",
          "partial": "Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "VarInfo",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#VarInfo",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "VarInfo",
          "package": "toysolver",
          "partial": "Var Info",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:VarInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "VarType",
          "package": "toysolver",
          "source": "src/Text-LPFile.html#VarType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "VarType",
          "package": "toysolver",
          "partial": "Var Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:VarType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "Constraint",
          "package": "toysolver",
          "signature": "Constraint",
          "source": "src/Text-LPFile.html#Constraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "Constraint",
          "package": "toysolver",
          "partial": "Constraint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:Constraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "ContinuousVariable",
          "package": "toysolver",
          "signature": "ContinuousVariable",
          "source": "src/Text-LPFile.html#VarType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "ContinuousVariable",
          "package": "toysolver",
          "partial": "Continuous Variable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:ContinuousVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "Eql",
          "package": "toysolver",
          "signature": "Eql",
          "source": "src/Text-LPFile.html#RelOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "Eql",
          "package": "toysolver",
          "partial": "Eql",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:Eql"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "Finite",
          "package": "toysolver",
          "signature": "Finite Rational",
          "source": "src/Text-LPFile.html#BoundExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "Finite",
          "package": "toysolver",
          "partial": "Finite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:Finite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "Ge",
          "package": "toysolver",
          "signature": "Ge",
          "source": "src/Text-LPFile.html#RelOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "Ge",
          "package": "toysolver",
          "partial": "Ge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:Ge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "IntegerVariable",
          "package": "toysolver",
          "signature": "IntegerVariable",
          "source": "src/Text-LPFile.html#VarType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "IntegerVariable",
          "package": "toysolver",
          "partial": "Integer Variable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:IntegerVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "LP",
          "package": "toysolver",
          "signature": "LP",
          "source": "src/Text-LPFile.html#LP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "LP",
          "package": "toysolver",
          "partial": "LP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:LP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "LazyConstraint",
          "package": "toysolver",
          "signature": "LazyConstraint",
          "source": "src/Text-LPFile.html#ConstraintType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "LazyConstraint",
          "package": "toysolver",
          "partial": "Lazy Constraint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:LazyConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "Le",
          "package": "toysolver",
          "signature": "Le",
          "source": "src/Text-LPFile.html#RelOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "Le",
          "package": "toysolver",
          "partial": "Le",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:Le"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "NegInf",
          "package": "toysolver",
          "signature": "NegInf",
          "source": "src/Text-LPFile.html#BoundExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "NegInf",
          "package": "toysolver",
          "partial": "Neg Inf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:NegInf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "NormalConstraint",
          "package": "toysolver",
          "signature": "NormalConstraint",
          "source": "src/Text-LPFile.html#ConstraintType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "NormalConstraint",
          "package": "toysolver",
          "partial": "Normal Constraint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:NormalConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "PosInf",
          "package": "toysolver",
          "signature": "PosInf",
          "source": "src/Text-LPFile.html#BoundExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "PosInf",
          "package": "toysolver",
          "partial": "Pos Inf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:PosInf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType 1 SOS constraint\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "S1",
          "package": "toysolver",
          "signature": "S1",
          "source": "src/Text-LPFile.html#SOSType",
          "type": "function"
        },
        "index": {
          "description": "Type SOS constraint",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "S1",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:S1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType 2 SOS constraint\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "S2",
          "package": "toysolver",
          "signature": "S2",
          "source": "src/Text-LPFile.html#SOSType",
          "type": "function"
        },
        "index": {
          "description": "Type SOS constraint",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "S2",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:S2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "SemiContinuousVariable",
          "package": "toysolver",
          "signature": "SemiContinuousVariable",
          "source": "src/Text-LPFile.html#VarType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "SemiContinuousVariable",
          "package": "toysolver",
          "partial": "Semi Continuous Variable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:SemiContinuousVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "Term",
          "package": "toysolver",
          "signature": "Term Rational [Var]",
          "source": "src/Text-LPFile.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "Term",
          "normalized": "Term Rational[Var]",
          "package": "toysolver",
          "partial": "Term",
          "signature": "Term Rational[Var]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "UserDefinedCut",
          "package": "toysolver",
          "signature": "UserDefinedCut",
          "source": "src/Text-LPFile.html#ConstraintType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "UserDefinedCut",
          "package": "toysolver",
          "partial": "User Defined Cut",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:UserDefinedCut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "VarInfo",
          "package": "toysolver",
          "signature": "VarInfo",
          "source": "src/Text-LPFile.html#VarInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "VarInfo",
          "package": "toysolver",
          "partial": "Var Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:VarInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "constrBody",
          "package": "toysolver",
          "signature": "(Expr, RelOp, Rational)",
          "source": "src/Text-LPFile.html#Constraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "constrBody",
          "normalized": "(Expr,RelOp,Rational)",
          "package": "toysolver",
          "partial": "Body",
          "signature": "(Expr,RelOp,Rational)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:constrBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "constrIndicator",
          "package": "toysolver",
          "signature": "Maybe (Var, Rational)",
          "source": "src/Text-LPFile.html#Constraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "constrIndicator",
          "normalized": "Maybe(Var,Rational)",
          "package": "toysolver",
          "partial": "Indicator",
          "signature": "Maybe(Var,Rational)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:constrIndicator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "constrLabel",
          "package": "toysolver",
          "signature": "Maybe Label",
          "source": "src/Text-LPFile.html#Constraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "constrLabel",
          "package": "toysolver",
          "partial": "Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:constrLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "constrType",
          "package": "toysolver",
          "signature": "ConstraintType",
          "source": "src/Text-LPFile.html#Constraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "constrType",
          "package": "toysolver",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:constrType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "constraints",
          "package": "toysolver",
          "signature": "[Constraint]",
          "source": "src/Text-LPFile.html#LP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "constraints",
          "normalized": "[Constraint]",
          "package": "toysolver",
          "signature": "[Constraint]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:constraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault bounds\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "defaultBounds",
          "package": "toysolver",
          "signature": "Bounds",
          "source": "src/Text-LPFile.html#defaultBounds",
          "type": "function"
        },
        "index": {
          "description": "default bounds",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "defaultBounds",
          "package": "toysolver",
          "partial": "Bounds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:defaultBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault lower bound (0)\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "defaultLB",
          "package": "toysolver",
          "signature": "BoundExpr",
          "source": "src/Text-LPFile.html#defaultLB",
          "type": "function"
        },
        "index": {
          "description": "default lower bound",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "defaultLB",
          "package": "toysolver",
          "partial": "LB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:defaultLB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault upper bound (+&#8734;)\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "defaultUB",
          "package": "toysolver",
          "signature": "BoundExpr",
          "source": "src/Text-LPFile.html#defaultUB",
          "type": "function"
        },
        "index": {
          "description": "default upper bound",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "defaultUB",
          "package": "toysolver",
          "partial": "UB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:defaultUB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "dir",
          "package": "toysolver",
          "signature": "OptDir",
          "source": "src/Text-LPFile.html#LP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "dir",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:dir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elooking up bounds for a variable\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "getBounds",
          "package": "toysolver",
          "signature": "LP -\u003e Var -\u003e Bounds",
          "source": "src/Text-LPFile.html#getBounds",
          "type": "function"
        },
        "index": {
          "description": "looking up bounds for variable",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "getBounds",
          "normalized": "LP-\u003eVar-\u003eBounds",
          "package": "toysolver",
          "partial": "Bounds",
          "signature": "LP-\u003eVar-\u003eBounds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:getBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elooking up attributes for a variable\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "getVarInfo",
          "package": "toysolver",
          "signature": "LP -\u003e Var -\u003e VarInfo",
          "source": "src/Text-LPFile.html#getVarInfo",
          "type": "function"
        },
        "index": {
          "description": "looking up attributes for variable",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "getVarInfo",
          "normalized": "LP-\u003eVar-\u003eVarInfo",
          "package": "toysolver",
          "partial": "Var Info",
          "signature": "LP-\u003eVar-\u003eVarInfo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:getVarInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elooking up bounds for a variable\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "getVarType",
          "package": "toysolver",
          "signature": "LP -\u003e Var -\u003e VarType",
          "source": "src/Text-LPFile.html#getVarType",
          "type": "function"
        },
        "index": {
          "description": "looking up bounds for variable",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "getVarType",
          "normalized": "LP-\u003eVar-\u003eVarType",
          "package": "toysolver",
          "partial": "Var Type",
          "signature": "LP-\u003eVar-\u003eVarType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:getVarType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "integerVariables",
          "package": "toysolver",
          "signature": "LP -\u003e Set Var",
          "source": "src/Text-LPFile.html#integerVariables",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "integerVariables",
          "normalized": "LP-\u003eSet Var",
          "package": "toysolver",
          "partial": "Variables",
          "signature": "LP-\u003eSet Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:integerVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "objectiveFunction",
          "package": "toysolver",
          "signature": "ObjectiveFunction",
          "source": "src/Text-LPFile.html#LP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "objectiveFunction",
          "package": "toysolver",
          "partial": "Function",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:objectiveFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a file containing LP file data.\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "parseFile",
          "package": "toysolver",
          "signature": "FilePath -\u003e IO (Either ParseError LP)",
          "source": "src/Text-LPFile.html#parseFile",
          "type": "function"
        },
        "index": {
          "description": "Parse file containing LP file data",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "parseFile",
          "normalized": "FilePath-\u003eIO(Either ParseError LP)",
          "package": "toysolver",
          "partial": "File",
          "signature": "FilePath-\u003eIO(Either ParseError LP)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:parseFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string containing LP file data.\n The source name is only | used in error messages and may be the empty string.\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "parseString",
          "package": "toysolver",
          "signature": "SourceName -\u003e String -\u003e Either ParseError LP",
          "source": "src/Text-LPFile.html#parseString",
          "type": "function"
        },
        "index": {
          "description": "Parse string containing LP file data The source name is only used in error messages and may be the empty string",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "parseString",
          "normalized": "SourceName-\u003eString-\u003eEither ParseError LP",
          "package": "toysolver",
          "partial": "String",
          "signature": "SourceName-\u003eString-\u003eEither ParseError LP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:parseString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender a problem into a string.\n\u003c/p\u003e",
          "module": "Text.LPFile",
          "name": "render",
          "package": "toysolver",
          "signature": "LP -\u003e Maybe String",
          "source": "src/Text-LPFile.html#render",
          "type": "function"
        },
        "index": {
          "description": "Render problem into string",
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "render",
          "normalized": "LP-\u003eMaybe String",
          "package": "toysolver",
          "signature": "LP-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:render"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "semiContinuousVariables",
          "package": "toysolver",
          "signature": "LP -\u003e Set Var",
          "source": "src/Text-LPFile.html#semiContinuousVariables",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "semiContinuousVariables",
          "normalized": "LP-\u003eSet Var",
          "package": "toysolver",
          "partial": "Continuous Variables",
          "signature": "LP-\u003eSet Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:semiContinuousVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "sos",
          "package": "toysolver",
          "signature": "[SOS]",
          "source": "src/Text-LPFile.html#LP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "sos",
          "normalized": "[SOS]",
          "package": "toysolver",
          "signature": "[SOS]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:sos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "varBounds",
          "package": "toysolver",
          "signature": "Bounds",
          "source": "src/Text-LPFile.html#VarInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "varBounds",
          "package": "toysolver",
          "partial": "Bounds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:varBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "varInfo",
          "package": "toysolver",
          "signature": "Map Var VarInfo",
          "source": "src/Text-LPFile.html#LP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "varInfo",
          "package": "toysolver",
          "partial": "Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:varInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "varName",
          "package": "toysolver",
          "signature": "Var",
          "source": "src/Text-LPFile.html#VarInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "varName",
          "package": "toysolver",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:varName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "varType",
          "package": "toysolver",
          "signature": "VarType",
          "source": "src/Text-LPFile.html#VarInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "varType",
          "package": "toysolver",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:varType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.LPFile",
          "name": "variables",
          "package": "toysolver",
          "signature": "Set Var",
          "source": "src/Text-LPFile.html#LP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text LPFile",
          "module": "Text.LPFile",
          "name": "variables",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:variables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA .mps format parser library.\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://pic.dhe.ibm.com/infocenter/cosinfoc/v12r4/topic/ilog.odms.cplex.help/CPLEX/File_formats_reference/topics/MPS_synopsis.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://pic.dhe.ibm.com/infocenter/cosinfoc/v12r4/topic/ilog.odms.cplex.help/CPLEX/File_formats_reference/topics/MPS_ext_synopsis.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://www.gurobi.com/documentation/5.0/reference-manual/node744\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://en.wikipedia.org/wiki/MPS_(format)\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Text.MPSFile",
          "name": "MPSFile",
          "package": "toysolver",
          "source": "src/Text-MPSFile.html",
          "type": "module"
        },
        "index": {
          "description": "mps format parser library References http pic.dhe.ibm.com infocenter cosinfoc v12r4 topic ilog.odms.cplex.help CPLEX File formats reference topics MPS synopsis.html http pic.dhe.ibm.com infocenter cosinfoc v12r4 topic ilog.odms.cplex.help CPLEX File formats reference topics MPS ext synopsis.html http www.gurobi.com documentation reference-manual node744 http en.wikipedia.org wiki MPS format",
          "hierarchy": "Text MPSFile",
          "module": "Text.MPSFile",
          "name": "MPSFile",
          "package": "toysolver",
          "partial": "MPSFile",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MPSFile.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a file containing LP file data.\n\u003c/p\u003e",
          "module": "Text.MPSFile",
          "name": "parseFile",
          "package": "toysolver",
          "signature": "FilePath -\u003e IO (Either ParseError LP)",
          "source": "src/Text-MPSFile.html#parseFile",
          "type": "function"
        },
        "index": {
          "description": "Parse file containing LP file data",
          "hierarchy": "Text MPSFile",
          "module": "Text.MPSFile",
          "name": "parseFile",
          "normalized": "FilePath-\u003eIO(Either ParseError LP)",
          "package": "toysolver",
          "partial": "File",
          "signature": "FilePath-\u003eIO(Either ParseError LP)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MPSFile.html#v:parseFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string containing LP file data.\n The source name is only | used in error messages and may be the empty string.\n\u003c/p\u003e",
          "module": "Text.MPSFile",
          "name": "parseString",
          "package": "toysolver",
          "signature": "SourceName -\u003e String -\u003e Either ParseError LP",
          "source": "src/Text-MPSFile.html#parseString",
          "type": "function"
        },
        "index": {
          "description": "Parse string containing LP file data The source name is only used in error messages and may be the empty string",
          "hierarchy": "Text MPSFile",
          "module": "Text.MPSFile",
          "name": "parseString",
          "normalized": "SourceName-\u003eString-\u003eEither ParseError LP",
          "package": "toysolver",
          "partial": "String",
          "signature": "SourceName-\u003eString-\u003eEither ParseError LP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MPSFile.html#v:parseString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://maxsat.ia.udl.cat/requirements/\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Text.MaxSAT",
          "name": "MaxSAT",
          "package": "toysolver",
          "source": "src/Text-MaxSAT.html",
          "type": "module"
        },
        "index": {
          "description": "References http maxsat.ia.udl.cat requirements",
          "hierarchy": "Text MaxSAT",
          "module": "Text.MaxSAT",
          "name": "MaxSAT",
          "package": "toysolver",
          "partial": "Max SAT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.MaxSAT",
          "name": "WCNF",
          "package": "toysolver",
          "source": "src/Text-MaxSAT.html#WCNF",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text MaxSAT",
          "module": "Text.MaxSAT",
          "name": "WCNF",
          "package": "toysolver",
          "partial": "WCNF",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#t:WCNF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshould be able to represent 2^63\n\u003c/p\u003e",
          "module": "Text.MaxSAT",
          "name": "Weight",
          "package": "toysolver",
          "source": "src/Text-MaxSAT.html#Weight",
          "type": "type"
        },
        "index": {
          "description": "should be able to represent",
          "hierarchy": "Text MaxSAT",
          "module": "Text.MaxSAT",
          "name": "Weight",
          "package": "toysolver",
          "partial": "Weight",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#t:Weight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.MaxSAT",
          "name": "WeightedClause",
          "package": "toysolver",
          "source": "src/Text-MaxSAT.html#WeightedClause",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text MaxSAT",
          "module": "Text.MaxSAT",
          "name": "WeightedClause",
          "package": "toysolver",
          "partial": "Weighted Clause",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#t:WeightedClause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.MaxSAT",
          "name": "WCNF",
          "package": "toysolver",
          "signature": "WCNF",
          "source": "src/Text-MaxSAT.html#WCNF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text MaxSAT",
          "module": "Text.MaxSAT",
          "name": "WCNF",
          "package": "toysolver",
          "partial": "WCNF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#v:WCNF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.MaxSAT",
          "name": "clauses",
          "package": "toysolver",
          "signature": "[WeightedClause]",
          "source": "src/Text-MaxSAT.html#WCNF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text MaxSAT",
          "module": "Text.MaxSAT",
          "name": "clauses",
          "normalized": "[WeightedClause]",
          "package": "toysolver",
          "signature": "[WeightedClause]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#v:clauses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.MaxSAT",
          "name": "numClauses",
          "package": "toysolver",
          "signature": "Int",
          "source": "src/Text-MaxSAT.html#WCNF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text MaxSAT",
          "module": "Text.MaxSAT",
          "name": "numClauses",
          "package": "toysolver",
          "partial": "Clauses",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#v:numClauses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.MaxSAT",
          "name": "numVars",
          "package": "toysolver",
          "signature": "Int",
          "source": "src/Text-MaxSAT.html#WCNF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text MaxSAT",
          "module": "Text.MaxSAT",
          "name": "numVars",
          "package": "toysolver",
          "partial": "Vars",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#v:numVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.MaxSAT",
          "name": "parseWCNFFile",
          "package": "toysolver",
          "signature": "FilePath -\u003e IO (Either String WCNF)",
          "source": "src/Text-MaxSAT.html#parseWCNFFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text MaxSAT",
          "module": "Text.MaxSAT",
          "name": "parseWCNFFile",
          "normalized": "FilePath-\u003eIO(Either String WCNF)",
          "package": "toysolver",
          "partial": "WCNFFile",
          "signature": "FilePath-\u003eIO(Either String WCNF)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#v:parseWCNFFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.MaxSAT",
          "name": "parseWCNFString",
          "package": "toysolver",
          "signature": "String -\u003e Either String WCNF",
          "source": "src/Text-MaxSAT.html#parseWCNFString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text MaxSAT",
          "module": "Text.MaxSAT",
          "name": "parseWCNFString",
          "normalized": "String-\u003eEither String WCNF",
          "package": "toysolver",
          "partial": "WCNFString",
          "signature": "String-\u003eEither String WCNF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#v:parseWCNFString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.MaxSAT",
          "name": "topCost",
          "package": "toysolver",
          "signature": "Weight",
          "source": "src/Text-MaxSAT.html#WCNF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text MaxSAT",
          "module": "Text.MaxSAT",
          "name": "topCost",
          "package": "toysolver",
          "partial": "Cost",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#v:topCost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA parser library for .opb file and .wbo files used by PB Competition.\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Input/Output Format and Solver Requirements for the Competitions of\n   Pseudo-Boolean Solvers\n   \u003ca\u003ehttp://www.cril.univ-artois.fr/PB11/format.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Text.PBFile",
          "name": "PBFile",
          "package": "toysolver",
          "source": "src/Text-PBFile.html",
          "type": "module"
        },
        "index": {
          "description": "parser library for opb file and wbo files used by PB Competition References Input Output Format and Solver Requirements for the Competitions of Pseudo-Boolean Solvers http www.cril.univ-artois.fr PB11 format.pdf",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "PBFile",
          "package": "toysolver",
          "partial": "PBFile",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLhs, relational operator and rhs.\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "Constraint",
          "package": "toysolver",
          "source": "src/Text-PBFile.html#Constraint",
          "type": "type"
        },
        "index": {
          "description": "Lhs relational operator and rhs",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "Constraint",
          "package": "toysolver",
          "partial": "Constraint",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:Constraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePair of \u003cem\u003eobjective function\u003c/em\u003e and a list of constraints.\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "Formula",
          "package": "toysolver",
          "source": "src/Text-PBFile.html#Formula",
          "type": "type"
        },
        "index": {
          "description": "Pair of objective function and list of constraints",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "Formula",
          "package": "toysolver",
          "partial": "Formula",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:Formula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePositive (resp. negative) literal is represented as a positive (resp. negative) integer.\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "Lit",
          "package": "toysolver",
          "source": "src/Text-PBFile.html#Lit",
          "type": "type"
        },
        "index": {
          "description": "Positive resp negative literal is represented as positive resp negative integer",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "Lit",
          "package": "toysolver",
          "partial": "Lit",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRelational operators\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "Op",
          "package": "toysolver",
          "source": "src/Text-PBFile.html#Op",
          "type": "data"
        },
        "index": {
          "description": "Relational operators",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "Op",
          "package": "toysolver",
          "partial": "Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:Op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pair of weight and constraint.\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "SoftConstraint",
          "package": "toysolver",
          "source": "src/Text-PBFile.html#SoftConstraint",
          "type": "type"
        },
        "index": {
          "description": "pair of weight and constraint",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "SoftConstraint",
          "package": "toysolver",
          "partial": "Soft Constraint",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:SoftConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pair of \u003cem\u003etop cost\u003c/em\u003e and a list of soft constraints.\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "SoftFormula",
          "package": "toysolver",
          "source": "src/Text-PBFile.html#SoftFormula",
          "type": "type"
        },
        "index": {
          "description": "pair of top cost and list of soft constraints",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "SoftFormula",
          "package": "toysolver",
          "partial": "Soft Formula",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:SoftFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum of \u003ccode\u003e\u003ca\u003eWeightedTerm\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "Sum",
          "package": "toysolver",
          "source": "src/Text-PBFile.html#Sum",
          "type": "type"
        },
        "index": {
          "description": "Sum of WeightedTerm",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "Sum",
          "package": "toysolver",
          "partial": "Sum",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:Sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of variables interpreted as products\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "Term",
          "package": "toysolver",
          "source": "src/Text-PBFile.html#Term",
          "type": "type"
        },
        "index": {
          "description": "List of variables interpreted as products",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "Term",
          "package": "toysolver",
          "partial": "Term",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariable are repserented positive integer.\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "Var",
          "package": "toysolver",
          "source": "src/Text-PBFile.html#Var",
          "type": "type"
        },
        "index": {
          "description": "Variable are repserented positive integer",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "Var",
          "package": "toysolver",
          "partial": "Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCoefficient and \u003ccode\u003e\u003ca\u003eTerm\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "WeightedTerm",
          "package": "toysolver",
          "source": "src/Text-PBFile.html#WeightedTerm",
          "type": "type"
        },
        "index": {
          "description": "Coefficient and Term",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "WeightedTerm",
          "package": "toysolver",
          "partial": "Weighted Term",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:WeightedTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eequal\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "Eq",
          "package": "toysolver",
          "signature": "Eq",
          "source": "src/Text-PBFile.html#Op",
          "type": "function"
        },
        "index": {
          "description": "equal",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "Eq",
          "package": "toysolver",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:Eq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003egreater than or equal\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "Ge",
          "package": "toysolver",
          "signature": "Ge",
          "source": "src/Text-PBFile.html#Op",
          "type": "function"
        },
        "index": {
          "description": "greater than or equal",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "Ge",
          "package": "toysolver",
          "partial": "Ge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:Ge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a .opb format string containing pseudo boolean problem.\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "parseOPBFile",
          "package": "toysolver",
          "signature": "FilePath -\u003e IO (Either ParseError Formula)",
          "source": "src/Text-PBFile.html#parseOPBFile",
          "type": "function"
        },
        "index": {
          "description": "Parse opb format string containing pseudo boolean problem",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "parseOPBFile",
          "normalized": "FilePath-\u003eIO(Either ParseError Formula)",
          "package": "toysolver",
          "partial": "OPBFile",
          "signature": "FilePath-\u003eIO(Either ParseError Formula)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:parseOPBFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a .opb file containing pseudo boolean problem.\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "parseOPBString",
          "package": "toysolver",
          "signature": "SourceName -\u003e String -\u003e Either ParseError Formula",
          "source": "src/Text-PBFile.html#parseOPBString",
          "type": "function"
        },
        "index": {
          "description": "Parse opb file containing pseudo boolean problem",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "parseOPBString",
          "normalized": "SourceName-\u003eString-\u003eEither ParseError Formula",
          "package": "toysolver",
          "partial": "OPBString",
          "signature": "SourceName-\u003eString-\u003eEither ParseError Formula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:parseOPBString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a .wbo format string containing weighted boolean optimization problem.\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "parseWBOFile",
          "package": "toysolver",
          "signature": "FilePath -\u003e IO (Either ParseError SoftFormula)",
          "source": "src/Text-PBFile.html#parseWBOFile",
          "type": "function"
        },
        "index": {
          "description": "Parse wbo format string containing weighted boolean optimization problem",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "parseWBOFile",
          "normalized": "FilePath-\u003eIO(Either ParseError SoftFormula)",
          "package": "toysolver",
          "partial": "WBOFile",
          "signature": "FilePath-\u003eIO(Either ParseError SoftFormula)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:parseWBOFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a .wbo file containing weighted boolean optimization problem.\n\u003c/p\u003e",
          "module": "Text.PBFile",
          "name": "parseWBOString",
          "package": "toysolver",
          "signature": "SourceName -\u003e String -\u003e Either ParseError SoftFormula",
          "source": "src/Text-PBFile.html#parseWBOString",
          "type": "function"
        },
        "index": {
          "description": "Parse wbo file containing weighted boolean optimization problem",
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "parseWBOString",
          "normalized": "SourceName-\u003eString-\u003eEither ParseError SoftFormula",
          "package": "toysolver",
          "partial": "WBOString",
          "signature": "SourceName-\u003eString-\u003eEither ParseError SoftFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:parseWBOString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PBFile",
          "name": "pbNumVars",
          "package": "toysolver",
          "signature": "Formula -\u003e Int",
          "source": "src/Text-PBFile.html#pbNumVars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "pbNumVars",
          "normalized": "Formula-\u003eInt",
          "package": "toysolver",
          "partial": "Num Vars",
          "signature": "Formula-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:pbNumVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PBFile",
          "name": "showOPB",
          "package": "toysolver",
          "signature": "Formula -\u003e ShowS",
          "source": "src/Text-PBFile.html#showOPB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "showOPB",
          "normalized": "Formula-\u003eShowS",
          "package": "toysolver",
          "partial": "OPB",
          "signature": "Formula-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:showOPB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PBFile",
          "name": "showWBO",
          "package": "toysolver",
          "signature": "SoftFormula -\u003e ShowS",
          "source": "src/Text-PBFile.html#showWBO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "showWBO",
          "normalized": "SoftFormula-\u003eShowS",
          "package": "toysolver",
          "partial": "WBO",
          "signature": "SoftFormula-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:showWBO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PBFile",
          "name": "wboNumVars",
          "package": "toysolver",
          "signature": "SoftFormula -\u003e Int",
          "source": "src/Text-PBFile.html#wboNumVars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PBFile",
          "module": "Text.PBFile",
          "name": "wboNumVars",
          "normalized": "SoftFormula-\u003eInt",
          "package": "toysolver",
          "partial": "Num Vars",
          "signature": "SoftFormula-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:wboNumVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e SDPA (Semidefinite Programming Algorithm) User's Manual\n   \u003ca\u003ehttp://sdpa.indsys.chuo-u.ac.jp/~fujisawa/sdpa_doc.pdf\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://euler.nmt.edu/~brian/sdplib/FORMAT\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Text.SDPFile",
          "name": "SDPFile",
          "package": "toysolver",
          "source": "src/Text-SDPFile.html",
          "type": "module"
        },
        "index": {
          "description": "References SDPA Semidefinite Programming Algorithm User Manual http sdpa.indsys.chuo-u.ac.jp fujisawa sdpa doc.pdf http euler.nmt.edu brian sdplib FORMAT",
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "SDPFile",
          "package": "toysolver",
          "partial": "SDPFile",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.SDPFile",
          "name": "Block",
          "package": "toysolver",
          "source": "src/Text-SDPFile.html#Block",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "Block",
          "package": "toysolver",
          "partial": "Block",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#t:Block"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.SDPFile",
          "name": "DenseBlock",
          "package": "toysolver",
          "source": "src/Text-SDPFile.html#DenseBlock",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "DenseBlock",
          "package": "toysolver",
          "partial": "Dense Block",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#t:DenseBlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.SDPFile",
          "name": "DenseMatrix",
          "package": "toysolver",
          "source": "src/Text-SDPFile.html#DenseMatrix",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "DenseMatrix",
          "package": "toysolver",
          "partial": "Dense Matrix",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#t:DenseMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.SDPFile",
          "name": "Matrix",
          "package": "toysolver",
          "source": "src/Text-SDPFile.html#Matrix",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "Matrix",
          "package": "toysolver",
          "partial": "Matrix",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#t:Matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.SDPFile",
          "name": "Problem",
          "package": "toysolver",
          "source": "src/Text-SDPFile.html#Problem",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "Problem",
          "package": "toysolver",
          "partial": "Problem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#t:Problem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.SDPFile",
          "name": "Problem",
          "package": "toysolver",
          "signature": "Problem",
          "source": "src/Text-SDPFile.html#Problem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "Problem",
          "package": "toysolver",
          "partial": "Problem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:Problem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.SDPFile",
          "name": "blockElem",
          "package": "toysolver",
          "signature": "Int -\u003e Int -\u003e Block -\u003e Rational",
          "source": "src/Text-SDPFile.html#blockElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "blockElem",
          "normalized": "Int-\u003eInt-\u003eBlock-\u003eRational",
          "package": "toysolver",
          "partial": "Elem",
          "signature": "Int-\u003eInt-\u003eBlock-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:blockElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe block strcuture vector (bLOCKsTRUCT)\n\u003c/p\u003e",
          "module": "Text.SDPFile",
          "name": "blockStruct",
          "package": "toysolver",
          "signature": "[Int]",
          "source": "src/Text-SDPFile.html#Problem",
          "type": "function"
        },
        "index": {
          "description": "the block strcuture vector bLOCKsTRUCT",
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "blockStruct",
          "normalized": "[Int]",
          "package": "toysolver",
          "partial": "Struct",
          "signature": "[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:blockStruct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstant Vector\n\u003c/p\u003e",
          "module": "Text.SDPFile",
          "name": "costs",
          "package": "toysolver",
          "signature": "[Rational]",
          "source": "src/Text-SDPFile.html#Problem",
          "type": "function"
        },
        "index": {
          "description": "Constant Vector",
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "costs",
          "normalized": "[Rational]",
          "package": "toysolver",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:costs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.SDPFile",
          "name": "denseBlock",
          "package": "toysolver",
          "signature": "DenseBlock -\u003e Block",
          "source": "src/Text-SDPFile.html#denseBlock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "denseBlock",
          "normalized": "DenseBlock-\u003eBlock",
          "package": "toysolver",
          "partial": "Block",
          "signature": "DenseBlock-\u003eBlock",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:denseBlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.SDPFile",
          "name": "denseMatrix",
          "package": "toysolver",
          "signature": "DenseMatrix -\u003e Matrix",
          "source": "src/Text-SDPFile.html#denseMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "denseMatrix",
          "normalized": "DenseMatrix-\u003eMatrix",
          "package": "toysolver",
          "partial": "Matrix",
          "signature": "DenseMatrix-\u003eMatrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:denseMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.SDPFile",
          "name": "diagBlock",
          "package": "toysolver",
          "signature": "[Rational] -\u003e Block",
          "source": "src/Text-SDPFile.html#diagBlock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "diagBlock",
          "normalized": "[Rational]-\u003eBlock",
          "package": "toysolver",
          "partial": "Block",
          "signature": "[Rational]-\u003eBlock",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:diagBlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe number of primal variables (mDim)\n\u003c/p\u003e",
          "module": "Text.SDPFile",
          "name": "mDim",
          "package": "toysolver",
          "signature": "Problem -\u003e Int",
          "source": "src/Text-SDPFile.html#mDim",
          "type": "function"
        },
        "index": {
          "description": "the number of primal variables mDim",
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "mDim",
          "normalized": "Problem-\u003eInt",
          "package": "toysolver",
          "partial": "Dim",
          "signature": "Problem-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:mDim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstraint Matrices\n\u003c/p\u003e",
          "module": "Text.SDPFile",
          "name": "matrices",
          "package": "toysolver",
          "signature": "[Matrix]",
          "source": "src/Text-SDPFile.html#Problem",
          "type": "function"
        },
        "index": {
          "description": "Constraint Matrices",
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "matrices",
          "normalized": "[Matrix]",
          "package": "toysolver",
          "signature": "[Matrix]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:matrices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe number of blocks (nBLOCK)\n\u003c/p\u003e",
          "module": "Text.SDPFile",
          "name": "nBlock",
          "package": "toysolver",
          "signature": "Problem -\u003e Int",
          "source": "src/Text-SDPFile.html#nBlock",
          "type": "function"
        },
        "index": {
          "description": "the number of blocks nBLOCK",
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "nBlock",
          "normalized": "Problem-\u003eInt",
          "package": "toysolver",
          "partial": "Block",
          "signature": "Problem-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:nBlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a SDPA format file (.dat).\n\u003c/p\u003e",
          "module": "Text.SDPFile",
          "name": "parseDataFile",
          "package": "toysolver",
          "signature": "FilePath -\u003e IO (Either ParseError Problem)",
          "source": "src/Text-SDPFile.html#parseDataFile",
          "type": "function"
        },
        "index": {
          "description": "Parse SDPA format file dat",
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "parseDataFile",
          "normalized": "FilePath-\u003eIO(Either ParseError Problem)",
          "package": "toysolver",
          "partial": "Data File",
          "signature": "FilePath-\u003eIO(Either ParseError Problem)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:parseDataFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a SDPA format (.dat) string.\n\u003c/p\u003e",
          "module": "Text.SDPFile",
          "name": "parseDataString",
          "package": "toysolver",
          "signature": "SourceName -\u003e String -\u003e Either ParseError Problem",
          "source": "src/Text-SDPFile.html#parseDataString",
          "type": "function"
        },
        "index": {
          "description": "Parse SDPA format dat string",
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "parseDataString",
          "normalized": "SourceName-\u003eString-\u003eEither ParseError Problem",
          "package": "toysolver",
          "partial": "Data String",
          "signature": "SourceName-\u003eString-\u003eEither ParseError Problem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:parseDataString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a SDPA sparse format file (.dat-s).\n\u003c/p\u003e",
          "module": "Text.SDPFile",
          "name": "parseSparseDataFile",
          "package": "toysolver",
          "signature": "FilePath -\u003e IO (Either ParseError Problem)",
          "source": "src/Text-SDPFile.html#parseSparseDataFile",
          "type": "function"
        },
        "index": {
          "description": "Parse SDPA sparse format file dat-s",
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "parseSparseDataFile",
          "normalized": "FilePath-\u003eIO(Either ParseError Problem)",
          "package": "toysolver",
          "partial": "Sparse Data File",
          "signature": "FilePath-\u003eIO(Either ParseError Problem)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:parseSparseDataFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a SDPA sparse format (.dat-s) string.\n\u003c/p\u003e",
          "module": "Text.SDPFile",
          "name": "parseSparseDataString",
          "package": "toysolver",
          "signature": "SourceName -\u003e String -\u003e Either ParseError Problem",
          "source": "src/Text-SDPFile.html#parseSparseDataString",
          "type": "function"
        },
        "index": {
          "description": "Parse SDPA sparse format dat-s string",
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "parseSparseDataString",
          "normalized": "SourceName-\u003eString-\u003eEither ParseError Problem",
          "package": "toysolver",
          "partial": "Sparse Data String",
          "signature": "SourceName-\u003eString-\u003eEither ParseError Problem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:parseSparseDataString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.SDPFile",
          "name": "render",
          "package": "toysolver",
          "signature": "Problem -\u003e ShowS",
          "source": "src/Text-SDPFile.html#render",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "render",
          "normalized": "Problem-\u003eShowS",
          "package": "toysolver",
          "signature": "Problem-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:render"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.SDPFile",
          "name": "renderSparse",
          "package": "toysolver",
          "signature": "Problem -\u003e ShowS",
          "source": "src/Text-SDPFile.html#renderSparse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text SDPFile",
          "module": "Text.SDPFile",
          "name": "renderSparse",
          "normalized": "Problem-\u003eShowS",
          "package": "toysolver",
          "partial": "Sparse",
          "signature": "Problem-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:renderSparse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSome utility functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util",
          "name": "Util",
          "package": "toysolver",
          "source": "src/Util.html",
          "type": "module"
        },
        "index": {
          "description": "Some utility functions",
          "hierarchy": "Util",
          "module": "Util",
          "name": "Util",
          "package": "toysolver",
          "partial": "Util",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombining two \u003ccode\u003eMaybe\u003c/code\u003e values using given function.\n\u003c/p\u003e",
          "module": "Util",
          "name": "combineMaybe",
          "package": "toysolver",
          "signature": "(a -\u003e a -\u003e a) -\u003e Maybe a -\u003e Maybe a -\u003e Maybe a",
          "source": "src/Util.html#combineMaybe",
          "type": "function"
        },
        "index": {
          "description": "Combining two Maybe values using given function",
          "hierarchy": "Util",
          "module": "Util",
          "name": "combineMaybe",
          "normalized": "(a-\u003ea-\u003ea)-\u003eMaybe a-\u003eMaybe a-\u003eMaybe a",
          "package": "toysolver",
          "partial": "Maybe",
          "signature": "(a-\u003ea-\u003ea)-\u003eMaybe a-\u003eMaybe a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:combineMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efractional part\n\u003c/p\u003e\u003cpre\u003e\n   fracPart x = x - fromInteger (floor x)\n\u003c/pre\u003e",
          "module": "Util",
          "name": "fracPart",
          "package": "toysolver",
          "signature": "a -\u003e a",
          "source": "src/Util.html#fracPart",
          "type": "function"
        },
        "index": {
          "description": "fractional part fracPart fromInteger floor",
          "hierarchy": "Util",
          "module": "Util",
          "name": "fracPart",
          "normalized": "a-\u003ea",
          "package": "toysolver",
          "partial": "Part",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:fracPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eis the number integral?\n\u003c/p\u003e\u003cpre\u003e\n    isInteger x = fromInteger (round x) == x\n\u003c/pre\u003e",
          "module": "Util",
          "name": "isInteger",
          "package": "toysolver",
          "signature": "a -\u003e Bool",
          "source": "src/Util.html#isInteger",
          "type": "function"
        },
        "index": {
          "description": "is the number integral isInteger fromInteger round",
          "hierarchy": "Util",
          "module": "Util",
          "name": "isInteger",
          "normalized": "a-\u003eBool",
          "package": "toysolver",
          "partial": "Integer",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:isInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util",
          "name": "revForM",
          "package": "toysolver",
          "signature": "[a] -\u003e (a -\u003e m b) -\u003e m [b]",
          "source": "src/Util.html#revForM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util",
          "module": "Util",
          "name": "revForM",
          "normalized": "[a]-\u003e(a-\u003eb c)-\u003eb[c]",
          "package": "toysolver",
          "partial": "For",
          "signature": "[a]-\u003e(a-\u003em b)-\u003em[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:revForM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util",
          "name": "revMapM",
          "package": "toysolver",
          "signature": "(a -\u003e m b) -\u003e [a] -\u003e m [b]",
          "source": "src/Util.html#revMapM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util",
          "module": "Util",
          "name": "revMapM",
          "normalized": "(a-\u003eb c)-\u003e[a]-\u003eb[c]",
          "package": "toysolver",
          "partial": "Map",
          "signature": "(a-\u003em b)-\u003e[a]-\u003em[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:revMapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util",
          "name": "revSequence",
          "package": "toysolver",
          "signature": "[m a] -\u003e m [a]",
          "source": "src/Util.html#revSequence",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util",
          "module": "Util",
          "name": "revSequence",
          "normalized": "[a b]-\u003ea[b]",
          "package": "toysolver",
          "partial": "Sequence",
          "signature": "[m a]-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:revSequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util",
          "name": "showRational",
          "package": "toysolver",
          "signature": "Bool -\u003e Rational -\u003e String",
          "source": "src/Util.html#showRational",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util",
          "module": "Util",
          "name": "showRational",
          "normalized": "Bool-\u003eRational-\u003eString",
          "package": "toysolver",
          "partial": "Rational",
          "signature": "Bool-\u003eRational-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:showRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util",
          "name": "showRationalAsFiniteDecimal",
          "package": "toysolver",
          "signature": "Rational -\u003e Maybe String",
          "source": "src/Util.html#showRationalAsFiniteDecimal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util",
          "module": "Util",
          "name": "showRationalAsFiniteDecimal",
          "normalized": "Rational-\u003eMaybe String",
          "package": "toysolver",
          "partial": "Rational As Finite Decimal",
          "signature": "Rational-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:showRationalAsFiniteDecimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Version",
          "name": "Version",
          "package": "toysolver",
          "source": "src/Version.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Version",
          "module": "Version",
          "name": "Version",
          "package": "toysolver",
          "partial": "Version",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Version.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Version",
          "name": "packageVersions",
          "package": "toysolver",
          "signature": "[(String, String)]",
          "source": "src/Version.html#packageVersions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Version",
          "module": "Version",
          "name": "packageVersions",
          "normalized": "[(String,String)]",
          "package": "toysolver",
          "partial": "Versions",
          "signature": "[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Version.html#v:packageVersions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Version",
          "name": "version",
          "package": "toysolver",
          "signature": "Version",
          "source": "src/Paths_toysolver.html#version",
          "type": "function"
        },
        "index": {
          "hierarchy": "Version",
          "module": "Version",
          "name": "version",
          "package": "toysolver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/toysolver/docs/Version.html#v:version"
      }
    }
  ]
]