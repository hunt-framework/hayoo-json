[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "HaskellForMaths"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "Base",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "Base",
          "package": "HaskellForMaths",
          "partial": "Base",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F11",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F11",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F11",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F13",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F13",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F13",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F13"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F17",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F17",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F17",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F17"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F19",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F19",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F19",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F19"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF2 is a type for the finite field with 2 elements\n\u003c/p\u003e",
          "module": "Math.Algebra.Field.Base",
          "name": "F2",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F2",
          "type": "type"
        },
        "index": {
          "description": "F2 is type for the finite field with elements",
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F2",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F23",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F23",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F23",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F23"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F29",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F29",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F29",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F29"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF3 is a type for the finite field with 3 elements\n\u003c/p\u003e",
          "module": "Math.Algebra.Field.Base",
          "name": "F3",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F3",
          "type": "type"
        },
        "index": {
          "description": "F3 is type for the finite field with elements",
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F3",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F31",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F31",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F31",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F31"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F37",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F37",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F37",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F37"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F41",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F41",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F41",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F41"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F43",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F43",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F43",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F43"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F47",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F47",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F47",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F47"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF5 is a type for the finite field with 5 elements\n\u003c/p\u003e",
          "module": "Math.Algebra.Field.Base",
          "name": "F5",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F5",
          "type": "type"
        },
        "index": {
          "description": "F5 is type for the finite field with elements",
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F5",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F53",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F53",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F53",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F53"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F59",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F59",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F59",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F59"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F61",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F61",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F61",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F61"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F67",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F67",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F67",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F67"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF7 is a type for the finite field with 7 elements\n\u003c/p\u003e",
          "module": "Math.Algebra.Field.Base",
          "name": "F7",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F7",
          "type": "type"
        },
        "index": {
          "description": "F7 is type for the finite field with elements",
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F7",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F71",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F71",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F71",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F71"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F73",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F73",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F73",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F73"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F79",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F79",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F79",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F79"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F83",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F83",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F83",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F83"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F89",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F89",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F89",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F89"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "F97",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#F97",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "F97",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:F97"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "FiniteField",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#FiniteField",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "FiniteField",
          "package": "HaskellForMaths",
          "partial": "Finite Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:FiniteField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "Fp",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#Fp",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "Fp",
          "package": "HaskellForMaths",
          "partial": "Fp",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:Fp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQ is just the rationals, but with a better show function than the Prelude version\n\u003c/p\u003e",
          "module": "Math.Algebra.Field.Base",
          "name": "Q",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Base.html#Q",
          "type": "newtype"
        },
        "index": {
          "description": "is just the rationals but with better show function than the Prelude version",
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "Q",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#t:Q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "Fp",
          "package": "HaskellForMaths",
          "signature": "Fp Integer",
          "source": "src/Math-Algebra-Field-Base.html#Fp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "Fp",
          "package": "HaskellForMaths",
          "partial": "Fp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:Fp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "Q",
          "package": "HaskellForMaths",
          "signature": "Q Rational",
          "source": "src/Math-Algebra-Field-Base.html#Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "Q",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:Q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "basisFq",
          "package": "HaskellForMaths",
          "signature": "fq -\u003e [fq]",
          "source": "src/Math-Algebra-Field-Base.html#basisFq",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "basisFq",
          "normalized": "a-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Fq",
          "signature": "fq-\u003e[fq]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:basisFq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "char",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Int",
          "source": "src/Math-Algebra-Field-Base.html#char",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "char",
          "normalized": "[a]-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "denominatorQ",
          "package": "HaskellForMaths",
          "signature": "Q -\u003e Integer",
          "source": "src/Math-Algebra-Field-Base.html#denominatorQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "denominatorQ",
          "normalized": "Q-\u003eInteger",
          "package": "HaskellForMaths",
          "signature": "Q-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:denominatorQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "eltsFq",
          "package": "HaskellForMaths",
          "signature": "fq -\u003e [fq]",
          "source": "src/Math-Algebra-Field-Base.html#eltsFq",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "eltsFq",
          "normalized": "a-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Fq",
          "signature": "fq-\u003e[fq]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:eltsFq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "extendedEuclid",
          "package": "HaskellForMaths",
          "signature": "t -\u003e t -\u003e (t, t, t)",
          "source": "src/Math-Algebra-Field-Base.html#extendedEuclid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "extendedEuclid",
          "normalized": "a-\u003ea-\u003e(a,a,a)",
          "package": "HaskellForMaths",
          "partial": "Euclid",
          "signature": "t-\u003et-\u003e(t,t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:extendedEuclid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f11",
          "package": "HaskellForMaths",
          "signature": "[F11]",
          "source": "src/Math-Algebra-Field-Base.html#f11",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f11",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f13",
          "package": "HaskellForMaths",
          "signature": "[F13]",
          "source": "src/Math-Algebra-Field-Base.html#f13",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f13",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f13"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f17",
          "package": "HaskellForMaths",
          "signature": "[F17]",
          "source": "src/Math-Algebra-Field-Base.html#f17",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f17",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f17"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f19",
          "package": "HaskellForMaths",
          "signature": "[F19]",
          "source": "src/Math-Algebra-Field-Base.html#f19",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f19",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f19"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef2 lists the elements of F2\n\u003c/p\u003e",
          "module": "Math.Algebra.Field.Base",
          "name": "f2",
          "package": "HaskellForMaths",
          "signature": "[F2]",
          "source": "src/Math-Algebra-Field-Base.html#f2",
          "type": "function"
        },
        "index": {
          "description": "f2 lists the elements of F2",
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f2",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f23",
          "package": "HaskellForMaths",
          "signature": "[F23]",
          "source": "src/Math-Algebra-Field-Base.html#f23",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f23",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f23"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f29",
          "package": "HaskellForMaths",
          "signature": "[F29]",
          "source": "src/Math-Algebra-Field-Base.html#f29",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f29",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f29"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef3 lists the elements of F3\n\u003c/p\u003e",
          "module": "Math.Algebra.Field.Base",
          "name": "f3",
          "package": "HaskellForMaths",
          "signature": "[F3]",
          "source": "src/Math-Algebra-Field-Base.html#f3",
          "type": "function"
        },
        "index": {
          "description": "f3 lists the elements of F3",
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f3",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f31",
          "package": "HaskellForMaths",
          "signature": "[F31]",
          "source": "src/Math-Algebra-Field-Base.html#f31",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f31",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f31"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f37",
          "package": "HaskellForMaths",
          "signature": "[F37]",
          "source": "src/Math-Algebra-Field-Base.html#f37",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f37",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f37"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f41",
          "package": "HaskellForMaths",
          "signature": "[F41]",
          "source": "src/Math-Algebra-Field-Base.html#f41",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f41",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f41"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f43",
          "package": "HaskellForMaths",
          "signature": "[F43]",
          "source": "src/Math-Algebra-Field-Base.html#f43",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f43",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f43"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f47",
          "package": "HaskellForMaths",
          "signature": "[F47]",
          "source": "src/Math-Algebra-Field-Base.html#f47",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f47",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f47"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef5 lists the elements of F5\n\u003c/p\u003e",
          "module": "Math.Algebra.Field.Base",
          "name": "f5",
          "package": "HaskellForMaths",
          "signature": "[F5]",
          "source": "src/Math-Algebra-Field-Base.html#f5",
          "type": "function"
        },
        "index": {
          "description": "f5 lists the elements of F5",
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f5",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f53",
          "package": "HaskellForMaths",
          "signature": "[F53]",
          "source": "src/Math-Algebra-Field-Base.html#f53",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f53",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f53"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f59",
          "package": "HaskellForMaths",
          "signature": "[F59]",
          "source": "src/Math-Algebra-Field-Base.html#f59",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f59",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f59"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f61",
          "package": "HaskellForMaths",
          "signature": "[F61]",
          "source": "src/Math-Algebra-Field-Base.html#f61",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f61",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f61"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f67",
          "package": "HaskellForMaths",
          "signature": "[F67]",
          "source": "src/Math-Algebra-Field-Base.html#f67",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f67",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f67"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef7 lists the elements of F7\n\u003c/p\u003e",
          "module": "Math.Algebra.Field.Base",
          "name": "f7",
          "package": "HaskellForMaths",
          "signature": "[F7]",
          "source": "src/Math-Algebra-Field-Base.html#f7",
          "type": "function"
        },
        "index": {
          "description": "f7 lists the elements of F7",
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f7",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f71",
          "package": "HaskellForMaths",
          "signature": "[F71]",
          "source": "src/Math-Algebra-Field-Base.html#f71",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f71",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f71"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f73",
          "package": "HaskellForMaths",
          "signature": "[F73]",
          "source": "src/Math-Algebra-Field-Base.html#f73",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f73",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f73"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f79",
          "package": "HaskellForMaths",
          "signature": "[F79]",
          "source": "src/Math-Algebra-Field-Base.html#f79",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f79",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f79"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f83",
          "package": "HaskellForMaths",
          "signature": "[F83]",
          "source": "src/Math-Algebra-Field-Base.html#f83",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f83",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f83"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f89",
          "package": "HaskellForMaths",
          "signature": "[F89]",
          "source": "src/Math-Algebra-Field-Base.html#f89",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f89",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f89"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "f97",
          "package": "HaskellForMaths",
          "signature": "[F97]",
          "source": "src/Math-Algebra-Field-Base.html#f97",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "f97",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:f97"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "numeratorQ",
          "package": "HaskellForMaths",
          "signature": "Q -\u003e Integer",
          "source": "src/Math-Algebra-Field-Base.html#numeratorQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "numeratorQ",
          "normalized": "Q-\u003eInteger",
          "package": "HaskellForMaths",
          "signature": "Q-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:numeratorQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "powers",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [a]",
          "source": "src/Math-Algebra-Field-Base.html#powers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "powers",
          "normalized": "a-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:powers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Base",
          "name": "primitiveElt",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e a",
          "source": "src/Math-Algebra-Field-Base.html#primitiveElt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Base",
          "module": "Math.Algebra.Field.Base",
          "name": "primitiveElt",
          "normalized": "[a]-\u003ea",
          "package": "HaskellForMaths",
          "partial": "Elt",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Base.html#v:primitiveElt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "Extension",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "Extension",
          "package": "HaskellForMaths",
          "partial": "Extension",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "ConwayF16",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#ConwayF16",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "ConwayF16",
          "package": "HaskellForMaths",
          "partial": "Conway",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:ConwayF16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "ConwayF25",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#ConwayF25",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "ConwayF25",
          "package": "HaskellForMaths",
          "partial": "Conway",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:ConwayF25"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "ConwayF27",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#ConwayF27",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "ConwayF27",
          "package": "HaskellForMaths",
          "partial": "Conway",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:ConwayF27"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "ConwayF32",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#ConwayF32",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "ConwayF32",
          "package": "HaskellForMaths",
          "partial": "Conway",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:ConwayF32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "ConwayF4",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#ConwayF4",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "ConwayF4",
          "package": "HaskellForMaths",
          "partial": "Conway",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:ConwayF4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "ConwayF8",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#ConwayF8",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "ConwayF8",
          "package": "HaskellForMaths",
          "partial": "Conway",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:ConwayF8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "ConwayF9",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#ConwayF9",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "ConwayF9",
          "package": "HaskellForMaths",
          "partial": "Conway",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:ConwayF9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "ExtensionField",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#ExtensionField",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "ExtensionField",
          "package": "HaskellForMaths",
          "partial": "Extension Field",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:ExtensionField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "F16",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#F16",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "F16",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:F16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "F25",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#F25",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "F25",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:F25"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "F27",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#F27",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "F27",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:F27"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "F32",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#F32",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "F32",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:F32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "F4",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#F4",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "F4",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:F4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "F8",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#F8",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "F8",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:F8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "F9",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#F9",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "F9",
          "package": "HaskellForMaths",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:F9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "PolynomialAsType",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#PolynomialAsType",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "PolynomialAsType",
          "package": "HaskellForMaths",
          "partial": "Polynomial As Type",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:PolynomialAsType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrt2",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#QSqrt2",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrt2",
          "package": "HaskellForMaths",
          "partial": "QSqrt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:QSqrt2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrt3",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#QSqrt3",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrt3",
          "package": "HaskellForMaths",
          "partial": "QSqrt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:QSqrt3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrt5",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#QSqrt5",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrt5",
          "package": "HaskellForMaths",
          "partial": "QSqrt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:QSqrt5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrt7",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#QSqrt7",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrt7",
          "package": "HaskellForMaths",
          "partial": "QSqrt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:QSqrt7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrtMinus1",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#QSqrtMinus1",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrtMinus1",
          "package": "HaskellForMaths",
          "partial": "QSqrt Minus",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:QSqrtMinus1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrtMinus2",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#QSqrtMinus2",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrtMinus2",
          "package": "HaskellForMaths",
          "partial": "QSqrt Minus",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:QSqrtMinus2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrtMinus3",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#QSqrtMinus3",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrtMinus3",
          "package": "HaskellForMaths",
          "partial": "QSqrt Minus",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:QSqrtMinus3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrtMinus5",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#QSqrtMinus5",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "QSqrtMinus5",
          "package": "HaskellForMaths",
          "partial": "QSqrt Minus",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:QSqrtMinus5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "Sqrt",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#Sqrt",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "Sqrt",
          "package": "HaskellForMaths",
          "partial": "Sqrt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:Sqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "UPoly",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Field-Extension.html#UPoly",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "UPoly",
          "package": "HaskellForMaths",
          "partial": "UPoly",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#t:UPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "(/\u003e)",
          "package": "HaskellForMaths",
          "signature": "t -\u003e UPoly t -\u003e UPoly t",
          "source": "src/Math-Algebra-Field-Extension.html#%2F%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "(/\u003e) /\u003e",
          "normalized": "a-\u003eUPoly a-\u003eUPoly a",
          "package": "HaskellForMaths",
          "signature": "t-\u003eUPoly t-\u003eUPoly t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:-47--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "(\u003c*\u003e)",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Algebra-Field-Extension.html#%3C%2A%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "(\u003c*\u003e) \u003c*\u003e",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:-60--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "(\u003c+\u003e)",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Algebra-Field-Extension.html#%3C%2B%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "Ext",
          "package": "HaskellForMaths",
          "signature": "Ext (UPoly k)",
          "source": "src/Math-Algebra-Field-Extension.html#ExtensionField",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "Ext",
          "package": "HaskellForMaths",
          "partial": "Ext",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:Ext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "Sqrt",
          "package": "HaskellForMaths",
          "signature": "Sqrt a",
          "source": "src/Math-Algebra-Field-Extension.html#Sqrt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "Sqrt",
          "package": "HaskellForMaths",
          "partial": "Sqrt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:Sqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "UP",
          "package": "HaskellForMaths",
          "signature": "UP [a]",
          "source": "src/Math-Algebra-Field-Extension.html#UPoly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "UP",
          "normalized": "UP[a]",
          "package": "HaskellForMaths",
          "partial": "UP",
          "signature": "UP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:UP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "a16",
          "package": "HaskellForMaths",
          "signature": "F16",
          "source": "src/Math-Algebra-Field-Extension.html#a16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "a16",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:a16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "a25",
          "package": "HaskellForMaths",
          "signature": "F25",
          "source": "src/Math-Algebra-Field-Extension.html#a25",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "a25",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:a25"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "a27",
          "package": "HaskellForMaths",
          "signature": "F27",
          "source": "src/Math-Algebra-Field-Extension.html#a27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "a27",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:a27"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "a32",
          "package": "HaskellForMaths",
          "signature": "F32",
          "source": "src/Math-Algebra-Field-Extension.html#a32",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "a32",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:a32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "a4",
          "package": "HaskellForMaths",
          "signature": "F4",
          "source": "src/Math-Algebra-Field-Extension.html#a4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "a4",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:a4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "a8",
          "package": "HaskellForMaths",
          "signature": "F8",
          "source": "src/Math-Algebra-Field-Extension.html#a8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "a8",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:a8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "a9",
          "package": "HaskellForMaths",
          "signature": "F9",
          "source": "src/Math-Algebra-Field-Extension.html#a9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "a9",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:a9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "conjugate",
          "package": "HaskellForMaths",
          "signature": "ExtensionField Q (Sqrt d) -\u003e ExtensionField Q (Sqrt d)",
          "source": "src/Math-Algebra-Field-Extension.html#conjugate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "conjugate",
          "normalized": "ExtensionField Q(Sqrt a)-\u003eExtensionField Q(Sqrt a)",
          "package": "HaskellForMaths",
          "signature": "ExtensionField Q(Sqrt d)-\u003eExtensionField Q(Sqrt d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:conjugate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "convert",
          "package": "HaskellForMaths",
          "signature": "UPoly Integer -\u003e UPoly a",
          "source": "src/Math-Algebra-Field-Extension.html#convert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "convert",
          "normalized": "UPoly Integer-\u003eUPoly a",
          "package": "HaskellForMaths",
          "signature": "UPoly Integer-\u003eUPoly a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "deg",
          "package": "HaskellForMaths",
          "signature": "UPoly a -\u003e Int",
          "source": "src/Math-Algebra-Field-Extension.html#deg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "deg",
          "normalized": "UPoly a-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "UPoly a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:deg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "degree",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Int",
          "source": "src/Math-Algebra-Field-Extension.html#degree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "degree",
          "normalized": "[a]-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:degree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "embed",
          "package": "HaskellForMaths",
          "signature": "UPoly Integer -\u003e ExtensionField k poly",
          "source": "src/Math-Algebra-Field-Extension.html#embed",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "embed",
          "normalized": "UPoly Integer-\u003eExtensionField a b",
          "package": "HaskellForMaths",
          "signature": "UPoly Integer-\u003eExtensionField k poly",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:embed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "extendedEuclidUP",
          "package": "HaskellForMaths",
          "signature": "UPoly k -\u003e UPoly k -\u003e (UPoly k, UPoly k, UPoly k)",
          "source": "src/Math-Algebra-Field-Extension.html#extendedEuclidUP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "extendedEuclidUP",
          "normalized": "UPoly a-\u003eUPoly a-\u003e(UPoly a,UPoly a,UPoly a)",
          "package": "HaskellForMaths",
          "partial": "Euclid UP",
          "signature": "UPoly k-\u003eUPoly k-\u003e(UPoly k,UPoly k,UPoly k)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:extendedEuclidUP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "f16",
          "package": "HaskellForMaths",
          "signature": "[F16]",
          "source": "src/Math-Algebra-Field-Extension.html#f16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "f16",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:f16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "f25",
          "package": "HaskellForMaths",
          "signature": "[F25]",
          "source": "src/Math-Algebra-Field-Extension.html#f25",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "f25",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:f25"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "f27",
          "package": "HaskellForMaths",
          "signature": "[F27]",
          "source": "src/Math-Algebra-Field-Extension.html#f27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "f27",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:f27"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "f32",
          "package": "HaskellForMaths",
          "signature": "[F32]",
          "source": "src/Math-Algebra-Field-Extension.html#f32",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "f32",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:f32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "f4",
          "package": "HaskellForMaths",
          "signature": "[F4]",
          "source": "src/Math-Algebra-Field-Extension.html#f4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "f4",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:f4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "f8",
          "package": "HaskellForMaths",
          "signature": "[F8]",
          "source": "src/Math-Algebra-Field-Extension.html#f8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "f8",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:f8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "f9",
          "package": "HaskellForMaths",
          "signature": "[F9]",
          "source": "src/Math-Algebra-Field-Extension.html#f9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "f9",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:f9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "frobeniusAut",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a",
          "source": "src/Math-Algebra-Field-Extension.html#frobeniusAut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "frobeniusAut",
          "normalized": "a-\u003ea",
          "package": "HaskellForMaths",
          "partial": "Aut",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:frobeniusAut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "i",
          "package": "HaskellForMaths",
          "signature": "QSqrtMinus1",
          "source": "src/Math-Algebra-Field-Extension.html#i",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "i",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:i"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "lt",
          "package": "HaskellForMaths",
          "signature": "UPoly a -\u003e a",
          "source": "src/Math-Algebra-Field-Extension.html#lt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "lt",
          "normalized": "UPoly a-\u003ea",
          "package": "HaskellForMaths",
          "signature": "UPoly a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:lt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "modUP",
          "package": "HaskellForMaths",
          "signature": "UPoly k -\u003e UPoly k -\u003e UPoly k",
          "source": "src/Math-Algebra-Field-Extension.html#modUP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "modUP",
          "normalized": "UPoly a-\u003eUPoly a-\u003eUPoly a",
          "package": "HaskellForMaths",
          "partial": "UP",
          "signature": "UPoly k-\u003eUPoly k-\u003eUPoly k",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:modUP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "monomial",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Int -\u003e UPoly a",
          "source": "src/Math-Algebra-Field-Extension.html#monomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "monomial",
          "normalized": "a-\u003eInt-\u003eUPoly a",
          "package": "HaskellForMaths",
          "signature": "a-\u003eInt-\u003eUPoly a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:monomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "polys",
          "package": "HaskellForMaths",
          "signature": "a1 -\u003e [a] -\u003e [UPoly a]",
          "source": "src/Math-Algebra-Field-Extension.html#polys",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "polys",
          "normalized": "a-\u003e[a]-\u003e[UPoly a]",
          "package": "HaskellForMaths",
          "signature": "a-\u003e[a]-\u003e[UPoly a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:polys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "pvalue",
          "package": "HaskellForMaths",
          "signature": "(k, poly) -\u003e UPoly k",
          "source": "src/Math-Algebra-Field-Extension.html#pvalue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "pvalue",
          "normalized": "(a,b)-\u003eUPoly a",
          "package": "HaskellForMaths",
          "signature": "(k,poly)-\u003eUPoly k",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:pvalue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "quotRemUP",
          "package": "HaskellForMaths",
          "signature": "UPoly k -\u003e UPoly k -\u003e (UPoly k, UPoly k)",
          "source": "src/Math-Algebra-Field-Extension.html#quotRemUP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "quotRemUP",
          "normalized": "UPoly a-\u003eUPoly a-\u003e(UPoly a,UPoly a)",
          "package": "HaskellForMaths",
          "partial": "Rem UP",
          "signature": "UPoly k-\u003eUPoly k-\u003e(UPoly k,UPoly k)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:quotRemUP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "showUP",
          "package": "HaskellForMaths",
          "signature": "[Char] -\u003e [a] -\u003e [Char]",
          "source": "src/Math-Algebra-Field-Extension.html#showUP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "showUP",
          "normalized": "[Char]-\u003e[a]-\u003e[Char]",
          "package": "HaskellForMaths",
          "partial": "UP",
          "signature": "[Char]-\u003e[a]-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:showUP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "sqrt2",
          "package": "HaskellForMaths",
          "signature": "QSqrt2",
          "source": "src/Math-Algebra-Field-Extension.html#sqrt2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "sqrt2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:sqrt2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "sqrt3",
          "package": "HaskellForMaths",
          "signature": "QSqrt3",
          "source": "src/Math-Algebra-Field-Extension.html#sqrt3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "sqrt3",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:sqrt3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "sqrt5",
          "package": "HaskellForMaths",
          "signature": "QSqrt5",
          "source": "src/Math-Algebra-Field-Extension.html#sqrt5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "sqrt5",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:sqrt5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "sqrt7",
          "package": "HaskellForMaths",
          "signature": "QSqrt7",
          "source": "src/Math-Algebra-Field-Extension.html#sqrt7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "sqrt7",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:sqrt7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "sqrtminus2",
          "package": "HaskellForMaths",
          "signature": "QSqrtMinus2",
          "source": "src/Math-Algebra-Field-Extension.html#sqrtminus2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "sqrtminus2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:sqrtminus2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "sqrtminus3",
          "package": "HaskellForMaths",
          "signature": "QSqrtMinus3",
          "source": "src/Math-Algebra-Field-Extension.html#sqrtminus3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "sqrtminus3",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:sqrtminus3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "sqrtminus5",
          "package": "HaskellForMaths",
          "signature": "QSqrtMinus5",
          "source": "src/Math-Algebra-Field-Extension.html#sqrtminus5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "sqrtminus5",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:sqrtminus5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "toUPoly",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e UPoly a",
          "source": "src/Math-Algebra-Field-Extension.html#toUPoly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "toUPoly",
          "normalized": "[a]-\u003eUPoly a",
          "package": "HaskellForMaths",
          "partial": "UPoly",
          "signature": "[a]-\u003eUPoly a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:toUPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Field.Extension",
          "name": "x",
          "package": "HaskellForMaths",
          "signature": "UPoly Integer",
          "source": "src/Math-Algebra-Field-Extension.html#x",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Field Extension",
          "module": "Math.Algebra.Field.Extension",
          "name": "x",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Field-Extension.html#v:x"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "CayleyGraph",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Group-CayleyGraph.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Algebra Group CayleyGraph",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "CayleyGraph",
          "package": "HaskellForMaths",
          "partial": "Cayley Graph",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-CayleyGraph.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "Digraph",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Group-CayleyGraph.html#Digraph",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebra Group CayleyGraph",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "Digraph",
          "package": "HaskellForMaths",
          "partial": "Digraph",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-CayleyGraph.html#t:Digraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "DG",
          "package": "HaskellForMaths",
          "signature": "DG [a] [(a, a)]",
          "source": "src/Math-Algebra-Group-CayleyGraph.html#Digraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group CayleyGraph",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "DG",
          "normalized": "DG[a][(a,a)]",
          "package": "HaskellForMaths",
          "partial": "DG",
          "signature": "DG[a][(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-CayleyGraph.html#v:DG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "bubblesort",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a]",
          "source": "src/Math-Algebra-Group-CayleyGraph.html#bubblesort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group CayleyGraph",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "bubblesort",
          "normalized": "[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-CayleyGraph.html#v:bubblesort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "cayleyDigraphP",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Digraph a",
          "source": "src/Math-Algebra-Group-CayleyGraph.html#cayleyDigraphP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group CayleyGraph",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "cayleyDigraphP",
          "normalized": "[a]-\u003eDigraph a",
          "package": "HaskellForMaths",
          "partial": "Digraph",
          "signature": "[a]-\u003eDigraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-CayleyGraph.html#v:cayleyDigraphP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "cayleyDigraphS",
          "package": "HaskellForMaths",
          "signature": "([a], [([a], [a])]) -\u003e Digraph [a]",
          "source": "src/Math-Algebra-Group-CayleyGraph.html#cayleyDigraphS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group CayleyGraph",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "cayleyDigraphS",
          "normalized": "([a],[([a],[a])])-\u003eDigraph[a]",
          "package": "HaskellForMaths",
          "partial": "Digraph",
          "signature": "([a],[([a],[a])])-\u003eDigraph[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-CayleyGraph.html#v:cayleyDigraphS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Cayley graph (undirected) on the generators (and their inverses),\n for a group given as permutations\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "cayleyGraphP",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e Graph (Permutation a)",
          "source": "src/Math-Algebra-Group-CayleyGraph.html#cayleyGraphP",
          "type": "function"
        },
        "index": {
          "description": "The Cayley graph undirected on the generators and their inverses for group given as permutations",
          "hierarchy": "Math Algebra Group CayleyGraph",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "cayleyGraphP",
          "normalized": "[Permutation a]-\u003eGraph(Permutation a)",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "[Permutation a]-\u003eGraph(Permutation a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-CayleyGraph.html#v:cayleyGraphP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Cayley graph (undirected) on the generators (and their inverses),\n for a group given as generators and relations\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "cayleyGraphS",
          "package": "HaskellForMaths",
          "signature": "([a], [([a], [a])]) -\u003e Graph [a]",
          "source": "src/Math-Algebra-Group-CayleyGraph.html#cayleyGraphS",
          "type": "function"
        },
        "index": {
          "description": "The Cayley graph undirected on the generators and their inverses for group given as generators and relations",
          "hierarchy": "Math Algebra Group CayleyGraph",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "cayleyGraphS",
          "normalized": "([a],[([a],[a])])-\u003eGraph[a]",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "([a],[([a],[a])])-\u003eGraph[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-CayleyGraph.html#v:cayleyGraphS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "fromTrans",
          "package": "HaskellForMaths",
          "signature": "[SGen] -\u003e [Int]",
          "source": "src/Math-Algebra-Group-CayleyGraph.html#fromTrans",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group CayleyGraph",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "fromTrans",
          "normalized": "[SGen]-\u003e[Int]",
          "package": "HaskellForMaths",
          "partial": "Trans",
          "signature": "[SGen]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-CayleyGraph.html#v:fromTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "fromTranspositions",
          "package": "HaskellForMaths",
          "signature": "[SGen] -\u003e Permutation Int",
          "source": "src/Math-Algebra-Group-CayleyGraph.html#fromTranspositions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group CayleyGraph",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "fromTranspositions",
          "normalized": "[SGen]-\u003ePermutation Int",
          "package": "HaskellForMaths",
          "partial": "Transpositions",
          "signature": "[SGen]-\u003ePermutation Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-CayleyGraph.html#v:fromTranspositions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "inversions",
          "package": "HaskellForMaths",
          "signature": "Permutation t -\u003e [(t, t)]",
          "source": "src/Math-Algebra-Group-CayleyGraph.html#inversions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group CayleyGraph",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "inversions",
          "normalized": "Permutation a-\u003e[(a,a)]",
          "package": "HaskellForMaths",
          "signature": "Permutation t-\u003e[(t,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-CayleyGraph.html#v:inversions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "toTrans",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e [SGen]",
          "source": "src/Math-Algebra-Group-CayleyGraph.html#toTrans",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group CayleyGraph",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "toTrans",
          "normalized": "[a]-\u003e[SGen]",
          "package": "HaskellForMaths",
          "partial": "Trans",
          "signature": "[t]-\u003e[SGen]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-CayleyGraph.html#v:toTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "toTranspositions",
          "package": "HaskellForMaths",
          "signature": "Permutation t -\u003e [SGen]",
          "source": "src/Math-Algebra-Group-CayleyGraph.html#toTranspositions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group CayleyGraph",
          "module": "Math.Algebra.Group.CayleyGraph",
          "name": "toTranspositions",
          "normalized": "Permutation a-\u003e[SGen]",
          "package": "HaskellForMaths",
          "partial": "Transpositions",
          "signature": "Permutation t-\u003e[SGen]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-CayleyGraph.html#v:toTranspositions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module for doing arithmetic in permutation groups.\n\u003c/p\u003e\u003cp\u003eGroup elements are represented as permutations of underlying sets, and are entered and displayed\n using a Haskell-friendly version of cycle notation. For example, the permutation (1 2 3)(4 5)\n would be entered as \u003ccode\u003ep [[1,2,3],[4,5]]\u003c/code\u003e, and displayed as [[1,2,3],[4,5]]. Permutations can be defined\n over arbitrary underlying sets (types), not just the integers.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003eg\u003c/code\u003e and \u003ccode\u003eh\u003c/code\u003e are group elements, then the expressions \u003ccode\u003eg*h\u003c/code\u003e and \u003ccode\u003eg^-1\u003c/code\u003e calculate product and inverse respectively.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "PermutationGroup",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Group-PermutationGroup.html",
          "type": "module"
        },
        "index": {
          "description": "module for doing arithmetic in permutation groups Group elements are represented as permutations of underlying sets and are entered and displayed using Haskell-friendly version of cycle notation For example the permutation would be entered as and displayed as Permutations can be defined over arbitrary underlying sets types not just the integers If and are group elements then the expressions and calculate product and inverse respectively",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "PermutationGroup",
          "package": "HaskellForMaths",
          "partial": "Permutation Group",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type for permutations, considered as functions or actions which can be performed on an underlying set.\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "Permutation",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#Permutation",
          "type": "newtype"
        },
        "index": {
          "description": "type for permutations considered as functions or actions which can be performed on an underlying set",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "Permutation",
          "package": "HaskellForMaths",
          "partial": "Permutation",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#t:Permutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(~~^)",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e Permutation a -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#~~%5E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(~~^) ~~^",
          "normalized": "[Permutation a]-\u003ePermutation a-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "signature": "[Permutation a]-\u003ePermutation a-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:-126--126--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eg ~^ h returns the conjugate of g by h, that is, h^-1*g*h.\n The tilde is meant to a mnemonic, because conjugacy is an equivalence relation.\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(~^)",
          "package": "HaskellForMaths",
          "signature": "Permutation a -\u003e Permutation a -\u003e Permutation a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#~%5E",
          "type": "function"
        },
        "index": {
          "description": "returns the conjugate of by that is The tilde is meant to mnemonic because conjugacy is an equivalence relation",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(~^) ~^",
          "normalized": "Permutation a-\u003ePermutation a-\u003ePermutation a",
          "package": "HaskellForMaths",
          "signature": "Permutation a-\u003ePermutation a-\u003ePermutation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:-126--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(~^^)",
          "package": "HaskellForMaths",
          "signature": "Permutation a -\u003e [Permutation a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#~%5E%5E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(~^^) ~^^",
          "normalized": "Permutation a-\u003e[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "signature": "Permutation a-\u003e[Permutation a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:-126--94--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(*-)",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#%2A-",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(*-) *-",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:-42--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(-*)",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e a -\u003e [a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#-%2A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(-*) -*",
          "normalized": "[a]-\u003ea-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:-45--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(-*-)",
          "package": "HaskellForMaths",
          "signature": "[b] -\u003e [b] -\u003e [b]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#-%2A-",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(-*-) -*-",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[b]-\u003e[b]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:-45--42--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eb -^ g returns the image of an edge or block b under the action of the permutation g.\n For example, \u003ccode\u003e[1,2] -^ p [[1,4],[2,3]]\u003c/code\u003e returns [3,4].\n The dash is meant to be a mnemonic for edge or line or block.\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(-^)",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Permutation a -\u003e [a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#-%5E",
          "type": "function"
        },
        "index": {
          "description": "returns the image of an edge or block under the action of the permutation For example returns The dash is meant to be mnemonic for edge or line or block",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(-^) -^",
          "normalized": "[a]-\u003ePermutation a-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003ePermutation a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:-45--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eb -^^ gs returns the orbit of the block or edge b under the action of the gs\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(-^^)",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [Permutation a] -\u003e [[a]]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#-%5E%5E",
          "type": "function"
        },
        "index": {
          "description": "gs returns the orbit of the block or edge under the action of the gs",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(-^^) -^^",
          "normalized": "[a]-\u003e[Permutation a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[Permutation a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:-45--94--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for quotientGp\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(//)",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a] -\u003e [Permutation Int]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#%2F%2F",
          "type": "function"
        },
        "index": {
          "description": "Synonym for quotientGp",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(//) //",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation Int]",
          "package": "HaskellForMaths",
          "signature": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:-47--47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ex .^ g returns the image of a vertex or point x under the action of the permutation g.\n For example, \u003ccode\u003e1 .^ p [[1,2,3]]\u003c/code\u003e returns 2.\n The dot is meant to be a mnemonic for point or vertex.\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(.^)",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Permutation a -\u003e a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#.%5E",
          "type": "function"
        },
        "index": {
          "description": "returns the image of vertex or point under the action of the permutation For example returns The dot is meant to be mnemonic for point or vertex",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(.^) .^",
          "normalized": "a-\u003ePermutation a-\u003ea",
          "package": "HaskellForMaths",
          "signature": "a-\u003ePermutation a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:.-94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ex .^^ gs returns the orbit of the point or vertex x under the action of the gs\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(.^^)",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [Permutation a] -\u003e [a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#.%5E%5E",
          "type": "function"
        },
        "index": {
          "description": "gs returns the orbit of the point or vertex under the action of the gs",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "(.^^) .^^",
          "normalized": "a-\u003e[Permutation a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "a-\u003e[Permutation a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:.-94--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "P",
          "package": "HaskellForMaths",
          "signature": "P (Map a a)",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#Permutation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "P",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e_A n returns generators for An, the alternating group on [1..n]\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "_A",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#_A",
          "type": "function"
        },
        "index": {
          "description": "returns generators for An the alternating group on",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "_A",
          "normalized": "a-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "signature": "a-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:_A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e_C n returns generators for Cn, the cyclic group of order n\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "_C",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#_C",
          "type": "function"
        },
        "index": {
          "description": "returns generators for Cn the cyclic group of order",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "_C",
          "normalized": "a-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "signature": "a-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:_C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "_D",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#_D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "_D",
          "normalized": "a-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "signature": "a-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:_D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "_D2",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#_D2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "_D2",
          "normalized": "a-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "signature": "a-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:_D2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e_S n returns generators for Sn, the symmetric group on [1..n]\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "_S",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#_S",
          "type": "function"
        },
        "index": {
          "description": "returns generators for Sn the symmetric group on",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "_S",
          "normalized": "a-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "signature": "a-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:_S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "action",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e (a -\u003e a) -\u003e Permutation a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#action",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "action",
          "normalized": "[a]-\u003e(a-\u003ea)-\u003ePermutation a",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e(a-\u003ea)-\u003ePermutation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:action"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "centralizer",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e [t] -\u003e [t]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#centralizer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "centralizer",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[t]-\u003e[t]-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:centralizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "centre",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e [t]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#centre",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "centre",
          "normalized": "[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[t]-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:centre"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "closure",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a -\u003e a] -\u003e [a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#closure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "closure",
          "normalized": "[a]-\u003e[a-\u003ea]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a-\u003ea]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:closure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "closureS",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a -\u003e a] -\u003e Set a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#closureS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "closureS",
          "normalized": "[a]-\u003e[a-\u003ea]-\u003eSet a",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a-\u003ea]-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:closureS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "comm",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#comm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "comm",
          "normalized": "a-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:comm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "commutatorGp",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#commutatorGp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "commutatorGp",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Gp",
          "signature": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:commutatorGp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "conjClass",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e Permutation a -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#conjClass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "conjClass",
          "normalized": "[Permutation a]-\u003ePermutation a-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Class",
          "signature": "[Permutation a]-\u003ePermutation a-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:conjClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econjClassReps gs returns conjugacy class representatives and sizes for the group generated by gs.\n This implementation is only suitable for use with small groups (|G| \u003c 10000).\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "conjClassReps",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [(Permutation a, Int)]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#conjClassReps",
          "type": "function"
        },
        "index": {
          "description": "conjClassReps gs returns conjugacy class representatives and sizes for the group generated by gs This implementation is only suitable for use with small groups",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "conjClassReps",
          "normalized": "[Permutation a]-\u003e[(Permutation a,Int)]",
          "package": "HaskellForMaths",
          "partial": "Class Reps",
          "signature": "[Permutation a]-\u003e[(Permutation a,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:conjClassReps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "conjugateSubgps",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a] -\u003e [[Permutation a]]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#conjugateSubgps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "conjugateSubgps",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003e[[Permutation a]]",
          "package": "HaskellForMaths",
          "partial": "Subgps",
          "signature": "[Permutation a]-\u003e[Permutation a]-\u003e[[Permutation a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:conjugateSubgps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "cosets",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e [t] -\u003e [[t]]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#cosets",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "cosets",
          "normalized": "[a]-\u003e[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[t]-\u003e[t]-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:cosets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "cycleOf",
          "package": "HaskellForMaths",
          "signature": "Permutation a -\u003e a -\u003e [a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#cycleOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "cycleOf",
          "normalized": "Permutation a-\u003ea-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Of",
          "signature": "Permutation a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:cycleOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "derivedSubgp",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#derivedSubgp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "derivedSubgp",
          "normalized": "[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Subgp",
          "signature": "[Permutation a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:derivedSubgp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven generators for groups H and K, acting on sets A and B respectively,\n return generators for the direct product H*K, acting on the disjoint union A+B (= Either A B)\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "dp",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation b] -\u003e [Permutation (Either a b)]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#dp",
          "type": "function"
        },
        "index": {
          "description": "Given generators for groups and acting on sets and respectively return generators for the direct product acting on the disjoint union Either",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "dp",
          "normalized": "[Permutation a]-\u003e[Permutation b]-\u003e[Permutation(Either a b)]",
          "package": "HaskellForMaths",
          "signature": "[Permutation a]-\u003e[Permutation b]-\u003e[Permutation(Either a b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:dp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven generators for a group, return a (sorted) list of all elements of the group.\n Implemented using a naive closure algorithm, so only suitable for small groups (|G| \u003c 10000)\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "elts",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#elts",
          "type": "function"
        },
        "index": {
          "description": "Given generators for group return sorted list of all elements of the group Implemented using naive closure algorithm so only suitable for small groups",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "elts",
          "normalized": "[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:elts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "eltsS",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Set a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#eltsS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "eltsS",
          "normalized": "[a]-\u003eSet a",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:eltsS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "eltsTGS",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#eltsTGS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "eltsTGS",
          "normalized": "[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "TGS",
          "signature": "[Permutation a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:eltsTGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromBinary",
          "package": "HaskellForMaths",
          "signature": "Permutation [a] -\u003e Permutation a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#fromBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromBinary",
          "normalized": "Permutation[a]-\u003ePermutation a",
          "package": "HaskellForMaths",
          "partial": "Binary",
          "signature": "Permutation[a]-\u003ePermutation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:fromBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromBinary'",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#fromBinary%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromBinary'",
          "normalized": "[a]-\u003ea",
          "package": "HaskellForMaths",
          "partial": "Binary'",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:fromBinary-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromCycles",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Permutation a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#fromCycles",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromCycles",
          "normalized": "[[a]]-\u003ePermutation a",
          "package": "HaskellForMaths",
          "partial": "Cycles",
          "signature": "[[a]]-\u003ePermutation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:fromCycles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromDigits",
          "package": "HaskellForMaths",
          "signature": "Permutation [a] -\u003e Permutation a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#fromDigits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromDigits",
          "normalized": "Permutation[a]-\u003ePermutation a",
          "package": "HaskellForMaths",
          "partial": "Digits",
          "signature": "Permutation[a]-\u003ePermutation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:fromDigits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromDigits'",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#fromDigits%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromDigits'",
          "normalized": "[a]-\u003ea",
          "package": "HaskellForMaths",
          "partial": "Digits'",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:fromDigits-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromList",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Permutation a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromList",
          "normalized": "[a]-\u003ePermutation a",
          "package": "HaskellForMaths",
          "partial": "List",
          "signature": "[a]-\u003ePermutation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromPairs",
          "package": "HaskellForMaths",
          "signature": "[(a, a)] -\u003e Permutation a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#fromPairs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromPairs",
          "normalized": "[(a,a)]-\u003ePermutation a",
          "package": "HaskellForMaths",
          "partial": "Pairs",
          "signature": "[(a,a)]-\u003ePermutation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:fromPairs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromPairs'",
          "package": "HaskellForMaths",
          "signature": "[(a, a)] -\u003e Permutation a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#fromPairs%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "fromPairs'",
          "normalized": "[(a,a)]-\u003ePermutation a",
          "package": "HaskellForMaths",
          "partial": "Pairs'",
          "signature": "[(a,a)]-\u003ePermutation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:fromPairs-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "gens",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#gens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "gens",
          "normalized": "[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:gens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "isMember",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e a -\u003e Bool",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#isMember",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "isMember",
          "normalized": "[a]-\u003ea-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Member",
          "signature": "[a]-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:isMember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "isMinimal",
          "package": "HaskellForMaths",
          "signature": "Permutation a -\u003e Bool",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#isMinimal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "isMinimal",
          "normalized": "Permutation a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Minimal",
          "signature": "Permutation a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:isMinimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eisNormal gs ks returns True if \u003cks\u003e is normal in \u003cgs\u003e.\n Note, it is caller's responsibility to ensure that \u003cks\u003e is a subgroup of \u003cgs\u003e (ie that each k is in \u003cgs\u003e).\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "isNormal",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a] -\u003e Bool",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#isNormal",
          "type": "function"
        },
        "index": {
          "description": "isNormal gs ks returns True if ks is normal in gs Note it is caller responsibility to ensure that ks is subgroup of gs ie that each is in gs",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "isNormal",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Normal",
          "signature": "[Permutation a]-\u003e[Permutation a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:isNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "isSimple",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e Bool",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#isSimple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "isSimple",
          "normalized": "[Permutation a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Simple",
          "signature": "[Permutation a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:isSimple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "isSubgp",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#isSubgp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "isSubgp",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Subgp",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:isSubgp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "minsupp",
          "package": "HaskellForMaths",
          "signature": "Permutation c -\u003e c",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#minsupp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "minsupp",
          "normalized": "Permutation a-\u003ea",
          "package": "HaskellForMaths",
          "signature": "Permutation c-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:minsupp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "normalClosure",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#normalClosure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "normalClosure",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Closure",
          "signature": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:normalClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the normal subgroups of a group. Only suitable for use on small groups (eg \u003c 100 elts)\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "normalSubgps",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [[Permutation a]]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#normalSubgps",
          "type": "function"
        },
        "index": {
          "description": "Return the normal subgroups of group Only suitable for use on small groups eg elts",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "normalSubgps",
          "normalized": "[Permutation a]-\u003e[[Permutation a]]",
          "package": "HaskellForMaths",
          "partial": "Subgps",
          "signature": "[Permutation a]-\u003e[[Permutation a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:normalSubgps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "normalizer",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#normalizer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "normalizer",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "signature": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:normalizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orbit",
          "package": "HaskellForMaths",
          "signature": "(a -\u003e t -\u003e a) -\u003e a -\u003e [t] -\u003e [a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#orbit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orbit",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003e[b]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "(a-\u003et-\u003ea)-\u003ea-\u003e[t]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:orbit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orbitB",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [a] -\u003e [[a]]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#orbitB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orbitB",
          "normalized": "[Permutation a]-\u003e[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[Permutation a]-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:orbitB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orbitE",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [a] -\u003e [[a]]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#orbitE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orbitE",
          "normalized": "[Permutation a]-\u003e[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[Permutation a]-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:orbitE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orbitP",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e a -\u003e [a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#orbitP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orbitP",
          "normalized": "[Permutation a]-\u003ea-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[Permutation a]-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:orbitP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orbitV",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e a -\u003e [a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#orbitV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orbitV",
          "normalized": "[Permutation a]-\u003ea-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[Permutation a]-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:orbitV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orbits",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [[a]]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#orbits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orbits",
          "normalized": "[Permutation a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[Permutation a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:orbits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven generators for a group, return the order of the group (the number of elements).\n Implemented using a naive closure algorithm, so only suitable for small groups (|G| \u003c 10000)\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "order",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Int",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#order",
          "type": "function"
        },
        "index": {
          "description": "Given generators for group return the order of the group the number of elements Implemented using naive closure algorithm so only suitable for small groups",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "order",
          "normalized": "[a]-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:order"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orderElt",
          "package": "HaskellForMaths",
          "signature": "Permutation a -\u003e Int",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#orderElt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orderElt",
          "normalized": "Permutation a-\u003eInt",
          "package": "HaskellForMaths",
          "partial": "Elt",
          "signature": "Permutation a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:orderElt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a strong generating set, return the order of the group it generates\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orderSGS",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e Integer",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#orderSGS",
          "type": "function"
        },
        "index": {
          "description": "Given strong generating set return the order of the group it generates",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orderSGS",
          "normalized": "[Permutation a]-\u003eInteger",
          "package": "HaskellForMaths",
          "partial": "SGS",
          "signature": "[Permutation a]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:orderSGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orderTGS",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e a1",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#orderTGS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "orderTGS",
          "normalized": "[Permutation a]-\u003ea",
          "package": "HaskellForMaths",
          "partial": "TGS",
          "signature": "[Permutation a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:orderTGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a permutation from a list of cycles.\n For example, \u003ccode\u003ep [[1,2,3],[4,5]]\u003c/code\u003e returns the permutation that sends 1 to 2, 2 to 3, 3 to 1, 4 to 5, 5 to 4.\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "p",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Permutation a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#p",
          "type": "function"
        },
        "index": {
          "description": "Construct permutation from list of cycles For example returns the permutation that sends to to to to to",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "p",
          "normalized": "[[a]]-\u003ePermutation a",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003ePermutation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:p"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "parity",
          "package": "HaskellForMaths",
          "signature": "Permutation a -\u003e Int",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#parity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "parity",
          "normalized": "Permutation a-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "Permutation a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:parity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "permutationMatrix",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Permutation a -\u003e [[t]]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#permutationMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "permutationMatrix",
          "normalized": "[a]-\u003ePermutation a-\u003e[[b]]",
          "package": "HaskellForMaths",
          "partial": "Matrix",
          "signature": "[a]-\u003ePermutation a-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:permutationMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "ptStab",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#ptStab",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "ptStab",
          "normalized": "[Permutation a]-\u003e[a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Stab",
          "signature": "[Permutation a]-\u003e[a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:ptStab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003equotientGp gs ks returns \u003cgs\u003e / \u003cks\u003e\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "quotientGp",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a] -\u003e [Permutation Int]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#quotientGp",
          "type": "function"
        },
        "index": {
          "description": "quotientGp gs ks returns gs ks",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "quotientGp",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation Int]",
          "package": "HaskellForMaths",
          "partial": "Gp",
          "signature": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:quotientGp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "reduceGens",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#reduceGens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "reduceGens",
          "normalized": "[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Gens",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:reduceGens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "rotateL",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#rotateL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "rotateL",
          "normalized": "[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:rotateL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "rrpr",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e a -\u003e Permutation a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#rrpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "rrpr",
          "normalized": "[a]-\u003ea-\u003ePermutation a",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003ea-\u003ePermutation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:rrpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "rrpr'",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e a -\u003e Permutation a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#rrpr%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "rrpr'",
          "normalized": "[a]-\u003ea-\u003ePermutation a",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003ea-\u003ePermutation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:rrpr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "setStab",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#setStab",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "setStab",
          "normalized": "[Permutation a]-\u003e[a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Stab",
          "signature": "[Permutation a]-\u003e[a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:setStab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "sign",
          "package": "HaskellForMaths",
          "signature": "Permutation a1 -\u003e a",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#sign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "sign",
          "normalized": "Permutation a-\u003ea",
          "package": "HaskellForMaths",
          "signature": "Permutation a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:sign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "stabilizer",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e a -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#stabilizer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "stabilizer",
          "normalized": "[Permutation a]-\u003ea-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "signature": "[Permutation a]-\u003ea-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:stabilizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "subgpAction",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a] -\u003e [Permutation a1]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#subgpAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "subgpAction",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Action",
          "signature": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:subgpAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the subgroups of a group. Only suitable for use on small groups (eg \u003c 100 elts)\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "subgps",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [[Permutation a]]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#subgps",
          "type": "function"
        },
        "index": {
          "description": "Return the subgroups of group Only suitable for use on small groups eg elts",
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "subgps",
          "normalized": "[Permutation a]-\u003e[[Permutation a]]",
          "package": "HaskellForMaths",
          "signature": "[Permutation a]-\u003e[[Permutation a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:subgps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "supp",
          "package": "HaskellForMaths",
          "signature": "Permutation a -\u003e [a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#supp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "supp",
          "normalized": "Permutation a-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "Permutation a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:supp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "tgsFromSgs",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#tgsFromSgs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "tgsFromSgs",
          "normalized": "[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "From Sgs",
          "signature": "[Permutation a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:tgsFromSgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "toCycles",
          "package": "HaskellForMaths",
          "signature": "Permutation a -\u003e [[a]]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#toCycles",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "toCycles",
          "normalized": "Permutation a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Cycles",
          "signature": "Permutation a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:toCycles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "toPairs",
          "package": "HaskellForMaths",
          "signature": "Permutation a -\u003e [(a, a)]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#toPairs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "toPairs",
          "normalized": "Permutation a-\u003e[(a,a)]",
          "package": "HaskellForMaths",
          "partial": "Pairs",
          "signature": "Permutation a-\u003e[(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:toPairs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "toSn",
          "package": "HaskellForMaths",
          "signature": "[Permutation k] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#toSn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "toSn",
          "normalized": "[Permutation a]-\u003e[Permutation b]",
          "package": "HaskellForMaths",
          "partial": "Sn",
          "signature": "[Permutation k]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:toSn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "wr",
          "package": "HaskellForMaths",
          "signature": "[Permutation t] -\u003e [Permutation t1] -\u003e [Permutation (t, t1)]",
          "source": "src/Math-Algebra-Group-PermutationGroup.html#wr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group PermutationGroup",
          "module": "Math.Algebra.Group.PermutationGroup",
          "name": "wr",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation(a,a)]",
          "package": "HaskellForMaths",
          "signature": "[Permutation t]-\u003e[Permutation t]-\u003e[Permutation(t,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-PermutationGroup.html#v:wr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "RandomSchreierSims",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Group-RandomSchreierSims.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Algebra Group RandomSchreierSims",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "RandomSchreierSims",
          "package": "HaskellForMaths",
          "partial": "Random Schreier Sims",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-RandomSchreierSims.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "baseTransversalsSGS",
          "package": "HaskellForMaths",
          "signature": "[Permutation k] -\u003e [(k, Map k (Permutation k))]",
          "source": "src/Math-Algebra-Group-RandomSchreierSims.html#baseTransversalsSGS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group RandomSchreierSims",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "baseTransversalsSGS",
          "normalized": "[Permutation a]-\u003e[(a,Map a(Permutation a))]",
          "package": "HaskellForMaths",
          "partial": "Transversals SGS",
          "signature": "[Permutation k]-\u003e[(k,Map k(Permutation k))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-RandomSchreierSims.html#v:baseTransversalsSGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "initLevels",
          "package": "HaskellForMaths",
          "signature": "[Permutation k] -\u003e [((k, Map k a), [a1])]",
          "source": "src/Math-Algebra-Group-RandomSchreierSims.html#initLevels",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group RandomSchreierSims",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "initLevels",
          "normalized": "[Permutation a]-\u003e[((a,Map a b),[b])]",
          "package": "HaskellForMaths",
          "partial": "Levels",
          "signature": "[Permutation k]-\u003e[((k,Map k a),[a])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-RandomSchreierSims.html#v:initLevels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "initProdRepl",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e IO (Int, IOArray Int (Permutation a))",
          "source": "src/Math-Algebra-Group-RandomSchreierSims.html#initProdRepl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group RandomSchreierSims",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "initProdRepl",
          "normalized": "[Permutation a]-\u003eIO(Int,IOArray Int(Permutation a))",
          "package": "HaskellForMaths",
          "partial": "Prod Repl",
          "signature": "[Permutation a]-\u003eIO(Int,IOArray Int(Permutation a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-RandomSchreierSims.html#v:initProdRepl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a strong generating set gs, isMemberSGS gs is a membership test for the group\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "isMemberSGS",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e Permutation a -\u003e Bool",
          "source": "src/Math-Algebra-Group-RandomSchreierSims.html#isMemberSGS",
          "type": "function"
        },
        "index": {
          "description": "Given strong generating set gs isMemberSGS gs is membership test for the group",
          "hierarchy": "Math Algebra Group RandomSchreierSims",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "isMemberSGS",
          "normalized": "[Permutation a]-\u003ePermutation a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Member SGS",
          "signature": "[Permutation a]-\u003ePermutation a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-RandomSchreierSims.html#v:isMemberSGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "nextProdRepl",
          "package": "HaskellForMaths",
          "signature": "(Int, IOArray Int (Permutation a)) -\u003e IO (Maybe (Permutation a))",
          "source": "src/Math-Algebra-Group-RandomSchreierSims.html#nextProdRepl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group RandomSchreierSims",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "nextProdRepl",
          "normalized": "(Int,IOArray Int(Permutation a))-\u003eIO(Maybe(Permutation a))",
          "package": "HaskellForMaths",
          "partial": "Prod Repl",
          "signature": "(Int,IOArray Int(Permutation a))-\u003eIO(Maybe(Permutation a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-RandomSchreierSims.html#v:nextProdRepl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "rss",
          "package": "HaskellForMaths",
          "signature": "[Permutation k] -\u003e [((k, Map k (Permutation k)), [Permutation k])]",
          "source": "src/Math-Algebra-Group-RandomSchreierSims.html#rss",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group RandomSchreierSims",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "rss",
          "normalized": "[Permutation a]-\u003e[((a,Map a(Permutation a)),[Permutation a])]",
          "package": "HaskellForMaths",
          "signature": "[Permutation k]-\u003e[((k,Map k(Permutation k)),[Permutation k])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-RandomSchreierSims.html#v:rss"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "rss'",
          "package": "HaskellForMaths",
          "signature": "(Int, IOArray Int (Permutation k)) -\u003e [((k, Map k (Permutation k)), [Permutation k])] -\u003e a -\u003e IO [((k, Map k (Permutation k)), [Permutation k])]",
          "source": "src/Math-Algebra-Group-RandomSchreierSims.html#rss%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group RandomSchreierSims",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "rss'",
          "normalized": "(Int,IOArray Int(Permutation a))-\u003e[((a,Map a(Permutation a)),[Permutation a])]-\u003eb-\u003eIO[((a,Map a(Permutation a)),[Permutation a])]",
          "package": "HaskellForMaths",
          "signature": "(Int,IOArray Int(Permutation k))-\u003e[((k,Map k(Permutation k)),[Permutation k])]-\u003ea-\u003eIO[((k,Map k(Permutation k)),[Permutation k])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-RandomSchreierSims.html#v:rss-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven generators for a permutation group, return a strong generating set.\n The result is calculated using random Schreier-Sims algorithm, so has a small (\u003c10^-6) chance of being incomplete.\n The sgs is relative to the base implied by the Ord instance.\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "sgs",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-RandomSchreierSims.html#sgs",
          "type": "function"
        },
        "index": {
          "description": "Given generators for permutation group return strong generating set The result is calculated using random Schreier-Sims algorithm so has small chance of being incomplete The sgs is relative to the base implied by the Ord instance",
          "hierarchy": "Math Algebra Group RandomSchreierSims",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "sgs",
          "normalized": "[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "signature": "[Permutation a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-RandomSchreierSims.html#v:sgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "testProdRepl",
          "package": "HaskellForMaths",
          "signature": "IO ()",
          "source": "src/Math-Algebra-Group-RandomSchreierSims.html#testProdRepl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group RandomSchreierSims",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "testProdRepl",
          "normalized": "IO()",
          "package": "HaskellForMaths",
          "partial": "Prod Repl",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-RandomSchreierSims.html#v:testProdRepl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "updateArray",
          "package": "HaskellForMaths",
          "signature": "a1 i a -\u003e i -\u003e i -\u003e t -\u003e m (Maybe a)",
          "source": "src/Math-Algebra-Group-RandomSchreierSims.html#updateArray",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group RandomSchreierSims",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "updateArray",
          "normalized": "a b a-\u003eb-\u003eb-\u003ec-\u003ed(Maybe a)",
          "package": "HaskellForMaths",
          "partial": "Array",
          "signature": "a i a-\u003ei-\u003ei-\u003et-\u003em(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-RandomSchreierSims.html#v:updateArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "updateLevels",
          "package": "HaskellForMaths",
          "signature": "[((k, Map k (Permutation k)), [Permutation k])] -\u003e Maybe (Permutation k) -\u003e (Bool, [((k, Map k (Permutation k)), [Permutation k])])",
          "source": "src/Math-Algebra-Group-RandomSchreierSims.html#updateLevels",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group RandomSchreierSims",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "updateLevels",
          "normalized": "[((a,Map a(Permutation a)),[Permutation a])]-\u003eMaybe(Permutation a)-\u003e(Bool,[((a,Map a(Permutation a)),[Permutation a])])",
          "package": "HaskellForMaths",
          "partial": "Levels",
          "signature": "[((k,Map k(Permutation k)),[Permutation k])]-\u003eMaybe(Permutation k)-\u003e(Bool,[((k,Map k(Permutation k)),[Permutation k])])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-RandomSchreierSims.html#v:updateLevels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "updateLevels'",
          "package": "HaskellForMaths",
          "signature": "[((k, Map k (Permutation k)), [Permutation k])] -\u003e [((k, Map k (Permutation k)), [Permutation k])] -\u003e Permutation k -\u003e k -\u003e [((k, Map k (Permutation k)), [Permutation k])]",
          "source": "src/Math-Algebra-Group-RandomSchreierSims.html#updateLevels%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group RandomSchreierSims",
          "module": "Math.Algebra.Group.RandomSchreierSims",
          "name": "updateLevels'",
          "normalized": "[((a,Map a(Permutation a)),[Permutation a])]-\u003e[((a,Map a(Permutation a)),[Permutation a])]-\u003ePermutation a-\u003ea-\u003e[((a,Map a(Permutation a)),[Permutation a])]",
          "package": "HaskellForMaths",
          "partial": "Levels'",
          "signature": "[((k,Map k(Permutation k)),[Permutation k])]-\u003e[((k,Map k(Permutation k)),[Permutation k])]-\u003ePermutation k-\u003ek-\u003e[((k,Map k(Permutation k)),[Permutation k])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-RandomSchreierSims.html#v:updateLevels-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "SchreierSims",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Group-SchreierSims.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "SchreierSims",
          "package": "HaskellForMaths",
          "partial": "Schreier Sims",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "bsgs",
          "package": "HaskellForMaths",
          "signature": "[Permutation k] -\u003e [(k, Map k (Permutation k))]",
          "source": "src/Math-Algebra-Group-SchreierSims.html#bsgs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "bsgs",
          "normalized": "[Permutation a]-\u003e[(a,Map a(Permutation a))]",
          "package": "HaskellForMaths",
          "signature": "[Permutation k]-\u003e[(k,Map k(Permutation k))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:bsgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "bsgs'",
          "package": "HaskellForMaths",
          "signature": "[k] -\u003e [Permutation k] -\u003e [(k, Map k (Permutation k))]",
          "source": "src/Math-Algebra-Group-SchreierSims.html#bsgs%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "bsgs'",
          "normalized": "[a]-\u003e[Permutation a]-\u003e[(a,Map a(Permutation a))]",
          "package": "HaskellForMaths",
          "signature": "[k]-\u003e[Permutation k]-\u003e[(k,Map k(Permutation k))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:bsgs-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "cartProd",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Math-Algebra-Group-SchreierSims.html#cartProd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "cartProd",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Prod",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:cartProd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "commutatorGp",
          "package": "HaskellForMaths",
          "signature": "[Permutation k] -\u003e [Permutation k] -\u003e [Permutation k]",
          "source": "src/Math-Algebra-Group-SchreierSims.html#commutatorGp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "commutatorGp",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Gp",
          "signature": "[Permutation k]-\u003e[Permutation k]-\u003e[Permutation k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:commutatorGp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "cosetRepsGx",
          "package": "HaskellForMaths",
          "signature": "[Permutation k] -\u003e k -\u003e Map k (Permutation k)",
          "source": "src/Math-Algebra-Group-SchreierSims.html#cosetRepsGx",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "cosetRepsGx",
          "normalized": "[Permutation a]-\u003ea-\u003eMap a(Permutation a)",
          "package": "HaskellForMaths",
          "partial": "Reps Gx",
          "signature": "[Permutation k]-\u003ek-\u003eMap k(Permutation k)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:cosetRepsGx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "derivedSubgp",
          "package": "HaskellForMaths",
          "signature": "[Permutation k] -\u003e [Permutation k]",
          "source": "src/Math-Algebra-Group-SchreierSims.html#derivedSubgp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "derivedSubgp",
          "normalized": "[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Subgp",
          "signature": "[Permutation k]-\u003e[Permutation k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:derivedSubgp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven generators for a group, return a (sorted) list of all elements of the group, using Schreier-Sims algorithm\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "elts",
          "package": "HaskellForMaths",
          "signature": "[Permutation t] -\u003e [Permutation t]",
          "source": "src/Math-Algebra-Group-SchreierSims.html#elts",
          "type": "function"
        },
        "index": {
          "description": "Given generators for group return sorted list of all elements of the group using Schreier-Sims algorithm",
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "elts",
          "normalized": "[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "signature": "[Permutation t]-\u003e[Permutation t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:elts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "eltsBSGS",
          "package": "HaskellForMaths",
          "signature": "[(a, Map k b)] -\u003e [b]",
          "source": "src/Math-Algebra-Group-SchreierSims.html#eltsBSGS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "eltsBSGS",
          "normalized": "[(a,Map b c)]-\u003e[c]",
          "package": "HaskellForMaths",
          "partial": "BSGS",
          "signature": "[(a,Map k b)]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:eltsBSGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "findBase",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e a",
          "source": "src/Math-Algebra-Group-SchreierSims.html#findBase",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "findBase",
          "normalized": "[Permutation a]-\u003ea",
          "package": "HaskellForMaths",
          "partial": "Base",
          "signature": "[Permutation a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:findBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "index",
          "package": "HaskellForMaths",
          "signature": "[Permutation t] -\u003e [Permutation t1] -\u003e Integer",
          "source": "src/Math-Algebra-Group-SchreierSims.html#index",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "index",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003eInteger",
          "package": "HaskellForMaths",
          "signature": "[Permutation t]-\u003e[Permutation t]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven generators for a group, determine whether a permutation is a member of the group, using Schreier-Sims algorithm\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "isMember",
          "package": "HaskellForMaths",
          "signature": "[Permutation t] -\u003e Permutation t -\u003e Bool",
          "source": "src/Math-Algebra-Group-SchreierSims.html#isMember",
          "type": "function"
        },
        "index": {
          "description": "Given generators for group determine whether permutation is member of the group using Schreier-Sims algorithm",
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "isMember",
          "normalized": "[Permutation a]-\u003ePermutation a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Member",
          "signature": "[Permutation t]-\u003ePermutation t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:isMember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "isMemberBSGS",
          "package": "HaskellForMaths",
          "signature": "[(k, Map k (Permutation k))] -\u003e Permutation k -\u003e Bool",
          "source": "src/Math-Algebra-Group-SchreierSims.html#isMemberBSGS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "isMemberBSGS",
          "normalized": "[(a,Map a(Permutation a))]-\u003ePermutation a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Member BSGS",
          "signature": "[(k,Map k(Permutation k))]-\u003ePermutation k-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:isMemberBSGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "isNormal",
          "package": "HaskellForMaths",
          "signature": "[Permutation k] -\u003e [Permutation k] -\u003e Bool",
          "source": "src/Math-Algebra-Group-SchreierSims.html#isNormal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "isNormal",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Normal",
          "signature": "[Permutation k]-\u003e[Permutation k]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:isNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "isSubgp",
          "package": "HaskellForMaths",
          "signature": "[Permutation k] -\u003e [Permutation k] -\u003e Bool",
          "source": "src/Math-Algebra-Group-SchreierSims.html#isSubgp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "isSubgp",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Subgp",
          "signature": "[Permutation k]-\u003e[Permutation k]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:isSubgp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "newLevel",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [Permutation a] -\u003e ([a], ((a, Map a (Permutation a)), [Permutation a]))",
          "source": "src/Math-Algebra-Group-SchreierSims.html#newLevel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "newLevel",
          "normalized": "[a]-\u003e[Permutation a]-\u003e([a],((a,Map a(Permutation a)),[Permutation a]))",
          "package": "HaskellForMaths",
          "partial": "Level",
          "signature": "[a]-\u003e[Permutation a]-\u003e([a],((a,Map a(Permutation a)),[Permutation a]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:newLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "newLevel'",
          "package": "HaskellForMaths",
          "signature": "t -\u003e [Permutation t] -\u003e ((t, Map t (Permutation t)), [Permutation t])",
          "source": "src/Math-Algebra-Group-SchreierSims.html#newLevel%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "newLevel'",
          "normalized": "a-\u003e[Permutation a]-\u003e((a,Map a(Permutation a)),[Permutation a])",
          "package": "HaskellForMaths",
          "partial": "Level'",
          "signature": "t-\u003e[Permutation t]-\u003e((t,Map t(Permutation t)),[Permutation t])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:newLevel-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "normalClosure",
          "package": "HaskellForMaths",
          "signature": "[Permutation k] -\u003e [Permutation k] -\u003e [Permutation k]",
          "source": "src/Math-Algebra-Group-SchreierSims.html#normalClosure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "normalClosure",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Closure",
          "signature": "[Permutation k]-\u003e[Permutation k]-\u003e[Permutation k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:normalClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven generators for a group, return the order of the group (the number of elements), using Schreier-Sims algorithm\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "order",
          "package": "HaskellForMaths",
          "signature": "[Permutation t] -\u003e Integer",
          "source": "src/Math-Algebra-Group-SchreierSims.html#order",
          "type": "function"
        },
        "index": {
          "description": "Given generators for group return the order of the group the number of elements using Schreier-Sims algorithm",
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "order",
          "normalized": "[Permutation a]-\u003eInteger",
          "package": "HaskellForMaths",
          "signature": "[Permutation t]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:order"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "orderBSGS",
          "package": "HaskellForMaths",
          "signature": "[(a1, Map k a)] -\u003e Integer",
          "source": "src/Math-Algebra-Group-SchreierSims.html#orderBSGS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "orderBSGS",
          "normalized": "[(a,Map b a)]-\u003eInteger",
          "package": "HaskellForMaths",
          "partial": "BSGS",
          "signature": "[(a,Map k a)]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:orderBSGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "reduceGens",
          "package": "HaskellForMaths",
          "signature": "[Permutation k] -\u003e [Permutation k]",
          "source": "src/Math-Algebra-Group-SchreierSims.html#reduceGens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "reduceGens",
          "normalized": "[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Gens",
          "signature": "[Permutation k]-\u003e[Permutation k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:reduceGens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "reduceGensBSGS",
          "package": "HaskellForMaths",
          "signature": "[Permutation k] -\u003e ([Permutation k], [(k, Map k (Permutation k))])",
          "source": "src/Math-Algebra-Group-SchreierSims.html#reduceGensBSGS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "reduceGensBSGS",
          "normalized": "[Permutation a]-\u003e([Permutation a],[(a,Map a(Permutation a))])",
          "package": "HaskellForMaths",
          "partial": "Gens BSGS",
          "signature": "[Permutation k]-\u003e([Permutation k],[(k,Map k(Permutation k))])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:reduceGensBSGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "schreierGeneratorsGx",
          "package": "HaskellForMaths",
          "signature": "(k, Map k (Permutation k)) -\u003e [Permutation k] -\u003e [Permutation k]",
          "source": "src/Math-Algebra-Group-SchreierSims.html#schreierGeneratorsGx",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "schreierGeneratorsGx",
          "normalized": "(a,Map a(Permutation a))-\u003e[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Generators Gx",
          "signature": "(k,Map k(Permutation k))-\u003e[Permutation k]-\u003e[Permutation k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:schreierGeneratorsGx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven generators for a permutation group, return a strong generating set.\n The result is calculated using Schreier-Sims algorithm, and is relative to the base implied by the Ord instance\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "sgs",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-SchreierSims.html#sgs",
          "type": "function"
        },
        "index": {
          "description": "Given generators for permutation group return strong generating set The result is calculated using Schreier-Sims algorithm and is relative to the base implied by the Ord instance",
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "sgs",
          "normalized": "[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "signature": "[Permutation a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:sgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "sift",
          "package": "HaskellForMaths",
          "signature": "[(k, Map k (Permutation k))] -\u003e Permutation k -\u003e Maybe (Permutation k)",
          "source": "src/Math-Algebra-Group-SchreierSims.html#sift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "sift",
          "normalized": "[(a,Map a(Permutation a))]-\u003ePermutation a-\u003eMaybe(Permutation a)",
          "package": "HaskellForMaths",
          "signature": "[(k,Map k(Permutation k))]-\u003ePermutation k-\u003eMaybe(Permutation k)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:sift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "ss",
          "package": "HaskellForMaths",
          "signature": "[k] -\u003e [Permutation k] -\u003e [((k, Map k (Permutation k)), [Permutation k])]",
          "source": "src/Math-Algebra-Group-SchreierSims.html#ss",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "ss",
          "normalized": "[a]-\u003e[Permutation a]-\u003e[((a,Map a(Permutation a)),[Permutation a])]",
          "package": "HaskellForMaths",
          "signature": "[k]-\u003e[Permutation k]-\u003e[((k,Map k(Permutation k)),[Permutation k])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:ss"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "ss'",
          "package": "HaskellForMaths",
          "signature": "[k] -\u003e [((k, Map k (Permutation k)), [Permutation k])] -\u003e [((k, Map k (Permutation k)), [Permutation k])] -\u003e [((k, Map k (Permutation k)), [Permutation k])]",
          "source": "src/Math-Algebra-Group-SchreierSims.html#ss%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group SchreierSims",
          "module": "Math.Algebra.Group.SchreierSims",
          "name": "ss'",
          "normalized": "[a]-\u003e[((a,Map a(Permutation a)),[Permutation a])]-\u003e[((a,Map a(Permutation a)),[Permutation a])]-\u003e[((a,Map a(Permutation a)),[Permutation a])]",
          "package": "HaskellForMaths",
          "signature": "[k]-\u003e[((k,Map k(Permutation k)),[Permutation k])]-\u003e[((k,Map k(Permutation k)),[Permutation k])]-\u003e[((k,Map k(Permutation k)),[Permutation k])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-SchreierSims.html#v:ss-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "StringRewriting",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Group-StringRewriting.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "StringRewriting",
          "package": "HaskellForMaths",
          "partial": "String Rewriting",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "SGen",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Group-StringRewriting.html#SGen",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "SGen",
          "package": "HaskellForMaths",
          "partial": "SGen",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#t:SGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "S",
          "package": "HaskellForMaths",
          "signature": "S Int",
          "source": "src/Math-Algebra-Group-StringRewriting.html#SGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "S",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "_D",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Int -\u003e Int -\u003e ([Char], [([Char], [Char])])",
          "source": "src/Math-Algebra-Group-StringRewriting.html#_D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "_D",
          "normalized": "Int-\u003eInt-\u003eInt-\u003e([Char],[([Char],[Char])])",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eInt-\u003eInt-\u003e([Char],[([Char],[Char])])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:_D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "_S",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e ([SGen], [([SGen], [a])])",
          "source": "src/Math-Algebra-Group-StringRewriting.html#_S",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "_S",
          "normalized": "Int-\u003e([SGen],[([SGen],[a])])",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e([SGen],[([SGen],[a])])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:_S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "_S'",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e ([SGen], [([SGen], [SGen])])",
          "source": "src/Math-Algebra-Group-StringRewriting.html#_S%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "_S'",
          "normalized": "Int-\u003e([SGen],[([SGen],[SGen])])",
          "package": "HaskellForMaths",
          "partial": "S'",
          "signature": "Int-\u003e([SGen],[([SGen],[SGen])])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:_S-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven generators and relations, return (normal forms of) all elements\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "elts",
          "package": "HaskellForMaths",
          "signature": "([a], [([a], [a])]) -\u003e [[a]]",
          "source": "src/Math-Algebra-Group-StringRewriting.html#elts",
          "type": "function"
        },
        "index": {
          "description": "Given generators and relations return normal forms of all elements",
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "elts",
          "normalized": "([a],[([a],[a])])-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "([a],[([a],[a])])-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:elts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "findOverlap",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e Maybe ([a], [a], [a])",
          "source": "src/Math-Algebra-Group-StringRewriting.html#findOverlap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "findOverlap",
          "normalized": "[a]-\u003e[a]-\u003eMaybe([a],[a],[a])",
          "package": "HaskellForMaths",
          "partial": "Overlap",
          "signature": "[a]-\u003e[a]-\u003eMaybe([a],[a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:findOverlap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplementation of the Knuth-Bendix algorithm. Given a list of relations, return a confluent rewrite system.\n The algorithm is not guaranteed to terminate.\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "knuthBendix",
          "package": "HaskellForMaths",
          "signature": "[([a], [a])] -\u003e [([a], [a])]",
          "source": "src/Math-Algebra-Group-StringRewriting.html#knuthBendix",
          "type": "function"
        },
        "index": {
          "description": "Implementation of the Knuth-Bendix algorithm Given list of relations return confluent rewrite system The algorithm is not guaranteed to terminate",
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "knuthBendix",
          "normalized": "[([a],[a])]-\u003e[([a],[a])]",
          "package": "HaskellForMaths",
          "partial": "Bendix",
          "signature": "[([a],[a])]-\u003e[([a],[a])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:knuthBendix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "knuthBendix1",
          "package": "HaskellForMaths",
          "signature": "[([a], [a])] -\u003e [([a], [a])]",
          "source": "src/Math-Algebra-Group-StringRewriting.html#knuthBendix1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "knuthBendix1",
          "normalized": "[([a],[a])]-\u003e[([a],[a])]",
          "package": "HaskellForMaths",
          "partial": "Bendix",
          "signature": "[([a],[a])]-\u003e[([a],[a])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:knuthBendix1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "knuthBendix2",
          "package": "HaskellForMaths",
          "signature": "[([a], [a])] -\u003e [([a], [a])]",
          "source": "src/Math-Algebra-Group-StringRewriting.html#knuthBendix2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "knuthBendix2",
          "normalized": "[([a],[a])]-\u003e[([a],[a])]",
          "package": "HaskellForMaths",
          "partial": "Bendix",
          "signature": "[([a],[a])]-\u003e[([a],[a])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:knuthBendix2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "knuthBendix3",
          "package": "HaskellForMaths",
          "signature": "[([a], [a])] -\u003e [([a], [a])]",
          "source": "src/Math-Algebra-Group-StringRewriting.html#knuthBendix3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "knuthBendix3",
          "normalized": "[([a],[a])]-\u003e[([a],[a])]",
          "package": "HaskellForMaths",
          "partial": "Bendix",
          "signature": "[([a],[a])]-\u003e[([a],[a])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:knuthBendix3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "merge",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Algebra-Group-StringRewriting.html#merge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "merge",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:merge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven generators and a confluent rewrite system, return (normal forms of) all elements\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "nfs",
          "package": "HaskellForMaths",
          "signature": "([a], [([a], [a])]) -\u003e [[a]]",
          "source": "src/Math-Algebra-Group-StringRewriting.html#nfs",
          "type": "function"
        },
        "index": {
          "description": "Given generators and confluent rewrite system return normal forms of all elements",
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "nfs",
          "normalized": "([a],[([a],[a])])-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "([a],[([a],[a])])-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:nfs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "ordpair",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e Maybe ([a], [a])",
          "source": "src/Math-Algebra-Group-StringRewriting.html#ordpair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "ordpair",
          "normalized": "[a]-\u003e[a]-\u003eMaybe([a],[a])",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003eMaybe([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:ordpair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list of rewrite rules of the form (left,right), and a word,\n rewrite it by repeatedly replacing any left substring in the word by the corresponding right\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "rewrite",
          "package": "HaskellForMaths",
          "signature": "[([a], [a])] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Algebra-Group-StringRewriting.html#rewrite",
          "type": "function"
        },
        "index": {
          "description": "Given list of rewrite rules of the form left right and word rewrite it by repeatedly replacing any left substring in the word by the corresponding right",
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "rewrite",
          "normalized": "[([a],[a])]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[([a],[a])]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:rewrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "rewrite1",
          "package": "HaskellForMaths",
          "signature": "([a], [a]) -\u003e [a] -\u003e Maybe [a]",
          "source": "src/Math-Algebra-Group-StringRewriting.html#rewrite1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "rewrite1",
          "normalized": "([a],[a])-\u003e[a]-\u003eMaybe[a]",
          "package": "HaskellForMaths",
          "signature": "([a],[a])-\u003e[a]-\u003eMaybe[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:rewrite1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "s1",
          "package": "HaskellForMaths",
          "signature": "SGen",
          "source": "src/Math-Algebra-Group-StringRewriting.html#s1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "s1",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:s1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "s2",
          "package": "HaskellForMaths",
          "signature": "SGen",
          "source": "src/Math-Algebra-Group-StringRewriting.html#s2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "s2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:s2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "s3",
          "package": "HaskellForMaths",
          "signature": "SGen",
          "source": "src/Math-Algebra-Group-StringRewriting.html#s3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "s3",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:s3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "s_",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e SGen",
          "source": "src/Math-Algebra-Group-StringRewriting.html#s_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "s_",
          "normalized": "Int-\u003eSGen",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eSGen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:s_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "shortlex",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e Ordering",
          "source": "src/Math-Algebra-Group-StringRewriting.html#shortlex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "shortlex",
          "normalized": "[a]-\u003e[a]-\u003eOrdering",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:shortlex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "splitSubstring",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e Maybe ([a], [a])",
          "source": "src/Math-Algebra-Group-StringRewriting.html#splitSubstring",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "splitSubstring",
          "normalized": "[a]-\u003e[a]-\u003eMaybe([a],[a])",
          "package": "HaskellForMaths",
          "partial": "Substring",
          "signature": "[a]-\u003e[a]-\u003eMaybe([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:splitSubstring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "tri",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Int -\u003e Int -\u003e ([Char], [([Char], [Char])])",
          "source": "src/Math-Algebra-Group-StringRewriting.html#tri",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group StringRewriting",
          "module": "Math.Algebra.Group.StringRewriting",
          "name": "tri",
          "normalized": "Int-\u003eInt-\u003eInt-\u003e([Char],[([Char],[Char])])",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eInt-\u003eInt-\u003e([Char],[([Char],[Char])])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-StringRewriting.html#v:tri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.Subquotients",
          "name": "Subquotients",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-Group-Subquotients.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "Subquotients",
          "package": "HaskellForMaths",
          "partial": "Subquotients",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a transitive group gs, and a block system for gs, return the kernel and image of the block homomorphism\n (the homomorphism onto the action of gs on the blocks)\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "blockHomomorphism",
          "package": "HaskellForMaths",
          "signature": "[Permutation t] -\u003e [[t]] -\u003e ([Permutation t], [Permutation [t]])",
          "source": "src/Math-Algebra-Group-Subquotients.html#blockHomomorphism",
          "type": "function"
        },
        "index": {
          "description": "Given transitive group gs and block system for gs return the kernel and image of the block homomorphism the homomorphism onto the action of gs on the blocks",
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "blockHomomorphism",
          "normalized": "[Permutation a]-\u003e[[a]]-\u003e([Permutation a],[Permutation[a]])",
          "package": "HaskellForMaths",
          "partial": "Homomorphism",
          "signature": "[Permutation t]-\u003e[[t]]-\u003e([Permutation t],[Permutation[t]])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:blockHomomorphism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.Subquotients",
          "name": "blockHomomorphism'",
          "package": "HaskellForMaths",
          "signature": "[Permutation t] -\u003e [[t]] -\u003e ([Permutation t], [Permutation [t]])",
          "source": "src/Math-Algebra-Group-Subquotients.html#blockHomomorphism%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "blockHomomorphism'",
          "normalized": "[Permutation a]-\u003e[[a]]-\u003e([Permutation a],[Permutation[a]])",
          "package": "HaskellForMaths",
          "partial": "Homomorphism'",
          "signature": "[Permutation t]-\u003e[[t]]-\u003e([Permutation t],[Permutation[t]])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:blockHomomorphism-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a transitive group gs, find all non-trivial block systems. That is, if gs act on xs,\n find all the ways that the xs can be divided into blocks, such that the gs also have a permutation action on the blocks\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "blockSystems",
          "package": "HaskellForMaths",
          "signature": "[Permutation t] -\u003e [[[t]]]",
          "source": "src/Math-Algebra-Group-Subquotients.html#blockSystems",
          "type": "function"
        },
        "index": {
          "description": "Given transitive group gs find all non-trivial block systems That is if gs act on xs find all the ways that the xs can be divided into blocks such that the gs also have permutation action on the blocks",
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "blockSystems",
          "normalized": "[Permutation a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "Systems",
          "signature": "[Permutation t]-\u003e[[[t]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:blockSystems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA more efficient version of blockSystems, if we have an sgs\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "blockSystemsSGS",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [[[a]]]",
          "source": "src/Math-Algebra-Group-Subquotients.html#blockSystemsSGS",
          "type": "function"
        },
        "index": {
          "description": "more efficient version of blockSystems if we have an sgs",
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "blockSystemsSGS",
          "normalized": "[Permutation a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "Systems SGS",
          "signature": "[Permutation a]-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:blockSystemsSGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.Subquotients",
          "name": "centralizerSymTrans",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-Subquotients.html#centralizerSymTrans",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "centralizerSymTrans",
          "normalized": "[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Sym Trans",
          "signature": "[Permutation a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:centralizerSymTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.Subquotients",
          "name": "intersectionNormalClosure",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-Subquotients.html#intersectionNormalClosure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "intersectionNormalClosure",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Normal Closure",
          "signature": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:intersectionNormalClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.Subquotients",
          "name": "isLeft",
          "package": "HaskellForMaths",
          "signature": "Either t t1 -\u003e Bool",
          "source": "src/Math-Algebra-Group-Subquotients.html#isLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "isLeft",
          "normalized": "Either a a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Left",
          "signature": "Either t t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:isLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA permutation group is primitive if it has no non-trivial block systems\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "isPrimitive",
          "package": "HaskellForMaths",
          "signature": "[Permutation t] -\u003e Bool",
          "source": "src/Math-Algebra-Group-Subquotients.html#isPrimitive",
          "type": "function"
        },
        "index": {
          "description": "permutation group is primitive if it has no non-trivial block systems",
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "isPrimitive",
          "normalized": "[Permutation a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Primitive",
          "signature": "[Permutation t]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:isPrimitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.Subquotients",
          "name": "isPrimitiveSGS",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e Bool",
          "source": "src/Math-Algebra-Group-Subquotients.html#isPrimitiveSGS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "isPrimitiveSGS",
          "normalized": "[Permutation a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Primitive SGS",
          "signature": "[Permutation a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:isPrimitiveSGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.Subquotients",
          "name": "isRight",
          "package": "HaskellForMaths",
          "signature": "Either t t1 -\u003e Bool",
          "source": "src/Math-Algebra-Group-Subquotients.html#isRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "isRight",
          "normalized": "Either a a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Right",
          "signature": "Either t t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:isRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.Subquotients",
          "name": "isTransitive",
          "package": "HaskellForMaths",
          "signature": "[Permutation t] -\u003e Bool",
          "source": "src/Math-Algebra-Group-Subquotients.html#isTransitive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "isTransitive",
          "normalized": "[Permutation a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Transitive",
          "signature": "[Permutation t]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:isTransitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.Subquotients",
          "name": "minimalBlock",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [a] -\u003e [[a]]",
          "source": "src/Math-Algebra-Group-Subquotients.html#minimalBlock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "minimalBlock",
          "normalized": "[Permutation a]-\u003e[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Block",
          "signature": "[Permutation a]-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:minimalBlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.Subquotients",
          "name": "normalClosure",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [Permutation a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-Subquotients.html#normalClosure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "normalClosure",
          "normalized": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Closure",
          "signature": "[Permutation a]-\u003e[Permutation a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:normalClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.Subquotients",
          "name": "ptStab",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [a] -\u003e [Permutation a]",
          "source": "src/Math-Algebra-Group-Subquotients.html#ptStab",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "ptStab",
          "normalized": "[Permutation a]-\u003e[a]-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Stab",
          "signature": "[Permutation a]-\u003e[a]-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:ptStab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.Subquotients",
          "name": "restrictLeft",
          "package": "HaskellForMaths",
          "signature": "Permutation (Either a t) -\u003e Permutation a",
          "source": "src/Math-Algebra-Group-Subquotients.html#restrictLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "restrictLeft",
          "normalized": "Permutation(Either a b)-\u003ePermutation a",
          "package": "HaskellForMaths",
          "partial": "Left",
          "signature": "Permutation(Either a t)-\u003ePermutation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:restrictLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a group gs and a transitive constituent ys, return the kernel and image of the transitive constituent homomorphism.\n That is, suppose that gs acts on a set xs, and ys is a subset of xs on which gs acts transitively.\n Then the transitive constituent homomorphism is the restriction of the action of gs to an action on the ys.\n\u003c/p\u003e",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "transitiveConstituentHomomorphism",
          "package": "HaskellForMaths",
          "signature": "[Permutation a] -\u003e [a] -\u003e ([Permutation a], [Permutation a])",
          "source": "src/Math-Algebra-Group-Subquotients.html#transitiveConstituentHomomorphism",
          "type": "function"
        },
        "index": {
          "description": "Given group gs and transitive constituent ys return the kernel and image of the transitive constituent homomorphism That is suppose that gs acts on set xs and ys is subset of xs on which gs acts transitively Then the transitive constituent homomorphism is the restriction of the action of gs to an action on the ys",
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "transitiveConstituentHomomorphism",
          "normalized": "[Permutation a]-\u003e[a]-\u003e([Permutation a],[Permutation a])",
          "package": "HaskellForMaths",
          "partial": "Constituent Homomorphism",
          "signature": "[Permutation a]-\u003e[a]-\u003e([Permutation a],[Permutation a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:transitiveConstituentHomomorphism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.Subquotients",
          "name": "transitiveConstituentHomomorphism'",
          "package": "HaskellForMaths",
          "signature": "[Permutation t] -\u003e [t] -\u003e ([Permutation t], [Permutation t])",
          "source": "src/Math-Algebra-Group-Subquotients.html#transitiveConstituentHomomorphism%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "transitiveConstituentHomomorphism'",
          "normalized": "[Permutation a]-\u003e[a]-\u003e([Permutation a],[Permutation a])",
          "package": "HaskellForMaths",
          "partial": "Constituent Homomorphism'",
          "signature": "[Permutation t]-\u003e[t]-\u003e([Permutation t],[Permutation t])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:transitiveConstituentHomomorphism-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.Group.Subquotients",
          "name": "unRight",
          "package": "HaskellForMaths",
          "signature": "Permutation (Either t a) -\u003e Permutation a",
          "source": "src/Math-Algebra-Group-Subquotients.html#unRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra Group Subquotients",
          "module": "Math.Algebra.Group.Subquotients",
          "name": "unRight",
          "normalized": "Permutation(Either a b)-\u003ePermutation b",
          "package": "HaskellForMaths",
          "partial": "Right",
          "signature": "Permutation(Either t a)-\u003ePermutation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-Group-Subquotients.html#v:unRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module providing elementary operations involving scalars, vectors, and matrices\n over a ring or field. Vectors are represented as [a], matrices as [[a]].\n (No distinction is made between row and column vectors.)\n It is the caller's responsibility to ensure that the lists have the correct number of elements.\n\u003c/p\u003e\u003cp\u003eThe mnemonic for many of the arithmetic operations is that the number of angle brackets\n on each side indicates the dimension of the argument on that side. For example,\n v \u003c*\u003e\u003e m is multiplication of a vector on the left by a matrix on the right.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "LinearAlgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-LinearAlgebra.html",
          "type": "module"
        },
        "index": {
          "description": "module providing elementary operations involving scalars vectors and matrices over ring or field Vectors are represented as matrices as No distinction is made between row and column vectors It is the caller responsibility to ensure that the lists have the correct number of elements The mnemonic for many of the arithmetic operations is that the number of angle brackets on each side indicates the dimension of the argument on that side For example is multiplication of vector on the left by matrix on the right",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "LinearAlgebra",
          "package": "HaskellForMaths",
          "partial": "Linear Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(!)",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Int -\u003e a",
          "source": "src/Math-Algebra-LinearAlgebra.html#%21",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(!) !",
          "normalized": "[a]-\u003eInt-\u003ea",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:-33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ek *\u003e v returns the product k*v of the scalar k and the vector v\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(*\u003e)",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/Math-Algebra-LinearAlgebra.html#%2A%3E",
          "type": "function"
        },
        "index": {
          "description": "returns the product of the scalar and the vector",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(*\u003e) *\u003e",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:-42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ek *\u003e\u003e m returns the product k*m of the scalar k and the matrix m\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(*\u003e\u003e)",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [[a]] -\u003e [[a]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#%2A%3E%3E",
          "type": "function"
        },
        "index": {
          "description": "returns the product of the scalar and the matrix",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(*\u003e\u003e) *\u003e\u003e",
          "normalized": "a-\u003e[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "a-\u003e[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:-42--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eu \u003c*\u003e v returns the tensor product of vectors (also called outer or matrix product)\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c*\u003e)",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [[a]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#%3C%2A%3E",
          "type": "function"
        },
        "index": {
          "description": "returns the tensor product of vectors also called outer or matrix product",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c*\u003e) \u003c*\u003e",
          "normalized": "[a]-\u003e[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:-60--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ev \u003c*\u003e\u003e m is multiplication of a vector by a matrix on the right\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c*\u003e\u003e)",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]] -\u003e [a]",
          "source": "src/Math-Algebra-LinearAlgebra.html#%3C%2A%3E%3E",
          "type": "function"
        },
        "index": {
          "description": "is multiplication of vector by matrix on the right",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c*\u003e\u003e) \u003c*\u003e\u003e",
          "normalized": "[a]-\u003e[[a]]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[[a]]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:-60--42--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eu \u003c+\u003e v returns the sum u+v of vectors\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c+\u003e)",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Algebra-LinearAlgebra.html#%3C%2B%3E",
          "type": "function"
        },
        "index": {
          "description": "returns the sum of vectors",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eu \u003c-\u003e v returns the difference u-v of vectors\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c-\u003e)",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Algebra-LinearAlgebra.html#%3C-%3E",
          "type": "function"
        },
        "index": {
          "description": "returns the difference u-v of vectors",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c-\u003e) \u003c-\u003e",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:-60--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003em \u003c\u003c*\u003e v is multiplication of a vector by a matrix on the left\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c\u003c*\u003e)",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Algebra-LinearAlgebra.html#%3C%3C%2A%3E",
          "type": "function"
        },
        "index": {
          "description": "is multiplication of vector by matrix on the left",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c\u003c*\u003e) \u003c\u003c*\u003e",
          "normalized": "[[a]]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:-60--60--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea \u003c\u003c*\u003e\u003e b returns the product a*b of matrices\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c\u003c*\u003e\u003e)",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]] -\u003e [[a]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#%3C%3C%2A%3E%3E",
          "type": "function"
        },
        "index": {
          "description": "returns the product of matrices",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c\u003c*\u003e\u003e) \u003c\u003c*\u003e\u003e",
          "normalized": "[[a]]-\u003e[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003e[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:-60--60--42--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea \u003c\u003c+\u003e\u003e b returns the sum a+b of matrices\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c\u003c+\u003e\u003e)",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]] -\u003e [[a]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#%3C%3C%2B%3E%3E",
          "type": "function"
        },
        "index": {
          "description": "returns the sum of matrices",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c\u003c+\u003e\u003e) \u003c\u003c+\u003e\u003e",
          "normalized": "[[a]]-\u003e[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003e[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:-60--60--43--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea \u003c\u003c-\u003e\u003e b returns the difference a-b of matrices\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c\u003c-\u003e\u003e)",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]] -\u003e [[a]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#%3C%3C-%3E%3E",
          "type": "function"
        },
        "index": {
          "description": "returns the difference a-b of matrices",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c\u003c-\u003e\u003e) \u003c\u003c-\u003e\u003e",
          "normalized": "[[a]]-\u003e[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003e[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:-60--60--45--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eu \u003c.\u003e v returns the dot product of vectors (also called inner or scalar product)\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c.\u003e)",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e a",
          "source": "src/Math-Algebra-LinearAlgebra.html#%3C.%3E",
          "type": "function"
        },
        "index": {
          "description": "returns the dot product of vectors also called inner or scalar product",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "(\u003c.\u003e) \u003c.\u003e",
          "normalized": "[a]-\u003e[a]-\u003ea",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:-60-.-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe determinant of a matrix (over a field)\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "det",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e a",
          "source": "src/Math-Algebra-LinearAlgebra.html#det",
          "type": "function"
        },
        "index": {
          "description": "The determinant of matrix over field",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "det",
          "normalized": "[[a]]-\u003ea",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:det"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.LinearAlgebra",
          "name": "fMatrix",
          "package": "HaskellForMaths",
          "signature": "t1 -\u003e (t1 -\u003e t1 -\u003e t) -\u003e [[t]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#fMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "fMatrix",
          "normalized": "a-\u003e(a-\u003ea-\u003ea)-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Matrix",
          "signature": "t-\u003e(t-\u003et-\u003et)-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:fMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.LinearAlgebra",
          "name": "fMatrix'",
          "package": "HaskellForMaths",
          "signature": "t1 -\u003e (t1 -\u003e t1 -\u003e t) -\u003e [[t]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#fMatrix%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "fMatrix'",
          "normalized": "a-\u003e(a-\u003ea-\u003ea)-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Matrix'",
          "signature": "t-\u003e(t-\u003et-\u003et)-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:fMatrix-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eiMx n is the n*n identity matrix\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "iMx",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [[t]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#iMx",
          "type": "function"
        },
        "index": {
          "description": "iMx is the identity matrix",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "iMx",
          "normalized": "Int-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Mx",
          "signature": "Int-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:iMx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.LinearAlgebra",
          "name": "idMx",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [[a]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#idMx",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "idMx",
          "normalized": "Int-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Mx",
          "signature": "Int-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:idMx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.LinearAlgebra",
          "name": "inSpanRE",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [a] -\u003e Bool",
          "source": "src/Math-Algebra-LinearAlgebra.html#inSpanRE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "inSpanRE",
          "normalized": "[[a]]-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Span RE",
          "signature": "[[a]]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:inSpanRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe inverse of a matrix (over a field), if it exists\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "inverse",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Maybe [[a]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#inverse",
          "type": "function"
        },
        "index": {
          "description": "The inverse of matrix over field if it exists",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "inverse",
          "normalized": "[[a]]-\u003eMaybe[[a]]",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003eMaybe[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:inverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.LinearAlgebra",
          "name": "inverse1",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#inverse1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "inverse1",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:inverse1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.LinearAlgebra",
          "name": "inverse2",
          "package": "HaskellForMaths",
          "signature": "[[t]] -\u003e [[t]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#inverse2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "inverse2",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[[t]]-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:inverse2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.LinearAlgebra",
          "name": "isZero",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Bool",
          "source": "src/Math-Algebra-LinearAlgebra.html#isZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "isZero",
          "normalized": "[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Zero",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:isZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ejMx n is the n*n matrix of all 1s\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "jMx",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [[t]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#jMx",
          "type": "function"
        },
        "index": {
          "description": "jMx is the matrix of all",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "jMx",
          "normalized": "Int-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Mx",
          "signature": "Int-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:jMx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.LinearAlgebra",
          "name": "kernel",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#kernel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "kernel",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:kernel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.LinearAlgebra",
          "name": "kernelRRE",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#kernelRRE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "kernelRRE",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "RRE",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:kernelRRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.LinearAlgebra",
          "name": "rank",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Int",
          "source": "src/Math-Algebra-LinearAlgebra.html#rank",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "rank",
          "normalized": "[[a]]-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:rank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.LinearAlgebra",
          "name": "reducedRowEchelonForm",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#reducedRowEchelonForm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "reducedRowEchelonForm",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Row Echelon Form",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:reducedRowEchelonForm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.LinearAlgebra",
          "name": "rowEchelonForm",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#rowEchelonForm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "rowEchelonForm",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Echelon Form",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:rowEchelonForm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.LinearAlgebra",
          "name": "solveLinearSystem",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [a] -\u003e Maybe [a]",
          "source": "src/Math-Algebra-LinearAlgebra.html#solveLinearSystem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "solveLinearSystem",
          "normalized": "[[a]]-\u003e[a]-\u003eMaybe[a]",
          "package": "HaskellForMaths",
          "partial": "Linear System",
          "signature": "[[a]]-\u003e[a]-\u003eMaybe[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:solveLinearSystem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ezMx n is the n*n matrix of all 0s\n\u003c/p\u003e",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "zMx",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [[t]]",
          "source": "src/Math-Algebra-LinearAlgebra.html#zMx",
          "type": "function"
        },
        "index": {
          "description": "zMx is the matrix of all",
          "hierarchy": "Math Algebra LinearAlgebra",
          "module": "Math.Algebra.LinearAlgebra",
          "name": "zMx",
          "normalized": "Int-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Mx",
          "signature": "Int-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-LinearAlgebra.html#v:zMx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "GSBasis",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-NonCommutative-GSBasis.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative GSBasis",
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "GSBasis",
          "package": "HaskellForMaths",
          "partial": "GSBasis",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-GSBasis.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "findOverlap",
          "package": "HaskellForMaths",
          "signature": "Monomial v -\u003e Monomial v -\u003e Maybe (Monomial v, Monomial v, Monomial v)",
          "source": "src/Math-Algebra-NonCommutative-GSBasis.html#findOverlap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative GSBasis",
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "findOverlap",
          "normalized": "Monomial a-\u003eMonomial a-\u003eMaybe(Monomial a,Monomial a,Monomial a)",
          "package": "HaskellForMaths",
          "partial": "Overlap",
          "signature": "Monomial v-\u003eMonomial v-\u003eMaybe(Monomial v,Monomial v,Monomial v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-GSBasis.html#v:findOverlap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "gb",
          "package": "HaskellForMaths",
          "signature": "[NPoly r v] -\u003e [NPoly r v]",
          "source": "src/Math-Algebra-NonCommutative-GSBasis.html#gb",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative GSBasis",
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "gb",
          "normalized": "[NPoly a b]-\u003e[NPoly a b]",
          "package": "HaskellForMaths",
          "signature": "[NPoly r v]-\u003e[NPoly r v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-GSBasis.html#v:gb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "gb'",
          "package": "HaskellForMaths",
          "signature": "[NPoly r v] -\u003e [NPoly r v]",
          "source": "src/Math-Algebra-NonCommutative-GSBasis.html#gb%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative GSBasis",
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "gb'",
          "normalized": "[NPoly a b]-\u003e[NPoly a b]",
          "package": "HaskellForMaths",
          "signature": "[NPoly r v]-\u003e[NPoly r v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-GSBasis.html#v:gb-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "gb1",
          "package": "HaskellForMaths",
          "signature": "[NPoly r v] -\u003e [NPoly r v]",
          "source": "src/Math-Algebra-NonCommutative-GSBasis.html#gb1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative GSBasis",
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "gb1",
          "normalized": "[NPoly a b]-\u003e[NPoly a b]",
          "package": "HaskellForMaths",
          "signature": "[NPoly r v]-\u003e[NPoly r v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-GSBasis.html#v:gb1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "gb2",
          "package": "HaskellForMaths",
          "signature": "[NPoly r v] -\u003e [NPoly r v]",
          "source": "src/Math-Algebra-NonCommutative-GSBasis.html#gb2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative GSBasis",
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "gb2",
          "normalized": "[NPoly a b]-\u003e[NPoly a b]",
          "package": "HaskellForMaths",
          "signature": "[NPoly r v]-\u003e[NPoly r v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-GSBasis.html#v:gb2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "gb2'",
          "package": "HaskellForMaths",
          "signature": "[NPoly t v] -\u003e [(NPoly t v, NPoly t v, NPoly t v, NPoly t v)]",
          "source": "src/Math-Algebra-NonCommutative-GSBasis.html#gb2%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative GSBasis",
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "gb2'",
          "normalized": "[NPoly a b]-\u003e[(NPoly a b,NPoly a b,NPoly a b,NPoly a b)]",
          "package": "HaskellForMaths",
          "signature": "[NPoly t v]-\u003e[(NPoly t v,NPoly t v,NPoly t v,NPoly t v)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-GSBasis.html#v:gb2-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "mbasisQA",
          "package": "HaskellForMaths",
          "signature": "[NPoly r v] -\u003e [NPoly r v] -\u003e [NPoly r v]",
          "source": "src/Math-Algebra-NonCommutative-GSBasis.html#mbasisQA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative GSBasis",
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "mbasisQA",
          "normalized": "[NPoly a b]-\u003e[NPoly a b]-\u003e[NPoly a b]",
          "package": "HaskellForMaths",
          "partial": "QA",
          "signature": "[NPoly r v]-\u003e[NPoly r v]-\u003e[NPoly r v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-GSBasis.html#v:mbasisQA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "reduce",
          "package": "HaskellForMaths",
          "signature": "[NPoly r v] -\u003e [NPoly r v]",
          "source": "src/Math-Algebra-NonCommutative-GSBasis.html#reduce",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative GSBasis",
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "reduce",
          "normalized": "[NPoly a b]-\u003e[NPoly a b]",
          "package": "HaskellForMaths",
          "signature": "[NPoly r v]-\u003e[NPoly r v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-GSBasis.html#v:reduce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "sPoly",
          "package": "HaskellForMaths",
          "signature": "NPoly t v -\u003e NPoly t v -\u003e NPoly t v",
          "source": "src/Math-Algebra-NonCommutative-GSBasis.html#sPoly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative GSBasis",
          "module": "Math.Algebra.NonCommutative.GSBasis",
          "name": "sPoly",
          "normalized": "NPoly a b-\u003eNPoly a b-\u003eNPoly a b",
          "package": "HaskellForMaths",
          "partial": "Poly",
          "signature": "NPoly t v-\u003eNPoly t v-\u003eNPoly t v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-GSBasis.html#v:sPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module providing a type for non-commutative polynomials.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "NCPoly",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html",
          "type": "module"
        },
        "index": {
          "description": "module providing type for non-commutative polynomials",
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "NCPoly",
          "package": "HaskellForMaths",
          "partial": "NCPoly",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "Invertible",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#Invertible",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "Invertible",
          "package": "HaskellForMaths",
          "partial": "Invertible",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#t:Invertible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "Monomial",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#Monomial",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "Monomial",
          "package": "HaskellForMaths",
          "partial": "Monomial",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#t:Monomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "NPoly",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#NPoly",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "NPoly",
          "package": "HaskellForMaths",
          "partial": "NPoly",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#t:NPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "Var",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#Var",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "Var",
          "package": "HaskellForMaths",
          "partial": "Var",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "(%%)",
          "package": "HaskellForMaths",
          "signature": "NPoly r v -\u003e [NPoly r v] -\u003e NPoly r v",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#%25%25",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "(%%) %%",
          "normalized": "NPoly a b-\u003e[NPoly a b]-\u003eNPoly a b",
          "package": "HaskellForMaths",
          "signature": "NPoly r v-\u003e[NPoly r v]-\u003eNPoly r v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:-37--37-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "(^-)",
          "package": "HaskellForMaths",
          "signature": "a -\u003e b -\u003e a",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#%5E-",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "(^-) ^-",
          "normalized": "a-\u003eb-\u003ea",
          "package": "HaskellForMaths",
          "signature": "a-\u003eb-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:-94--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "M",
          "package": "HaskellForMaths",
          "signature": "M [v]",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#Monomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "M",
          "normalized": "M[a]",
          "package": "HaskellForMaths",
          "signature": "M[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "NP",
          "package": "HaskellForMaths",
          "signature": "NP [(Monomial v, r)]",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#NPoly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "NP",
          "normalized": "NP[(Monomial a,b)]",
          "package": "HaskellForMaths",
          "partial": "NP",
          "signature": "NP[(Monomial v,r)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:NP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "X",
          "package": "HaskellForMaths",
          "signature": "X",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#Var",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "X",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "Y",
          "package": "HaskellForMaths",
          "signature": "Y",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#Var",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "Y",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "Z",
          "package": "HaskellForMaths",
          "signature": "Z",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#Var",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "Z",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "cmpTerm",
          "package": "HaskellForMaths",
          "signature": "(a, t) -\u003e (a, t1) -\u003e Ordering",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#cmpTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "cmpTerm",
          "normalized": "(a,b)-\u003e(a,b)-\u003eOrdering",
          "package": "HaskellForMaths",
          "partial": "Term",
          "signature": "(a,t)-\u003e(a,t)-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:cmpTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "collect",
          "package": "HaskellForMaths",
          "signature": "[(a, a1)] -\u003e [(a, a1)]",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#collect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "collect",
          "normalized": "[(a,a)]-\u003e[(a,a)]",
          "package": "HaskellForMaths",
          "signature": "[(a,a)]-\u003e[(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:collect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "divM",
          "package": "HaskellForMaths",
          "signature": "Monomial v -\u003e Monomial v -\u003e Maybe (Monomial v, Monomial v)",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#divM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "divM",
          "normalized": "Monomial a-\u003eMonomial a-\u003eMaybe(Monomial a,Monomial a)",
          "package": "HaskellForMaths",
          "signature": "Monomial v-\u003eMonomial v-\u003eMaybe(Monomial v,Monomial v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:divM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "inject",
          "package": "HaskellForMaths",
          "signature": "r -\u003e NPoly r v",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#inject",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "inject",
          "normalized": "a-\u003eNPoly a b",
          "package": "HaskellForMaths",
          "signature": "r-\u003eNPoly r v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:inject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "inv",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#inv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "inv",
          "normalized": "a-\u003ea",
          "package": "HaskellForMaths",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:inv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "lc",
          "package": "HaskellForMaths",
          "signature": "NPoly t t1 -\u003e t",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#lc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "lc",
          "normalized": "NPoly a a-\u003ea",
          "package": "HaskellForMaths",
          "signature": "NPoly t t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:lc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "lm",
          "package": "HaskellForMaths",
          "signature": "NPoly t t1 -\u003e Monomial t1",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#lm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "lm",
          "normalized": "NPoly a a-\u003eMonomial a",
          "package": "HaskellForMaths",
          "signature": "NPoly t t-\u003eMonomial t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:lm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "lt",
          "package": "HaskellForMaths",
          "signature": "NPoly r v -\u003e NPoly r v",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#lt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "lt",
          "normalized": "NPoly a b-\u003eNPoly a b",
          "package": "HaskellForMaths",
          "signature": "NPoly r v-\u003eNPoly r v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:lt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "mergeTerms",
          "package": "HaskellForMaths",
          "signature": "[(a, a1)] -\u003e [(a, a1)] -\u003e [(a, a1)]",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#mergeTerms",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "mergeTerms",
          "normalized": "[(a,a)]-\u003e[(a,a)]-\u003e[(a,a)]",
          "package": "HaskellForMaths",
          "partial": "Terms",
          "signature": "[(a,a)]-\u003e[(a,a)]-\u003e[(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:mergeTerms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "quotRemNP",
          "package": "HaskellForMaths",
          "signature": "NPoly r v -\u003e [NPoly r v] -\u003e ([(NPoly r v, NPoly r v)], NPoly r v)",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#quotRemNP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "quotRemNP",
          "normalized": "NPoly a b-\u003e[NPoly a b]-\u003e([(NPoly a b,NPoly a b)],NPoly a b)",
          "package": "HaskellForMaths",
          "partial": "Rem NP",
          "signature": "NPoly r v-\u003e[NPoly r v]-\u003e([(NPoly r v,NPoly r v)],NPoly r v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:quotRemNP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "remNP",
          "package": "HaskellForMaths",
          "signature": "NPoly r v -\u003e [NPoly r v] -\u003e NPoly r v",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#remNP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "remNP",
          "normalized": "NPoly a b-\u003e[NPoly a b]-\u003eNPoly a b",
          "package": "HaskellForMaths",
          "partial": "NP",
          "signature": "NPoly r v-\u003e[NPoly r v]-\u003eNPoly r v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:remNP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "remNP2",
          "package": "HaskellForMaths",
          "signature": "NPoly r v -\u003e [NPoly r v] -\u003e NPoly r v",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#remNP2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "remNP2",
          "normalized": "NPoly a b-\u003e[NPoly a b]-\u003eNPoly a b",
          "package": "HaskellForMaths",
          "partial": "NP",
          "signature": "NPoly r v-\u003e[NPoly r v]-\u003eNPoly r v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:remNP2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "subst",
          "package": "HaskellForMaths",
          "signature": "[(NPoly r v, NPoly r1 v1)] -\u003e NPoly r1 v -\u003e NPoly r1 v1",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#subst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "subst",
          "normalized": "[(NPoly a b,NPoly a b)]-\u003eNPoly a b-\u003eNPoly a b",
          "package": "HaskellForMaths",
          "signature": "[(NPoly r v,NPoly r v)]-\u003eNPoly r v-\u003eNPoly r v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:subst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "toMonic",
          "package": "HaskellForMaths",
          "signature": "NPoly r v -\u003e NPoly r v",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#toMonic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "toMonic",
          "normalized": "NPoly a b-\u003eNPoly a b",
          "package": "HaskellForMaths",
          "partial": "Monic",
          "signature": "NPoly r v-\u003eNPoly r v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:toMonic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a non-commutative variable for use in forming non-commutative polynomials.\n For example, we could define x = var \u003ca\u003ex\u003c/a\u003e, y = var \u003ca\u003ey\u003c/a\u003e. Then x*y /= y*x.\n\u003c/p\u003e",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "var",
          "package": "HaskellForMaths",
          "signature": "v -\u003e NPoly k v",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#var",
          "type": "function"
        },
        "index": {
          "description": "Create non-commutative variable for use in forming non-commutative polynomials For example we could define var var Then",
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "var",
          "normalized": "a-\u003eNPoly b a",
          "package": "HaskellForMaths",
          "signature": "v-\u003eNPoly k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "x",
          "package": "HaskellForMaths",
          "signature": "NPoly Q Var",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#x",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "x",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:x"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "y",
          "package": "HaskellForMaths",
          "signature": "NPoly Q Var",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "y",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "z",
          "package": "HaskellForMaths",
          "signature": "NPoly Q Var",
          "source": "src/Math-Algebra-NonCommutative-NCPoly.html#z",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative NCPoly",
          "module": "Math.Algebra.NonCommutative.NCPoly",
          "name": "z",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-NCPoly.html#v:z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining the tensor, symmetric, and exterior algebras.\n This module has been partially superceded by Math.Algebras.TensorAlgebra, which should be used in preference.\n This module is likely to be removed at some point.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "TensorAlgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html",
          "type": "module"
        },
        "index": {
          "description": "module defining the tensor symmetric and exterior algebras This module has been partially superceded by Math.Algebras.TensorAlgebra which should be used in preference This module is likely to be removed at some point",
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "TensorAlgebra",
          "package": "HaskellForMaths",
          "partial": "Tensor Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "Basis",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#Basis",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "Basis",
          "package": "HaskellForMaths",
          "partial": "Basis",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#t:Basis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "WeylGens",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#WeylGens",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "WeylGens",
          "package": "HaskellForMaths",
          "partial": "Weyl Gens",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#t:WeylGens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "D",
          "package": "HaskellForMaths",
          "signature": "D Int",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#WeylGens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "D",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "E",
          "package": "HaskellForMaths",
          "signature": "E Int",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#Basis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "E",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "X",
          "package": "HaskellForMaths",
          "signature": "X Int",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#WeylGens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "X",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "comm",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#comm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "comm",
          "normalized": "a-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:comm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "d1",
          "package": "HaskellForMaths",
          "signature": "NPoly Q WeylGens",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#d1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "d1",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:d1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "d2",
          "package": "HaskellForMaths",
          "signature": "NPoly Q WeylGens",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#d2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "d2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:d2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "d3",
          "package": "HaskellForMaths",
          "signature": "NPoly Q WeylGens",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#d3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "d3",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:d3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "d_",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e NPoly Q WeylGens",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#d_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "d_",
          "normalized": "Int-\u003eNPoly Q WeylGens",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eNPoly Q WeylGens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:d_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "delta",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a -\u003e a1",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#delta",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "delta",
          "normalized": "a-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:delta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "dim",
          "package": "HaskellForMaths",
          "signature": "NPoly t Basis -\u003e Int",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#dim",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "dim",
          "normalized": "NPoly a Basis-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "NPoly t Basis-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:dim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "e1",
          "package": "HaskellForMaths",
          "signature": "NPoly Q Basis",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#e1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "e1",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:e1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "e2",
          "package": "HaskellForMaths",
          "signature": "NPoly Q Basis",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#e2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "e2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:e2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "e3",
          "package": "HaskellForMaths",
          "signature": "NPoly Q Basis",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#e3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "e3",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:e3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "e4",
          "package": "HaskellForMaths",
          "signature": "NPoly Q Basis",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#e4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "e4",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:e4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "e_",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e NPoly Q Basis",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#e_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "e_",
          "normalized": "Int-\u003eNPoly Q Basis",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eNPoly Q Basis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:e_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "extRelations",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [NPoly Q Basis]",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#extRelations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "extRelations",
          "normalized": "Int-\u003e[NPoly Q Basis]",
          "package": "HaskellForMaths",
          "partial": "Relations",
          "signature": "Int-\u003e[NPoly Q Basis]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:extRelations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "exteriorBasis",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [NPoly Q Basis]",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#exteriorBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "exteriorBasis",
          "normalized": "Int-\u003e[NPoly Q Basis]",
          "package": "HaskellForMaths",
          "partial": "Basis",
          "signature": "Int-\u003e[NPoly Q Basis]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:exteriorBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "extnf",
          "package": "HaskellForMaths",
          "signature": "NPoly Q Basis -\u003e NPoly Q Basis",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#extnf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "extnf",
          "normalized": "NPoly Q Basis-\u003eNPoly Q Basis",
          "package": "HaskellForMaths",
          "signature": "NPoly Q Basis-\u003eNPoly Q Basis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:extnf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "symRelations",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [NPoly Q Basis]",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#symRelations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "symRelations",
          "normalized": "Int-\u003e[NPoly Q Basis]",
          "package": "HaskellForMaths",
          "partial": "Relations",
          "signature": "Int-\u003e[NPoly Q Basis]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:symRelations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "symmetricBasis",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [NPoly Q Basis]",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#symmetricBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "symmetricBasis",
          "normalized": "Int-\u003e[NPoly Q Basis]",
          "package": "HaskellForMaths",
          "partial": "Basis",
          "signature": "Int-\u003e[NPoly Q Basis]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:symmetricBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "symnf",
          "package": "HaskellForMaths",
          "signature": "NPoly Q Basis -\u003e NPoly Q Basis",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#symnf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "symnf",
          "normalized": "NPoly Q Basis-\u003eNPoly Q Basis",
          "package": "HaskellForMaths",
          "signature": "NPoly Q Basis-\u003eNPoly Q Basis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:symnf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "tensorBasis",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [NPoly Q Basis]",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#tensorBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "tensorBasis",
          "normalized": "Int-\u003e[NPoly Q Basis]",
          "package": "HaskellForMaths",
          "partial": "Basis",
          "signature": "Int-\u003e[NPoly Q Basis]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:tensorBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "weylBasis",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [NPoly Q Basis]",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#weylBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "weylBasis",
          "normalized": "Int-\u003e[NPoly Q Basis]",
          "package": "HaskellForMaths",
          "partial": "Basis",
          "signature": "Int-\u003e[NPoly Q Basis]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:weylBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "weylBasis'",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [NPoly Q WeylGens]",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#weylBasis%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "weylBasis'",
          "normalized": "Int-\u003e[NPoly Q WeylGens]",
          "package": "HaskellForMaths",
          "partial": "Basis'",
          "signature": "Int-\u003e[NPoly Q WeylGens]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:weylBasis-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "weylRelations",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [NPoly Q Basis]",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#weylRelations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "weylRelations",
          "normalized": "Int-\u003e[NPoly Q Basis]",
          "package": "HaskellForMaths",
          "partial": "Relations",
          "signature": "Int-\u003e[NPoly Q Basis]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:weylRelations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "weylRelations'",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [NPoly Q WeylGens]",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#weylRelations%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "weylRelations'",
          "normalized": "Int-\u003e[NPoly Q WeylGens]",
          "package": "HaskellForMaths",
          "partial": "Relations'",
          "signature": "Int-\u003e[NPoly Q WeylGens]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:weylRelations-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "weylnf",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e NPoly Q Basis -\u003e NPoly Q Basis",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#weylnf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "weylnf",
          "normalized": "Int-\u003eNPoly Q Basis-\u003eNPoly Q Basis",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eNPoly Q Basis-\u003eNPoly Q Basis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:weylnf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "weylnf'",
          "package": "HaskellForMaths",
          "signature": "NPoly Q WeylGens -\u003e NPoly Q WeylGens",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#weylnf%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "weylnf'",
          "normalized": "NPoly Q WeylGens-\u003eNPoly Q WeylGens",
          "package": "HaskellForMaths",
          "signature": "NPoly Q WeylGens-\u003eNPoly Q WeylGens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:weylnf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "x1",
          "package": "HaskellForMaths",
          "signature": "NPoly Q WeylGens",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#x1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "x1",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:x1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "x2",
          "package": "HaskellForMaths",
          "signature": "NPoly Q WeylGens",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#x2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "x2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:x2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "x3",
          "package": "HaskellForMaths",
          "signature": "NPoly Q WeylGens",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#x3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "x3",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:x3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "x_",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e NPoly Q WeylGens",
          "source": "src/Math-Algebra-NonCommutative-TensorAlgebra.html#x_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebra NonCommutative TensorAlgebra",
          "module": "Math.Algebra.NonCommutative.TensorAlgebra",
          "name": "x_",
          "normalized": "Int-\u003eNPoly Q WeylGens",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eNPoly Q WeylGens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebra-NonCommutative-TensorAlgebra.html#v:x_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining the affine plane and its symmetries\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Algebras.AffinePlane",
          "name": "AffinePlane",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-AffinePlane.html",
          "type": "module"
        },
        "index": {
          "description": "module defining the affine plane and its symmetries",
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "AffinePlane",
          "package": "HaskellForMaths",
          "partial": "Affine Plane",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "ABCD",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-AffinePlane.html#ABCD",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "ABCD",
          "package": "HaskellForMaths",
          "partial": "ABCD",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#t:ABCD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "SL2",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-AffinePlane.html#SL2",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "SL2",
          "package": "HaskellForMaths",
          "partial": "SL",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#t:SL2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "XY",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-AffinePlane.html#XY",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "XY",
          "package": "HaskellForMaths",
          "partial": "XY",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#t:XY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "A",
          "package": "HaskellForMaths",
          "signature": "A",
          "source": "src/Math-Algebras-AffinePlane.html#ABCD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "A",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "B",
          "package": "HaskellForMaths",
          "signature": "B",
          "source": "src/Math-Algebras-AffinePlane.html#ABCD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "B",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#v:B"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "C",
          "package": "HaskellForMaths",
          "signature": "C",
          "source": "src/Math-Algebras-AffinePlane.html#ABCD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "C",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "D",
          "package": "HaskellForMaths",
          "signature": "D",
          "source": "src/Math-Algebras-AffinePlane.html#ABCD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "D",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#v:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "SL2",
          "package": "HaskellForMaths",
          "signature": "SL2 (GlexMonomial v)",
          "source": "src/Math-Algebras-AffinePlane.html#SL2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "SL2",
          "package": "HaskellForMaths",
          "partial": "SL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#v:SL2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "X",
          "package": "HaskellForMaths",
          "signature": "X",
          "source": "src/Math-Algebras-AffinePlane.html#XY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "X",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#v:X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "Y",
          "package": "HaskellForMaths",
          "signature": "Y",
          "source": "src/Math-Algebras-AffinePlane.html#XY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "Y",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#v:Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "a",
          "package": "HaskellForMaths",
          "signature": "Vect Q (m ABCD)",
          "source": "src/Math-Algebras-AffinePlane.html#a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "a",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#v:a"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "b",
          "package": "HaskellForMaths",
          "signature": "Vect Q (m ABCD)",
          "source": "src/Math-Algebras-AffinePlane.html#a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "b",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#v:b"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "c",
          "package": "HaskellForMaths",
          "signature": "Vect Q (m ABCD)",
          "source": "src/Math-Algebras-AffinePlane.html#a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "c",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#v:c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "d",
          "package": "HaskellForMaths",
          "signature": "Vect Q (m ABCD)",
          "source": "src/Math-Algebras-AffinePlane.html#a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "d",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#v:d"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "sl2Var",
          "package": "HaskellForMaths",
          "signature": "v -\u003e Vect k (SL2 v)",
          "source": "src/Math-Algebras-AffinePlane.html#sl2Var",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "sl2Var",
          "normalized": "a-\u003eVect b(SL a)",
          "package": "HaskellForMaths",
          "partial": "Var",
          "signature": "v-\u003eVect k(SL v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#v:sl2Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "x",
          "package": "HaskellForMaths",
          "signature": "GlexPoly Q XY",
          "source": "src/Math-Algebras-AffinePlane.html#x",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "x",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#v:x"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.AffinePlane",
          "name": "y",
          "package": "HaskellForMaths",
          "signature": "GlexPoly Q XY",
          "source": "src/Math-Algebras-AffinePlane.html#y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras AffinePlane",
          "module": "Math.Algebras.AffinePlane",
          "name": "y",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-AffinePlane.html#v:y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining the algebra of commutative polynomials over a field k\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Algebras.Commutative",
          "name": "Commutative",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Commutative.html",
          "type": "module"
        },
        "index": {
          "description": "module defining the algebra of commutative polynomials over field",
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "Commutative",
          "package": "HaskellForMaths",
          "partial": "Commutative",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Commutative",
          "name": "DivisionBasis",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Commutative.html#DivisionBasis",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "DivisionBasis",
          "package": "HaskellForMaths",
          "partial": "Division Basis",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#t:DivisionBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Commutative",
          "name": "GlexMonomial",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Commutative.html#GlexMonomial",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "GlexMonomial",
          "package": "HaskellForMaths",
          "partial": "Glex Monomial",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#t:GlexMonomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Commutative",
          "name": "GlexPoly",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Commutative.html#GlexPoly",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "GlexPoly",
          "package": "HaskellForMaths",
          "partial": "Glex Poly",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#t:GlexPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Commutative",
          "name": "Monomial",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Commutative.html#Monomial",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "Monomial",
          "package": "HaskellForMaths",
          "partial": "Monomial",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#t:Monomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(%%) reduces a polynomial with respect to a list of polynomials.\n\u003c/p\u003e",
          "module": "Math.Algebras.Commutative",
          "name": "(%%)",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e [Vect k b] -\u003e Vect k b",
          "source": "src/Math-Algebras-Commutative.html#%25%25",
          "type": "function"
        },
        "index": {
          "description": "reduces polynomial with respect to list of polynomials",
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "(%%) %%",
          "normalized": "Vect a b-\u003e[Vect a b]-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003e[Vect k b]-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#v:-37--37-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Commutative",
          "name": "Glex",
          "package": "HaskellForMaths",
          "signature": "Glex Int [(v, Int)]",
          "source": "src/Math-Algebras-Commutative.html#GlexMonomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "Glex",
          "normalized": "Glex Int[(a,Int)]",
          "package": "HaskellForMaths",
          "partial": "Glex",
          "signature": "Glex Int[(v,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#v:Glex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn effect, we have (Num k, Monomial m) =\u003e Monad (v -\u003e Vect k (m v)), with return = var, and (\u003e\u003e=) = bind.\n However, we can't express this directly in Haskell, firstly because of the Ord b constraint,\n secondly because Haskell doesn't support type functions.\n\u003c/p\u003e",
          "module": "Math.Algebras.Commutative",
          "name": "bind",
          "package": "HaskellForMaths",
          "signature": "Vect k (m v) -\u003e (v -\u003e Vect k b) -\u003e Vect k b",
          "source": "src/Math-Algebras-Commutative.html#bind",
          "type": "function"
        },
        "index": {
          "description": "In effect we have Num Monomial Monad Vect with return var and bind However we can express this directly in Haskell firstly because of the Ord constraint secondly because Haskell doesn support type functions",
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "bind",
          "normalized": "Vect a(b c)-\u003e(c-\u003eVect a d)-\u003eVect a d",
          "package": "HaskellForMaths",
          "signature": "Vect k(m v)-\u003e(v-\u003eVect k b)-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#v:bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Commutative",
          "name": "divB",
          "package": "HaskellForMaths",
          "signature": "b -\u003e b -\u003e b",
          "source": "src/Math-Algebras-Commutative.html#divB",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "divB",
          "normalized": "a-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "signature": "b-\u003eb-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#v:divB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Commutative",
          "name": "divT",
          "package": "HaskellForMaths",
          "signature": "(t, t1) -\u003e (t, t1) -\u003e (t, t1)",
          "source": "src/Math-Algebras-Commutative.html#divT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "divT",
          "normalized": "(a,a)-\u003e(a,a)-\u003e(a,a)",
          "package": "HaskellForMaths",
          "signature": "(t,t)-\u003e(t,t)-\u003e(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#v:divT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Commutative",
          "name": "dividesB",
          "package": "HaskellForMaths",
          "signature": "b -\u003e b -\u003e Bool",
          "source": "src/Math-Algebras-Commutative.html#dividesB",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "dividesB",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "b-\u003eb-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#v:dividesB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Commutative",
          "name": "dividesT",
          "package": "HaskellForMaths",
          "signature": "(b, t) -\u003e (b, t1) -\u003e Bool",
          "source": "src/Math-Algebras-Commutative.html#dividesT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "dividesT",
          "normalized": "(a,b)-\u003e(a,b)-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "(b,t)-\u003e(b,t)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#v:dividesT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eglexVar creates a variable in the algebra of commutative polynomials with Glex term ordering.\n For example, the following code creates variables called x, y and z:\n\u003c/p\u003e\u003cpre\u003e [x,y,z] = map glexVar [\"x\",\"y\",\"z\"] :: GlexPoly Q String\n\u003c/pre\u003e",
          "module": "Math.Algebras.Commutative",
          "name": "glexVar",
          "package": "HaskellForMaths",
          "signature": "v -\u003e GlexPoly k v",
          "source": "src/Math-Algebras-Commutative.html#glexVar",
          "type": "function"
        },
        "index": {
          "description": "glexVar creates variable in the algebra of commutative polynomials with Glex term ordering For example the following code creates variables called and map glexVar GlexPoly String",
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "glexVar",
          "normalized": "a-\u003eGlexPoly b a",
          "package": "HaskellForMaths",
          "partial": "Var",
          "signature": "v-\u003eGlexPoly k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#v:glexVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Commutative",
          "name": "lt",
          "package": "HaskellForMaths",
          "signature": "Vect t t1 -\u003e (t1, t)",
          "source": "src/Math-Algebras-Commutative.html#lt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "lt",
          "normalized": "Vect a a-\u003e(a,a)",
          "package": "HaskellForMaths",
          "signature": "Vect t t-\u003e(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#v:lt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Commutative",
          "name": "powers",
          "package": "HaskellForMaths",
          "signature": "m v -\u003e [(v, Int)]",
          "source": "src/Math-Algebras-Commutative.html#powers",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "powers",
          "normalized": "a b-\u003e[(b,Int)]",
          "package": "HaskellForMaths",
          "signature": "m v-\u003e[(v,Int)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#v:powers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Commutative",
          "name": "quotRemMP",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e [Vect k b] -\u003e ([Vect k b], Vect k b)",
          "source": "src/Math-Algebras-Commutative.html#quotRemMP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "quotRemMP",
          "normalized": "Vect a b-\u003e[Vect a b]-\u003e([Vect a b],Vect a b)",
          "package": "HaskellForMaths",
          "partial": "Rem MP",
          "signature": "Vect k b-\u003e[Vect k b]-\u003e([Vect k b],Vect k b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#v:quotRemMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Commutative",
          "name": "var",
          "package": "HaskellForMaths",
          "signature": "v -\u003e Vect Q (m v)",
          "source": "src/Math-Algebras-Commutative.html#var",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras Commutative",
          "module": "Math.Algebras.Commutative",
          "name": "var",
          "normalized": "a-\u003eVect Q(b a)",
          "package": "HaskellForMaths",
          "signature": "v-\u003eVect Q(m v)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Commutative.html#v:var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module for doing arithmetic in the group algebra.\n\u003c/p\u003e\u003cp\u003eGroup elements are represented as permutations of the integers, and are entered and displayed\n using a Haskell-friendly version of cycle notation. For example, the permutation (1 2 3)(4 5)\n would be entered as \u003ccode\u003ep [[1,2,3],[4,5]]\u003c/code\u003e, and displayed as [[1,2,3],[4,5]].\n\u003c/p\u003e\u003cp\u003eGiven a field K and group G, the group algebra KG is the free K-vector space over the elements of G.\n Elements of the group algebra consist of arbitrary K-linear combinations of elements of G.\n For example, \u003ccode\u003ep [[1,2,3]] + 2 * p [[1,2],[3,4]]\u003c/code\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Algebras.GroupAlgebra",
          "name": "GroupAlgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-GroupAlgebra.html",
          "type": "module"
        },
        "index": {
          "description": "module for doing arithmetic in the group algebra Group elements are represented as permutations of the integers and are entered and displayed using Haskell-friendly version of cycle notation For example the permutation would be entered as and displayed as Given field and group the group algebra KG is the free K-vector space over the elements of Elements of the group algebra consist of arbitrary K-linear combinations of elements of For example",
          "hierarchy": "Math Algebras GroupAlgebra",
          "module": "Math.Algebras.GroupAlgebra",
          "name": "GroupAlgebra",
          "package": "HaskellForMaths",
          "partial": "Group Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-GroupAlgebra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.GroupAlgebra",
          "name": "GroupAlgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-GroupAlgebra.html#GroupAlgebra",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebras GroupAlgebra",
          "module": "Math.Algebras.GroupAlgebra",
          "name": "GroupAlgebra",
          "package": "HaskellForMaths",
          "partial": "Group Algebra",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-GroupAlgebra.html#t:GroupAlgebra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a permutation, as an element of the group algebra, from a list of cycles.\n For example, \u003ccode\u003ep [[1,2],[3,4,5]]\u003c/code\u003e constructs the permutation (1 2)(3 4 5), which is displayed\n as [[1,2],[3,4,5]].\n\u003c/p\u003e",
          "module": "Math.Algebras.GroupAlgebra",
          "name": "p",
          "package": "HaskellForMaths",
          "signature": "[[Int]] -\u003e GroupAlgebra Q",
          "source": "src/Math-Algebras-GroupAlgebra.html#p",
          "type": "function"
        },
        "index": {
          "description": "Construct permutation as an element of the group algebra from list of cycles For example constructs the permutation which is displayed as",
          "hierarchy": "Math Algebras GroupAlgebra",
          "module": "Math.Algebras.GroupAlgebra",
          "name": "p",
          "normalized": "[[Int]]-\u003eGroupAlgebra Q",
          "package": "HaskellForMaths",
          "signature": "[[Int]]-\u003eGroupAlgebra Q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-GroupAlgebra.html#v:p"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.LaurentPoly",
          "name": "LaurentPoly",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-LaurentPoly.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Algebras LaurentPoly",
          "module": "Math.Algebras.LaurentPoly",
          "name": "LaurentPoly",
          "package": "HaskellForMaths",
          "partial": "Laurent Poly",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-LaurentPoly.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.LaurentPoly",
          "name": "LaurentMonomial",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-LaurentPoly.html#LaurentMonomial",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebras LaurentPoly",
          "module": "Math.Algebras.LaurentPoly",
          "name": "LaurentMonomial",
          "package": "HaskellForMaths",
          "partial": "Laurent Monomial",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-LaurentPoly.html#t:LaurentMonomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.LaurentPoly",
          "name": "LaurentPoly",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-LaurentPoly.html#LaurentPoly",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebras LaurentPoly",
          "module": "Math.Algebras.LaurentPoly",
          "name": "LaurentPoly",
          "package": "HaskellForMaths",
          "partial": "Laurent Poly",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-LaurentPoly.html#t:LaurentPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.LaurentPoly",
          "name": "LM",
          "package": "HaskellForMaths",
          "signature": "LM Int [(String, Int)]",
          "source": "src/Math-Algebras-LaurentPoly.html#LaurentMonomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras LaurentPoly",
          "module": "Math.Algebras.LaurentPoly",
          "name": "LM",
          "normalized": "LM Int[(String,Int)]",
          "package": "HaskellForMaths",
          "partial": "LM",
          "signature": "LM Int[(String,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-LaurentPoly.html#v:LM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.LaurentPoly",
          "name": "lvar",
          "package": "HaskellForMaths",
          "signature": "String -\u003e LaurentPoly Q",
          "source": "src/Math-Algebras-LaurentPoly.html#lvar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras LaurentPoly",
          "module": "Math.Algebras.LaurentPoly",
          "name": "lvar",
          "normalized": "String-\u003eLaurentPoly Q",
          "package": "HaskellForMaths",
          "signature": "String-\u003eLaurentPoly Q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-LaurentPoly.html#v:lvar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.LaurentPoly",
          "name": "q",
          "package": "HaskellForMaths",
          "signature": "LaurentPoly Q",
          "source": "src/Math-Algebras-LaurentPoly.html#q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras LaurentPoly",
          "module": "Math.Algebras.LaurentPoly",
          "name": "q",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-LaurentPoly.html#v:q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.LaurentPoly",
          "name": "q'",
          "package": "HaskellForMaths",
          "signature": "LaurentPoly Q",
          "source": "src/Math-Algebras-LaurentPoly.html#q%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras LaurentPoly",
          "module": "Math.Algebras.LaurentPoly",
          "name": "q'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-LaurentPoly.html#v:q-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Matrix",
          "name": "Matrix",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Matrix.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Algebras Matrix",
          "module": "Math.Algebras.Matrix",
          "name": "Matrix",
          "package": "HaskellForMaths",
          "partial": "Matrix",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Matrix.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Matrix",
          "name": "M3",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Matrix.html#M3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebras Matrix",
          "module": "Math.Algebras.Matrix",
          "name": "M3",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Matrix.html#t:M3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Matrix",
          "name": "Mat2",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Matrix.html#Mat2",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebras Matrix",
          "module": "Math.Algebras.Matrix",
          "name": "Mat2",
          "package": "HaskellForMaths",
          "partial": "Mat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Matrix.html#t:Mat2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Matrix",
          "name": "Mat2'",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Matrix.html#Mat2%27",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebras Matrix",
          "module": "Math.Algebras.Matrix",
          "name": "Mat2'",
          "package": "HaskellForMaths",
          "partial": "Mat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Matrix.html#t:Mat2-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Matrix",
          "name": "E2",
          "package": "HaskellForMaths",
          "signature": "E2 Int Int",
          "source": "src/Math-Algebras-Matrix.html#Mat2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Matrix",
          "module": "Math.Algebras.Matrix",
          "name": "E2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Matrix.html#v:E2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Matrix",
          "name": "E2'",
          "package": "HaskellForMaths",
          "signature": "E2' Int Int",
          "source": "src/Math-Algebras-Matrix.html#Mat2%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Matrix",
          "module": "Math.Algebras.Matrix",
          "name": "E2'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Matrix.html#v:E2-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Matrix",
          "name": "E3",
          "package": "HaskellForMaths",
          "signature": "E3 Int Int",
          "source": "src/Math-Algebras-Matrix.html#M3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Matrix",
          "module": "Math.Algebras.Matrix",
          "name": "E3",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Matrix.html#v:E3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Matrix",
          "name": "toEB",
          "package": "HaskellForMaths",
          "signature": "[k] -\u003e Vect k EBasis",
          "source": "src/Math-Algebras-Matrix.html#toEB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Matrix",
          "module": "Math.Algebras.Matrix",
          "name": "toEB",
          "normalized": "[a]-\u003eVect a EBasis",
          "package": "HaskellForMaths",
          "partial": "EB",
          "signature": "[k]-\u003eVect k EBasis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Matrix.html#v:toEB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Matrix",
          "name": "toEB2",
          "package": "HaskellForMaths",
          "signature": "[k] -\u003e Vect k EBasis",
          "source": "src/Math-Algebras-Matrix.html#toEB2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Matrix",
          "module": "Math.Algebras.Matrix",
          "name": "toEB2",
          "normalized": "[a]-\u003eVect a EBasis",
          "package": "HaskellForMaths",
          "partial": "EB",
          "signature": "[k]-\u003eVect k EBasis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Matrix.html#v:toEB2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Matrix",
          "name": "toMat2",
          "package": "HaskellForMaths",
          "signature": "[[k]] -\u003e Vect k Mat2",
          "source": "src/Math-Algebras-Matrix.html#toMat2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Matrix",
          "module": "Math.Algebras.Matrix",
          "name": "toMat2",
          "normalized": "[[a]]-\u003eVect a Mat",
          "package": "HaskellForMaths",
          "partial": "Mat",
          "signature": "[[k]]-\u003eVect k Mat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Matrix.html#v:toMat2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining the algebra of non-commutative polynomials over a field k\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Algebras.NonCommutative",
          "name": "NonCommutative",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-NonCommutative.html",
          "type": "module"
        },
        "index": {
          "description": "module defining the algebra of non-commutative polynomials over field",
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "NonCommutative",
          "package": "HaskellForMaths",
          "partial": "Non Commutative",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "DivisionBasis",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-NonCommutative.html#DivisionBasis",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "DivisionBasis",
          "package": "HaskellForMaths",
          "partial": "Division Basis",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#t:DivisionBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "Monomial",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-NonCommutative.html#Monomial",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "Monomial",
          "package": "HaskellForMaths",
          "partial": "Monomial",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#t:Monomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "NCPoly",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-NonCommutative.html#NCPoly",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "NCPoly",
          "package": "HaskellForMaths",
          "partial": "NCPoly",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#t:NCPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "NonComMonomial",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-NonCommutative.html#NonComMonomial",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "NonComMonomial",
          "package": "HaskellForMaths",
          "partial": "Non Com Monomial",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#t:NonComMonomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "(%%)",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e [Vect k b] -\u003e Vect k b",
          "source": "src/Math-Algebras-NonCommutative.html#%25%25",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "(%%) %%",
          "normalized": "Vect a b-\u003e[Vect a b]-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003e[Vect k b]-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#v:-37--37-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "NCM",
          "package": "HaskellForMaths",
          "signature": "NCM Int [v]",
          "source": "src/Math-Algebras-NonCommutative.html#NonComMonomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "NCM",
          "normalized": "NCM Int[a]",
          "package": "HaskellForMaths",
          "partial": "NCM",
          "signature": "NCM Int[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#v:NCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "bind",
          "package": "HaskellForMaths",
          "signature": "Vect k (m v) -\u003e (v -\u003e Vect k b) -\u003e Vect k b",
          "source": "src/Math-Algebras-NonCommutative.html#bind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "bind",
          "normalized": "Vect a(b c)-\u003e(c-\u003eVect a d)-\u003eVect a d",
          "package": "HaskellForMaths",
          "signature": "Vect k(m v)-\u003e(v-\u003eVect k b)-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#v:bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "divM",
          "package": "HaskellForMaths",
          "signature": "m -\u003e m -\u003e Maybe (m, m)",
          "source": "src/Math-Algebras-NonCommutative.html#divM",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "divM",
          "normalized": "a-\u003ea-\u003eMaybe(a,a)",
          "package": "HaskellForMaths",
          "signature": "m-\u003em-\u003eMaybe(m,m)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#v:divM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "lc",
          "package": "HaskellForMaths",
          "signature": "Vect t t1 -\u003e t",
          "source": "src/Math-Algebras-NonCommutative.html#lc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "lc",
          "normalized": "Vect a a-\u003ea",
          "package": "HaskellForMaths",
          "signature": "Vect t t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#v:lc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "lm",
          "package": "HaskellForMaths",
          "signature": "Vect t t1 -\u003e t1",
          "source": "src/Math-Algebras-NonCommutative.html#lm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "lm",
          "normalized": "Vect a a-\u003ea",
          "package": "HaskellForMaths",
          "signature": "Vect t t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#v:lm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "lt",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e Vect k b",
          "source": "src/Math-Algebras-NonCommutative.html#lt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "lt",
          "normalized": "Vect a b-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#v:lt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "ncm",
          "package": "HaskellForMaths",
          "signature": "[v] -\u003e NonComMonomial v",
          "source": "src/Math-Algebras-NonCommutative.html#ncm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "ncm",
          "normalized": "[a]-\u003eNonComMonomial a",
          "package": "HaskellForMaths",
          "signature": "[v]-\u003eNonComMonomial v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#v:ncm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "powers",
          "package": "HaskellForMaths",
          "signature": "m v -\u003e [(v, Int)]",
          "source": "src/Math-Algebras-NonCommutative.html#powers",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "powers",
          "normalized": "a b-\u003e[(b,Int)]",
          "package": "HaskellForMaths",
          "signature": "m v-\u003e[(v,Int)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#v:powers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "quotRemNP",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e [Vect k b] -\u003e ([(Vect k b, Vect k b)], Vect k b)",
          "source": "src/Math-Algebras-NonCommutative.html#quotRemNP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "quotRemNP",
          "normalized": "Vect a b-\u003e[Vect a b]-\u003e([(Vect a b,Vect a b)],Vect a b)",
          "package": "HaskellForMaths",
          "partial": "Rem NP",
          "signature": "Vect k b-\u003e[Vect k b]-\u003e([(Vect k b,Vect k b)],Vect k b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#v:quotRemNP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "remNP",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e [Vect k b] -\u003e Vect k b",
          "source": "src/Math-Algebras-NonCommutative.html#remNP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "remNP",
          "normalized": "Vect a b-\u003e[Vect a b]-\u003eVect a b",
          "package": "HaskellForMaths",
          "partial": "NP",
          "signature": "Vect k b-\u003e[Vect k b]-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#v:remNP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.NonCommutative",
          "name": "var",
          "package": "HaskellForMaths",
          "signature": "v -\u003e Vect Q (m v)",
          "source": "src/Math-Algebras-NonCommutative.html#var",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras NonCommutative",
          "module": "Math.Algebras.NonCommutative",
          "name": "var",
          "normalized": "a-\u003eVect Q(b a)",
          "package": "HaskellForMaths",
          "signature": "v-\u003eVect Q(m v)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-NonCommutative.html#v:var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining the (non-associative) algebra of octonions over an arbitrary field.\n\u003c/p\u003e\u003cp\u003eThe octonions are the algebra defined by the basis {1,i0,i1,i2,i3,i4,i5,i6},\n where each i_n * i_n = -1, and i_n+1 * i_n+2 = i_n+4 (where the indices are modulo 7).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Algebras.Octonions",
          "name": "Octonions",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Octonions.html",
          "type": "module"
        },
        "index": {
          "description": "module defining the non-associative algebra of octonions over an arbitrary field The octonions are the algebra defined by the basis i0 i1 i2 i3 i4 i5 i6 where each and where the indices are modulo",
          "hierarchy": "Math Algebras Octonions",
          "module": "Math.Algebras.Octonions",
          "name": "Octonions",
          "package": "HaskellForMaths",
          "partial": "Octonions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Octonions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Octonions",
          "name": "OBasis",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Octonions.html#OBasis",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebras Octonions",
          "module": "Math.Algebras.Octonions",
          "name": "OBasis",
          "package": "HaskellForMaths",
          "partial": "OBasis",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Octonions.html#t:OBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Octonions",
          "name": "Octonion",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Octonions.html#Octonion",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebras Octonions",
          "module": "Math.Algebras.Octonions",
          "name": "Octonion",
          "package": "HaskellForMaths",
          "partial": "Octonion",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Octonions.html#t:Octonion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Octonions",
          "name": "O",
          "package": "HaskellForMaths",
          "signature": "O Int",
          "source": "src/Math-Algebras-Octonions.html#OBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Octonions",
          "module": "Math.Algebras.Octonions",
          "name": "O",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Octonions.html#v:O"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Octonions",
          "name": "i0",
          "package": "HaskellForMaths",
          "signature": "Octonion Q",
          "source": "src/Math-Algebras-Octonions.html#i0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Octonions",
          "module": "Math.Algebras.Octonions",
          "name": "i0",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Octonions.html#v:i0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Octonions",
          "name": "i1",
          "package": "HaskellForMaths",
          "signature": "Octonion Q",
          "source": "src/Math-Algebras-Octonions.html#i0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Octonions",
          "module": "Math.Algebras.Octonions",
          "name": "i1",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Octonions.html#v:i1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Octonions",
          "name": "i2",
          "package": "HaskellForMaths",
          "signature": "Octonion Q",
          "source": "src/Math-Algebras-Octonions.html#i0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Octonions",
          "module": "Math.Algebras.Octonions",
          "name": "i2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Octonions.html#v:i2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Octonions",
          "name": "i3",
          "package": "HaskellForMaths",
          "signature": "Octonion Q",
          "source": "src/Math-Algebras-Octonions.html#i0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Octonions",
          "module": "Math.Algebras.Octonions",
          "name": "i3",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Octonions.html#v:i3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Octonions",
          "name": "i4",
          "package": "HaskellForMaths",
          "signature": "Octonion Q",
          "source": "src/Math-Algebras-Octonions.html#i0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Octonions",
          "module": "Math.Algebras.Octonions",
          "name": "i4",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Octonions.html#v:i4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Octonions",
          "name": "i5",
          "package": "HaskellForMaths",
          "signature": "Octonion Q",
          "source": "src/Math-Algebras-Octonions.html#i0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Octonions",
          "module": "Math.Algebras.Octonions",
          "name": "i5",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Octonions.html#v:i5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Octonions",
          "name": "i6",
          "package": "HaskellForMaths",
          "signature": "Octonion Q",
          "source": "src/Math-Algebras-Octonions.html#i0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Octonions",
          "module": "Math.Algebras.Octonions",
          "name": "i6",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Octonions.html#v:i6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Octonions",
          "name": "i_",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Octonion k",
          "source": "src/Math-Algebras-Octonions.html#i_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Octonions",
          "module": "Math.Algebras.Octonions",
          "name": "i_",
          "normalized": "Int-\u003eOctonion a",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eOctonion k",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Octonions.html#v:i_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining the algebra of quaternions over an arbitrary field.\n\u003c/p\u003e\u003cp\u003eThe quaternions are the algebra defined by the basis {1,i,j,k}, where i^2 = j^2 = k^2 = ijk = -1\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Algebras.Quaternions",
          "name": "Quaternions",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Quaternions.html",
          "type": "module"
        },
        "index": {
          "description": "module defining the algebra of quaternions over an arbitrary field The quaternions are the algebra defined by the basis where ijk",
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "Quaternions",
          "package": "HaskellForMaths",
          "partial": "Quaternions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "HBasis",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Quaternions.html#HBasis",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "HBasis",
          "package": "HaskellForMaths",
          "partial": "HBasis",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#t:HBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "HasConjugation",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Quaternions.html#HasConjugation",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "HasConjugation",
          "package": "HaskellForMaths",
          "partial": "Has Conjugation",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#t:HasConjugation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "Quaternion",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Quaternions.html#Quaternion",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "Quaternion",
          "package": "HaskellForMaths",
          "partial": "Quaternion",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#t:Quaternion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "(\u003c.\u003e)",
          "package": "HaskellForMaths",
          "signature": "Vect k HBasis -\u003e Quaternion k -\u003e k",
          "source": "src/Math-Algebras-Quaternions.html#%3C.%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "(\u003c.\u003e) \u003c.\u003e",
          "normalized": "Vect a HBasis-\u003eQuaternion a-\u003ea",
          "package": "HaskellForMaths",
          "signature": "Vect k HBasis-\u003eQuaternion k-\u003ek",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:-60-.-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "(^-)",
          "package": "HaskellForMaths",
          "signature": "a1 -\u003e a -\u003e a1",
          "source": "src/Math-Algebras-Quaternions.html#%5E-",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "(^-) ^-",
          "normalized": "a-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:-94--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "I",
          "package": "HaskellForMaths",
          "signature": "I",
          "source": "src/Math-Algebras-Quaternions.html#HBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "I",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "J",
          "package": "HaskellForMaths",
          "signature": "J",
          "source": "src/Math-Algebras-Quaternions.html#HBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "J",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:J"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "K",
          "package": "HaskellForMaths",
          "signature": "K",
          "source": "src/Math-Algebras-Quaternions.html#HBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "K",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:K"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "One",
          "package": "HaskellForMaths",
          "signature": "One",
          "source": "src/Math-Algebras-Quaternions.html#HBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "One",
          "package": "HaskellForMaths",
          "partial": "One",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:One"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "asMatrix",
          "package": "HaskellForMaths",
          "signature": "(Vect t HBasis -\u003e Quaternion t) -\u003e [Vect t HBasis] -\u003e [[t]]",
          "source": "src/Math-Algebras-Quaternions.html#asMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "asMatrix",
          "normalized": "(Vect a HBasis-\u003eQuaternion a)-\u003e[Vect a HBasis]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Matrix",
          "signature": "(Vect t HBasis-\u003eQuaternion t)-\u003e[Vect t HBasis]-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:asMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA conjugation operation is required to satisfy the following laws:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e conj (x+y) = conj x + conj y\n\u003c/li\u003e\u003cli\u003e conj (x*y) = conj y * conj x  (note the order-reversal)\n\u003c/li\u003e\u003cli\u003e conj (conj x) = x\n\u003c/li\u003e\u003cli\u003e conj x = x if and only if x in k\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Math.Algebras.Quaternions",
          "name": "conj",
          "package": "HaskellForMaths",
          "signature": "Vect k a -\u003e Vect k a",
          "source": "src/Math-Algebras-Quaternions.html#conj",
          "type": "method"
        },
        "index": {
          "description": "conjugation operation is required to satisfy the following laws conj conj conj conj conj conj note the order-reversal conj conj conj if and only if in",
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "conj",
          "normalized": "Vect a b-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k a-\u003eVect k a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:conj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe quaternions have {1,i,j,k} as basis, where i^2 = j^2 = k^2 = ijk = -1.\n\u003c/p\u003e",
          "module": "Math.Algebras.Quaternions",
          "name": "i",
          "package": "HaskellForMaths",
          "signature": "Quaternion k",
          "source": "src/Math-Algebras-Quaternions.html#i",
          "type": "function"
        },
        "index": {
          "description": "The quaternions have as basis where ijk",
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "i",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:i"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "i'",
          "package": "HaskellForMaths",
          "signature": "Vect k (Dual HBasis)",
          "source": "src/Math-Algebras-Quaternions.html#one%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "i'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:i-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe quaternions have {1,i,j,k} as basis, where i^2 = j^2 = k^2 = ijk = -1.\n\u003c/p\u003e",
          "module": "Math.Algebras.Quaternions",
          "name": "j",
          "package": "HaskellForMaths",
          "signature": "Quaternion k",
          "source": "src/Math-Algebras-Quaternions.html#i",
          "type": "function"
        },
        "index": {
          "description": "The quaternions have as basis where ijk",
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "j",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:j"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "j'",
          "package": "HaskellForMaths",
          "signature": "Vect k (Dual HBasis)",
          "source": "src/Math-Algebras-Quaternions.html#one%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "j'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:j-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe quaternions have {1,i,j,k} as basis, where i^2 = j^2 = k^2 = ijk = -1.\n\u003c/p\u003e",
          "module": "Math.Algebras.Quaternions",
          "name": "k",
          "package": "HaskellForMaths",
          "signature": "Quaternion k",
          "source": "src/Math-Algebras-Quaternions.html#i",
          "type": "function"
        },
        "index": {
          "description": "The quaternions have as basis where ijk",
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "k",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:k"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "k'",
          "package": "HaskellForMaths",
          "signature": "Vect k (Dual HBasis)",
          "source": "src/Math-Algebras-Quaternions.html#one%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "k'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:k-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "one'",
          "package": "HaskellForMaths",
          "signature": "Vect k (Dual HBasis)",
          "source": "src/Math-Algebras-Quaternions.html#one%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "one'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:one-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "refl",
          "package": "HaskellForMaths",
          "signature": "Vect k a -\u003e Vect k a -\u003e Vect k a",
          "source": "src/Math-Algebras-Quaternions.html#refl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "refl",
          "normalized": "Vect a b-\u003eVect a b-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k a-\u003eVect k a-\u003eVect k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:refl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a non-zero quaternion q in H, the map x -\u003e q^-1 * x * q defines an action on the 3-dimensional vector space\n of pure quaternions X (ie linear combinations of i,j,k). It turns out that this action is a rotation of X,\n and this is a surjective group homomorphism from H* onto SO3. If we restrict q to the group of unit quaternions\n (those of norm 1), then this homomorphism is 2-to-1 (since q and -q give the same rotation).\n This shows that the multiplicative group of unit quaternions is isomorphic to Spin3, the double cover of SO3.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ereprSO3 q\u003c/code\u003e returns the 3*3 matrix representing this map.\n\u003c/p\u003e",
          "module": "Math.Algebras.Quaternions",
          "name": "reprSO3",
          "package": "HaskellForMaths",
          "signature": "Quaternion k -\u003e [[k]]",
          "source": "src/Math-Algebras-Quaternions.html#reprSO3",
          "type": "function"
        },
        "index": {
          "description": "Given non-zero quaternion in the map defines an action on the dimensional vector space of pure quaternions ie linear combinations of It turns out that this action is rotation of and this is surjective group homomorphism from onto SO3 If we restrict to the group of unit quaternions those of norm then this homomorphism is to-1 since and give the same rotation This shows that the multiplicative group of unit quaternions is isomorphic to Spin3 the double cover of SO3 reprSO3 returns the matrix representing this map",
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "reprSO3",
          "normalized": "Quaternion a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "SO",
          "signature": "Quaternion k-\u003e[[k]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:reprSO3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "reprSO3'",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Math-Algebras-Quaternions.html#reprSO3%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "reprSO3'",
          "normalized": "a-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "partial": "SO",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:reprSO3-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a pair of unit quaternions (l,r), the map x -\u003e l^-1 * x * r defines an action on the 4-dimensional space\n of quaternions. It turns out that this action is a rotation, and this is a surjective group homomorphism\n onto SO4. The homomorphism is 2-to-1 (since (l,r) and (-l,-r) give the same map).\n This shows that the multiplicative group of pairs of unit quaternions (with pointwise multiplication)\n is isomorphic to Spin4, the double cover of SO4.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ereprSO4 (l,r)\u003c/code\u003e returns the 4*4 matrix representing this map.\n\u003c/p\u003e",
          "module": "Math.Algebras.Quaternions",
          "name": "reprSO4",
          "package": "HaskellForMaths",
          "signature": "(Quaternion k, Quaternion k) -\u003e [[k]]",
          "source": "src/Math-Algebras-Quaternions.html#reprSO4",
          "type": "function"
        },
        "index": {
          "description": "Given pair of unit quaternions the map defines an action on the dimensional space of quaternions It turns out that this action is rotation and this is surjective group homomorphism onto SO4 The homomorphism is to-1 since and give the same map This shows that the multiplicative group of pairs of unit quaternions with pointwise multiplication is isomorphic to Spin4 the double cover of SO4 reprSO4 returns the matrix representing this map",
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "reprSO4",
          "normalized": "(Quaternion a,Quaternion a)-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "SO",
          "signature": "(Quaternion k,Quaternion k)-\u003e[[k]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:reprSO4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "reprSO4'",
          "package": "HaskellForMaths",
          "signature": "(a, a) -\u003e a -\u003e a",
          "source": "src/Math-Algebras-Quaternions.html#reprSO4%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "reprSO4'",
          "normalized": "(a,a)-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "partial": "SO",
          "signature": "(a,a)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:reprSO4-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Quaternions",
          "name": "reprSO4d",
          "package": "HaskellForMaths",
          "signature": "Vect k (DSum HBasis HBasis) -\u003e [[k]]",
          "source": "src/Math-Algebras-Quaternions.html#reprSO4d",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "reprSO4d",
          "normalized": "Vect a(DSum HBasis HBasis)-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "SO",
          "signature": "Vect k(DSum HBasis HBasis)-\u003e[[k]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:reprSO4d"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe scalar part of the quaternion w+xi+yj+zk is w. Also called the real part.\n\u003c/p\u003e",
          "module": "Math.Algebras.Quaternions",
          "name": "scalarPart",
          "package": "HaskellForMaths",
          "signature": "Quaternion k -\u003e k",
          "source": "src/Math-Algebras-Quaternions.html#scalarPart",
          "type": "function"
        },
        "index": {
          "description": "The scalar part of the quaternion xi yj zk is Also called the real part",
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "scalarPart",
          "normalized": "Quaternion a-\u003ea",
          "package": "HaskellForMaths",
          "partial": "Part",
          "signature": "Quaternion k-\u003ek",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:scalarPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe squared norm is defined as sqnorm x = x * conj x. It satisfies:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e sqnorm (x*y) = sqnorm x * sqnorm y\n\u003c/li\u003e\u003cli\u003e sqnorm (unit k) = k^2, for k a scalar\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Math.Algebras.Quaternions",
          "name": "sqnorm",
          "package": "HaskellForMaths",
          "signature": "Vect k a -\u003e k",
          "source": "src/Math-Algebras-Quaternions.html#sqnorm",
          "type": "method"
        },
        "index": {
          "description": "The squared norm is defined as sqnorm conj It satisfies sqnorm sqnorm sqnorm sqnorm unit for scalar",
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "sqnorm",
          "normalized": "Vect a b-\u003ea",
          "package": "HaskellForMaths",
          "signature": "Vect k a-\u003ek",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:sqnorm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe vector part of the quaternion w+xi+yj+zk is xi+yj+zk. Also called the pure part.\n\u003c/p\u003e",
          "module": "Math.Algebras.Quaternions",
          "name": "vectorPart",
          "package": "HaskellForMaths",
          "signature": "Quaternion k -\u003e Quaternion k",
          "source": "src/Math-Algebras-Quaternions.html#vectorPart",
          "type": "function"
        },
        "index": {
          "description": "The vector part of the quaternion xi yj zk is xi yj zk Also called the pure part",
          "hierarchy": "Math Algebras Quaternions",
          "module": "Math.Algebras.Quaternions",
          "name": "vectorPart",
          "normalized": "Quaternion a-\u003eQuaternion a",
          "package": "HaskellForMaths",
          "partial": "Part",
          "signature": "Quaternion k-\u003eQuaternion k",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Quaternions.html#v:vectorPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining various algebraic structures that can be defined on vector spaces\n - specifically algebra, coalgebra, bialgebra, Hopf algebra, module, comodule\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Algebras.Structures",
          "name": "Structures",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Structures.html",
          "type": "module"
        },
        "index": {
          "description": "module defining various algebraic structures that can be defined on vector spaces specifically algebra coalgebra bialgebra Hopf algebra module comodule",
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "Structures",
          "package": "HaskellForMaths",
          "partial": "Structures",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCaution: If we declare an instance Algebra k b, then we are saying that the vector space Vect k b is a k-algebra.\n In other words, we are saying that b is the basis for a k-algebra. So a more accurate name for this class\n would have been AlgebraBasis.\n\u003c/p\u003e",
          "module": "Math.Algebras.Structures",
          "name": "Algebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Structures.html#Algebra",
          "type": "class"
        },
        "index": {
          "description": "Caution If we declare an instance Algebra then we are saying that the vector space Vect is k-algebra In other words we are saying that is the basis for k-algebra So more accurate name for this class would have been AlgebraBasis",
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "Algebra",
          "package": "HaskellForMaths",
          "partial": "Algebra",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#t:Algebra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA bialgebra is an algebra which is also a coalgebra, subject to the compatibility conditions\n that counit and comult must be algebra morphisms (or equivalently, that unit and mult must be coalgebra morphisms)\n\u003c/p\u003e",
          "module": "Math.Algebras.Structures",
          "name": "Bialgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Structures.html#Bialgebra",
          "type": "class"
        },
        "index": {
          "description": "bialgebra is an algebra which is also coalgebra subject to the compatibility conditions that counit and comult must be algebra morphisms or equivalently that unit and mult must be coalgebra morphisms",
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "Bialgebra",
          "package": "HaskellForMaths",
          "partial": "Bialgebra",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#t:Bialgebra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn instance declaration for Coalgebra k b is saying that the vector space Vect k b is a k-coalgebra.\n\u003c/p\u003e",
          "module": "Math.Algebras.Structures",
          "name": "Coalgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Structures.html#Coalgebra",
          "type": "class"
        },
        "index": {
          "description": "An instance declaration for Coalgebra is saying that the vector space Vect is k-coalgebra",
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "Coalgebra",
          "package": "HaskellForMaths",
          "partial": "Coalgebra",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#t:Coalgebra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "Comodule",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Structures.html#Comodule",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "Comodule",
          "package": "HaskellForMaths",
          "partial": "Comodule",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#t:Comodule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pairing is a non-degenerate bilinear form U x V -\u003e k.\n We are typically interested in pairings having additional properties. For example:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e A bialgebra pairing is a pairing between bialgebras A and B such that the mult in A is adjoint to the comult in B, and vice versa, and the unit in A is adjoint to the counit in B, and vice versa.\n\u003c/li\u003e\u003cli\u003e A Hopf pairing is a bialgebra pairing between Hopf algebras A and B such that the antipodes in A and B are adjoint.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Math.Algebras.Structures",
          "name": "HasPairing",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Structures.html#HasPairing",
          "type": "class"
        },
        "index": {
          "description": "pairing is non-degenerate bilinear form We are typically interested in pairings having additional properties For example bialgebra pairing is pairing between bialgebras and such that the mult in is adjoint to the comult in and vice versa and the unit in is adjoint to the counit in and vice versa Hopf pairing is bialgebra pairing between Hopf algebras and such that the antipodes in and are adjoint",
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "HasPairing",
          "package": "HaskellForMaths",
          "partial": "Has Pairing",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#t:HasPairing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "HopfAlgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Structures.html#HopfAlgebra",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "HopfAlgebra",
          "package": "HaskellForMaths",
          "partial": "Hopf Algebra",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#t:HopfAlgebra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "Module",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Structures.html#Module",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "Module",
          "package": "HaskellForMaths",
          "partial": "Module",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#t:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonoid\n\u003c/p\u003e",
          "module": "Math.Algebras.Structures",
          "name": "Mon",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Structures.html#Mon",
          "type": "class"
        },
        "index": {
          "description": "Monoid",
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "Mon",
          "package": "HaskellForMaths",
          "partial": "Mon",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#t:Mon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "MonoidCoalgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Structures.html#MonoidCoalgebra",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "MonoidCoalgebra",
          "package": "HaskellForMaths",
          "partial": "Monoid Coalgebra",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#t:MonoidCoalgebra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "SetCoalgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-Structures.html#SetCoalgebra",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "SetCoalgebra",
          "package": "HaskellForMaths",
          "partial": "Set Coalgebra",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#t:SetCoalgebra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "(*.)",
          "package": "HaskellForMaths",
          "signature": "Vect k a -\u003e Vect k m -\u003e Vect k m",
          "source": "src/Math-Algebras-Structures.html#%2A.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "(*.) *.",
          "normalized": "Vect a b-\u003eVect a c-\u003eVect a c",
          "package": "HaskellForMaths",
          "signature": "Vect k a-\u003eVect k m-\u003eVect k m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:-42-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "MC",
          "package": "HaskellForMaths",
          "signature": "MC m",
          "source": "src/Math-Algebras-Structures.html#MonoidCoalgebra",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "MC",
          "package": "HaskellForMaths",
          "partial": "MC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:MC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "SC",
          "package": "HaskellForMaths",
          "signature": "SC b",
          "source": "src/Math-Algebras-Structures.html#SetCoalgebra",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "SC",
          "package": "HaskellForMaths",
          "partial": "SC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:SC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "action",
          "package": "HaskellForMaths",
          "signature": "Vect k (Tensor a m) -\u003e Vect k m",
          "source": "src/Math-Algebras-Structures.html#action",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "action",
          "normalized": "Vect a(Tensor b c)-\u003eVect a c",
          "package": "HaskellForMaths",
          "signature": "Vect k(Tensor a m)-\u003eVect k m",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:action"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "antipode",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e Vect k b",
          "source": "src/Math-Algebras-Structures.html#antipode",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "antipode",
          "normalized": "Vect a b-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003eVect k b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:antipode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "coaction",
          "package": "HaskellForMaths",
          "signature": "Vect k n -\u003e Vect k (Tensor c n)",
          "source": "src/Math-Algebras-Structures.html#coaction",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "coaction",
          "normalized": "Vect a b-\u003eVect a(Tensor c b)",
          "package": "HaskellForMaths",
          "signature": "Vect k n-\u003eVect k(Tensor c n)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:coaction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "comult",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e Vect k (Tensor b b)",
          "source": "src/Math-Algebras-Structures.html#comult",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "comult",
          "normalized": "Vect a b-\u003eVect a(Tensor b b)",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003eVect k(Tensor b b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:comult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "counit",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e k",
          "source": "src/Math-Algebras-Structures.html#counit",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "counit",
          "normalized": "Vect a b-\u003ea",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003ek",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:counit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSometimes it is more convenient to work with this version of counit.\n\u003c/p\u003e",
          "module": "Math.Algebras.Structures",
          "name": "counit'",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e Vect k ()",
          "source": "src/Math-Algebras-Structures.html#counit%27",
          "type": "function"
        },
        "index": {
          "description": "Sometimes it is more convenient to work with this version of counit",
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "counit'",
          "normalized": "Vect a b-\u003eVect a()",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003eVect k()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:counit-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "mmult",
          "package": "HaskellForMaths",
          "signature": "m -\u003e m -\u003e m",
          "source": "src/Math-Algebras-Structures.html#mmult",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "mmult",
          "normalized": "a-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "signature": "m-\u003em-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:mmult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "mult",
          "package": "HaskellForMaths",
          "signature": "Vect k (Tensor b b) -\u003e Vect k b",
          "source": "src/Math-Algebras-Structures.html#mult",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "mult",
          "normalized": "Vect a(Tensor b b)-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k(Tensor b b)-\u003eVect k b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:mult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "munit",
          "package": "HaskellForMaths",
          "signature": "m",
          "source": "src/Math-Algebras-Structures.html#munit",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "munit",
          "package": "HaskellForMaths",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:munit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "pairing",
          "package": "HaskellForMaths",
          "signature": "Vect k (Tensor u v) -\u003e Vect k ()",
          "source": "src/Math-Algebras-Structures.html#pairing",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "pairing",
          "normalized": "Vect a(Tensor b c)-\u003eVect a()",
          "package": "HaskellForMaths",
          "signature": "Vect k(Tensor u v)-\u003eVect k()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:pairing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe pairing function with a more Haskellish type signature\n\u003c/p\u003e",
          "module": "Math.Algebras.Structures",
          "name": "pairing'",
          "package": "HaskellForMaths",
          "signature": "Vect k u -\u003e Vect k v -\u003e k",
          "source": "src/Math-Algebras-Structures.html#pairing%27",
          "type": "function"
        },
        "index": {
          "description": "The pairing function with more Haskellish type signature",
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "pairing'",
          "normalized": "Vect a b-\u003eVect a c-\u003ea",
          "package": "HaskellForMaths",
          "signature": "Vect k u-\u003eVect k v-\u003ek",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:pairing-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.Structures",
          "name": "unit",
          "package": "HaskellForMaths",
          "signature": "k -\u003e Vect k b",
          "source": "src/Math-Algebras-Structures.html#unit",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "unit",
          "normalized": "a-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "k-\u003eVect k b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:unit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSometimes it is more convenient to work with this version of unit.\n\u003c/p\u003e",
          "module": "Math.Algebras.Structures",
          "name": "unit'",
          "package": "HaskellForMaths",
          "signature": "Vect k () -\u003e Vect k b",
          "source": "src/Math-Algebras-Structures.html#unit%27",
          "type": "function"
        },
        "index": {
          "description": "Sometimes it is more convenient to work with this version of unit",
          "hierarchy": "Math Algebras Structures",
          "module": "Math.Algebras.Structures",
          "name": "unit'",
          "normalized": "Vect a()-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k()-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-Structures.html#v:unit-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining the tensor algebra, symmetric algebra, exterior (or alternating) algebra, and tensor coalgebra\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "TensorAlgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-TensorAlgebra.html",
          "type": "module"
        },
        "index": {
          "description": "module defining the tensor algebra symmetric algebra exterior or alternating algebra and tensor coalgebra",
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "TensorAlgebra",
          "package": "HaskellForMaths",
          "partial": "Tensor Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data type representing basis elements of the exterior algebra over a set/type.\n The exterior algebra is the quotient of the tensor algebra by\n the ideal generated by all\n self-products u&#8855;u and sums of products u&#8855;v + v&#8855;u\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "ExteriorAlgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-TensorAlgebra.html#ExteriorAlgebra",
          "type": "data"
        },
        "index": {
          "description": "data type representing basis elements of the exterior algebra over set type The exterior algebra is the quotient of the tensor algebra by the ideal generated by all self-products and sums of products",
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "ExteriorAlgebra",
          "package": "HaskellForMaths",
          "partial": "Exterior Algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#t:ExteriorAlgebra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data type representing basis elements of the symmetric algebra over a set/type.\n The symmetric algebra is the quotient of the tensor algebra by\n the ideal generated by all\n differences of products u&#8855;v - v&#8855;u.\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "SymmetricAlgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-TensorAlgebra.html#SymmetricAlgebra",
          "type": "data"
        },
        "index": {
          "description": "data type representing basis elements of the symmetric algebra over set type The symmetric algebra is the quotient of the tensor algebra by the ideal generated by all differences of products",
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "SymmetricAlgebra",
          "package": "HaskellForMaths",
          "partial": "Symmetric Algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#t:SymmetricAlgebra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data type representing basis elements of the tensor algebra over a set/type.\n Elements of the tensor algebra are linear combinations of iterated tensor products of elements of the set/type.\n If V = Vect k a is the free vector space over a, then the tensor algebra T(V) = Vect k (TensorAlgebra a) is isomorphic\n to the infinite direct sum:\n\u003c/p\u003e\u003cp\u003eT(V) = k &#8853; V &#8853; V&#8855;V &#8853; V&#8855;V&#8855;V &#8853; ...\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "TensorAlgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-TensorAlgebra.html#TensorAlgebra",
          "type": "data"
        },
        "index": {
          "description": "data type representing basis elements of the tensor algebra over set type Elements of the tensor algebra are linear combinations of iterated tensor products of elements of the set type If Vect is the free vector space over then the tensor algebra Vect TensorAlgebra is isomorphic to the infinite direct sum",
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "TensorAlgebra",
          "package": "HaskellForMaths",
          "partial": "Tensor Algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#t:TensorAlgebra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "TensorCoalgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-TensorAlgebra.html#TensorCoalgebra",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "TensorCoalgebra",
          "package": "HaskellForMaths",
          "partial": "Tensor Coalgebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#t:TensorCoalgebra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "Ext",
          "package": "HaskellForMaths",
          "signature": "Ext Int [a]",
          "source": "src/Math-Algebras-TensorAlgebra.html#ExteriorAlgebra",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "Ext",
          "normalized": "Ext Int[a]",
          "package": "HaskellForMaths",
          "partial": "Ext",
          "signature": "Ext Int[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:Ext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "Sym",
          "package": "HaskellForMaths",
          "signature": "Sym Int [a]",
          "source": "src/Math-Algebras-TensorAlgebra.html#SymmetricAlgebra",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "Sym",
          "normalized": "Sym Int[a]",
          "package": "HaskellForMaths",
          "partial": "Sym",
          "signature": "Sym Int[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:Sym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "TA",
          "package": "HaskellForMaths",
          "signature": "TA Int [a]",
          "source": "src/Math-Algebras-TensorAlgebra.html#TensorAlgebra",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "TA",
          "normalized": "TA Int[a]",
          "package": "HaskellForMaths",
          "partial": "TA",
          "signature": "TA Int[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:TA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "TC",
          "package": "HaskellForMaths",
          "signature": "TC Int [c]",
          "source": "src/Math-Algebras-TensorAlgebra.html#TensorCoalgebra",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "TC",
          "normalized": "TC Int[a]",
          "package": "HaskellForMaths",
          "partial": "TC",
          "signature": "TC Int[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:TC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "bindExt",
          "package": "HaskellForMaths",
          "signature": "Vect k (ExteriorAlgebra a) -\u003e (Vect k a -\u003e Vect k (ExteriorAlgebra b)) -\u003e Vect k (ExteriorAlgebra b)",
          "source": "src/Math-Algebras-TensorAlgebra.html#bindExt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "bindExt",
          "normalized": "Vect a(ExteriorAlgebra b)-\u003e(Vect a b-\u003eVect a(ExteriorAlgebra c))-\u003eVect a(ExteriorAlgebra c)",
          "package": "HaskellForMaths",
          "partial": "Ext",
          "signature": "Vect k(ExteriorAlgebra a)-\u003e(Vect k a-\u003eVect k(ExteriorAlgebra b))-\u003eVect k(ExteriorAlgebra b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:bindExt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "bindExt'",
          "package": "HaskellForMaths",
          "signature": "Vect k (ExteriorAlgebra a) -\u003e (a -\u003e Vect k (ExteriorAlgebra b)) -\u003e Vect k (ExteriorAlgebra b)",
          "source": "src/Math-Algebras-TensorAlgebra.html#bindExt%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "bindExt'",
          "normalized": "Vect a(ExteriorAlgebra b)-\u003e(b-\u003eVect a(ExteriorAlgebra c))-\u003eVect a(ExteriorAlgebra c)",
          "package": "HaskellForMaths",
          "partial": "Ext'",
          "signature": "Vect k(ExteriorAlgebra a)-\u003e(a-\u003eVect k(ExteriorAlgebra b))-\u003eVect k(ExteriorAlgebra b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:bindExt-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "bindSym",
          "package": "HaskellForMaths",
          "signature": "Vect k (SymmetricAlgebra a) -\u003e (Vect k a -\u003e Vect k (SymmetricAlgebra b)) -\u003e Vect k (SymmetricAlgebra b)",
          "source": "src/Math-Algebras-TensorAlgebra.html#bindSym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "bindSym",
          "normalized": "Vect a(SymmetricAlgebra b)-\u003e(Vect a b-\u003eVect a(SymmetricAlgebra c))-\u003eVect a(SymmetricAlgebra c)",
          "package": "HaskellForMaths",
          "partial": "Sym",
          "signature": "Vect k(SymmetricAlgebra a)-\u003e(Vect k a-\u003eVect k(SymmetricAlgebra b))-\u003eVect k(SymmetricAlgebra b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:bindSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "bindSym'",
          "package": "HaskellForMaths",
          "signature": "Vect k (SymmetricAlgebra a) -\u003e (a -\u003e Vect k (SymmetricAlgebra b)) -\u003e Vect k (SymmetricAlgebra b)",
          "source": "src/Math-Algebras-TensorAlgebra.html#bindSym%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "bindSym'",
          "normalized": "Vect a(SymmetricAlgebra b)-\u003e(b-\u003eVect a(SymmetricAlgebra c))-\u003eVect a(SymmetricAlgebra c)",
          "package": "HaskellForMaths",
          "partial": "Sym'",
          "signature": "Vect k(SymmetricAlgebra a)-\u003e(a-\u003eVect k(SymmetricAlgebra b))-\u003eVect k(SymmetricAlgebra b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:bindSym-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "bindTA",
          "package": "HaskellForMaths",
          "signature": "Vect k (TensorAlgebra a) -\u003e (Vect k a -\u003e Vect k (TensorAlgebra b)) -\u003e Vect k (TensorAlgebra b)",
          "source": "src/Math-Algebras-TensorAlgebra.html#bindTA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "bindTA",
          "normalized": "Vect a(TensorAlgebra b)-\u003e(Vect a b-\u003eVect a(TensorAlgebra c))-\u003eVect a(TensorAlgebra c)",
          "package": "HaskellForMaths",
          "partial": "TA",
          "signature": "Vect k(TensorAlgebra a)-\u003e(Vect k a-\u003eVect k(TensorAlgebra b))-\u003eVect k(TensorAlgebra b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:bindTA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "bindTA'",
          "package": "HaskellForMaths",
          "signature": "Vect k (TensorAlgebra a) -\u003e (a -\u003e Vect k (TensorAlgebra b)) -\u003e Vect k (TensorAlgebra b)",
          "source": "src/Math-Algebras-TensorAlgebra.html#bindTA%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "bindTA'",
          "normalized": "Vect a(TensorAlgebra b)-\u003e(b-\u003eVect a(TensorAlgebra c))-\u003eVect a(TensorAlgebra c)",
          "package": "HaskellForMaths",
          "partial": "TA'",
          "signature": "Vect k(TensorAlgebra a)-\u003e(a-\u003eVect k(TensorAlgebra b))-\u003eVect k(TensorAlgebra b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:bindTA-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "cobindTC",
          "package": "HaskellForMaths",
          "signature": "(Vect k (TensorCoalgebra c) -\u003e Vect k d) -\u003e Vect k (TensorCoalgebra c) -\u003e Vect k (TensorCoalgebra d)",
          "source": "src/Math-Algebras-TensorAlgebra.html#cobindTC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "cobindTC",
          "normalized": "(Vect a(TensorCoalgebra b)-\u003eVect a c)-\u003eVect a(TensorCoalgebra b)-\u003eVect a(TensorCoalgebra c)",
          "package": "HaskellForMaths",
          "partial": "TC",
          "signature": "(Vect k(TensorCoalgebra c)-\u003eVect k d)-\u003eVect k(TensorCoalgebra c)-\u003eVect k(TensorCoalgebra d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:cobindTC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "coliftTC",
          "package": "HaskellForMaths",
          "signature": "(Vect k c -\u003e Vect k d) -\u003e Vect k c -\u003e Vect k (TensorCoalgebra d)",
          "source": "src/Math-Algebras-TensorAlgebra.html#coliftTC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "coliftTC",
          "normalized": "(Vect a b-\u003eVect a c)-\u003eVect a b-\u003eVect a(TensorCoalgebra c)",
          "package": "HaskellForMaths",
          "partial": "TC",
          "signature": "(Vect k c-\u003eVect k d)-\u003eVect k c-\u003eVect k(TensorCoalgebra d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:coliftTC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "coliftTC'",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e (m b -\u003e Vect k c) -\u003e Vect k b -\u003e Vect k (TensorCoalgebra c)",
          "source": "src/Math-Algebras-TensorAlgebra.html#coliftTC%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "coliftTC'",
          "normalized": "Int-\u003e(a b-\u003eVect c d)-\u003eVect c b-\u003eVect c(TensorCoalgebra d)",
          "package": "HaskellForMaths",
          "partial": "TC'",
          "signature": "Int-\u003e(m b-\u003eVect k c)-\u003eVect k b-\u003eVect k(TensorCoalgebra c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:coliftTC-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "fmapExt",
          "package": "HaskellForMaths",
          "signature": "(Vect k a -\u003e Vect k b) -\u003e Vect k (ExteriorAlgebra a) -\u003e Vect k (ExteriorAlgebra b)",
          "source": "src/Math-Algebras-TensorAlgebra.html#fmapExt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "fmapExt",
          "normalized": "(Vect a b-\u003eVect a c)-\u003eVect a(ExteriorAlgebra b)-\u003eVect a(ExteriorAlgebra c)",
          "package": "HaskellForMaths",
          "partial": "Ext",
          "signature": "(Vect k a-\u003eVect k b)-\u003eVect k(ExteriorAlgebra a)-\u003eVect k(ExteriorAlgebra b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:fmapExt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "fmapExt'",
          "package": "HaskellForMaths",
          "signature": "(a -\u003e b) -\u003e Vect k (ExteriorAlgebra a) -\u003e Vect k (ExteriorAlgebra b)",
          "source": "src/Math-Algebras-TensorAlgebra.html#fmapExt%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "fmapExt'",
          "normalized": "(a-\u003eb)-\u003eVect c(ExteriorAlgebra a)-\u003eVect c(ExteriorAlgebra b)",
          "package": "HaskellForMaths",
          "partial": "Ext'",
          "signature": "(a-\u003eb)-\u003eVect k(ExteriorAlgebra a)-\u003eVect k(ExteriorAlgebra b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:fmapExt-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "fmapSym",
          "package": "HaskellForMaths",
          "signature": "(Vect k a -\u003e Vect k b) -\u003e Vect k (SymmetricAlgebra a) -\u003e Vect k (SymmetricAlgebra b)",
          "source": "src/Math-Algebras-TensorAlgebra.html#fmapSym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "fmapSym",
          "normalized": "(Vect a b-\u003eVect a c)-\u003eVect a(SymmetricAlgebra b)-\u003eVect a(SymmetricAlgebra c)",
          "package": "HaskellForMaths",
          "partial": "Sym",
          "signature": "(Vect k a-\u003eVect k b)-\u003eVect k(SymmetricAlgebra a)-\u003eVect k(SymmetricAlgebra b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:fmapSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "fmapSym'",
          "package": "HaskellForMaths",
          "signature": "(a -\u003e b) -\u003e Vect k (SymmetricAlgebra a) -\u003e Vect k (SymmetricAlgebra b)",
          "source": "src/Math-Algebras-TensorAlgebra.html#fmapSym%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "fmapSym'",
          "normalized": "(a-\u003eb)-\u003eVect c(SymmetricAlgebra a)-\u003eVect c(SymmetricAlgebra b)",
          "package": "HaskellForMaths",
          "partial": "Sym'",
          "signature": "(a-\u003eb)-\u003eVect k(SymmetricAlgebra a)-\u003eVect k(SymmetricAlgebra b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:fmapSym-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTensor algebra is a functor from k-Vect to k-Alg.\n The action on objects is Vect k a -\u003e Vect k (TensorAlgebra a).\n The action on arrows is f -\u003e fmapTA f.\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "fmapTA",
          "package": "HaskellForMaths",
          "signature": "(Vect k a -\u003e Vect k b) -\u003e Vect k (TensorAlgebra a) -\u003e Vect k (TensorAlgebra b)",
          "source": "src/Math-Algebras-TensorAlgebra.html#fmapTA",
          "type": "function"
        },
        "index": {
          "description": "Tensor algebra is functor from k-Vect to k-Alg The action on objects is Vect Vect TensorAlgebra The action on arrows is fmapTA",
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "fmapTA",
          "normalized": "(Vect a b-\u003eVect a c)-\u003eVect a(TensorAlgebra b)-\u003eVect a(TensorAlgebra c)",
          "package": "HaskellForMaths",
          "partial": "TA",
          "signature": "(Vect k a-\u003eVect k b)-\u003eVect k(TensorAlgebra a)-\u003eVect k(TensorAlgebra b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:fmapTA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf we compose the free vector space functor Set -\u003e k-Vect with the tensor algebra functor k-Vect -\u003e k-Alg,\n we obtain a functor Set -\u003e k-Alg, the free algebra functor.\n The action on objects is a -\u003e Vect k (TensorAlgebra a).\n The action on arrows is f -\u003e fmapTA' f.\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "fmapTA'",
          "package": "HaskellForMaths",
          "signature": "(a -\u003e b) -\u003e Vect k (TensorAlgebra a) -\u003e Vect k (TensorAlgebra b)",
          "source": "src/Math-Algebras-TensorAlgebra.html#fmapTA%27",
          "type": "function"
        },
        "index": {
          "description": "If we compose the free vector space functor Set k-Vect with the tensor algebra functor k-Vect k-Alg we obtain functor Set k-Alg the free algebra functor The action on objects is Vect TensorAlgebra The action on arrows is fmapTA",
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "fmapTA'",
          "normalized": "(a-\u003eb)-\u003eVect c(TensorAlgebra a)-\u003eVect c(TensorAlgebra b)",
          "package": "HaskellForMaths",
          "partial": "TA'",
          "signature": "(a-\u003eb)-\u003eVect k(TensorAlgebra a)-\u003eVect k(TensorAlgebra b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:fmapTA-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "injectExt",
          "package": "HaskellForMaths",
          "signature": "Vect k a -\u003e Vect k (ExteriorAlgebra a)",
          "source": "src/Math-Algebras-TensorAlgebra.html#injectExt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "injectExt",
          "normalized": "Vect a b-\u003eVect a(ExteriorAlgebra b)",
          "package": "HaskellForMaths",
          "partial": "Ext",
          "signature": "Vect k a-\u003eVect k(ExteriorAlgebra a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:injectExt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "injectExt'",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Vect k (ExteriorAlgebra a)",
          "source": "src/Math-Algebras-TensorAlgebra.html#injectExt%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "injectExt'",
          "normalized": "a-\u003eVect b(ExteriorAlgebra a)",
          "package": "HaskellForMaths",
          "partial": "Ext'",
          "signature": "a-\u003eVect k(ExteriorAlgebra a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:injectExt-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "injectSym",
          "package": "HaskellForMaths",
          "signature": "Vect k a -\u003e Vect k (SymmetricAlgebra a)",
          "source": "src/Math-Algebras-TensorAlgebra.html#injectSym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "injectSym",
          "normalized": "Vect a b-\u003eVect a(SymmetricAlgebra b)",
          "package": "HaskellForMaths",
          "partial": "Sym",
          "signature": "Vect k a-\u003eVect k(SymmetricAlgebra a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:injectSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "injectSym'",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Vect k (SymmetricAlgebra a)",
          "source": "src/Math-Algebras-TensorAlgebra.html#injectSym%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "injectSym'",
          "normalized": "a-\u003eVect b(SymmetricAlgebra a)",
          "package": "HaskellForMaths",
          "partial": "Sym'",
          "signature": "a-\u003eVect k(SymmetricAlgebra a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:injectSym-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject an element of the free vector space V = Vect k a into the tensor algebra T(V) = Vect k (TensorAlgebra a)\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "injectTA",
          "package": "HaskellForMaths",
          "signature": "Vect k a -\u003e Vect k (TensorAlgebra a)",
          "source": "src/Math-Algebras-TensorAlgebra.html#injectTA",
          "type": "function"
        },
        "index": {
          "description": "Inject an element of the free vector space Vect into the tensor algebra Vect TensorAlgebra",
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "injectTA",
          "normalized": "Vect a b-\u003eVect a(TensorAlgebra b)",
          "package": "HaskellForMaths",
          "partial": "TA",
          "signature": "Vect k a-\u003eVect k(TensorAlgebra a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:injectTA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject an element of the set/type A/a into the tensor algebra T(A) = Vect k (TensorAlgebra a).\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "injectTA'",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Vect k (TensorAlgebra a)",
          "source": "src/Math-Algebras-TensorAlgebra.html#injectTA%27",
          "type": "function"
        },
        "index": {
          "description": "Inject an element of the set type into the tensor algebra Vect TensorAlgebra",
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "injectTA'",
          "normalized": "a-\u003eVect b(TensorAlgebra a)",
          "package": "HaskellForMaths",
          "partial": "TA'",
          "signature": "a-\u003eVect k(TensorAlgebra a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:injectTA-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "liftExt",
          "package": "HaskellForMaths",
          "signature": "(Vect k a -\u003e Vect k b) -\u003e Vect k (ExteriorAlgebra a) -\u003e Vect k b",
          "source": "src/Math-Algebras-TensorAlgebra.html#liftExt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "liftExt",
          "normalized": "(Vect a b-\u003eVect a c)-\u003eVect a(ExteriorAlgebra b)-\u003eVect a c",
          "package": "HaskellForMaths",
          "partial": "Ext",
          "signature": "(Vect k a-\u003eVect k b)-\u003eVect k(ExteriorAlgebra a)-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:liftExt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "liftExt'",
          "package": "HaskellForMaths",
          "signature": "(a -\u003e Vect k b) -\u003e Vect k (ExteriorAlgebra a) -\u003e Vect k b",
          "source": "src/Math-Algebras-TensorAlgebra.html#liftExt%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "liftExt'",
          "normalized": "(a-\u003eVect b c)-\u003eVect b(ExteriorAlgebra a)-\u003eVect b c",
          "package": "HaskellForMaths",
          "partial": "Ext'",
          "signature": "(a-\u003eVect k b)-\u003eVect k(ExteriorAlgebra a)-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:liftExt-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "liftSym",
          "package": "HaskellForMaths",
          "signature": "(Vect k a -\u003e Vect k b) -\u003e Vect k (SymmetricAlgebra a) -\u003e Vect k b",
          "source": "src/Math-Algebras-TensorAlgebra.html#liftSym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "liftSym",
          "normalized": "(Vect a b-\u003eVect a c)-\u003eVect a(SymmetricAlgebra b)-\u003eVect a c",
          "package": "HaskellForMaths",
          "partial": "Sym",
          "signature": "(Vect k a-\u003eVect k b)-\u003eVect k(SymmetricAlgebra a)-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:liftSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "liftSym'",
          "package": "HaskellForMaths",
          "signature": "(a -\u003e Vect k b) -\u003e Vect k (SymmetricAlgebra a) -\u003e Vect k b",
          "source": "src/Math-Algebras-TensorAlgebra.html#liftSym%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "liftSym'",
          "normalized": "(a-\u003eVect b c)-\u003eVect b(SymmetricAlgebra a)-\u003eVect b c",
          "package": "HaskellForMaths",
          "partial": "Sym'",
          "signature": "(a-\u003eVect k b)-\u003eVect k(SymmetricAlgebra a)-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:liftSym-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven vector spaces A = Vect k a, B = Vect k b, where B is also an algebra,\n lift a linear map f: A -\u003e B to an algebra morphism f': T(A) -\u003e B,\n where T(A) is the tensor algebra Vect k (TensorAlgebra a).\n f' will agree with f on A itself (considered as a subspace of T(A)).\n In other words, f = f' . injectTA\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "liftTA",
          "package": "HaskellForMaths",
          "signature": "(Vect k a -\u003e Vect k b) -\u003e Vect k (TensorAlgebra a) -\u003e Vect k b",
          "source": "src/Math-Algebras-TensorAlgebra.html#liftTA",
          "type": "function"
        },
        "index": {
          "description": "Given vector spaces Vect Vect where is also an algebra lift linear map to an algebra morphism where is the tensor algebra Vect TensorAlgebra will agree with on itself considered as subspace of In other words injectTA",
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "liftTA",
          "normalized": "(Vect a b-\u003eVect a c)-\u003eVect a(TensorAlgebra b)-\u003eVect a c",
          "package": "HaskellForMaths",
          "partial": "TA",
          "signature": "(Vect k a-\u003eVect k b)-\u003eVect k(TensorAlgebra a)-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:liftTA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a set/type A/a, and a vector space B = Vect k b, where B is also an algebra,\n lift a function f: A -\u003e B to an algebra morphism f': T(A) -\u003e B.\n f' will agree with f on A itself. In other words, f = f' . injectTA'\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "liftTA'",
          "package": "HaskellForMaths",
          "signature": "(a -\u003e Vect k b) -\u003e Vect k (TensorAlgebra a) -\u003e Vect k b",
          "source": "src/Math-Algebras-TensorAlgebra.html#liftTA%27",
          "type": "function"
        },
        "index": {
          "description": "Given set type and vector space Vect where is also an algebra lift function to an algebra morphism will agree with on itself In other words injectTA",
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "liftTA'",
          "normalized": "(a-\u003eVect b c)-\u003eVect b(TensorAlgebra a)-\u003eVect b c",
          "package": "HaskellForMaths",
          "partial": "TA'",
          "signature": "(a-\u003eVect k b)-\u003eVect k(TensorAlgebra a)-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:liftTA-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "projectTC",
          "package": "HaskellForMaths",
          "signature": "Vect k (TensorCoalgebra b) -\u003e Vect k b",
          "source": "src/Math-Algebras-TensorAlgebra.html#projectTC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "projectTC",
          "normalized": "Vect a(TensorCoalgebra b)-\u003eVect a b",
          "package": "HaskellForMaths",
          "partial": "TC",
          "signature": "Vect k(TensorCoalgebra b)-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:projectTC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorAlgebra",
          "name": "signedSort",
          "package": "HaskellForMaths",
          "signature": "t -\u003e Bool -\u003e [a] -\u003e [a] -\u003e (t, [a])",
          "source": "src/Math-Algebras-TensorAlgebra.html#signedSort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "signedSort",
          "normalized": "a-\u003eBool-\u003e[b]-\u003e[b]-\u003e(a,[b])",
          "package": "HaskellForMaths",
          "partial": "Sort",
          "signature": "t-\u003eBool-\u003e[a]-\u003e[a]-\u003e(t,[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:signedSort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlgebra morphism from tensor algebra to exterior algebra.\n The kernel of the morphism is the ideal generated by all\n self-products u&#8855;u and sums of products u&#8855;v + v&#8855;u\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "toExt",
          "package": "HaskellForMaths",
          "signature": "Vect k (TensorAlgebra a) -\u003e Vect k (ExteriorAlgebra a)",
          "source": "src/Math-Algebras-TensorAlgebra.html#toExt",
          "type": "function"
        },
        "index": {
          "description": "Algebra morphism from tensor algebra to exterior algebra The kernel of the morphism is the ideal generated by all self-products and sums of products",
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "toExt",
          "normalized": "Vect a(TensorAlgebra b)-\u003eVect a(ExteriorAlgebra b)",
          "package": "HaskellForMaths",
          "partial": "Ext",
          "signature": "Vect k(TensorAlgebra a)-\u003eVect k(ExteriorAlgebra a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:toExt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlgebra morphism from tensor algebra to symmetric algebra.\n The kernel of the morphism is the ideal generated by all\n differences of products u&#8855;v - v&#8855;u.\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "toSym",
          "package": "HaskellForMaths",
          "signature": "Vect k (TensorAlgebra a) -\u003e Vect k (SymmetricAlgebra a)",
          "source": "src/Math-Algebras-TensorAlgebra.html#toSym",
          "type": "function"
        },
        "index": {
          "description": "Algebra morphism from tensor algebra to symmetric algebra The kernel of the morphism is the ideal generated by all differences of products",
          "hierarchy": "Math Algebras TensorAlgebra",
          "module": "Math.Algebras.TensorAlgebra",
          "name": "toSym",
          "normalized": "Vect a(TensorAlgebra b)-\u003eVect a(SymmetricAlgebra b)",
          "package": "HaskellForMaths",
          "partial": "Sym",
          "signature": "Vect k(TensorAlgebra a)-\u003eVect k(SymmetricAlgebra a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorAlgebra.html#v:toSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining direct sum and tensor product of vector spaces\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Algebras.TensorProduct",
          "name": "TensorProduct",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-TensorProduct.html",
          "type": "module"
        },
        "index": {
          "description": "module defining direct sum and tensor product of vector spaces",
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "TensorProduct",
          "package": "HaskellForMaths",
          "partial": "Tensor Product",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type for constructing a basis for the direct sum of vector spaces.\n The direct sum of Vect k a and Vect k b is Vect k (DSum a b)\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorProduct",
          "name": "DSum",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-TensorProduct.html#DSum",
          "type": "type"
        },
        "index": {
          "description": "type for constructing basis for the direct sum of vector spaces The direct sum of Vect and Vect is Vect DSum",
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "DSum",
          "package": "HaskellForMaths",
          "partial": "DSum",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#t:DSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type for constructing a basis for the tensor product of vector spaces.\n The tensor product of Vect k a and Vect k b is Vect k (Tensor a b)\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorProduct",
          "name": "Tensor",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-TensorProduct.html#Tensor",
          "type": "type"
        },
        "index": {
          "description": "type for constructing basis for the tensor product of vector spaces The tensor product of Vect and Vect is Vect Tensor",
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "Tensor",
          "package": "HaskellForMaths",
          "partial": "Tensor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#t:Tensor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorProduct",
          "name": "assocL",
          "package": "HaskellForMaths",
          "signature": "Vect k (Tensor a (Tensor b c)) -\u003e Vect k (Tensor (Tensor a b) c)",
          "source": "src/Math-Algebras-TensorProduct.html#assocL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "assocL",
          "normalized": "Vect a(Tensor b(Tensor c d))-\u003eVect a(Tensor(Tensor b c)d)",
          "package": "HaskellForMaths",
          "signature": "Vect k(Tensor a(Tensor b c))-\u003eVect k(Tensor(Tensor a b)c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:assocL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorProduct",
          "name": "assocR",
          "package": "HaskellForMaths",
          "signature": "Vect k (Tensor (Tensor a b) c) -\u003e Vect k (Tensor a (Tensor b c))",
          "source": "src/Math-Algebras-TensorProduct.html#assocR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "assocR",
          "normalized": "Vect a(Tensor(Tensor b c)d)-\u003eVect a(Tensor b(Tensor c d))",
          "package": "HaskellForMaths",
          "signature": "Vect k(Tensor(Tensor a b)c)-\u003eVect k(Tensor a(Tensor b c))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:assocR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe coproduct of two linear functions (with the same target).\n Satisfies the universal property that f == coprodf f g . i1 and g == coprodf f g . i2\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorProduct",
          "name": "coprodf",
          "package": "HaskellForMaths",
          "signature": "(Vect k a -\u003e Vect k t) -\u003e (Vect k b -\u003e Vect k t) -\u003e Vect k (DSum a b) -\u003e Vect k t",
          "source": "src/Math-Algebras-TensorProduct.html#coprodf",
          "type": "function"
        },
        "index": {
          "description": "The coproduct of two linear functions with the same target Satisfies the universal property that coprodf i1 and coprodf i2",
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "coprodf",
          "normalized": "(Vect a b-\u003eVect a c)-\u003e(Vect a d-\u003eVect a c)-\u003eVect a(DSum b d)-\u003eVect a c",
          "package": "HaskellForMaths",
          "signature": "(Vect k a-\u003eVect k t)-\u003e(Vect k b-\u003eVect k t)-\u003eVect k(DSum a b)-\u003eVect k t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:coprodf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorProduct",
          "name": "delta",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a -\u003e a1",
          "source": "src/Math-Algebras-TensorProduct.html#delta",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "delta",
          "normalized": "a-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:delta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorProduct",
          "name": "distrL",
          "package": "HaskellForMaths",
          "signature": "Vect k (Tensor a (DSum b c)) -\u003e Vect k (DSum (Tensor a b) (Tensor a c))",
          "source": "src/Math-Algebras-TensorProduct.html#distrL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "distrL",
          "normalized": "Vect a(Tensor b(DSum c d))-\u003eVect a(DSum(Tensor b c)(Tensor b d))",
          "package": "HaskellForMaths",
          "signature": "Vect k(Tensor a(DSum b c))-\u003eVect k(DSum(Tensor a b)(Tensor a c))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:distrL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorProduct",
          "name": "distrR",
          "package": "HaskellForMaths",
          "signature": "Vect k (Tensor (DSum a b) c) -\u003e Vect k (DSum (Tensor a c) (Tensor b c))",
          "source": "src/Math-Algebras-TensorProduct.html#distrR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "distrR",
          "normalized": "Vect a(Tensor(DSum b c)d)-\u003eVect a(DSum(Tensor b d)(Tensor c d))",
          "package": "HaskellForMaths",
          "signature": "Vect k(Tensor(DSum a b)c)-\u003eVect k(DSum(Tensor a c)(Tensor b c))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:distrR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe direct sum of two vector space elements\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorProduct",
          "name": "dsume",
          "package": "HaskellForMaths",
          "signature": "Vect k a -\u003e Vect k b -\u003e Vect k (DSum a b)",
          "source": "src/Math-Algebras-TensorProduct.html#dsume",
          "type": "function"
        },
        "index": {
          "description": "The direct sum of two vector space elements",
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "dsume",
          "normalized": "Vect a b-\u003eVect a c-\u003eVect a(DSum b c)",
          "package": "HaskellForMaths",
          "signature": "Vect k a-\u003eVect k b-\u003eVect k(DSum a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:dsume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe direct sum of two linear functions.\n Satisfies the universal property that f == p1 . dsumf f g . i1 and g == p2 . dsumf f g . i2\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorProduct",
          "name": "dsumf",
          "package": "HaskellForMaths",
          "signature": "(Vect k a -\u003e Vect k a') -\u003e (Vect k b -\u003e Vect k b') -\u003e Vect k (DSum a b) -\u003e Vect k (DSum a' b')",
          "source": "src/Math-Algebras-TensorProduct.html#dsumf",
          "type": "function"
        },
        "index": {
          "description": "The direct sum of two linear functions Satisfies the universal property that p1 dsumf i1 and p2 dsumf i2",
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "dsumf",
          "normalized": "(Vect a b-\u003eVect a c)-\u003e(Vect a d-\u003eVect a e)-\u003eVect a(DSum b d)-\u003eVect a(DSum c e)",
          "package": "HaskellForMaths",
          "signature": "(Vect k a-\u003eVect k a')-\u003e(Vect k b-\u003eVect k b')-\u003eVect k(DSum a b)-\u003eVect k(DSum a' b')",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:dsumf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorProduct",
          "name": "ev",
          "package": "HaskellForMaths",
          "signature": "Vect k (Tensor (Dual b) b) -\u003e k",
          "source": "src/Math-Algebras-TensorProduct.html#ev",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "ev",
          "normalized": "Vect a(Tensor(Dual b)b)-\u003ea",
          "package": "HaskellForMaths",
          "signature": "Vect k(Tensor(Dual b)b)-\u003ek",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:ev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInjection of left summand into direct sum\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorProduct",
          "name": "i1",
          "package": "HaskellForMaths",
          "signature": "Vect k a -\u003e Vect k (DSum a b)",
          "source": "src/Math-Algebras-TensorProduct.html#i1",
          "type": "function"
        },
        "index": {
          "description": "Injection of left summand into direct sum",
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "i1",
          "normalized": "Vect a b-\u003eVect a(DSum b c)",
          "package": "HaskellForMaths",
          "signature": "Vect k a-\u003eVect k(DSum a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:i1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInjection of right summand into direct sum\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorProduct",
          "name": "i2",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e Vect k (DSum a b)",
          "source": "src/Math-Algebras-TensorProduct.html#i2",
          "type": "function"
        },
        "index": {
          "description": "Injection of right summand into direct sum",
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "i2",
          "normalized": "Vect a b-\u003eVect a(DSum c b)",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003eVect k(DSum a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:i2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProjection onto left summand from direct sum\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorProduct",
          "name": "p1",
          "package": "HaskellForMaths",
          "signature": "Vect k (DSum a b) -\u003e Vect k a",
          "source": "src/Math-Algebras-TensorProduct.html#p1",
          "type": "function"
        },
        "index": {
          "description": "Projection onto left summand from direct sum",
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "p1",
          "normalized": "Vect a(DSum b c)-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k(DSum a b)-\u003eVect k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:p1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProjection onto right summand from direct sum\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorProduct",
          "name": "p2",
          "package": "HaskellForMaths",
          "signature": "Vect k (DSum a b) -\u003e Vect k b",
          "source": "src/Math-Algebras-TensorProduct.html#p2",
          "type": "function"
        },
        "index": {
          "description": "Projection onto right summand from direct sum",
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "p2",
          "normalized": "Vect a(DSum b c)-\u003eVect a c",
          "package": "HaskellForMaths",
          "signature": "Vect k(DSum a b)-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:p2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe product of two linear functions (with the same source).\n Satisfies the universal property that f == p1 . prodf f g and g == p2 . prodf f g\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorProduct",
          "name": "prodf",
          "package": "HaskellForMaths",
          "signature": "(Vect k s -\u003e Vect k a) -\u003e (Vect k s -\u003e Vect k b) -\u003e Vect k s -\u003e Vect k (DSum a b)",
          "source": "src/Math-Algebras-TensorProduct.html#prodf",
          "type": "function"
        },
        "index": {
          "description": "The product of two linear functions with the same source Satisfies the universal property that p1 prodf and p2 prodf",
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "prodf",
          "normalized": "(Vect a b-\u003eVect a c)-\u003e(Vect a b-\u003eVect a d)-\u003eVect a b-\u003eVect a(DSum c d)",
          "package": "HaskellForMaths",
          "signature": "(Vect k s-\u003eVect k a)-\u003e(Vect k s-\u003eVect k b)-\u003eVect k s-\u003eVect k(DSum a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:prodf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorProduct",
          "name": "reify",
          "package": "HaskellForMaths",
          "signature": "Vect k (Dual b) -\u003e Vect k b -\u003e k",
          "source": "src/Math-Algebras-TensorProduct.html#reify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "reify",
          "normalized": "Vect a(Dual b)-\u003eVect a b-\u003ea",
          "package": "HaskellForMaths",
          "signature": "Vect k(Dual b)-\u003eVect k b-\u003ek",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:reify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe tensor product of two vector space elements\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorProduct",
          "name": "te",
          "package": "HaskellForMaths",
          "signature": "Vect k a -\u003e Vect k b -\u003e Vect k (Tensor a b)",
          "source": "src/Math-Algebras-TensorProduct.html#te",
          "type": "function"
        },
        "index": {
          "description": "The tensor product of two vector space elements",
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "te",
          "normalized": "Vect a b-\u003eVect a c-\u003eVect a(Tensor b c)",
          "package": "HaskellForMaths",
          "signature": "Vect k a-\u003eVect k b-\u003eVect k(Tensor a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:te"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe tensor product of two linear functions\n\u003c/p\u003e",
          "module": "Math.Algebras.TensorProduct",
          "name": "tf",
          "package": "HaskellForMaths",
          "signature": "(Vect k a -\u003e Vect k a') -\u003e (Vect k b -\u003e Vect k b') -\u003e Vect k (Tensor a b) -\u003e Vect k (Tensor a' b')",
          "source": "src/Math-Algebras-TensorProduct.html#tf",
          "type": "function"
        },
        "index": {
          "description": "The tensor product of two linear functions",
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "tf",
          "normalized": "(Vect a b-\u003eVect a c)-\u003e(Vect a d-\u003eVect a e)-\u003eVect a(Tensor b d)-\u003eVect a(Tensor c e)",
          "package": "HaskellForMaths",
          "signature": "(Vect k a-\u003eVect k a')-\u003e(Vect k b-\u003eVect k b')-\u003eVect k(Tensor a b)-\u003eVect k(Tensor a' b')",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:tf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorProduct",
          "name": "twist",
          "package": "HaskellForMaths",
          "signature": "Vect k (Tensor a b) -\u003e Vect k (Tensor b a)",
          "source": "src/Math-Algebras-TensorProduct.html#twist",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "twist",
          "normalized": "Vect a(Tensor b c)-\u003eVect a(Tensor c b)",
          "package": "HaskellForMaths",
          "signature": "Vect k(Tensor a b)-\u003eVect k(Tensor b a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:twist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorProduct",
          "name": "undistrL",
          "package": "HaskellForMaths",
          "signature": "Vect k (DSum (Tensor a b) (Tensor a c)) -\u003e Vect k (Tensor a (DSum b c))",
          "source": "src/Math-Algebras-TensorProduct.html#undistrL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "undistrL",
          "normalized": "Vect a(DSum(Tensor b c)(Tensor b d))-\u003eVect a(Tensor b(DSum c d))",
          "package": "HaskellForMaths",
          "signature": "Vect k(DSum(Tensor a b)(Tensor a c))-\u003eVect k(Tensor a(DSum b c))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:undistrL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorProduct",
          "name": "undistrR",
          "package": "HaskellForMaths",
          "signature": "Vect k (DSum (Tensor a c) (Tensor b c)) -\u003e Vect k (Tensor (DSum a b) c)",
          "source": "src/Math-Algebras-TensorProduct.html#undistrR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "undistrR",
          "normalized": "Vect a(DSum(Tensor b c)(Tensor d c))-\u003eVect a(Tensor(DSum b d)c)",
          "package": "HaskellForMaths",
          "signature": "Vect k(DSum(Tensor a c)(Tensor b c))-\u003eVect k(Tensor(DSum a b)c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:undistrR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorProduct",
          "name": "unitInL",
          "package": "HaskellForMaths",
          "signature": "Vect k a -\u003e Vect k (Tensor () a)",
          "source": "src/Math-Algebras-TensorProduct.html#unitInL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "unitInL",
          "normalized": "Vect a b-\u003eVect a(Tensor()b)",
          "package": "HaskellForMaths",
          "partial": "In",
          "signature": "Vect k a-\u003eVect k(Tensor()a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:unitInL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorProduct",
          "name": "unitInR",
          "package": "HaskellForMaths",
          "signature": "Vect k a -\u003e Vect k (Tensor a ())",
          "source": "src/Math-Algebras-TensorProduct.html#unitInR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "unitInR",
          "normalized": "Vect a b-\u003eVect a(Tensor b())",
          "package": "HaskellForMaths",
          "partial": "In",
          "signature": "Vect k a-\u003eVect k(Tensor a())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:unitInR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorProduct",
          "name": "unitOutL",
          "package": "HaskellForMaths",
          "signature": "Vect k (Tensor () a) -\u003e Vect k a",
          "source": "src/Math-Algebras-TensorProduct.html#unitOutL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "unitOutL",
          "normalized": "Vect a(Tensor()b)-\u003eVect a b",
          "package": "HaskellForMaths",
          "partial": "Out",
          "signature": "Vect k(Tensor()a)-\u003eVect k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:unitOutL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.TensorProduct",
          "name": "unitOutR",
          "package": "HaskellForMaths",
          "signature": "Vect k (Tensor a ()) -\u003e Vect k a",
          "source": "src/Math-Algebras-TensorProduct.html#unitOutR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras TensorProduct",
          "module": "Math.Algebras.TensorProduct",
          "name": "unitOutR",
          "normalized": "Vect a(Tensor b())-\u003eVect a b",
          "package": "HaskellForMaths",
          "partial": "Out",
          "signature": "Vect k(Tensor a())-\u003eVect k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-TensorProduct.html#v:unitOutR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining the type and operations of free k-vector spaces over a basis b (for a field k)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "VectorSpace",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-VectorSpace.html",
          "type": "module"
        },
        "index": {
          "description": "module defining the type and operations of free k-vector spaces over basis for field",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "VectorSpace",
          "package": "HaskellForMaths",
          "partial": "Vector Space",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a finite vector space basis b, Dual b can be used to represent a basis for the dual vector space.\n The intention is that for a given individual basis element b_i, (Dual b_i) represents the indicator function for b_i,\n which takes b_i to 1 and all other basis elements to 0.\n\u003c/p\u003e\u003cp\u003e(Note that if the basis b is infinite, then Dual b may only represent a sub-basis of the dual vector space.)\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "Dual",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-VectorSpace.html#Dual",
          "type": "newtype"
        },
        "index": {
          "description": "Given finite vector space basis Dual can be used to represent basis for the dual vector space The intention is that for given individual basis element Dual represents the indicator function for which takes to and all other basis elements to Note that if the basis is infinite then Dual may only represent sub-basis of the dual vector space",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "Dual",
          "package": "HaskellForMaths",
          "partial": "Dual",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#t:Dual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrivial k is the field k considered as a k-vector space. In maths, we would not normally make a distinction here,\n but in the code, we need this if we want to be able to put k as one side of a tensor product.\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "Trivial",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-VectorSpace.html#Trivial",
          "type": "type"
        },
        "index": {
          "description": "Trivial is the field considered as k-vector space In maths we would not normally make distinction here but in the code we need this if we want to be able to put as one side of tensor product",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "Trivial",
          "package": "HaskellForMaths",
          "partial": "Trivial",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#t:Trivial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a field type k and a basis type b, Vect k b is the type of the free k-vector space over b.\n Elements (values) of Vect k b consist of k-linear combinations of elements (values) of b.\n\u003c/p\u003e\u003cp\u003eIn order for Vect k b to be a vector space, it is necessary that k is a field (that is, an instance of Fractional).\n In practice, we often relax this condition, and require that k is a ring (that is, an instance of Num). In that case,\n Vect k b should more correctly be called (the type of) the free k-module over b.\n\u003c/p\u003e\u003cp\u003eMost of the code requires that b is an instance of Ord. This is primarily to enable us to simplify to a normal form.\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "Vect",
          "package": "HaskellForMaths",
          "source": "src/Math-Algebras-VectorSpace.html#Vect",
          "type": "newtype"
        },
        "index": {
          "description": "Given field type and basis type Vect is the type of the free k-vector space over Elements values of Vect consist of k-linear combinations of elements values of In order for Vect to be vector space it is necessary that is field that is an instance of Fractional In practice we often relax this condition and require that is ring that is an instance of Num In that case Vect should more correctly be called the type of the free k-module over Most of the code requires that is an instance of Ord This is primarily to enable us to simplify to normal form",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "Vect",
          "package": "HaskellForMaths",
          "partial": "Vect",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#t:Vect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as smultL. Mnemonic is \"multiply through (from the left)\"\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "(*\u003e)",
          "package": "HaskellForMaths",
          "signature": "k -\u003e Vect k b -\u003e Vect k b",
          "source": "src/Math-Algebras-VectorSpace.html#%2A%3E",
          "type": "function"
        },
        "index": {
          "description": "Same as smultL Mnemonic is multiply through from the left",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "(*\u003e) *\u003e",
          "normalized": "a-\u003eVect a b-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "k-\u003eVect k b-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:-42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as smultR. Mnemonic is \"multiply through (from the right)\"\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "(\u003c*)",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e k -\u003e Vect k b",
          "source": "src/Math-Algebras-VectorSpace.html#%3C%2A",
          "type": "function"
        },
        "index": {
          "description": "Same as smultR Mnemonic is multiply through from the right",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "(\u003c*) \u003c*",
          "normalized": "Vect a b-\u003ea-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003ek-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:-60--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAddition of vectors (same as add)\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "(\u003c+\u003e)",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e Vect k b -\u003e Vect k b",
          "source": "src/Math-Algebras-VectorSpace.html#%3C%2B%3E",
          "type": "function"
        },
        "index": {
          "description": "Addition of vectors same as add",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "Vect a b-\u003eVect a b-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003eVect k b-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubtraction of vectors\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "(\u003c-\u003e)",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e Vect k b -\u003e Vect k b",
          "source": "src/Math-Algebras-VectorSpace.html#%3C-%3E",
          "type": "function"
        },
        "index": {
          "description": "Subtraction of vectors",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "(\u003c-\u003e) \u003c-\u003e",
          "normalized": "Vect a b-\u003eVect a b-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003eVect k b-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:-60--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.VectorSpace",
          "name": "Dual",
          "package": "HaskellForMaths",
          "signature": "Dual b",
          "source": "src/Math-Algebras-VectorSpace.html#Dual",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "Dual",
          "package": "HaskellForMaths",
          "partial": "Dual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:Dual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Algebras.VectorSpace",
          "name": "V",
          "package": "HaskellForMaths",
          "signature": "V [(b, k)]",
          "source": "src/Math-Algebras-VectorSpace.html#Vect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "V",
          "normalized": "V[(a,b)]",
          "package": "HaskellForMaths",
          "signature": "V[(b,k)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAddition of vectors\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "add",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e Vect k b -\u003e Vect k b",
          "source": "src/Math-Algebras-VectorSpace.html#add",
          "type": "function"
        },
        "index": {
          "description": "Addition of vectors",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "add",
          "normalized": "Vect a b-\u003eVect a b-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003eVect k b-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the coefficient of the specified basis element in a vector\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "coeff",
          "package": "HaskellForMaths",
          "signature": "a1 -\u003e Vect a a1 -\u003e a",
          "source": "src/Math-Algebras-VectorSpace.html#coeff",
          "type": "function"
        },
        "index": {
          "description": "Return the coefficient of the specified basis element in vector",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "coeff",
          "normalized": "a-\u003eVect a a-\u003ea",
          "package": "HaskellForMaths",
          "signature": "a-\u003eVect a a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:coeff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA linear map between vector spaces A and B can be defined by giving its action on the basis elements of A.\n The action on all elements of A then follows by linearity.\n\u003c/p\u003e\u003cp\u003eIf we have A = Vect k a, B = Vect k b, and f :: a -\u003e Vect k b is a function from the basis elements of A into B,\n then \u003ccode\u003elinear f\u003c/code\u003e is the linear map that this defines by linearity.\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "linear",
          "package": "HaskellForMaths",
          "signature": "(a -\u003e Vect k b) -\u003e Vect k a -\u003e Vect k b",
          "source": "src/Math-Algebras-VectorSpace.html#linear",
          "type": "function"
        },
        "index": {
          "description": "linear map between vector spaces and can be defined by giving its action on the basis elements of The action on all elements of then follows by linearity If we have Vect Vect and Vect is function from the basis elements of into then linear is the linear map that this defines by linearity",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "linear",
          "normalized": "(a-\u003eVect b c)-\u003eVect b a-\u003eVect b c",
          "package": "HaskellForMaths",
          "signature": "(a-\u003eVect k b)-\u003eVect k a-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNegation of a vector\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "negatev",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e Vect k b",
          "source": "src/Math-Algebras-VectorSpace.html#negatev",
          "type": "function"
        },
        "index": {
          "description": "Negation of vector",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "negatev",
          "normalized": "Vect a b-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:negatev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an element of Vect k b into normal form. Normal form consists in having the basis elements in ascending order,\n with no duplicates, and all coefficients non-zero\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "nf",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e Vect k b",
          "source": "src/Math-Algebras-VectorSpace.html#nf",
          "type": "function"
        },
        "index": {
          "description": "Convert an element of Vect into normal form Normal form consists in having the basis elements in ascending order with no duplicates and all coefficients non-zero",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "nf",
          "normalized": "Vect a b-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:nf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove the term for a specified basis element from a vector\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "removeTerm",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Vect k a -\u003e Vect k a",
          "source": "src/Math-Algebras-VectorSpace.html#removeTerm",
          "type": "function"
        },
        "index": {
          "description": "Remove the term for specified basis element from vector",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "removeTerm",
          "normalized": "a-\u003eVect b a-\u003eVect b a",
          "package": "HaskellForMaths",
          "partial": "Term",
          "signature": "a-\u003eVect k a-\u003eVect k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:removeTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScalar multiplication (on the left)\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "smultL",
          "package": "HaskellForMaths",
          "signature": "k -\u003e Vect k b -\u003e Vect k b",
          "source": "src/Math-Algebras-VectorSpace.html#smultL",
          "type": "function"
        },
        "index": {
          "description": "Scalar multiplication on the left",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "smultL",
          "normalized": "a-\u003eVect a b-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "k-\u003eVect k b-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:smultL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScalar multiplication on the right\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "smultR",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e k -\u003e Vect k b",
          "source": "src/Math-Algebras-VectorSpace.html#smultR",
          "type": "function"
        },
        "index": {
          "description": "Scalar multiplication on the right",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "smultR",
          "normalized": "Vect a b-\u003ea-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003ek-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:smultR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum of a list of vectors\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "sumv",
          "package": "HaskellForMaths",
          "signature": "[Vect k b] -\u003e Vect k b",
          "source": "src/Math-Algebras-VectorSpace.html#sumv",
          "type": "function"
        },
        "index": {
          "description": "Sum of list of vectors",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "sumv",
          "normalized": "[Vect a b]-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "[Vect k b]-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:sumv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnwrap an element of the trivial k-vector space to an element of the field k\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "unwrap",
          "package": "HaskellForMaths",
          "signature": "Vect k () -\u003e k",
          "source": "src/Math-Algebras-VectorSpace.html#unwrap",
          "type": "function"
        },
        "index": {
          "description": "Unwrap an element of the trivial k-vector space to an element of the field",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "unwrap",
          "normalized": "Vect a()-\u003ea",
          "package": "HaskellForMaths",
          "signature": "Vect k()-\u003ek",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:unwrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap an element of the field k to an element of the trivial k-vector space\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "wrap",
          "package": "HaskellForMaths",
          "signature": "k -\u003e Vect k ()",
          "source": "src/Math-Algebras-VectorSpace.html#wrap",
          "type": "function"
        },
        "index": {
          "description": "Wrap an element of the field to an element of the trivial k-vector space",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "wrap",
          "normalized": "a-\u003eVect a()",
          "package": "HaskellForMaths",
          "signature": "k-\u003eVect k()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:wrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe zero vector\n\u003c/p\u003e",
          "module": "Math.Algebras.VectorSpace",
          "name": "zerov",
          "package": "HaskellForMaths",
          "signature": "Vect k b",
          "source": "src/Math-Algebras-VectorSpace.html#zerov",
          "type": "function"
        },
        "index": {
          "description": "The zero vector",
          "hierarchy": "Math Algebras VectorSpace",
          "module": "Math.Algebras.VectorSpace",
          "name": "zerov",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Algebras-VectorSpace.html#v:zerov"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining the following Combinatorial Hopf Algebras, together with coalgebra or Hopf algebra morphisms between them:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Sh, the Shuffle Hopf algebra\n\u003c/li\u003e\u003cli\u003e SSym, the Malvenuto-Reutnenauer Hopf algebra of permutations\n\u003c/li\u003e\u003cli\u003e YSym, the (dual of the) Loday-Ronco Hopf algebra of binary trees\n\u003c/li\u003e\u003cli\u003e QSym, the Hopf algebra of quasi-symmetric functions (having a basis indexed by compositions)\n\u003c/li\u003e\u003cli\u003e Sym, the Hopf algebra of symmetric functions (having a basis indexed by integer partitions)\n\u003c/li\u003e\u003cli\u003e NSym, the Hopf algebra of non-commutative symmetric functions\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "CombinatorialHopfAlgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html",
          "type": "module"
        },
        "index": {
          "description": "module defining the following Combinatorial Hopf Algebras together with coalgebra or Hopf algebra morphisms between them Sh the Shuffle Hopf algebra SSym the Malvenuto-Reutnenauer Hopf algebra of permutations YSym the dual of the Loday-Ronco Hopf algebra of binary trees QSym the Hopf algebra of quasi-symmetric functions having basis indexed by compositions Sym the Hopf algebra of symmetric functions having basis indexed by integer partitions NSym the Hopf algebra of non-commutative symmetric functions",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "CombinatorialHopfAlgebra",
          "package": "HaskellForMaths",
          "partial": "Combinatorial Hopf Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA basis for NSym, the Hopf algebra of non-commutative symmetric functions, indexed by compositions\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "NSym",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#NSym",
          "type": "newtype"
        },
        "index": {
          "description": "basis for NSym the Hopf algebra of non-commutative symmetric functions indexed by compositions",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "NSym",
          "package": "HaskellForMaths",
          "partial": "NSym",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#t:NSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type for (rooted) planar binary trees. The basis elements of the Loday-Ronco Hopf algebra are indexed by these.\n\u003c/p\u003e\u003cp\u003eAlthough the trees are labelled, we're really only interested in the shapes of the trees, and hence in the type PBT ().\n The Algebra, Coalgebra and HopfAlgebra instances all ignore the labels.\n However, it is convenient to allow labels, as they can be useful for seeing what is going on, and they also make it possible\n to define various ways to create trees from lists of labels.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "PBT",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#PBT",
          "type": "data"
        },
        "index": {
          "description": "type for rooted planar binary trees The basis elements of the Loday-Ronco Hopf algebra are indexed by these Although the trees are labelled we re really only interested in the shapes of the trees and hence in the type PBT The Algebra Coalgebra and HopfAlgebra instances all ignore the labels However it is convenient to allow labels as they can be useful for seeing what is going on and they also make it possible to define various ways to create trees from lists of labels",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "PBT",
          "package": "HaskellForMaths",
          "partial": "PBT",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#t:PBT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type for the fundamental basis for the quasi-symmetric functions, indexed by compositions.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "QSymF",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#QSymF",
          "type": "newtype"
        },
        "index": {
          "description": "type for the fundamental basis for the quasi-symmetric functions indexed by compositions",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "QSymF",
          "package": "HaskellForMaths",
          "partial": "QSym",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#t:QSymF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type for the monomial basis for the quasi-symmetric functions, indexed by compositions.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "QSymM",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#QSymM",
          "type": "newtype"
        },
        "index": {
          "description": "type for the monomial basis for the quasi-symmetric functions indexed by compositions",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "QSymM",
          "package": "HaskellForMaths",
          "partial": "QSym",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#t:QSymM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe fundamental basis for the Malvenuto-Reutenauer Hopf algebra of permutations, SSym.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SSymF",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#SSymF",
          "type": "newtype"
        },
        "index": {
          "description": "The fundamental basis for the Malvenuto-Reutenauer Hopf algebra of permutations SSym",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SSymF",
          "package": "HaskellForMaths",
          "partial": "SSym",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#t:SSymF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn alternative \"monomial\" basis for the Malvenuto-Reutenauer Hopf algebra of permutations, SSym.\n This basis is related to the fundamental basis by Mobius inversion in the poset of permutations with the weak order.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SSymM",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#SSymM",
          "type": "newtype"
        },
        "index": {
          "description": "An alternative monomial basis for the Malvenuto-Reutenauer Hopf algebra of permutations SSym This basis is related to the fundamental basis by Mobius inversion in the poset of permutations with the weak order",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SSymM",
          "package": "HaskellForMaths",
          "partial": "SSym",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#t:SSymM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA basis for the shuffle algebra. As a vector space, the shuffle algebra is identical to the tensor algebra.\n However, we consider a different algebra structure, based on the shuffle product. Together with the\n deconcatenation coproduct, this leads to a Hopf algebra structure.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "Shuffle",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#Shuffle",
          "type": "newtype"
        },
        "index": {
          "description": "basis for the shuffle algebra As vector space the shuffle algebra is identical to the tensor algebra However we consider different algebra structure based on the shuffle product Together with the deconcatenation coproduct this leads to Hopf algebra structure",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "Shuffle",
          "package": "HaskellForMaths",
          "partial": "Shuffle",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#t:Shuffle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SymE",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#SymE",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SymE",
          "package": "HaskellForMaths",
          "partial": "Sym",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#t:SymE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SymH",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#SymH",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SymH",
          "package": "HaskellForMaths",
          "partial": "Sym",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#t:SymH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type for the monomial basis for Sym, the Hopf algebra of symmetric functions, indexed by integer partitions\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SymM",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#SymM",
          "type": "newtype"
        },
        "index": {
          "description": "type for the monomial basis for Sym the Hopf algebra of symmetric functions indexed by integer partitions",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SymM",
          "package": "HaskellForMaths",
          "partial": "Sym",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#t:SymM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe fundamental basis for (the dual of) the Loday-Ronco Hopf algebra of binary trees, YSym.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "YSymF",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#YSymF",
          "type": "newtype"
        },
        "index": {
          "description": "The fundamental basis for the dual of the Loday-Ronco Hopf algebra of binary trees YSym",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "YSymF",
          "package": "HaskellForMaths",
          "partial": "YSym",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#t:YSymF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn alternative \"monomial\" basis for (the dual of) the Loday-Ronco Hopf algebra of binary trees, YSym.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "YSymM",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#YSymM",
          "type": "newtype"
        },
        "index": {
          "description": "An alternative monomial basis for the dual of the Loday-Ronco Hopf algebra of binary trees YSym",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "YSymM",
          "package": "HaskellForMaths",
          "partial": "YSym",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#t:YSymM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "E",
          "package": "HaskellForMaths",
          "signature": "E",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#PBT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "E",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "NSym",
          "package": "HaskellForMaths",
          "signature": "NSym [Int]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#NSym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "NSym",
          "normalized": "NSym[Int]",
          "package": "HaskellForMaths",
          "partial": "NSym",
          "signature": "NSym[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:NSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "QSymF",
          "package": "HaskellForMaths",
          "signature": "QSymF [Int]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#QSymF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "QSymF",
          "normalized": "QSymF[Int]",
          "package": "HaskellForMaths",
          "partial": "QSym",
          "signature": "QSymF[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:QSymF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "QSymM",
          "package": "HaskellForMaths",
          "signature": "QSymM [Int]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#QSymM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "QSymM",
          "normalized": "QSymM[Int]",
          "package": "HaskellForMaths",
          "partial": "QSym",
          "signature": "QSymM[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:QSymM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SSymF",
          "package": "HaskellForMaths",
          "signature": "SSymF [Int]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#SSymF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SSymF",
          "normalized": "SSymF[Int]",
          "package": "HaskellForMaths",
          "partial": "SSym",
          "signature": "SSymF[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:SSymF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SSymM",
          "package": "HaskellForMaths",
          "signature": "SSymM [Int]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#SSymM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SSymM",
          "normalized": "SSymM[Int]",
          "package": "HaskellForMaths",
          "partial": "SSym",
          "signature": "SSymM[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:SSymM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "Sh",
          "package": "HaskellForMaths",
          "signature": "Sh [a]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#Shuffle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "Sh",
          "normalized": "Sh[a]",
          "package": "HaskellForMaths",
          "partial": "Sh",
          "signature": "Sh[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:Sh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SymE",
          "package": "HaskellForMaths",
          "signature": "SymE [Int]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#SymE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SymE",
          "normalized": "SymE[Int]",
          "package": "HaskellForMaths",
          "partial": "Sym",
          "signature": "SymE[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:SymE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SymH",
          "package": "HaskellForMaths",
          "signature": "SymH [Int]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#SymH",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SymH",
          "normalized": "SymH[Int]",
          "package": "HaskellForMaths",
          "partial": "Sym",
          "signature": "SymH[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:SymH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SymM",
          "package": "HaskellForMaths",
          "signature": "SymM [Int]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#SymM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "SymM",
          "normalized": "SymM[Int]",
          "package": "HaskellForMaths",
          "partial": "Sym",
          "signature": "SymM[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:SymM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "T",
          "package": "HaskellForMaths",
          "signature": "T (PBT a) a (PBT a)",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#PBT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "T",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "YSymF",
          "package": "HaskellForMaths",
          "signature": "YSymF (PBT a)",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#YSymF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "YSymF",
          "package": "HaskellForMaths",
          "partial": "YSym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:YSymF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "YSymM",
          "package": "HaskellForMaths",
          "signature": "YSymM (PBT ())",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#YSymM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "YSymM",
          "normalized": "YSymM(PBT())",
          "package": "HaskellForMaths",
          "partial": "YSym",
          "signature": "YSymM(PBT())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:YSymM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "coarsenings",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#coarsenings",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "coarsenings",
          "normalized": "[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:coarsenings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList the compositions of an integer n. For example, the compositions of 4 are [[1,1,1,1],[1,1,2],[1,2,1],[1,3],[2,1,1],[2,2],[3,1],[4]]\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "compositions",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [[Int]]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#compositions",
          "type": "function"
        },
        "index": {
          "description": "List the compositions of an integer For example the compositions of are",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "compositions",
          "normalized": "Int-\u003e[[Int]]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:compositions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "compositionsFromPartition",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#compositionsFromPartition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "compositionsFromPartition",
          "normalized": "[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "From Partition",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:compositionsFromPartition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "deconcatenations",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [([a], [a])]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#deconcatenations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "deconcatenations",
          "normalized": "[a]-\u003e[([a],[a])]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[([a],[a])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:deconcatenations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "descendingTree",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e PBT t",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#descendingTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "descendingTree",
          "normalized": "[a]-\u003ePBT a",
          "package": "HaskellForMaths",
          "partial": "Tree",
          "signature": "[t]-\u003ePBT t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:descendingTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a permutation p of [1..n], we can construct a tree (the descending tree of p) as follows:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Split the permutation as p = ls ++ [n] ++ rs\n\u003c/li\u003e\u003cli\u003e Place n at the root of the tree, and recursively place the descending trees of ls and rs as the left and right children of the root\n\u003c/li\u003e\u003cli\u003e To bottom out the recursion, the descending tree of the empty permutation is of course the empty tree\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThis map between bases SSymF -\u003e YSymF turns out to induce a morphism of Hopf algebras.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "descendingTreeMap",
          "package": "HaskellForMaths",
          "signature": "Vect k SSymF -\u003e Vect k (YSymF ())",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#descendingTreeMap",
          "type": "function"
        },
        "index": {
          "description": "Given permutation of we can construct tree the descending tree of as follows Split the permutation as ls rs Place at the root of the tree and recursively place the descending trees of ls and rs as the left and right children of the root To bottom out the recursion the descending tree of the empty permutation is of course the empty tree This map between bases SSymF YSymF turns out to induce morphism of Hopf algebras",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "descendingTreeMap",
          "normalized": "Vect a SSymF-\u003eVect a(YSymF())",
          "package": "HaskellForMaths",
          "partial": "Tree Map",
          "signature": "Vect k SSymF-\u003eVect k(YSymF())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:descendingTreeMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "descentComposition",
          "package": "HaskellForMaths",
          "signature": "[b] -\u003e [Int]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#descentComposition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "descentComposition",
          "normalized": "[a]-\u003e[Int]",
          "package": "HaskellForMaths",
          "partial": "Composition",
          "signature": "[b]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:descentComposition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a permutation of [1..n], its descents are those positions where the next number is less than the previous number.\n For example, the permutation [2,3,5,1,6,4] has descents from 5 to 1 and from 6 to 4. The descents can be regarded as cutting\n the permutation sequence into segments - 235-16-4 - and by counting the lengths of the segments, we get a composition 3+2+1.\n This map between bases SSymF -\u003e QSymF turns out to induce a morphism of Hopf algebras.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "descentMap",
          "package": "HaskellForMaths",
          "signature": "Vect k SSymF -\u003e Vect k QSymF",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#descentMap",
          "type": "function"
        },
        "index": {
          "description": "Given permutation of its descents are those positions where the next number is less than the previous number For example the permutation has descents from to and from to The descents can be regarded as cutting the permutation sequence into segments and by counting the lengths of the segments we get composition This map between bases SSymF QSymF turns out to induce morphism of Hopf algebras",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "descentMap",
          "normalized": "Vect a SSymF-\u003eVect a QSymF",
          "package": "HaskellForMaths",
          "partial": "Map",
          "signature": "Vect k SSymF-\u003eVect k QSymF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:descentMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "descents",
          "package": "HaskellForMaths",
          "signature": "[b] -\u003e [Int]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#descents",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "descents",
          "normalized": "[a]-\u003e[Int]",
          "package": "HaskellForMaths",
          "signature": "[b]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:descents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "flatten",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [t]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#flatten",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "flatten",
          "normalized": "[a]-\u003e[b]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:flatten"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "graft",
          "package": "HaskellForMaths",
          "signature": "[PBT a] -\u003e PBT a -\u003e PBT a",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#graft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "graft",
          "normalized": "[PBT a]-\u003ePBT a-\u003ePBT a",
          "package": "HaskellForMaths",
          "signature": "[PBT a]-\u003ePBT a-\u003ePBT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:graft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "inversions",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [(t, t)]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#inversions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "inversions",
          "normalized": "[a]-\u003e[(b,b)]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[(t,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:inversions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "isUnderIrreducible",
          "package": "HaskellForMaths",
          "signature": "PBT t -\u003e Bool",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#isUnderIrreducible",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "isUnderIrreducible",
          "normalized": "PBT a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Under Irreducible",
          "signature": "PBT t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:isUnderIrreducible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "leafCountTree",
          "package": "HaskellForMaths",
          "signature": "PBT t -\u003e PBT a",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#leafCountTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "leafCountTree",
          "normalized": "PBT a-\u003ePBT b",
          "package": "HaskellForMaths",
          "partial": "Count Tree",
          "signature": "PBT t-\u003ePBT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:leafCountTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "leafcount",
          "package": "HaskellForMaths",
          "signature": "PBT t -\u003e a",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#leafcount",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "leafcount",
          "normalized": "PBT a-\u003eb",
          "package": "HaskellForMaths",
          "signature": "PBT t-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:leafcount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "leftLeafComposition",
          "package": "HaskellForMaths",
          "signature": "PBT t -\u003e [Int]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#leftLeafComposition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "leftLeafComposition",
          "normalized": "PBT a-\u003e[Int]",
          "package": "HaskellForMaths",
          "partial": "Leaf Composition",
          "signature": "PBT t-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:leftLeafComposition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "leftLeafComposition'",
          "package": "HaskellForMaths",
          "signature": "YSymF t -\u003e QSymF",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#leftLeafComposition%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "leftLeafComposition'",
          "normalized": "YSymF a-\u003eQSymF",
          "package": "HaskellForMaths",
          "partial": "Leaf Composition'",
          "signature": "YSymF t-\u003eQSymF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:leftLeafComposition-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Hopf algebra morphism from YSymF to QSymF\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "leftLeafCompositionMap",
          "package": "HaskellForMaths",
          "signature": "Vect k (YSymF a) -\u003e Vect k QSymF",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#leftLeafCompositionMap",
          "type": "function"
        },
        "index": {
          "description": "Hopf algebra morphism from YSymF to QSymF",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "leftLeafCompositionMap",
          "normalized": "Vect a(YSymF b)-\u003eVect a QSymF",
          "package": "HaskellForMaths",
          "partial": "Leaf Composition Map",
          "signature": "Vect k(YSymF a)-\u003eVect k QSymF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:leftLeafCompositionMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "lrCountTree",
          "package": "HaskellForMaths",
          "signature": "PBT t -\u003e PBT (a, a)",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#lrCountTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "lrCountTree",
          "normalized": "PBT a-\u003ePBT(b,b)",
          "package": "HaskellForMaths",
          "partial": "Count Tree",
          "signature": "PBT t-\u003ePBT(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:lrCountTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "maxPerm",
          "package": "HaskellForMaths",
          "signature": "PBT t -\u003e [a]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#maxPerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "maxPerm",
          "normalized": "PBT a-\u003e[b]",
          "package": "HaskellForMaths",
          "partial": "Perm",
          "signature": "PBT t-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:maxPerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "minPerm",
          "package": "HaskellForMaths",
          "signature": "PBT t -\u003e [a]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#minPerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "minPerm",
          "normalized": "PBT a-\u003e[b]",
          "package": "HaskellForMaths",
          "partial": "Perm",
          "signature": "PBT t-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:minPerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "mu",
          "package": "HaskellForMaths",
          "signature": "([a], a -\u003e a -\u003e Bool) -\u003e a -\u003e a -\u003e a1",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#mu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "mu",
          "normalized": "([a],a-\u003ea-\u003eBool)-\u003ea-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "signature": "([a],a-\u003ea-\u003eBool)-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:mu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "multisplits",
          "package": "HaskellForMaths",
          "signature": "a -\u003e PBT a1 -\u003e [[PBT a1]]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#multisplits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "multisplits",
          "normalized": "a-\u003ePBT a-\u003e[[PBT a]]",
          "package": "HaskellForMaths",
          "signature": "a-\u003ePBT a-\u003e[[PBT a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:multisplits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "nodeCountTree",
          "package": "HaskellForMaths",
          "signature": "PBT t -\u003e PBT a",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#nodeCountTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "nodeCountTree",
          "normalized": "PBT a-\u003ePBT b",
          "package": "HaskellForMaths",
          "partial": "Count Tree",
          "signature": "PBT t-\u003ePBT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:nodeCountTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "nodecount",
          "package": "HaskellForMaths",
          "signature": "PBT t -\u003e a",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#nodecount",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "nodecount",
          "normalized": "PBT a-\u003eb",
          "package": "HaskellForMaths",
          "signature": "PBT t-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:nodecount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "nsym",
          "package": "HaskellForMaths",
          "signature": "[Int] -\u003e Vect Q NSym",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#nsym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "nsym",
          "normalized": "[Int]-\u003eVect Q NSym",
          "package": "HaskellForMaths",
          "signature": "[Int]-\u003eVect Q NSym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:nsym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "nsymToSSym",
          "package": "HaskellForMaths",
          "signature": "Vect k NSym -\u003e Vect k SSymF",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#nsymToSSym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "nsymToSSym",
          "normalized": "Vect a NSym-\u003eVect a SSymF",
          "package": "HaskellForMaths",
          "partial": "To SSym",
          "signature": "Vect k NSym-\u003eVect k SSymF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:nsymToSSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA surjection of NSym onto Sym (defined over the complete basis)\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "nsymToSymH",
          "package": "HaskellForMaths",
          "signature": "Vect k NSym -\u003e Vect k SymH",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#nsymToSymH",
          "type": "function"
        },
        "index": {
          "description": "surjection of NSym onto Sym defined over the complete basis",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "nsymToSymH",
          "normalized": "Vect a NSym-\u003eVect a SymH",
          "package": "HaskellForMaths",
          "partial": "To Sym",
          "signature": "Vect k NSym-\u003eVect k SymH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:nsymToSymH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "numbered",
          "package": "HaskellForMaths",
          "signature": "PBT t -\u003e PBT a",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#numbered",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "numbered",
          "normalized": "PBT a-\u003ePBT b",
          "package": "HaskellForMaths",
          "signature": "PBT t-\u003ePBT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:numbered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "prefix",
          "package": "HaskellForMaths",
          "signature": "PBT a -\u003e [a]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#prefix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "prefix",
          "normalized": "PBT a-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "PBT a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:prefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "prop_Associative",
          "package": "HaskellForMaths",
          "signature": "(t -\u003e t -\u003e t) -\u003e (t, t, t) -\u003e Bool",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#prop_Associative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "prop_Associative",
          "normalized": "(a-\u003ea-\u003ea)-\u003e(a,a,a)-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Associative",
          "signature": "(t-\u003et-\u003et)-\u003e(t,t,t)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:prop_Associative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct the element of QSym in the fundamental basis indexed by the given composition\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "qsymF",
          "package": "HaskellForMaths",
          "signature": "[Int] -\u003e Vect Q QSymF",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#qsymF",
          "type": "function"
        },
        "index": {
          "description": "Construct the element of QSym in the fundamental basis indexed by the given composition",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "qsymF",
          "normalized": "[Int]-\u003eVect Q QSymF",
          "package": "HaskellForMaths",
          "signature": "[Int]-\u003eVect Q QSymF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:qsymF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an element of QSym represented in the fundamental basis to the monomial basis\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "qsymFtoM",
          "package": "HaskellForMaths",
          "signature": "Vect k QSymF -\u003e Vect k QSymM",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#qsymFtoM",
          "type": "function"
        },
        "index": {
          "description": "Convert an element of QSym represented in the fundamental basis to the monomial basis",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "qsymFtoM",
          "normalized": "Vect a QSymF-\u003eVect a QSymM",
          "package": "HaskellForMaths",
          "partial": "Fto",
          "signature": "Vect k QSymF-\u003eVect k QSymM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:qsymFtoM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct the element of QSym in the monomial basis indexed by the given composition\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "qsymM",
          "package": "HaskellForMaths",
          "signature": "[Int] -\u003e Vect Q QSymM",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#qsymM",
          "type": "function"
        },
        "index": {
          "description": "Construct the element of QSym in the monomial basis indexed by the given composition",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "qsymM",
          "normalized": "[Int]-\u003eVect Q QSymM",
          "package": "HaskellForMaths",
          "signature": "[Int]-\u003eVect Q QSymM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:qsymM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an element of QSym represented in the monomial basis to the fundamental basis\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "qsymMtoF",
          "package": "HaskellForMaths",
          "signature": "Vect k QSymM -\u003e Vect k QSymF",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#qsymMtoF",
          "type": "function"
        },
        "index": {
          "description": "Convert an element of QSym represented in the monomial basis to the fundamental basis",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "qsymMtoF",
          "normalized": "Vect a QSymM-\u003eVect a QSymF",
          "package": "HaskellForMaths",
          "partial": "Mto",
          "signature": "Vect k QSymM-\u003eVect k QSymF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:qsymMtoF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eqsymPoly n is\u003c/code\u003e is the quasi-symmetric polynomial in n variables for the indices is. (This corresponds to the\n monomial basis for QSym.) For example, qsymPoly 3 [2,1] == x1^2*x2+x1^2*x3+x2^2*x3.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "qsymPoly",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [Int] -\u003e GlexPoly Q String",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#qsymPoly",
          "type": "function"
        },
        "index": {
          "description": "qsymPoly is is the quasi-symmetric polynomial in variables for the indices is This corresponds to the monomial basis for QSym For example qsymPoly x1 x2 x1 x3 x2 x3",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "qsymPoly",
          "normalized": "Int-\u003e[Int]-\u003eGlexPoly Q String",
          "package": "HaskellForMaths",
          "partial": "Poly",
          "signature": "Int-\u003e[Int]-\u003eGlexPoly Q String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:qsymPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "quasiShuffles",
          "package": "HaskellForMaths",
          "signature": "[Int] -\u003e [Int] -\u003e [[Int]]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#quasiShuffles",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "quasiShuffles",
          "normalized": "[Int]-\u003e[Int]-\u003e[[Int]]",
          "package": "HaskellForMaths",
          "partial": "Shuffles",
          "signature": "[Int]-\u003e[Int]-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:quasiShuffles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "refinements",
          "package": "HaskellForMaths",
          "signature": "[Int] -\u003e [[Int]]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#refinements",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "refinements",
          "normalized": "[Int]-\u003e[[Int]]",
          "package": "HaskellForMaths",
          "signature": "[Int]-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:refinements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a basis element of the shuffle algebra\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "sh",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Vect Q (Shuffle a)",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#sh",
          "type": "function"
        },
        "index": {
          "description": "Construct basis element of the shuffle algebra",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "sh",
          "normalized": "[a]-\u003eVect Q(Shuffle a)",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eVect Q(Shuffle a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:sh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "shape",
          "package": "HaskellForMaths",
          "signature": "PBT a -\u003e PBT ()",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#shape",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "shape",
          "normalized": "PBT a-\u003ePBT()",
          "package": "HaskellForMaths",
          "signature": "PBT a-\u003ePBT()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:shape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "shapeSignature",
          "package": "HaskellForMaths",
          "signature": "PBT t1 -\u003e [t]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#shapeSignature",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "shapeSignature",
          "normalized": "PBT a-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Signature",
          "signature": "PBT t-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:shapeSignature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "shiftedConcat",
          "package": "HaskellForMaths",
          "signature": "SSymF -\u003e SSymF -\u003e SSymF",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#shiftedConcat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "shiftedConcat",
          "normalized": "SSymF-\u003eSSymF-\u003eSSymF",
          "package": "HaskellForMaths",
          "partial": "Concat",
          "signature": "SSymF-\u003eSSymF-\u003eSSymF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:shiftedConcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "shuffles",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#shuffles",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "shuffles",
          "normalized": "[a]-\u003e[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:shuffles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "splits",
          "package": "HaskellForMaths",
          "signature": "PBT a -\u003e [(PBT a, PBT a)]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#splits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "splits",
          "normalized": "PBT a-\u003e[(PBT a,PBT a)]",
          "package": "HaskellForMaths",
          "signature": "PBT a-\u003e[(PBT a,PBT a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:splits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a fundamental basis element in SSym.\n The list of ints must be a permutation of [1..n], eg [1,2], [3,4,2,1].\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ssymF",
          "package": "HaskellForMaths",
          "signature": "[Int] -\u003e Vect Q SSymF",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#ssymF",
          "type": "function"
        },
        "index": {
          "description": "Construct fundamental basis element in SSym The list of ints must be permutation of eg",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ssymF",
          "normalized": "[Int]-\u003eVect Q SSymF",
          "package": "HaskellForMaths",
          "signature": "[Int]-\u003eVect Q SSymF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:ssymF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe isomorphism from SSym to its dual that takes a permutation in the fundamental basis to its inverse in the dual basis\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ssymFtoDual",
          "package": "HaskellForMaths",
          "signature": "Vect k SSymF -\u003e Vect k (Dual SSymF)",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#ssymFtoDual",
          "type": "function"
        },
        "index": {
          "description": "The isomorphism from SSym to its dual that takes permutation in the fundamental basis to its inverse in the dual basis",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ssymFtoDual",
          "normalized": "Vect a SSymF-\u003eVect a(Dual SSymF)",
          "package": "HaskellForMaths",
          "partial": "Fto Dual",
          "signature": "Vect k SSymF-\u003eVect k(Dual SSymF)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:ssymFtoDual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an element of SSym represented in the fundamental basis to the monomial basis\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ssymFtoM",
          "package": "HaskellForMaths",
          "signature": "Vect k SSymF -\u003e Vect k SSymM",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#ssymFtoM",
          "type": "function"
        },
        "index": {
          "description": "Convert an element of SSym represented in the fundamental basis to the monomial basis",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ssymFtoM",
          "normalized": "Vect a SSymF-\u003eVect a SSymM",
          "package": "HaskellForMaths",
          "partial": "Fto",
          "signature": "Vect k SSymF-\u003eVect k SSymM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:ssymFtoM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monomial basis element in SSym.\n The list of ints must be a permutation of [1..n], eg [1,2], [3,4,2,1].\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ssymM",
          "package": "HaskellForMaths",
          "signature": "[Int] -\u003e Vect Q SSymM",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#ssymM",
          "type": "function"
        },
        "index": {
          "description": "Construct monomial basis element in SSym The list of ints must be permutation of eg",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ssymM",
          "normalized": "[Int]-\u003eVect Q SSymM",
          "package": "HaskellForMaths",
          "signature": "[Int]-\u003eVect Q SSymM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:ssymM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an element of SSym represented in the monomial basis to the fundamental basis\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ssymMtoF",
          "package": "HaskellForMaths",
          "signature": "Vect k SSymM -\u003e Vect k SSymF",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#ssymMtoF",
          "type": "function"
        },
        "index": {
          "description": "Convert an element of SSym represented in the monomial basis to the fundamental basis",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ssymMtoF",
          "normalized": "Vect a SSymM-\u003eVect a SSymF",
          "package": "HaskellForMaths",
          "partial": "Mto",
          "signature": "Vect k SSymM-\u003eVect k SSymF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:ssymMtoF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "symE",
          "package": "HaskellForMaths",
          "signature": "[Int] -\u003e Vect Q SymE",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#symE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "symE",
          "normalized": "[Int]-\u003eVect Q SymE",
          "package": "HaskellForMaths",
          "signature": "[Int]-\u003eVect Q SymE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:symE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from the elementary to the monomial basis of Sym\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "symEtoM",
          "package": "HaskellForMaths",
          "signature": "Vect k SymE -\u003e Vect k SymM",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#symEtoM",
          "type": "function"
        },
        "index": {
          "description": "Convert from the elementary to the monomial basis of Sym",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "symEtoM",
          "normalized": "Vect a SymE-\u003eVect a SymM",
          "package": "HaskellForMaths",
          "partial": "Eto",
          "signature": "Vect k SymE-\u003eVect k SymM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:symEtoM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "symH",
          "package": "HaskellForMaths",
          "signature": "[Int] -\u003e Vect Q SymH",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#symH",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "symH",
          "normalized": "[Int]-\u003eVect Q SymH",
          "package": "HaskellForMaths",
          "signature": "[Int]-\u003eVect Q SymH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:symH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from the complete to the monomial basis of Sym\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "symHtoM",
          "package": "HaskellForMaths",
          "signature": "Vect k SymH -\u003e Vect k SymM",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#symHtoM",
          "type": "function"
        },
        "index": {
          "description": "Convert from the complete to the monomial basis of Sym",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "symHtoM",
          "normalized": "Vect a SymH-\u003eVect a SymM",
          "package": "HaskellForMaths",
          "partial": "Hto",
          "signature": "Vect k SymH-\u003eVect k SymM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:symHtoM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct the element of Sym in the monomial basis indexed by the given integer partition\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "symM",
          "package": "HaskellForMaths",
          "signature": "[Int] -\u003e Vect Q SymM",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#symM",
          "type": "function"
        },
        "index": {
          "description": "Construct the element of Sym in the monomial basis indexed by the given integer partition",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "symM",
          "normalized": "[Int]-\u003eVect Q SymM",
          "package": "HaskellForMaths",
          "signature": "[Int]-\u003eVect Q SymM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:symM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "symMult",
          "package": "HaskellForMaths",
          "signature": "[Int] -\u003e [Int] -\u003e [[Int]]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#symMult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "symMult",
          "normalized": "[Int]-\u003e[Int]-\u003e[[Int]]",
          "package": "HaskellForMaths",
          "partial": "Mult",
          "signature": "[Int]-\u003e[Int]-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:symMult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe injection of Sym into QSym (defined over the monomial basis)\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "symToQSymM",
          "package": "HaskellForMaths",
          "signature": "Vect k SymM -\u003e Vect k QSymM",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#symToQSymM",
          "type": "function"
        },
        "index": {
          "description": "The injection of Sym into QSym defined over the monomial basis",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "symToQSymM",
          "normalized": "Vect a SymM-\u003eVect a QSymM",
          "package": "HaskellForMaths",
          "partial": "To QSym",
          "signature": "Vect k SymM-\u003eVect k QSymM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:symToQSymM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe covering relation for the Tamari partial order on binary trees\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "tamariCovers",
          "package": "HaskellForMaths",
          "signature": "PBT a -\u003e [PBT a]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#tamariCovers",
          "type": "function"
        },
        "index": {
          "description": "The covering relation for the Tamari partial order on binary trees",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "tamariCovers",
          "normalized": "PBT a-\u003e[PBT a]",
          "package": "HaskellForMaths",
          "partial": "Covers",
          "signature": "PBT a-\u003e[PBT a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:tamariCovers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Tamari partial order on binary trees.\n This is only defined between trees of the same size (number of nodes).\n The result between trees of different sizes is undefined (we don't check).\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "tamariOrder",
          "package": "HaskellForMaths",
          "signature": "PBT a -\u003e PBT a -\u003e Bool",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#tamariOrder",
          "type": "function"
        },
        "index": {
          "description": "The Tamari partial order on binary trees This is only defined between trees of the same size number of nodes The result between trees of different sizes is undefined we don check",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "tamariOrder",
          "normalized": "PBT a-\u003ePBT a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Order",
          "signature": "PBT a-\u003ePBT a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:tamariOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe up-set of a binary tree in the Tamari partial order\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "tamariUpSet",
          "package": "HaskellForMaths",
          "signature": "PBT a -\u003e [PBT a]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#tamariUpSet",
          "type": "function"
        },
        "index": {
          "description": "The up-set of binary tree in the Tamari partial order",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "tamariUpSet",
          "normalized": "PBT a-\u003e[PBT a]",
          "package": "HaskellForMaths",
          "partial": "Up Set",
          "signature": "PBT a-\u003e[PBT a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:tamariUpSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList all trees with the given number of nodes\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "trees",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [PBT ()]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#trees",
          "type": "function"
        },
        "index": {
          "description": "List all trees with the given number of nodes",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "trees",
          "normalized": "Int-\u003e[PBT()]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[PBT()]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:trees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "under",
          "package": "HaskellForMaths",
          "signature": "PBT a -\u003e PBT a -\u003e PBT a",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#under",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "under",
          "normalized": "PBT a-\u003ePBT a-\u003ePBT a",
          "package": "HaskellForMaths",
          "signature": "PBT a-\u003ePBT a-\u003ePBT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:under"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "underComposition",
          "package": "HaskellForMaths",
          "signature": "QSymF -\u003e SSymF",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#underComposition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "underComposition",
          "normalized": "QSymF-\u003eSSymF",
          "package": "HaskellForMaths",
          "partial": "Composition",
          "signature": "QSymF-\u003eSSymF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:underComposition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "underDecomposition",
          "package": "HaskellForMaths",
          "signature": "PBT a -\u003e [PBT a]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#underDecomposition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "underDecomposition",
          "normalized": "PBT a-\u003e[PBT a]",
          "package": "HaskellForMaths",
          "partial": "Decomposition",
          "signature": "PBT a-\u003e[PBT a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:underDecomposition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "weakOrder",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a1] -\u003e Bool",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#weakOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "weakOrder",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Order",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:weakOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "xvars",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [GlexPoly Q [Char]]",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#xvars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "xvars",
          "normalized": "a-\u003e[GlexPoly Q[Char]]",
          "package": "HaskellForMaths",
          "signature": "a-\u003e[GlexPoly Q[Char]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:xvars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct the element of YSym in the fundamental basis indexed by the given tree\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ysymF",
          "package": "HaskellForMaths",
          "signature": "PBT a -\u003e Vect Q (YSymF a)",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#ysymF",
          "type": "function"
        },
        "index": {
          "description": "Construct the element of YSym in the fundamental basis indexed by the given tree",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ysymF",
          "normalized": "PBT a-\u003eVect Q(YSymF a)",
          "package": "HaskellForMaths",
          "signature": "PBT a-\u003eVect Q(YSymF a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:ysymF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an element of YSym represented in the fundamental basis to the monomial basis\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ysymFtoM",
          "package": "HaskellForMaths",
          "signature": "Vect k (YSymF ()) -\u003e Vect k YSymM",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#ysymFtoM",
          "type": "function"
        },
        "index": {
          "description": "Convert an element of YSym represented in the fundamental basis to the monomial basis",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ysymFtoM",
          "normalized": "Vect a(YSymF())-\u003eVect a YSymM",
          "package": "HaskellForMaths",
          "partial": "Fto",
          "signature": "Vect k(YSymF())-\u003eVect k YSymM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:ysymFtoM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct the element of YSym in the monomial basis indexed by the given tree\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ysymM",
          "package": "HaskellForMaths",
          "signature": "PBT () -\u003e Vect Q YSymM",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#ysymM",
          "type": "function"
        },
        "index": {
          "description": "Construct the element of YSym in the monomial basis indexed by the given tree",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ysymM",
          "normalized": "PBT()-\u003eVect Q YSymM",
          "package": "HaskellForMaths",
          "signature": "PBT()-\u003eVect Q YSymM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:ysymM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an element of YSym represented in the monomial basis to the fundamental basis\n\u003c/p\u003e",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ysymMtoF",
          "package": "HaskellForMaths",
          "signature": "Vect k YSymM -\u003e Vect k (YSymF ())",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#ysymMtoF",
          "type": "function"
        },
        "index": {
          "description": "Convert an element of YSym represented in the monomial basis to the fundamental basis",
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ysymMtoF",
          "normalized": "Vect a YSymM-\u003eVect a(YSymF())",
          "package": "HaskellForMaths",
          "partial": "Mto",
          "signature": "Vect k YSymM-\u003eVect k(YSymF())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:ysymMtoF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ysymmToSh",
          "package": "HaskellForMaths",
          "signature": "f YSymM -\u003e f (Shuffle (PBT ()))",
          "source": "src/Math-Combinatorics-CombinatorialHopfAlgebra.html#ysymmToSh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics CombinatorialHopfAlgebra",
          "module": "Math.Combinatorics.CombinatorialHopfAlgebra",
          "name": "ysymmToSh",
          "normalized": "a YSymM-\u003ea(Shuffle(PBT()))",
          "package": "HaskellForMaths",
          "partial": "To Sh",
          "signature": "f YSymM-\u003ef(Shuffle(PBT()))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-CombinatorialHopfAlgebra.html#v:ysymmToSh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module for constructing and working with combinatorial designs.\n\u003c/p\u003e\u003cp\u003eGiven integers t \u003c k \u003c v and lambda \u003e 0, a t-design or t-(v,k,lambda) design is an incidence structure of points X and blocks B,\n where X is a set of v points, B is a collection of k-subsets of X, with the property that any t points are contained\n in exactly lambda blocks. If lambda = 1 and t \u003e= 2, then a t-design is also called a Steiner system S(t,k,v).\n\u003c/p\u003e\u003cp\u003eMany designs are highly symmetric structures, having large automorphism groups. In particular, the Mathieu groups,\n which were the first discovered sporadic finite simple groups, turn up as the automorphism groups of the Witt designs.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "Design",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-Design.html",
          "type": "module"
        },
        "index": {
          "description": "module for constructing and working with combinatorial designs Given integers and lambda t-design or lambda design is an incidence structure of points and blocks where is set of points is collection of k-subsets of with the property that any points are contained in exactly lambda blocks If lambda and then t-design is also called Steiner system Many designs are highly symmetric structures having large automorphism groups In particular the Mathieu groups which were the first discovered sporadic finite simple groups turn up as the automorphism groups of the Witt designs",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "Design",
          "package": "HaskellForMaths",
          "partial": "Design",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "Design",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-Design.html#Design",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "Design",
          "package": "HaskellForMaths",
          "partial": "Design",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#t:Design"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "D",
          "package": "HaskellForMaths",
          "signature": "D [a] [[a]]",
          "source": "src/Math-Combinatorics-Design.html#Design",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "D",
          "normalized": "D[a][[a]]",
          "package": "HaskellForMaths",
          "signature": "D[a][[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "ag",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e Design [a]",
          "source": "src/Math-Combinatorics-Design.html#ag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "ag",
          "normalized": "Int-\u003e[a]-\u003eDesign[a]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[a]-\u003eDesign[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:ag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe affine plane AG(2,Fq), a 2-(q^2,q,1) design or Steiner system S(2,q,q^2).\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "ag2",
          "package": "HaskellForMaths",
          "signature": "[k] -\u003e Design [k]",
          "source": "src/Math-Combinatorics-Design.html#ag2",
          "type": "function"
        },
        "index": {
          "description": "The affine plane AG Fq design or Steiner system",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "ag2",
          "normalized": "[a]-\u003eDesign[a]",
          "package": "HaskellForMaths",
          "signature": "[k]-\u003eDesign[k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:ag2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "alphaL2_11",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Combinatorics-Design.html#alphaL2_11",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "alphaL2_11",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:alphaL2_11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "alphaL2_23",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Combinatorics-Design.html#alphaL2_23",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "alphaL2_23",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:alphaL2_23"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "betaL2_11",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Combinatorics-Design.html#betaL2_11",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "betaL2_11",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:betaL2_11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "betaL2_23",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Combinatorics-Design.html#betaL2_23",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "betaL2_23",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:betaL2_23"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "blockResidual",
          "package": "HaskellForMaths",
          "signature": "Design t -\u003e [t] -\u003e Design t",
          "source": "src/Math-Combinatorics-Design.html#blockResidual",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "blockResidual",
          "normalized": "Design a-\u003e[a]-\u003eDesign a",
          "package": "HaskellForMaths",
          "partial": "Residual",
          "signature": "Design t-\u003e[t]-\u003eDesign t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:blockResidual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "blocks",
          "package": "HaskellForMaths",
          "signature": "Design t -\u003e [[t]]",
          "source": "src/Math-Combinatorics-Design.html#blocks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "blocks",
          "normalized": "Design a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "Design t-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:blocks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "complementaryDesign",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e Design a",
          "source": "src/Math-Combinatorics-Design.html#complementaryDesign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "complementaryDesign",
          "normalized": "Design a-\u003eDesign a",
          "package": "HaskellForMaths",
          "partial": "Design",
          "signature": "Design a-\u003eDesign a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:complementaryDesign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "deltaM12",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Combinatorics-Design.html#deltaM12",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "deltaM12",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:deltaM12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "deltaM24",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Combinatorics-Design.html#deltaM24",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "deltaM24",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:deltaM24"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "derivedDesign",
          "package": "HaskellForMaths",
          "signature": "Design t -\u003e t -\u003e Design t",
          "source": "src/Math-Combinatorics-Design.html#derivedDesign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "derivedDesign",
          "normalized": "Design a-\u003ea-\u003eDesign a",
          "package": "HaskellForMaths",
          "partial": "Design",
          "signature": "Design t-\u003et-\u003eDesign t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:derivedDesign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "design",
          "package": "HaskellForMaths",
          "signature": "([a], [[a]]) -\u003e Design a",
          "source": "src/Math-Combinatorics-Design.html#design",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "design",
          "normalized": "([a],[[a]])-\u003eDesign a",
          "package": "HaskellForMaths",
          "signature": "([a],[[a]])-\u003eDesign a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:design"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a strong generating set for the automorphism group of a design\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "designAuts",
          "package": "HaskellForMaths",
          "signature": "Design t -\u003e [Permutation t]",
          "source": "src/Math-Combinatorics-Design.html#designAuts",
          "type": "function"
        },
        "index": {
          "description": "Find strong generating set for the automorphism group of design",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "designAuts",
          "normalized": "Design a-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Auts",
          "signature": "Design t-\u003e[Permutation t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:designAuts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "designAuts1",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e [Permutation a]",
          "source": "src/Math-Combinatorics-Design.html#designAuts1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "designAuts1",
          "normalized": "Design a-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Auts",
          "signature": "Design a-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:designAuts1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "designParams",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e Maybe (Int, (Int, Int, Int))",
          "source": "src/Math-Combinatorics-Design.html#designParams",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "designParams",
          "normalized": "Design a-\u003eMaybe(Int,(Int,Int,Int))",
          "package": "HaskellForMaths",
          "partial": "Params",
          "signature": "Design a-\u003eMaybe(Int,(Int,Int,Int))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:designParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe dual of a design\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "dual",
          "package": "HaskellForMaths",
          "signature": "Design t -\u003e Design [t]",
          "source": "src/Math-Combinatorics-Design.html#dual",
          "type": "function"
        },
        "index": {
          "description": "The dual of design",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "dual",
          "normalized": "Design a-\u003eDesign[a]",
          "package": "HaskellForMaths",
          "signature": "Design t-\u003eDesign[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:dual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "fanoPlane",
          "package": "HaskellForMaths",
          "signature": "Design F7",
          "source": "src/Math-Combinatorics-Design.html#fanoPlane",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "fanoPlane",
          "package": "HaskellForMaths",
          "partial": "Plane",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:fanoPlane"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "findlambda",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Design a -\u003e Maybe Int",
          "source": "src/Math-Combinatorics-Design.html#findlambda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "findlambda",
          "normalized": "Int-\u003eDesign a-\u003eMaybe Int",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eDesign a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:findlambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "findvk",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e Maybe (Int, Int)",
          "source": "src/Math-Combinatorics-Design.html#findvk",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "findvk",
          "normalized": "Design a-\u003eMaybe(Int,Int)",
          "package": "HaskellForMaths",
          "signature": "Design a-\u003eMaybe(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:findvk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "flatsDesignAG",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e Int -\u003e Design [a]",
          "source": "src/Math-Combinatorics-Design.html#flatsDesignAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "flatsDesignAG",
          "normalized": "Int-\u003e[a]-\u003eInt-\u003eDesign[a]",
          "package": "HaskellForMaths",
          "partial": "Design AG",
          "signature": "Int-\u003e[a]-\u003eInt-\u003eDesign[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:flatsDesignAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "flatsDesignPG",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e Int -\u003e Design [a]",
          "source": "src/Math-Combinatorics-Design.html#flatsDesignPG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "flatsDesignPG",
          "normalized": "Int-\u003e[a]-\u003eInt-\u003eDesign[a]",
          "package": "HaskellForMaths",
          "partial": "Design PG",
          "signature": "Int-\u003e[a]-\u003eInt-\u003eDesign[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:flatsDesignPG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "gammaL2_11",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Combinatorics-Design.html#gammaL2_11",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "gammaL2_11",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:gammaL2_11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "gammaL2_23",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Combinatorics-Design.html#gammaL2_23",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "gammaL2_23",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:gammaL2_23"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "hexad",
          "package": "HaskellForMaths",
          "signature": "[Integer]",
          "source": "src/Math-Combinatorics-Design.html#hexad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "hexad",
          "normalized": "[Integer]",
          "package": "HaskellForMaths",
          "signature": "[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:hexad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe incidence graph of a design\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "incidenceGraph",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e Graph (Either a [a])",
          "source": "src/Math-Combinatorics-Design.html#incidenceGraph",
          "type": "function"
        },
        "index": {
          "description": "The incidence graph of design",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "incidenceGraph",
          "normalized": "Design a-\u003eGraph(Either a[a])",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "Design a-\u003eGraph(Either a[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:incidenceGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe incidence matrix of a design, with rows indexed by blocks and columns by points.\n (Note that in the literature, the opposite convention is sometimes used instead.)\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "incidenceMatrix",
          "package": "HaskellForMaths",
          "signature": "Design t -\u003e [[Int]]",
          "source": "src/Math-Combinatorics-Design.html#incidenceMatrix",
          "type": "function"
        },
        "index": {
          "description": "The incidence matrix of design with rows indexed by blocks and columns by points Note that in the literature the opposite convention is sometimes used instead",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "incidenceMatrix",
          "normalized": "Design a-\u003e[[Int]]",
          "package": "HaskellForMaths",
          "partial": "Matrix",
          "signature": "Design t-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:incidenceMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "is2Design",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e Bool",
          "source": "src/Math-Combinatorics-Design.html#is2Design",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "is2Design",
          "normalized": "Design a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Design",
          "signature": "Design a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:is2Design"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "isDesign",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Design a -\u003e Bool",
          "source": "src/Math-Combinatorics-Design.html#isDesign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "isDesign",
          "normalized": "Int-\u003eDesign a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Design",
          "signature": "Int-\u003eDesign a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:isDesign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "isDesignAut",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e Permutation a -\u003e Bool",
          "source": "src/Math-Combinatorics-Design.html#isDesignAut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "isDesignAut",
          "normalized": "Design a-\u003ePermutation a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Design Aut",
          "signature": "Design a-\u003ePermutation a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:isDesignAut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "isSquare",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e Bool",
          "source": "src/Math-Combinatorics-Design.html#isSquare",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "isSquare",
          "normalized": "Design a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Square",
          "signature": "Design a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:isSquare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "isStructure",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Design a -\u003e Bool",
          "source": "src/Math-Combinatorics-Design.html#isStructure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "isStructure",
          "normalized": "Int-\u003eDesign a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Structure",
          "signature": "Int-\u003eDesign a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:isStructure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "isSubset",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Design.html#isSubset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "isSubset",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Subset",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:isSubset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "isValid",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e Bool",
          "source": "src/Math-Combinatorics-Design.html#isValid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "isValid",
          "normalized": "Design a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Valid",
          "signature": "Design a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:isValid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "l2_11",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Combinatorics-Design.html#l2_11",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "l2_11",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:l2_11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "l2_23",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Combinatorics-Design.html#l2_23",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "l2_23",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:l2_23"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA strong generating set for the Mathieu group M11, a finite simple group of order 7920\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "m11sgs",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Combinatorics-Design.html#m11sgs",
          "type": "function"
        },
        "index": {
          "description": "strong generating set for the Mathieu group M11 finite simple group of order",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "m11sgs",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:m11sgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerators for the Mathieu group M12, a finite simple group of order 95040\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "m12",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Combinatorics-Design.html#m12",
          "type": "function"
        },
        "index": {
          "description": "Generators for the Mathieu group M12 finite simple group of order",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "m12",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:m12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA strong generating set for the Mathieu group M12, a finite simple group of order 95040\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "m12sgs",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Combinatorics-Design.html#m12sgs",
          "type": "function"
        },
        "index": {
          "description": "strong generating set for the Mathieu group M12 finite simple group of order",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "m12sgs",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:m12sgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA strong generating set for the Mathieu group M22, a finite simple group of order 443520\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "m22sgs",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Combinatorics-Design.html#m22sgs",
          "type": "function"
        },
        "index": {
          "description": "strong generating set for the Mathieu group M22 finite simple group of order",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "m22sgs",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:m22sgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA strong generating set for the Mathieu group M23, a finite simple group of order 10200960\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "m23sgs",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Combinatorics-Design.html#m23sgs",
          "type": "function"
        },
        "index": {
          "description": "strong generating set for the Mathieu group M23 finite simple group of order",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "m23sgs",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:m23sgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerators for the Mathieu group M24, a finite simple group of order 244823040\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "m24",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Combinatorics-Design.html#m24",
          "type": "function"
        },
        "index": {
          "description": "Generators for the Mathieu group M24 finite simple group of order",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "m24",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:m24"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA strong generating set for the Mathieu group M24, a finite simple group of order 244823040\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "m24sgs",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Combinatorics-Design.html#m24sgs",
          "type": "function"
        },
        "index": {
          "description": "strong generating set for the Mathieu group M24 finite simple group of order",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "m24sgs",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:m24sgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "noRepeatedBlocks",
          "package": "HaskellForMaths",
          "signature": "Design t -\u003e Bool",
          "source": "src/Math-Combinatorics-Design.html#noRepeatedBlocks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "noRepeatedBlocks",
          "normalized": "Design a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Repeated Blocks",
          "signature": "Design t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:noRepeatedBlocks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "octad",
          "package": "HaskellForMaths",
          "signature": "[Integer]",
          "source": "src/Math-Combinatorics-Design.html#octad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "octad",
          "normalized": "[Integer]",
          "package": "HaskellForMaths",
          "signature": "[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:octad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "pairDesign",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Design a",
          "source": "src/Math-Combinatorics-Design.html#pairDesign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "pairDesign",
          "normalized": "a-\u003eDesign a",
          "package": "HaskellForMaths",
          "partial": "Design",
          "signature": "a-\u003eDesign a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:pairDesign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "paleyDesign",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Design a",
          "source": "src/Math-Combinatorics-Design.html#paleyDesign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "paleyDesign",
          "normalized": "[a]-\u003eDesign a",
          "package": "HaskellForMaths",
          "partial": "Design",
          "signature": "[a]-\u003eDesign a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:paleyDesign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "pg",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e Design [a]",
          "source": "src/Math-Combinatorics-Design.html#pg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "pg",
          "normalized": "Int-\u003e[a]-\u003eDesign[a]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[a]-\u003eDesign[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:pg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe projective plane PG(2,Fq), a square 2-(q^2+q+1,q+1,1) design or Steiner system S(2,q+1,q^2+q+1).\n For example, \u003ccode\u003epg2 f2\u003c/code\u003e is the Fano plane, a Steiner triple system S(2,3,7).\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "pg2",
          "package": "HaskellForMaths",
          "signature": "[k] -\u003e Design [k]",
          "source": "src/Math-Combinatorics-Design.html#pg2",
          "type": "function"
        },
        "index": {
          "description": "The projective plane PG Fq square design or Steiner system For example pg2 f2 is the Fano plane Steiner triple system",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "pg2",
          "normalized": "[a]-\u003eDesign[a]",
          "package": "HaskellForMaths",
          "signature": "[k]-\u003eDesign[k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:pg2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "pointResidual",
          "package": "HaskellForMaths",
          "signature": "Design t -\u003e t -\u003e Design t",
          "source": "src/Math-Combinatorics-Design.html#pointResidual",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "pointResidual",
          "normalized": "Design a-\u003ea-\u003eDesign a",
          "package": "HaskellForMaths",
          "partial": "Residual",
          "signature": "Design t-\u003et-\u003eDesign t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:pointResidual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "points",
          "package": "HaskellForMaths",
          "signature": "Design t -\u003e [t]",
          "source": "src/Math-Combinatorics-Design.html#points",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "points",
          "normalized": "Design a-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "Design t-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:points"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Steiner system S(3,6,22), with 77 blocks, whose automorphism group is M22\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "s_3_6_22",
          "package": "HaskellForMaths",
          "signature": "Design Integer",
          "source": "src/Math-Combinatorics-Design.html#s_3_6_22",
          "type": "function"
        },
        "index": {
          "description": "The Steiner system with blocks whose automorphism group is M22",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "s_3_6_22",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:s_3_6_22"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Steiner system S(4,5,11), with 66 blocks, whose automorphism group is M11\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "s_4_5_11",
          "package": "HaskellForMaths",
          "signature": "Design Integer",
          "source": "src/Math-Combinatorics-Design.html#s_4_5_11",
          "type": "function"
        },
        "index": {
          "description": "The Steiner system with blocks whose automorphism group is M11",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "s_4_5_11",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:s_4_5_11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Steiner system S(4,7,23), with 253 blocks, whose automorphism group is M23\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "s_4_7_23",
          "package": "HaskellForMaths",
          "signature": "Design Integer",
          "source": "src/Math-Combinatorics-Design.html#s_4_7_23",
          "type": "function"
        },
        "index": {
          "description": "The Steiner system with blocks whose automorphism group is M23",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "s_4_7_23",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:s_4_7_23"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Steiner system S(5,6,12), with 132 blocks, whose automorphism group is M12\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "s_5_6_12",
          "package": "HaskellForMaths",
          "signature": "Design Integer",
          "source": "src/Math-Combinatorics-Design.html#s_5_6_12",
          "type": "function"
        },
        "index": {
          "description": "The Steiner system with blocks whose automorphism group is M12",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "s_5_6_12",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:s_5_6_12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Steiner system S(5,8,24), with 759 blocks, whose automorphism group is M24\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Design",
          "name": "s_5_8_24",
          "package": "HaskellForMaths",
          "signature": "Design Integer",
          "source": "src/Math-Combinatorics-Design.html#s_5_8_24",
          "type": "function"
        },
        "index": {
          "description": "The Steiner system with blocks whose automorphism group is M24",
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "s_5_8_24",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:s_5_8_24"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "s_5_8_24'",
          "package": "HaskellForMaths",
          "signature": "Design Integer",
          "source": "src/Math-Combinatorics-Design.html#s_5_8_24%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "s_5_8_24'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:s_5_8_24-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "subsetDesign",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Int -\u003e Design a",
          "source": "src/Math-Combinatorics-Design.html#subsetDesign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "subsetDesign",
          "normalized": "a-\u003eInt-\u003eDesign a",
          "package": "HaskellForMaths",
          "partial": "Design",
          "signature": "a-\u003eInt-\u003eDesign a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:subsetDesign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "tDesignParams",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Design a -\u003e Maybe (Int, Int, Int)",
          "source": "src/Math-Combinatorics-Design.html#tDesignParams",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "tDesignParams",
          "normalized": "Int-\u003eDesign a-\u003eMaybe(Int,Int,Int)",
          "package": "HaskellForMaths",
          "partial": "Design Params",
          "signature": "Int-\u003eDesign a-\u003eMaybe(Int,Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:tDesignParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "to1n",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e Design a1",
          "source": "src/Math-Combinatorics-Design.html#to1n",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "to1n",
          "normalized": "Design a-\u003eDesign a",
          "package": "HaskellForMaths",
          "signature": "Design a-\u003eDesign a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:to1n"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Design",
          "name": "toDesign",
          "package": "HaskellForMaths",
          "signature": "([a], [[a]]) -\u003e Design a",
          "source": "src/Math-Combinatorics-Design.html#toDesign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Design",
          "module": "Math.Combinatorics.Design",
          "name": "toDesign",
          "normalized": "([a],[[a]])-\u003eDesign a",
          "package": "HaskellForMaths",
          "partial": "Design",
          "signature": "([a],[[a]])-\u003eDesign a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Design.html#v:toDesign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module for working with directed graphs (digraphs).\n Some of the functions are specifically for working with directed acyclic graphs (DAGs),\n that is, directed graphs containing no cycles.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinatorics.Digraph",
          "name": "Digraph",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-Digraph.html",
          "type": "module"
        },
        "index": {
          "description": "module for working with directed graphs digraphs Some of the functions are specifically for working with directed acyclic graphs DAGs that is directed graphs containing no cycles",
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "Digraph",
          "package": "HaskellForMaths",
          "partial": "Digraph",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA digraph is represented as DG vs es, where vs is the list of vertices, and es is the list of edges.\n Edges are directed: an edge (u,v) means an edge from u to v.\n A digraph is considered to be in normal form if both es and vs are in ascending order.\n This is the preferred form, and some functions will only work for digraphs in normal form.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Digraph",
          "name": "Digraph",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-Digraph.html#Digraph",
          "type": "data"
        },
        "index": {
          "description": "digraph is represented as DG vs es where vs is the list of vertices and es is the list of edges Edges are directed an edge means an edge from to digraph is considered to be in normal form if both es and vs are in ascending order This is the preferred form and some functions will only work for digraphs in normal form",
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "Digraph",
          "package": "HaskellForMaths",
          "partial": "Digraph",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#t:Digraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "DG",
          "package": "HaskellForMaths",
          "signature": "DG [v] [(v, v)]",
          "source": "src/Math-Combinatorics-Digraph.html#Digraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "DG",
          "normalized": "DG[a][(a,a)]",
          "package": "HaskellForMaths",
          "partial": "DG",
          "signature": "DG[v][(v,v)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:DG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "adjLists",
          "package": "HaskellForMaths",
          "signature": "Digraph a -\u003e (Map a [a], Map a [a])",
          "source": "src/Math-Combinatorics-Digraph.html#adjLists",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "adjLists",
          "normalized": "Digraph a-\u003e(Map a[a],Map a[a])",
          "package": "HaskellForMaths",
          "partial": "Lists",
          "signature": "Digraph a-\u003e(Map a[a],Map a[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:adjLists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "dagIsos",
          "package": "HaskellForMaths",
          "signature": "Digraph a -\u003e Digraph a1 -\u003e [[(a, a1)]]",
          "source": "src/Math-Combinatorics-Digraph.html#dagIsos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "dagIsos",
          "normalized": "Digraph a-\u003eDigraph a-\u003e[[(a,a)]]",
          "package": "HaskellForMaths",
          "partial": "Isos",
          "signature": "Digraph a-\u003eDigraph a-\u003e[[(a,a)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:dagIsos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "digraphIsos1",
          "package": "HaskellForMaths",
          "signature": "Digraph a -\u003e Digraph a1 -\u003e [[(a, a1)]]",
          "source": "src/Math-Combinatorics-Digraph.html#digraphIsos1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "digraphIsos1",
          "normalized": "Digraph a-\u003eDigraph a-\u003e[[(a,a)]]",
          "package": "HaskellForMaths",
          "partial": "Isos",
          "signature": "Digraph a-\u003eDigraph a-\u003e[[(a,a)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:digraphIsos1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "digraphIsos2",
          "package": "HaskellForMaths",
          "signature": "Digraph k -\u003e Digraph k1 -\u003e [[(k, k1)]]",
          "source": "src/Math-Combinatorics-Digraph.html#digraphIsos2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "digraphIsos2",
          "normalized": "Digraph a-\u003eDigraph a-\u003e[[(a,a)]]",
          "package": "HaskellForMaths",
          "partial": "Isos",
          "signature": "Digraph k-\u003eDigraph k-\u003e[[(k,k)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:digraphIsos2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "edges",
          "package": "HaskellForMaths",
          "signature": "Digraph t -\u003e [(t, t)]",
          "source": "src/Math-Combinatorics-Digraph.html#edges",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "edges",
          "normalized": "Digraph a-\u003e[(a,a)]",
          "package": "HaskellForMaths",
          "signature": "Digraph t-\u003e[(t,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:edges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "heightPartitionDAG",
          "package": "HaskellForMaths",
          "signature": "Digraph k -\u003e [[k]]",
          "source": "src/Math-Combinatorics-Digraph.html#heightPartitionDAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "heightPartitionDAG",
          "normalized": "Digraph a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Partition DAG",
          "signature": "Digraph k-\u003e[[k]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:heightPartitionDAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "isDAG",
          "package": "HaskellForMaths",
          "signature": "Digraph a -\u003e Bool",
          "source": "src/Math-Combinatorics-Digraph.html#isDAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "isDAG",
          "normalized": "Digraph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "DAG",
          "signature": "Digraph a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:isDAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre the two DAGs isomorphic?\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Digraph",
          "name": "isDagIso",
          "package": "HaskellForMaths",
          "signature": "Digraph a -\u003e Digraph b -\u003e Bool",
          "source": "src/Math-Combinatorics-Digraph.html#isDagIso",
          "type": "function"
        },
        "index": {
          "description": "Are the two DAGs isomorphic",
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "isDagIso",
          "normalized": "Digraph a-\u003eDigraph b-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Dag Iso",
          "signature": "Digraph a-\u003eDigraph b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:isDagIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a directed acyclic graph (DAG), return a canonical representative for its isomorphism class.\n \u003ccode\u003eisoRepDAG dag\u003c/code\u003e is isomorphic to \u003ccode\u003edag\u003c/code\u003e. It follows that if \u003ccode\u003eisoRepDAG dagA == isoRepDAG dagB\u003c/code\u003e then \u003ccode\u003edagA\u003c/code\u003e is isomorphic to \u003ccode\u003edagB\u003c/code\u003e.\n Conversely, \u003ccode\u003eisoRepDAG dag\u003c/code\u003e is the minimal element in the isomorphism class, subject to some constraints.\n It follows that if \u003ccode\u003edagA\u003c/code\u003e is isomorphic to \u003ccode\u003edagB\u003c/code\u003e, then \u003ccode\u003eisoRepDAG dagA == isoRepDAG dagB\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe algorithm of course is faster on some DAGs than others: roughly speaking,\n it prefers \"tall\" DAGs (long chains) to \"wide\" DAGs (long antichains),\n and it prefers asymmetric DAGs (ie those with smaller automorphism groups).\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Digraph",
          "name": "isoRepDAG",
          "package": "HaskellForMaths",
          "signature": "Digraph a -\u003e Digraph Int",
          "source": "src/Math-Combinatorics-Digraph.html#isoRepDAG",
          "type": "function"
        },
        "index": {
          "description": "Given directed acyclic graph DAG return canonical representative for its isomorphism class isoRepDAG dag is isomorphic to dag It follows that if isoRepDAG dagA isoRepDAG dagB then dagA is isomorphic to dagB Conversely isoRepDAG dag is the minimal element in the isomorphism class subject to some constraints It follows that if dagA is isomorphic to dagB then isoRepDAG dagA isoRepDAG dagB The algorithm of course is faster on some DAGs than others roughly speaking it prefers tall DAGs long chains to wide DAGs long antichains and it prefers asymmetric DAGs ie those with smaller automorphism groups",
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "isoRepDAG",
          "normalized": "Digraph a-\u003eDigraph Int",
          "package": "HaskellForMaths",
          "partial": "Rep DAG",
          "signature": "Digraph a-\u003eDigraph Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:isoRepDAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "isoRepDAG1",
          "package": "HaskellForMaths",
          "signature": "Digraph k -\u003e Digraph Int",
          "source": "src/Math-Combinatorics-Digraph.html#isoRepDAG1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "isoRepDAG1",
          "normalized": "Digraph a-\u003eDigraph Int",
          "package": "HaskellForMaths",
          "partial": "Rep DAG",
          "signature": "Digraph k-\u003eDigraph Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:isoRepDAG1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "isoRepDAG2",
          "package": "HaskellForMaths",
          "signature": "Digraph t -\u003e [(t, t1)]",
          "source": "src/Math-Combinatorics-Digraph.html#isoRepDAG2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "isoRepDAG2",
          "normalized": "Digraph a-\u003e[(a,a)]",
          "package": "HaskellForMaths",
          "partial": "Rep DAG",
          "signature": "Digraph t-\u003e[(t,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:isoRepDAG2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "isoRepDAG3",
          "package": "HaskellForMaths",
          "signature": "Digraph a -\u003e Digraph Int",
          "source": "src/Math-Combinatorics-Digraph.html#isoRepDAG3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "isoRepDAG3",
          "normalized": "Digraph a-\u003eDigraph Int",
          "package": "HaskellForMaths",
          "partial": "Rep DAG",
          "signature": "Digraph a-\u003eDigraph Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:isoRepDAG3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "nf",
          "package": "HaskellForMaths",
          "signature": "Digraph v -\u003e Digraph v",
          "source": "src/Math-Combinatorics-Digraph.html#nf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "nf",
          "normalized": "Digraph a-\u003eDigraph a",
          "package": "HaskellForMaths",
          "signature": "Digraph v-\u003eDigraph v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:nf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "perms",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Digraph.html#perms",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "perms",
          "normalized": "[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:perms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "predecessors",
          "package": "HaskellForMaths",
          "signature": "Digraph t -\u003e t -\u003e [t]",
          "source": "src/Math-Combinatorics-Digraph.html#predecessors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "predecessors",
          "normalized": "Digraph a-\u003ea-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "Digraph t-\u003et-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:predecessors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "successors",
          "package": "HaskellForMaths",
          "signature": "Digraph t -\u003e t -\u003e [t]",
          "source": "src/Math-Combinatorics-Digraph.html#successors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "successors",
          "normalized": "Digraph a-\u003ea-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "Digraph t-\u003et-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:successors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "toSet",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a]",
          "source": "src/Math-Combinatorics-Digraph.html#toSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "toSet",
          "normalized": "[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Set",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:toSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Digraph",
          "name": "vertices",
          "package": "HaskellForMaths",
          "signature": "Digraph t -\u003e [t]",
          "source": "src/Math-Combinatorics-Digraph.html#vertices",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Digraph",
          "module": "Math.Combinatorics.Digraph",
          "name": "vertices",
          "normalized": "Digraph a-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "Digraph t-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Digraph.html#v:vertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConstructions of the finite geometries AG(n,Fq) and PG(n,Fq), their points, lines and flats,\n together with the incidence graphs between points and lines.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "FiniteGeometry",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-FiniteGeometry.html",
          "type": "module"
        },
        "index": {
          "description": "Constructions of the finite geometries AG Fq and PG Fq their points lines and flats together with the incidence graphs between points and lines",
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "FiniteGeometry",
          "package": "HaskellForMaths",
          "partial": "Finite Geometry",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "ZeroOneStar",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#ZeroOneStar",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "ZeroOneStar",
          "package": "HaskellForMaths",
          "partial": "Zero One Star",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#t:ZeroOneStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "One",
          "package": "HaskellForMaths",
          "signature": "One",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#ZeroOneStar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "One",
          "package": "HaskellForMaths",
          "partial": "One",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:One"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "Star",
          "package": "HaskellForMaths",
          "signature": "Star",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#ZeroOneStar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "Star",
          "package": "HaskellForMaths",
          "partial": "Star",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:Star"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "Zero",
          "package": "HaskellForMaths",
          "signature": "Zero",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#ZeroOneStar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "Zero",
          "package": "HaskellForMaths",
          "partial": "Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:Zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list of points in AG(n,Fq), return their closure, the smallest flat containing them\n\u003c/p\u003e",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "closureAG",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#closureAG",
          "type": "function"
        },
        "index": {
          "description": "Given list of points in AG Fq return their closure the smallest flat containing them",
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "closureAG",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "AG",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:closureAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a set of points in PG(n,Fq), return their closure, the smallest flat containing them\n\u003c/p\u003e",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "closurePG",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#closurePG",
          "type": "function"
        },
        "index": {
          "description": "Given set of points in PG Fq return their closure the smallest flat containing them",
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "closurePG",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "PG",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:closurePG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eflatsAG n fq k returns the k-flats in AG(n,Fq), where fq are the elements of Fq.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "flatsAG",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e Int -\u003e [[[a]]]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#flatsAG",
          "type": "function"
        },
        "index": {
          "description": "flatsAG fq returns the k-flats in AG Fq where fq are the elements of Fq",
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "flatsAG",
          "normalized": "Int-\u003e[a]-\u003eInt-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "AG",
          "signature": "Int-\u003e[a]-\u003eInt-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:flatsAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eflatsPG n fq k\u003c/code\u003e returns the k-flats in PG(n,Fq), where fq are the elements of Fq.\n The returned flats are represented as matrices in reduced row echelon form,\n the rows of which are the points that generate the flat.\n The full set of points in the flat can be recovered by calling \u003ccode\u003e\u003ca\u003eclosurePG\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "flatsPG",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e Int -\u003e [[[a]]]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#flatsPG",
          "type": "function"
        },
        "index": {
          "description": "flatsPG fq returns the k-flats in PG Fq where fq are the elements of Fq The returned flats are represented as matrices in reduced row echelon form the rows of which are the points that generate the flat The full set of points in the flat can be recovered by calling closurePG",
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "flatsPG",
          "normalized": "Int-\u003e[a]-\u003eInt-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "PG",
          "signature": "Int-\u003e[a]-\u003eInt-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:flatsPG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "heawood",
          "package": "HaskellForMaths",
          "signature": "Graph Integer",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#heawood",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "heawood",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:heawood"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncidence graph of AG(n,fq), considered as an incidence structure between points and lines\n\u003c/p\u003e",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "incidenceGraphAG",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e Graph (Either [a] [[a]])",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#incidenceGraphAG",
          "type": "function"
        },
        "index": {
          "description": "Incidence graph of AG fq considered as an incidence structure between points and lines",
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "incidenceGraphAG",
          "normalized": "Int-\u003e[a]-\u003eGraph(Either[a][[a]])",
          "package": "HaskellForMaths",
          "partial": "Graph AG",
          "signature": "Int-\u003e[a]-\u003eGraph(Either[a][[a]])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:incidenceGraphAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncidence graph of PG(n,fq), considered as an incidence structure between points and lines\n\u003c/p\u003e",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "incidenceGraphPG",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e Graph (Either [a] [[a]])",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#incidenceGraphPG",
          "type": "function"
        },
        "index": {
          "description": "Incidence graph of PG fq considered as an incidence structure between points and lines",
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "incidenceGraphPG",
          "normalized": "Int-\u003e[a]-\u003eGraph(Either[a][[a]])",
          "package": "HaskellForMaths",
          "partial": "Graph PG",
          "signature": "Int-\u003e[a]-\u003eGraph(Either[a][[a]])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:incidenceGraphPG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "ispnf",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e Bool",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#ispnf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "ispnf",
          "normalized": "[a]-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "[t]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:ispnf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "lineAG",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#lineAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "lineAG",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "AG",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:lineAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "linePG",
          "package": "HaskellForMaths",
          "signature": "[[t]] -\u003e [[t]]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#linePG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "linePG",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "PG",
          "signature": "[[t]]-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:linePG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe lines (1-flats) in AG(n,fq)\n\u003c/p\u003e",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "linesAG",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e [[[a]]]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#linesAG",
          "type": "function"
        },
        "index": {
          "description": "The lines flats in AG fq",
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "linesAG",
          "normalized": "Int-\u003e[a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "AG",
          "signature": "Int-\u003e[a]-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:linesAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "linesAG1",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e [[[a]]]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#linesAG1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "linesAG1",
          "normalized": "Int-\u003e[a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "AG",
          "signature": "Int-\u003e[a]-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:linesAG1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "linesAG2",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e [[[a]]]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#linesAG2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "linesAG2",
          "normalized": "Int-\u003e[a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "AG",
          "signature": "Int-\u003e[a]-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:linesAG2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe lines (1-flats) in PG(n,fq)\n\u003c/p\u003e",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "linesPG",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e [[[a]]]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#linesPG",
          "type": "function"
        },
        "index": {
          "description": "The lines flats in PG fq",
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "linesPG",
          "normalized": "Int-\u003e[a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "PG",
          "signature": "Int-\u003e[a]-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:linesPG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "numFlatsAG",
          "package": "HaskellForMaths",
          "signature": "b -\u003e a -\u003e b -\u003e a",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#numFlatsAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "numFlatsAG",
          "normalized": "a-\u003eb-\u003ea-\u003eb",
          "package": "HaskellForMaths",
          "partial": "Flats AG",
          "signature": "b-\u003ea-\u003eb-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:numFlatsAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "numFlatsPG",
          "package": "HaskellForMaths",
          "signature": "b -\u003e a -\u003e b -\u003e a",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#numFlatsPG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "numFlatsPG",
          "normalized": "a-\u003eb-\u003ea-\u003eb",
          "package": "HaskellForMaths",
          "partial": "Flats PG",
          "signature": "b-\u003ea-\u003eb-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:numFlatsPG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "orderAff",
          "package": "HaskellForMaths",
          "signature": "b -\u003e a -\u003e a",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#orderAff",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "orderAff",
          "normalized": "a-\u003eb-\u003eb",
          "package": "HaskellForMaths",
          "partial": "Aff",
          "signature": "b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:orderAff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "orderGL",
          "package": "HaskellForMaths",
          "signature": "b -\u003e a -\u003e a",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#orderGL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "orderGL",
          "normalized": "a-\u003eb-\u003eb",
          "package": "HaskellForMaths",
          "partial": "GL",
          "signature": "b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:orderGL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "orderPGL",
          "package": "HaskellForMaths",
          "signature": "b -\u003e a -\u003e a",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#orderPGL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "orderPGL",
          "normalized": "a-\u003eb-\u003eb",
          "package": "HaskellForMaths",
          "partial": "PGL",
          "signature": "b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:orderPGL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "pnf",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#pnf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "pnf",
          "normalized": "[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:pnf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eptsAG n fq returns the points of the affine geometry AG(n,Fq), where fq are the elements of Fq\n\u003c/p\u003e",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "ptsAG",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#ptsAG",
          "type": "function"
        },
        "index": {
          "description": "ptsAG fq returns the points of the affine geometry AG Fq where fq are the elements of Fq",
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "ptsAG",
          "normalized": "Int-\u003e[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "AG",
          "signature": "Int-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:ptsAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eptsPG n fq returns the points of the projective geometry PG(n,Fq), where fq are the elements of Fq\n\u003c/p\u003e",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "ptsPG",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#ptsPG",
          "type": "function"
        },
        "index": {
          "description": "ptsPG fq returns the points of the projective geometry PG Fq where fq are the elements of Fq",
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "ptsPG",
          "normalized": "Int-\u003e[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "PG",
          "signature": "Int-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:ptsPG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "qnomial",
          "package": "HaskellForMaths",
          "signature": "b -\u003e b -\u003e a -\u003e a",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#qnomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "qnomial",
          "normalized": "a-\u003ea-\u003eb-\u003eb",
          "package": "HaskellForMaths",
          "signature": "b-\u003eb-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:qnomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "qnomials",
          "package": "HaskellForMaths",
          "signature": "d -\u003e [[d]]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#qnomials",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "qnomials",
          "normalized": "a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "d-\u003e[[d]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:qnomials"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "qtorial",
          "package": "HaskellForMaths",
          "signature": "b -\u003e a -\u003e a",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#qtorial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "qtorial",
          "normalized": "a-\u003eb-\u003eb",
          "package": "HaskellForMaths",
          "signature": "b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:qtorial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "qtorials",
          "package": "HaskellForMaths",
          "signature": "b -\u003e [b]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#qtorials",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "qtorials",
          "normalized": "a-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "b-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:qtorials"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "rrefs",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Int -\u003e [[[ZeroOneStar]]]",
          "source": "src/Math-Combinatorics-FiniteGeometry.html#rrefs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics FiniteGeometry",
          "module": "Math.Combinatorics.FiniteGeometry",
          "name": "rrefs",
          "normalized": "Int-\u003eInt-\u003e[[[ZeroOneStar]]]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eInt-\u003e[[[ZeroOneStar]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-FiniteGeometry.html#v:rrefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining a polymorphic data type for (simple, undirected) graphs,\n together with constructions of some common families of graphs,\n new from old constructions, and calculation of simple properties of graphs.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "Graph",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-Graph.html",
          "type": "module"
        },
        "index": {
          "description": "module defining polymorphic data type for simple undirected graphs together with constructions of some common families of graphs new from old constructions and calculation of simple properties of graphs",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "Graph",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDatatype for graphs, represented as a list of vertices and a list of edges.\n For most purposes, graphs are required to be in normal form.\n A graph G vs es is in normal form if (i) vs is in ascending order without duplicates,\n (ii) es is in ascending order without duplicates, (iii) each e in es is a 2-element list [x,y], x\u003cy\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "Graph",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-Graph.html#Graph",
          "type": "data"
        },
        "index": {
          "description": "Datatype for graphs represented as list of vertices and list of edges For most purposes graphs are required to be in normal form graph vs es is in normal form if vs is in ascending order without duplicates ii es is in ascending order without duplicates iii each in es is element list",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "Graph",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#t:Graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "G",
          "package": "HaskellForMaths",
          "signature": "G [a] [[a]]",
          "source": "src/Math-Combinatorics-Graph.html#Graph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "G",
          "normalized": "G[a][[a]]",
          "package": "HaskellForMaths",
          "signature": "G[a][[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:G"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "adjacencyMatrix",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e [[t]]",
          "source": "src/Math-Combinatorics-Graph.html#adjacencyMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "adjacencyMatrix",
          "normalized": "Graph a-\u003e[[b]]",
          "package": "HaskellForMaths",
          "partial": "Matrix",
          "signature": "Graph a-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:adjacencyMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "bipartiteKneser",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Int -\u003e Graph (Either [Int] [Int])",
          "source": "src/Math-Combinatorics-Graph.html#bipartiteKneser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "bipartiteKneser",
          "normalized": "Int-\u003eInt-\u003eGraph(Either[Int][Int])",
          "package": "HaskellForMaths",
          "partial": "Kneser",
          "signature": "Int-\u003eInt-\u003eGraph(Either[Int][Int])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:bipartiteKneser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ec n is the cyclic graph on n vertices\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "c",
          "package": "HaskellForMaths",
          "signature": "t -\u003e Graph t",
          "source": "src/Math-Combinatorics-Graph.html#c",
          "type": "function"
        },
        "index": {
          "description": "is the cyclic graph on vertices",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "c",
          "normalized": "a-\u003eGraph a",
          "package": "HaskellForMaths",
          "signature": "t-\u003eGraph t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "complement",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e Graph t",
          "source": "src/Math-Combinatorics-Graph.html#complement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "complement",
          "normalized": "Graph a-\u003eGraph a",
          "package": "HaskellForMaths",
          "signature": "Graph t-\u003eGraph t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:complement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "component",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e a -\u003e [a]",
          "source": "src/Math-Combinatorics-Graph.html#component",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "component",
          "normalized": "Graph a-\u003ea-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "Graph a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:component"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "components",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Graph.html#components",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "components",
          "normalized": "Graph a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "Graph a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:components"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "cube",
          "package": "HaskellForMaths",
          "signature": "Graph Integer",
          "source": "src/Math-Combinatorics-Graph.html#cube",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "cube",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:cube"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "desargues1",
          "package": "HaskellForMaths",
          "signature": "Graph (Either [Int] [Int])",
          "source": "src/Math-Combinatorics-Graph.html#desargues1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "desargues1",
          "normalized": "Graph(Either[Int][Int])",
          "package": "HaskellForMaths",
          "signature": "Graph(Either[Int][Int])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:desargues1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "desargues2",
          "package": "HaskellForMaths",
          "signature": "Graph (Either Integer Integer)",
          "source": "src/Math-Combinatorics-Graph.html#desargues2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "desargues2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:desargues2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe diameter of a graph is maximum distance between two distinct vertices\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "diameter",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e Int",
          "source": "src/Math-Combinatorics-Graph.html#diameter",
          "type": "function"
        },
        "index": {
          "description": "The diameter of graph is maximum distance between two distinct vertices",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "diameter",
          "normalized": "Graph a-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "Graph t-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:diameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWithin a graph G, the distance d(u,v) between vertices u, v is length of the shortest path from u to v\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "distance",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e a -\u003e a -\u003e Int",
          "source": "src/Math-Combinatorics-Graph.html#distance",
          "type": "function"
        },
        "index": {
          "description": "Within graph the distance between vertices is length of the shortest path from to",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "distance",
          "normalized": "Graph a-\u003ea-\u003ea-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "Graph a-\u003ea-\u003ea-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:distance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "distancePartition",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Graph.html#distancePartition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "distancePartition",
          "normalized": "Graph a-\u003ea-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Partition",
          "signature": "Graph a-\u003ea-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:distancePartition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "dodecahedron",
          "package": "HaskellForMaths",
          "signature": "Graph Integer",
          "source": "src/Math-Combinatorics-Graph.html#dodecahedron",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "dodecahedron",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:dodecahedron"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "dodecahedron2",
          "package": "HaskellForMaths",
          "signature": "Graph (Either Integer Integer)",
          "source": "src/Math-Combinatorics-Graph.html#dodecahedron2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "dodecahedron2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:dodecahedron2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "durer",
          "package": "HaskellForMaths",
          "signature": "Graph (Either Integer Integer)",
          "source": "src/Math-Combinatorics-Graph.html#durer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "durer",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:durer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "edges",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e [[t]]",
          "source": "src/Math-Combinatorics-Graph.html#edges",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "edges",
          "normalized": "Graph a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "Graph t-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:edges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "findCycles",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Graph.html#findCycles",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "findCycles",
          "normalized": "Graph a-\u003ea-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Cycles",
          "signature": "Graph a-\u003ea-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:findCycles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "findPaths",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e a -\u003e a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Graph.html#findPaths",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "findPaths",
          "normalized": "Graph a-\u003ea-\u003ea-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Paths",
          "signature": "Graph a-\u003ea-\u003ea-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:findPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "fromAdjacencyMatrix",
          "package": "HaskellForMaths",
          "signature": "[[b]] -\u003e Graph Int",
          "source": "src/Math-Combinatorics-Graph.html#fromAdjacencyMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "fromAdjacencyMatrix",
          "normalized": "[[a]]-\u003eGraph Int",
          "package": "HaskellForMaths",
          "partial": "Adjacency Matrix",
          "signature": "[[b]]-\u003eGraph Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:fromAdjacencyMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a graph with vertices which are lists of 0s and 1s,\n return a graph with vertices which are the numbers obtained by interpreting these as binary digits.\n For example, [1,1,0] -\u003e 6.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "fromBinary",
          "package": "HaskellForMaths",
          "signature": "Graph [a] -\u003e Graph a",
          "source": "src/Math-Combinatorics-Graph.html#fromBinary",
          "type": "function"
        },
        "index": {
          "description": "Given graph with vertices which are lists of and return graph with vertices which are the numbers obtained by interpreting these as binary digits For example",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "fromBinary",
          "normalized": "Graph[a]-\u003eGraph a",
          "package": "HaskellForMaths",
          "partial": "Binary",
          "signature": "Graph[a]-\u003eGraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:fromBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a graph with vertices which are lists of small integers, eg [1,2,3],\n return a graph with vertices which are the numbers obtained by interpreting these as digits, eg 123.\n The caller is responsible for ensuring that this makes sense (eg that the small integers are all \u003c 10)\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "fromDigits",
          "package": "HaskellForMaths",
          "signature": "Graph [a] -\u003e Graph a",
          "source": "src/Math-Combinatorics-Graph.html#fromDigits",
          "type": "function"
        },
        "index": {
          "description": "Given graph with vertices which are lists of small integers eg return graph with vertices which are the numbers obtained by interpreting these as digits eg The caller is responsible for ensuring that this makes sense eg that the small integers are all",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "fromDigits",
          "normalized": "Graph[a]-\u003eGraph a",
          "package": "HaskellForMaths",
          "partial": "Digits",
          "signature": "Graph[a]-\u003eGraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:fromDigits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "fromIncidenceMatrix",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Graph t",
          "source": "src/Math-Combinatorics-Graph.html#fromIncidenceMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "fromIncidenceMatrix",
          "normalized": "[[a]]-\u003eGraph b",
          "package": "HaskellForMaths",
          "partial": "Incidence Matrix",
          "signature": "[[a]]-\u003eGraph t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:fromIncidenceMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe girth of a graph is the size of the smallest cycle that it contains.\n Note: If the graph contains no cycles, we return -1, representing infinity.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "girth",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e Int",
          "source": "src/Math-Combinatorics-Graph.html#girth",
          "type": "function"
        },
        "index": {
          "description": "The girth of graph is the size of the smallest cycle that it contains Note If the graph contains no cycles we return representing infinity",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "girth",
          "normalized": "Graph a-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "Graph t-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:girth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "gp",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a -\u003e Graph (Either a a)",
          "source": "src/Math-Combinatorics-Graph.html#gp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "gp",
          "normalized": "a-\u003ea-\u003eGraph(Either a a)",
          "package": "HaskellForMaths",
          "signature": "a-\u003ea-\u003eGraph(Either a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:gp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSafe constructor for graph from lists of vertices and edges.\n graph (vs,es) checks that vs and es are valid before returning the graph.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "graph",
          "package": "HaskellForMaths",
          "signature": "([t], [[t]]) -\u003e Graph t",
          "source": "src/Math-Combinatorics-Graph.html#graph",
          "type": "function"
        },
        "index": {
          "description": "Safe constructor for graph from lists of vertices and edges graph vs es checks that vs and es are valid before returning the graph",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "graph",
          "normalized": "([a],[[a]])-\u003eGraph a",
          "package": "HaskellForMaths",
          "signature": "([t],[[t]])-\u003eGraph t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "icosahedron",
          "package": "HaskellForMaths",
          "signature": "Graph Integer",
          "source": "src/Math-Combinatorics-Graph.html#icosahedron",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "icosahedron",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:icosahedron"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "incidenceMatrix",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e [[t]]",
          "source": "src/Math-Combinatorics-Graph.html#incidenceMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "incidenceMatrix",
          "normalized": "Graph a-\u003e[[b]]",
          "package": "HaskellForMaths",
          "partial": "Matrix",
          "signature": "Graph a-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:incidenceMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "inducedSubgraph",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e [a] -\u003e Graph a",
          "source": "src/Math-Combinatorics-Graph.html#inducedSubgraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "inducedSubgraph",
          "normalized": "Graph a-\u003e[a]-\u003eGraph a",
          "package": "HaskellForMaths",
          "partial": "Subgraph",
          "signature": "Graph a-\u003e[a]-\u003eGraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:inducedSubgraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs the graph connected?\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "isConnected",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e Bool",
          "source": "src/Math-Combinatorics-Graph.html#isConnected",
          "type": "function"
        },
        "index": {
          "description": "Is the graph connected",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "isConnected",
          "normalized": "Graph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Connected",
          "signature": "Graph t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:isConnected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA 3-regular graph is called a cubic graph\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "isCubic",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e Bool",
          "source": "src/Math-Combinatorics-Graph.html#isCubic",
          "type": "function"
        },
        "index": {
          "description": "regular graph is called cubic graph",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "isCubic",
          "normalized": "Graph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Cubic",
          "signature": "Graph t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:isCubic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "isGraph",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]] -\u003e Bool",
          "source": "src/Math-Combinatorics-Graph.html#isGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "isGraph",
          "normalized": "[a]-\u003e[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "[a]-\u003e[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:isGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA graph is regular if all vertices have the same valency (degree)\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "isRegular",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e Bool",
          "source": "src/Math-Combinatorics-Graph.html#isRegular",
          "type": "function"
        },
        "index": {
          "description": "graph is regular if all vertices have the same valency degree",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "isRegular",
          "normalized": "Graph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Regular",
          "signature": "Graph t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:isRegular"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "isSetSystem",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]] -\u003e Bool",
          "source": "src/Math-Combinatorics-Graph.html#isSetSystem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "isSetSystem",
          "normalized": "[a]-\u003e[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Set System",
          "signature": "[a]-\u003e[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:isSetSystem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "j",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Int -\u003e Int -\u003e Graph [Int]",
          "source": "src/Math-Combinatorics-Graph.html#j",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "j",
          "normalized": "Int-\u003eInt-\u003eInt-\u003eGraph[Int]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eInt-\u003eInt-\u003eGraph[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:j"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "johnson",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Int -\u003e Graph [Int]",
          "source": "src/Math-Combinatorics-Graph.html#johnson",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "johnson",
          "normalized": "Int-\u003eInt-\u003eGraph[Int]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eInt-\u003eGraph[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:johnson"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ek n is the complete graph on n vertices\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "k",
          "package": "HaskellForMaths",
          "signature": "t -\u003e Graph t",
          "source": "src/Math-Combinatorics-Graph.html#k",
          "type": "function"
        },
        "index": {
          "description": "is the complete graph on vertices",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "k",
          "normalized": "a-\u003eGraph a",
          "package": "HaskellForMaths",
          "signature": "t-\u003eGraph t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:k"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ekb m n is the complete bipartite graph on m and n vertices\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "kb",
          "package": "HaskellForMaths",
          "signature": "t -\u003e t -\u003e Graph t",
          "source": "src/Math-Combinatorics-Graph.html#kb",
          "type": "function"
        },
        "index": {
          "description": "kb is the complete bipartite graph on and vertices",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "kb",
          "normalized": "a-\u003ea-\u003eGraph a",
          "package": "HaskellForMaths",
          "signature": "t-\u003et-\u003eGraph t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:kb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ekb' m n is the complete bipartite graph on m left and n right vertices\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "kb'",
          "package": "HaskellForMaths",
          "signature": "t -\u003e t -\u003e Graph (Either t t)",
          "source": "src/Math-Combinatorics-Graph.html#kb%27",
          "type": "function"
        },
        "index": {
          "description": "kb is the complete bipartite graph on left and right vertices",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "kb'",
          "normalized": "a-\u003ea-\u003eGraph(Either a a)",
          "package": "HaskellForMaths",
          "signature": "t-\u003et-\u003eGraph(Either t t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:kb-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ekneser n k returns the kneser graph KG n,k -\n whose vertices are the k-element subsets of [1..n], with edges between disjoint subsets\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "kneser",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Int -\u003e Graph [Int]",
          "source": "src/Math-Combinatorics-Graph.html#kneser",
          "type": "function"
        },
        "index": {
          "description": "kneser returns the kneser graph KG whose vertices are the k-element subsets of with edges between disjoint subsets",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "kneser",
          "normalized": "Int-\u003eInt-\u003eGraph[Int]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eInt-\u003eGraph[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:kneser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "lineGraph",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e Graph t",
          "source": "src/Math-Combinatorics-Graph.html#lineGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "lineGraph",
          "normalized": "Graph a-\u003eGraph b",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "Graph a-\u003eGraph t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:lineGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "lineGraph'",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e Graph [a]",
          "source": "src/Math-Combinatorics-Graph.html#lineGraph%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "lineGraph'",
          "normalized": "Graph a-\u003eGraph[a]",
          "package": "HaskellForMaths",
          "partial": "Graph'",
          "signature": "Graph a-\u003eGraph[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:lineGraph-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "mobiusKantor",
          "package": "HaskellForMaths",
          "signature": "Graph (Either Integer Integer)",
          "source": "src/Math-Combinatorics-Graph.html#mobiusKantor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "mobiusKantor",
          "package": "HaskellForMaths",
          "partial": "Kantor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:mobiusKantor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "nbrs",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e a -\u003e [a]",
          "source": "src/Math-Combinatorics-Graph.html#nbrs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "nbrs",
          "normalized": "Graph a-\u003ea-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "Graph a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:nbrs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a graph to normal form. The input is assumed to be a valid graph apart from order\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "nf",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e Graph a",
          "source": "src/Math-Combinatorics-Graph.html#nf",
          "type": "function"
        },
        "index": {
          "description": "Convert graph to normal form The input is assumed to be valid graph apart from order",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "nf",
          "normalized": "Graph a-\u003eGraph a",
          "package": "HaskellForMaths",
          "signature": "Graph a-\u003eGraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:nf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe null graph on n vertices is the graph with no edges\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "nullGraph",
          "package": "HaskellForMaths",
          "signature": "t -\u003e Graph t",
          "source": "src/Math-Combinatorics-Graph.html#nullGraph",
          "type": "function"
        },
        "index": {
          "description": "The null graph on vertices is the graph with no edges",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "nullGraph",
          "normalized": "a-\u003eGraph a",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "t-\u003eGraph t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:nullGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe null graph, with no vertices or edges\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "nullGraph'",
          "package": "HaskellForMaths",
          "signature": "Graph Int",
          "source": "src/Math-Combinatorics-Graph.html#nullGraph%27",
          "type": "function"
        },
        "index": {
          "description": "The null graph with no vertices or edges",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "nullGraph'",
          "package": "HaskellForMaths",
          "partial": "Graph'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:nullGraph-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "octahedron",
          "package": "HaskellForMaths",
          "signature": "Graph Integer",
          "source": "src/Math-Combinatorics-Graph.html#octahedron",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "octahedron",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:octahedron"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "order",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e Int",
          "source": "src/Math-Combinatorics-Graph.html#order",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "order",
          "normalized": "Graph a-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "Graph a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:order"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "petersen",
          "package": "HaskellForMaths",
          "signature": "Graph [Integer]",
          "source": "src/Math-Combinatorics-Graph.html#petersen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "petersen",
          "normalized": "Graph[Integer]",
          "package": "HaskellForMaths",
          "signature": "Graph[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:petersen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "petersen2",
          "package": "HaskellForMaths",
          "signature": "Graph (Either Integer Integer)",
          "source": "src/Math-Combinatorics-Graph.html#petersen2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "petersen2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:petersen2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "powerset",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Graph.html#powerset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "powerset",
          "normalized": "[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:powerset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "prism",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Graph (Either a a)",
          "source": "src/Math-Combinatorics-Graph.html#prism",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "prism",
          "normalized": "a-\u003eGraph(Either a a)",
          "package": "HaskellForMaths",
          "signature": "a-\u003eGraph(Either a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:prism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eq k is the graph of the k-cube\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "q",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Graph t",
          "source": "src/Math-Combinatorics-Graph.html#q",
          "type": "function"
        },
        "index": {
          "description": "is the graph of the k-cube",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "q",
          "normalized": "Int-\u003eGraph a",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eGraph t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "q'",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Graph [t]",
          "source": "src/Math-Combinatorics-Graph.html#q%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "q'",
          "normalized": "Int-\u003eGraph[a]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eGraph[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:q-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "regularParam",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e Maybe Int",
          "source": "src/Math-Combinatorics-Graph.html#regularParam",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "regularParam",
          "normalized": "Graph a-\u003eMaybe Int",
          "package": "HaskellForMaths",
          "partial": "Param",
          "signature": "Graph a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:regularParam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe restriction of a graph to a subset of the vertices\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Graph",
          "name": "restriction",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e [a] -\u003e Graph a",
          "source": "src/Math-Combinatorics-Graph.html#restriction",
          "type": "function"
        },
        "index": {
          "description": "The restriction of graph to subset of the vertices",
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "restriction",
          "normalized": "Graph a-\u003e[a]-\u003eGraph a",
          "package": "HaskellForMaths",
          "signature": "Graph a-\u003e[a]-\u003eGraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:restriction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "set",
          "package": "HaskellForMaths",
          "signature": "[b] -\u003e [b]",
          "source": "src/Math-Combinatorics-Graph.html#set",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "set",
          "normalized": "[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[b]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "size",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e Int",
          "source": "src/Math-Combinatorics-Graph.html#size",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "size",
          "normalized": "Graph a-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "Graph t-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "tetrahedron",
          "package": "HaskellForMaths",
          "signature": "Graph Integer",
          "source": "src/Math-Combinatorics-Graph.html#tetrahedron",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "tetrahedron",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:tetrahedron"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "to1n",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e Graph t",
          "source": "src/Math-Combinatorics-Graph.html#to1n",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "to1n",
          "normalized": "Graph a-\u003eGraph b",
          "package": "HaskellForMaths",
          "signature": "Graph a-\u003eGraph t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:to1n"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "toGraph",
          "package": "HaskellForMaths",
          "signature": "([a], [[a]]) -\u003e Graph a",
          "source": "src/Math-Combinatorics-Graph.html#toGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "toGraph",
          "normalized": "([a],[[a]])-\u003eGraph a",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "([a],[[a]])-\u003eGraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:toGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "valencies",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e [(Int, Int)]",
          "source": "src/Math-Combinatorics-Graph.html#valencies",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "valencies",
          "normalized": "Graph a-\u003e[(Int,Int)]",
          "package": "HaskellForMaths",
          "signature": "Graph a-\u003e[(Int,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:valencies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "valency",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e a -\u003e Int",
          "source": "src/Math-Combinatorics-Graph.html#valency",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "valency",
          "normalized": "Graph a-\u003ea-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "Graph a-\u003ea-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:valency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "valencyPartition",
          "package": "HaskellForMaths",
          "signature": "Graph b -\u003e [[b]]",
          "source": "src/Math-Combinatorics-Graph.html#valencyPartition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "valencyPartition",
          "normalized": "Graph a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Partition",
          "signature": "Graph b-\u003e[[b]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:valencyPartition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Graph",
          "name": "vertices",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e [t]",
          "source": "src/Math-Combinatorics-Graph.html#vertices",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Graph",
          "module": "Math.Combinatorics.Graph",
          "name": "vertices",
          "normalized": "Graph a-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "Graph t-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Graph.html#v:vertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.GraphAuts",
          "name": "GraphAuts",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-GraphAuts.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Combinatorics GraphAuts",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "GraphAuts",
          "package": "HaskellForMaths",
          "partial": "Graph Auts",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-GraphAuts.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a graph g, \u003ccode\u003egraphAuts g\u003c/code\u003e returns generators for the automorphism group of g.\n If g is connected, then the generators will be a strong generating set.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "graphAuts",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e [Permutation a]",
          "source": "src/Math-Combinatorics-GraphAuts.html#graphAuts",
          "type": "function"
        },
        "index": {
          "description": "Given graph graphAuts returns generators for the automorphism group of If is connected then the generators will be strong generating set",
          "hierarchy": "Math Combinatorics GraphAuts",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "graphAuts",
          "normalized": "Graph a-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Auts",
          "signature": "Graph a-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-GraphAuts.html#v:graphAuts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.GraphAuts",
          "name": "graphIsos",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e Graph t1 -\u003e [[(t, t1)]]",
          "source": "src/Math-Combinatorics-GraphAuts.html#graphIsos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics GraphAuts",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "graphIsos",
          "normalized": "Graph a-\u003eGraph a-\u003e[[(a,a)]]",
          "package": "HaskellForMaths",
          "partial": "Isos",
          "signature": "Graph t-\u003eGraph t-\u003e[[(t,t)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-GraphAuts.html#v:graphIsos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven the incidence graph of an incidence structure between points and blocks\n (for example, a set system),\n \u003ccode\u003eincidenceAuts g\u003c/code\u003e returns generators for the automorphism group of the incidence structure.\n The generators are represented as permutations of the points.\n The incidence graph should be represented with the points on the left and the blocks on the right.\n If the incidence graph is connected, then the generators will be a strong generating set.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "incidenceAuts",
          "package": "HaskellForMaths",
          "signature": "Graph (Either p b) -\u003e [Permutation p]",
          "source": "src/Math-Combinatorics-GraphAuts.html#incidenceAuts",
          "type": "function"
        },
        "index": {
          "description": "Given the incidence graph of an incidence structure between points and blocks for example set system incidenceAuts returns generators for the automorphism group of the incidence structure The generators are represented as permutations of the points The incidence graph should be represented with the points on the left and the blocks on the right If the incidence graph is connected then the generators will be strong generating set",
          "hierarchy": "Math Combinatorics GraphAuts",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "incidenceAuts",
          "normalized": "Graph(Either a b)-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Auts",
          "signature": "Graph(Either p b)-\u003e[Permutation p]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-GraphAuts.html#v:incidenceAuts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.GraphAuts",
          "name": "incidenceIsos",
          "package": "HaskellForMaths",
          "signature": "Graph (Either t2 t) -\u003e Graph (Either t3 t1) -\u003e [[(t2, t3)]]",
          "source": "src/Math-Combinatorics-GraphAuts.html#incidenceIsos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics GraphAuts",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "incidenceIsos",
          "normalized": "Graph(Either a a)-\u003eGraph(Either a a)-\u003e[[(a,a)]]",
          "package": "HaskellForMaths",
          "partial": "Isos",
          "signature": "Graph(Either t t)-\u003eGraph(Either t t)-\u003e[[(t,t)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-GraphAuts.html#v:incidenceIsos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.GraphAuts",
          "name": "is2ArcTransitive",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e Bool",
          "source": "src/Math-Combinatorics-GraphAuts.html#is2ArcTransitive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics GraphAuts",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "is2ArcTransitive",
          "normalized": "Graph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Arc Transitive",
          "signature": "Graph t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-GraphAuts.html#v:is2ArcTransitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.GraphAuts",
          "name": "is3ArcTransitive",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e Bool",
          "source": "src/Math-Combinatorics-GraphAuts.html#is3ArcTransitive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics GraphAuts",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "is3ArcTransitive",
          "normalized": "Graph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Arc Transitive",
          "signature": "Graph t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-GraphAuts.html#v:is3ArcTransitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA graph is arc-transitive (or flag-transitive) if its automorphism group acts transitively on arcs. (An arc is an ordered pair of adjacent vertices.)\n\u003c/p\u003e",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "isArcTransitive",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e Bool",
          "source": "src/Math-Combinatorics-GraphAuts.html#isArcTransitive",
          "type": "function"
        },
        "index": {
          "description": "graph is arc-transitive or flag-transitive if its automorphism group acts transitively on arcs An arc is an ordered pair of adjacent vertices",
          "hierarchy": "Math Combinatorics GraphAuts",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "isArcTransitive",
          "normalized": "Graph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Arc Transitive",
          "signature": "Graph t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-GraphAuts.html#v:isArcTransitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA graph is distance transitive if given any two ordered pairs of vertices (u,u') and (v,v') with d(u,u') == d(v,v'),\n there is an automorphism of the graph that takes (u,u') to (v,v')\n\u003c/p\u003e",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "isDistanceTransitive",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e Bool",
          "source": "src/Math-Combinatorics-GraphAuts.html#isDistanceTransitive",
          "type": "function"
        },
        "index": {
          "description": "graph is distance transitive if given any two ordered pairs of vertices and with there is an automorphism of the graph that takes to",
          "hierarchy": "Math Combinatorics GraphAuts",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "isDistanceTransitive",
          "normalized": "Graph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Distance Transitive",
          "signature": "Graph t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-GraphAuts.html#v:isDistanceTransitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA graph is edge-transitive if its automorphism group acts transitively on the edges. Thus, given any two distinct edges, there is an automorphism mapping one to the other.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "isEdgeTransitive",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e Bool",
          "source": "src/Math-Combinatorics-GraphAuts.html#isEdgeTransitive",
          "type": "function"
        },
        "index": {
          "description": "graph is edge-transitive if its automorphism group acts transitively on the edges Thus given any two distinct edges there is an automorphism mapping one to the other",
          "hierarchy": "Math Combinatorics GraphAuts",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "isEdgeTransitive",
          "normalized": "Graph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Edge Transitive",
          "signature": "Graph t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-GraphAuts.html#v:isEdgeTransitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre the two graphs isomorphic?\n\u003c/p\u003e",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "isGraphIso",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e Graph b -\u003e Bool",
          "source": "src/Math-Combinatorics-GraphAuts.html#isGraphIso",
          "type": "function"
        },
        "index": {
          "description": "Are the two graphs isomorphic",
          "hierarchy": "Math Combinatorics GraphAuts",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "isGraphIso",
          "normalized": "Graph a-\u003eGraph b-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Graph Iso",
          "signature": "Graph a-\u003eGraph b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-GraphAuts.html#v:isGraphIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre the two incidence structures represented by these incidence graphs isomorphic?\n\u003c/p\u003e",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "isIncidenceIso",
          "package": "HaskellForMaths",
          "signature": "Graph (Either p1 b1) -\u003e Graph (Either p2 b2) -\u003e Bool",
          "source": "src/Math-Combinatorics-GraphAuts.html#isIncidenceIso",
          "type": "function"
        },
        "index": {
          "description": "Are the two incidence structures represented by these incidence graphs isomorphic",
          "hierarchy": "Math Combinatorics GraphAuts",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "isIncidenceIso",
          "normalized": "Graph(Either a b)-\u003eGraph(Either a b)-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Incidence Iso",
          "signature": "Graph(Either p b)-\u003eGraph(Either p b)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-GraphAuts.html#v:isIncidenceIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA graph is vertex-transitive if its automorphism group acts transitively on the vertices. Thus, given any two distinct vertices, there is an automorphism mapping one to the other.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "isVertexTransitive",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e Bool",
          "source": "src/Math-Combinatorics-GraphAuts.html#isVertexTransitive",
          "type": "function"
        },
        "index": {
          "description": "graph is vertex-transitive if its automorphism group acts transitively on the vertices Thus given any two distinct vertices there is an automorphism mapping one to the other",
          "hierarchy": "Math Combinatorics GraphAuts",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "isVertexTransitive",
          "normalized": "Graph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Vertex Transitive",
          "signature": "Graph t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-GraphAuts.html#v:isVertexTransitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA graph is n-arc-transitive is its automorphism group is transitive on n-arcs. (An n-arc is an ordered sequence (v0,...,vn) of adjacent vertices, with crossings allowed but not doubling back.)\n\u003c/p\u003e",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "isnArcTransitive",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Graph t -\u003e Bool",
          "source": "src/Math-Combinatorics-GraphAuts.html#isnArcTransitive",
          "type": "function"
        },
        "index": {
          "description": "graph is n-arc-transitive is its automorphism group is transitive on n-arcs An n-arc is an ordered sequence v0 vn of adjacent vertices with crossings allowed but not doubling back",
          "hierarchy": "Math Combinatorics GraphAuts",
          "module": "Math.Combinatorics.GraphAuts",
          "name": "isnArcTransitive",
          "normalized": "Int-\u003eGraph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Arc Transitive",
          "signature": "Int-\u003eGraph t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-GraphAuts.html#v:isnArcTransitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining a type for hypergraphs.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "Hypergraph",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-Hypergraph.html",
          "type": "module"
        },
        "index": {
          "description": "module defining type for hypergraphs",
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "Hypergraph",
          "package": "HaskellForMaths",
          "partial": "Hypergraph",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "Hypergraph",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-Hypergraph.html#Hypergraph",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "Hypergraph",
          "package": "HaskellForMaths",
          "partial": "Hypergraph",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#t:Hypergraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "H",
          "package": "HaskellForMaths",
          "signature": "H [a] [[a]]",
          "source": "src/Math-Combinatorics-Hypergraph.html#Hypergraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "H",
          "normalized": "H[a][[a]]",
          "package": "HaskellForMaths",
          "signature": "H[a][[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:H"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "coxeterGraph",
          "package": "HaskellForMaths",
          "signature": "Graph [Integer]",
          "source": "src/Math-Combinatorics-Hypergraph.html#coxeterGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "coxeterGraph",
          "normalized": "Graph[Integer]",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "Graph[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:coxeterGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "desarguesConfiguration",
          "package": "HaskellForMaths",
          "signature": "Hypergraph [Integer]",
          "source": "src/Math-Combinatorics-Hypergraph.html#desarguesConfiguration",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "desarguesConfiguration",
          "normalized": "Hypergraph[Integer]",
          "package": "HaskellForMaths",
          "partial": "Configuration",
          "signature": "Hypergraph[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:desarguesConfiguration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "desarguesGraph",
          "package": "HaskellForMaths",
          "signature": "Graph (Either [Integer] [[Integer]])",
          "source": "src/Math-Combinatorics-Hypergraph.html#desarguesGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "desarguesGraph",
          "normalized": "Graph(Either[Integer][[Integer]])",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "Graph(Either[Integer][[Integer]])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:desarguesGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "duads",
          "package": "HaskellForMaths",
          "signature": "[[Integer]]",
          "source": "src/Math-Combinatorics-Hypergraph.html#duads",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "duads",
          "normalized": "[[Integer]]",
          "package": "HaskellForMaths",
          "signature": "[[Integer]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:duads"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "dualGrid",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a -\u003e Hypergraph a",
          "source": "src/Math-Combinatorics-Hypergraph.html#dualGrid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "dualGrid",
          "normalized": "a-\u003ea-\u003eHypergraph a",
          "package": "HaskellForMaths",
          "partial": "Grid",
          "signature": "a-\u003ea-\u003eHypergraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:dualGrid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "fanoPlane",
          "package": "HaskellForMaths",
          "signature": "Hypergraph Integer",
          "source": "src/Math-Combinatorics-Hypergraph.html#fanoPlane",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "fanoPlane",
          "package": "HaskellForMaths",
          "partial": "Plane",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:fanoPlane"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "fromDesign",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e Hypergraph a",
          "source": "src/Math-Combinatorics-Hypergraph.html#fromDesign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "fromDesign",
          "normalized": "Design a-\u003eHypergraph a",
          "package": "HaskellForMaths",
          "partial": "Design",
          "signature": "Design a-\u003eHypergraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:fromDesign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "fromGraph",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e Hypergraph a",
          "source": "src/Math-Combinatorics-Hypergraph.html#fromGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "fromGraph",
          "normalized": "Graph a-\u003eHypergraph a",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "Graph a-\u003eHypergraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:fromGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "fromIncidenceMatrix",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Hypergraph a1",
          "source": "src/Math-Combinatorics-Hypergraph.html#fromIncidenceMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "fromIncidenceMatrix",
          "normalized": "[[a]]-\u003eHypergraph a",
          "package": "HaskellForMaths",
          "partial": "Incidence Matrix",
          "signature": "[[a]]-\u003eHypergraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:fromIncidenceMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "grid",
          "package": "HaskellForMaths",
          "signature": "t -\u003e t1 -\u003e Hypergraph (t, t1)",
          "source": "src/Math-Combinatorics-Hypergraph.html#grid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "grid",
          "normalized": "a-\u003ea-\u003eHypergraph(a,a)",
          "package": "HaskellForMaths",
          "signature": "t-\u003et-\u003eHypergraph(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:grid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Heawood graph is the incidence graph of the Fano plane\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "heawoodGraph",
          "package": "HaskellForMaths",
          "signature": "Graph (Either Integer [Integer])",
          "source": "src/Math-Combinatorics-Hypergraph.html#heawoodGraph",
          "type": "function"
        },
        "index": {
          "description": "The Heawood graph is the incidence graph of the Fano plane",
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "heawoodGraph",
          "normalized": "Graph(Either Integer[Integer])",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "Graph(Either Integer[Integer])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:heawoodGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "hypergraph",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]] -\u003e Hypergraph a",
          "source": "src/Math-Combinatorics-Hypergraph.html#hypergraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "hypergraph",
          "normalized": "[a]-\u003e[[a]]-\u003eHypergraph a",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[[a]]-\u003eHypergraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:hypergraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "incidenceGraph",
          "package": "HaskellForMaths",
          "signature": "Hypergraph a -\u003e Graph (Either a [a])",
          "source": "src/Math-Combinatorics-Hypergraph.html#incidenceGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "incidenceGraph",
          "normalized": "Hypergraph a-\u003eGraph(Either a[a])",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "Hypergraph a-\u003eGraph(Either a[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:incidenceGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "incidenceMatrix",
          "package": "HaskellForMaths",
          "signature": "Hypergraph a -\u003e [[t]]",
          "source": "src/Math-Combinatorics-Hypergraph.html#incidenceMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "incidenceMatrix",
          "normalized": "Hypergraph a-\u003e[[b]]",
          "package": "HaskellForMaths",
          "partial": "Matrix",
          "signature": "Hypergraph a-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:incidenceMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "intersectionGraph",
          "package": "HaskellForMaths",
          "signature": "Hypergraph a -\u003e Graph [a]",
          "source": "src/Math-Combinatorics-Hypergraph.html#intersectionGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "intersectionGraph",
          "normalized": "Hypergraph a-\u003eGraph[a]",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "Hypergraph a-\u003eGraph[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:intersectionGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs this hypergraph a (projective) configuration.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isConfiguration",
          "package": "HaskellForMaths",
          "signature": "Hypergraph a -\u003e Bool",
          "source": "src/Math-Combinatorics-Hypergraph.html#isConfiguration",
          "type": "function"
        },
        "index": {
          "description": "Is this hypergraph projective configuration",
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isConfiguration",
          "normalized": "Hypergraph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Configuration",
          "signature": "Hypergraph a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:isConfiguration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isGenQuadrangle'",
          "package": "HaskellForMaths",
          "signature": "Hypergraph a -\u003e Bool",
          "source": "src/Math-Combinatorics-Hypergraph.html#isGenQuadrangle%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isGenQuadrangle'",
          "normalized": "Hypergraph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Gen Quadrangle'",
          "signature": "Hypergraph a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:isGenQuadrangle-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isGeneralizedQuadrangle",
          "package": "HaskellForMaths",
          "signature": "Hypergraph a -\u003e Bool",
          "source": "src/Math-Combinatorics-Hypergraph.html#isGeneralizedQuadrangle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isGeneralizedQuadrangle",
          "normalized": "Hypergraph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Generalized Quadrangle",
          "signature": "Hypergraph a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:isGeneralizedQuadrangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isPartialLinearSpace",
          "package": "HaskellForMaths",
          "signature": "Hypergraph a -\u003e Bool",
          "source": "src/Math-Combinatorics-Hypergraph.html#isPartialLinearSpace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isPartialLinearSpace",
          "normalized": "Hypergraph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Partial Linear Space",
          "signature": "Hypergraph a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:isPartialLinearSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs this hypergraph a projective plane - meaning that any two lines meet in a unique point,\n and any two points lie on a unique line\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isProjectivePlane",
          "package": "HaskellForMaths",
          "signature": "Hypergraph a -\u003e Bool",
          "source": "src/Math-Combinatorics-Hypergraph.html#isProjectivePlane",
          "type": "function"
        },
        "index": {
          "description": "Is this hypergraph projective plane meaning that any two lines meet in unique point and any two points lie on unique line",
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isProjectivePlane",
          "normalized": "Hypergraph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Projective Plane",
          "signature": "Hypergraph a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:isProjectivePlane"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs this hypergraph a projective plane with a quadrangle.\n This is a stronger non-degeneracy condition.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isProjectivePlaneQuad",
          "package": "HaskellForMaths",
          "signature": "Hypergraph a -\u003e Bool",
          "source": "src/Math-Combinatorics-Hypergraph.html#isProjectivePlaneQuad",
          "type": "function"
        },
        "index": {
          "description": "Is this hypergraph projective plane with quadrangle This is stronger non-degeneracy condition",
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isProjectivePlaneQuad",
          "normalized": "Hypergraph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Projective Plane Quad",
          "signature": "Hypergraph a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:isProjectivePlaneQuad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs this hypergraph a projective plane with a triangle.\n This is a weak non-degeneracy condition, which eliminates all points on the same line, or all lines through the same point.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isProjectivePlaneTri",
          "package": "HaskellForMaths",
          "signature": "Hypergraph a -\u003e Bool",
          "source": "src/Math-Combinatorics-Hypergraph.html#isProjectivePlaneTri",
          "type": "function"
        },
        "index": {
          "description": "Is this hypergraph projective plane with triangle This is weak non-degeneracy condition which eliminates all points on the same line or all lines through the same point",
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isProjectivePlaneTri",
          "normalized": "Hypergraph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Projective Plane Tri",
          "signature": "Hypergraph a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:isProjectivePlaneTri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs this hypergraph uniform - meaning that all blocks are of the same size\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isUniform",
          "package": "HaskellForMaths",
          "signature": "Hypergraph a -\u003e Bool",
          "source": "src/Math-Combinatorics-Hypergraph.html#isUniform",
          "type": "function"
        },
        "index": {
          "description": "Is this hypergraph uniform meaning that all blocks are of the same size",
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "isUniform",
          "normalized": "Hypergraph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Uniform",
          "signature": "Hypergraph a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:isUniform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "pappusConfiguration",
          "package": "HaskellForMaths",
          "signature": "Hypergraph Integer",
          "source": "src/Math-Combinatorics-Hypergraph.html#pappusConfiguration",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "pappusConfiguration",
          "package": "HaskellForMaths",
          "partial": "Configuration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:pappusConfiguration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "pappusGraph",
          "package": "HaskellForMaths",
          "signature": "Graph (Either Integer [Integer])",
          "source": "src/Math-Combinatorics-Hypergraph.html#pappusGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "pappusGraph",
          "normalized": "Graph(Either Integer[Integer])",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "Graph(Either Integer[Integer])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:pappusGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "same",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Hypergraph.html#same",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "same",
          "normalized": "[a]-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:same"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "synthemes",
          "package": "HaskellForMaths",
          "signature": "[[[Integer]]]",
          "source": "src/Math-Combinatorics-Hypergraph.html#synthemes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "synthemes",
          "normalized": "[[[Integer]]]",
          "package": "HaskellForMaths",
          "signature": "[[[Integer]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:synthemes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Hypergraph",
          "name": "toHypergraph",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]] -\u003e Hypergraph a",
          "source": "src/Math-Combinatorics-Hypergraph.html#toHypergraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "toHypergraph",
          "normalized": "[a]-\u003e[[a]]-\u003eHypergraph a",
          "package": "HaskellForMaths",
          "partial": "Hypergraph",
          "signature": "[a]-\u003e[[a]]-\u003eHypergraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:toHypergraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Tutte-Coxeter graph, also called the Tutte 8-cage\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "tutteCoxeterGraph",
          "package": "HaskellForMaths",
          "signature": "Graph (Either [Integer] [[Integer]])",
          "source": "src/Math-Combinatorics-Hypergraph.html#tutteCoxeterGraph",
          "type": "function"
        },
        "index": {
          "description": "The Tutte-Coxeter graph also called the Tutte cage",
          "hierarchy": "Math Combinatorics Hypergraph",
          "module": "Math.Combinatorics.Hypergraph",
          "name": "tutteCoxeterGraph",
          "normalized": "Graph(Either[Integer][[Integer]])",
          "package": "HaskellForMaths",
          "partial": "Coxeter Graph",
          "signature": "Graph(Either[Integer][[Integer]])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Hypergraph.html#v:tutteCoxeterGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "IncidenceAlgebra",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "IncidenceAlgebra",
          "package": "HaskellForMaths",
          "partial": "Incidence Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type to represent an interval in a poset. The (closed) interval [x,y] is the set {z | x \u003c= z \u003c= y} within the poset.\n Note that the \"empty interval\" is not an interval - that is, the interval [x,y] is only defined for x \u003c= y.\n The (closed) intervals within a poset form a basis for the incidence algebra as a k-vector space.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "Interval",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#Interval",
          "type": "data"
        },
        "index": {
          "description": "type to represent an interval in poset The closed interval is the set within the poset Note that the empty interval is not an interval that is the interval is only defined for The closed intervals within poset form basis for the incidence algebra as k-vector space",
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "Interval",
          "package": "HaskellForMaths",
          "partial": "Interval",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#t:Interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "Iv",
          "package": "HaskellForMaths",
          "signature": "Iv (Poset a) (a, a)",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#Interval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "Iv",
          "normalized": "Iv(Poset a)(a,a)",
          "package": "HaskellForMaths",
          "partial": "Iv",
          "signature": "Iv(Poset a)(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:Iv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "basisIA",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e [Vect k (Interval a)]",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#basisIA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "basisIA",
          "normalized": "Poset a-\u003e[Vect b(Interval a)]",
          "package": "HaskellForMaths",
          "partial": "IA",
          "signature": "Poset a-\u003e[Vect k(Interval a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:basisIA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "etaIA",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Vect k (Interval a)",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#etaIA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "etaIA",
          "normalized": "Poset a-\u003eVect b(Interval a)",
          "package": "HaskellForMaths",
          "partial": "IA",
          "signature": "Poset a-\u003eVect k(Interval a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:etaIA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList representatives of the order isomorphism classes of intervals in a poset\n\u003c/p\u003e",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "intervalIsoClasses",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e [Interval a]",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#intervalIsoClasses",
          "type": "function"
        },
        "index": {
          "description": "List representatives of the order isomorphism classes of intervals in poset",
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "intervalIsoClasses",
          "normalized": "Poset a-\u003e[Interval a]",
          "package": "HaskellForMaths",
          "partial": "Iso Classes",
          "signature": "Poset a-\u003e[Interval a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:intervalIsoClasses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "intervalIsoMap",
          "package": "HaskellForMaths",
          "signature": "Poset b -\u003e Map (Interval b) (Maybe (Interval b))",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#intervalIsoMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "intervalIsoMap",
          "normalized": "Poset a-\u003eMap(Interval a)(Maybe(Interval a))",
          "package": "HaskellForMaths",
          "partial": "Iso Map",
          "signature": "Poset b-\u003eMap(Interval b)(Maybe(Interval b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:intervalIsoMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "intervalIsos",
          "package": "HaskellForMaths",
          "signature": "Interval a -\u003e Interval a1 -\u003e [[(a, a1)]]",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#intervalIsos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "intervalIsos",
          "normalized": "Interval a-\u003eInterval a-\u003e[[(a,a)]]",
          "package": "HaskellForMaths",
          "partial": "Isos",
          "signature": "Interval a-\u003eInterval a-\u003e[[(a,a)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:intervalIsos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe inverse of an element in the incidence algebra of a poset.\n This is only defined for elements which are non-zero on all intervals (x,x)\n\u003c/p\u003e",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "invIA",
          "package": "HaskellForMaths",
          "signature": "Vect k (Interval a) -\u003e Maybe (Vect k (Interval a))",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#invIA",
          "type": "function"
        },
        "index": {
          "description": "The inverse of an element in the incidence algebra of poset This is only defined for elements which are non-zero on all intervals",
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "invIA",
          "normalized": "Vect a(Interval b)-\u003eMaybe(Vect a(Interval b))",
          "package": "HaskellForMaths",
          "partial": "IA",
          "signature": "Vect k(Interval a)-\u003eMaybe(Vect k(Interval a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:invIA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "invIA1",
          "package": "HaskellForMaths",
          "signature": "Vect a (Interval t) -\u003e Vect a (Interval t)",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#invIA1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "invIA1",
          "normalized": "Vect a(Interval b)-\u003eVect a(Interval b)",
          "package": "HaskellForMaths",
          "partial": "IA",
          "signature": "Vect a(Interval t)-\u003eVect a(Interval t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:invIA1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "isIntervalIso",
          "package": "HaskellForMaths",
          "signature": "Interval a -\u003e Interval b -\u003e Bool",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#isIntervalIso",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "isIntervalIso",
          "normalized": "Interval a-\u003eInterval b-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Interval Iso",
          "signature": "Interval a-\u003eInterval b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:isIntervalIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "ivPoset",
          "package": "HaskellForMaths",
          "signature": "Interval t -\u003e Poset t",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#ivPoset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "ivPoset",
          "normalized": "Interval a-\u003ePoset a",
          "package": "HaskellForMaths",
          "partial": "Poset",
          "signature": "Interval t-\u003ePoset t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:ivPoset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "muB",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Vect k (Interval [Int])",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#muB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "muB",
          "normalized": "Int-\u003eVect a(Interval[Int])",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eVect k(Interval[Int])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:muB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "muC",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Vect k (Interval Int)",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#muC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "muC",
          "normalized": "Int-\u003eVect a(Interval Int)",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eVect k(Interval Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:muC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Mobius function of a poset\n\u003c/p\u003e",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "muIA",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Vect k (Interval a)",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#muIA",
          "type": "function"
        },
        "index": {
          "description": "The Mobius function of poset",
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "muIA",
          "normalized": "Poset a-\u003eVect b(Interval a)",
          "package": "HaskellForMaths",
          "partial": "IA",
          "signature": "Poset a-\u003eVect k(Interval a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:muIA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "muIA1",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Vect k (Interval a)",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#muIA1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "muIA1",
          "normalized": "Poset a-\u003eVect b(Interval a)",
          "package": "HaskellForMaths",
          "partial": "IA",
          "signature": "Poset a-\u003eVect k(Interval a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:muIA1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "muL",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e Vect Int (Interval [[a]])",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#muL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "muL",
          "normalized": "Int-\u003e[a]-\u003eVect Int(Interval[[a]])",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[a]-\u003eVect Int(Interval[[a]])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:muL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function (ie element of the incidence algebra) that counts the total number of chains in each interval\n\u003c/p\u003e",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "numChainsIA",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Vect Q (Interval a)",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#numChainsIA",
          "type": "function"
        },
        "index": {
          "description": "function ie element of the incidence algebra that counts the total number of chains in each interval",
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "numChainsIA",
          "normalized": "Poset a-\u003eVect Q(Interval a)",
          "package": "HaskellForMaths",
          "partial": "Chains IA",
          "signature": "Poset a-\u003eVect Q(Interval a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:numChainsIA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function (ie element of the incidence algebra) that counts the number of maximal chains in each interval\n\u003c/p\u003e",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "numMaximalChainsIA",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Vect Q (Interval a)",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#numMaximalChainsIA",
          "type": "function"
        },
        "index": {
          "description": "function ie element of the incidence algebra that counts the number of maximal chains in each interval",
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "numMaximalChainsIA",
          "normalized": "Poset a-\u003eVect Q(Interval a)",
          "package": "HaskellForMaths",
          "partial": "Maximal Chains IA",
          "signature": "Poset a-\u003eVect Q(Interval a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:numMaximalChainsIA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003etoIsoClasses\u003c/code\u003e is the linear map from the incidence Hopf algebra of a poset to itself,\n in which each interval is mapped to (the minimal representative of) its isomorphism class.\n Thus the result can be considered as a linear combination of isomorphism classes of intervals,\n rather than of intervals themselves.\n Note that if this operation is to be performed repeatedly for the same poset,\n then it is more efficient to use \u003ccode\u003etoIsoClasses' poset\u003c/code\u003e, which memoizes the isomorphism class lookup table.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "toIsoClasses",
          "package": "HaskellForMaths",
          "signature": "Vect k (Interval a) -\u003e Vect k (Interval a)",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#toIsoClasses",
          "type": "function"
        },
        "index": {
          "description": "toIsoClasses is the linear map from the incidence Hopf algebra of poset to itself in which each interval is mapped to the minimal representative of its isomorphism class Thus the result can be considered as linear combination of isomorphism classes of intervals rather than of intervals themselves Note that if this operation is to be performed repeatedly for the same poset then it is more efficient to use toIsoClasses poset which memoizes the isomorphism class lookup table",
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "toIsoClasses",
          "normalized": "Vect a(Interval b)-\u003eVect a(Interval b)",
          "package": "HaskellForMaths",
          "partial": "Iso Classes",
          "signature": "Vect k(Interval a)-\u003eVect k(Interval a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:toIsoClasses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a poset, \u003ccode\u003etoIsoClasses' poset\u003c/code\u003e is the linear map from the incidence Hopf algebra of the poset to itself,\n in which each interval is mapped to (the minimal representative of) its isomorphism class.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "toIsoClasses'",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Vect k (Interval a) -\u003e Vect k (Interval a)",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#toIsoClasses%27",
          "type": "function"
        },
        "index": {
          "description": "Given poset toIsoClasses poset is the linear map from the incidence Hopf algebra of the poset to itself in which each interval is mapped to the minimal representative of its isomorphism class",
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "toIsoClasses'",
          "normalized": "Poset a-\u003eVect b(Interval a)-\u003eVect b(Interval a)",
          "package": "HaskellForMaths",
          "partial": "Iso Classes'",
          "signature": "Poset a-\u003eVect k(Interval a)-\u003eVect k(Interval a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:toIsoClasses-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit of the incidence algebra of a poset\n\u003c/p\u003e",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "unitIA",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Vect k (Interval a)",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#unitIA",
          "type": "function"
        },
        "index": {
          "description": "The unit of the incidence algebra of poset",
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "unitIA",
          "normalized": "Poset a-\u003eVect b(Interval a)",
          "package": "HaskellForMaths",
          "partial": "IA",
          "signature": "Poset a-\u003eVect k(Interval a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:unitIA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe zeta function of a poset\n\u003c/p\u003e",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "zetaIA",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Vect k (Interval a)",
          "source": "src/Math-Combinatorics-IncidenceAlgebra.html#zetaIA",
          "type": "function"
        },
        "index": {
          "description": "The zeta function of poset",
          "hierarchy": "Math Combinatorics IncidenceAlgebra",
          "module": "Math.Combinatorics.IncidenceAlgebra",
          "name": "zetaIA",
          "normalized": "Poset a-\u003eVect b(Interval a)",
          "package": "HaskellForMaths",
          "partial": "IA",
          "signature": "Poset a-\u003eVect k(Interval a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-IncidenceAlgebra.html#v:zetaIA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.LatinSquares",
          "name": "LatinSquares",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-LatinSquares.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "LatinSquares",
          "package": "HaskellForMaths",
          "partial": "Latin Squares",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.LatinSquares",
          "name": "findLatinSqs",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[[a]]]",
          "source": "src/Math-Combinatorics-LatinSquares.html#findLatinSqs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "findLatinSqs",
          "normalized": "[a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "Latin Sqs",
          "signature": "[a]-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#v:findLatinSqs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.LatinSquares",
          "name": "findMOLS",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [[[b]]] -\u003e [[[[b]]]]",
          "source": "src/Math-Combinatorics-LatinSquares.html#findMOLS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "findMOLS",
          "normalized": "a-\u003e[[[b]]]-\u003e[[[[b]]]]",
          "package": "HaskellForMaths",
          "partial": "MOLS",
          "signature": "a-\u003e[[[b]]]-\u003e[[[[b]]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#v:findMOLS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.LatinSquares",
          "name": "fromLS",
          "package": "HaskellForMaths",
          "signature": "[[Int]] -\u003e [[Int]]",
          "source": "src/Math-Combinatorics-LatinSquares.html#fromLS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "fromLS",
          "normalized": "[[Int]]-\u003e[[Int]]",
          "package": "HaskellForMaths",
          "partial": "LS",
          "signature": "[[Int]]-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#v:fromLS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.LatinSquares",
          "name": "fromMOLS",
          "package": "HaskellForMaths",
          "signature": "[[[Int]]] -\u003e [[Int]]",
          "source": "src/Math-Combinatorics-LatinSquares.html#fromMOLS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "fromMOLS",
          "normalized": "[[[Int]]]-\u003e[[Int]]",
          "package": "HaskellForMaths",
          "partial": "MOLS",
          "signature": "[[[Int]]]-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#v:fromMOLS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMOLS from a projective plane\n\u003c/p\u003e",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "fromProjectivePlane",
          "package": "HaskellForMaths",
          "signature": "Design [k] -\u003e [[[Int]]]",
          "source": "src/Math-Combinatorics-LatinSquares.html#fromProjectivePlane",
          "type": "function"
        },
        "index": {
          "description": "MOLS from projective plane",
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "fromProjectivePlane",
          "normalized": "Design[a]-\u003e[[[Int]]]",
          "package": "HaskellForMaths",
          "partial": "Projective Plane",
          "signature": "Design[k]-\u003e[[[Int]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#v:fromProjectivePlane"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.LatinSquares",
          "name": "graphOA",
          "package": "HaskellForMaths",
          "signature": "[[b]] -\u003e Graph [b]",
          "source": "src/Math-Combinatorics-LatinSquares.html#graphOA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "graphOA",
          "normalized": "[[a]]-\u003eGraph[a]",
          "package": "HaskellForMaths",
          "partial": "OA",
          "signature": "[[b]]-\u003eGraph[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#v:graphOA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.LatinSquares",
          "name": "incidenceGraphLS",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Graph (Int, Int, a)",
          "source": "src/Math-Combinatorics-LatinSquares.html#incidenceGraphLS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "incidenceGraphLS",
          "normalized": "[[a]]-\u003eGraph(Int,Int,a)",
          "package": "HaskellForMaths",
          "partial": "Graph LS",
          "signature": "[[a]]-\u003eGraph(Int,Int,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#v:incidenceGraphLS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.LatinSquares",
          "name": "incidenceGraphLS'",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Graph (Int, Int)",
          "source": "src/Math-Combinatorics-LatinSquares.html#incidenceGraphLS%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "incidenceGraphLS'",
          "normalized": "[[a]]-\u003eGraph(Int,Int)",
          "package": "HaskellForMaths",
          "partial": "Graph LS'",
          "signature": "[[a]]-\u003eGraph(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#v:incidenceGraphLS-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.LatinSquares",
          "name": "isLatinSq",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Bool",
          "source": "src/Math-Combinatorics-LatinSquares.html#isLatinSq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "isLatinSq",
          "normalized": "[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Latin Sq",
          "signature": "[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#v:isLatinSq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre the latin squares mutually orthogonal (ie each pair is orthogonal)?\n\u003c/p\u003e",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "isMOLS",
          "package": "HaskellForMaths",
          "signature": "[[[a]]] -\u003e Bool",
          "source": "src/Math-Combinatorics-LatinSquares.html#isMOLS",
          "type": "function"
        },
        "index": {
          "description": "Are the latin squares mutually orthogonal ie each pair is orthogonal",
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "isMOLS",
          "normalized": "[[[a]]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "MOLS",
          "signature": "[[[a]]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#v:isMOLS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.LatinSquares",
          "name": "isOA",
          "package": "HaskellForMaths",
          "signature": "(Int, Int) -\u003e [[b]] -\u003e Bool",
          "source": "src/Math-Combinatorics-LatinSquares.html#isOA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "isOA",
          "normalized": "(Int,Int)-\u003e[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "OA",
          "signature": "(Int,Int)-\u003e[[b]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#v:isOA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.LatinSquares",
          "name": "isOneOfEach",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Bool",
          "source": "src/Math-Combinatorics-LatinSquares.html#isOneOfEach",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "isOneOfEach",
          "normalized": "[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "One Of Each",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#v:isOneOfEach"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre the two latin squares orthogonal?\n\u003c/p\u003e",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "isOrthogonal",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[b]] -\u003e Bool",
          "source": "src/Math-Combinatorics-LatinSquares.html#isOrthogonal",
          "type": "function"
        },
        "index": {
          "description": "Are the two latin squares orthogonal",
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "isOrthogonal",
          "normalized": "[[a]]-\u003e[[b]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Orthogonal",
          "signature": "[[a]]-\u003e[[b]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#v:isOrthogonal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.LatinSquares",
          "name": "srgParamsOA",
          "package": "HaskellForMaths",
          "signature": "(t, t) -\u003e Maybe (t, t, t, t)",
          "source": "src/Math-Combinatorics-LatinSquares.html#srgParamsOA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics LatinSquares",
          "module": "Math.Combinatorics.LatinSquares",
          "name": "srgParamsOA",
          "normalized": "(a,a)-\u003eMaybe(a,a,a,a)",
          "package": "HaskellForMaths",
          "partial": "Params OA",
          "signature": "(t,t)-\u003eMaybe(t,t,t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-LatinSquares.html#v:srgParamsOA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module providing functions to construct and investigate (small, finite) matroids.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "Matroid",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-Matroid.html",
          "type": "module"
        },
        "index": {
          "description": "module providing functions to construct and investigate small finite matroids",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "Matroid",
          "package": "HaskellForMaths",
          "partial": "Matroid",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "LMR",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-Matroid.html#LMR",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "LMR",
          "package": "HaskellForMaths",
          "partial": "LMR",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#t:LMR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA datatype to represent a matroid. \u003ccode\u003eM es bs\u003c/code\u003e is the matroid whose elements are \u003ccode\u003ees\u003c/code\u003e, and whose bases are \u003ccode\u003ebs\u003c/code\u003e.\n The normal form is for the \u003ccode\u003ees\u003c/code\u003e to be in order, for each of the \u003ccode\u003ebs\u003c/code\u003e individually to be in order.\n (So the TrieSet should have the property that any path from the root to a leaf is strictly increasing).\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "Matroid",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-Matroid.html#Matroid",
          "type": "data"
        },
        "index": {
          "description": "datatype to represent matroid es bs is the matroid whose elements are es and whose bases are bs The normal form is for the es to be in order for each of the bs individually to be in order So the TrieSet should have the property that any path from the root to leaf is strictly increasing",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "Matroid",
          "package": "HaskellForMaths",
          "partial": "Matroid",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#t:Matroid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe data structure that we use to store the bases of the matroid\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "TrieSet",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-Matroid.html#TrieSet",
          "type": "data"
        },
        "index": {
          "description": "The data structure that we use to store the bases of the matroid",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "TrieSet",
          "package": "HaskellForMaths",
          "partial": "Trie Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#t:TrieSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "(///)",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#%2F%2F%2F",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "(///) ///",
          "normalized": "Matroid a-\u003e[a]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[a]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:-47--47--47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "(\\\\\\)",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#%5C%5C%5C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "(\\\\\\) \\\\\\",
          "normalized": "Matroid a-\u003e[a]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[a]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:-92--92--92-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "L",
          "package": "HaskellForMaths",
          "signature": "L a",
          "source": "src/Math-Combinatorics-Matroid.html#LMR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "L",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "M",
          "package": "HaskellForMaths",
          "signature": "M [a] (TrieSet a)",
          "source": "src/Math-Combinatorics-Matroid.html#Matroid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "M",
          "normalized": "M[a](TrieSet a)",
          "package": "HaskellForMaths",
          "signature": "M[a](TrieSet a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "Mid",
          "package": "HaskellForMaths",
          "signature": "Mid",
          "source": "src/Math-Combinatorics-Matroid.html#LMR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "Mid",
          "package": "HaskellForMaths",
          "partial": "Mid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:Mid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "R",
          "package": "HaskellForMaths",
          "signature": "R b",
          "source": "src/Math-Combinatorics-Matroid.html#LMR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "R",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "TS",
          "package": "HaskellForMaths",
          "signature": "TS [(a, TrieSet a)]",
          "source": "src/Math-Combinatorics-Matroid.html#TrieSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "TS",
          "normalized": "TS[(a,TrieSet a)]",
          "package": "HaskellForMaths",
          "partial": "TS",
          "signature": "TS[(a,TrieSet a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:TS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list of points in k^n, number the points [1..], and construct the matroid whose independent sets\n correspond to those sets of points which are affinely independent.\n\u003c/p\u003e\u003cp\u003eA multiset of points in k^n is said to be affinely dependent if it contains two identical points,\n or three collinear points, or four coplanar points, or ... - and affinely independent otherwise.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "affineMatroid",
          "package": "HaskellForMaths",
          "signature": "[[k]] -\u003e Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#affineMatroid",
          "type": "function"
        },
        "index": {
          "description": "Given list of points in number the points and construct the matroid whose independent sets correspond to those sets of points which are affinely independent multiset of points in is said to be affinely dependent if it contains two identical points or three collinear points or four coplanar points or and affinely independent otherwise",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "affineMatroid",
          "normalized": "[[a]]-\u003eMatroid Int",
          "package": "HaskellForMaths",
          "partial": "Matroid",
          "signature": "[[k]]-\u003eMatroid Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:affineMatroid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn all bases for the given matroid\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "bases",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Matroid.html#bases",
          "type": "function"
        },
        "index": {
          "description": "Return all bases for the given matroid",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "bases",
          "normalized": "Matroid a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:bases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList the circuit-hyperplanes of a matroid.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "circuitHyperplanes",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Matroid.html#circuitHyperplanes",
          "type": "function"
        },
        "index": {
          "description": "List the circuit-hyperplanes of matroid",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "circuitHyperplanes",
          "normalized": "Matroid a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Hyperplanes",
          "signature": "Matroid a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:circuitHyperplanes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn all circuits for the given matroid, in shortlex order.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "circuits",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Matroid.html#circuits",
          "type": "function"
        },
        "index": {
          "description": "Return all circuits for the given matroid in shortlex order",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "circuits",
          "normalized": "Matroid a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:circuits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "closedUnderSubsets",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#closedUnderSubsets",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "closedUnderSubsets",
          "normalized": "[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Under Subsets",
          "signature": "[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:closedUnderSubsets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a matroid m, \u003ccode\u003eclosure m\u003c/code\u003e is the closure operator on subsets of its element set\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "closure",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e [a]",
          "source": "src/Math-Combinatorics-Matroid.html#closure",
          "type": "function"
        },
        "index": {
          "description": "Given matroid closure is the closure operator on subsets of its element set",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "closure",
          "normalized": "Matroid a-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:closure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "cocircuits",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Matroid.html#cocircuits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "cocircuits",
          "normalized": "Matroid a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:cocircuits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "component",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e a -\u003e [a]",
          "source": "src/Math-Combinatorics-Matroid.html#component",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "component",
          "normalized": "Matroid a-\u003ea-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:component"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "contraction",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#contraction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "contraction",
          "normalized": "Matroid a-\u003e[a]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[a]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:contraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "coveringFlats",
          "package": "HaskellForMaths",
          "signature": "Matroid t -\u003e [t] -\u003e [[t]]",
          "source": "src/Math-Combinatorics-Matroid.html#coveringFlats",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "coveringFlats",
          "normalized": "Matroid a-\u003e[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Flats",
          "signature": "Matroid t-\u003e[t]-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:coveringFlats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven the edges of an undirected graph, number the edges [1..], and construct the matroid whose independent sets\n correspond to those sets of edges which contain no cycle. The bases therefore correspond to maximal forests within the graph.\n The edge set is allowed to contain loops or parallel edges.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "cycleMatroid",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#cycleMatroid",
          "type": "function"
        },
        "index": {
          "description": "Given the edges of an undirected graph number the edges and construct the matroid whose independent sets correspond to those sets of edges which contain no cycle The bases therefore correspond to maximal forests within the graph The edge set is allowed to contain loops or parallel edges",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "cycleMatroid",
          "normalized": "[[a]]-\u003eMatroid Int",
          "package": "HaskellForMaths",
          "partial": "Matroid",
          "signature": "[[a]]-\u003eMatroid Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:cycleMatroid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "cycleMatroid'",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Matroid [a]",
          "source": "src/Math-Combinatorics-Matroid.html#cycleMatroid%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "cycleMatroid'",
          "normalized": "[[a]]-\u003eMatroid[a]",
          "package": "HaskellForMaths",
          "partial": "Matroid'",
          "signature": "[[a]]-\u003eMatroid[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:cycleMatroid-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "deletion",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#deletion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "deletion",
          "normalized": "Matroid a-\u003e[a]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[a]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:deletion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "deletions",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Matroid.html#deletions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "deletions",
          "normalized": "[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:deletions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Desargues configuration\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "desargues",
          "package": "HaskellForMaths",
          "signature": "Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#desargues",
          "type": "function"
        },
        "index": {
          "description": "The Desargues configuration",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "desargues",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:desargues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe direct sum of two matroids\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "dsum",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Matroid b -\u003e Matroid (Either a b)",
          "source": "src/Math-Combinatorics-Matroid.html#dsum",
          "type": "function"
        },
        "index": {
          "description": "The direct sum of two matroids",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "dsum",
          "normalized": "Matroid a-\u003eMatroid b-\u003eMatroid(Either a b)",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003eMatroid b-\u003eMatroid(Either a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:dsum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe dual matroid\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "dual",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#dual",
          "type": "function"
        },
        "index": {
          "description": "The dual matroid",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "dual",
          "normalized": "Matroid a-\u003eMatroid a",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:dual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the elements over which the matroid is defined.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "elements",
          "package": "HaskellForMaths",
          "signature": "Matroid t -\u003e [t]",
          "source": "src/Math-Combinatorics-Matroid.html#elements",
          "type": "function"
        },
        "index": {
          "description": "Return the elements over which the matroid is defined",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "elements",
          "normalized": "Matroid a-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "Matroid t-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:elements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "ex161",
          "package": "HaskellForMaths",
          "signature": "[[t]]",
          "source": "src/Math-Combinatorics-Matroid.html#ex161",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "ex161",
          "normalized": "[[a]]",
          "package": "HaskellForMaths",
          "signature": "[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:ex161"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "exists",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#exists",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "exists",
          "normalized": "[a]-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:exists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Fano plane F7 = PG(2,F2)\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "f7",
          "package": "HaskellForMaths",
          "signature": "Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#f7",
          "type": "function"
        },
        "index": {
          "description": "The Fano plane F7 PG F2",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "f7",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:f7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF7-, the relaxation of the Fano plane by removal of a line\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "f7m",
          "package": "HaskellForMaths",
          "signature": "Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#f7m",
          "type": "function"
        },
        "index": {
          "description": "F7 the relaxation of the Fano plane by removal of line",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "f7m",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:f7m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "fcig",
          "package": "HaskellForMaths",
          "signature": "Matroid t -\u003e [t] -\u003e [[t]]",
          "source": "src/Math-Combinatorics-Matroid.html#fcig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fcig",
          "normalized": "Matroid a-\u003e[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "Matroid t-\u003e[t]-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fcig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "fcim",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e [[k]]",
          "source": "src/Math-Combinatorics-Matroid.html#fcim",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fcim",
          "normalized": "Matroid a-\u003e[a]-\u003e[[b]]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[a]-\u003e[[k]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fcim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "fcim'",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e [[t]]",
          "source": "src/Math-Combinatorics-Matroid.html#fcim%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fcim'",
          "normalized": "Matroid a-\u003e[a]-\u003e[[b]]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[a]-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fcim-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe flats of a matroid are its closed sets. They form a lattice under inclusion.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "flats",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Matroid.html#flats",
          "type": "function"
        },
        "index": {
          "description": "The flats of matroid are its closed sets They form lattice under inclusion",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "flats",
          "normalized": "Matroid a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:flats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "flats1",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Matroid.html#flats1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "flats1",
          "normalized": "Matroid a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:flats1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReconstruct a matroid from its elements and bases.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromBases",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#fromBases",
          "type": "function"
        },
        "index": {
          "description": "Reconstruct matroid from its elements and bases",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromBases",
          "normalized": "[a]-\u003e[[a]]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "partial": "Bases",
          "signature": "[a]-\u003e[[a]]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fromBases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReconstruct a matroid from its elements and circuits.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromCircuits",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#fromCircuits",
          "type": "function"
        },
        "index": {
          "description": "Reconstruct matroid from its elements and circuits",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromCircuits",
          "normalized": "[a]-\u003e[[a]]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "partial": "Circuits",
          "signature": "[a]-\u003e[[a]]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fromCircuits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReconstruct a matroid from its elements and closure operator\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromClosure",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e ([a] -\u003e [a]) -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#fromClosure",
          "type": "function"
        },
        "index": {
          "description": "Reconstruct matroid from its elements and closure operator",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromClosure",
          "normalized": "[a]-\u003e([a]-\u003e[a])-\u003eMatroid a",
          "package": "HaskellForMaths",
          "partial": "Closure",
          "signature": "[a]-\u003e([a]-\u003e[a])-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fromClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReconstruct a matroid from its flats. (The flats must be given in shortlex order.)\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromFlats",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#fromFlats",
          "type": "function"
        },
        "index": {
          "description": "Reconstruct matroid from its flats The flats must be given in shortlex order",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromFlats",
          "normalized": "[[a]]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "partial": "Flats",
          "signature": "[[a]]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fromFlats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "fromFlats'",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#fromFlats%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromFlats'",
          "normalized": "[[a]]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "partial": "Flats'",
          "signature": "[[a]]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fromFlats-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efromGeoRep returns a matroid from a geometric representation consisting of dependent flats of various ranks.\n Given lists of dependent rank 0 flats (loops), rank 1 flats (points), rank 2 flats (lines) and rank 3 flats (planes),\n \u003ccode\u003efromGeoRep loops points lines planes\u003c/code\u003e returns the matroid having these as dependent flats.\n Note that if all the elements lie in the same plane, then this should still be listed as an argument.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromGeoRep",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]] -\u003e [[a]] -\u003e [[a]] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#fromGeoRep",
          "type": "function"
        },
        "index": {
          "description": "fromGeoRep returns matroid from geometric representation consisting of dependent flats of various ranks Given lists of dependent rank flats loops rank flats points rank flats lines and rank flats planes fromGeoRep loops points lines planes returns the matroid having these as dependent flats Note that if all the elements lie in the same plane then this should still be listed as an argument",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromGeoRep",
          "normalized": "[[a]]-\u003e[[a]]-\u003e[[a]]-\u003e[[a]]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "partial": "Geo Rep",
          "signature": "[[a]]-\u003e[[a]]-\u003e[[a]]-\u003e[[a]]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fromGeoRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReconstruct a matroid from its elements and hyperplanes\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromHyperplanes",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#fromHyperplanes",
          "type": "function"
        },
        "index": {
          "description": "Reconstruct matroid from its elements and hyperplanes",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromHyperplanes",
          "normalized": "[a]-\u003e[[a]]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "partial": "Hyperplanes",
          "signature": "[a]-\u003e[[a]]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fromHyperplanes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "fromHyperplanes1",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#fromHyperplanes1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromHyperplanes1",
          "normalized": "[a]-\u003e[[a]]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "partial": "Hyperplanes",
          "signature": "[a]-\u003e[[a]]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fromHyperplanes1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a matroid from its elements and its independent sets.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromIndeps",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#fromIndeps",
          "type": "function"
        },
        "index": {
          "description": "Construct matroid from its elements and its independent sets",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromIndeps",
          "normalized": "[a]-\u003e[[a]]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "partial": "Indeps",
          "signature": "[a]-\u003e[[a]]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fromIndeps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "fromIndeps1",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#fromIndeps1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromIndeps1",
          "normalized": "[a]-\u003e[[a]]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "partial": "Indeps",
          "signature": "[a]-\u003e[[a]]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fromIndeps1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReconstruct a matroid from its elements and rank function\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromRankfun",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e ([a] -\u003e Int) -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#fromRankfun",
          "type": "function"
        },
        "index": {
          "description": "Reconstruct matroid from its elements and rank function",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fromRankfun",
          "normalized": "[a]-\u003e([a]-\u003eInt)-\u003eMatroid a",
          "package": "HaskellForMaths",
          "partial": "Rankfun",
          "signature": "[a]-\u003e([a]-\u003eInt)-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fromRankfun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a matroid m, a basis b, and an element e, \u003ccode\u003efundamentalCircuit m b e\u003c/code\u003e returns the unique circuit contained in b union {e},\n which is called the fundamental circuit of e with respect to b.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "fundamentalCircuit",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e a -\u003e [a]",
          "source": "src/Math-Combinatorics-Matroid.html#fundamentalCircuit",
          "type": "function"
        },
        "index": {
          "description": "Given matroid basis and an element fundamentalCircuit returns the unique circuit contained in union which is called the fundamental circuit of with respect to",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fundamentalCircuit",
          "normalized": "Matroid a-\u003e[a]-\u003ea-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Circuit",
          "signature": "Matroid a-\u003e[a]-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fundamentalCircuit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a matroid m, the fundamental-circuit incidence matrix relative to a base b\n has rows indexed by the elements of b, and columns indexed by the elements not in b.\n The bi, ej entry is 1 if bi is in the fundamental circuit of ej relative to b, and 0 otherwise.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "fundamentalCircuitIncidenceMatrix",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e [[k]]",
          "source": "src/Math-Combinatorics-Matroid.html#fundamentalCircuitIncidenceMatrix",
          "type": "function"
        },
        "index": {
          "description": "Given matroid the fundamental-circuit incidence matrix relative to base has rows indexed by the elements of and columns indexed by the elements not in The bi ej entry is if bi is in the fundamental circuit of ej relative to and otherwise",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fundamentalCircuitIncidenceMatrix",
          "normalized": "Matroid a-\u003e[a]-\u003e[[b]]",
          "package": "HaskellForMaths",
          "partial": "Circuit Incidence Matrix",
          "signature": "Matroid a-\u003e[a]-\u003e[[k]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fundamentalCircuitIncidenceMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "fundamentalCircuitIncidenceMatrix'",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e [[t]]",
          "source": "src/Math-Combinatorics-Matroid.html#fundamentalCircuitIncidenceMatrix%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "fundamentalCircuitIncidenceMatrix'",
          "normalized": "Matroid a-\u003e[a]-\u003e[[b]]",
          "package": "HaskellForMaths",
          "partial": "Circuit Incidence Matrix'",
          "signature": "Matroid a-\u003e[a]-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:fundamentalCircuitIncidenceMatrix-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "hyperplanes",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Matroid.html#hyperplanes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "hyperplanes",
          "normalized": "Matroid a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:hyperplanes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "hyperplanes1",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Matroid.html#hyperplanes1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "hyperplanes1",
          "normalized": "Matroid a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:hyperplanes1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "implies",
          "package": "HaskellForMaths",
          "signature": "Bool -\u003e Bool -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#implies",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "implies",
          "normalized": "Bool-\u003eBool-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "Bool-\u003eBool-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:implies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "incidenceGraphB",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Graph (Either a [a])",
          "source": "src/Math-Combinatorics-Matroid.html#incidenceGraphB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "incidenceGraphB",
          "normalized": "Matroid a-\u003eGraph(Either a[a])",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "Matroid a-\u003eGraph(Either a[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:incidenceGraphB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "incidenceGraphC",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Graph (Either a [a])",
          "source": "src/Math-Combinatorics-Matroid.html#incidenceGraphC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "incidenceGraphC",
          "normalized": "Matroid a-\u003eGraph(Either a[a])",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "Matroid a-\u003eGraph(Either a[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:incidenceGraphC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "incidenceGraphH",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Graph (Either a [a])",
          "source": "src/Math-Combinatorics-Matroid.html#incidenceGraphH",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "incidenceGraphH",
          "normalized": "Matroid a-\u003eGraph(Either a[a])",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "Matroid a-\u003eGraph(Either a[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:incidenceGraphH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "indepCounts",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [Int]",
          "source": "src/Math-Combinatorics-Matroid.html#indepCounts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "indepCounts",
          "normalized": "Matroid a-\u003e[Int]",
          "package": "HaskellForMaths",
          "partial": "Counts",
          "signature": "Matroid a-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:indepCounts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn all the independent sets of a matroid, in shortlex order.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "indeps",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Matroid.html#indeps",
          "type": "function"
        },
        "index": {
          "description": "Return all the independent sets of matroid in shortlex order",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "indeps",
          "normalized": "Matroid a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:indeps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA base or basis in a matroid is a maximal independent set.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isBase",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isBase",
          "type": "function"
        },
        "index": {
          "description": "base or basis in matroid is maximal independent set",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isBase",
          "normalized": "Matroid a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Base",
          "signature": "Matroid a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA binary matroid is a matroid which is representable over F2\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isBinary",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isBinary",
          "type": "function"
        },
        "index": {
          "description": "binary matroid is matroid which is representable over F2",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isBinary",
          "normalized": "Matroid a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Binary",
          "signature": "Matroid a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "isBinary2",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isBinary2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isBinary2",
          "normalized": "Matroid a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Binary",
          "signature": "Matroid a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isBinary2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA circuit in a matroid is a minimal dependent set.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isCircuit",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isCircuit",
          "type": "function"
        },
        "index": {
          "description": "circuit in matroid is minimal dependent set",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isCircuit",
          "normalized": "Matroid a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Circuit",
          "signature": "Matroid a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isCircuit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "isCircuitHyperplane",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isCircuitHyperplane",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isCircuitHyperplane",
          "normalized": "Matroid a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Circuit Hyperplane",
          "signature": "Matroid a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isCircuitHyperplane"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "isClutter",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isClutter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isClutter",
          "normalized": "[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Clutter",
          "signature": "[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isClutter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "isCobase",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isCobase",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isCobase",
          "normalized": "Matroid a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Cobase",
          "signature": "Matroid a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isCobase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "isCocircuit",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isCocircuit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isCocircuit",
          "normalized": "Matroid a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Cocircuit",
          "signature": "Matroid a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isCocircuit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "isCoindependent",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isCoindependent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isCoindependent",
          "normalized": "Matroid a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Coindependent",
          "signature": "Matroid a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isCoindependent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "isColoop",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e a -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isColoop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isColoop",
          "normalized": "Matroid a-\u003ea-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Coloop",
          "signature": "Matroid a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isColoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA matroid is (2-)connected if, for every pair of distinct elements, there is a circuit containing both\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isConnected",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isConnected",
          "type": "function"
        },
        "index": {
          "description": "matroid is connected if for every pair of distinct elements there is circuit containing both",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isConnected",
          "normalized": "Matroid a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Connected",
          "signature": "Matroid a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isConnected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "isCoparallel",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isCoparallel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isCoparallel",
          "normalized": "Matroid a-\u003ea-\u003ea-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Coparallel",
          "signature": "Matroid a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isCoparallel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "isDependent",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isDependent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isDependent",
          "normalized": "Matroid a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Dependent",
          "signature": "Matroid a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isDependent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA flat in a matroid is a closed set, that is a set which is equal to its own closure\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isFlat",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isFlat",
          "type": "function"
        },
        "index": {
          "description": "flat in matroid is closed set that is set which is equal to its own closure",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isFlat",
          "normalized": "Matroid a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Flat",
          "signature": "Matroid a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isFlat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA hyperplane is a flat whose rank is one less than that of the matroid\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isHyperplane",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isHyperplane",
          "type": "function"
        },
        "index": {
          "description": "hyperplane is flat whose rank is one less than that of the matroid",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isHyperplane",
          "normalized": "Matroid a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Hyperplane",
          "signature": "Matroid a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isHyperplane"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "isIndependent",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isIndependent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isIndependent",
          "normalized": "Matroid a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Independent",
          "signature": "Matroid a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isIndependent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn element e in a matroid M is a loop if {e} is a circuit of M.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isLoop",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e a -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isLoop",
          "type": "function"
        },
        "index": {
          "description": "An element in matroid is loop if is circuit of",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isLoop",
          "normalized": "Matroid a-\u003ea-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Loop",
          "signature": "Matroid a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre the given sets the bases of some matroid?\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isMatroidBases",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isMatroidBases",
          "type": "function"
        },
        "index": {
          "description": "Are the given sets the bases of some matroid",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isMatroidBases",
          "normalized": "[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Matroid Bases",
          "signature": "[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isMatroidBases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre the given sets the circuits of some matroid?\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isMatroidCircuits",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isMatroidCircuits",
          "type": "function"
        },
        "index": {
          "description": "Are the given sets the circuits of some matroid",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isMatroidCircuits",
          "normalized": "[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Matroid Circuits",
          "signature": "[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isMatroidCircuits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "isMatroidHyperplanes",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isMatroidHyperplanes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isMatroidHyperplanes",
          "normalized": "[a]-\u003e[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Matroid Hyperplanes",
          "signature": "[a]-\u003e[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isMatroidHyperplanes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre these the independent sets of a matroid? (The sets must individually be ordered.)\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isMatroidIndeps",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isMatroidIndeps",
          "type": "function"
        },
        "index": {
          "description": "Are these the independent sets of matroid The sets must individually be ordered",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isMatroidIndeps",
          "normalized": "[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Matroid Indeps",
          "signature": "[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isMatroidIndeps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre the two matroids isomorphic?\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isMatroidIso",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Matroid b -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isMatroidIso",
          "type": "function"
        },
        "index": {
          "description": "Are the two matroids isomorphic",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isMatroidIso",
          "normalized": "Matroid a-\u003eMatroid b-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Matroid Iso",
          "signature": "Matroid a-\u003eMatroid b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isMatroidIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eElements f and g in a matroid M are parallel if {f,g} is a circuit of M.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isParallel",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isParallel",
          "type": "function"
        },
        "index": {
          "description": "Elements and in matroid are parallel if is circuit of",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isParallel",
          "normalized": "Matroid a-\u003ea-\u003ea-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Parallel",
          "signature": "Matroid a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isParallel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs the matroid representable over Fq? For example, to find out whether a matroid m is binary, evaluate \u003ccode\u003eisRepresentable f2 m\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isRepresentable",
          "package": "HaskellForMaths",
          "signature": "[fq] -\u003e Matroid a -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isRepresentable",
          "type": "function"
        },
        "index": {
          "description": "Is the matroid representable over Fq For example to find out whether matroid is binary evaluate isRepresentable f2",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isRepresentable",
          "normalized": "[a]-\u003eMatroid b-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Representable",
          "signature": "[fq]-\u003eMatroid a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isRepresentable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "isShortlex",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isShortlex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isShortlex",
          "normalized": "[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Shortlex",
          "signature": "[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isShortlex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA matroid is simple if it has no loops or parallel elements\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isSimple",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isSimple",
          "type": "function"
        },
        "index": {
          "description": "matroid is simple if it has no loops or parallel elements",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isSimple",
          "normalized": "Matroid a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Simple",
          "signature": "Matroid a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isSimple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "isSimpleGeoRep",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isSimpleGeoRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isSimpleGeoRep",
          "normalized": "[[a]]-\u003e[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Simple Geo Rep",
          "signature": "[[a]]-\u003e[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isSimpleGeoRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA subset of the elements in a matroid is spanning if its closure is all the elements\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isSpanning",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isSpanning",
          "type": "function"
        },
        "index": {
          "description": "subset of the elements in matroid is spanning if its closure is all the elements",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isSpanning",
          "normalized": "Matroid a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Spanning",
          "signature": "Matroid a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isSpanning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA ternary matroid is a matroid which is representable over F3\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "isTernary",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#isTernary",
          "type": "function"
        },
        "index": {
          "description": "ternary matroid is matroid which is representable over F3",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "isTernary",
          "normalized": "Matroid a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Ternary",
          "signature": "Matroid a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:isTernary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "markNonInitialRCs",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[ZeroOneStar]]",
          "source": "src/Math-Combinatorics-Matroid.html#markNonInitialRCs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "markNonInitialRCs",
          "normalized": "[[a]]-\u003e[[ZeroOneStar]]",
          "package": "HaskellForMaths",
          "partial": "Non Initial RCs",
          "signature": "[[a]]-\u003e[[ZeroOneStar]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:markNonInitialRCs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "markedfcim",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e [[ZeroOneStar]]",
          "source": "src/Math-Combinatorics-Matroid.html#markedfcim",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "markedfcim",
          "normalized": "Matroid a-\u003e[a]-\u003e[[ZeroOneStar]]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[a]-\u003e[[ZeroOneStar]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:markedfcim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ematroidAG n fq\u003c/code\u003e returns the affine geometry AG(n,Fq), where fq is a list of the elements of Fq\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "matroidAG",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#matroidAG",
          "type": "function"
        },
        "index": {
          "description": "matroidAG fq returns the affine geometry AG Fq where fq is list of the elements of Fq",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "matroidAG",
          "normalized": "Int-\u003e[a]-\u003eMatroid Int",
          "package": "HaskellForMaths",
          "partial": "AG",
          "signature": "Int-\u003e[a]-\u003eMatroid Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:matroidAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the automorphisms of the matroid.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "matroidAuts",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [Permutation a]",
          "source": "src/Math-Combinatorics-Matroid.html#matroidAuts",
          "type": "function"
        },
        "index": {
          "description": "Return the automorphisms of the matroid",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "matroidAuts",
          "normalized": "Matroid a-\u003e[Permutation a]",
          "package": "HaskellForMaths",
          "partial": "Auts",
          "signature": "Matroid a-\u003e[Permutation a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:matroidAuts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "matroidIsos",
          "package": "HaskellForMaths",
          "signature": "Matroid t2 -\u003e Matroid t3 -\u003e [[(t2, t3)]]",
          "source": "src/Math-Combinatorics-Matroid.html#matroidIsos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "matroidIsos",
          "normalized": "Matroid a-\u003eMatroid a-\u003e[[(a,a)]]",
          "package": "HaskellForMaths",
          "partial": "Isos",
          "signature": "Matroid t-\u003eMatroid t-\u003e[[(t,t)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:matroidIsos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ematroidPG n fq\u003c/code\u003e returns the projective geometry PG(n,Fq), where fq is a list of the elements of Fq\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "matroidPG",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#matroidPG",
          "type": "function"
        },
        "index": {
          "description": "matroidPG fq returns the projective geometry PG Fq where fq is list of the elements of Fq",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "matroidPG",
          "normalized": "Int-\u003e[a]-\u003eMatroid Int",
          "package": "HaskellForMaths",
          "partial": "PG",
          "signature": "Int-\u003e[a]-\u003eMatroid Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:matroidPG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "matroidUnion",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Matroid a -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#matroidUnion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "matroidUnion",
          "normalized": "Matroid a-\u003eMatroid a-\u003eMatroid a",
          "package": "HaskellForMaths",
          "partial": "Union",
          "signature": "Matroid a-\u003eMatroid a-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:matroidUnion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "minimal",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Matroid.html#minimal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "minimal",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:minimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "minimalFlat",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a]",
          "source": "src/Math-Combinatorics-Matroid.html#minimalFlat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "minimalFlat",
          "normalized": "Matroid a-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Flat",
          "signature": "Matroid a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:minimalFlat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "mw4",
          "package": "HaskellForMaths",
          "signature": "Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#mw4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "mw4",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:mw4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRelaxation of the Pappus configuration by removal of a line\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "nonPappus",
          "package": "HaskellForMaths",
          "signature": "Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#nonPappus",
          "type": "function"
        },
        "index": {
          "description": "Relaxation of the Pappus configuration by removal of line",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "nonPappus",
          "package": "HaskellForMaths",
          "partial": "Pappus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:nonPappus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "numBases",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Integer",
          "source": "src/Math-Combinatorics-Matroid.html#numBases",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "numBases",
          "normalized": "Matroid a-\u003eInteger",
          "package": "HaskellForMaths",
          "partial": "Bases",
          "signature": "Matroid a-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:numBases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "numIndeps",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Integer",
          "source": "src/Math-Combinatorics-Matroid.html#numIndeps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "numIndeps",
          "normalized": "Matroid a-\u003eInteger",
          "package": "HaskellForMaths",
          "partial": "Indeps",
          "signature": "Matroid a-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:numIndeps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "numSpanning",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Integer",
          "source": "src/Math-Combinatorics-Matroid.html#numSpanning",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "numSpanning",
          "normalized": "Matroid a-\u003eInteger",
          "package": "HaskellForMaths",
          "partial": "Spanning",
          "signature": "Matroid a-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:numSpanning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eP8 is a minor-minimal matroid that is not representable over F4, F8, F16, ... .\n It is Fq-representable if and only if q is not a power of 2.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "p8",
          "package": "HaskellForMaths",
          "signature": "Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#p8",
          "type": "function"
        },
        "index": {
          "description": "P8 is minor-minimal matroid that is not representable over F4 F8 F16 It is Fq-representable if and only if is not power of",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "p8",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:p8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "p8'",
          "package": "HaskellForMaths",
          "signature": "Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#p8%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "p8'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:p8-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eP8- is a relaxation of P8. It is Fq-representable if and only if q \u003e= 4.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "p8m",
          "package": "HaskellForMaths",
          "signature": "Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#p8m",
          "type": "function"
        },
        "index": {
          "description": "P8 is relaxation of P8 It is Fq-representable if and only if",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "p8m",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:p8m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eP8-- is a relaxation of P8-. It is a minor-minimal matroid that is not representable over F4.\n It is Fq-representable if and only if q \u003e= 5.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "p8mm",
          "package": "HaskellForMaths",
          "signature": "Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#p8mm",
          "type": "function"
        },
        "index": {
          "description": "P8 is relaxation of P8 It is minor-minimal matroid that is not representable over F4 It is Fq-representable if and only if",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "p8mm",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:p8mm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Pappus configuration from projective geometry\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "pappus",
          "package": "HaskellForMaths",
          "signature": "Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#pappus",
          "type": "function"
        },
        "index": {
          "description": "The Pappus configuration from projective geometry",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "pappus",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:pappus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "parallelConnection",
          "package": "HaskellForMaths",
          "signature": "(Matroid a, a) -\u003e (Matroid a1, a1) -\u003e Matroid (LMR a a1)",
          "source": "src/Math-Combinatorics-Matroid.html#parallelConnection",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "parallelConnection",
          "normalized": "(Matroid a,a)-\u003e(Matroid a,a)-\u003eMatroid(LMR a a)",
          "package": "HaskellForMaths",
          "partial": "Connection",
          "signature": "(Matroid a,a)-\u003e(Matroid a,a)-\u003eMatroid(LMR a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:parallelConnection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "partialMatchings",
          "package": "HaskellForMaths",
          "signature": "[(a, a)] -\u003e [[(a, a)]]",
          "source": "src/Math-Combinatorics-Matroid.html#partialMatchings",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "partialMatchings",
          "normalized": "[(a,a)]-\u003e[[(a,a)]]",
          "package": "HaskellForMaths",
          "partial": "Matchings",
          "signature": "[(a,a)]-\u003e[[(a,a)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:partialMatchings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rank of a matroid is the cardinality of a basis\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "rank",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Int",
          "source": "src/Math-Combinatorics-Matroid.html#rank",
          "type": "function"
        },
        "index": {
          "description": "The rank of matroid is the cardinality of basis",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "rank",
          "normalized": "Matroid a-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:rank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a matroid m over elements es, the rank polynomial is a polynomial r(x,y),\n which is essentially a generating function for the subsets of es, enumerated by size and rank.\n It is efficiently calculated using deletion and contraction.\n\u003c/p\u003e\u003cp\u003eIt has the property that r(0,0) is the number of bases in m, r(1,0) is the number of independent sets,\n r(0,1) is the number of spanning sets. It can also be used to derive the chromatic polynomial of a graph,\n the weight enumerator of a linear code, and more.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "rankPoly",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e GlexPoly Integer String",
          "source": "src/Math-Combinatorics-Matroid.html#rankPoly",
          "type": "function"
        },
        "index": {
          "description": "Given matroid over elements es the rank polynomial is polynomial which is essentially generating function for the subsets of es enumerated by size and rank It is efficiently calculated using deletion and contraction It has the property that is the number of bases in is the number of independent sets is the number of spanning sets It can also be used to derive the chromatic polynomial of graph the weight enumerator of linear code and more",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "rankPoly",
          "normalized": "Matroid a-\u003eGlexPoly Integer String",
          "package": "HaskellForMaths",
          "partial": "Poly",
          "signature": "Matroid a-\u003eGlexPoly Integer String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:rankPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "rankPoly1",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e GlexPoly Integer String",
          "source": "src/Math-Combinatorics-Matroid.html#rankPoly1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "rankPoly1",
          "normalized": "Matroid a-\u003eGlexPoly Integer String",
          "package": "HaskellForMaths",
          "partial": "Poly",
          "signature": "Matroid a-\u003eGlexPoly Integer String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:rankPoly1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a matroid m, \u003ccode\u003erankfun m\u003c/code\u003e is the rank function on subsets of its element set\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "rankfun",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Int",
          "source": "src/Math-Combinatorics-Matroid.html#rankfun",
          "type": "function"
        },
        "index": {
          "description": "Given matroid rankfun is the rank function on subsets of its element set",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "rankfun",
          "normalized": "Matroid a-\u003e[a]-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[a]-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:rankfun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a matroid m, and a set of elements b which is both a circuit and a hyperplane in m,\n then \u003ccode\u003erelaxation m b\u003c/code\u003e is the matroid which is obtained by adding b as a new basis.\n This corresponds to removing b from the geometric representation of m.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "relaxation",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#relaxation",
          "type": "function"
        },
        "index": {
          "description": "Given matroid and set of elements which is both circuit and hyperplane in then relaxation is the matroid which is obtained by adding as new basis This corresponds to removing from the geometric representation of",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "relaxation",
          "normalized": "Matroid a-\u003e[a]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[a]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:relaxation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind representations of the matroid m over fq. Specifically, this function will find one representative\n of each projective equivalence class of representation.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "representations",
          "package": "HaskellForMaths",
          "signature": "[fq] -\u003e Matroid a -\u003e [[[fq]]]",
          "source": "src/Math-Combinatorics-Matroid.html#representations",
          "type": "function"
        },
        "index": {
          "description": "Find representations of the matroid over fq Specifically this function will find one representative of each projective equivalence class of representation",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "representations",
          "normalized": "[a]-\u003eMatroid b-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "signature": "[fq]-\u003eMatroid a-\u003e[[[fq]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:representations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "representations1",
          "package": "HaskellForMaths",
          "signature": "[a1] -\u003e Matroid a -\u003e [[[a1]]]",
          "source": "src/Math-Combinatorics-Matroid.html#representations1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "representations1",
          "normalized": "[a]-\u003eMatroid a-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eMatroid a-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:representations1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "representations2",
          "package": "HaskellForMaths",
          "signature": "[a1] -\u003e Matroid a -\u003e [[[a1]]]",
          "source": "src/Math-Combinatorics-Matroid.html#representations2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "representations2",
          "normalized": "[a]-\u003eMatroid a-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eMatroid a-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:representations2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe restriction of a matroid to a subset of its elements\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "restriction",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#restriction",
          "type": "function"
        },
        "index": {
          "description": "The restriction of matroid to subset of its elements",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "restriction",
          "normalized": "Matroid a-\u003e[a]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[a]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:restriction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "restriction1",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [a] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#restriction1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "restriction1",
          "normalized": "Matroid a-\u003e[a]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[a]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:restriction1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "seriesConnection",
          "package": "HaskellForMaths",
          "signature": "(Matroid a, a) -\u003e (Matroid a1, a1) -\u003e Matroid (LMR a a1)",
          "source": "src/Math-Combinatorics-Matroid.html#seriesConnection",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "seriesConnection",
          "normalized": "(Matroid a,a)-\u003e(Matroid a,a)-\u003eMatroid(LMR a a)",
          "package": "HaskellForMaths",
          "partial": "Connection",
          "signature": "(Matroid a,a)-\u003e(Matroid a,a)-\u003eMatroid(LMR a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:seriesConnection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "shortlex",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e Ordering",
          "source": "src/Math-Combinatorics-Matroid.html#shortlex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "shortlex",
          "normalized": "[a]-\u003e[a]-\u003eOrdering",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:shortlex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA simple matroid has no loops or parallel elements, hence its geometric representation has no loops or dependent points.\n \u003ccode\u003esimpleFromGeoRep lines planes\u003c/code\u003e returns the simple matroid having these dependent flats.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "simpleFromGeoRep",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#simpleFromGeoRep",
          "type": "function"
        },
        "index": {
          "description": "simple matroid has no loops or parallel elements hence its geometric representation has no loops or dependent points simpleFromGeoRep lines planes returns the simple matroid having these dependent flats",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "simpleFromGeoRep",
          "normalized": "[[a]]-\u003e[[a]]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "partial": "From Geo Rep",
          "signature": "[[a]]-\u003e[[a]]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:simpleFromGeoRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "starSubstitutionsV",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [ZeroOneStar] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Matroid.html#starSubstitutionsV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "starSubstitutionsV",
          "normalized": "[a]-\u003e[ZeroOneStar]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Substitutions",
          "signature": "[a]-\u003e[ZeroOneStar]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:starSubstitutionsV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "substStars",
          "package": "HaskellForMaths",
          "signature": "[[ZeroOneStar]] -\u003e [a] -\u003e [[[a]]]",
          "source": "src/Math-Combinatorics-Matroid.html#substStars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "substStars",
          "normalized": "[[ZeroOneStar]]-\u003e[a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "Stars",
          "signature": "[[ZeroOneStar]]-\u003e[a]-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:substStars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a matroid over an arbitrary type, relabel to obtain a matroid over the integers.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "to1n",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#to1n",
          "type": "function"
        },
        "index": {
          "description": "Given matroid over an arbitrary type relabel to obtain matroid over the integers",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "to1n",
          "normalized": "Matroid a-\u003eMatroid Int",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003eMatroid Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:to1n"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "toShortlex",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Matroid.html#toShortlex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "toShortlex",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Shortlex",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:toShortlex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "transversalGraph",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [(Either a b, Either a1 b1)]",
          "source": "src/Math-Combinatorics-Matroid.html#transversalGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "transversalGraph",
          "normalized": "[[a]]-\u003e[(Either a b,Either a b)]",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "[[a]]-\u003e[(Either a b,Either a b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:transversalGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a set of elements es, and a sequence as = [a1,...,am] of subsets of es,\n return the matroid whose independent sets are the partial transversals of the as.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "transversalMatroid",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]] -\u003e Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#transversalMatroid",
          "type": "function"
        },
        "index": {
          "description": "Given set of elements es and sequence as a1 am of subsets of es return the matroid whose independent sets are the partial transversals of the as",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "transversalMatroid",
          "normalized": "[a]-\u003e[[a]]-\u003eMatroid a",
          "package": "HaskellForMaths",
          "partial": "Matroid",
          "signature": "[a]-\u003e[[a]]-\u003eMatroid a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:transversalMatroid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "tsempty",
          "package": "HaskellForMaths",
          "signature": "TrieSet a",
          "source": "src/Math-Combinatorics-Matroid.html#tsempty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "tsempty",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:tsempty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "tsfromlist",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e TrieSet a",
          "source": "src/Math-Combinatorics-Matroid.html#tsfromlist",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "tsfromlist",
          "normalized": "[[a]]-\u003eTrieSet a",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003eTrieSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:tsfromlist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "tsinsert",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e TrieSet a -\u003e TrieSet a",
          "source": "src/Math-Combinatorics-Matroid.html#tsinsert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "tsinsert",
          "normalized": "[a]-\u003eTrieSet a-\u003eTrieSet a",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eTrieSet a-\u003eTrieSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:tsinsert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "tsmember",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e TrieSet a -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#tsmember",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "tsmember",
          "normalized": "[a]-\u003eTrieSet a-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eTrieSet a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:tsmember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "tsshow",
          "package": "HaskellForMaths",
          "signature": "TrieSet a -\u003e [Char]",
          "source": "src/Math-Combinatorics-Matroid.html#tsshow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "tsshow",
          "normalized": "TrieSet a-\u003e[Char]",
          "package": "HaskellForMaths",
          "signature": "TrieSet a-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:tsshow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "tssubmember",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e TrieSet a -\u003e Bool",
          "source": "src/Math-Combinatorics-Matroid.html#tssubmember",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "tssubmember",
          "normalized": "[a]-\u003eTrieSet a-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eTrieSet a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:tssubmember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "tstolist",
          "package": "HaskellForMaths",
          "signature": "TrieSet a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Matroid.html#tstolist",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "tstolist",
          "normalized": "TrieSet a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "TrieSet a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:tstolist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "twoSum",
          "package": "HaskellForMaths",
          "signature": "(Matroid a, a) -\u003e (Matroid a1, a1) -\u003e Matroid (LMR a a1)",
          "source": "src/Math-Combinatorics-Matroid.html#twoSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "twoSum",
          "normalized": "(Matroid a,a)-\u003e(Matroid a,a)-\u003eMatroid(LMR a a)",
          "package": "HaskellForMaths",
          "partial": "Sum",
          "signature": "(Matroid a,a)-\u003e(Matroid a,a)-\u003eMatroid(LMR a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:twoSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe uniform matroid U m n is the matroid whose independent sets are all subsets of [1..n] with m or fewer elements.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "u",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Int -\u003e Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#u",
          "type": "function"
        },
        "index": {
          "description": "The uniform matroid is the matroid whose independent sets are all subsets of with or fewer elements",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "u",
          "normalized": "Int-\u003eInt-\u003eMatroid Int",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eInt-\u003eMatroid Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:u"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "uniformMatroid",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Int -\u003e Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#uniformMatroid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "uniformMatroid",
          "normalized": "Int-\u003eInt-\u003eMatroid Int",
          "package": "HaskellForMaths",
          "partial": "Matroid",
          "signature": "Int-\u003eInt-\u003eMatroid Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:uniformMatroid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "unique",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e t",
          "source": "src/Math-Combinatorics-Matroid.html#unique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "unique",
          "normalized": "[a]-\u003ea",
          "package": "HaskellForMaths",
          "signature": "[t]-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:unique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Vamos matroid V8. It is not representable over any field.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "v8",
          "package": "HaskellForMaths",
          "signature": "Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#v8",
          "type": "function"
        },
        "index": {
          "description": "The Vamos matroid V8 It is not representable over any field",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "v8",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:v8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "vamosMatroid",
          "package": "HaskellForMaths",
          "signature": "Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#vamosMatroid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "vamosMatroid",
          "package": "HaskellForMaths",
          "partial": "Matroid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:vamosMatroid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "vamosMatroid1",
          "package": "HaskellForMaths",
          "signature": "Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#vamosMatroid1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "vamosMatroid1",
          "package": "HaskellForMaths",
          "partial": "Matroid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:vamosMatroid1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a matrix, represented as a list of rows, number the columns [1..],\n and construct the matroid whose independent sets correspond to those sets of columns which are linearly independent\n (or in case there are repetitions, those multisets of columns which are sets, and which are linearly independent).\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "vectorMatroid",
          "package": "HaskellForMaths",
          "signature": "[[k]] -\u003e Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#vectorMatroid",
          "type": "function"
        },
        "index": {
          "description": "Given matrix represented as list of rows number the columns and construct the matroid whose independent sets correspond to those sets of columns which are linearly independent or in case there are repetitions those multisets of columns which are sets and which are linearly independent",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "vectorMatroid",
          "normalized": "[[a]]-\u003eMatroid Int",
          "package": "HaskellForMaths",
          "partial": "Matroid",
          "signature": "[[k]]-\u003eMatroid Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:vectorMatroid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list of vectors (or rows of a matrix), number the vectors (rows) [1..], and construct the matroid whose independent sets\n correspond to those sets of vectors (rows) which are linearly independent\n (or in case there are repetitions, those multisets which are sets, and which are linearly independent).\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Matroid",
          "name": "vectorMatroid'",
          "package": "HaskellForMaths",
          "signature": "[[k]] -\u003e Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#vectorMatroid%27",
          "type": "function"
        },
        "index": {
          "description": "Given list of vectors or rows of matrix number the vectors rows and construct the matroid whose independent sets correspond to those sets of vectors rows which are linearly independent or in case there are repetitions those multisets which are sets and which are linearly independent",
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "vectorMatroid'",
          "normalized": "[[a]]-\u003eMatroid Int",
          "package": "HaskellForMaths",
          "partial": "Matroid'",
          "signature": "[[k]]-\u003eMatroid Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:vectorMatroid-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "w4",
          "package": "HaskellForMaths",
          "signature": "Matroid a",
          "source": "src/Math-Combinatorics-Matroid.html#w4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "w4",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:w4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "w4'",
          "package": "HaskellForMaths",
          "signature": "Matroid Int",
          "source": "src/Math-Combinatorics-Matroid.html#w4%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "w4'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:w4-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "wheelGraph",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Graph a",
          "source": "src/Math-Combinatorics-Matroid.html#wheelGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "wheelGraph",
          "normalized": "a-\u003eGraph a",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "a-\u003eGraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:wheelGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "whitney1st",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [Int]",
          "source": "src/Math-Combinatorics-Matroid.html#whitney1st",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "whitney1st",
          "normalized": "Matroid a-\u003e[Int]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:whitney1st"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "whitney2nd",
          "package": "HaskellForMaths",
          "signature": "Matroid a -\u003e [Int]",
          "source": "src/Math-Combinatorics-Matroid.html#whitney2nd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "whitney2nd",
          "normalized": "Matroid a-\u003e[Int]",
          "package": "HaskellForMaths",
          "signature": "Matroid a-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:whitney2nd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Matroid",
          "name": "x",
          "package": "HaskellForMaths",
          "signature": "GlexPoly Integer String",
          "source": "src/Math-Combinatorics-Matroid.html#x",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Matroid",
          "module": "Math.Combinatorics.Matroid",
          "name": "x",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Matroid.html#v:x"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "Poset",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-Poset.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "Poset",
          "package": "HaskellForMaths",
          "partial": "Poset",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA poset is represented as a pair (set,po), where set is the underlying set of the poset, and po is the partial order relation\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "Poset",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-Poset.html#Poset",
          "type": "newtype"
        },
        "index": {
          "description": "poset is represented as pair set po where set is the underlying set of the poset and po is the partial order relation",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "Poset",
          "package": "HaskellForMaths",
          "partial": "Poset",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#t:Poset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "Poset",
          "package": "HaskellForMaths",
          "signature": "Poset ([t], t -\u003e t -\u003e Bool)",
          "source": "src/Math-Combinatorics-Poset.html#Poset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "Poset",
          "normalized": "Poset([a],a-\u003ea-\u003eBool)",
          "package": "HaskellForMaths",
          "partial": "Poset",
          "signature": "Poset([t],t-\u003et-\u003eBool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:Poset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn antichain is a poset in which distinct elements are incomparable.\n antichainN n is the poset consisting of [1..n], with x \u003c= y only when x == y.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "antichainN",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Poset Int",
          "source": "src/Math-Combinatorics-Poset.html#antichainN",
          "type": "function"
        },
        "index": {
          "description": "An antichain is poset in which distinct elements are incomparable antichainN is the poset consisting of with only when",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "antichainN",
          "normalized": "Int-\u003ePoset Int",
          "package": "HaskellForMaths",
          "signature": "Int-\u003ePoset Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:antichainN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA chain is a poset in which every pair of elements is comparable (ie either x \u003c= y or y \u003c= x).\n It is therefore a linear or total order.\n chainN n is the poset consisting of the numbers [1..n] ordered by (\u003c=)\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "chainN",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Poset Int",
          "source": "src/Math-Combinatorics-Poset.html#chainN",
          "type": "function"
        },
        "index": {
          "description": "chain is poset in which every pair of elements is comparable ie either or It is therefore linear or total order chainN is the poset consisting of the numbers ordered by",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "chainN",
          "normalized": "Int-\u003ePoset Int",
          "package": "HaskellForMaths",
          "signature": "Int-\u003ePoset Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:chainN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "divides",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Math-Combinatorics-Poset.html#divides",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "divides",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:divides"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "divisors",
          "package": "HaskellForMaths",
          "signature": "t -\u003e [t]",
          "source": "src/Math-Combinatorics-Poset.html#divisors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "divisors",
          "normalized": "a-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "t-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:divisors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe direct product of two posets\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "dprod",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Poset b -\u003e Poset (a, b)",
          "source": "src/Math-Combinatorics-Poset.html#dprod",
          "type": "function"
        },
        "index": {
          "description": "The direct product of two posets",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "dprod",
          "normalized": "Poset a-\u003ePoset b-\u003ePoset(a,b)",
          "package": "HaskellForMaths",
          "signature": "Poset a-\u003ePoset b-\u003ePoset(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:dprod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe direct sum of two posets\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "dsum",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Poset b -\u003e Poset (Either a b)",
          "source": "src/Math-Combinatorics-Poset.html#dsum",
          "type": "function"
        },
        "index": {
          "description": "The direct sum of two posets",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "dsum",
          "normalized": "Poset a-\u003ePoset b-\u003ePoset(Either a b)",
          "package": "HaskellForMaths",
          "signature": "Poset a-\u003ePoset b-\u003ePoset(Either a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:dsum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe dual of a poset\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "dual",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Poset a",
          "source": "src/Math-Combinatorics-Poset.html#dual",
          "type": "function"
        },
        "index": {
          "description": "The dual of poset",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "dual",
          "normalized": "Poset a-\u003ePoset a",
          "package": "HaskellForMaths",
          "signature": "Poset a-\u003ePoset a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:dual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a poset (X,\u003c=), we say that y covers x, written x -\u003c y, if x \u003c y and there is no z in X with x \u003c z \u003c y.\n The Hasse digraph of a poset is the digraph whose vertices are the elements of the poset,\n with an edge between every pair (x,y) with x -\u003c y.\n The Hasse digraph can be represented diagrammatically as a Hasse diagram, by drawing x below y whenever x -\u003c y.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "hasseDigraph",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Digraph a",
          "source": "src/Math-Combinatorics-Poset.html#hasseDigraph",
          "type": "function"
        },
        "index": {
          "description": "Given poset we say that covers written if and there is no in with The Hasse digraph of poset is the digraph whose vertices are the elements of the poset with an edge between every pair with The Hasse digraph can be represented diagrammatically as Hasse diagram by drawing below whenever",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "hasseDigraph",
          "normalized": "Poset a-\u003eDigraph a",
          "package": "HaskellForMaths",
          "partial": "Digraph",
          "signature": "Poset a-\u003eDigraph a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:hasseDigraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "implies",
          "package": "HaskellForMaths",
          "signature": "Bool -\u003e Bool -\u003e Bool",
          "source": "src/Math-Combinatorics-Poset.html#implies",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "implies",
          "normalized": "Bool-\u003eBool-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "Bool-\u003eBool-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:implies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "integerPartitions",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Poset.html#integerPartitions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "integerPartitions",
          "normalized": "a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Partitions",
          "signature": "a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:integerPartitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "integerPartitions1",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Poset.html#integerPartitions1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "integerPartitions1",
          "normalized": "a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Partitions",
          "signature": "a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:integerPartitions1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "interval",
          "package": "HaskellForMaths",
          "signature": "Poset t -\u003e (t, t) -\u003e [t]",
          "source": "src/Math-Combinatorics-Poset.html#interval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "interval",
          "normalized": "Poset a-\u003e(a,a)-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "Poset t-\u003e(t,t)-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "intervalPartitions",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[[a]]]",
          "source": "src/Math-Combinatorics-Poset.html#intervalPartitions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "intervalPartitions",
          "normalized": "[a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "Partitions",
          "signature": "[a]-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:intervalPartitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "intervalPartitions2",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e [[[t]]]",
          "source": "src/Math-Combinatorics-Poset.html#intervalPartitions2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "intervalPartitions2",
          "normalized": "[a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "Partitions",
          "signature": "[t]-\u003e[[[t]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:intervalPartitions2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "intervals",
          "package": "HaskellForMaths",
          "signature": "Poset t -\u003e [(t, t)]",
          "source": "src/Math-Combinatorics-Poset.html#intervals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "intervals",
          "normalized": "Poset a-\u003e[(a,a)]",
          "package": "HaskellForMaths",
          "signature": "Poset t-\u003e[(t,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:intervals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "isAntisymmetric",
          "package": "HaskellForMaths",
          "signature": "([a], a -\u003e a -\u003e Bool) -\u003e Bool",
          "source": "src/Math-Combinatorics-Poset.html#isAntisymmetric",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "isAntisymmetric",
          "normalized": "([a],a-\u003ea-\u003eBool)-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Antisymmetric",
          "signature": "([a],a-\u003ea-\u003eBool)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:isAntisymmetric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "isIPRefinement",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Poset.html#isIPRefinement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "isIPRefinement",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "IPRefinement",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:isIPRefinement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "isInterval",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Bool",
          "source": "src/Math-Combinatorics-Poset.html#isInterval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "isInterval",
          "normalized": "[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Interval",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:isInterval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA linear extension of a poset is a linear ordering of the elements which extends the partial order.\n Equivalently, it is an ordering [x1..xn] of the underlying set, such that if xi \u003c= xj then i \u003c= j.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "isLinext",
          "package": "HaskellForMaths",
          "signature": "Poset t -\u003e [t] -\u003e Bool",
          "source": "src/Math-Combinatorics-Poset.html#isLinext",
          "type": "function"
        },
        "index": {
          "description": "linear extension of poset is linear ordering of the elements which extends the partial order Equivalently it is an ordering x1..xn of the underlying set such that if xi xj then",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "isLinext",
          "normalized": "Poset a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Linext",
          "signature": "Poset t-\u003e[t]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:isLinext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre the two posets order-isomorphic?\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "isOrderIso",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Poset b -\u003e Bool",
          "source": "src/Math-Combinatorics-Poset.html#isOrderIso",
          "type": "function"
        },
        "index": {
          "description": "Are the two posets order-isomorphic",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "isOrderIso",
          "normalized": "Poset a-\u003ePoset b-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Order Iso",
          "signature": "Poset a-\u003ePoset b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:isOrderIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "isOrderPreserving",
          "package": "HaskellForMaths",
          "signature": "(a -\u003e b) -\u003e Poset a -\u003e Poset b -\u003e Bool",
          "source": "src/Math-Combinatorics-Poset.html#isOrderPreserving",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "isOrderPreserving",
          "normalized": "(a-\u003eb)-\u003ePoset a-\u003ePoset b-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Order Preserving",
          "signature": "(a-\u003eb)-\u003ePoset a-\u003ePoset b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:isOrderPreserving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "isPoset",
          "package": "HaskellForMaths",
          "signature": "([t], t -\u003e t -\u003e Bool) -\u003e Bool",
          "source": "src/Math-Combinatorics-Poset.html#isPoset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "isPoset",
          "normalized": "([a],a-\u003ea-\u003eBool)-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Poset",
          "signature": "([t],t-\u003et-\u003eBool)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:isPoset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "isRefinement",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]] -\u003e Bool",
          "source": "src/Math-Combinatorics-Poset.html#isRefinement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "isRefinement",
          "normalized": "[[a]]-\u003e[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Refinement",
          "signature": "[[a]]-\u003e[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:isRefinement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "isReflexive",
          "package": "HaskellForMaths",
          "signature": "([t], t -\u003e t -\u003e Bool) -\u003e Bool",
          "source": "src/Math-Combinatorics-Poset.html#isReflexive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "isReflexive",
          "normalized": "([a],a-\u003ea-\u003eBool)-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Reflexive",
          "signature": "([t],t-\u003et-\u003eBool)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:isReflexive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "isSubspace",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]] -\u003e Bool",
          "source": "src/Math-Combinatorics-Poset.html#isSubspace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "isSubspace",
          "normalized": "[[a]]-\u003e[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Subspace",
          "signature": "[[a]]-\u003e[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:isSubspace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "isTransitive",
          "package": "HaskellForMaths",
          "signature": "([t], t -\u003e t -\u003e Bool) -\u003e Bool",
          "source": "src/Math-Combinatorics-Poset.html#isTransitive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "isTransitive",
          "normalized": "([a],a-\u003ea-\u003eBool)-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Transitive",
          "signature": "([t],t-\u003et-\u003eBool)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:isTransitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLinear extensions of a poset\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "linexts",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Poset.html#linexts",
          "type": "function"
        },
        "index": {
          "description": "Linear extensions of poset",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "linexts",
          "normalized": "Poset a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "Poset a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:linexts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "orderAuts1",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e [[(a, a)]]",
          "source": "src/Math-Combinatorics-Poset.html#orderAuts1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "orderAuts1",
          "normalized": "Poset a-\u003e[[(a,a)]]",
          "package": "HaskellForMaths",
          "partial": "Auts",
          "signature": "Poset a-\u003e[[(a,a)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:orderAuts1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "orderIsos",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Poset a1 -\u003e [[(a, a1)]]",
          "source": "src/Math-Combinatorics-Poset.html#orderIsos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "orderIsos",
          "normalized": "Poset a-\u003ePoset a-\u003e[[(a,a)]]",
          "package": "HaskellForMaths",
          "partial": "Isos",
          "signature": "Poset a-\u003ePoset a-\u003e[[(a,a)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:orderIsos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "orderIsos01",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e Poset a1 -\u003e [[(a, a1)]]",
          "source": "src/Math-Combinatorics-Poset.html#orderIsos01",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "orderIsos01",
          "normalized": "Poset a-\u003ePoset a-\u003e[[(a,a)]]",
          "package": "HaskellForMaths",
          "partial": "Isos",
          "signature": "Poset a-\u003ePoset a-\u003e[[(a,a)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:orderIsos01"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "partitions",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e [[[t]]]",
          "source": "src/Math-Combinatorics-Poset.html#partitions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "partitions",
          "normalized": "[a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "signature": "[t]-\u003e[[[t]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:partitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "poset",
          "package": "HaskellForMaths",
          "signature": "([t], t -\u003e t -\u003e Bool) -\u003e Poset t",
          "source": "src/Math-Combinatorics-Poset.html#poset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "poset",
          "normalized": "([a],a-\u003ea-\u003eBool)-\u003ePoset a",
          "package": "HaskellForMaths",
          "signature": "([t],t-\u003et-\u003eBool)-\u003ePoset t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:poset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eposetB n is the lattice of subsets of [1..n] ordered by inclusion\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "posetB",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Poset [Int]",
          "source": "src/Math-Combinatorics-Poset.html#posetB",
          "type": "function"
        },
        "index": {
          "description": "posetB is the lattice of subsets of ordered by inclusion",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "posetB",
          "normalized": "Int-\u003ePoset[Int]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003ePoset[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:posetB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eposetD n is the lattice of (positive) divisors of n\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "posetD",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Poset Int",
          "source": "src/Math-Combinatorics-Poset.html#posetD",
          "type": "function"
        },
        "index": {
          "description": "posetD is the lattice of positive divisors of",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "posetD",
          "normalized": "Int-\u003ePoset Int",
          "package": "HaskellForMaths",
          "signature": "Int-\u003ePoset Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:posetD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eposetIP n is the poset of integer partitions of n, ordered by refinement\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "posetIP",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Poset [Int]",
          "source": "src/Math-Combinatorics-Poset.html#posetIP",
          "type": "function"
        },
        "index": {
          "description": "posetIP is the poset of integer partitions of ordered by refinement",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "posetIP",
          "normalized": "Int-\u003ePoset[Int]",
          "package": "HaskellForMaths",
          "partial": "IP",
          "signature": "Int-\u003ePoset[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:posetIP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eposetL n fq is the lattice of subspaces of the vector space Fq^n, ordered by inclusion.\n Subspaces are represented by their reduced row echelon form.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "posetL",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [fq] -\u003e Poset [[fq]]",
          "source": "src/Math-Combinatorics-Poset.html#posetL",
          "type": "function"
        },
        "index": {
          "description": "posetL fq is the lattice of subspaces of the vector space Fq ordered by inclusion Subspaces are represented by their reduced row echelon form",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "posetL",
          "normalized": "Int-\u003e[a]-\u003ePoset[[a]]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[fq]-\u003ePoset[[fq]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:posetL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eposetP n is the lattice of set partitions of [1..n], ordered by refinement\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "posetP",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Poset [[Int]]",
          "source": "src/Math-Combinatorics-Poset.html#posetP",
          "type": "function"
        },
        "index": {
          "description": "posetP is the lattice of set partitions of ordered by refinement",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "posetP",
          "normalized": "Int-\u003ePoset[[Int]]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003ePoset[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:posetP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "powerset",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Math-Combinatorics-Poset.html#powerset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "powerset",
          "normalized": "[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:powerset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a DAG (directed acyclic graph), return the poset consisting of the vertices of the DAG, ordered by reachability.\n This can be used to recover a poset from its Hasse digraph.\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "reachabilityPoset",
          "package": "HaskellForMaths",
          "signature": "Digraph a -\u003e Poset a",
          "source": "src/Math-Combinatorics-Poset.html#reachabilityPoset",
          "type": "function"
        },
        "index": {
          "description": "Given DAG directed acyclic graph return the poset consisting of the vertices of the DAG ordered by reachability This can be used to recover poset from its Hasse digraph",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "reachabilityPoset",
          "normalized": "Digraph a-\u003ePoset a",
          "package": "HaskellForMaths",
          "partial": "Poset",
          "signature": "Digraph a-\u003ePoset a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:reachabilityPoset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe subposet of a poset satisfying a predicate\n\u003c/p\u003e",
          "module": "Math.Combinatorics.Poset",
          "name": "subposet",
          "package": "HaskellForMaths",
          "signature": "Poset a -\u003e (a -\u003e Bool) -\u003e Poset a",
          "source": "src/Math-Combinatorics-Poset.html#subposet",
          "type": "function"
        },
        "index": {
          "description": "The subposet of poset satisfying predicate",
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "subposet",
          "normalized": "Poset a-\u003e(a-\u003eBool)-\u003ePoset a",
          "package": "HaskellForMaths",
          "signature": "Poset a-\u003e(a-\u003eBool)-\u003ePoset a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:subposet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.Poset",
          "name": "subspaces",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Int -\u003e [[[a]]]",
          "source": "src/Math-Combinatorics-Poset.html#subspaces",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics Poset",
          "module": "Math.Combinatorics.Poset",
          "name": "subspaces",
          "normalized": "[a]-\u003eInt-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eInt-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-Poset.html#v:subspaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining various strongly regular graphs, including the Clebsch, Hoffman-Singleton, Higman-Sims, and McLaughlin graphs.\n\u003c/p\u003e\u003cp\u003eA strongly regular graph with parameters (n,k,lambda,mu) is a (simple) graph with n vertices,\n in which the number of common neighbours of x and y is k, lambda or mu according as whether\n x and y are equal, adjacent, or non-adjacent. (In particular, it is a k-regular graph.)\n\u003c/p\u003e\u003cp\u003eStrongly regular graphs are highly symmetric, and have large automorphism groups.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "StronglyRegularGraph",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html",
          "type": "module"
        },
        "index": {
          "description": "module defining various strongly regular graphs including the Clebsch Hoffman-Singleton Higman-Sims and McLaughlin graphs strongly regular graph with parameters lambda mu is simple graph with vertices in which the number of common neighbours of and is lambda or mu according as whether and are equal adjacent or non-adjacent In particular it is k-regular graph Strongly regular graphs are highly symmetric and have large automorphism groups",
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "StronglyRegularGraph",
          "package": "HaskellForMaths",
          "partial": "Strongly Regular Graph",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "DesignVertex",
          "package": "HaskellForMaths",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#DesignVertex",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "DesignVertex",
          "package": "HaskellForMaths",
          "partial": "Design Vertex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#t:DesignVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "(+^)",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e Permutation a -\u003e [[a]]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#%2B%5E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "(+^) +^",
          "normalized": "[[a]]-\u003ePermutation a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003ePermutation a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:-43--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "(+^^)",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [Permutation a] -\u003e [[[a]]]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#%2B%5E%5E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "(+^^) +^^",
          "normalized": "[[a]]-\u003e[Permutation a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003e[Permutation a]-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:-43--94--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "B",
          "package": "HaskellForMaths",
          "signature": "B [Integer]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#DesignVertex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "B",
          "normalized": "B[Integer]",
          "package": "HaskellForMaths",
          "signature": "B[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:B"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "C",
          "package": "HaskellForMaths",
          "signature": "C",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#DesignVertex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "C",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "P",
          "package": "HaskellForMaths",
          "signature": "P Integer",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#DesignVertex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "P",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "_HS",
          "package": "HaskellForMaths",
          "signature": "[Permutation DesignVertex]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#_HS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "_HS",
          "normalized": "[Permutation DesignVertex]",
          "package": "HaskellForMaths",
          "partial": "HS",
          "signature": "[Permutation DesignVertex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:_HS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "_HS2",
          "package": "HaskellForMaths",
          "signature": "[Permutation DesignVertex]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#_HS2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "_HS2",
          "normalized": "[Permutation DesignVertex]",
          "package": "HaskellForMaths",
          "partial": "HS",
          "signature": "[Permutation DesignVertex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:_HS2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "_McL",
          "package": "HaskellForMaths",
          "signature": "[Permutation DesignVertex]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#_McL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "_McL",
          "normalized": "[Permutation DesignVertex]",
          "package": "HaskellForMaths",
          "partial": "Mc",
          "signature": "[Permutation DesignVertex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:_McL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "_McL2",
          "package": "HaskellForMaths",
          "signature": "[Permutation DesignVertex]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#_McL2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "_McL2",
          "normalized": "[Permutation DesignVertex]",
          "package": "HaskellForMaths",
          "partial": "Mc",
          "signature": "[Permutation DesignVertex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:_McL2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "clebsch",
          "package": "HaskellForMaths",
          "signature": "Graph [Integer]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#clebsch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "clebsch",
          "normalized": "Graph[Integer]",
          "package": "HaskellForMaths",
          "signature": "Graph[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:clebsch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "clebsch'",
          "package": "HaskellForMaths",
          "signature": "Graph Integer",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#clebsch%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "clebsch'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:clebsch-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "clebsch2",
          "package": "HaskellForMaths",
          "signature": "Graph DesignVertex",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#clebsch2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "clebsch2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:clebsch2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "gewirtz",
          "package": "HaskellForMaths",
          "signature": "Graph [Integer]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#gewirtz",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "gewirtz",
          "normalized": "Graph[Integer]",
          "package": "HaskellForMaths",
          "signature": "Graph[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:gewirtz"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "gewirtz'",
          "package": "HaskellForMaths",
          "signature": "Graph Integer",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#gewirtz%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "gewirtz'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:gewirtz-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "heptads",
          "package": "HaskellForMaths",
          "signature": "[[[Integer]]]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#heptads",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "heptads",
          "normalized": "[[[Integer]]]",
          "package": "HaskellForMaths",
          "signature": "[[[Integer]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:heptads"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "higmanSimsGraph",
          "package": "HaskellForMaths",
          "signature": "Graph DesignVertex",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#higmanSimsGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "higmanSimsGraph",
          "package": "HaskellForMaths",
          "partial": "Sims Graph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:higmanSimsGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "higmanSimsGraph'",
          "package": "HaskellForMaths",
          "signature": "Graph Integer",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#higmanSimsGraph%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "higmanSimsGraph'",
          "package": "HaskellForMaths",
          "partial": "Sims Graph'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:higmanSimsGraph-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "higmanSimsM22",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#higmanSimsM22",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "higmanSimsM22",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "partial": "Sims",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:higmanSimsM22"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "hoffmanSingleton",
          "package": "HaskellForMaths",
          "signature": "Graph (Either [[Integer]] [Integer])",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#hoffmanSingleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "hoffmanSingleton",
          "normalized": "Graph(Either[[Integer]][Integer])",
          "package": "HaskellForMaths",
          "partial": "Singleton",
          "signature": "Graph(Either[[Integer]][Integer])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:hoffmanSingleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "hoffmanSingleton'",
          "package": "HaskellForMaths",
          "signature": "Graph Integer",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#hoffmanSingleton%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "hoffmanSingleton'",
          "package": "HaskellForMaths",
          "partial": "Singleton'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:hoffmanSingleton-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "hsA7",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#hsA7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "hsA7",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:hsA7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "inducedA7",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer -\u003e Permutation (Either [[Integer]] [Integer])",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#inducedA7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "inducedA7",
          "normalized": "Permutation Integer-\u003ePermutation(Either[[Integer]][Integer])",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer-\u003ePermutation(Either[[Integer]][Integer])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:inducedA7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "inducedM22",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer -\u003e Permutation DesignVertex",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#inducedM22",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "inducedM22",
          "normalized": "Permutation Integer-\u003ePermutation DesignVertex",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer-\u003ePermutation DesignVertex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:inducedM22"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "isSRG",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e Bool",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#isSRG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "isSRG",
          "normalized": "Graph a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "SRG",
          "signature": "Graph a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:isSRG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "l2",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Graph (a, a)",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#l2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "l2",
          "normalized": "a-\u003eGraph(a,a)",
          "package": "HaskellForMaths",
          "signature": "a-\u003eGraph(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:l2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "l2'",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Graph t",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#l2%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "l2'",
          "normalized": "a-\u003eGraph b",
          "package": "HaskellForMaths",
          "signature": "a-\u003eGraph t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:l2-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "mcLaughlin",
          "package": "HaskellForMaths",
          "signature": "Graph DesignVertex",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#mcLaughlin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "mcLaughlin",
          "package": "HaskellForMaths",
          "partial": "Laughlin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:mcLaughlin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "mcLaughlin'",
          "package": "HaskellForMaths",
          "signature": "Graph Integer",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#mcLaughlin%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "mcLaughlin'",
          "package": "HaskellForMaths",
          "partial": "Laughlin'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:mcLaughlin-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "paleyGraph",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e Graph t",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#paleyGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "paleyGraph",
          "normalized": "[a]-\u003eGraph a",
          "package": "HaskellForMaths",
          "partial": "Graph",
          "signature": "[t]-\u003eGraph t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:paleyGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "schlafli",
          "package": "HaskellForMaths",
          "signature": "Graph Integer",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#schlafli",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "schlafli",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:schlafli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "schlafli'",
          "package": "HaskellForMaths",
          "signature": "Graph Integer",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#schlafli%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "schlafli'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:schlafli-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "sp",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Graph [F2]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#sp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "sp",
          "normalized": "Int-\u003eGraph[F]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eGraph[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:sp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "sp2",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Graph [F2]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#sp2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "sp2",
          "normalized": "Int-\u003eGraph[F]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eGraph[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:sp2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "srgParams",
          "package": "HaskellForMaths",
          "signature": "Graph a -\u003e Maybe (Int, Int, Int, Int)",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#srgParams",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "srgParams",
          "normalized": "Graph a-\u003eMaybe(Int,Int,Int,Int)",
          "package": "HaskellForMaths",
          "partial": "Params",
          "signature": "Graph a-\u003eMaybe(Int,Int,Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:srgParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "switch",
          "package": "HaskellForMaths",
          "signature": "Graph t -\u003e [t] -\u003e Graph t",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#switch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "switch",
          "normalized": "Graph a-\u003e[a]-\u003eGraph a",
          "package": "HaskellForMaths",
          "signature": "Graph t-\u003e[t]-\u003eGraph t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:switch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "t",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Graph [a]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#t",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "t",
          "normalized": "a-\u003eGraph[a]",
          "package": "HaskellForMaths",
          "signature": "a-\u003eGraph[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "t'",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Graph t",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#t%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "t'",
          "normalized": "a-\u003eGraph b",
          "package": "HaskellForMaths",
          "signature": "a-\u003eGraph t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:t-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "triples",
          "package": "HaskellForMaths",
          "signature": "[[Integer]]",
          "source": "src/Math-Combinatorics-StronglyRegularGraph.html#triples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinatorics StronglyRegularGraph",
          "module": "Math.Combinatorics.StronglyRegularGraph",
          "name": "triples",
          "normalized": "[[Integer]]",
          "package": "HaskellForMaths",
          "signature": "[[Integer]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Combinatorics-StronglyRegularGraph.html#v:triples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "IntegerAsType",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "IntegerAsType",
          "package": "HaskellForMaths",
          "partial": "Integer As Type",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "IntegerAsType",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#IntegerAsType",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "IntegerAsType",
          "package": "HaskellForMaths",
          "partial": "Integer As Type",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:IntegerAsType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "M",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#M",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "M",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T11",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T11",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T11",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T13",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T13",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T13",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T13"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T17",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T17",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T17",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T17"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T19",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T19",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T19",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T19"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T2",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T2",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T2",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T23",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T23",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T23",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T23"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T29",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T29",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T29",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T29"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T3",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T3",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T31",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T31",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T31",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T31"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T37",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T37",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T37",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T37"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T41",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T41",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T41",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T41"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T43",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T43",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T43",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T43"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T47",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T47",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T47",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T47"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T5",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T5",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T5",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T53",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T53",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T53",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T53"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T59",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T59",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T59",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T59"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T61",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T61",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T61",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T61"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T67",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T67",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T67",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T67"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T7",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T7",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T7",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T71",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T71",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T71",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T71"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T73",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T73",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T73",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T73"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T79",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T79",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T79",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T79"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T83",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T83",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T83",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T83"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T89",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T89",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T89",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T89"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "T97",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#T97",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "T97",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:T97"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "TMinus1",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#TMinus1",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "TMinus1",
          "package": "HaskellForMaths",
          "partial": "TMinus",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:TMinus1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "TOne",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#TOne",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "TOne",
          "package": "HaskellForMaths",
          "partial": "TOne",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:TOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "TZero",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-IntegerAsType.html#TZero",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "TZero",
          "package": "HaskellForMaths",
          "partial": "TZero",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#t:TZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "M",
          "package": "HaskellForMaths",
          "signature": "M a b",
          "source": "src/Math-Common-IntegerAsType.html#M",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "M",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#v:M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.IntegerAsType",
          "name": "value",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Integer",
          "source": "src/Math-Common-IntegerAsType.html#value",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Common IntegerAsType",
          "module": "Math.Common.IntegerAsType",
          "name": "value",
          "normalized": "a-\u003eInteger",
          "package": "HaskellForMaths",
          "signature": "a-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-IntegerAsType.html#v:value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.ListSet",
          "name": "ListSet",
          "package": "HaskellForMaths",
          "source": "src/Math-Common-ListSet.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Common ListSet",
          "module": "Math.Common.ListSet",
          "name": "ListSet",
          "package": "HaskellForMaths",
          "partial": "List Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-ListSet.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.ListSet",
          "name": "(\\\\)",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Common-ListSet.html#%5C%5C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Common ListSet",
          "module": "Math.Common.ListSet",
          "name": "(\\\\) \\\\",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-ListSet.html#v:-92--92-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.ListSet",
          "name": "disjoint",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/Math-Common-ListSet.html#disjoint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Common ListSet",
          "module": "Math.Common.ListSet",
          "name": "disjoint",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-ListSet.html#v:disjoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.ListSet",
          "name": "intersect",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Common-ListSet.html#intersect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Common ListSet",
          "module": "Math.Common.ListSet",
          "name": "intersect",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-ListSet.html#v:intersect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.ListSet",
          "name": "isListSet",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Bool",
          "source": "src/Math-Common-ListSet.html#isListSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Common ListSet",
          "module": "Math.Common.ListSet",
          "name": "isListSet",
          "normalized": "[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "List Set",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-ListSet.html#v:isListSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.ListSet",
          "name": "isSubset",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/Math-Common-ListSet.html#isSubset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Common ListSet",
          "module": "Math.Common.ListSet",
          "name": "isSubset",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Subset",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-ListSet.html#v:isSubset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.ListSet",
          "name": "symDiff",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Common-ListSet.html#symDiff",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Common ListSet",
          "module": "Math.Common.ListSet",
          "name": "symDiff",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Diff",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-ListSet.html#v:symDiff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.ListSet",
          "name": "toListSet",
          "package": "HaskellForMaths",
          "signature": "[b] -\u003e [b]",
          "source": "src/Math-Common-ListSet.html#toListSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Common ListSet",
          "module": "Math.Common.ListSet",
          "name": "toListSet",
          "normalized": "[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "List Set",
          "signature": "[b]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-ListSet.html#v:toListSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Common.ListSet",
          "name": "union",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Common-ListSet.html#union",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Common ListSet",
          "module": "Math.Common.ListSet",
          "name": "union",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Common-ListSet.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module providing an efficient implementation of the Buchberger algorithm for calculating the (reduced) Groebner basis for an ideal,\n together with some straightforward applications.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "GroebnerBasis",
          "package": "HaskellForMaths",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html",
          "type": "module"
        },
        "index": {
          "description": "module providing an efficient implementation of the Buchberger algorithm for calculating the reduced Groebner basis for an ideal together with some straightforward applications",
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "GroebnerBasis",
          "package": "HaskellForMaths",
          "partial": "Groebner Basis",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "(!)",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e Int -\u003e a",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#%21",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "(!) !",
          "normalized": "[a]-\u003eInt-\u003ea",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:-33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "cmpNormal",
          "package": "HaskellForMaths",
          "signature": "((t, t4), (t1, t5)) -\u003e ((t2, t4), (t3, t5)) -\u003e Ordering",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#cmpNormal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "cmpNormal",
          "normalized": "((a,a),(a,a))-\u003e((a,a),(a,a))-\u003eOrdering",
          "package": "HaskellForMaths",
          "partial": "Normal",
          "signature": "((t,t),(t,t))-\u003e((t,t),(t,t))-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:cmpNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "cmpSug",
          "package": "HaskellForMaths",
          "signature": "((t2, t3), (t, t4)) -\u003e ((t2, t3), (t1, t4)) -\u003e Ordering",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#cmpSug",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "cmpSug",
          "normalized": "((a,a),(a,a))-\u003e((a,a),(a,a))-\u003eOrdering",
          "package": "HaskellForMaths",
          "partial": "Sug",
          "signature": "((t,t),(t,t))-\u003e((t,t),(t,t))-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:cmpSug"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "dim",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m] -\u003e Int",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#dim",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "dim",
          "normalized": "[Vect a b]-\u003e[Vect a b]-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "[Vect k m]-\u003e[Vect k m]-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:dim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "dim'",
          "package": "HaskellForMaths",
          "signature": "[Vect k (m v)] -\u003e Int",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#dim%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "dim'",
          "normalized": "[Vect a(b c)]-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "[Vect k(m v)]-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:dim-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eeliminate vs gs\u003c/code\u003e returns the elimination ideal obtained from the ideal generated by gs by eliminating the variables vs.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "eliminate",
          "package": "HaskellForMaths",
          "signature": "[Vect k (m v)] -\u003e [Vect k (m v)] -\u003e [Vect k (m v)]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#eliminate",
          "type": "function"
        },
        "index": {
          "description": "eliminate vs gs returns the elimination ideal obtained from the ideal generated by gs by eliminating the variables vs",
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "eliminate",
          "normalized": "[Vect a(b c)]-\u003e[Vect a(b c)]-\u003e[Vect a(b c)]",
          "package": "HaskellForMaths",
          "signature": "[Vect k(m v)]-\u003e[Vect k(m v)]-\u003e[Vect k(m v)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:eliminate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "eliminateFst",
          "package": "HaskellForMaths",
          "signature": "[Vect b1 (Elim2 t b)] -\u003e [Vect b1 b]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#eliminateFst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "eliminateFst",
          "normalized": "[Vect a(Elim b a)]-\u003e[Vect a a]",
          "package": "HaskellForMaths",
          "partial": "Fst",
          "signature": "[Vect b(Elim t b)]-\u003e[Vect b b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:eliminateFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "fromElimSnd",
          "package": "HaskellForMaths",
          "signature": "f (Elim2 t b) -\u003e f b",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#fromElimSnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "fromElimSnd",
          "normalized": "a(Elim b c)-\u003ea c",
          "package": "HaskellForMaths",
          "partial": "Elim Snd",
          "signature": "f(Elim t b)-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:fromElimSnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list of polynomials over a field, return a Groebner basis for the ideal generated by the polynomials.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "gb",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#gb",
          "type": "function"
        },
        "index": {
          "description": "Given list of polynomials over field return Groebner basis for the ideal generated by the polynomials",
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "gb",
          "normalized": "[Vect a b]-\u003e[Vect a b]",
          "package": "HaskellForMaths",
          "signature": "[Vect k m]-\u003e[Vect k m]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:gb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "gb1",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#gb1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "gb1",
          "normalized": "[Vect a b]-\u003e[Vect a b]",
          "package": "HaskellForMaths",
          "signature": "[Vect k m]-\u003e[Vect k m]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:gb1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "gb2",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#gb2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "gb2",
          "normalized": "[Vect a b]-\u003e[Vect a b]",
          "package": "HaskellForMaths",
          "signature": "[Vect k m]-\u003e[Vect k m]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:gb2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "gb2a",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#gb2a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "gb2a",
          "normalized": "[Vect a b]-\u003e[Vect a b]",
          "package": "HaskellForMaths",
          "signature": "[Vect k m]-\u003e[Vect k m]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:gb2a"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "gb3",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#gb3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "gb3",
          "normalized": "[Vect a b]-\u003e[Vect a b]",
          "package": "HaskellForMaths",
          "signature": "[Vect k m]-\u003e[Vect k m]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:gb3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "gb4",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#gb4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "gb4",
          "normalized": "[Vect a b]-\u003e[Vect a b]",
          "package": "HaskellForMaths",
          "signature": "[Vect k m]-\u003e[Vect k m]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:gb4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven variables vs, and a homogeneous ideal gs, \u003ccode\u003ehilbertFunQA vs gs\u003c/code\u003e returns the Hilbert function for the quotient algebra k[vs]/\u003cgs\u003e.\n Given an integer i, the Hilbert function returns the number of degree i monomials in a basis for k[vs]/\u003cgs\u003e.\n For a homogeneous ideal, this number is independent of the monomial ordering used\n (even though the elements of the monomial basis themselves are dependent on the ordering).\n\u003c/p\u003e\u003cp\u003eIf the ideal I is not homogeneous, then R/I is not graded, and the Hilbert function is not well-defined.\n Specifically, the number of degree i monomials in a basis is likely to depend on which monomial ordering you use.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "hilbertFunQA",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m] -\u003e Int -\u003e Integer",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#hilbertFunQA",
          "type": "function"
        },
        "index": {
          "description": "Given variables vs and homogeneous ideal gs hilbertFunQA vs gs returns the Hilbert function for the quotient algebra vs gs Given an integer the Hilbert function returns the number of degree monomials in basis for vs gs For homogeneous ideal this number is independent of the monomial ordering used even though the elements of the monomial basis themselves are dependent on the ordering If the ideal is not homogeneous then is not graded and the Hilbert function is not well-defined Specifically the number of degree monomials in basis is likely to depend on which monomial ordering you use",
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "hilbertFunQA",
          "normalized": "[Vect a b]-\u003e[Vect a b]-\u003eInt-\u003eInteger",
          "package": "HaskellForMaths",
          "partial": "Fun QA",
          "signature": "[Vect k m]-\u003e[Vect k m]-\u003eInt-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:hilbertFunQA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor i \u003e\u003e 0, the Hilbert function becomes a polynomial in i, called the Hilbert polynomial.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "hilbertPolyQA",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m] -\u003e GlexPoly Q String",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#hilbertPolyQA",
          "type": "function"
        },
        "index": {
          "description": "For the Hilbert function becomes polynomial in called the Hilbert polynomial",
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "hilbertPolyQA",
          "normalized": "[Vect a b]-\u003e[Vect a b]-\u003eGlexPoly Q String",
          "package": "HaskellForMaths",
          "partial": "Poly QA",
          "signature": "[Vect k m]-\u003e[Vect k m]-\u003eGlexPoly Q String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:hilbertPolyQA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "hilbertPolyQA'",
          "package": "HaskellForMaths",
          "signature": "[Vect k (m v)] -\u003e GlexPoly Q String",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#hilbertPolyQA%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "hilbertPolyQA'",
          "normalized": "[Vect a(b c)]-\u003eGlexPoly Q String",
          "package": "HaskellForMaths",
          "partial": "Poly QA'",
          "signature": "[Vect k(m v)]-\u003eGlexPoly Q String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:hilbertPolyQA-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven variables vs, and a homogeneous ideal gs, \u003ccode\u003ehilbertSeriesQA vs gs\u003c/code\u003e returns the Hilbert series for the quotient algebra k[vs]/\u003cgs\u003e.\n The Hilbert series should be interpreted as a formal power series where the coefficient of t^i is the Hilbert function evaluated at i.\n That is, the i'th element in the series is the number of degree i monomials in a basis for k[vs]/\u003cgs\u003e.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "hilbertSeriesQA",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m] -\u003e [Integer]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#hilbertSeriesQA",
          "type": "function"
        },
        "index": {
          "description": "Given variables vs and homogeneous ideal gs hilbertSeriesQA vs gs returns the Hilbert series for the quotient algebra vs gs The Hilbert series should be interpreted as formal power series where the coefficient of is the Hilbert function evaluated at That is the th element in the series is the number of degree monomials in basis for vs gs",
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "hilbertSeriesQA",
          "normalized": "[Vect a b]-\u003e[Vect a b]-\u003e[Integer]",
          "package": "HaskellForMaths",
          "partial": "Series QA",
          "signature": "[Vect k m]-\u003e[Vect k m]-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:hilbertSeriesQA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn the case where every variable v occurs in some generator g of the homogeneous ideal (the usual case),\n then the vs can be inferred from the gs.\n \u003ccode\u003ehilbertSeriesQA' gs\u003c/code\u003e returns the Hilbert series for the quotient algebra k[vs]/\u003cgs\u003e.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "hilbertSeriesQA'",
          "package": "HaskellForMaths",
          "signature": "[Vect k (m v)] -\u003e [Integer]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#hilbertSeriesQA%27",
          "type": "function"
        },
        "index": {
          "description": "In the case where every variable occurs in some generator of the homogeneous ideal the usual case then the vs can be inferred from the gs hilbertSeriesQA gs returns the Hilbert series for the quotient algebra vs gs",
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "hilbertSeriesQA'",
          "normalized": "[Vect a(b c)]-\u003e[Integer]",
          "package": "HaskellForMaths",
          "partial": "Series QA'",
          "signature": "[Vect k(m v)]-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:hilbertSeriesQA-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "hilbertSeriesQA1",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m] -\u003e [Int]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#hilbertSeriesQA1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "hilbertSeriesQA1",
          "normalized": "[Vect a b]-\u003e[Vect a b]-\u003e[Int]",
          "package": "HaskellForMaths",
          "partial": "Series QA",
          "signature": "[Vect k m]-\u003e[Vect k m]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:hilbertSeriesQA1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe intersection of ideals I and J is the set of all polynomials which belong to both I and J.\n\u003c/p\u003e\u003cp\u003eIf fs and gs are generators for I and J, then \u003ccode\u003eintersectI fs gs\u003c/code\u003e returns generators for the intersection of I and J\n\u003c/p\u003e\u003cp\u003eThe geometric interpretation is that the variety of the intersection is the union of the varieties,\n ie V(I intersect J) = V(I) union V(J).\n\u003c/p\u003e\u003cp\u003eThe reason for prefering the intersection over the product is that the intersection of radical ideals is radical,\n whereas the product need not be.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "intersectI",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m] -\u003e [Vect k m]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#intersectI",
          "type": "function"
        },
        "index": {
          "description": "The intersection of ideals and is the set of all polynomials which belong to both and If fs and gs are generators for and then intersectI fs gs returns generators for the intersection of and The geometric interpretation is that the variety of the intersection is the union of the varieties ie intersect union The reason for prefering the intersection over the product is that the intersection of radical ideals is radical whereas the product need not be",
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "intersectI",
          "normalized": "[Vect a b]-\u003e[Vect a b]-\u003e[Vect a b]",
          "package": "HaskellForMaths",
          "signature": "[Vect k m]-\u003e[Vect k m]-\u003e[Vect k m]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:intersectI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "isElimFst",
          "package": "HaskellForMaths",
          "signature": "Vect b1 (Elim2 b t) -\u003e Bool",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#isElimFst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "isElimFst",
          "normalized": "Vect a(Elim a b)-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Elim Fst",
          "signature": "Vect b(Elim b t)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:isElimFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "isGB",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e Bool",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#isGB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "isGB",
          "normalized": "[Vect a b]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "GB",
          "signature": "[Vect k m]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:isGB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven an ideal I, the leading term ideal lt(I) consists of the leading terms of all elements of I.\n If I is generated by gs, then \u003ccode\u003eltIdeal gs\u003c/code\u003e returns generators for lt(I).\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "ltIdeal",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#ltIdeal",
          "type": "function"
        },
        "index": {
          "description": "Given an ideal the leading term ideal lt consists of the leading terms of all elements of If is generated by gs then ltIdeal gs returns generators for lt",
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "ltIdeal",
          "normalized": "[Vect a b]-\u003e[Vect a b]",
          "package": "HaskellForMaths",
          "partial": "Ideal",
          "signature": "[Vect k m]-\u003e[Vect k m]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:ltIdeal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "mbasis",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e [t]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#mbasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "mbasis",
          "normalized": "[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[t]-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:mbasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven variables vs, and a Groebner basis gs, \u003ccode\u003embasisQA vs gs\u003c/code\u003e returns a monomial basis for the quotient algebra k[vs]/\u003cgs\u003e.\n For example, \u003ccode\u003embasisQA [x,y] [x^2+y^2-1]\u003c/code\u003e returns a monomial basis for k[x,y]/\u003cx^2+y^2-1\u003e.\n In general, the monomial basis is likely to be infinite.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "mbasisQA",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m] -\u003e [Vect k m]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#mbasisQA",
          "type": "function"
        },
        "index": {
          "description": "Given variables vs and Groebner basis gs mbasisQA vs gs returns monomial basis for the quotient algebra vs gs For example mbasisQA returns monomial basis for In general the monomial basis is likely to be infinite",
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "mbasisQA",
          "normalized": "[Vect a b]-\u003e[Vect a b]-\u003e[Vect a b]",
          "package": "HaskellForMaths",
          "partial": "QA",
          "signature": "[Vect k m]-\u003e[Vect k m]-\u003e[Vect k m]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:mbasisQA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "memberGB",
          "package": "HaskellForMaths",
          "signature": "Vect k m -\u003e [Vect k m] -\u003e Bool",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#memberGB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "memberGB",
          "normalized": "Vect a b-\u003e[Vect a b]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "GB",
          "signature": "Vect k m-\u003e[Vect k m]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:memberGB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ememberI f gs\u003c/code\u003e returns whether f is in the ideal generated by gs\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "memberI",
          "package": "HaskellForMaths",
          "signature": "Vect k m -\u003e [Vect k m] -\u003e Bool",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#memberI",
          "type": "function"
        },
        "index": {
          "description": "memberI gs returns whether is in the ideal generated by gs",
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "memberI",
          "normalized": "Vect a b-\u003e[Vect a b]-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "Vect k m-\u003e[Vect k m]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:memberI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "mergeBy",
          "package": "HaskellForMaths",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e [a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#mergeBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "mergeBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:mergeBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "numMonomials",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a -\u003e Integer",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#numMonomials",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "numMonomials",
          "normalized": "a-\u003ea-\u003eInteger",
          "package": "HaskellForMaths",
          "partial": "Monomials",
          "signature": "a-\u003ea-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:numMonomials"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "pairWith",
          "package": "HaskellForMaths",
          "signature": "(a1 -\u003e a1 -\u003e a) -\u003e [a1] -\u003e [a]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#pairWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "pairWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:pairWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven ideals I and J, their product I.J is the ideal generated by all products {f.g | f \u003c- I, g \u003c- J}.\n\u003c/p\u003e\u003cp\u003eIf fs and gs are generators for I and J, then \u003ccode\u003eproductI fs gs\u003c/code\u003e returns generators for I.J.\n\u003c/p\u003e\u003cp\u003eThe geometric interpretation is that the variety of the product is the union of the varieties,\n ie V(I.J) = V(I) union V(J)\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "productI",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m] -\u003e [Vect k m]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#productI",
          "type": "function"
        },
        "index": {
          "description": "Given ideals and their product I.J is the ideal generated by all products f.g If fs and gs are generators for and then productI fs gs returns generators for I.J The geometric interpretation is that the variety of the product is the union of the varieties ie I.J union",
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "productI",
          "normalized": "[Vect a b]-\u003e[Vect a b]-\u003e[Vect a b]",
          "package": "HaskellForMaths",
          "signature": "[Vect k m]-\u003e[Vect k m]-\u003e[Vect k m]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:productI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven ideals I and J, their quotient is defined as I:J = {f | f \u003c- R, f.g is in I for all g in J}.\n\u003c/p\u003e\u003cp\u003eIf fs and gs are generators for I and J, then \u003ccode\u003equotientI fs gs\u003c/code\u003e returns generators for I:J.\n\u003c/p\u003e\u003cp\u003eThe ideal quotient is the algebraic analogue of the Zariski closure of a difference of varieties.\n V(I:J) contains the Zariski closure of V(I)-V(J), with equality if k is algebraically closed and I is a radical ideal.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "quotientI",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m] -\u003e [Vect k m]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#quotientI",
          "type": "function"
        },
        "index": {
          "description": "Given ideals and their quotient is defined as f.g is in for all in If fs and gs are generators for and then quotientI fs gs returns generators for The ideal quotient is the algebraic analogue of the Zariski closure of difference of varieties contains the Zariski closure of with equality if is algebraically closed and is radical ideal",
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "quotientI",
          "normalized": "[Vect a b]-\u003e[Vect a b]-\u003e[Vect a b]",
          "package": "HaskellForMaths",
          "signature": "[Vect k m]-\u003e[Vect k m]-\u003e[Vect k m]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:quotientI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "quotientP",
          "package": "HaskellForMaths",
          "signature": "[Vect k b] -\u003e Vect k b -\u003e [Vect k b]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#quotientP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "quotientP",
          "normalized": "[Vect a b]-\u003eVect a b-\u003e[Vect a b]",
          "package": "HaskellForMaths",
          "signature": "[Vect k b]-\u003eVect k b-\u003e[Vect k b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:quotientP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "reduce",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#reduce",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "reduce",
          "normalized": "[Vect a b]-\u003e[Vect a b]",
          "package": "HaskellForMaths",
          "signature": "[Vect k m]-\u003e[Vect k m]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:reduce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "sPoly",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e Vect k b -\u003e Vect k b",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#sPoly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "sPoly",
          "normalized": "Vect a b-\u003eVect a b-\u003eVect a b",
          "package": "HaskellForMaths",
          "partial": "Poly",
          "signature": "Vect k b-\u003eVect k b-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:sPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "sugar",
          "package": "HaskellForMaths",
          "signature": "Vect b m1 -\u003e Vect b1 m2 -\u003e m -\u003e Int",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#sugar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "sugar",
          "normalized": "Vect a b-\u003eVect a b-\u003eb-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "Vect b m-\u003eVect b m-\u003em-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:sugar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven ideals I and J, their sum is defined as I+J = {f+g | f \u003c- I, g \u003c- J}.\n\u003c/p\u003e\u003cp\u003eIf fs and gs are generators for I and J, then \u003ccode\u003esumI fs gs\u003c/code\u003e returns generators for I+J.\n\u003c/p\u003e\u003cp\u003eThe geometric interpretation is that the variety of the sum is the intersection of the varieties,\n ie V(I+J) = V(I) intersect V(J)\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "sumI",
          "package": "HaskellForMaths",
          "signature": "[Vect k m] -\u003e [Vect k m] -\u003e [Vect k m]",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#sumI",
          "type": "function"
        },
        "index": {
          "description": "Given ideals and their sum is defined as If fs and gs are generators for and then sumI fs gs returns generators for The geometric interpretation is that the variety of the sum is the intersection of the varieties ie intersect",
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "sumI",
          "normalized": "[Vect a b]-\u003e[Vect a b]-\u003e[Vect a b]",
          "package": "HaskellForMaths",
          "signature": "[Vect k m]-\u003e[Vect k m]-\u003e[Vect k m]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:sumI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "toElimFst",
          "package": "HaskellForMaths",
          "signature": "f a -\u003e f (Elim2 a b)",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#toElimFst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "toElimFst",
          "normalized": "a b-\u003ea(Elim b c)",
          "package": "HaskellForMaths",
          "partial": "Elim Fst",
          "signature": "f a-\u003ef(Elim a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:toElimFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "toElimSnd",
          "package": "HaskellForMaths",
          "signature": "f b -\u003e f (Elim2 a b)",
          "source": "src/Math-CommutativeAlgebra-GroebnerBasis.html#toElimSnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra GroebnerBasis",
          "module": "Math.CommutativeAlgebra.GroebnerBasis",
          "name": "toElimSnd",
          "normalized": "a b-\u003ea(Elim c b)",
          "package": "HaskellForMaths",
          "partial": "Elim Snd",
          "signature": "f b-\u003ef(Elim a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-GroebnerBasis.html#v:toElimSnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining the algebra of commutative polynomials over a field k.\n Polynomials are represented as the free k-vector space with the monomials as basis.\n\u003c/p\u003e\u003cp\u003eA monomial ordering is required to specify how monomials are to be ordered.\n The Lex, Glex, and Grevlex monomial orders are defined, with the possibility to add others.\n\u003c/p\u003e\u003cp\u003eIn order to make use of this module, some variables must be defined, for example:\n\u003c/p\u003e\u003cpre\u003e [t,u,v,x,y,z] = map glexvar [\"t\",\"u\",\"v\",\"x\",\"y\",\"z\"]\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Polynomial",
          "package": "HaskellForMaths",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html",
          "type": "module"
        },
        "index": {
          "description": "module defining the algebra of commutative polynomials over field Polynomials are represented as the free k-vector space with the monomials as basis monomial ordering is required to specify how monomials are to be ordered The Lex Glex and Grevlex monomial orders are defined with the possibility to add others In order to make use of this module some variables must be defined for example map glexvar",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Polynomial",
          "package": "HaskellForMaths",
          "partial": "Polynomial",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Elim2",
          "package": "HaskellForMaths",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#Elim2",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Elim2",
          "package": "HaskellForMaths",
          "partial": "Elim",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#t:Elim2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type representing monomials with Glex ordering.\n\u003c/p\u003e\u003cp\u003eGlex stands for graded lexicographic. Thus monomials are ordered first by degree, then by lexicographic order.\n For example, in Glex ordering, monomials up to degree two would be ordered as follows: x^2+xy+xz+y^2+yz+z^2+x+y+z+1.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Glex",
          "package": "HaskellForMaths",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#Glex",
          "type": "newtype"
        },
        "index": {
          "description": "type representing monomials with Glex ordering Glex stands for graded lexicographic Thus monomials are ordered first by degree then by lexicographic order For example in Glex ordering monomials up to degree two would be ordered as follows xy xz yz",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Glex",
          "package": "HaskellForMaths",
          "partial": "Glex",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#t:Glex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type representing polynomials with Glex term ordering.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "GlexPoly",
          "package": "HaskellForMaths",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#GlexPoly",
          "type": "type"
        },
        "index": {
          "description": "type representing polynomials with Glex term ordering",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "GlexPoly",
          "package": "HaskellForMaths",
          "partial": "Glex Poly",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#t:GlexPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type representing monomials with Grevlex ordering.\n\u003c/p\u003e\u003cp\u003eGrevlex stands for graded reverse lexicographic. Thus monomials are ordered first by degree, then by reverse lexicographic order.\n For example, in Grevlex ordering, monomials up to degree two would be ordered as follows: x^2+xy+y^2+xz+yz+z^2+x+y+z+1.\n\u003c/p\u003e\u003cp\u003eIn general, Grevlex leads to the smallest Groebner bases.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Grevlex",
          "package": "HaskellForMaths",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#Grevlex",
          "type": "newtype"
        },
        "index": {
          "description": "type representing monomials with Grevlex ordering Grevlex stands for graded reverse lexicographic Thus monomials are ordered first by degree then by reverse lexicographic order For example in Grevlex ordering monomials up to degree two would be ordered as follows xy xz yz In general Grevlex leads to the smallest Groebner bases",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Grevlex",
          "package": "HaskellForMaths",
          "partial": "Grevlex",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#t:Grevlex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type representing polynomials with Grevlex term ordering.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "GrevlexPoly",
          "package": "HaskellForMaths",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#GrevlexPoly",
          "type": "type"
        },
        "index": {
          "description": "type representing polynomials with Grevlex term ordering",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "GrevlexPoly",
          "package": "HaskellForMaths",
          "partial": "Grevlex Poly",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#t:GrevlexPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type representing monomials with Lex ordering.\n\u003c/p\u003e\u003cp\u003eLex stands for lexicographic ordering.\n For example, in Lex ordering, monomials up to degree two would be ordered as follows: x^2+xy+xz+x+y^2+yz+y+z^2+z+1.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Lex",
          "package": "HaskellForMaths",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#Lex",
          "type": "newtype"
        },
        "index": {
          "description": "type representing monomials with Lex ordering Lex stands for lexicographic ordering For example in Lex ordering monomials up to degree two would be ordered as follows xy xz yz",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Lex",
          "package": "HaskellForMaths",
          "partial": "Lex",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#t:Lex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type representing polynomials with Lex term ordering.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "LexPoly",
          "package": "HaskellForMaths",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#LexPoly",
          "type": "type"
        },
        "index": {
          "description": "type representing polynomials with Lex term ordering",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "LexPoly",
          "package": "HaskellForMaths",
          "partial": "Lex Poly",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#t:LexPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe underlying implementation of monomials in variables of type v. Most often, we will be interested in MonImpl String,\n with the variable \"x\" represented by M 1 [(\"x\",1)]. However, other types can be used instead.\n\u003c/p\u003e\u003cp\u003eNo Ord instance is defined for MonImpl v, so it cannot be used as the basis for a free vector space of polynomials.\n Instead, several different newtype wrappers are provided, corresponding to different monomial orderings.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "MonImpl",
          "package": "HaskellForMaths",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#MonImpl",
          "type": "data"
        },
        "index": {
          "description": "The underlying implementation of monomials in variables of type Most often we will be interested in MonImpl String with the variable represented by However other types can be used instead No Ord instance is defined for MonImpl so it cannot be used as the basis for free vector space of polynomials Instead several different newtype wrappers are provided corresponding to different monomial orderings",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "MonImpl",
          "package": "HaskellForMaths",
          "partial": "Mon Impl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#t:MonImpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn order to work with monomials, we need to be able to multiply them and divide them.\n Multiplication is defined by the Mon (monoid) class. Division is defined in this class.\n The functions here are primarily intended for internal use only.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Monomial",
          "package": "HaskellForMaths",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#Monomial",
          "type": "class"
        },
        "index": {
          "description": "In order to work with monomials we need to be able to multiply them and divide them Multiplication is defined by the Mon monoid class Division is defined in this class The functions here are primarily intended for internal use only",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Monomial",
          "package": "HaskellForMaths",
          "partial": "Monomial",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#t:Monomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe want to be able to construct monomials over any set of variables that we choose.\n Although we will often use String as the type of our variables,\n it is useful to define polymorphic types for monomials.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "MonomialConstructor",
          "package": "HaskellForMaths",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#MonomialConstructor",
          "type": "class"
        },
        "index": {
          "description": "We want to be able to construct monomials over any set of variables that we choose Although we will often use String as the type of our variables it is useful to define polymorphic types for monomials",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "MonomialConstructor",
          "package": "HaskellForMaths",
          "partial": "Monomial Constructor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#t:MonomialConstructor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ef %% gs\u003c/code\u003e is the reduction of a polynomial f with respect to a list of polynomials gs.\n In the case where the gs are a Groebner basis for an ideal I,\n then \u003ccode\u003ef %% gs\u003c/code\u003e is the equivalence class representative of f in R/I,\n and is zero if and only if f is in I.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "(%%)",
          "package": "HaskellForMaths",
          "signature": "Vect k m -\u003e [Vect k m] -\u003e Vect k m",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#%25%25",
          "type": "function"
        },
        "index": {
          "description": "gs is the reduction of polynomial with respect to list of polynomials gs In the case where the gs are Groebner basis for an ideal then gs is the equivalence class representative of in and is zero if and only if is in",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "(%%) %%",
          "normalized": "Vect a b-\u003e[Vect a b]-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k m-\u003e[Vect k m]-\u003eVect k m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:-37--37-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "(*-\u003e)",
          "package": "HaskellForMaths",
          "signature": "(b, k) -\u003e Vect k b -\u003e Vect k b",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#%2A-%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "(*-\u003e) *-\u003e",
          "normalized": "(a,b)-\u003eVect b a-\u003eVect b a",
          "package": "HaskellForMaths",
          "signature": "(b,k)-\u003eVect k b-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:-42--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Elim2",
          "package": "HaskellForMaths",
          "signature": "Elim2 !a !b",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#Elim2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Elim2",
          "package": "HaskellForMaths",
          "partial": "Elim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:Elim2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Glex",
          "package": "HaskellForMaths",
          "signature": "Glex (MonImpl v)",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#Glex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Glex",
          "package": "HaskellForMaths",
          "partial": "Glex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:Glex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Grevlex",
          "package": "HaskellForMaths",
          "signature": "Grevlex (MonImpl v)",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#Grevlex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Grevlex",
          "package": "HaskellForMaths",
          "partial": "Grevlex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:Grevlex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Lex",
          "package": "HaskellForMaths",
          "signature": "Lex (MonImpl v)",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#Lex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "Lex",
          "package": "HaskellForMaths",
          "partial": "Lex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:Lex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "M",
          "package": "HaskellForMaths",
          "signature": "M Int [(v, Int)]",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#MonImpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "M",
          "normalized": "M Int[(a,Int)]",
          "package": "HaskellForMaths",
          "signature": "M Int[(v,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven (Num k, MonomialConstructor m), then Vect k (m v) is the free commutative algebra over v.\n As such, it is a monad (in the mathematical sense). The following pseudo-code (not legal Haskell)\n shows how this would work:\n\u003c/p\u003e\u003cpre\u003e instance (Num k, Monomial m) =\u003e Monad (\\v -\u003e Vect k (m v)) where\n     return = var\n     (\u003e\u003e=) = bind\n\u003c/pre\u003e\u003cp\u003ebind corresponds to variable substitution, so \u003ccode\u003ev `bind` f\u003c/code\u003e returns the result of making the substitutions\n encoded in f into v.\n\u003c/p\u003e\u003cp\u003eNote that the type signature is slightly more general than that required by (\u003e\u003e=).\n For a monad, we would only require:\n\u003c/p\u003e\u003cpre\u003e bind :: (MonomialConstructor m, Num k, Ord (m v), Show (m v), Algebra k (m v)) =\u003e\n     Vect k (m u) -\u003e (u -\u003e Vect k (m v)) -\u003e Vect k (m v)\n\u003c/pre\u003e\u003cp\u003eInstead, the given type signature allows us to substitute in elements of any algebra.\n This is occasionally useful.\n\u003c/p\u003e\u003cp\u003ebind performs variable substitution\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "bind",
          "package": "HaskellForMaths",
          "signature": "Vect k (m v) -\u003e (v -\u003e Vect k a) -\u003e Vect k a",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#bind",
          "type": "function"
        },
        "index": {
          "description": "Given Num MonomialConstructor then Vect is the free commutative algebra over As such it is monad in the mathematical sense The following pseudo-code not legal Haskell shows how this would work instance Num Monomial Monad Vect where return var bind bind corresponds to variable substitution so bind returns the result of making the substitutions encoded in into Note that the type signature is slightly more general than that required by For monad we would only require bind MonomialConstructor Num Ord Show Algebra Vect Vect Vect Instead the given type signature allows us to substitute in elements of any algebra This is occasionally useful bind performs variable substitution",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "bind",
          "normalized": "Vect a(b c)-\u003e(c-\u003eVect a d)-\u003eVect a d",
          "package": "HaskellForMaths",
          "signature": "Vect k(m v)-\u003e(v-\u003eVect k a)-\u003eVect k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "deg",
          "package": "HaskellForMaths",
          "signature": "Vect t m -\u003e Int",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#deg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "deg",
          "normalized": "Vect a b-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "Vect t m-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:deg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate a polynomial at a point.\n For example \u003ccode\u003eeval (x^2+y^2) [(x,1),(y,2)]\u003c/code\u003e evaluates x^2+y^2 at the point (x,y)=(1,2).\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "eval",
          "package": "HaskellForMaths",
          "signature": "Vect k (m v) -\u003e [(Vect k (m v), k)] -\u003e k",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#eval",
          "type": "function"
        },
        "index": {
          "description": "Evaluate polynomial at point For example eval evaluates at the point",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "eval",
          "normalized": "Vect a(b c)-\u003e[(Vect a(b c),a)]-\u003ea",
          "package": "HaskellForMaths",
          "signature": "Vect k(m v)-\u003e[(Vect k(m v),k)]-\u003ek",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:eval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "flipbind",
          "package": "HaskellForMaths",
          "signature": "(v -\u003e Vect k b) -\u003e Vect k (m v) -\u003e Vect k b",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#flipbind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "flipbind",
          "normalized": "(a-\u003eVect b c)-\u003eVect b(d a)-\u003eVect b c",
          "package": "HaskellForMaths",
          "signature": "(v-\u003eVect k b)-\u003eVect k(m v)-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:flipbind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eglexvar v\u003c/code\u003e creates a variable in the algebra of commutative polynomials over Q with Glex term ordering.\n It is provided as a shortcut, to avoid having to provide a type annotation, as with \u003ccode\u003evar\u003c/code\u003e.\n For example, the following code creates variables called x, y and z:\n\u003c/p\u003e\u003cpre\u003e [x,y,z] = map glexvar [\"x\",\"y\",\"z\"]\n\u003c/pre\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "glexvar",
          "package": "HaskellForMaths",
          "signature": "v -\u003e GlexPoly Q v",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#glexvar",
          "type": "function"
        },
        "index": {
          "description": "glexvar creates variable in the algebra of commutative polynomials over with Glex term ordering It is provided as shortcut to avoid having to provide type annotation as with var For example the following code creates variables called and map glexvar",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "glexvar",
          "normalized": "a-\u003eGlexPoly Q a",
          "package": "HaskellForMaths",
          "signature": "v-\u003eGlexPoly Q v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:glexvar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003egrevlexvar v\u003c/code\u003e creates a variable in the algebra of commutative polynomials over Q with Grevlex term ordering.\n It is provided as a shortcut, to avoid having to provide a type annotation, as with \u003ccode\u003evar\u003c/code\u003e.\n For example, the following code creates variables called x, y and z:\n\u003c/p\u003e\u003cpre\u003e [x,y,z] = map grevlexvar [\"x\",\"y\",\"z\"]\n\u003c/pre\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "grevlexvar",
          "package": "HaskellForMaths",
          "signature": "v -\u003e GrevlexPoly Q v",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#grevlexvar",
          "type": "function"
        },
        "index": {
          "description": "grevlexvar creates variable in the algebra of commutative polynomials over with Grevlex term ordering It is provided as shortcut to avoid having to provide type annotation as with var For example the following code creates variables called and map grevlexvar",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "grevlexvar",
          "normalized": "a-\u003eGrevlexPoly Q a",
          "package": "HaskellForMaths",
          "signature": "v-\u003eGrevlexPoly Q v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:grevlexvar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "lc",
          "package": "HaskellForMaths",
          "signature": "Vect c a -\u003e c",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#lc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "lc",
          "normalized": "Vect a b-\u003ea",
          "package": "HaskellForMaths",
          "signature": "Vect c a-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:lc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003elexvar v\u003c/code\u003e creates a variable in the algebra of commutative polynomials over Q with Lex term ordering.\n It is provided as a shortcut, to avoid having to provide a type annotation, as with \u003ccode\u003evar\u003c/code\u003e.\n For example, the following code creates variables called x, y and z:\n\u003c/p\u003e\u003cpre\u003e [x,y,z] = map lexvar [\"x\",\"y\",\"z\"]\n\u003c/pre\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "lexvar",
          "package": "HaskellForMaths",
          "signature": "v -\u003e LexPoly Q v",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#lexvar",
          "type": "function"
        },
        "index": {
          "description": "lexvar creates variable in the algebra of commutative polynomials over with Lex term ordering It is provided as shortcut to avoid having to provide type annotation as with var For example the following code creates variables called and map lexvar",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "lexvar",
          "normalized": "a-\u003eLexPoly Q a",
          "package": "HaskellForMaths",
          "signature": "v-\u003eLexPoly Q v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:lexvar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "lm",
          "package": "HaskellForMaths",
          "signature": "Vect b c -\u003e c",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#lm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "lm",
          "normalized": "Vect a b-\u003eb",
          "package": "HaskellForMaths",
          "signature": "Vect b c-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:lm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "lt",
          "package": "HaskellForMaths",
          "signature": "Vect t t1 -\u003e (t1, t)",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#lt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "lt",
          "normalized": "Vect a a-\u003e(a,a)",
          "package": "HaskellForMaths",
          "signature": "Vect t t-\u003e(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:lt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mcoprime",
          "package": "HaskellForMaths",
          "signature": "m -\u003e m -\u003e Bool",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#mcoprime",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mcoprime",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "m-\u003em-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:mcoprime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mdeg",
          "package": "HaskellForMaths",
          "signature": "m -\u003e Int",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#mdeg",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mdeg",
          "normalized": "a-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "m-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:mdeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mdiv",
          "package": "HaskellForMaths",
          "signature": "m -\u003e m -\u003e m",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#mdiv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mdiv",
          "normalized": "a-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "signature": "m-\u003em-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:mdiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mdivides",
          "package": "HaskellForMaths",
          "signature": "m -\u003e m -\u003e Bool",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#mdivides",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mdivides",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "m-\u003em-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:mdivides"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mgcd",
          "package": "HaskellForMaths",
          "signature": "m -\u003e m -\u003e m",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#mgcd",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mgcd",
          "normalized": "a-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "signature": "m-\u003em-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:mgcd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mindices",
          "package": "HaskellForMaths",
          "signature": "m v -\u003e [(v, Int)]",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#mindices",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mindices",
          "normalized": "a b-\u003e[(b,Int)]",
          "package": "HaskellForMaths",
          "signature": "m v-\u003e[(v,Int)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:mindices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mlcm",
          "package": "HaskellForMaths",
          "signature": "m -\u003e m -\u003e m",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#mlcm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mlcm",
          "normalized": "a-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "signature": "m-\u003em-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:mlcm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mproperlydivides",
          "package": "HaskellForMaths",
          "signature": "m -\u003e m -\u003e Bool",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#mproperlydivides",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mproperlydivides",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "m-\u003em-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:mproperlydivides"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mvar",
          "package": "HaskellForMaths",
          "signature": "v -\u003e m v",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#mvar",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "mvar",
          "normalized": "a-\u003eb a",
          "package": "HaskellForMaths",
          "signature": "v-\u003em v",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:mvar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "quotRemMP",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e [Vect k b] -\u003e ([Vect k b], Vect k b)",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#quotRemMP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "quotRemMP",
          "normalized": "Vect a b-\u003e[Vect a b]-\u003e([Vect a b],Vect a b)",
          "package": "HaskellForMaths",
          "partial": "Rem MP",
          "signature": "Vect k b-\u003e[Vect k b]-\u003e([Vect k b],Vect k b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:quotRemMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "rewrite",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e [Vect k b] -\u003e Vect k b",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#rewrite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "rewrite",
          "normalized": "Vect a b-\u003e[Vect a b]-\u003eVect a b",
          "package": "HaskellForMaths",
          "signature": "Vect k b-\u003e[Vect k b]-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:rewrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform variable substitution on a polynomial.\n For example \u003ccode\u003esubst (x*z-y^2) [(x,u^2),(y,u*v),(z,v^2)]\u003c/code\u003e performs the substitution x -\u003e u^2, y -\u003e u*v, z -\u003e v^2.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "subst",
          "package": "HaskellForMaths",
          "signature": "Vect k (m u) -\u003e [(Vect k (m u), Vect k (m v))] -\u003e Vect k (m v)",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#subst",
          "type": "function"
        },
        "index": {
          "description": "Perform variable substitution on polynomial For example subst z-y performs the substitution",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "subst",
          "normalized": "Vect a(b c)-\u003e[(Vect a(b c),Vect a(b d))]-\u003eVect a(b d)",
          "package": "HaskellForMaths",
          "signature": "Vect k(m u)-\u003e[(Vect k(m u),Vect k(m v))]-\u003eVect k(m v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:subst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "tdiv",
          "package": "HaskellForMaths",
          "signature": "(t, t1) -\u003e (t, t1) -\u003e (t, t1)",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#tdiv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "tdiv",
          "normalized": "(a,a)-\u003e(a,a)-\u003e(a,a)",
          "package": "HaskellForMaths",
          "signature": "(t,t)-\u003e(t,t)-\u003e(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:tdiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "tdivides",
          "package": "HaskellForMaths",
          "signature": "(m, t) -\u003e (m, t1) -\u003e Bool",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#tdivides",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "tdivides",
          "normalized": "(a,b)-\u003e(a,b)-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "(m,t)-\u003e(m,t)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:tdivides"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "tgcd",
          "package": "HaskellForMaths",
          "signature": "(t2, t) -\u003e (t2, t1) -\u003e (t2, t3)",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#tgcd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "tgcd",
          "normalized": "(a,a)-\u003e(a,a)-\u003e(a,a)",
          "package": "HaskellForMaths",
          "signature": "(t,t)-\u003e(t,t)-\u003e(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:tgcd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "tmult",
          "package": "HaskellForMaths",
          "signature": "(t, t1) -\u003e (t, t1) -\u003e (t, t1)",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#tmult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "tmult",
          "normalized": "(a,a)-\u003e(a,a)-\u003e(a,a)",
          "package": "HaskellForMaths",
          "signature": "(t,t)-\u003e(t,t)-\u003e(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:tmult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "toMonic",
          "package": "HaskellForMaths",
          "signature": "Vect k b -\u003e Vect k b",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#toMonic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "toMonic",
          "normalized": "Vect a b-\u003eVect a b",
          "package": "HaskellForMaths",
          "partial": "Monic",
          "signature": "Vect k b-\u003eVect k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:toMonic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003evar v\u003c/code\u003e creates a variable in the vector space of polynomials.\n For example, if we want to work in Q[x,y,z], we might define:\n\u003c/p\u003e\u003cpre\u003e [x,y,z] = map var [\"x\",\"y\",\"z\"] :: [GlexPoly Q String]\n\u003c/pre\u003e\u003cp\u003eNotice that, in general, it is necessary to provide a type annotation so that\n the compiler knows which field and which term order to use.\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "var",
          "package": "HaskellForMaths",
          "signature": "v -\u003e Vect k (m v)",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#var",
          "type": "function"
        },
        "index": {
          "description": "var creates variable in the vector space of polynomials For example if we want to work in we might define map var GlexPoly String Notice that in general it is necessary to provide type annotation so that the compiler knows which field and which term order to use",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "var",
          "normalized": "a-\u003eVect b(c a)",
          "package": "HaskellForMaths",
          "signature": "v-\u003eVect k(m v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList the variables used in a polynomial\n\u003c/p\u003e",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "vars",
          "package": "HaskellForMaths",
          "signature": "Vect k (m v) -\u003e [Vect k (m v)]",
          "source": "src/Math-CommutativeAlgebra-Polynomial.html#vars",
          "type": "function"
        },
        "index": {
          "description": "List the variables used in polynomial",
          "hierarchy": "Math CommutativeAlgebra Polynomial",
          "module": "Math.CommutativeAlgebra.Polynomial",
          "name": "vars",
          "normalized": "Vect a(b c)-\u003e[Vect a(b c)]",
          "package": "HaskellForMaths",
          "signature": "Vect k(m v)-\u003e[Vect k(m v)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-CommutativeAlgebra-Polynomial.html#v:vars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining the field Q of rationals and the small finite fields F2, F3, F4, F5, F7, F8, F9, F11, F13, F16, F17, F19, F23, F25.\n\u003c/p\u003e\u003cp\u003eGiven a prime power q, Fq is the type representing elements of the field (eg \u003ccode\u003eF4\u003c/code\u003e),\n fq is a list of the elements of the field, beginning 0,1,... (eg \u003ccode\u003ef4\u003c/code\u003e),\n and for prime power fields, aq is a primitive element, which generates the multiplicative group (eg \u003ccode\u003ea4\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eThe design philosophy is that fq, the list of elements, represents the field.\n Thus, many functions elsewhere in the library expect to take fq as an argument,\n telling them which field to work over.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Core.Field",
          "name": "Field",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html",
          "type": "module"
        },
        "index": {
          "description": "module defining the field of rationals and the small finite fields F2 F3 F4 F5 F7 F8 F9 F11 F13 F16 F17 F19 F23 F25 Given prime power Fq is the type representing elements of the field eg F4 fq is list of the elements of the field beginning eg f4 and for prime power fields aq is primitive element which generates the multiplicative group eg a4 The design philosophy is that fq the list of elements represents the field Thus many functions elsewhere in the library expect to take fq as an argument telling them which field to work over",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "Field",
          "package": "HaskellForMaths",
          "partial": "Field",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF11 is a type for the finite field with 11 elements\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "F11",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#F11",
          "type": "newtype"
        },
        "index": {
          "description": "F11 is type for the finite field with elements",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F11",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:F11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF13 is a type for the finite field with 13 elements\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "F13",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#F13",
          "type": "newtype"
        },
        "index": {
          "description": "F13 is type for the finite field with elements",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F13",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:F13"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF16 is a type for the finite field with 16 elements.\n F16 is represented as the extension of F2 by an element a16 satisfying x^4+x+1 = 0\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "F16",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#F16",
          "type": "newtype"
        },
        "index": {
          "description": "F16 is type for the finite field with elements F16 is represented as the extension of F2 by an element a16 satisfying",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F16",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:F16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF17 is a type for the finite field with 17 elements\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "F17",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#F17",
          "type": "newtype"
        },
        "index": {
          "description": "F17 is type for the finite field with elements",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F17",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:F17"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF19 is a type for the finite field with 19 elements\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "F19",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#F19",
          "type": "newtype"
        },
        "index": {
          "description": "F19 is type for the finite field with elements",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F19",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:F19"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF2 is a type for the finite field with 2 elements\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "F2",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#F2",
          "type": "newtype"
        },
        "index": {
          "description": "F2 is type for the finite field with elements",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F2",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:F2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF23 is a type for the finite field with 23 elements\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "F23",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#F23",
          "type": "newtype"
        },
        "index": {
          "description": "F23 is type for the finite field with elements",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F23",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:F23"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF25 is a type for the finite field with 25 elements.\n F25 is represented as the extension of F5 by an element a25 satisfying x^2+4x+2 = 0\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "F25",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#F25",
          "type": "newtype"
        },
        "index": {
          "description": "F25 is type for the finite field with elements F25 is represented as the extension of F5 by an element a25 satisfying",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F25",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:F25"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF3 is a type for the finite field with 3 elements\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "F3",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#F3",
          "type": "newtype"
        },
        "index": {
          "description": "F3 is type for the finite field with elements",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F3",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:F3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF4 is a type for the finite field with 4 elements.\n F4 is represented as the extension of F2 by an element a4 satisfying x^2+x+1 = 0\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "F4",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#F4",
          "type": "newtype"
        },
        "index": {
          "description": "F4 is type for the finite field with elements F4 is represented as the extension of F2 by an element a4 satisfying",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F4",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:F4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF5 is a type for the finite field with 5 elements\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "F5",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#F5",
          "type": "newtype"
        },
        "index": {
          "description": "F5 is type for the finite field with elements",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F5",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:F5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF7 is a type for the finite field with 7 elements\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "F7",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#F7",
          "type": "newtype"
        },
        "index": {
          "description": "F7 is type for the finite field with elements",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F7",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:F7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF8 is a type for the finite field with 8 elements.\n F8 is represented as the extension of F2 by an element a8 satisfying x^3+x+1 = 0\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "F8",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#F8",
          "type": "newtype"
        },
        "index": {
          "description": "F8 is type for the finite field with elements F8 is represented as the extension of F2 by an element a8 satisfying",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F8",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:F8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eF9 is a type for the finite field with 9 elements.\n F9 is represented as the extension of F3 by an element a9 satisfying x^2+2x+2 = 0\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "F9",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#F9",
          "type": "newtype"
        },
        "index": {
          "description": "F9 is type for the finite field with elements F9 is represented as the extension of F3 by an element a9 satisfying",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F9",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:F9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQ is just the rationals, but with a better show function than the Prelude version\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "Q",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Field.html#Q",
          "type": "newtype"
        },
        "index": {
          "description": "is just the rationals but with better show function than the Prelude version",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "Q",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#t:Q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "F11",
          "package": "HaskellForMaths",
          "signature": "F11 Int",
          "source": "src/Math-Core-Field.html#F11",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F11",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:F11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "F13",
          "package": "HaskellForMaths",
          "signature": "F13 Int",
          "source": "src/Math-Core-Field.html#F13",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F13",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:F13"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "F16",
          "package": "HaskellForMaths",
          "signature": "F16 Int",
          "source": "src/Math-Core-Field.html#F16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F16",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:F16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "F17",
          "package": "HaskellForMaths",
          "signature": "F17 Int",
          "source": "src/Math-Core-Field.html#F17",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F17",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:F17"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "F19",
          "package": "HaskellForMaths",
          "signature": "F19 Int",
          "source": "src/Math-Core-Field.html#F19",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F19",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:F19"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "F2",
          "package": "HaskellForMaths",
          "signature": "F2 Int",
          "source": "src/Math-Core-Field.html#F2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:F2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "F23",
          "package": "HaskellForMaths",
          "signature": "F23 Int",
          "source": "src/Math-Core-Field.html#F23",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F23",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:F23"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "F25",
          "package": "HaskellForMaths",
          "signature": "F25 Int",
          "source": "src/Math-Core-Field.html#F25",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F25",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:F25"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "F3",
          "package": "HaskellForMaths",
          "signature": "F3 Int",
          "source": "src/Math-Core-Field.html#F3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F3",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:F3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "F4",
          "package": "HaskellForMaths",
          "signature": "F4 Int",
          "source": "src/Math-Core-Field.html#F4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F4",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:F4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "F5",
          "package": "HaskellForMaths",
          "signature": "F5 Int",
          "source": "src/Math-Core-Field.html#F5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F5",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:F5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "F7",
          "package": "HaskellForMaths",
          "signature": "F7 Int",
          "source": "src/Math-Core-Field.html#F7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F7",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:F7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "F8",
          "package": "HaskellForMaths",
          "signature": "F8 Int",
          "source": "src/Math-Core-Field.html#F8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F8",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:F8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "F9",
          "package": "HaskellForMaths",
          "signature": "F9 Int",
          "source": "src/Math-Core-Field.html#F9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "F9",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:F9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "Q",
          "package": "HaskellForMaths",
          "signature": "Q Rational",
          "source": "src/Math-Core-Field.html#Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "Q",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:Q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea16 is a primitive element for F16 as an extension over F2. a16 satisfies x^4+x+1 = 0.\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "a16",
          "package": "HaskellForMaths",
          "signature": "F16",
          "source": "src/Math-Core-Field.html#a16",
          "type": "function"
        },
        "index": {
          "description": "a16 is primitive element for F16 as an extension over F2 a16 satisfies",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "a16",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:a16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea25 is a primitive element for F25 as an extension over F5. a25 satisfies x^2+4x+2 = 0.\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "a25",
          "package": "HaskellForMaths",
          "signature": "F25",
          "source": "src/Math-Core-Field.html#a25",
          "type": "function"
        },
        "index": {
          "description": "a25 is primitive element for F25 as an extension over F5 a25 satisfies",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "a25",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:a25"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea4 is a primitive element for F4 as an extension over F2. a4 satisfies x^2+x+1 = 0.\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "a4",
          "package": "HaskellForMaths",
          "signature": "F4",
          "source": "src/Math-Core-Field.html#a4",
          "type": "function"
        },
        "index": {
          "description": "a4 is primitive element for F4 as an extension over F2 a4 satisfies",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "a4",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:a4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea8 is a primitive element for F8 as an extension over F2. a8 satisfies x^3+x+1 = 0.\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "a8",
          "package": "HaskellForMaths",
          "signature": "F8",
          "source": "src/Math-Core-Field.html#a8",
          "type": "function"
        },
        "index": {
          "description": "a8 is primitive element for F8 as an extension over F2 a8 satisfies",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "a8",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:a8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea9 is a primitive element for F9 as an extension over F3. a9 satisfies x^2+2x+2 = 0.\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "a9",
          "package": "HaskellForMaths",
          "signature": "F9",
          "source": "src/Math-Core-Field.html#a9",
          "type": "function"
        },
        "index": {
          "description": "a9 is primitive element for F9 as an extension over F3 a9 satisfies",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "a9",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:a9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "denominatorQ",
          "package": "HaskellForMaths",
          "signature": "Q -\u003e Integer",
          "source": "src/Math-Core-Field.html#denominatorQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "denominatorQ",
          "normalized": "Q-\u003eInteger",
          "package": "HaskellForMaths",
          "signature": "Q-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:denominatorQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef11 is a list of the elements of F11\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "f11",
          "package": "HaskellForMaths",
          "signature": "[F11]",
          "source": "src/Math-Core-Field.html#f11",
          "type": "function"
        },
        "index": {
          "description": "f11 is list of the elements of F11",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "f11",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:f11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef13 is a list of the elements of F13\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "f13",
          "package": "HaskellForMaths",
          "signature": "[F13]",
          "source": "src/Math-Core-Field.html#f13",
          "type": "function"
        },
        "index": {
          "description": "f13 is list of the elements of F13",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "f13",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:f13"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef16 is a list of the elements of F16\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "f16",
          "package": "HaskellForMaths",
          "signature": "[F16]",
          "source": "src/Math-Core-Field.html#f16",
          "type": "function"
        },
        "index": {
          "description": "f16 is list of the elements of F16",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "f16",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:f16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef17 is a list of the elements of F17\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "f17",
          "package": "HaskellForMaths",
          "signature": "[F17]",
          "source": "src/Math-Core-Field.html#f17",
          "type": "function"
        },
        "index": {
          "description": "f17 is list of the elements of F17",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "f17",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:f17"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef19 is a list of the elements of F19\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "f19",
          "package": "HaskellForMaths",
          "signature": "[F19]",
          "source": "src/Math-Core-Field.html#f19",
          "type": "function"
        },
        "index": {
          "description": "f19 is list of the elements of F19",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "f19",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:f19"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef2 is a list of the elements of F2\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "f2",
          "package": "HaskellForMaths",
          "signature": "[F2]",
          "source": "src/Math-Core-Field.html#f2",
          "type": "function"
        },
        "index": {
          "description": "f2 is list of the elements of F2",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "f2",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:f2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef23 is a list of the elements of F23\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "f23",
          "package": "HaskellForMaths",
          "signature": "[F23]",
          "source": "src/Math-Core-Field.html#f23",
          "type": "function"
        },
        "index": {
          "description": "f23 is list of the elements of F23",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "f23",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:f23"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef25 is a list of the elements of F25\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "f25",
          "package": "HaskellForMaths",
          "signature": "[F25]",
          "source": "src/Math-Core-Field.html#f25",
          "type": "function"
        },
        "index": {
          "description": "f25 is list of the elements of F25",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "f25",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:f25"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef3 is a list of the elements of F3\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "f3",
          "package": "HaskellForMaths",
          "signature": "[F3]",
          "source": "src/Math-Core-Field.html#f3",
          "type": "function"
        },
        "index": {
          "description": "f3 is list of the elements of F3",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "f3",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:f3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef4 is a list of the elements of F4\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "f4",
          "package": "HaskellForMaths",
          "signature": "[F4]",
          "source": "src/Math-Core-Field.html#f4",
          "type": "function"
        },
        "index": {
          "description": "f4 is list of the elements of F4",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "f4",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:f4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef5 is a list of the elements of F5\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "f5",
          "package": "HaskellForMaths",
          "signature": "[F5]",
          "source": "src/Math-Core-Field.html#f5",
          "type": "function"
        },
        "index": {
          "description": "f5 is list of the elements of F5",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "f5",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:f5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef7 is a list of the elements of F7\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "f7",
          "package": "HaskellForMaths",
          "signature": "[F7]",
          "source": "src/Math-Core-Field.html#f7",
          "type": "function"
        },
        "index": {
          "description": "f7 is list of the elements of F7",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "f7",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:f7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef8 is a list of the elements of F8\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "f8",
          "package": "HaskellForMaths",
          "signature": "[F8]",
          "source": "src/Math-Core-Field.html#f8",
          "type": "function"
        },
        "index": {
          "description": "f8 is list of the elements of F8",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "f8",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:f8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ef9 is a list of the elements of F9\n\u003c/p\u003e",
          "module": "Math.Core.Field",
          "name": "f9",
          "package": "HaskellForMaths",
          "signature": "[F9]",
          "source": "src/Math-Core-Field.html#f9",
          "type": "function"
        },
        "index": {
          "description": "f9 is list of the elements of F9",
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "f9",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:f9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "numeratorQ",
          "package": "HaskellForMaths",
          "signature": "Q -\u003e Integer",
          "source": "src/Math-Core-Field.html#numeratorQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "numeratorQ",
          "normalized": "Q-\u003eInteger",
          "package": "HaskellForMaths",
          "signature": "Q-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:numeratorQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Field",
          "name": "powers",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [a]",
          "source": "src/Math-Core-Field.html#powers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Field",
          "module": "Math.Core.Field",
          "name": "powers",
          "normalized": "a-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Field.html#v:powers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module of simple utility functions which are used throughout the rest of the library\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Core.Utils",
          "name": "Utils",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Utils.html",
          "type": "module"
        },
        "index": {
          "description": "module of simple utility functions which are used throughout the rest of the library",
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "Utils",
          "package": "HaskellForMaths",
          "partial": "Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class of finite sets\n\u003c/p\u003e",
          "module": "Math.Core.Utils",
          "name": "FinSet",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Utils.html#FinSet",
          "type": "class"
        },
        "index": {
          "description": "The class of finite sets",
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "FinSet",
          "package": "HaskellForMaths",
          "partial": "Fin Set",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#t:FinSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class representing algebraic structures having an inverse operation.\n Note that in some cases not every element has an inverse.\n\u003c/p\u003e",
          "module": "Math.Core.Utils",
          "name": "HasInverses",
          "package": "HaskellForMaths",
          "source": "src/Math-Core-Utils.html#HasInverses",
          "type": "class"
        },
        "index": {
          "description": "class representing algebraic structures having an inverse operation Note that in some cases not every element has an inverse",
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "HasInverses",
          "package": "HaskellForMaths",
          "partial": "Has Inverses",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#t:HasInverses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA trick: x^-1 returns the inverse of x\n\u003c/p\u003e",
          "module": "Math.Core.Utils",
          "name": "(^-)",
          "package": "HaskellForMaths",
          "signature": "a -\u003e b -\u003e a",
          "source": "src/Math-Core-Utils.html#%5E-",
          "type": "function"
        },
        "index": {
          "description": "trick returns the inverse of",
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "(^-) ^-",
          "normalized": "a-\u003eb-\u003ea",
          "package": "HaskellForMaths",
          "signature": "a-\u003eb-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:-94--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003echoose n k\u003c/code\u003e is the number of ways of choosing k distinct elements from an n-set\n\u003c/p\u003e",
          "module": "Math.Core.Utils",
          "name": "choose",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Math-Core-Utils.html#choose",
          "type": "function"
        },
        "index": {
          "description": "choose is the number of ways of choosing distinct elements from an n-set",
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "choose",
          "normalized": "a-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:choose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "cmpfst",
          "package": "HaskellForMaths",
          "signature": "(a, b) -\u003e (a, b1) -\u003e Ordering",
          "source": "src/Math-Core-Utils.html#cmpfst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "cmpfst",
          "normalized": "(a,b)-\u003e(a,b)-\u003eOrdering",
          "package": "HaskellForMaths",
          "signature": "(a,b)-\u003e(a,b)-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:cmpfst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a positive integer \u003ccode\u003ek\u003c/code\u003e, and a set \u003ccode\u003exs\u003c/code\u003e, represented as a list,\n \u003ccode\u003ecombinationsOf k xs\u003c/code\u003e returns all k-element subsets of xs.\n The result will be in lex order, relative to the order of the xs.\n\u003c/p\u003e",
          "module": "Math.Core.Utils",
          "name": "combinationsOf",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e [[a]]",
          "source": "src/Math-Core-Utils.html#combinationsOf",
          "type": "function"
        },
        "index": {
          "description": "Given positive integer and set xs represented as list combinationsOf xs returns all k-element subsets of xs The result will be in lex order relative to the order of the xs",
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "combinationsOf",
          "normalized": "Int-\u003e[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Of",
          "signature": "Int-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:combinationsOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe multiset or set difference between two ascending lists. If xs and ys are ascending, then diffAsc xs ys == xs \\ ys,\n and diffAsc is more efficient. If xs and ys are sets (that is, have no repetitions), then diffAsc xs ys is the set difference.\n The code does not check that the lists are ascending.\n\u003c/p\u003e",
          "module": "Math.Core.Utils",
          "name": "diffAsc",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Core-Utils.html#diffAsc",
          "type": "function"
        },
        "index": {
          "description": "The multiset or set difference between two ascending lists If xs and ys are ascending then diffAsc xs ys xs ys and diffAsc is more efficient If xs and ys are sets that is have no repetitions then diffAsc xs ys is the set difference The code does not check that the lists are ascending",
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "diffAsc",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Asc",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:diffAsc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe multiset or set difference between two descending lists. If xs and ys are descending, then diffDesc xs ys == xs \\ ys,\n and diffDesc is more efficient. If xs and ys are sets (that is, have no repetitions), then diffDesc xs ys is the set difference.\n The code does not check that the lists are descending.\n\u003c/p\u003e",
          "module": "Math.Core.Utils",
          "name": "diffDesc",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Core-Utils.html#diffDesc",
          "type": "function"
        },
        "index": {
          "description": "The multiset or set difference between two descending lists If xs and ys are descending then diffDesc xs ys xs ys and diffDesc is more efficient If xs and ys are sets that is have no repetitions then diffDesc xs ys is the set difference The code does not check that the lists are descending",
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "diffDesc",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Desc",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:diffDesc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "elts",
          "package": "HaskellForMaths",
          "signature": "[x]",
          "source": "src/Math-Core-Utils.html#elts",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "elts",
          "normalized": "[a]",
          "package": "HaskellForMaths",
          "signature": "[x]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:elts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "eqfst",
          "package": "HaskellForMaths",
          "signature": "(a, b) -\u003e (a, b1) -\u003e Bool",
          "source": "src/Math-Core-Utils.html#eqfst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "eqfst",
          "normalized": "(a,b)-\u003e(a,b)-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "(a,b)-\u003e(a,b)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:eqfst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "foldcmpl",
          "package": "HaskellForMaths",
          "signature": "(b -\u003e b -\u003e Bool) -\u003e [b] -\u003e Bool",
          "source": "src/Math-Core-Utils.html#foldcmpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "foldcmpl",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "(b-\u003eb-\u003eBool)-\u003e[b]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:foldcmpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "fromBase",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [a] -\u003e a",
          "source": "src/Math-Core-Utils.html#fromBase",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "fromBase",
          "normalized": "a-\u003e[a]-\u003ea",
          "package": "HaskellForMaths",
          "partial": "Base",
          "signature": "a-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:fromBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "insertDesc",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/Math-Core-Utils.html#insertDesc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "insertDesc",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Desc",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:insertDesc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "inverse",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a",
          "source": "src/Math-Core-Utils.html#inverse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "inverse",
          "normalized": "a-\u003ea",
          "package": "HaskellForMaths",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:inverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "isStrictlyDecreasing",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e Bool",
          "source": "src/Math-Core-Utils.html#isStrictlyDecreasing",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "isStrictlyDecreasing",
          "normalized": "[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Strictly Decreasing",
          "signature": "[t]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:isStrictlyDecreasing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "isStrictlyIncreasing",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e Bool",
          "source": "src/Math-Core-Utils.html#isStrictlyIncreasing",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "isStrictlyIncreasing",
          "normalized": "[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Strictly Increasing",
          "signature": "[t]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:isStrictlyIncreasing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "isSubMultisetAsc",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/Math-Core-Utils.html#isSubMultisetAsc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "isSubMultisetAsc",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Sub Multiset Asc",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:isSubMultisetAsc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "isSubsetAsc",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/Math-Core-Utils.html#isSubsetAsc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "isSubsetAsc",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Subset Asc",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:isSubsetAsc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "isWeaklyDecreasing",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e Bool",
          "source": "src/Math-Core-Utils.html#isWeaklyDecreasing",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "isWeaklyDecreasing",
          "normalized": "[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Weakly Decreasing",
          "signature": "[t]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:isWeaklyDecreasing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "isWeaklyIncreasing",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e Bool",
          "source": "src/Math-Core-Utils.html#isWeaklyIncreasing",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "isWeaklyIncreasing",
          "normalized": "[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Weakly Increasing",
          "signature": "[t]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:isWeaklyIncreasing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe multiset sum of two ascending lists. If xs and ys are ascending, then multisetSumAsc xs ys == sort (xs++ys).\n The code does not check that the lists are ascending.\n\u003c/p\u003e",
          "module": "Math.Core.Utils",
          "name": "multisetSumAsc",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Core-Utils.html#multisetSumAsc",
          "type": "function"
        },
        "index": {
          "description": "The multiset sum of two ascending lists If xs and ys are ascending then multisetSumAsc xs ys sort xs ys The code does not check that the lists are ascending",
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "multisetSumAsc",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Sum Asc",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:multisetSumAsc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe multiset sum of two descending lists. If xs and ys are descending, then multisetSumDesc xs ys == sort (xs++ys).\n The code does not check that the lists are descending.\n\u003c/p\u003e",
          "module": "Math.Core.Utils",
          "name": "multisetSumDesc",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Core-Utils.html#multisetSumDesc",
          "type": "function"
        },
        "index": {
          "description": "The multiset sum of two descending lists If xs and ys are descending then multisetSumDesc xs ys sort xs ys The code does not check that the lists are descending",
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "multisetSumDesc",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Sum Desc",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:multisetSumDesc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "ordpair",
          "package": "HaskellForMaths",
          "signature": "t -\u003e t -\u003e (t, t)",
          "source": "src/Math-Core-Utils.html#ordpair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "ordpair",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "HaskellForMaths",
          "signature": "t-\u003et-\u003e(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:ordpair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "pairs",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [(a, a)]",
          "source": "src/Math-Core-Utils.html#pairs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "pairs",
          "normalized": "[a]-\u003e[(a,a)]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:pairs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a set \u003ccode\u003exs\u003c/code\u003e, represented as an ordered list, \u003ccode\u003epowersetbfs xs\u003c/code\u003e returns the list of all subsets of xs, in shortlex order\n\u003c/p\u003e",
          "module": "Math.Core.Utils",
          "name": "powersetbfs",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Math-Core-Utils.html#powersetbfs",
          "type": "function"
        },
        "index": {
          "description": "Given set xs represented as an ordered list powersetbfs xs returns the list of all subsets of xs in shortlex order",
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "powersetbfs",
          "normalized": "[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:powersetbfs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a set \u003ccode\u003exs\u003c/code\u003e, represented as an ordered list, \u003ccode\u003epowersetdfs xs\u003c/code\u003e returns the list of all subsets of xs, in lex order\n\u003c/p\u003e",
          "module": "Math.Core.Utils",
          "name": "powersetdfs",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Math-Core-Utils.html#powersetdfs",
          "type": "function"
        },
        "index": {
          "description": "Given set xs represented as an ordered list powersetdfs xs returns the list of all subsets of xs in lex order",
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "powersetdfs",
          "normalized": "[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:powersetdfs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set union of two ascending lists. If both inputs are strictly increasing, then the output is their union\n and is strictly increasing. The code does not check that the lists are strictly increasing.\n\u003c/p\u003e",
          "module": "Math.Core.Utils",
          "name": "setUnionAsc",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Core-Utils.html#setUnionAsc",
          "type": "function"
        },
        "index": {
          "description": "The set union of two ascending lists If both inputs are strictly increasing then the output is their union and is strictly increasing The code does not check that the lists are strictly increasing",
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "setUnionAsc",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Union Asc",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:setUnionAsc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "sortDesc",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a]",
          "source": "src/Math-Core-Utils.html#sortDesc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "sortDesc",
          "normalized": "[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Desc",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:sortDesc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Core.Utils",
          "name": "toSet",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a]",
          "source": "src/Math-Core-Utils.html#toSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Core Utils",
          "module": "Math.Core.Utils",
          "name": "toSet",
          "normalized": "[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "Set",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Core-Utils.html#v:toSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module for finding prime factors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Factor",
          "name": "Factor",
          "package": "HaskellForMaths",
          "source": "src/Math-NumberTheory-Factor.html",
          "type": "module"
        },
        "index": {
          "description": "module for finding prime factors",
          "hierarchy": "Math NumberTheory Factor",
          "module": "Math.NumberTheory.Factor",
          "name": "Factor",
          "package": "HaskellForMaths",
          "partial": "Factor",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-Factor.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList the prime factors of n (with multiplicity).\n The algorithm uses trial division to find small factors,\n followed if necessary by the elliptic curve method to find larger factors.\n The running time increases with the size of the second largest prime factor of n.\n It can find 10-digit prime factors in seconds, but can struggle with 20-digit prime factors.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Factor",
          "name": "pfactors",
          "package": "HaskellForMaths",
          "signature": "Integer -\u003e [Integer]",
          "source": "src/Math-NumberTheory-Factor.html#pfactors",
          "type": "function"
        },
        "index": {
          "description": "List the prime factors of with multiplicity The algorithm uses trial division to find small factors followed if necessary by the elliptic curve method to find larger factors The running time increases with the size of the second largest prime factor of It can find digit prime factors in seconds but can struggle with digit prime factors",
          "hierarchy": "Math NumberTheory Factor",
          "module": "Math.NumberTheory.Factor",
          "name": "pfactors",
          "normalized": "Integer-\u003e[Integer]",
          "package": "HaskellForMaths",
          "signature": "Integer-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-Factor.html#v:pfactors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module providing functions to test for primality, and find next and previous primes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Prime",
          "name": "Prime",
          "package": "HaskellForMaths",
          "source": "src/Math-NumberTheory-Prime.html",
          "type": "module"
        },
        "index": {
          "description": "module providing functions to test for primality and find next and previous primes",
          "hierarchy": "Math NumberTheory Prime",
          "module": "Math.NumberTheory.Prime",
          "name": "Prime",
          "package": "HaskellForMaths",
          "partial": "Prime",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-Prime.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Prime",
          "name": "isMillerRabinPrime",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Bool",
          "source": "src/Math-NumberTheory-Prime.html#isMillerRabinPrime",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Prime",
          "module": "Math.NumberTheory.Prime",
          "name": "isMillerRabinPrime",
          "normalized": "a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Miller Rabin Prime",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-Prime.html#v:isMillerRabinPrime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs this number prime? The algorithm consists of using trial division to test for very small factors,\n followed if necessary by the Miller-Rabin probabilistic test.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Prime",
          "name": "isPrime",
          "package": "HaskellForMaths",
          "signature": "Integer -\u003e Bool",
          "source": "src/Math-NumberTheory-Prime.html#isPrime",
          "type": "function"
        },
        "index": {
          "description": "Is this number prime The algorithm consists of using trial division to test for very small factors followed if necessary by the Miller-Rabin probabilistic test",
          "hierarchy": "Math NumberTheory Prime",
          "module": "Math.NumberTheory.Prime",
          "name": "isPrime",
          "normalized": "Integer-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Prime",
          "signature": "Integer-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-Prime.html#v:isPrime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Prime",
          "name": "isTrialDivisionPrime",
          "package": "HaskellForMaths",
          "signature": "Integer -\u003e Bool",
          "source": "src/Math-NumberTheory-Prime.html#isTrialDivisionPrime",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Prime",
          "module": "Math.NumberTheory.Prime",
          "name": "isTrialDivisionPrime",
          "normalized": "Integer-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Trial Division Prime",
          "signature": "Integer-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-Prime.html#v:isTrialDivisionPrime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven n, \u003ccode\u003enextPrime n\u003c/code\u003e returns the least p, p \u003e n, such that p is prime\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Prime",
          "name": "nextPrime",
          "package": "HaskellForMaths",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Prime.html#nextPrime",
          "type": "function"
        },
        "index": {
          "description": "Given nextPrime returns the least such that is prime",
          "hierarchy": "Math NumberTheory Prime",
          "module": "Math.NumberTheory.Prime",
          "name": "nextPrime",
          "normalized": "Integer-\u003eInteger",
          "package": "HaskellForMaths",
          "partial": "Prime",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-Prime.html#v:nextPrime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Prime",
          "name": "notPrime",
          "package": "HaskellForMaths",
          "signature": "Integer -\u003e Bool",
          "source": "src/Math-NumberTheory-Prime.html#notPrime",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Prime",
          "module": "Math.NumberTheory.Prime",
          "name": "notPrime",
          "normalized": "Integer-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Prime",
          "signature": "Integer-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-Prime.html#v:notPrime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven n, \u003ccode\u003eprevPrime n\u003c/code\u003e returns the greatest p, p \u003c n, such that p is prime\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Prime",
          "name": "prevPrime",
          "package": "HaskellForMaths",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Prime.html#prevPrime",
          "type": "function"
        },
        "index": {
          "description": "Given prevPrime returns the greatest such that is prime",
          "hierarchy": "Math NumberTheory Prime",
          "module": "Math.NumberTheory.Prime",
          "name": "prevPrime",
          "normalized": "Integer-\u003eInteger",
          "package": "HaskellForMaths",
          "partial": "Prime",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-Prime.html#v:prevPrime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA (lazy) list of the primes\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Prime",
          "name": "primes",
          "package": "HaskellForMaths",
          "signature": "[Integer]",
          "source": "src/Math-NumberTheory-Prime.html#primes",
          "type": "function"
        },
        "index": {
          "description": "lazy list of the primes",
          "hierarchy": "Math NumberTheory Prime",
          "module": "Math.NumberTheory.Prime",
          "name": "primes",
          "normalized": "[Integer]",
          "package": "HaskellForMaths",
          "signature": "[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-Prime.html#v:primes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module for arithmetic in quadratic number fields. A quadratic number field is a field of the form Q(sqrt d),\n where d is a square-free integer. For example, we can perform the following calculation in Q(sqrt 2):\n\u003c/p\u003e\u003cpre\u003e (1 + sqrt 2) / (2 + sqrt 2)\n\u003c/pre\u003e\u003cp\u003eIt is also possible to mix different square roots in the same calculation. For example:\n\u003c/p\u003e\u003cpre\u003e (1 + sqrt 2) * (1 + sqrt 3)\n\u003c/pre\u003e\u003cp\u003eSquare roots of negative numbers are also permitted. For example:\n\u003c/p\u003e\u003cpre\u003e i * sqrt(-3)\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "QuadraticField",
          "package": "HaskellForMaths",
          "source": "src/Math-NumberTheory-QuadraticField.html",
          "type": "module"
        },
        "index": {
          "description": "module for arithmetic in quadratic number fields quadratic number field is field of the form sqrt where is square-free integer For example we can perform the following calculation in sqrt sqrt sqrt It is also possible to mix different square roots in the same calculation For example sqrt sqrt Square roots of negative numbers are also permitted For example sqrt",
          "hierarchy": "Math NumberTheory QuadraticField",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "QuadraticField",
          "package": "HaskellForMaths",
          "partial": "Quadratic Field",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-QuadraticField.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type for elements of quadratic number fields\n\u003c/p\u003e",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "QNF",
          "package": "HaskellForMaths",
          "source": "src/Math-NumberTheory-QuadraticField.html#QNF",
          "type": "type"
        },
        "index": {
          "description": "The type for elements of quadratic number fields",
          "hierarchy": "Math NumberTheory QuadraticField",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "QNF",
          "package": "HaskellForMaths",
          "partial": "QNF",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-QuadraticField.html#t:QNF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA basis for quadratic number fields Q(sqrt d), where d is a square-free integer.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "QNFBasis",
          "package": "HaskellForMaths",
          "source": "src/Math-NumberTheory-QuadraticField.html#QNFBasis",
          "type": "data"
        },
        "index": {
          "description": "basis for quadratic number fields sqrt where is square-free integer",
          "hierarchy": "Math NumberTheory QuadraticField",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "QNFBasis",
          "package": "HaskellForMaths",
          "partial": "QNFBasis",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-QuadraticField.html#t:QNFBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.QuadraticField",
          "name": "XVar",
          "package": "HaskellForMaths",
          "source": "src/Math-NumberTheory-QuadraticField.html#XVar",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math NumberTheory QuadraticField",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "XVar",
          "package": "HaskellForMaths",
          "partial": "XVar",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-QuadraticField.html#t:XVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.QuadraticField",
          "name": "One",
          "package": "HaskellForMaths",
          "signature": "One",
          "source": "src/Math-NumberTheory-QuadraticField.html#QNFBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory QuadraticField",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "One",
          "package": "HaskellForMaths",
          "partial": "One",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-QuadraticField.html#v:One"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.QuadraticField",
          "name": "Sqrt",
          "package": "HaskellForMaths",
          "signature": "Sqrt Integer",
          "source": "src/Math-NumberTheory-QuadraticField.html#QNFBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory QuadraticField",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "Sqrt",
          "package": "HaskellForMaths",
          "partial": "Sqrt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-QuadraticField.html#v:Sqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.QuadraticField",
          "name": "X",
          "package": "HaskellForMaths",
          "signature": "X Int",
          "source": "src/Math-NumberTheory-QuadraticField.html#XVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory QuadraticField",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "X",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-QuadraticField.html#v:X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.QuadraticField",
          "name": "i",
          "package": "HaskellForMaths",
          "signature": "QNF",
          "source": "src/Math-NumberTheory-QuadraticField.html#i",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory QuadraticField",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "i",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-QuadraticField.html#v:i"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlthough this has the same name as the Prelude.sqrt function, it should be thought of as more like a constructor\n for creating elements of quadratic fields.\n\u003c/p\u003e\u003cp\u003eNote that for d positive, sqrt d means the positive square root, and sqrt (-d) should be interpreted as the square root\n with positive imaginary part, that is i * sqrt d. This has the consequence that for example, sqrt (-2) * sqrt (-3) = - sqrt 6.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "sqrt",
          "package": "HaskellForMaths",
          "signature": "Integer -\u003e QNF",
          "source": "src/Math-NumberTheory-QuadraticField.html#sqrt",
          "type": "function"
        },
        "index": {
          "description": "Although this has the same name as the Prelude.sqrt function it should be thought of as more like constructor for creating elements of quadratic fields Note that for positive sqrt means the positive square root and sqrt should be interpreted as the square root with positive imaginary part that is sqrt This has the consequence that for example sqrt sqrt sqrt",
          "hierarchy": "Math NumberTheory QuadraticField",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "sqrt",
          "normalized": "Integer-\u003eQNF",
          "package": "HaskellForMaths",
          "signature": "Integer-\u003eQNF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-QuadraticField.html#v:sqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.QuadraticField",
          "name": "sqrt2",
          "package": "HaskellForMaths",
          "signature": "QNF",
          "source": "src/Math-NumberTheory-QuadraticField.html#sqrt2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory QuadraticField",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "sqrt2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-QuadraticField.html#v:sqrt2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.QuadraticField",
          "name": "sqrt3",
          "package": "HaskellForMaths",
          "signature": "QNF",
          "source": "src/Math-NumberTheory-QuadraticField.html#sqrt3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory QuadraticField",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "sqrt3",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-QuadraticField.html#v:sqrt3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.QuadraticField",
          "name": "sqrt5",
          "package": "HaskellForMaths",
          "signature": "QNF",
          "source": "src/Math-NumberTheory-QuadraticField.html#sqrt5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory QuadraticField",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "sqrt5",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-QuadraticField.html#v:sqrt5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.QuadraticField",
          "name": "sqrt6",
          "package": "HaskellForMaths",
          "signature": "QNF",
          "source": "src/Math-NumberTheory-QuadraticField.html#sqrt6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory QuadraticField",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "sqrt6",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-QuadraticField.html#v:sqrt6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.QuadraticField",
          "name": "sqrt7",
          "package": "HaskellForMaths",
          "signature": "QNF",
          "source": "src/Math-NumberTheory-QuadraticField.html#sqrt7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory QuadraticField",
          "module": "Math.NumberTheory.QuadraticField",
          "name": "sqrt7",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-NumberTheory-QuadraticField.html#v:sqrt7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "Classical",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "Classical",
          "package": "HaskellForMaths",
          "partial": "Classical",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "b",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e [Permutation [a]]",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#b",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "b",
          "normalized": "Int-\u003e[a]-\u003e[Permutation[a]]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[a]-\u003e[Permutation[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:b"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "d",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e [Permutation [a]]",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#d",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "d",
          "normalized": "Int-\u003e[a]-\u003e[Permutation[a]]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[a]-\u003e[Permutation[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:d"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "elemTransvection",
          "package": "HaskellForMaths",
          "signature": "t1 -\u003e (t1, t1) -\u003e t -\u003e [[t]]",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#elemTransvection",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "elemTransvection",
          "normalized": "a-\u003e(a,a)-\u003ea-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Transvection",
          "signature": "t-\u003e(t,t)-\u003et-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:elemTransvection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe projective special linear group PSL(n,Fq) == A(n,Fq) == SL(n,Fq)/Z,\n returned as permutations of the points of PG(n-1,Fq).\n This is a finite simple group provided n\u003e2 or q\u003e3.\n\u003c/p\u003e",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "l",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [k] -\u003e [Permutation [k]]",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#l",
          "type": "function"
        },
        "index": {
          "description": "The projective special linear group PSL Fq Fq SL Fq returned as permutations of the points of PG n-1 Fq This is finite simple group provided or",
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "l",
          "normalized": "Int-\u003e[a]-\u003e[Permutation[a]]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[k]-\u003e[Permutation[k]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "numPtsAG",
          "package": "HaskellForMaths",
          "signature": "b -\u003e a -\u003e a",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#numPtsAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "numPtsAG",
          "normalized": "a-\u003eb-\u003eb",
          "package": "HaskellForMaths",
          "partial": "Pts AG",
          "signature": "b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:numPtsAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "numPtsPG",
          "package": "HaskellForMaths",
          "signature": "b -\u003e a -\u003e a",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#numPtsPG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "numPtsPG",
          "normalized": "a-\u003eb-\u003eb",
          "package": "HaskellForMaths",
          "partial": "Pts PG",
          "signature": "b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:numPtsPG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "o",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e [Permutation [a]]",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#o",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "o",
          "normalized": "Int-\u003e[a]-\u003e[Permutation[a]]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[a]-\u003e[Permutation[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:o"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "omegaeven",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e t -\u003e [[[t1]]]",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#omegaeven",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "omegaeven",
          "normalized": "Int-\u003ea-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003et-\u003e[[[t]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:omegaeven"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "omegaodd",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [a] -\u003e [[[t]]]",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#omegaodd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "omegaodd",
          "normalized": "Int-\u003e[a]-\u003e[[[b]]]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[a]-\u003e[[[t]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:omegaodd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "orderL",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#orderL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "orderL",
          "normalized": "a-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:orderL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "orderS",
          "package": "HaskellForMaths",
          "signature": "b -\u003e a -\u003e a",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#orderS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "orderS",
          "normalized": "a-\u003eb-\u003eb",
          "package": "HaskellForMaths",
          "signature": "b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:orderS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "orderS2",
          "package": "HaskellForMaths",
          "signature": "b -\u003e a -\u003e a",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#orderS2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "orderS2",
          "normalized": "a-\u003eb-\u003eb",
          "package": "HaskellForMaths",
          "signature": "b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:orderS2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "s",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [k] -\u003e [Permutation [k]]",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#s",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "s",
          "normalized": "Int-\u003e[a]-\u003e[Permutation[a]]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[k]-\u003e[Permutation[k]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:s"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe projective symplectic group PSp(2n,Fq) == Cn(Fq) == Sp(2n,Fq)/Z,\n returned as permutations of the points of PG(2n-1,Fq).\n This is a finite simple group for n\u003e1, except for PSp(4,F2).\n\u003c/p\u003e",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "s2",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [k] -\u003e [Permutation [k]]",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#s2",
          "type": "function"
        },
        "index": {
          "description": "The projective symplectic group PSp Fq Cn Fq Sp Fq returned as permutations of the points of PG n-1 Fq This is finite simple group for except for PSp F2",
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "s2",
          "normalized": "Int-\u003e[a]-\u003e[Permutation[a]]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[k]-\u003e[Permutation[k]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:s2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe special linear group SL(n,Fq), generated by elementary transvections, returned as matrices\n\u003c/p\u003e",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "sl",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [k] -\u003e [[[k]]]",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#sl",
          "type": "function"
        },
        "index": {
          "description": "The special linear group SL Fq generated by elementary transvections returned as matrices",
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "sl",
          "normalized": "Int-\u003e[a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[k]-\u003e[[[k]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:sl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe symplectic group Sp(2n,Fq), returned as matrices\n\u003c/p\u003e",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "sp2",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [k] -\u003e [[[k]]]",
          "source": "src/Math-Projects-ChevalleyGroup-Classical.html#sp2",
          "type": "function"
        },
        "index": {
          "description": "The symplectic group Sp Fq returned as matrices",
          "hierarchy": "Math Projects ChevalleyGroup Classical",
          "module": "Math.Projects.ChevalleyGroup.Classical",
          "name": "sp2",
          "normalized": "Int-\u003e[a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e[k]-\u003e[[[k]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Classical.html#v:sp2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "Exceptional",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "Exceptional",
          "package": "HaskellForMaths",
          "partial": "Exceptional",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "Octonion",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#Octonion",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "Octonion",
          "package": "HaskellForMaths",
          "partial": "Octonion",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#t:Octonion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "(%^)",
          "package": "HaskellForMaths",
          "signature": "Octonion k -\u003e [[k]] -\u003e Octonion k",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#%25%5E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "(%^) %^",
          "normalized": "Octonion a-\u003e[[a]]-\u003eOctonion a",
          "package": "HaskellForMaths",
          "signature": "Octonion k-\u003e[[k]]-\u003eOctonion k",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:-37--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "O",
          "package": "HaskellForMaths",
          "signature": "O [(Int, k)]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#Octonion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "O",
          "normalized": "O[(Int,a)]",
          "package": "HaskellForMaths",
          "signature": "O[(Int,k)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:O"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "alpha3",
          "package": "HaskellForMaths",
          "signature": "[[F3]]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#alpha3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "alpha3",
          "normalized": "[[F]]",
          "package": "HaskellForMaths",
          "signature": "[[F]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:alpha3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "alpha3'",
          "package": "HaskellForMaths",
          "signature": "Permutation (Octonion F3)",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#alpha3%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "alpha3'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:alpha3-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "alpha4",
          "package": "HaskellForMaths",
          "signature": "[[F4]]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#alpha4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "alpha4",
          "normalized": "[[F]]",
          "package": "HaskellForMaths",
          "signature": "[[F]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:alpha4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "alpha4'",
          "package": "HaskellForMaths",
          "signature": "Permutation (Octonion F4)",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#alpha4%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "alpha4'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:alpha4-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "antiCommutes",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#antiCommutes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "antiCommutes",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Commutes",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:antiCommutes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "autFrom",
          "package": "HaskellForMaths",
          "signature": "Octonion t -\u003e Octonion t -\u003e Octonion t -\u003e [[t]]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#autFrom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "autFrom",
          "normalized": "Octonion a-\u003eOctonion a-\u003eOctonion a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "From",
          "signature": "Octonion t-\u003eOctonion t-\u003eOctonion t-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:autFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "beta3",
          "package": "HaskellForMaths",
          "signature": "[[F3]]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#beta3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "beta3",
          "normalized": "[[F]]",
          "package": "HaskellForMaths",
          "signature": "[[F]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:beta3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "beta3'",
          "package": "HaskellForMaths",
          "signature": "Permutation (Octonion F3)",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#beta3%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "beta3'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:beta3-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "beta4",
          "package": "HaskellForMaths",
          "signature": "[[F4]]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#beta4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "beta4",
          "normalized": "[[F]]",
          "package": "HaskellForMaths",
          "signature": "[[F]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:beta4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "beta4'",
          "package": "HaskellForMaths",
          "signature": "Permutation (Octonion F4)",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#beta4%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "beta4'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:beta4-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "conj",
          "package": "HaskellForMaths",
          "signature": "Octonion k -\u003e Octonion k",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#conj",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "conj",
          "normalized": "Octonion a-\u003eOctonion a",
          "package": "HaskellForMaths",
          "signature": "Octonion k-\u003eOctonion k",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:conj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "expose",
          "package": "HaskellForMaths",
          "signature": "Octonion t -\u003e [(Int, t)]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#expose",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "expose",
          "normalized": "Octonion a-\u003e[(Int,a)]",
          "package": "HaskellForMaths",
          "signature": "Octonion t-\u003e[(Int,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:expose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "fromList",
          "package": "HaskellForMaths",
          "signature": "[k] -\u003e Octonion k",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "fromList",
          "normalized": "[a]-\u003eOctonion a",
          "package": "HaskellForMaths",
          "partial": "List",
          "signature": "[k]-\u003eOctonion k",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerators for G2(3), a finite simple group of order 4245696,\n as a permutation group on the 702 unit imaginary octonions over F3\n\u003c/p\u003e",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "g2_3",
          "package": "HaskellForMaths",
          "signature": "[Permutation (Octonion F3)]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#g2_3",
          "type": "function"
        },
        "index": {
          "description": "Generators for G2 finite simple group of order as permutation group on the unit imaginary octonions over F3",
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "g2_3",
          "normalized": "[Permutation(Octonion F)]",
          "package": "HaskellForMaths",
          "signature": "[Permutation(Octonion F)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:g2_3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "gamma3",
          "package": "HaskellForMaths",
          "signature": "[[F3]]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#gamma3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "gamma3",
          "normalized": "[[F]]",
          "package": "HaskellForMaths",
          "signature": "[[F]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:gamma3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "gamma3'",
          "package": "HaskellForMaths",
          "signature": "Permutation (Octonion F3)",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#gamma3%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "gamma3'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:gamma3-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "gamma3s",
          "package": "HaskellForMaths",
          "signature": "[Octonion F3]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#gamma3s",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "gamma3s",
          "normalized": "[Octonion F]",
          "package": "HaskellForMaths",
          "signature": "[Octonion F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:gamma3s"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "gamma4",
          "package": "HaskellForMaths",
          "signature": "[[F4]]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#gamma4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "gamma4",
          "normalized": "[[F]]",
          "package": "HaskellForMaths",
          "signature": "[[F]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:gamma4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "gamma4'",
          "package": "HaskellForMaths",
          "signature": "Permutation (Octonion F4)",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#gamma4%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "gamma4'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:gamma4-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "gamma4s",
          "package": "HaskellForMaths",
          "signature": "[Octonion F4]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#gamma4s",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "gamma4s",
          "normalized": "[Octonion F]",
          "package": "HaskellForMaths",
          "signature": "[Octonion F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:gamma4s"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "i0",
          "package": "HaskellForMaths",
          "signature": "Octonion Q",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#i0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "i0",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:i0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "i1",
          "package": "HaskellForMaths",
          "signature": "Octonion Q",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#i0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "i1",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:i1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "i2",
          "package": "HaskellForMaths",
          "signature": "Octonion Q",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#i0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "i2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:i2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "i3",
          "package": "HaskellForMaths",
          "signature": "Octonion Q",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#i0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "i3",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:i3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "i4",
          "package": "HaskellForMaths",
          "signature": "Octonion Q",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#i0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "i4",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:i4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "i5",
          "package": "HaskellForMaths",
          "signature": "Octonion Q",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#i0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "i5",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:i5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "i6",
          "package": "HaskellForMaths",
          "signature": "Octonion Q",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#i0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "i6",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:i6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "isOrthogonal",
          "package": "HaskellForMaths",
          "signature": "Octonion a -\u003e Octonion a -\u003e Bool",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#isOrthogonal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "isOrthogonal",
          "normalized": "Octonion a-\u003eOctonion a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Orthogonal",
          "signature": "Octonion a-\u003eOctonion a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:isOrthogonal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "isUnit",
          "package": "HaskellForMaths",
          "signature": "Octonion a -\u003e Bool",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#isUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "isUnit",
          "normalized": "Octonion a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Unit",
          "signature": "Octonion a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:isUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "m",
          "package": "HaskellForMaths",
          "signature": "(a, t) -\u003e (a, t) -\u003e (a, t)",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#m",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "m",
          "normalized": "(a,b)-\u003e(a,b)-\u003e(a,b)",
          "package": "HaskellForMaths",
          "signature": "(a,t)-\u003e(a,t)-\u003e(a,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "nf",
          "package": "HaskellForMaths",
          "signature": "[(t, t1)] -\u003e [(t, t1)]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#nf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "nf",
          "normalized": "[(a,a)]-\u003e[(a,a)]",
          "package": "HaskellForMaths",
          "signature": "[(t,t)]-\u003e[(t,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:nf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "octonions",
          "package": "HaskellForMaths",
          "signature": "[k] -\u003e [Octonion k]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#octonions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "octonions",
          "normalized": "[a]-\u003e[Octonion a]",
          "package": "HaskellForMaths",
          "signature": "[k]-\u003e[Octonion k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:octonions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "sqnorm",
          "package": "HaskellForMaths",
          "signature": "Octonion a -\u003e a",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#sqnorm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "sqnorm",
          "normalized": "Octonion a-\u003ea",
          "package": "HaskellForMaths",
          "signature": "Octonion a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:sqnorm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "toList",
          "package": "HaskellForMaths",
          "signature": "Octonion a -\u003e [a]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#toList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "toList",
          "normalized": "Octonion a-\u003e[a]",
          "package": "HaskellForMaths",
          "partial": "List",
          "signature": "Octonion a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "unitImagOctonions",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [Octonion a]",
          "source": "src/Math-Projects-ChevalleyGroup-Exceptional.html#unitImagOctonions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects ChevalleyGroup Exceptional",
          "module": "Math.Projects.ChevalleyGroup.Exceptional",
          "name": "unitImagOctonions",
          "normalized": "[a]-\u003e[Octonion a]",
          "package": "HaskellForMaths",
          "partial": "Imag Octonions",
          "signature": "[a]-\u003e[Octonion a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-ChevalleyGroup-Exceptional.html#v:unitImagOctonions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "Braid",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-KnotTheory-Braid.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory Braid",
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "Braid",
          "package": "HaskellForMaths",
          "partial": "Braid",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-Braid.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "BraidGens",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-KnotTheory-Braid.html#BraidGens",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory Braid",
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "BraidGens",
          "package": "HaskellForMaths",
          "partial": "Braid Gens",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-Braid.html#t:BraidGens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "LPQ",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-KnotTheory-Braid.html#LPQ",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory Braid",
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "LPQ",
          "package": "HaskellForMaths",
          "partial": "LPQ",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-Braid.html#t:LPQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "S",
          "package": "HaskellForMaths",
          "signature": "S Int",
          "source": "src/Math-Projects-KnotTheory-Braid.html#BraidGens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory Braid",
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "S",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-Braid.html#v:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "k3_1",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ BraidGens",
          "source": "src/Math-Projects-KnotTheory-Braid.html#k3_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory Braid",
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "k3_1",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-Braid.html#v:k3_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "k4_1",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ BraidGens",
          "source": "src/Math-Projects-KnotTheory-Braid.html#k4_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory Braid",
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "k4_1",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-Braid.html#v:k4_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "k5_1",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ BraidGens",
          "source": "src/Math-Projects-KnotTheory-Braid.html#k5_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory Braid",
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "k5_1",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-Braid.html#v:k5_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "k7_1",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ BraidGens",
          "source": "src/Math-Projects-KnotTheory-Braid.html#k7_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory Braid",
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "k7_1",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-Braid.html#v:k7_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "s1",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ BraidGens",
          "source": "src/Math-Projects-KnotTheory-Braid.html#s1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory Braid",
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "s1",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-Braid.html#v:s1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "s2",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ BraidGens",
          "source": "src/Math-Projects-KnotTheory-Braid.html#s2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory Braid",
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "s2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-Braid.html#v:s2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "s3",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ BraidGens",
          "source": "src/Math-Projects-KnotTheory-Braid.html#s3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory Braid",
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "s3",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-Braid.html#v:s3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "s4",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ BraidGens",
          "source": "src/Math-Projects-KnotTheory-Braid.html#s4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory Braid",
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "s4",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-Braid.html#v:s4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "s_",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e NPoly LPQ BraidGens",
          "source": "src/Math-Projects-KnotTheory-Braid.html#s_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory Braid",
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "s_",
          "normalized": "Int-\u003eNPoly LPQ BraidGens",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eNPoly LPQ BraidGens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-Braid.html#v:s_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "writhe",
          "package": "HaskellForMaths",
          "signature": "NPoly t BraidGens -\u003e Int",
          "source": "src/Math-Projects-KnotTheory-Braid.html#writhe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory Braid",
          "module": "Math.Projects.KnotTheory.Braid",
          "name": "writhe",
          "normalized": "NPoly a BraidGens-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "NPoly t BraidGens-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-Braid.html#v:writhe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "IwahoriHecke",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "IwahoriHecke",
          "package": "HaskellForMaths",
          "partial": "Iwahori Hecke",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "IwahoriHeckeGens",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#IwahoriHeckeGens",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "IwahoriHeckeGens",
          "package": "HaskellForMaths",
          "partial": "Iwahori Hecke Gens",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#t:IwahoriHeckeGens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "T",
          "package": "HaskellForMaths",
          "signature": "T Int",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#IwahoriHeckeGens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "T",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "coeffs",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly t -\u003e LaurentMPoly t -\u003e [LaurentMPoly t]",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#coeffs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "coeffs",
          "normalized": "LaurentMPoly a-\u003eLaurentMPoly a-\u003e[LaurentMPoly a]",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly t-\u003eLaurentMPoly t-\u003e[LaurentMPoly t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:coeffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "dimIH",
          "package": "HaskellForMaths",
          "signature": "NPoly t IwahoriHeckeGens -\u003e Int",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#dimIH",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "dimIH",
          "normalized": "NPoly a IwahoriHeckeGens-\u003eInt",
          "package": "HaskellForMaths",
          "partial": "IH",
          "signature": "NPoly t IwahoriHeckeGens-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:dimIH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "fromBraid",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ BraidGens -\u003e NPoly LPQ IwahoriHeckeGens",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#fromBraid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "fromBraid",
          "normalized": "NPoly LPQ BraidGens-\u003eNPoly LPQ IwahoriHeckeGens",
          "package": "HaskellForMaths",
          "partial": "Braid",
          "signature": "NPoly LPQ BraidGens-\u003eNPoly LPQ IwahoriHeckeGens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:fromBraid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "homfly",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e NPoly LPQ BraidGens -\u003e LaurentMPoly Q",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#homfly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "homfly",
          "normalized": "Int-\u003eNPoly LPQ BraidGens-\u003eLaurentMPoly Q",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eNPoly LPQ BraidGens-\u003eLaurentMPoly Q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:homfly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "homfly'",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e NPoly LPQ BraidGens -\u003e LaurentMPoly Q",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#homfly%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "homfly'",
          "normalized": "Int-\u003eNPoly LPQ BraidGens-\u003eLaurentMPoly Q",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eNPoly LPQ BraidGens-\u003eLaurentMPoly Q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:homfly-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "homfly''",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e NPoly LPQ BraidGens -\u003e LaurentMPoly (LaurentMPoly Q)",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#homfly%27%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "homfly''",
          "normalized": "Int-\u003eNPoly LPQ BraidGens-\u003eLaurentMPoly(LaurentMPoly Q)",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eNPoly LPQ BraidGens-\u003eLaurentMPoly(LaurentMPoly Q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:homfly-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "i",
          "package": "HaskellForMaths",
          "signature": "LPQ",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#i",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "i",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:i"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "ihBasis",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [NPoly LPQ IwahoriHeckeGens]",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#ihBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "ihBasis",
          "normalized": "Int-\u003e[NPoly LPQ IwahoriHeckeGens]",
          "package": "HaskellForMaths",
          "partial": "Basis",
          "signature": "Int-\u003e[NPoly LPQ IwahoriHeckeGens]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:ihBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "ihRelations",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [NPoly LPQ IwahoriHeckeGens]",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#ihRelations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "ihRelations",
          "normalized": "Int-\u003e[NPoly LPQ IwahoriHeckeGens]",
          "package": "HaskellForMaths",
          "partial": "Relations",
          "signature": "Int-\u003e[NPoly LPQ IwahoriHeckeGens]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:ihRelations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "ihnf",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ IwahoriHeckeGens -\u003e NPoly LPQ IwahoriHeckeGens",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#ihnf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "ihnf",
          "normalized": "NPoly LPQ IwahoriHeckeGens-\u003eNPoly LPQ IwahoriHeckeGens",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ IwahoriHeckeGens-\u003eNPoly LPQ IwahoriHeckeGens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:ihnf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "jones'",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e NPoly LPQ BraidGens -\u003e LaurentMPoly Q",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#jones%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "jones'",
          "normalized": "Int-\u003eNPoly LPQ BraidGens-\u003eLaurentMPoly Q",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eNPoly LPQ BraidGens-\u003eLaurentMPoly Q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:jones-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "l",
          "package": "HaskellForMaths",
          "signature": "LPQ",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#l",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "l",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "m",
          "package": "HaskellForMaths",
          "signature": "LPQ",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#m",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "m",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "q",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly Q",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "q",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "q'",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ IwahoriHeckeGens",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#q%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "q'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:q-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "t1",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ IwahoriHeckeGens",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#t1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "t1",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:t1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "t2",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ IwahoriHeckeGens",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#t2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "t2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:t2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "t3",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ IwahoriHeckeGens",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#t3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "t3",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:t3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "t4",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ IwahoriHeckeGens",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#t4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "t4",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:t4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "t_",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e NPoly LPQ IwahoriHeckeGens",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#t_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "t_",
          "normalized": "Int-\u003eNPoly LPQ IwahoriHeckeGens",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eNPoly LPQ IwahoriHeckeGens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:t_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "tau",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e NPoly LPQ IwahoriHeckeGens -\u003e LPQ",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#tau",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "tau",
          "normalized": "Int-\u003eNPoly LPQ IwahoriHeckeGens-\u003eLPQ",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eNPoly LPQ IwahoriHeckeGens-\u003eLPQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:tau"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "tau'",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e (Monomial IwahoriHeckeGens, LPQ) -\u003e LPQ",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#tau%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "tau'",
          "normalized": "Int-\u003e(Monomial IwahoriHeckeGens,LPQ)-\u003eLPQ",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e(Monomial IwahoriHeckeGens,LPQ)-\u003eLPQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:tau-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "z",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly Q",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#z",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "z",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "z'",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ IwahoriHeckeGens",
          "source": "src/Math-Projects-KnotTheory-IwahoriHecke.html#z%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory IwahoriHecke",
          "module": "Math.Projects.KnotTheory.IwahoriHecke",
          "name": "z'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-IwahoriHecke.html#v:z-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "LaurentMPoly",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "LaurentMPoly",
          "package": "HaskellForMaths",
          "partial": "Laurent MPoly",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "LaurentMPoly",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#LaurentMPoly",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "LaurentMPoly",
          "package": "HaskellForMaths",
          "partial": "Laurent MPoly",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#t:LaurentMPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "LaurentMonomial",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#LaurentMonomial",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "LaurentMonomial",
          "package": "HaskellForMaths",
          "partial": "Laurent Monomial",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#t:LaurentMonomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "(^^^)",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly t -\u003e Q -\u003e LaurentMPoly t",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#%5E%5E%5E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "(^^^) ^^^",
          "normalized": "LaurentMPoly a-\u003eQ-\u003eLaurentMPoly a",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly t-\u003eQ-\u003eLaurentMPoly t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:-94--94--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "LM",
          "package": "HaskellForMaths",
          "signature": "LM (Map String Q)",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#LaurentMonomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "LM",
          "package": "HaskellForMaths",
          "partial": "LM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:LM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "LP",
          "package": "HaskellForMaths",
          "signature": "LP [(LaurentMonomial, r)]",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#LaurentMPoly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "LP",
          "normalized": "LP[(LaurentMonomial,a)]",
          "package": "HaskellForMaths",
          "partial": "LP",
          "signature": "LP[(LaurentMonomial,r)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:LP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "cmpTerm",
          "package": "HaskellForMaths",
          "signature": "(a, t) -\u003e (a, t1) -\u003e Ordering",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#cmpTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "cmpTerm",
          "normalized": "(a,b)-\u003e(a,b)-\u003eOrdering",
          "package": "HaskellForMaths",
          "partial": "Term",
          "signature": "(a,t)-\u003e(a,t)-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:cmpTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "collect",
          "package": "HaskellForMaths",
          "signature": "[(a, a1)] -\u003e [(a, a1)]",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#collect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "collect",
          "normalized": "[(a,a)]-\u003e[(a,a)]",
          "package": "HaskellForMaths",
          "signature": "[(a,a)]-\u003e[(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:collect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "degLM",
          "package": "HaskellForMaths",
          "signature": "LaurentMonomial -\u003e Q",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#degLM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "degLM",
          "normalized": "LaurentMonomial-\u003eQ",
          "package": "HaskellForMaths",
          "partial": "LM",
          "signature": "LaurentMonomial-\u003eQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:degLM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "denominatorLM",
          "package": "HaskellForMaths",
          "signature": "LaurentMonomial -\u003e LaurentMonomial",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#denominatorLM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "denominatorLM",
          "normalized": "LaurentMonomial-\u003eLaurentMonomial",
          "package": "HaskellForMaths",
          "partial": "LM",
          "signature": "LaurentMonomial-\u003eLaurentMonomial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:denominatorLM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "denominatorLP",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly t -\u003e LaurentMPoly r",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#denominatorLP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "denominatorLP",
          "normalized": "LaurentMPoly a-\u003eLaurentMPoly b",
          "package": "HaskellForMaths",
          "partial": "LP",
          "signature": "LaurentMPoly t-\u003eLaurentMPoly r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:denominatorLP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "divLM",
          "package": "HaskellForMaths",
          "signature": "LaurentMonomial -\u003e LaurentMonomial -\u003e Maybe LaurentMonomial",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#divLM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "divLM",
          "normalized": "LaurentMonomial-\u003eLaurentMonomial-\u003eMaybe LaurentMonomial",
          "package": "HaskellForMaths",
          "partial": "LM",
          "signature": "LaurentMonomial-\u003eLaurentMonomial-\u003eMaybe LaurentMonomial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:divLM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "inject",
          "package": "HaskellForMaths",
          "signature": "r -\u003e LaurentMPoly r",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#inject",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "inject",
          "normalized": "a-\u003eLaurentMPoly a",
          "package": "HaskellForMaths",
          "signature": "r-\u003eLaurentMPoly r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:inject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "lc",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly t -\u003e t",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#lc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "lc",
          "normalized": "LaurentMPoly a-\u003ea",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:lc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "lcmLM",
          "package": "HaskellForMaths",
          "signature": "LaurentMonomial -\u003e LaurentMonomial -\u003e LaurentMonomial",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#lcmLM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "lcmLM",
          "normalized": "LaurentMonomial-\u003eLaurentMonomial-\u003eLaurentMonomial",
          "package": "HaskellForMaths",
          "partial": "LM",
          "signature": "LaurentMonomial-\u003eLaurentMonomial-\u003eLaurentMonomial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:lcmLM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "lm",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly t -\u003e LaurentMonomial",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#lm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "lm",
          "normalized": "LaurentMPoly a-\u003eLaurentMonomial",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly t-\u003eLaurentMonomial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:lm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "lt",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly r -\u003e LaurentMPoly r",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#lt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "lt",
          "normalized": "LaurentMPoly a-\u003eLaurentMPoly a",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly r-\u003eLaurentMPoly r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:lt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "mergeTerms",
          "package": "HaskellForMaths",
          "signature": "[(a, a1)] -\u003e [(a, a1)] -\u003e [(a, a1)]",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#mergeTerms",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "mergeTerms",
          "normalized": "[(a,a)]-\u003e[(a,a)]-\u003e[(a,a)]",
          "package": "HaskellForMaths",
          "partial": "Terms",
          "signature": "[(a,a)]-\u003e[(a,a)]-\u003e[(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:mergeTerms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "quotRemLP",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly t -\u003e LaurentMPoly t -\u003e (LaurentMPoly t, LaurentMPoly t)",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#quotRemLP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "quotRemLP",
          "normalized": "LaurentMPoly a-\u003eLaurentMPoly a-\u003e(LaurentMPoly a,LaurentMPoly a)",
          "package": "HaskellForMaths",
          "partial": "Rem LP",
          "signature": "LaurentMPoly t-\u003eLaurentMPoly t-\u003e(LaurentMPoly t,LaurentMPoly t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:quotRemLP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "reduceLP",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly t -\u003e LaurentMPoly t -\u003e LaurentMPoly t",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#reduceLP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "reduceLP",
          "normalized": "LaurentMPoly a-\u003eLaurentMPoly a-\u003eLaurentMPoly a",
          "package": "HaskellForMaths",
          "partial": "LP",
          "signature": "LaurentMPoly t-\u003eLaurentMPoly t-\u003eLaurentMPoly t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:reduceLP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "sqrtvar",
          "package": "HaskellForMaths",
          "signature": "String -\u003e LaurentMPoly r",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#sqrtvar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "sqrtvar",
          "normalized": "String-\u003eLaurentMPoly a",
          "package": "HaskellForMaths",
          "signature": "String-\u003eLaurentMPoly r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:sqrtvar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "subst",
          "package": "HaskellForMaths",
          "signature": "[(LaurentMPoly r, LaurentMPoly r)] -\u003e LaurentMPoly r -\u003e LaurentMPoly r",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#subst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "subst",
          "normalized": "[(LaurentMPoly a,LaurentMPoly a)]-\u003eLaurentMPoly a-\u003eLaurentMPoly a",
          "package": "HaskellForMaths",
          "signature": "[(LaurentMPoly r,LaurentMPoly r)]-\u003eLaurentMPoly r-\u003eLaurentMPoly r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:subst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "t",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly Q",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#t",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "t",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "var",
          "package": "HaskellForMaths",
          "signature": "String -\u003e LaurentMPoly r",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#var",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "var",
          "normalized": "String-\u003eLaurentMPoly a",
          "package": "HaskellForMaths",
          "signature": "String-\u003eLaurentMPoly r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "x",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly Q",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#x",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "x",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:x"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "y",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly Q",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "y",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "z",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly Q",
          "source": "src/Math-Projects-KnotTheory-LaurentMPoly.html#z",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory LaurentMPoly",
          "module": "Math.Projects.KnotTheory.LaurentMPoly",
          "name": "z",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-LaurentMPoly.html#v:z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "TemperleyLieb",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "TemperleyLieb",
          "package": "HaskellForMaths",
          "partial": "Temperley Lieb",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "TemperleyLiebGens",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#TemperleyLiebGens",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "TemperleyLiebGens",
          "package": "HaskellForMaths",
          "partial": "Temperley Lieb Gens",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#t:TemperleyLiebGens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "E",
          "package": "HaskellForMaths",
          "signature": "E Int",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#TemperleyLiebGens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "E",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "a",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly Q",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "a",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:a"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "a'",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ TemperleyLiebGens",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#a%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "a'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:a-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "d",
          "package": "HaskellForMaths",
          "signature": "LaurentMPoly Q",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#d",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "d",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:d"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "d'",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ TemperleyLiebGens",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#d%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "d'",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:d-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "dimTL",
          "package": "HaskellForMaths",
          "signature": "NPoly t TemperleyLiebGens -\u003e Int",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#dimTL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "dimTL",
          "normalized": "NPoly a TemperleyLiebGens-\u003eInt",
          "package": "HaskellForMaths",
          "partial": "TL",
          "signature": "NPoly t TemperleyLiebGens-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:dimTL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "e1",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ TemperleyLiebGens",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#e1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "e1",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:e1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "e2",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ TemperleyLiebGens",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#e2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "e2",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:e2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "e3",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ TemperleyLiebGens",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#e3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "e3",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:e3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "e4",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ TemperleyLiebGens",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#e4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "e4",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:e4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "e_",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e NPoly LPQ TemperleyLiebGens",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#e_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "e_",
          "normalized": "Int-\u003eNPoly LPQ TemperleyLiebGens",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eNPoly LPQ TemperleyLiebGens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:e_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "fromBraid",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ BraidGens -\u003e NPoly LPQ TemperleyLiebGens",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#fromBraid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "fromBraid",
          "normalized": "NPoly LPQ BraidGens-\u003eNPoly LPQ TemperleyLiebGens",
          "package": "HaskellForMaths",
          "partial": "Braid",
          "signature": "NPoly LPQ BraidGens-\u003eNPoly LPQ TemperleyLiebGens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:fromBraid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "jones",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e NPoly LPQ BraidGens -\u003e LaurentMPoly Q",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#jones",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "jones",
          "normalized": "Int-\u003eNPoly LPQ BraidGens-\u003eLaurentMPoly Q",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eNPoly LPQ BraidGens-\u003eLaurentMPoly Q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:jones"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "tlBasis",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [NPoly LPQ TemperleyLiebGens]",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#tlBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "tlBasis",
          "normalized": "Int-\u003e[NPoly LPQ TemperleyLiebGens]",
          "package": "HaskellForMaths",
          "partial": "Basis",
          "signature": "Int-\u003e[NPoly LPQ TemperleyLiebGens]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:tlBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "tlRelations",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e [NPoly LPQ TemperleyLiebGens]",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#tlRelations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "tlRelations",
          "normalized": "Int-\u003e[NPoly LPQ TemperleyLiebGens]",
          "package": "HaskellForMaths",
          "partial": "Relations",
          "signature": "Int-\u003e[NPoly LPQ TemperleyLiebGens]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:tlRelations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "tlnf",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ TemperleyLiebGens -\u003e NPoly LPQ TemperleyLiebGens",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#tlnf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "tlnf",
          "normalized": "NPoly LPQ TemperleyLiebGens-\u003eNPoly LPQ TemperleyLiebGens",
          "package": "HaskellForMaths",
          "signature": "NPoly LPQ TemperleyLiebGens-\u003eNPoly LPQ TemperleyLiebGens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:tlnf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "tr",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e NPoly (LaurentMPoly Q) TemperleyLiebGens -\u003e LaurentMPoly Q",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#tr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "tr",
          "normalized": "Int-\u003eNPoly(LaurentMPoly Q)TemperleyLiebGens-\u003eLaurentMPoly Q",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eNPoly(LaurentMPoly Q)TemperleyLiebGens-\u003eLaurentMPoly Q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:tr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "tr'",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Monomial TemperleyLiebGens -\u003e LaurentMPoly Q",
          "source": "src/Math-Projects-KnotTheory-TemperleyLieb.html#tr%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects KnotTheory TemperleyLieb",
          "module": "Math.Projects.KnotTheory.TemperleyLieb",
          "name": "tr'",
          "normalized": "Int-\u003eMonomial TemperleyLiebGens-\u003eLaurentMPoly Q",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eMonomial TemperleyLiebGens-\u003eLaurentMPoly Q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-KnotTheory-TemperleyLieb.html#v:tr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "MiniquaternionGeometry",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-MiniquaternionGeometry.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "MiniquaternionGeometry",
          "package": "HaskellForMaths",
          "partial": "Miniquaternion Geometry",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "F9",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#F9",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "F9",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#t:F9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "J9",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#J9",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "J9",
          "package": "HaskellForMaths",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#t:J9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "(\u003c*)",
          "package": "HaskellForMaths",
          "signature": "[b] -\u003e b -\u003e [b]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#%3C%2A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "(\u003c*) \u003c*",
          "normalized": "[a]-\u003ea-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[b]-\u003eb-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:-60--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "F9",
          "package": "HaskellForMaths",
          "signature": "F9 F3 F3",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#F9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "F9",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:F9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "J9",
          "package": "HaskellForMaths",
          "signature": "J9 F9",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#J9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "J9",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:J9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "autA",
          "package": "HaskellForMaths",
          "signature": "Permutation J9",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#autA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "autA",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:autA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "autB",
          "package": "HaskellForMaths",
          "signature": "Permutation J9",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#autB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "autB",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:autB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "autC",
          "package": "HaskellForMaths",
          "signature": "Permutation J9",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#autC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "autC",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:autC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "autJ9",
          "package": "HaskellForMaths",
          "signature": "J9 -\u003e Permutation J9",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#autJ9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "autJ9",
          "normalized": "J-\u003ePermutation J",
          "package": "HaskellForMaths",
          "signature": "J-\u003ePermutation J",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:autJ9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "autsJ9",
          "package": "HaskellForMaths",
          "signature": "[Permutation J9]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#autsJ9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "autsJ9",
          "normalized": "[Permutation J]",
          "package": "HaskellForMaths",
          "signature": "[Permutation J]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:autsJ9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "collinear",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e [a] -\u003e Bool",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#collinear",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "collinear",
          "normalized": "Design a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "Design a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:collinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "collineationsOmega",
          "package": "HaskellForMaths",
          "signature": "[Permutation [J9]]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#collineationsOmega",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "collineationsOmega",
          "normalized": "[Permutation[J]]",
          "package": "HaskellForMaths",
          "partial": "Omega",
          "signature": "[Permutation[J]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:collineationsOmega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "collineationsPhi",
          "package": "HaskellForMaths",
          "signature": "[Permutation [F9]]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#collineationsPhi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "collineationsPhi",
          "normalized": "[Permutation[F]]",
          "package": "HaskellForMaths",
          "partial": "Phi",
          "signature": "[Permutation[F]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:collineationsPhi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "collineationsPsi",
          "package": "HaskellForMaths",
          "signature": "[Permutation [J9]]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#collineationsPsi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "collineationsPsi",
          "normalized": "[Permutation[J]]",
          "package": "HaskellForMaths",
          "partial": "Psi",
          "signature": "[Permutation[J]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:collineationsPsi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "concurrent",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e [[a]] -\u003e Bool",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#concurrent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "concurrent",
          "normalized": "Design a-\u003e[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "signature": "Design a-\u003e[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:concurrent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "conj",
          "package": "HaskellForMaths",
          "signature": "F9 -\u003e F9",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#conj",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "conj",
          "normalized": "F-\u003eF",
          "package": "HaskellForMaths",
          "signature": "F-\u003eF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:conj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "conj'",
          "package": "HaskellForMaths",
          "signature": "J9 -\u003e J9",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#conj%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "conj'",
          "normalized": "J-\u003eJ",
          "package": "HaskellForMaths",
          "signature": "J-\u003eJ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:conj-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "e",
          "package": "HaskellForMaths",
          "signature": "F9",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#e",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "e",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:e"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "f9",
          "package": "HaskellForMaths",
          "signature": "[F9]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#f9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "f9",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:f9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "findOvals",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e [[a]]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#findOvals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "findOvals",
          "normalized": "Design a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Ovals",
          "signature": "Design a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:findOvals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "findOvals1",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e [[a]]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#findOvals1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "findOvals1",
          "normalized": "Design a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Ovals",
          "signature": "Design a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:findOvals1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "findQuadrangles",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e [[a]]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#findQuadrangles",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "findQuadrangles",
          "normalized": "Design a-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Quadrangles",
          "signature": "Design a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:findQuadrangles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "i",
          "package": "HaskellForMaths",
          "signature": "J9",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#i",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "i",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:i"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "isAut",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e (t -\u003e a) -\u003e Bool",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#isAut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "isAut",
          "normalized": "[a]-\u003e(a-\u003eb)-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Aut",
          "signature": "[t]-\u003e(t-\u003ea)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:isAut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "isComplex",
          "package": "HaskellForMaths",
          "signature": "J9 -\u003e Bool",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#isComplex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "isComplex",
          "normalized": "J-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Complex",
          "signature": "J-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:isComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "isOval",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e [a] -\u003e Bool",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#isOval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "isOval",
          "normalized": "Design a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Oval",
          "signature": "Design a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:isOval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "isProjectivePlane",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e Bool",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#isProjectivePlane",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "isProjectivePlane",
          "normalized": "Design a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Projective Plane",
          "signature": "Design a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:isProjectivePlane"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "isQuadrangle",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e [a] -\u003e Bool",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#isQuadrangle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "isQuadrangle",
          "normalized": "Design a-\u003e[a]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Quadrangle",
          "signature": "Design a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:isQuadrangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "isQuadrilateral",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e [[a]] -\u003e Bool",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#isQuadrilateral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "isQuadrilateral",
          "normalized": "Design a-\u003e[[a]]-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Quadrilateral",
          "signature": "Design a-\u003e[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:isQuadrilateral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "isReal",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Bool",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#isReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "isReal",
          "normalized": "a-\u003eBool",
          "package": "HaskellForMaths",
          "partial": "Real",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:isReal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "j",
          "package": "HaskellForMaths",
          "signature": "J9",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#j",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "j",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:j"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "j9",
          "package": "HaskellForMaths",
          "signature": "[J9]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#j9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "j9",
          "normalized": "[J]",
          "package": "HaskellForMaths",
          "signature": "[J]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:j9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "k",
          "package": "HaskellForMaths",
          "signature": "J9",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#k",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "k",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:k"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "leftLinesPG2",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e [[[t]]]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#leftLinesPG2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "leftLinesPG2",
          "normalized": "[a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "Lines PG",
          "signature": "[t]-\u003e[[[t]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:leftLinesPG2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "liftToGraph",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e Permutation a -\u003e Permutation (Either a [a])",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#liftToGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "liftToGraph",
          "normalized": "Design a-\u003ePermutation a-\u003ePermutation(Either a[a])",
          "package": "HaskellForMaths",
          "partial": "To Graph",
          "signature": "Design a-\u003ePermutation a-\u003ePermutation(Either a[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:liftToGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "norm",
          "package": "HaskellForMaths",
          "signature": "F9 -\u003e F3",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#norm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "norm",
          "normalized": "F-\u003eF",
          "package": "HaskellForMaths",
          "signature": "F-\u003eF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:norm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "omega",
          "package": "HaskellForMaths",
          "signature": "Design [J9]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#omega",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "omega",
          "normalized": "Design[J]",
          "package": "HaskellForMaths",
          "signature": "Design[J]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:omega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "omega0",
          "package": "HaskellForMaths",
          "signature": "Design [J9]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#omega0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "omega0",
          "normalized": "Design[J]",
          "package": "HaskellForMaths",
          "signature": "Design[J]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:omega0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "omega2",
          "package": "HaskellForMaths",
          "signature": "Design [J9]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#omega2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "omega2",
          "normalized": "Design[J]",
          "package": "HaskellForMaths",
          "signature": "Design[J]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:omega2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "omegaD",
          "package": "HaskellForMaths",
          "signature": "Design [J9]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#omegaD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "omegaD",
          "normalized": "Design[J]",
          "package": "HaskellForMaths",
          "signature": "Design[J]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:omegaD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "omegaD1",
          "package": "HaskellForMaths",
          "signature": "Design Integer",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#omegaD1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "omegaD1",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:omegaD1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "omegaD2",
          "package": "HaskellForMaths",
          "signature": "Design [J9]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#omegaD2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "omegaD2",
          "normalized": "Design[J]",
          "package": "HaskellForMaths",
          "signature": "Design[J]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:omegaD2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "order",
          "package": "HaskellForMaths",
          "signature": "Design a -\u003e Int",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#order",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "order",
          "normalized": "Design a-\u003eInt",
          "package": "HaskellForMaths",
          "signature": "Design a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:order"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "orthogonalLinesPG2",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[[a]]]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#orthogonalLinesPG2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "orthogonalLinesPG2",
          "normalized": "[[a]]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "Lines PG",
          "signature": "[[a]]-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:orthogonalLinesPG2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "phi",
          "package": "HaskellForMaths",
          "signature": "Design [F9]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#phi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "phi",
          "normalized": "Design[F]",
          "package": "HaskellForMaths",
          "signature": "Design[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:phi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "phi'",
          "package": "HaskellForMaths",
          "signature": "Design [F9]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#phi%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "phi'",
          "normalized": "Design[F]",
          "package": "HaskellForMaths",
          "signature": "Design[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:phi-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "psi",
          "package": "HaskellForMaths",
          "signature": "Design [J9]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#psi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "psi",
          "normalized": "Design[J]",
          "package": "HaskellForMaths",
          "signature": "Design[J]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:psi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "psi2",
          "package": "HaskellForMaths",
          "signature": "Design [J9]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#psi2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "psi2",
          "normalized": "Design[J]",
          "package": "HaskellForMaths",
          "signature": "Design[J]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:psi2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "ptsPG2",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e [[t]]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#ptsPG2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "ptsPG2",
          "normalized": "[a]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "PG",
          "signature": "[t]-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:ptsPG2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "rightLinesPG2",
          "package": "HaskellForMaths",
          "signature": "[t] -\u003e [[[t]]]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#rightLinesPG2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "rightLinesPG2",
          "normalized": "[a]-\u003e[[[a]]]",
          "package": "HaskellForMaths",
          "partial": "Lines PG",
          "signature": "[t]-\u003e[[[t]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:rightLinesPG2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "squaresF9",
          "package": "HaskellForMaths",
          "signature": "[F9]",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#squaresF9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "squaresF9",
          "normalized": "[F]",
          "package": "HaskellForMaths",
          "signature": "[F]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:squaresF9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "w",
          "package": "HaskellForMaths",
          "signature": "F9",
          "source": "src/Math-Projects-MiniquaternionGeometry.html#w",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects MiniquaternionGeometry",
          "module": "Math.Projects.MiniquaternionGeometry",
          "name": "w",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-MiniquaternionGeometry.html#v:w"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "RootSystem",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-RootSystem.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "RootSystem",
          "package": "HaskellForMaths",
          "partial": "Root System",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "Type",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-RootSystem.html#Type",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "Type",
          "package": "HaskellForMaths",
          "partial": "Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#t:Type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "(+|+)",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]] -\u003e [[a]]",
          "source": "src/Math-Projects-RootSystem.html#%2B%7C%2B",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "(+|+) +|+",
          "normalized": "[[a]]-\u003e[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003e[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:-43--124--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "(+-+)",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Projects-RootSystem.html#%2B-%2B",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "(+-+) +-+",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:-43--45--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "A",
          "package": "HaskellForMaths",
          "signature": "A",
          "source": "src/Math-Projects-RootSystem.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "A",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "B",
          "package": "HaskellForMaths",
          "signature": "B",
          "source": "src/Math-Projects-RootSystem.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "B",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:B"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "C",
          "package": "HaskellForMaths",
          "signature": "C",
          "source": "src/Math-Projects-RootSystem.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "C",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "D",
          "package": "HaskellForMaths",
          "signature": "D",
          "source": "src/Math-Projects-RootSystem.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "D",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "E",
          "package": "HaskellForMaths",
          "signature": "E",
          "source": "src/Math-Projects-RootSystem.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "E",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "F",
          "package": "HaskellForMaths",
          "signature": "F",
          "source": "src/Math-Projects-RootSystem.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "F",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:F"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "G",
          "package": "HaskellForMaths",
          "signature": "G",
          "source": "src/Math-Projects-RootSystem.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "G",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:G"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "basisElt",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Int -\u003e [Q]",
          "source": "src/Math-Projects-RootSystem.html#basisElt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "basisElt",
          "normalized": "Int-\u003eInt-\u003e[Q]",
          "package": "HaskellForMaths",
          "partial": "Elt",
          "signature": "Int-\u003eInt-\u003e[Q]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:basisElt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "cartanMatrix",
          "package": "HaskellForMaths",
          "signature": "Type -\u003e Int -\u003e [[Q]]",
          "source": "src/Math-Projects-RootSystem.html#cartanMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "cartanMatrix",
          "normalized": "Type-\u003eInt-\u003e[[Q]]",
          "package": "HaskellForMaths",
          "partial": "Matrix",
          "signature": "Type-\u003eInt-\u003e[[Q]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:cartanMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "closure",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Math-Projects-RootSystem.html#closure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "closure",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:closure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "coxeterFromDynkin",
          "package": "HaskellForMaths",
          "signature": "[[a1]] -\u003e [[a]]",
          "source": "src/Math-Projects-RootSystem.html#coxeterFromDynkin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "coxeterFromDynkin",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "From Dynkin",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:coxeterFromDynkin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "coxeterMatrix",
          "package": "HaskellForMaths",
          "signature": "Type -\u003e Int -\u003e [[a]]",
          "source": "src/Math-Projects-RootSystem.html#coxeterMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "coxeterMatrix",
          "normalized": "Type-\u003eInt-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Matrix",
          "signature": "Type-\u003eInt-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:coxeterMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "coxeterPresentation",
          "package": "HaskellForMaths",
          "signature": "Type -\u003e Int -\u003e ([SGen], [([SGen], [a])])",
          "source": "src/Math-Projects-RootSystem.html#coxeterPresentation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "coxeterPresentation",
          "normalized": "Type-\u003eInt-\u003e([SGen],[([SGen],[a])])",
          "package": "HaskellForMaths",
          "partial": "Presentation",
          "signature": "Type-\u003eInt-\u003e([SGen],[([SGen],[a])])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:coxeterPresentation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "dynkinDiagram",
          "package": "HaskellForMaths",
          "signature": "Type -\u003e Int -\u003e [[Q]]",
          "source": "src/Math-Projects-RootSystem.html#dynkinDiagram",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "dynkinDiagram",
          "normalized": "Type-\u003eInt-\u003e[[Q]]",
          "package": "HaskellForMaths",
          "partial": "Diagram",
          "signature": "Type-\u003eInt-\u003e[[Q]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:dynkinDiagram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "dynkinFromCartan",
          "package": "HaskellForMaths",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Math-Projects-RootSystem.html#dynkinFromCartan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "dynkinFromCartan",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "From Cartan",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:dynkinFromCartan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "elemMx",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Int -\u003e Int -\u003e [[Q]]",
          "source": "src/Math-Projects-RootSystem.html#elemMx",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "elemMx",
          "normalized": "Int-\u003eInt-\u003eInt-\u003e[[Q]]",
          "package": "HaskellForMaths",
          "partial": "Mx",
          "signature": "Int-\u003eInt-\u003eInt-\u003e[[Q]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:elemMx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "eltsCoxeter",
          "package": "HaskellForMaths",
          "signature": "Type -\u003e Int -\u003e [[SGen]]",
          "source": "src/Math-Projects-RootSystem.html#eltsCoxeter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "eltsCoxeter",
          "normalized": "Type-\u003eInt-\u003e[[SGen]]",
          "package": "HaskellForMaths",
          "partial": "Coxeter",
          "signature": "Type-\u003eInt-\u003e[[SGen]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:eltsCoxeter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "factorial",
          "package": "HaskellForMaths",
          "signature": "a -\u003e Integer",
          "source": "src/Math-Projects-RootSystem.html#factorial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "factorial",
          "normalized": "a-\u003eInteger",
          "package": "HaskellForMaths",
          "signature": "a-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:factorial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "form",
          "package": "HaskellForMaths",
          "signature": "Type -\u003e Int -\u003e [[a]]",
          "source": "src/Math-Projects-RootSystem.html#form",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "form",
          "normalized": "Type-\u003eInt-\u003e[[a]]",
          "package": "HaskellForMaths",
          "signature": "Type-\u003eInt-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:form"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "fromCoxeterMatrix",
          "package": "HaskellForMaths",
          "signature": "[[Int]] -\u003e ([SGen], [([SGen], [a])])",
          "source": "src/Math-Projects-RootSystem.html#fromCoxeterMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "fromCoxeterMatrix",
          "normalized": "[[Int]]-\u003e([SGen],[([SGen],[a])])",
          "package": "HaskellForMaths",
          "partial": "Coxeter Matrix",
          "signature": "[[Int]]-\u003e([SGen],[([SGen],[a])])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:fromCoxeterMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "fromCoxeterMatrix2",
          "package": "HaskellForMaths",
          "signature": "[[Int]] -\u003e ([SGen], [([SGen], [SGen])])",
          "source": "src/Math-Projects-RootSystem.html#fromCoxeterMatrix2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "fromCoxeterMatrix2",
          "normalized": "[[Int]]-\u003e([SGen],[([SGen],[SGen])])",
          "package": "HaskellForMaths",
          "partial": "Coxeter Matrix",
          "signature": "[[Int]]-\u003e([SGen],[([SGen],[SGen])])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:fromCoxeterMatrix2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "lieMult",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Math-Projects-RootSystem.html#lieMult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "lieMult",
          "normalized": "a-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "partial": "Mult",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:lieMult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "numRoots",
          "package": "HaskellForMaths",
          "signature": "Type -\u003e a -\u003e a",
          "source": "src/Math-Projects-RootSystem.html#numRoots",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "numRoots",
          "normalized": "Type-\u003ea-\u003ea",
          "package": "HaskellForMaths",
          "partial": "Roots",
          "signature": "Type-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:numRoots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "orderWeyl",
          "package": "HaskellForMaths",
          "signature": "Type -\u003e a -\u003e Integer",
          "source": "src/Math-Projects-RootSystem.html#orderWeyl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "orderWeyl",
          "normalized": "Type-\u003ea-\u003eInteger",
          "package": "HaskellForMaths",
          "partial": "Weyl",
          "signature": "Type-\u003ea-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:orderWeyl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "poincarePoly",
          "package": "HaskellForMaths",
          "signature": "Type -\u003e Int -\u003e [Int]",
          "source": "src/Math-Projects-RootSystem.html#poincarePoly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "poincarePoly",
          "normalized": "Type-\u003eInt-\u003e[Int]",
          "package": "HaskellForMaths",
          "partial": "Poly",
          "signature": "Type-\u003eInt-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:poincarePoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "rootSystem",
          "package": "HaskellForMaths",
          "signature": "Type -\u003e Int -\u003e [[Q]]",
          "source": "src/Math-Projects-RootSystem.html#rootSystem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "rootSystem",
          "normalized": "Type-\u003eInt-\u003e[[Q]]",
          "package": "HaskellForMaths",
          "partial": "System",
          "signature": "Type-\u003eInt-\u003e[[Q]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:rootSystem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "setDiag",
          "package": "HaskellForMaths",
          "signature": "a -\u003e [[a]] -\u003e [[a]]",
          "source": "src/Math-Projects-RootSystem.html#setDiag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "setDiag",
          "normalized": "a-\u003e[[a]]-\u003e[[a]]",
          "package": "HaskellForMaths",
          "partial": "Diag",
          "signature": "a-\u003e[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:setDiag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "simpleSystem",
          "package": "HaskellForMaths",
          "signature": "Type -\u003e Int -\u003e [[Q]]",
          "source": "src/Math-Projects-RootSystem.html#simpleSystem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "simpleSystem",
          "normalized": "Type-\u003eInt-\u003e[[Q]]",
          "package": "HaskellForMaths",
          "partial": "System",
          "signature": "Type-\u003eInt-\u003e[[Q]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:simpleSystem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "w",
          "package": "HaskellForMaths",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Projects-RootSystem.html#w",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "w",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "HaskellForMaths",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:w"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "wMx",
          "package": "HaskellForMaths",
          "signature": "[Q] -\u003e [[Q]]",
          "source": "src/Math-Projects-RootSystem.html#wMx",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "wMx",
          "normalized": "[Q]-\u003e[[Q]]",
          "package": "HaskellForMaths",
          "partial": "Mx",
          "signature": "[Q]-\u003e[[Q]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:wMx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "weylMatrices",
          "package": "HaskellForMaths",
          "signature": "Type -\u003e Int -\u003e [[[Q]]]",
          "source": "src/Math-Projects-RootSystem.html#weylMatrices",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "weylMatrices",
          "normalized": "Type-\u003eInt-\u003e[[[Q]]]",
          "package": "HaskellForMaths",
          "partial": "Matrices",
          "signature": "Type-\u003eInt-\u003e[[[Q]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:weylMatrices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.RootSystem",
          "name": "weylPerms",
          "package": "HaskellForMaths",
          "signature": "Type -\u003e Int -\u003e [Permutation [Q]]",
          "source": "src/Math-Projects-RootSystem.html#weylPerms",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects RootSystem",
          "module": "Math.Projects.RootSystem",
          "name": "weylPerms",
          "normalized": "Type-\u003eInt-\u003e[Permutation[Q]]",
          "package": "HaskellForMaths",
          "partial": "Perms",
          "signature": "Type-\u003eInt-\u003e[Permutation[Q]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-RootSystem.html#v:weylPerms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "Rubik",
          "package": "HaskellForMaths",
          "source": "src/Math-Projects-Rubik.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "Rubik",
          "package": "HaskellForMaths",
          "partial": "Rubik",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "_B",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#_B",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "_B",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:_B"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "_D",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#_D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "_D",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:_D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "_F",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#_F",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "_F",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:_F"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "_L",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#_L",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "_L",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:_L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "_R",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#_R",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "_R",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:_R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "_U",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#_U",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "_U",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:_U"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "_b",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#_b",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "_b",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:_b"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "_d",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#_d",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "_d",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:_d"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "_f",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#_f",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "_f",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "_l",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#_l",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "_l",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:_l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "_r",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "_r",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "_u",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#_u",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "_u",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:_u"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "b",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#b",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "b",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:b"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "bf",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#bf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "bf",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:bf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "cornerBlocks",
          "package": "HaskellForMaths",
          "signature": "[[Integer]]",
          "source": "src/Math-Projects-Rubik.html#cornerBlocks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "cornerBlocks",
          "normalized": "[[Integer]]",
          "package": "HaskellForMaths",
          "partial": "Blocks",
          "signature": "[[Integer]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:cornerBlocks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "cornerFaces",
          "package": "HaskellForMaths",
          "signature": "[Integer]",
          "source": "src/Math-Projects-Rubik.html#cornerFaces",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "cornerFaces",
          "normalized": "[Integer]",
          "package": "HaskellForMaths",
          "partial": "Faces",
          "signature": "[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:cornerFaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "d",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#d",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "d",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:d"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "edgeBlocks",
          "package": "HaskellForMaths",
          "signature": "[[Integer]]",
          "source": "src/Math-Projects-Rubik.html#edgeBlocks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "edgeBlocks",
          "normalized": "[[Integer]]",
          "package": "HaskellForMaths",
          "partial": "Blocks",
          "signature": "[[Integer]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:edgeBlocks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "f",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#f",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "f",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "kerCornerBlocks",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Projects-Rubik.html#kerCornerBlocks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "kerCornerBlocks",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "partial": "Corner Blocks",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:kerCornerBlocks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "kerCornerFaces",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Projects-Rubik.html#kerCornerFaces",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "kerCornerFaces",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "partial": "Corner Faces",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:kerCornerFaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "kerEdgeBlocks",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Projects-Rubik.html#kerEdgeBlocks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "kerEdgeBlocks",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "partial": "Edge Blocks",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:kerEdgeBlocks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "kerEdgeFaces",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Projects-Rubik.html#kerEdgeFaces",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "kerEdgeFaces",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "partial": "Edge Faces",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:kerEdgeFaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "l",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#l",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "l",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "r",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "r",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "rubikCube",
          "package": "HaskellForMaths",
          "signature": "[Permutation Integer]",
          "source": "src/Math-Projects-Rubik.html#rubikCube",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "rubikCube",
          "normalized": "[Permutation Integer]",
          "package": "HaskellForMaths",
          "partial": "Cube",
          "signature": "[Permutation Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:rubikCube"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "u",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#u",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "u",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:u"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Projects.Rubik",
          "name": "ud",
          "package": "HaskellForMaths",
          "signature": "Permutation Integer",
          "source": "src/Math-Projects-Rubik.html#ud",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Projects Rubik",
          "module": "Math.Projects.Rubik",
          "name": "ud",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-Projects-Rubik.html#v:ud"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "OrientedTangle",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "OrientedTangle",
          "package": "HaskellForMaths",
          "partial": "Oriented Tangle",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "HorizDir",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#HorizDir",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "HorizDir",
          "package": "HaskellForMaths",
          "partial": "Horiz Dir",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#t:HorizDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "Oriented",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#Oriented",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "Oriented",
          "package": "HaskellForMaths",
          "partial": "Oriented",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#t:Oriented"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "OrientedTangle",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#OrientedTangle",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "OrientedTangle",
          "package": "HaskellForMaths",
          "partial": "Oriented Tangle",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#t:OrientedTangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "Minus",
          "package": "HaskellForMaths",
          "signature": "Minus",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#Oriented",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "Minus",
          "package": "HaskellForMaths",
          "partial": "Minus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:Minus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "Plus",
          "package": "HaskellForMaths",
          "signature": "Plus",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#Oriented",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "Plus",
          "package": "HaskellForMaths",
          "partial": "Plus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:Plus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "ToL",
          "package": "HaskellForMaths",
          "signature": "ToL",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#HorizDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "ToL",
          "package": "HaskellForMaths",
          "partial": "To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:ToL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "ToR",
          "package": "HaskellForMaths",
          "signature": "ToR",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#HorizDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "ToR",
          "package": "HaskellForMaths",
          "partial": "To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:ToR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "c",
          "package": "HaskellForMaths",
          "signature": "b -\u003e (EBasis, EBasis) -\u003e Vect (LaurentPoly Q) (EBasis, EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#c",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "c",
          "normalized": "a-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "package": "HaskellForMaths",
          "signature": "b-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "c'",
          "package": "HaskellForMaths",
          "signature": "b -\u003e (EBasis, EBasis) -\u003e Vect (LaurentPoly Q) (EBasis, EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#c%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "c'",
          "normalized": "a-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "package": "HaskellForMaths",
          "signature": "b-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:c-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "capLR",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Vect (LaurentPoly Q) (EBasis, EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#capLR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "capLR",
          "normalized": "Int-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "package": "HaskellForMaths",
          "partial": "LR",
          "signature": "Int-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:capLR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "capRL",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Vect k (Tensor EBasis EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#capRL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "capRL",
          "normalized": "Int-\u003eVect a(Tensor EBasis EBasis)",
          "package": "HaskellForMaths",
          "partial": "RL",
          "signature": "Int-\u003eVect k(Tensor EBasis EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:capRL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "coevalV",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Vect k (Tensor EBasis EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#coevalV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "coevalV",
          "normalized": "Int-\u003eVect a(Tensor EBasis EBasis)",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eVect k(Tensor EBasis EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:coevalV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "coevalV'",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Vect k (Tensor EBasis EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#coevalV%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "coevalV'",
          "normalized": "Int-\u003eVect a(Tensor EBasis EBasis)",
          "package": "HaskellForMaths",
          "partial": "V'",
          "signature": "Int-\u003eVect k(Tensor EBasis EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:coevalV-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "cupLR",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e (EBasis, EBasis) -\u003e Vect (LaurentPoly Q) ()",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#cupLR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "cupLR",
          "normalized": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)()",
          "package": "HaskellForMaths",
          "partial": "LR",
          "signature": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:cupLR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "cupRL",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e (EBasis, EBasis) -\u003e Vect (LaurentPoly Q) ()",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#cupRL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "cupRL",
          "normalized": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)()",
          "package": "HaskellForMaths",
          "partial": "RL",
          "signature": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:cupRL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "evalV",
          "package": "HaskellForMaths",
          "signature": "(EBasis, EBasis) -\u003e Vect (LaurentPoly Q) ()",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#evalV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "evalV",
          "normalized": "(EBasis,EBasis)-\u003eVect(LaurentPoly Q)()",
          "package": "HaskellForMaths",
          "signature": "(EBasis,EBasis)-\u003eVect(LaurentPoly Q)()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:evalV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "evalV'",
          "package": "HaskellForMaths",
          "signature": "(EBasis, EBasis) -\u003e Vect (LaurentPoly Q) ()",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#evalV%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "evalV'",
          "normalized": "(EBasis,EBasis)-\u003eVect(LaurentPoly Q)()",
          "package": "HaskellForMaths",
          "partial": "V'",
          "signature": "(EBasis,EBasis)-\u003eVect(LaurentPoly Q)()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:evalV-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "idV",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#idV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "idV",
          "normalized": "a-\u003ea",
          "package": "HaskellForMaths",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:idV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "idV'",
          "package": "HaskellForMaths",
          "signature": "a -\u003e a",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#idV%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "idV'",
          "normalized": "a-\u003ea",
          "package": "HaskellForMaths",
          "partial": "V'",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:idV-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "lambda",
          "package": "HaskellForMaths",
          "signature": "b -\u003e LaurentPoly Q",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#lambda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "lambda",
          "normalized": "a-\u003eLaurentPoly Q",
          "package": "HaskellForMaths",
          "signature": "b-\u003eLaurentPoly Q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:lambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "mu",
          "package": "HaskellForMaths",
          "signature": "b -\u003e EBasis -\u003e Vect (LaurentPoly Q) EBasis",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#mu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "mu",
          "normalized": "a-\u003eEBasis-\u003eVect(LaurentPoly Q)EBasis",
          "package": "HaskellForMaths",
          "signature": "b-\u003eEBasis-\u003eVect(LaurentPoly Q)EBasis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:mu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "mu'",
          "package": "HaskellForMaths",
          "signature": "b -\u003e EBasis -\u003e Vect (LaurentPoly Q) EBasis",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#mu%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "mu'",
          "normalized": "a-\u003eEBasis-\u003eVect(LaurentPoly Q)EBasis",
          "package": "HaskellForMaths",
          "signature": "b-\u003eEBasis-\u003eVect(LaurentPoly Q)EBasis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:mu-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "oloop",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Vect (LaurentPoly Q) ()",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#oloop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "oloop",
          "normalized": "Int-\u003eVect(LaurentPoly Q)()",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eVect(LaurentPoly Q)()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:oloop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "otrefoil",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Vect (LaurentPoly Q) ()",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#otrefoil",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "otrefoil",
          "normalized": "Int-\u003eVect(LaurentPoly Q)()",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eVect(LaurentPoly Q)()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:otrefoil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "otrefoil'",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Vect (LaurentPoly Q) ()",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#otrefoil%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "otrefoil'",
          "normalized": "Int-\u003eVect(LaurentPoly Q)()",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eVect(LaurentPoly Q)()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:otrefoil-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "testcc'",
          "package": "HaskellForMaths",
          "signature": "b -\u003e Vect (LaurentPoly Q) (EBasis, EBasis) -\u003e Vect (LaurentPoly Q) (EBasis, EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#testcc%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "testcc'",
          "normalized": "a-\u003eVect(LaurentPoly Q)(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "package": "HaskellForMaths",
          "signature": "b-\u003eVect(LaurentPoly Q)(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:testcc-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "tminus",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e (EBasis, EBasis) -\u003e Vect (LaurentPoly Q) (EBasis, EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#tminus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "tminus",
          "normalized": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:tminus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "tplus",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e (EBasis, EBasis) -\u003e Vect (LaurentPoly Q) (EBasis, EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#tplus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "tplus",
          "normalized": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:tplus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "xminus",
          "package": "HaskellForMaths",
          "signature": "b -\u003e (EBasis, EBasis) -\u003e Vect (LaurentPoly Q) (EBasis, EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#xminus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "xminus",
          "normalized": "a-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "package": "HaskellForMaths",
          "signature": "b-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:xminus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "xplus",
          "package": "HaskellForMaths",
          "signature": "b -\u003e (EBasis, EBasis) -\u003e Vect (LaurentPoly Q) (EBasis, EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#xplus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "xplus",
          "normalized": "a-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "package": "HaskellForMaths",
          "signature": "b-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:xplus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "yminus",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e (EBasis, EBasis) -\u003e Vect (LaurentPoly Q) (EBasis, EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#yminus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "yminus",
          "normalized": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:yminus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "yplus",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e (EBasis, EBasis) -\u003e Vect (LaurentPoly Q) (EBasis, EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#yplus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "yplus",
          "normalized": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:yplus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "zminus",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e (EBasis, EBasis) -\u003e Vect (LaurentPoly Q) (EBasis, EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#zminus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "zminus",
          "normalized": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:zminus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "zplus",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e (EBasis, EBasis) -\u003e Vect (LaurentPoly Q) (EBasis, EBasis)",
          "source": "src/Math-QuantumAlgebra-OrientedTangle.html#zplus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra OrientedTangle",
          "module": "Math.QuantumAlgebra.OrientedTangle",
          "name": "zplus",
          "normalized": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "package": "HaskellForMaths",
          "signature": "Int-\u003e(EBasis,EBasis)-\u003eVect(LaurentPoly Q)(EBasis,EBasis)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-OrientedTangle.html#v:zplus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining the quantum plane and its symmetries\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "QuantumPlane",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html",
          "type": "module"
        },
        "index": {
          "description": "module defining the quantum plane and its symmetries",
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "QuantumPlane",
          "package": "HaskellForMaths",
          "partial": "Quantum Plane",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "Aq02",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#Aq02",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "Aq02",
          "package": "HaskellForMaths",
          "partial": "Aq",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#t:Aq02"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "Aq20",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#Aq20",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "Aq20",
          "package": "HaskellForMaths",
          "partial": "Aq",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#t:Aq20"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "M2q",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#M2q",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "M2q",
          "package": "HaskellForMaths",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#t:M2q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "SL2q",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#SL2q",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "SL2q",
          "package": "HaskellForMaths",
          "partial": "SL",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#t:SL2q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "Aq02",
          "package": "HaskellForMaths",
          "signature": "Aq02 (NonComMonomial v)",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#Aq02",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "Aq02",
          "package": "HaskellForMaths",
          "partial": "Aq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:Aq02"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "Aq20",
          "package": "HaskellForMaths",
          "signature": "Aq20 (NonComMonomial v)",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#Aq20",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "Aq20",
          "package": "HaskellForMaths",
          "partial": "Aq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:Aq20"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "M2q",
          "package": "HaskellForMaths",
          "signature": "M2q (NonComMonomial v)",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#M2q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "M2q",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:M2q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "SL2q",
          "package": "HaskellForMaths",
          "signature": "SL2q (NonComMonomial v)",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#SL2q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "SL2q",
          "package": "HaskellForMaths",
          "partial": "SL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:SL2q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "a",
          "package": "HaskellForMaths",
          "signature": "Vect (LaurentPoly Q) (m [Char])",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "a",
          "normalized": "Vect(LaurentPoly Q)(a[Char])",
          "package": "HaskellForMaths",
          "signature": "Vect(LaurentPoly Q)(m[Char])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:a"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "aq02",
          "package": "HaskellForMaths",
          "signature": "[Vect (LaurentPoly Q) (m [Char])]",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#aq02",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "aq02",
          "normalized": "[Vect(LaurentPoly Q)(a[Char])]",
          "package": "HaskellForMaths",
          "signature": "[Vect(LaurentPoly Q)(m[Char])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:aq02"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "aq20",
          "package": "HaskellForMaths",
          "signature": "[Vect (LaurentPoly Q) (m [Char])]",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#aq20",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "aq20",
          "normalized": "[Vect(LaurentPoly Q)(a[Char])]",
          "package": "HaskellForMaths",
          "signature": "[Vect(LaurentPoly Q)(m[Char])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:aq20"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "b",
          "package": "HaskellForMaths",
          "signature": "Vect (LaurentPoly Q) (m [Char])",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#b",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "b",
          "normalized": "Vect(LaurentPoly Q)(a[Char])",
          "package": "HaskellForMaths",
          "signature": "Vect(LaurentPoly Q)(m[Char])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:b"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "c",
          "package": "HaskellForMaths",
          "signature": "Vect (LaurentPoly Q) (m [Char])",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#c",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "c",
          "normalized": "Vect(LaurentPoly Q)(a[Char])",
          "package": "HaskellForMaths",
          "signature": "Vect(LaurentPoly Q)(m[Char])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "d",
          "package": "HaskellForMaths",
          "signature": "Vect (LaurentPoly Q) (m [Char])",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#d",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "d",
          "normalized": "Vect(LaurentPoly Q)(a[Char])",
          "package": "HaskellForMaths",
          "signature": "Vect(LaurentPoly Q)(m[Char])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:d"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "detq",
          "package": "HaskellForMaths",
          "signature": "Vect (LaurentPoly Q) (m [Char])",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#detq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "detq",
          "normalized": "Vect(LaurentPoly Q)(a[Char])",
          "package": "HaskellForMaths",
          "signature": "Vect(LaurentPoly Q)(m[Char])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:detq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "m2q",
          "package": "HaskellForMaths",
          "signature": "[Vect (LaurentPoly Q) (m [Char])]",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#m2q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "m2q",
          "normalized": "[Vect(LaurentPoly Q)(a[Char])]",
          "package": "HaskellForMaths",
          "signature": "[Vect(LaurentPoly Q)(m[Char])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:m2q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "qvar",
          "package": "HaskellForMaths",
          "signature": "v -\u003e Vect (LaurentPoly Q) (m v)",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#qvar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "qvar",
          "normalized": "a-\u003eVect(LaurentPoly Q)(b a)",
          "package": "HaskellForMaths",
          "signature": "v-\u003eVect(LaurentPoly Q)(m v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:qvar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "sl2q",
          "package": "HaskellForMaths",
          "signature": "[Vect (LaurentPoly Q) (m [Char])]",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#sl2q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "sl2q",
          "normalized": "[Vect(LaurentPoly Q)(a[Char])]",
          "package": "HaskellForMaths",
          "signature": "[Vect(LaurentPoly Q)(m[Char])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:sl2q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "u",
          "package": "HaskellForMaths",
          "signature": "Vect (LaurentPoly Q) (m [Char])",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#u",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "u",
          "normalized": "Vect(LaurentPoly Q)(a[Char])",
          "package": "HaskellForMaths",
          "signature": "Vect(LaurentPoly Q)(m[Char])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:u"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "v",
          "package": "HaskellForMaths",
          "signature": "Vect (LaurentPoly Q) (m [Char])",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#v",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "v",
          "normalized": "Vect(LaurentPoly Q)(a[Char])",
          "package": "HaskellForMaths",
          "signature": "Vect(LaurentPoly Q)(m[Char])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:v"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "x",
          "package": "HaskellForMaths",
          "signature": "Vect (LaurentPoly Q) (m [Char])",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#x",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "x",
          "normalized": "Vect(LaurentPoly Q)(a[Char])",
          "package": "HaskellForMaths",
          "signature": "Vect(LaurentPoly Q)(m[Char])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:x"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "y",
          "package": "HaskellForMaths",
          "signature": "Vect (LaurentPoly Q) (m [Char])",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "y",
          "normalized": "Vect(LaurentPoly Q)(a[Char])",
          "package": "HaskellForMaths",
          "signature": "Vect(LaurentPoly Q)(m[Char])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "yb",
          "package": "HaskellForMaths",
          "signature": "Vect (LaurentPoly Q) (t, t) -\u003e Vect (LaurentPoly Q) (t, t)",
          "source": "src/Math-QuantumAlgebra-QuantumPlane.html#yb",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra QuantumPlane",
          "module": "Math.QuantumAlgebra.QuantumPlane",
          "name": "yb",
          "normalized": "Vect(LaurentPoly Q)(a,a)-\u003eVect(LaurentPoly Q)(a,a)",
          "package": "HaskellForMaths",
          "signature": "Vect(LaurentPoly Q)(t,t)-\u003eVect(LaurentPoly Q)(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-QuantumPlane.html#v:yb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining the category of tangles, and representations into the category of vector spaces\n (specifically, knot invariants).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "Tangle",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-Tangle.html",
          "type": "module"
        },
        "index": {
          "description": "module defining the category of tangles and representations into the category of vector spaces specifically knot invariants",
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "Tangle",
          "package": "HaskellForMaths",
          "partial": "Tangle",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "Oriented",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-Tangle.html#Oriented",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "Oriented",
          "package": "HaskellForMaths",
          "partial": "Oriented",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#t:Oriented"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "Tangle",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-Tangle.html#Tangle",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "Tangle",
          "package": "HaskellForMaths",
          "partial": "Tangle",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#t:Tangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "TangleRep",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-Tangle.html#TangleRep",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "TangleRep",
          "package": "HaskellForMaths",
          "partial": "Tangle Rep",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#t:TangleRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "Minus",
          "package": "HaskellForMaths",
          "signature": "Minus",
          "source": "src/Math-QuantumAlgebra-Tangle.html#Oriented",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "Minus",
          "package": "HaskellForMaths",
          "partial": "Minus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#v:Minus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "Plus",
          "package": "HaskellForMaths",
          "signature": "Plus",
          "source": "src/Math-QuantumAlgebra-Tangle.html#Oriented",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "Plus",
          "package": "HaskellForMaths",
          "partial": "Plus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#v:Plus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "cap",
          "package": "HaskellForMaths",
          "signature": "[Oriented] -\u003e TangleRep [Oriented]",
          "source": "src/Math-QuantumAlgebra-Tangle.html#cap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "cap",
          "normalized": "[Oriented]-\u003eTangleRep[Oriented]",
          "package": "HaskellForMaths",
          "signature": "[Oriented]-\u003eTangleRep[Oriented]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#v:cap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "cup",
          "package": "HaskellForMaths",
          "signature": "[Oriented] -\u003e TangleRep [Oriented]",
          "source": "src/Math-QuantumAlgebra-Tangle.html#cup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "cup",
          "normalized": "[Oriented]-\u003eTangleRep[Oriented]",
          "package": "HaskellForMaths",
          "signature": "[Oriented]-\u003eTangleRep[Oriented]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#v:cup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "kauffman",
          "package": "HaskellForMaths",
          "signature": "Ar Tangle -\u003e TangleRep [Oriented] -\u003e TangleRep [Oriented]",
          "source": "src/Math-QuantumAlgebra-Tangle.html#kauffman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "kauffman",
          "normalized": "Ar Tangle-\u003eTangleRep[Oriented]-\u003eTangleRep[Oriented]",
          "package": "HaskellForMaths",
          "signature": "Ar Tangle-\u003eTangleRep[Oriented]-\u003eTangleRep[Oriented]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#v:kauffman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "loop",
          "package": "HaskellForMaths",
          "signature": "Vect (LaurentPoly Q) [Oriented]",
          "source": "src/Math-QuantumAlgebra-Tangle.html#loop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "loop",
          "normalized": "Vect(LaurentPoly Q)[Oriented]",
          "package": "HaskellForMaths",
          "signature": "Vect(LaurentPoly Q)[Oriented]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#v:loop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "loopT",
          "package": "HaskellForMaths",
          "signature": "Ar Tangle",
          "source": "src/Math-QuantumAlgebra-Tangle.html#loopT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "loopT",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#v:loopT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "over",
          "package": "HaskellForMaths",
          "signature": "[Oriented] -\u003e TangleRep [Oriented]",
          "source": "src/Math-QuantumAlgebra-Tangle.html#over",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "over",
          "normalized": "[Oriented]-\u003eTangleRep[Oriented]",
          "package": "HaskellForMaths",
          "signature": "[Oriented]-\u003eTangleRep[Oriented]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#v:over"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "trefoil",
          "package": "HaskellForMaths",
          "signature": "Vect (LaurentPoly Q) [Oriented]",
          "source": "src/Math-QuantumAlgebra-Tangle.html#trefoil",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "trefoil",
          "normalized": "Vect(LaurentPoly Q)[Oriented]",
          "package": "HaskellForMaths",
          "signature": "Vect(LaurentPoly Q)[Oriented]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#v:trefoil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "trefoilT",
          "package": "HaskellForMaths",
          "signature": "Ar Tangle",
          "source": "src/Math-QuantumAlgebra-Tangle.html#trefoilT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "trefoilT",
          "package": "HaskellForMaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#v:trefoilT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "under",
          "package": "HaskellForMaths",
          "signature": "[Oriented] -\u003e TangleRep [Oriented]",
          "source": "src/Math-QuantumAlgebra-Tangle.html#under",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra Tangle",
          "module": "Math.QuantumAlgebra.Tangle",
          "name": "under",
          "normalized": "[Oriented]-\u003eTangleRep[Oriented]",
          "package": "HaskellForMaths",
          "signature": "[Oriented]-\u003eTangleRep[Oriented]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-Tangle.html#v:under"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module defining classes and example instances of categories and tensor categories\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "TensorCategory",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html",
          "type": "module"
        },
        "index": {
          "description": "module defining classes and example instances of categories and tensor categories",
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "TensorCategory",
          "package": "HaskellForMaths",
          "partial": "Tensor Category",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "Braid",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#Braid",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "Braid",
          "package": "HaskellForMaths",
          "partial": "Braid",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#t:Braid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "Category",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#Category",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "Category",
          "package": "HaskellForMaths",
          "partial": "Category",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#t:Category"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "Cob2",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#Cob2",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "Cob2",
          "package": "HaskellForMaths",
          "partial": "Cob",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#t:Cob2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "StrictTensorCategory",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#StrictTensorCategory",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "StrictTensorCategory",
          "package": "HaskellForMaths",
          "partial": "Strict Tensor Category",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#t:StrictTensorCategory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "SymmetricGroupoid",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#SymmetricGroupoid",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "SymmetricGroupoid",
          "package": "HaskellForMaths",
          "partial": "Symmetric Groupoid",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#t:SymmetricGroupoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "TensorCategory",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#TensorCategory",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "TensorCategory",
          "package": "HaskellForMaths",
          "partial": "Tensor Category",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#t:TensorCategory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "WeakTensorCategory",
          "package": "HaskellForMaths",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#WeakTensorCategory",
          "type": "class"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "WeakTensorCategory",
          "package": "HaskellForMaths",
          "partial": "Weak Tensor Category",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#t:WeakTensorCategory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "(\u003e\u003e\u003e)",
          "package": "HaskellForMaths",
          "signature": "Ar c -\u003e Ar c -\u003e Ar c",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#%3E%3E%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "(\u003e\u003e\u003e) \u003e\u003e\u003e",
          "normalized": "Ar a-\u003eAr a-\u003eAr a",
          "package": "HaskellForMaths",
          "signature": "Ar c-\u003eAr c-\u003eAr c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#v:-62--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "assoc",
          "package": "HaskellForMaths",
          "signature": "Ob c -\u003e Ob c -\u003e Ob c",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#assoc",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "assoc",
          "normalized": "Ob a-\u003eOb a-\u003eOb a",
          "package": "HaskellForMaths",
          "signature": "Ob c-\u003eOb c-\u003eOb c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#v:assoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "id_",
          "package": "HaskellForMaths",
          "signature": "Ob c -\u003e Ar c",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#id_",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "id_",
          "normalized": "Ob a-\u003eAr a",
          "package": "HaskellForMaths",
          "signature": "Ob c-\u003eAr c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#v:id_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "lunit",
          "package": "HaskellForMaths",
          "signature": "Ob c -\u003e Ob c",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#lunit",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "lunit",
          "normalized": "Ob a-\u003eOb a",
          "package": "HaskellForMaths",
          "signature": "Ob c-\u003eOb c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#v:lunit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "rewrite",
          "package": "HaskellForMaths",
          "signature": "Ar Cob2 -\u003e Ar Cob2",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#rewrite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "rewrite",
          "normalized": "Ar Cob-\u003eAr Cob",
          "package": "HaskellForMaths",
          "signature": "Ar Cob-\u003eAr Cob",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#v:rewrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "runit",
          "package": "HaskellForMaths",
          "signature": "Ob c -\u003e Ob c",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#runit",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "runit",
          "normalized": "Ob a-\u003eOb a",
          "package": "HaskellForMaths",
          "signature": "Ob c-\u003eOb c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#v:runit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "s",
          "package": "HaskellForMaths",
          "signature": "Int -\u003e Int -\u003e Ar Braid",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#s",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "s",
          "normalized": "Int-\u003eInt-\u003eAr Braid",
          "package": "HaskellForMaths",
          "signature": "Int-\u003eInt-\u003eAr Braid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#v:s"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "source",
          "package": "HaskellForMaths",
          "signature": "Ar c -\u003e Ob c",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#source",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "source",
          "normalized": "Ar a-\u003eOb a",
          "package": "HaskellForMaths",
          "signature": "Ar c-\u003eOb c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#v:source"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "tar",
          "package": "HaskellForMaths",
          "signature": "Ar c -\u003e Ar c -\u003e Ar c",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#tar",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "tar",
          "normalized": "Ar a-\u003eAr a-\u003eAr a",
          "package": "HaskellForMaths",
          "signature": "Ar c-\u003eAr c-\u003eAr c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#v:tar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "tob",
          "package": "HaskellForMaths",
          "signature": "Ob c -\u003e Ob c -\u003e Ob c",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#tob",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "tob",
          "normalized": "Ob a-\u003eOb a-\u003eOb a",
          "package": "HaskellForMaths",
          "signature": "Ob c-\u003eOb c-\u003eOb c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#v:tob"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "tunit",
          "package": "HaskellForMaths",
          "signature": "Ob c",
          "source": "src/Math-QuantumAlgebra-TensorCategory.html#tunit",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math QuantumAlgebra TensorCategory",
          "module": "Math.QuantumAlgebra.TensorCategory",
          "name": "tunit",
          "package": "HaskellForMaths",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/HaskellForMaths/docs/Math-QuantumAlgebra-TensorCategory.html#v:tunit"
      }
    }
  ]
]