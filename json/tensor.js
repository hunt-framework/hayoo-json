[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "tensor"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "Cardinal",
          "package": "tensor",
          "source": "src/Data-Cardinal.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "Cardinal",
          "package": "tensor",
          "partial": "Cardinal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "C0",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#C0",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "C0",
          "package": "tensor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:C0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "C1",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#C1",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "C1",
          "package": "tensor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:C1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "C10",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#C10",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "C10",
          "package": "tensor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:C10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "C2",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#C2",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "C2",
          "package": "tensor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:C2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "C3",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#C3",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "C3",
          "package": "tensor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:C3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "C4",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#C4",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "C4",
          "package": "tensor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:C4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "C5",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#C5",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "C5",
          "package": "tensor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:C5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "C6",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#C6",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "C6",
          "package": "tensor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:C6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "C7",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#C7",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "C7",
          "package": "tensor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:C7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "C8",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#C8",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "C8",
          "package": "tensor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:C8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "C9",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#C9",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "C9",
          "package": "tensor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:C9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCardinal number as a type. The associated data type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e\n provides the next cardinal type. The method \u003ccode\u003e\u003ccode\u003e\u003ca\u003efromCardinal\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n provides a numeric representation of the cardinal number; it should\n be independent on the argument and work on \u003ccode\u003e\u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Cardinal",
          "name": "Cardinal",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#Cardinal",
          "type": "class"
        },
        "index": {
          "description": "Cardinal number as type The associated data type Succ provides the next cardinal type The method fromCardinal provides numeric representation of the cardinal number it should be independent on the argument and work on undefined",
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "Cardinal",
          "package": "tensor",
          "partial": "Cardinal",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:Cardinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe cardinality of a type is defined by its \u003ccode\u003e\u003ccode\u003e\u003ca\u003eCardinal\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e type\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eCard\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Cardinal",
          "name": "Cardinality",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#Cardinality",
          "type": "class"
        },
        "index": {
          "description": "The cardinality of type is defined by its Cardinal type Card",
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "Cardinality",
          "package": "tensor",
          "partial": "Cardinality",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:Cardinality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "GCardinality",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#GCardinality",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "GCardinality",
          "package": "tensor",
          "partial": "GCardinality",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:GCardinality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "Zero",
          "package": "tensor",
          "source": "src/Data-Cardinal.html#Zero",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "Zero",
          "package": "tensor",
          "partial": "Zero",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#t:Zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe numeric cardinality of a type. \u003ccode\u003e\u003ccode\u003e\u003ca\u003ecard\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is independent on its\n argument.\n\u003c/p\u003e",
          "module": "Data.Cardinal",
          "name": "card",
          "package": "tensor",
          "signature": "a -\u003e i",
          "source": "src/Data-Cardinal.html#card",
          "type": "function"
        },
        "index": {
          "description": "The numeric cardinality of type card is independent on its argument",
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "card",
          "normalized": "a-\u003eb",
          "package": "tensor",
          "signature": "a-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#v:card"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cardinal",
          "name": "fromCardinal",
          "package": "tensor",
          "signature": "a -\u003e i",
          "source": "src/Data-Cardinal.html#fromCardinal",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Cardinal",
          "module": "Data.Cardinal",
          "name": "fromCardinal",
          "normalized": "a-\u003eb",
          "package": "tensor",
          "partial": "Cardinal",
          "signature": "a-\u003ei",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Cardinal.html#v:fromCardinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eIn this module we provide a way to canonically define a totally ordered set\n with a given number of elements.  These types have a custom \u003ccode\u003e\u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n instances so that their elements are displayed with usual decimal number.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eOne\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e = {\u003ccode\u003e\u003ca\u003eOne\u003c/a\u003e\u003c/code\u003e} = {1}\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eOne\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e = {\u003ccode\u003e\u003ccode\u003e\u003ca\u003eFirst\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eOne\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e} = {1,2}\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eOne\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e = {\u003ccode\u003e\u003ccode\u003e\u003ca\u003eFirst\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFirst\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eOne\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e} = {1,2,3}\n\u003c/p\u003e\u003cp\u003e...\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Ordinal",
          "name": "Ordinal",
          "package": "tensor",
          "source": "src/Data-Ordinal.html",
          "type": "module"
        },
        "index": {
          "description": "In this module we provide way to canonically define totally ordered set with given number of elements These types have custom Show instances so that their elements are displayed with usual decimal number One One Succ One First Succ One Succ Succ One First Succ First Succ Succ One",
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "Ordinal",
          "package": "tensor",
          "partial": "Ordinal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ordinal",
          "name": "Eight",
          "package": "tensor",
          "source": "src/Data-Ordinal.html#Eight",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "Eight",
          "package": "tensor",
          "partial": "Eight",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#t:Eight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ordinal",
          "name": "Five",
          "package": "tensor",
          "source": "src/Data-Ordinal.html#Five",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "Five",
          "package": "tensor",
          "partial": "Five",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#t:Five"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ordinal",
          "name": "Four",
          "package": "tensor",
          "source": "src/Data-Ordinal.html#Four",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "Four",
          "package": "tensor",
          "partial": "Four",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#t:Four"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ordinal",
          "name": "Nine",
          "package": "tensor",
          "source": "src/Data-Ordinal.html#Nine",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "Nine",
          "package": "tensor",
          "partial": "Nine",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#t:Nine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA set with one element.\n\u003c/p\u003e",
          "module": "Data.Ordinal",
          "name": "One",
          "package": "tensor",
          "source": "src/Data-Ordinal.html#One",
          "type": "data"
        },
        "index": {
          "description": "set with one element",
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "One",
          "package": "tensor",
          "partial": "One",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#t:One"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass of ordered sets with n elements. The methods in this class\n provide a convenient way to convert to and from a numeric type.\n\u003c/p\u003e",
          "module": "Data.Ordinal",
          "name": "Ordinal",
          "package": "tensor",
          "source": "src/Data-Ordinal.html#Ordinal",
          "type": "class"
        },
        "index": {
          "description": "Class of ordered sets with elements The methods in this class provide convenient way to convert to and from numeric type",
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "Ordinal",
          "package": "tensor",
          "partial": "Ordinal",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#t:Ordinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ordinal",
          "name": "Seven",
          "package": "tensor",
          "source": "src/Data-Ordinal.html#Seven",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "Seven",
          "package": "tensor",
          "partial": "Seven",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#t:Seven"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ordinal",
          "name": "Six",
          "package": "tensor",
          "source": "src/Data-Ordinal.html#Six",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "Six",
          "package": "tensor",
          "partial": "Six",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#t:Six"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf \u003ccode\u003en\u003c/code\u003e is a set with n elements, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e is a set with n+1 elements.\n\u003c/p\u003e",
          "module": "Data.Ordinal",
          "name": "Succ",
          "package": "tensor",
          "source": "src/Data-Ordinal.html#Succ",
          "type": "data"
        },
        "index": {
          "description": "If is set with elements Succ is set with elements",
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "Succ",
          "package": "tensor",
          "partial": "Succ",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#t:Succ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ordinal",
          "name": "Ten",
          "package": "tensor",
          "source": "src/Data-Ordinal.html#Ten",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "Ten",
          "package": "tensor",
          "partial": "Ten",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#t:Ten"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ordinal",
          "name": "Three",
          "package": "tensor",
          "source": "src/Data-Ordinal.html#Three",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "Three",
          "package": "tensor",
          "partial": "Three",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#t:Three"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ordinal",
          "name": "Two",
          "package": "tensor",
          "source": "src/Data-Ordinal.html#Two",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "Two",
          "package": "tensor",
          "partial": "Two",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#t:Two"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe first element of the type.\n\u003c/p\u003e",
          "module": "Data.Ordinal",
          "name": "First",
          "package": "tensor",
          "signature": "First",
          "source": "src/Data-Ordinal.html#Succ",
          "type": "function"
        },
        "index": {
          "description": "The first element of the type",
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "First",
          "package": "tensor",
          "partial": "First",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#v:First"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ordinal",
          "name": "One",
          "package": "tensor",
          "signature": "One",
          "source": "src/Data-Ordinal.html#One",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "One",
          "package": "tensor",
          "partial": "One",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#v:One"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe last \u003ccode\u003en\u003c/code\u003e elements.\n\u003c/p\u003e",
          "module": "Data.Ordinal",
          "name": "Succ",
          "package": "tensor",
          "signature": "Succ n",
          "source": "src/Data-Ordinal.html#Succ",
          "type": "function"
        },
        "index": {
          "description": "The last elements",
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "Succ",
          "package": "tensor",
          "partial": "Succ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#v:Succ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ordinal",
          "name": "fromOrdinal",
          "package": "tensor",
          "signature": "n -\u003e i",
          "source": "src/Data-Ordinal.html#fromOrdinal",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "fromOrdinal",
          "normalized": "a-\u003eb",
          "package": "tensor",
          "partial": "Ordinal",
          "signature": "n-\u003ei",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#v:fromOrdinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ordinal",
          "name": "toOrdinal",
          "package": "tensor",
          "signature": "i -\u003e n",
          "source": "src/Data-Ordinal.html#toOrdinal",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Ordinal",
          "module": "Data.Ordinal",
          "name": "toOrdinal",
          "normalized": "a-\u003eb",
          "package": "tensor",
          "partial": "Ordinal",
          "signature": "i-\u003en",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Ordinal.html#v:toOrdinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis library defines data types and classes for fixed dimension\nvectors and tensors. The main objects are:\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eOrdinal\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e A totally ordered set with fixed size. The\n\u003ccode\u003e\u003ccode\u003e\u003ca\u003eOrdinal\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eOne\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e contains 1 element,\n\u003ccode\u003e\u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eOne\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e contains 2 elements,\n\u003ccode\u003e\u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eOne\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e contains\n3 elements, and so on (see \u003ca\u003eData.Ordinal\u003c/a\u003e for more details). The type\n\u003ccode\u003e\u003ccode\u003e\u003ca\u003eTwo\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is an alias for \u003ccode\u003e\u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e\n\u003ccode\u003e\u003ca\u003eOne\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eThree\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is an alias for\n\u003ccode\u003e\u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eOne\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, and so\non.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eMultiIndex\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e The index set. It can be\nlinear, rectangular, parallelepipedal, etc. The dimensions of the\nsides are expressed using \u003ccode\u003e\u003ccode\u003e\u003ca\u003eOrdinal\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e types and the type\nconstructor \u003ccode\u003e\u003ccode\u003e\u003ca\u003e:|:\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e,\ne.g. \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eTwo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e:|:\u003c/a\u003e\u003c/code\u003e\n(\u003ccode\u003e\u003ca\u003eThree\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e:|:\u003c/a\u003e\u003c/code\u003e\n\u003ccode\u003e\u003ca\u003eNil\u003c/a\u003e\u003c/code\u003e))\u003c/code\u003e is a rectangular index set with 2\nrows and 3 columns. The index set also contains elements, for example\n\u003ccode\u003e(\u003ccode\u003e\u003ca\u003eTwo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e:|:\u003c/a\u003e\u003c/code\u003e\n(\u003ccode\u003e\u003ca\u003eThree\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e:|:\u003c/a\u003e\u003c/code\u003e\n\u003ccode\u003e\u003ca\u003eNil\u003c/a\u003e\u003c/code\u003e))\u003c/code\u003e contains all the pairs \u003ccode\u003e(i\n\u003ccode\u003e\u003ca\u003e:|:\u003c/a\u003e\u003c/code\u003e (j \u003ccode\u003e\u003ca\u003e:|:\u003c/a\u003e\u003c/code\u003e\nNil))\u003c/code\u003e where i is in \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTwo\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and j is in\n\u003ccode\u003e\u003ccode\u003e\u003ca\u003eThree\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e. See \u003ca\u003eData.TypeList.MultiIndex\u003c/a\u003e for more\ndetails.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eTensor\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e It is an assignment of elements to each\nelement of its \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMultiIndex\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eObjects like vectors and matrices are special cases of tensors.  Most of\nthe functions to manipulate tensors are grouped into type classes.  This\nallow the possibility of having different internal representations\n(backends) of a tensor, and act on these with the same functions. At the\nmoment we provide two backends: one in \u003ca\u003eData.Tensor.Pure\u003c/a\u003e (not complete)\nthat uses a recursive definition, and another in \u003ca\u003eData.Tensor.Vector\u003c/a\u003e\nthat is based on \u003ca\u003ehttp://hackage.haskell.org/package/vector\u003c/a\u003e and is\nfaster. More backends (e.g. one based on\n\u003ca\u003ehttp://hackage.haskell.org/package/repa\u003c/a\u003e) are planned for future\nreleases.\n\u003c/p\u003e\u003cp\u003eHere is a usage example (start \u003ccode\u003eghci\u003c/code\u003e with the option\n\u003ccode\u003e-XTypeOperators\u003c/code\u003e):\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Tensor.Vector\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [2,3,5,1,3,6,0,5,4,2,1,3] :: Tensor (Four :|: Three :|: Nil) Int\n\u003c/code\u003e\u003c/strong\u003e[[2,3,5],[1,3,6],[0,5,4],[2,1,3]]\n\u003c/pre\u003e\u003cp\u003eThe above defines a tensor with 4 rows and 3 columns (a matrix) and\n\u003ccode\u003e\u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e coefficients. The entries of this matrix are taken from a list\nusing \u003ccode\u003e\u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e which is a method of the class\n\u003ccode\u003e\u003ccode\u003e\u003ca\u003eFromList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e. Notice the output: the \u003ccode\u003e\u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e instance is\ndefined in such a way to give a readable representation as list of\nlists. The is equivalent but slightly more readable code:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [2,3,5,1,3,6,0,5,4,2,1,3] :: Matrix Four Three Int\n\u003c/code\u003e\u003c/strong\u003e[[2,3,5],[1,3,6],[0,5,4],[2,1,3]]\n\u003c/pre\u003e\u003cp\u003eAnalogously\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [7,3,-6] :: Tensor (Three :|: Nil) Int\n\u003c/code\u003e\u003c/strong\u003e[7,3,-6]\n\u003c/pre\u003e\u003cp\u003eand\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [7,3,-6] :: Vector Three Int\n\u003c/code\u003e\u003c/strong\u003e[7,3,-6]\n\u003c/pre\u003e\u003cp\u003eare the same. In order to access an entry of a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTensor\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\nwe use the \u003ccode\u003e\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e operator, which takes the same\n\u003ccode\u003e\u003ccode\u003e\u003ca\u003eMultiIndex\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e of the \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTensor\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\nas its second argument:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet a = fromList [2,3,5,1,3,6,0,5,4,2,1,3] :: Matrix Four Three Int\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet b = fromList [7,3,-6] :: Vector Three Int\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ea ! (toMultiIndex [1,3] :: (Four :|: Three :|: Nil))\n\u003c/code\u003e\u003c/strong\u003e5\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eb ! (toMultiIndex [2] :: (Three :|: Nil))\n\u003c/code\u003e\u003c/strong\u003e3\n\u003c/pre\u003e\u003cp\u003eit returns the element at the coordinate (1,3) of the matrix \u003ccode\u003ea\u003c/code\u003e, and\nthe element at the coordinate 2 of the vector b. In fact, thanks to\ntype inference, we could simply write\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ea ! toMultiIndex [1,3]\n\u003c/code\u003e\u003c/strong\u003e5\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eb ! toMultiIndex [2]\n\u003c/code\u003e\u003c/strong\u003e2\n\u003c/pre\u003e\u003cp\u003eAnd now a couple of examples of algebraic operations (requires adding\n\u003ccode\u003e\u003ca\u003eData.Tensor.LinearAlgebra\u003c/a\u003e\u003c/code\u003e to the import list):\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Tensor.Vector\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Tensor.LinearAlgebra hiding (Matrix)\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet a = fromList [2,3,5,1,3,6,0,5,4,2,1,3] :: Matrix Four Three Int\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet b = fromList [7,3,-6] :: Vector Three Int\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ea .*. b\n\u003c/code\u003e\u003c/strong\u003e[-7,-20,-9,-1]\n\u003c/pre\u003e\u003cp\u003eis the product of matrix \u003ccode\u003ea\u003c/code\u003e and vector \u003ccode\u003eb\u003c/code\u003e, while\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet c = fromList [3,4,0,-1,4,5,6,2,1] :: Matrix Three Three Int\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ec\n\u003c/code\u003e\u003c/strong\u003e[[3,4,0],[-1,4,5],[6,2,1]]\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003echarPoly c\n\u003c/code\u003e\u003c/strong\u003e[106,13,8]\n\u003c/pre\u003e\u003cp\u003egives the coefficients of the characteristic polynomial of the matrix\n\u003ccode\u003ec\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Tensor.Examples",
          "name": "Examples",
          "package": "tensor",
          "source": "src/Data-Tensor-Examples.html",
          "type": "module"
        },
        "index": {
          "description": "This library defines data types and classes for fixed dimension vectors and tensors The main objects are Ordinal totally ordered set with fixed size The Ordinal type One contains element Succ One contains elements Succ Succ One contains elements and so on see Data.Ordinal for more details The type Two is an alias for Succ One Three is an alias for Succ Succ One and so on MultiIndex The index set It can be linear rectangular parallelepipedal etc The dimensions of the sides are expressed using Ordinal types and the type constructor e.g Two Three Nil is rectangular index set with rows and columns The index set also contains elements for example Two Three Nil contains all the pairs Nil where is in Two and is in Three See Data.TypeList.MultiIndex for more details Tensor It is an assignment of elements to each element of its MultiIndex Objects like vectors and matrices are special cases of tensors Most of the functions to manipulate tensors are grouped into type classes This allow the possibility of having different internal representations backends of tensor and act on these with the same functions At the moment we provide two backends one in Data.Tensor.Pure not complete that uses recursive definition and another in Data.Tensor.Vector that is based on http hackage.haskell.org package vector and is faster More backends e.g one based on http hackage.haskell.org package repa are planned for future releases Here is usage example start ghci with the option XTypeOperators import Data.Tensor.Vector fromList Tensor Four Three Nil Int The above defines tensor with rows and columns matrix and Int coefficients The entries of this matrix are taken from list using fromList which is method of the class FromList Notice the output the Show instance is defined in such way to give readable representation as list of lists The is equivalent but slightly more readable code fromList Matrix Four Three Int Analogously fromList Tensor Three Nil Int and fromList Vector Three Int are the same In order to access an entry of Tensor we use the operator which takes the same MultiIndex of the Tensor as its second argument let fromList Matrix Four Three Int let fromList Vector Three Int toMultiIndex Four Three Nil toMultiIndex Three Nil it returns the element at the coordinate of the matrix and the element at the coordinate of the vector In fact thanks to type inference we could simply write toMultiIndex toMultiIndex And now couple of examples of algebraic operations requires adding Data.Tensor.LinearAlgebra to the import list import Data.Tensor.Vector import Data.Tensor.LinearAlgebra hiding Matrix let fromList Matrix Four Three Int let fromList Vector Three Int is the product of matrix and vector while let fromList Matrix Three Three Int charPoly gives the coefficients of the characteristic polynomial of the matrix",
          "hierarchy": "Data Tensor Examples",
          "module": "Data.Tensor.Examples",
          "name": "Examples",
          "package": "tensor",
          "partial": "Examples",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Examples.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.LinearAlgebra",
          "name": "LinearAlgebra",
          "package": "tensor",
          "source": "src/Data-Tensor-LinearAlgebra.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "LinearAlgebra",
          "package": "tensor",
          "partial": "Linear Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.LinearAlgebra",
          "name": ":⊗:",
          "package": "tensor",
          "source": "src/Data-Tensor-LinearAlgebra.html#%3A%2297%3A",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": ":⊗:",
          "package": "tensor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#t::-8855-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.LinearAlgebra",
          "name": "DotProduct",
          "package": "tensor",
          "source": "src/Data-Tensor-LinearAlgebra.html#DotProduct",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "DotProduct",
          "package": "tensor",
          "partial": "Dot Product",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#t:DotProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolves linear systems \u003ccode\u003eAX=B\u003c/code\u003e; \u003ccode\u003et1\u003c/code\u003e is the type of \u003ccode\u003eA\u003c/code\u003e, \u003ccode\u003et2\u003c/code\u003e is\n the type of \u003ccode\u003eB\u003c/code\u003e, and \u003ccode\u003e\u003ccode\u003e\u003ca\u003eSolSpace\u003c/a\u003e\u003c/code\u003e t1 t2\u003c/code\u003e is the type of the solution\n \u003ccode\u003eX\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "LinearSystem",
          "package": "tensor",
          "source": "src/Data-Tensor-LinearAlgebra.html#LinearSystem",
          "type": "class"
        },
        "index": {
          "description": "Solves linear systems AX t1 is the type of t2 is the type of and SolSpace t1 t2 is the type of the solution",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "LinearSystem",
          "package": "tensor",
          "partial": "Linear System",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#t:LinearSystem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA matrix with \u003ccode\u003ei\u003c/code\u003e rows and \u003ccode\u003ej\u003c/code\u003e columns.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "Matrix",
          "package": "tensor",
          "source": "src/Data-Tensor-LinearAlgebra.html#Matrix",
          "type": "class"
        },
        "index": {
          "description": "matrix with rows and columns",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "Matrix",
          "package": "tensor",
          "partial": "Matrix",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#t:Matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.LinearAlgebra",
          "name": "MatrixProductSpace",
          "package": "tensor",
          "source": "src/Data-Tensor-LinearAlgebra.html#MatrixProductSpace",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "MatrixProductSpace",
          "package": "tensor",
          "partial": "Matrix Product Space",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#t:MatrixProductSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA general form of product between two tensors, in which the last\n \u003ccode\u003en\u003c/code\u003e dimensions of \u003ccode\u003et1\u003c/code\u003e are contracted with the first \u003ccode\u003en\u003c/code\u003e dimensions\n of \u003ccode\u003et2\u003c/code\u003e. The resulting tensor belongs to the space \u003ccode\u003e\u003ccode\u003e\u003ca\u003eProdSpace\u003c/a\u003e\u003c/code\u003e n\n t1 t2\u003c/code\u003e. The operators \u003ccode\u003e\u003ccode\u003e\u003ca\u003e.*.\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and \u003ccode/\u003e below are particular cases\n where \u003ccode\u003en\u003c/code\u003e is equal to 1 and 0 respectively.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "Product",
          "package": "tensor",
          "source": "src/Data-Tensor-LinearAlgebra.html#Product",
          "type": "class"
        },
        "index": {
          "description": "general form of product between two tensors in which the last dimensions of t1 are contracted with the first dimensions of t2 The resulting tensor belongs to the space ProdSpace t1 t2 The operators and below are particular cases where is equal to and respectively",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "Product",
          "package": "tensor",
          "partial": "Product",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#t:Product"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.LinearAlgebra",
          "name": "SquareMatrix",
          "package": "tensor",
          "source": "src/Data-Tensor-LinearAlgebra.html#SquareMatrix",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "SquareMatrix",
          "package": "tensor",
          "partial": "Square Matrix",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#t:SquareMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.LinearAlgebra",
          "name": "VectorSpace",
          "package": "tensor",
          "source": "src/Data-Tensor-LinearAlgebra.html#VectorSpace",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "VectorSpace",
          "package": "tensor",
          "partial": "Vector Space",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#t:VectorSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.LinearAlgebra",
          "name": "(*.)",
          "package": "tensor",
          "signature": "e -\u003e v e -\u003e v e",
          "source": "src/Data-Tensor-LinearAlgebra.html#%2A.",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "(*.) *.",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "tensor",
          "signature": "e-\u003ev e-\u003ev e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:-42-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTensor product of \u003ccode\u003et1\u003c/code\u003e and \u003ccode\u003et2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "(⊗)",
          "package": "tensor",
          "signature": "t1 -\u003e t2 -\u003e t1 :⊗: t2",
          "source": "src/Data-Tensor-LinearAlgebra.html#%2297",
          "type": "function"
        },
        "index": {
          "description": "Tensor product of t1 and t2",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "(⊗) ⊗",
          "normalized": "a-\u003ea-\u003ea a",
          "package": "tensor",
          "signature": "t-\u003et-\u003et t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:-8855-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt is the product of the last dimension of \u003ccode\u003et1\u003c/code\u003e with the first\n dimension of \u003ccode\u003et2\u003c/code\u003e. In the case where \u003ccode\u003et1\u003c/code\u003e and \u003ccode\u003et2\u003c/code\u003e are matrices this\n coincide with the ordinary matrix product.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "(.*.)",
          "package": "tensor",
          "signature": "t1 -\u003e t2 -\u003e MatrixProductSpace t1 t2",
          "source": "src/Data-Tensor-LinearAlgebra.html#.%2A.",
          "type": "function"
        },
        "index": {
          "description": "It is the product of the last dimension of t1 with the first dimension of t2 In the case where t1 and t2 are matrices this coincide with the ordinary matrix product",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "(.*.) .*.",
          "normalized": "a-\u003ea-\u003eMatrixProductSpace a a",
          "package": "tensor",
          "signature": "t-\u003et-\u003eMatrixProductSpace t t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:.-42-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.LinearAlgebra",
          "name": "(.+.)",
          "package": "tensor",
          "signature": "v e -\u003e v e -\u003e v e",
          "source": "src/Data-Tensor-LinearAlgebra.html#.%2B.",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "(.+.) .+.",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "tensor",
          "signature": "v e-\u003ev e-\u003ev e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:.-43-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputes the coefficient of the polynomial p(z)=det(A+zI)\n using the method of \u003cem\u003eclosed ordered walks\u003c/em\u003e (\u003cem\u003eclow\u003c/em\u003e) illustrated\n in the paper of G. Rote\n \u003ca\u003ehttp://page.mi.fu-berlin.de/rote/Papers/pdf/Division-free+algorithms.pdf\u003c/a\u003e.\n The number of operations for the whole process is O(n^4), where\n n is the number of rows of the matrix. The first coefficient is\n the known term and equals the determinant, while the last one\n is the coefficient of z^(n-1) and equals the trace. The\n coefficient of z^n equals 1 and is not included in the\n resulting list. The k-th coefficient is the sum of all\n principal minors of order n-k+1.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "charPoly",
          "package": "tensor",
          "signature": "t e -\u003e [e]",
          "source": "src/Data-Tensor-LinearAlgebra.html#charPoly",
          "type": "method"
        },
        "index": {
          "description": "Computes the coefficient of the polynomial det zI using the method of closed ordered walks clow illustrated in the paper of Rote http page.mi.fu-berlin.de rote Papers pdf Division-free algorithms.pdf The number of operations for the whole process is where is the number of rows of the matrix The first coefficient is the known term and equals the determinant while the last one is the coefficient of n-1 and equals the trace The coefficient of equals and is not included in the resulting list The k-th coefficient is the sum of all principal minors of order n-k",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "charPoly",
          "normalized": "a b-\u003e[b]",
          "package": "tensor",
          "partial": "Poly",
          "signature": "t e-\u003e[e]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:charPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ecolAdd\u003c/a\u003e\u003c/code\u003e j1 a j2 t\u003c/code\u003e adds \u003ccode\u003ea\u003c/code\u003e times the column \u003ccode\u003ej2\u003c/code\u003e to\n the column \u003ccode\u003ej1\u003c/code\u003e ot \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "colAdd",
          "package": "tensor",
          "signature": "j -\u003e Elem t -\u003e j -\u003e t -\u003e t",
          "source": "src/Data-Tensor-LinearAlgebra.html#colAdd",
          "type": "method"
        },
        "index": {
          "description": "colAdd j1 j2 adds times the column j2 to the column j1 ot",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "colAdd",
          "normalized": "a-\u003eElem b-\u003ea-\u003eb-\u003eb",
          "package": "tensor",
          "partial": "Add",
          "signature": "j-\u003eElem t-\u003ej-\u003et-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:colAdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiply a column by a number.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "colMult",
          "package": "tensor",
          "signature": "j -\u003e Elem t -\u003e t -\u003e t",
          "source": "src/Data-Tensor-LinearAlgebra.html#colMult",
          "type": "method"
        },
        "index": {
          "description": "Multiply column by number",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "colMult",
          "normalized": "a-\u003eElem b-\u003eb-\u003eb",
          "package": "tensor",
          "partial": "Mult",
          "signature": "j-\u003eElem t-\u003et-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:colMult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwitch two columns.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "colSwitch",
          "package": "tensor",
          "signature": "j -\u003e j -\u003e t -\u003e t",
          "source": "src/Data-Tensor-LinearAlgebra.html#colSwitch",
          "type": "method"
        },
        "index": {
          "description": "Switch two columns",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "colSwitch",
          "normalized": "a-\u003ea-\u003eb-\u003eb",
          "package": "tensor",
          "partial": "Switch",
          "signature": "j-\u003ej-\u003et-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:colSwitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeterminant of the matrix.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "det",
          "package": "tensor",
          "signature": "t e -\u003e e",
          "source": "src/Data-Tensor-LinearAlgebra.html#det",
          "type": "method"
        },
        "index": {
          "description": "Determinant of the matrix",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "det",
          "normalized": "a b-\u003eb",
          "package": "tensor",
          "signature": "t e-\u003ee",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:det"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.LinearAlgebra",
          "name": "dot",
          "package": "tensor",
          "signature": "t e -\u003e t e -\u003e e",
          "source": "src/Data-Tensor-LinearAlgebra.html#dot",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "dot",
          "normalized": "a b-\u003ea b-\u003eb",
          "package": "tensor",
          "signature": "t e-\u003et e-\u003ee",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:dot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInverts, if the matrix is invertible, otherwise \u003ccode\u003e\u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "inverse",
          "package": "tensor",
          "signature": "t e -\u003e Maybe (t e)",
          "source": "src/Data-Tensor-LinearAlgebra.html#inverse",
          "type": "method"
        },
        "index": {
          "description": "Inverts if the matrix is invertible otherwise Nothing",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "inverse",
          "normalized": "a b-\u003eMaybe(a b)",
          "package": "tensor",
          "signature": "t e-\u003eMaybe(t e)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:inverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimal polynomial. The algorithm follows the paper of\n S. Bialas and M. Bialas\n \u003ca\u003ehttp://bulletin.pan.pl/(56-4)391.pdf\u003c/a\u003e. The number of\n operations is O(n^4), where n is the number of rows of the\n matrix.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "minPoly",
          "package": "tensor",
          "signature": "t e -\u003e [e]",
          "source": "src/Data-Tensor-LinearAlgebra.html#minPoly",
          "type": "method"
        },
        "index": {
          "description": "Minimal polynomial The algorithm follows the paper of Bialas and Bialas http bulletin.pan.pl pdf The number of operations is where is the number of rows of the matrix",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "minPoly",
          "normalized": "a b-\u003e[b]",
          "package": "tensor",
          "partial": "Poly",
          "signature": "t e-\u003e[e]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:minPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e if the system \u003ccode\u003eAX=B\u003c/code\u003e has no solution,\n otherwise returns a solution for the system and a list of basis\n vectors for the kernel of \u003ccode\u003eA\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "parametricSolve",
          "package": "tensor",
          "signature": "t1 -\u003e t2 -\u003e Maybe (SolSpace t1 t2, [SolSpace t1 t2])",
          "source": "src/Data-Tensor-LinearAlgebra.html#parametricSolve",
          "type": "method"
        },
        "index": {
          "description": "Returns Nothing if the system AX has no solution otherwise returns solution for the system and list of basis vectors for the kernel of",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "parametricSolve",
          "normalized": "a-\u003ea-\u003eMaybe(SolSpace a a,[SolSpace a a])",
          "package": "tensor",
          "partial": "Solve",
          "signature": "t-\u003et-\u003eMaybe(SolSpace t t,[SolSpace t t])",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:parametricSolve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate a polynomial on a matrix.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "polyEval",
          "package": "tensor",
          "signature": "t e -\u003e [e] -\u003e t e",
          "source": "src/Data-Tensor-LinearAlgebra.html#polyEval",
          "type": "method"
        },
        "index": {
          "description": "Evaluate polynomial on matrix",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "polyEval",
          "normalized": "a b-\u003e[b]-\u003ea b",
          "package": "tensor",
          "partial": "Eval",
          "signature": "t e-\u003e[e]-\u003et e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:polyEval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.LinearAlgebra",
          "name": "prod",
          "package": "tensor",
          "signature": "n -\u003e t1 -\u003e t2 -\u003e ProdSpace n t1 t2",
          "source": "src/Data-Tensor-LinearAlgebra.html#prod",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "prod",
          "normalized": "a-\u003eb-\u003eb-\u003eProdSpace a b b",
          "package": "tensor",
          "signature": "n-\u003et-\u003et-\u003eProdSpace n t t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:prod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003erowAdd\u003c/a\u003e\u003c/code\u003e i1 a i2 t\u003c/code\u003e adds \u003ccode\u003ea\u003c/code\u003e times the row \u003ccode\u003ei2\u003c/code\u003e to the\n row \u003ccode\u003ei1\u003c/code\u003e ot \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "rowAdd",
          "package": "tensor",
          "signature": "i -\u003e Elem t -\u003e i -\u003e t -\u003e t",
          "source": "src/Data-Tensor-LinearAlgebra.html#rowAdd",
          "type": "method"
        },
        "index": {
          "description": "rowAdd i1 i2 adds times the row i2 to the row i1 ot",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "rowAdd",
          "normalized": "a-\u003eElem b-\u003ea-\u003eb-\u003eb",
          "package": "tensor",
          "partial": "Add",
          "signature": "i-\u003eElem t-\u003ei-\u003et-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:rowAdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReduced row echelon form of the matrix.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "rowEchelonForm",
          "package": "tensor",
          "signature": "t -\u003e t",
          "source": "src/Data-Tensor-LinearAlgebra.html#rowEchelonForm",
          "type": "method"
        },
        "index": {
          "description": "Reduced row echelon form of the matrix",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "rowEchelonForm",
          "normalized": "a-\u003ea",
          "package": "tensor",
          "partial": "Echelon Form",
          "signature": "t-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:rowEchelonForm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiply a row by a number.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "rowMult",
          "package": "tensor",
          "signature": "i -\u003e Elem t -\u003e t -\u003e t",
          "source": "src/Data-Tensor-LinearAlgebra.html#rowMult",
          "type": "method"
        },
        "index": {
          "description": "Multiply row by number",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "rowMult",
          "normalized": "a-\u003eElem b-\u003eb-\u003eb",
          "package": "tensor",
          "partial": "Mult",
          "signature": "i-\u003eElem t-\u003et-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:rowMult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwitch two rows.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "rowSwitch",
          "package": "tensor",
          "signature": "i -\u003e i -\u003e t -\u003e t",
          "source": "src/Data-Tensor-LinearAlgebra.html#rowSwitch",
          "type": "method"
        },
        "index": {
          "description": "Switch two rows",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "rowSwitch",
          "normalized": "a-\u003ea-\u003eb-\u003eb",
          "package": "tensor",
          "partial": "Switch",
          "signature": "i-\u003ei-\u003et-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:rowSwitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrace of the matrix.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "tr",
          "package": "tensor",
          "signature": "t e -\u003e e",
          "source": "src/Data-Tensor-LinearAlgebra.html#tr",
          "type": "method"
        },
        "index": {
          "description": "Trace of the matrix",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "tr",
          "normalized": "a b-\u003eb",
          "package": "tensor",
          "signature": "t e-\u003ee",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:tr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerforms row operations on the augmented matrix [t1,t2] until\n t1 is in reduced row echelon form, then slits the result.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "triangularSolve",
          "package": "tensor",
          "signature": "t1 -\u003e t2 -\u003e (t1, t2)",
          "source": "src/Data-Tensor-LinearAlgebra.html#triangularSolve",
          "type": "method"
        },
        "index": {
          "description": "Performs row operations on the augmented matrix t1 t2 until t1 is in reduced row echelon form then slits the result",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "triangularSolve",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "tensor",
          "partial": "Solve",
          "signature": "t-\u003et-\u003e(t,t)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:triangularSolve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndentity matrix.\n\u003c/p\u003e",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "unit",
          "package": "tensor",
          "signature": "t e",
          "source": "src/Data-Tensor-LinearAlgebra.html#unit",
          "type": "method"
        },
        "index": {
          "description": "Indentity matrix",
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "unit",
          "package": "tensor",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:unit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.LinearAlgebra",
          "name": "zero",
          "package": "tensor",
          "signature": "v e",
          "source": "src/Data-Tensor-LinearAlgebra.html#zero",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Tensor LinearAlgebra",
          "module": "Data.Tensor.LinearAlgebra",
          "name": "zero",
          "package": "tensor",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-LinearAlgebra.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImplementation of Tensor data type that uses recursively defined type\n families.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Tensor.Pure",
          "name": "Pure",
          "package": "tensor",
          "source": "src/Data-Tensor-Pure.html",
          "type": "module"
        },
        "index": {
          "description": "Implementation of Tensor data type that uses recursively defined type families",
          "hierarchy": "Data Tensor Pure",
          "module": "Data.Tensor.Pure",
          "name": "Pure",
          "package": "tensor",
          "partial": "Pure",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Pure.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.Pure",
          "name": "Matrix",
          "package": "tensor",
          "source": "src/Data-Tensor-Pure.html#Matrix",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Tensor Pure",
          "module": "Data.Tensor.Pure",
          "name": "Matrix",
          "package": "tensor",
          "partial": "Matrix",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Pure.html#t:Matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.Pure",
          "name": "Tensor",
          "package": "tensor",
          "signature": "Tensor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tensor Pure",
          "module": "Data.Tensor.Pure",
          "name": "Tensor",
          "package": "tensor",
          "partial": "Tensor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Pure.html#t:Tensor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.Pure",
          "name": "Vector",
          "package": "tensor",
          "source": "src/Data-Tensor-Pure.html#Vector",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Tensor Pure",
          "module": "Data.Tensor.Pure",
          "name": "Vector",
          "package": "tensor",
          "partial": "Vector",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Pure.html#t:Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module define a datatype \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTensor\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e which implements the classes and\n methods defined in \u003ca\u003eData.Tensor\u003c/a\u003e and \u003ca\u003eData.Tensor.LinearAlgebra\u003c/a\u003e. It is\n represented internally as a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Tensor.Vector",
          "name": "Vector",
          "package": "tensor",
          "source": "src/Data-Tensor-Vector.html",
          "type": "module"
        },
        "index": {
          "description": "This module define datatype Tensor which implements the classes and methods defined in Data.Tensor and Data.Tensor.LinearAlgebra It is represented internally as Vector",
          "hierarchy": "Data Tensor Vector",
          "module": "Data.Tensor.Vector",
          "name": "Vector",
          "package": "tensor",
          "partial": "Vector",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Vector.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.Vector",
          "name": "ColumnVector",
          "package": "tensor",
          "source": "src/Data-Tensor-Vector-Internal.html#ColumnVector",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Tensor Vector",
          "module": "Data.Tensor.Vector",
          "name": "ColumnVector",
          "package": "tensor",
          "partial": "Column Vector",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Vector.html#t:ColumnVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.Vector",
          "name": "Matrix",
          "package": "tensor",
          "source": "src/Data-Tensor-Vector-Internal.html#Matrix",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Tensor Vector",
          "module": "Data.Tensor.Vector",
          "name": "Matrix",
          "package": "tensor",
          "partial": "Matrix",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Vector.html#t:Matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.Vector",
          "name": "RowVector",
          "package": "tensor",
          "source": "src/Data-Tensor-Vector-Internal.html#RowVector",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Tensor Vector",
          "module": "Data.Tensor.Vector",
          "name": "RowVector",
          "package": "tensor",
          "partial": "Row Vector",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Vector.html#t:RowVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.Vector",
          "name": "Tensor",
          "package": "tensor",
          "source": "src/Data-Tensor-Vector-Internal.html#Tensor",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Tensor Vector",
          "module": "Data.Tensor.Vector",
          "name": "Tensor",
          "package": "tensor",
          "partial": "Tensor",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Vector.html#t:Tensor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.Vector",
          "name": "Vector",
          "package": "tensor",
          "source": "src/Data-Tensor-Vector-Internal.html#Vector",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Tensor Vector",
          "module": "Data.Tensor.Vector",
          "name": "Vector",
          "package": "tensor",
          "partial": "Vector",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Vector.html#t:Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.Vector",
          "name": "columnVector2Vector",
          "package": "tensor",
          "signature": "ColumnVector n e -\u003e Vector n e",
          "source": "src/Data-Tensor-Vector-Internal.html#columnVector2Vector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tensor Vector",
          "module": "Data.Tensor.Vector",
          "name": "columnVector2Vector",
          "normalized": "ColumnVector a b-\u003eVector a b",
          "package": "tensor",
          "partial": "Vector Vector",
          "signature": "ColumnVector n e-\u003eVector n e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Vector.html#v:columnVector2Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.Vector",
          "name": "fromVector",
          "package": "tensor",
          "signature": "Vector e -\u003e Tensor i e",
          "source": "src/Data-Tensor-Vector-Internal.html#fromVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tensor Vector",
          "module": "Data.Tensor.Vector",
          "name": "fromVector",
          "normalized": "Vector a-\u003eTensor b a",
          "package": "tensor",
          "partial": "Vector",
          "signature": "Vector e-\u003eTensor i e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Vector.html#v:fromVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.Vector",
          "name": "rowVector2Vector",
          "package": "tensor",
          "signature": "RowVector n e -\u003e Vector n e",
          "source": "src/Data-Tensor-Vector-Internal.html#rowVector2Vector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tensor Vector",
          "module": "Data.Tensor.Vector",
          "name": "rowVector2Vector",
          "normalized": "RowVector a b-\u003eVector a b",
          "package": "tensor",
          "partial": "Vector Vector",
          "signature": "RowVector n e-\u003eVector n e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Vector.html#v:rowVector2Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.Vector",
          "name": "vector2ColumnVector",
          "package": "tensor",
          "signature": "Vector n e -\u003e ColumnVector n e",
          "source": "src/Data-Tensor-Vector-Internal.html#vector2ColumnVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tensor Vector",
          "module": "Data.Tensor.Vector",
          "name": "vector2ColumnVector",
          "normalized": "Vector a b-\u003eColumnVector a b",
          "package": "tensor",
          "partial": "Column Vector",
          "signature": "Vector n e-\u003eColumnVector n e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Vector.html#v:vector2ColumnVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor.Vector",
          "name": "vector2RowVector",
          "package": "tensor",
          "signature": "Vector n e -\u003e RowVector n e",
          "source": "src/Data-Tensor-Vector-Internal.html#vector2RowVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tensor Vector",
          "module": "Data.Tensor.Vector",
          "name": "vector2RowVector",
          "normalized": "Vector a b-\u003eRowVector a b",
          "package": "tensor",
          "partial": "Row Vector",
          "signature": "Vector n e-\u003eRowVector n e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor-Vector.html#v:vector2RowVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor",
          "name": "Tensor",
          "package": "tensor",
          "source": "src/Data-Tensor.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "Tensor",
          "package": "tensor",
          "partial": "Tensor",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor",
          "name": "DirectSum",
          "package": "tensor",
          "source": "src/Data-Tensor.html#DirectSum",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "DirectSum",
          "package": "tensor",
          "partial": "Direct Sum",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#t:DirectSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor",
          "name": "FromList",
          "package": "tensor",
          "source": "src/Data-Tensor.html#FromList",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "FromList",
          "package": "tensor",
          "partial": "From List",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#t:FromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSlices the \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTensor\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e \u003ccode\u003et\u003c/code\u003e by dropping \u003ccode\u003ei\u003c/code\u003e at the beginning of its \u003ccode\u003e\u003ccode\u003e\u003ca\u003eIndex\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n and \u003ccode\u003ej\u003c/code\u003e at the end. The result has type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eSlice\u003c/a\u003e\u003c/code\u003e i j t\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tensor",
          "name": "Sliceable",
          "package": "tensor",
          "source": "src/Data-Tensor.html#Sliceable",
          "type": "class"
        },
        "index": {
          "description": "Slices the Tensor by dropping at the beginning of its Index and at the end The result has type Slice",
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "Sliceable",
          "package": "tensor",
          "partial": "Sliceable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#t:Sliceable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTensor\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is a map from an \u003ccode\u003e\u003ccode\u003e\u003ca\u003eIndex\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e type (which should be a\n \u003ccode\u003e\u003ccode\u003eMultiIndex\u003c/code\u003e\u003c/code\u003e) to an \u003ccode\u003e\u003ccode\u003e\u003ca\u003eElem\u003c/a\u003e\u003c/code\u003e\u003c/code\u003eent type.\n\u003c/p\u003e",
          "module": "Data.Tensor",
          "name": "Tensor",
          "package": "tensor",
          "source": "src/Data-Tensor.html#Tensor",
          "type": "class"
        },
        "index": {
          "description": "Tensor is map from an Index type which should be MultiIndex to an Elem ent type",
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "Tensor",
          "package": "tensor",
          "partial": "Tensor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#t:Tensor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor",
          "name": "Transpose",
          "package": "tensor",
          "source": "src/Data-Tensor.html#Transpose",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "Transpose",
          "package": "tensor",
          "partial": "Transpose",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#t:Transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003edims\u003c/code\u003e\u003c/code\u003e returns the dimensions of the \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTensor\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e. In any\n instance of \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTensor\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e \u003ccode\u003e\u003ccode\u003edims\u003c/code\u003e\u003c/code\u003e should be independent of its\n argument and work on \u003ccode\u003e\u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n | Returns the \u003ccode\u003e\u003ccode\u003e\u003ca\u003eElem\u003c/a\u003e\u003c/code\u003e\u003c/code\u003eent of \u003ccode\u003et\u003c/code\u003e corresponding to \u003ccode\u003e\u003ccode\u003e\u003ca\u003eIndex\u003c/a\u003e\u003c/code\u003e t\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tensor",
          "name": "(!)",
          "package": "tensor",
          "signature": "t -\u003e Index t -\u003e Elem t",
          "source": "src/Data-Tensor.html#%21",
          "type": "method"
        },
        "index": {
          "description": "dims returns the dimensions of the Tensor In any instance of Tensor dims should be independent of its argument and work on undefined Returns the Elem ent of corresponding to Index",
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "(!) !",
          "normalized": "a-\u003eIndex a-\u003eElem a",
          "package": "tensor",
          "signature": "t-\u003eIndex t-\u003eElem t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#v:-33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor",
          "name": "directSum",
          "package": "tensor",
          "signature": "n -\u003e t1 -\u003e t2 -\u003e SumSpace n t1 t2",
          "source": "src/Data-Tensor.html#directSum",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "directSum",
          "normalized": "a-\u003eb-\u003eb-\u003eSumSpace a b b",
          "package": "tensor",
          "partial": "Sum",
          "signature": "n-\u003et-\u003et-\u003eSumSpace n t t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#v:directSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eelemMap\u003c/a\u003e\u003c/code\u003e f t\u003c/code\u003e applies \u003ccode\u003ef\u003c/code\u003e to every \u003ccode\u003e\u003ccode\u003e\u003ca\u003eElem\u003c/a\u003e\u003c/code\u003e\u003c/code\u003eent of \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tensor",
          "name": "elemMap",
          "package": "tensor",
          "signature": "(Elem t1 -\u003e Elem t2) -\u003e t1 -\u003e t2",
          "source": "src/Data-Tensor.html#elemMap",
          "type": "function"
        },
        "index": {
          "description": "elemMap applies to every Elem ent of",
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "elemMap",
          "normalized": "(Elem a-\u003eElem a)-\u003ea-\u003ea",
          "package": "tensor",
          "partial": "Map",
          "signature": "(Elem t-\u003eElem t)-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#v:elemMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor",
          "name": "fromList",
          "package": "tensor",
          "signature": "[e] -\u003e t e",
          "source": "src/Data-Tensor.html#fromList",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "fromList",
          "normalized": "[a]-\u003eb a",
          "package": "tensor",
          "partial": "List",
          "signature": "[e]-\u003et e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTensor\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e according to the given function.\n\u003c/p\u003e",
          "module": "Data.Tensor",
          "name": "generate",
          "package": "tensor",
          "signature": "(Index t -\u003e Elem t) -\u003e t",
          "source": "src/Data-Tensor.html#generate",
          "type": "method"
        },
        "index": {
          "description": "Generates Tensor according to the given function",
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "generate",
          "normalized": "(Index a-\u003eElem a)-\u003ea",
          "package": "tensor",
          "signature": "(Index t-\u003eElem t)-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#v:generate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor",
          "name": "generateM",
          "package": "tensor",
          "signature": "(Index t -\u003e m (Elem t)) -\u003e m t",
          "source": "src/Data-Tensor.html#generateM",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "generateM",
          "normalized": "(Index a-\u003eb(Elem a))-\u003eb a",
          "package": "tensor",
          "signature": "(Index t-\u003em(Elem t))-\u003em t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#v:generateM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn \u003ccode\u003e\u003ccode\u003e\u003ca\u003eindexMap\u003c/a\u003e\u003c/code\u003e f t\u003c/code\u003e, the \u003ccode\u003e\u003ccode\u003e\u003ca\u003eElem\u003c/a\u003e\u003c/code\u003e\u003c/code\u003eent corresponding to the\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eIndex\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e \u003ccode\u003ei\u003c/code\u003e is the \u003ccode\u003e\u003ccode\u003e\u003ca\u003eElem\u003c/a\u003e\u003c/code\u003e\u003c/code\u003eent that \u003ccode\u003et\u003c/code\u003e assignes to the \u003ccode\u003e\u003ccode\u003e\u003ca\u003eIndex\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n \u003ccode\u003ef i\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tensor",
          "name": "indexMap",
          "package": "tensor",
          "signature": "(Index t1 -\u003e Index t2) -\u003e t2 -\u003e t1",
          "source": "src/Data-Tensor.html#indexMap",
          "type": "function"
        },
        "index": {
          "description": "In indexMap the Elem ent corresponding to the Index is the Elem ent that assignes to the Index",
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "indexMap",
          "normalized": "(Index a-\u003eIndex a)-\u003ea-\u003ea",
          "package": "tensor",
          "partial": "Map",
          "signature": "(Index t-\u003eIndex t)-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#v:indexMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTensor\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e consisting of the same \u003ccode\u003e\u003ccode\u003e\u003ca\u003eElem\u003c/a\u003e\u003c/code\u003e\u003c/code\u003eent\n repeated.\n\u003c/p\u003e",
          "module": "Data.Tensor",
          "name": "replicate",
          "package": "tensor",
          "signature": "Elem t -\u003e t",
          "source": "src/Data-Tensor.html#replicate",
          "type": "function"
        },
        "index": {
          "description": "Generates Tensor consisting of the same Elem ent repeated",
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "replicate",
          "normalized": "Elem a-\u003ea",
          "package": "tensor",
          "signature": "Elem t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor",
          "name": "replicateM",
          "package": "tensor",
          "signature": "m (Elem t) -\u003e m t",
          "source": "src/Data-Tensor.html#replicateM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "replicateM",
          "normalized": "a(Elem b)-\u003ea b",
          "package": "tensor",
          "signature": "m(Elem t)-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#v:replicateM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtracts the \u003ccode\u003e\u003ccode\u003e\u003ca\u003eSlice\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e of \u003ccode\u003et\u003c/code\u003e for the given initial and final\n indices \u003ccode\u003ei\u003c/code\u003e and \u003ccode\u003ej\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tensor",
          "name": "slice",
          "package": "tensor",
          "signature": "i -\u003e j -\u003e t -\u003e Slice i j t",
          "source": "src/Data-Tensor.html#slice",
          "type": "method"
        },
        "index": {
          "description": "Extracts the Slice of for the given initial and final indices and",
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "slice",
          "normalized": "a-\u003eb-\u003ec-\u003eSlice a b c",
          "package": "tensor",
          "signature": "i-\u003ej-\u003et-\u003eSlice i j t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#v:slice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor",
          "name": "split",
          "package": "tensor",
          "signature": "n -\u003e SumSpace n t1 t2 -\u003e (t1, t2)",
          "source": "src/Data-Tensor.html#split",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "split",
          "normalized": "a-\u003eSumSpace a b b-\u003e(b,b)",
          "package": "tensor",
          "signature": "n-\u003eSumSpace n t t-\u003e(t,t)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tensor",
          "name": "transpose",
          "package": "tensor",
          "signature": "t -\u003e TransposeSpace t",
          "source": "src/Data-Tensor.html#transpose",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Tensor",
          "module": "Data.Tensor",
          "name": "transpose",
          "normalized": "a-\u003eTransposeSpace a",
          "package": "tensor",
          "signature": "t-\u003eTransposeSpace t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-Tensor.html#v:transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeAlgebra",
          "name": "TypeAlgebra",
          "package": "tensor",
          "source": "src/Data-TypeAlgebra.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data TypeAlgebra",
          "module": "Data.TypeAlgebra",
          "name": "TypeAlgebra",
          "package": "tensor",
          "partial": "Type Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeAlgebra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProduct of types.\n\u003c/p\u003e",
          "module": "Data.TypeAlgebra",
          "name": "Prod",
          "package": "tensor",
          "source": "src/Data-TypeAlgebra.html#Prod",
          "type": "class"
        },
        "index": {
          "description": "Product of types",
          "hierarchy": "Data TypeAlgebra",
          "module": "Data.TypeAlgebra",
          "name": "Prod",
          "package": "tensor",
          "partial": "Prod",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeAlgebra.html#t:Prod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum of types.\n\u003c/p\u003e",
          "module": "Data.TypeAlgebra",
          "name": "Sum",
          "package": "tensor",
          "source": "src/Data-TypeAlgebra.html#Sum",
          "type": "class"
        },
        "index": {
          "description": "Sum of types",
          "hierarchy": "Data TypeAlgebra",
          "module": "Data.TypeAlgebra",
          "name": "Sum",
          "package": "tensor",
          "partial": "Sum",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeAlgebra.html#t:Sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe product of an element of \u003ccode\u003ea\u003c/code\u003e and an element of \u003ccode\u003eb\u003c/code\u003e is an\n element in the type \u003ccode\u003ea \u003ccode\u003e\u003ca\u003e:*:\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.TypeAlgebra",
          "name": "(\u003c*\u003e)",
          "package": "tensor",
          "signature": "a -\u003e b -\u003e a :*: b",
          "source": "src/Data-TypeAlgebra.html#%3C%2A%3E",
          "type": "method"
        },
        "index": {
          "description": "The product of an element of and an element of is an element in the type",
          "hierarchy": "Data TypeAlgebra",
          "module": "Data.TypeAlgebra",
          "name": "(\u003c*\u003e) \u003c*\u003e",
          "normalized": "a-\u003eb-\u003ea*b",
          "package": "tensor",
          "signature": "a-\u003eb-\u003ea*b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeAlgebra.html#v:-60--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe sum of an element of \u003ccode\u003ea\u003c/code\u003e and an element of \u003ccode\u003eb\u003c/code\u003e is an\n element in the type \u003ccode\u003ea \u003ccode\u003e\u003ca\u003e:+:\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.TypeAlgebra",
          "name": "(\u003c+\u003e)",
          "package": "tensor",
          "signature": "a -\u003e b -\u003e a :+: b",
          "source": "src/Data-TypeAlgebra.html#%3C%2B%3E",
          "type": "method"
        },
        "index": {
          "description": "The sum of an element of and an element of is an element in the type",
          "hierarchy": "Data TypeAlgebra",
          "module": "Data.TypeAlgebra",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "a-\u003eb-\u003ea b",
          "package": "tensor",
          "signature": "a-\u003eb-\u003ea b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeAlgebra.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eWe define the a multidimensional array of indices called \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMultiIndex\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e. The\n canonical implementation of a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMultiIndex\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is an heterogeneous list of\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eOrdinal\u003c/a\u003e\u003c/code\u003e\u003c/code\u003es.  Below we illustrate some example of \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMultiIndex\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e types and\n the elements they contain.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eThree\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e:|:\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNil\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e = {(1),(2),(3)}\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eThree\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e:|:\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eTwo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e:|:\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNil\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e =\n {(1,1),(1,2),(2,1),(2,2),(3,1),(3,2)}\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eThree\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e:|:\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eTwo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e:|:\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eTwo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e:|:\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNil\u003c/a\u003e\u003c/code\u003e))\u003c/code\u003e =\n {(1,1,1),(1,1,2),(1,2,1),(1,2,2),(2,1,1),(2,1,2),(2,2,1),(2,2,2),(3,1,1),(3,1,2),(3,2,1),(3,2,2)}\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.TypeList.MultiIndex",
          "name": "MultiIndex",
          "package": "tensor",
          "source": "src/Data-TypeList-MultiIndex.html",
          "type": "module"
        },
        "index": {
          "description": "We define the multidimensional array of indices called MultiIndex The canonical implementation of MultiIndex is an heterogeneous list of Ordinal Below we illustrate some example of MultiIndex types and the elements they contain Three Nil Three Two Nil Three Two Two Nil",
          "hierarchy": "Data TypeList MultiIndex",
          "module": "Data.TypeList.MultiIndex",
          "name": "MultiIndex",
          "package": "tensor",
          "partial": "Multi Index",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList-MultiIndex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the constructor for heterogeneous lists, equivalent to\n \u003ccode\u003e\u003ccode\u003e:\u003c/code\u003e\u003c/code\u003e for standard lists. \u003ccode\u003e\u003ccode\u003e\u003ca\u003eNil\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is used to end the lists, just\n like \u003ccode\u003e'[]'\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.TypeList.MultiIndex",
          "name": ":|:",
          "package": "tensor",
          "source": "src/Data-TypeList-MultiIndex.html#%3A%7C%3A",
          "type": "data"
        },
        "index": {
          "description": "This is the constructor for heterogeneous lists equivalent to for standard lists Nil is used to end the lists just like",
          "hierarchy": "Data TypeList MultiIndex",
          "module": "Data.TypeList.MultiIndex",
          "name": ":|:",
          "package": "tensor",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList-MultiIndex.html#t::-124-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass for types having multiple dimensions, like \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMultiIndex\u003c/a\u003e\u003c/code\u003e\u003c/code\u003ees\n or \u003ccode\u003e\u003ccode\u003eTensor\u003c/code\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Data.TypeList.MultiIndex",
          "name": "Dimensions",
          "package": "tensor",
          "source": "src/Data-TypeList-MultiIndex.html#Dimensions",
          "type": "class"
        },
        "index": {
          "description": "Class for types having multiple dimensions like MultiIndex es or Tensor",
          "hierarchy": "Data TypeList MultiIndex",
          "module": "Data.TypeList.MultiIndex",
          "name": "Dimensions",
          "package": "tensor",
          "partial": "Dimensions",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList-MultiIndex.html#t:Dimensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList.MultiIndex",
          "name": "MultiIndex",
          "package": "tensor",
          "source": "src/Data-TypeList-MultiIndex.html#MultiIndex",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data TypeList MultiIndex",
          "module": "Data.TypeList.MultiIndex",
          "name": "MultiIndex",
          "package": "tensor",
          "partial": "Multi Index",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList-MultiIndex.html#t:MultiIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList.MultiIndex",
          "name": "MultiIndexConcat",
          "package": "tensor",
          "source": "src/Data-TypeList-MultiIndex.html#MultiIndexConcat",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data TypeList MultiIndex",
          "module": "Data.TypeList.MultiIndex",
          "name": "MultiIndexConcat",
          "package": "tensor",
          "partial": "Multi Index Concat",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList-MultiIndex.html#t:MultiIndexConcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList.MultiIndex",
          "name": "Nil",
          "package": "tensor",
          "source": "src/Data-TypeList-MultiIndex.html#Nil",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data TypeList MultiIndex",
          "module": "Data.TypeList.MultiIndex",
          "name": "Nil",
          "package": "tensor",
          "partial": "Nil",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList-MultiIndex.html#t:Nil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList.MultiIndex",
          "name": ":|:",
          "package": "tensor",
          "signature": "a :|: b",
          "source": "src/Data-TypeList-MultiIndex.html#%3A%7C%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data TypeList MultiIndex",
          "module": "Data.TypeList.MultiIndex",
          "name": ":|:",
          "package": "tensor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList-MultiIndex.html#v::-124-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList.MultiIndex",
          "name": "Nil",
          "package": "tensor",
          "signature": "Nil",
          "source": "src/Data-TypeList-MultiIndex.html#Nil",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data TypeList MultiIndex",
          "module": "Data.TypeList.MultiIndex",
          "name": "Nil",
          "package": "tensor",
          "partial": "Nil",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList-MultiIndex.html#v:Nil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the dimensions list. It should always be independent\n on its argument and work on \u003ccode\u003e\u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.TypeList.MultiIndex",
          "name": "dimensions",
          "package": "tensor",
          "signature": "i -\u003e [n]",
          "source": "src/Data-TypeList-MultiIndex.html#dimensions",
          "type": "method"
        },
        "index": {
          "description": "Returns the dimensions list It should always be independent on its argument and work on undefined",
          "hierarchy": "Data TypeList MultiIndex",
          "module": "Data.TypeList.MultiIndex",
          "name": "dimensions",
          "normalized": "a-\u003e[b]",
          "package": "tensor",
          "signature": "i-\u003e[n]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList-MultiIndex.html#v:dimensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList.MultiIndex",
          "name": "fromMultiIndex",
          "package": "tensor",
          "signature": "i -\u003e [n]",
          "source": "src/Data-TypeList-MultiIndex.html#fromMultiIndex",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data TypeList MultiIndex",
          "module": "Data.TypeList.MultiIndex",
          "name": "fromMultiIndex",
          "normalized": "a-\u003e[b]",
          "package": "tensor",
          "partial": "Multi Index",
          "signature": "i-\u003e[n]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList-MultiIndex.html#v:fromMultiIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList.MultiIndex",
          "name": "multiIndex2Linear",
          "package": "tensor",
          "signature": "i -\u003e n",
          "source": "src/Data-TypeList-MultiIndex.html#multiIndex2Linear",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data TypeList MultiIndex",
          "module": "Data.TypeList.MultiIndex",
          "name": "multiIndex2Linear",
          "normalized": "a-\u003eb",
          "package": "tensor",
          "partial": "Index Linear",
          "signature": "i-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList-MultiIndex.html#v:multiIndex2Linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList.MultiIndex",
          "name": "toMultiIndex",
          "package": "tensor",
          "signature": "[n] -\u003e i",
          "source": "src/Data-TypeList-MultiIndex.html#toMultiIndex",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data TypeList MultiIndex",
          "module": "Data.TypeList.MultiIndex",
          "name": "toMultiIndex",
          "normalized": "[a]-\u003eb",
          "package": "tensor",
          "partial": "Multi Index",
          "signature": "[n]-\u003ei",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList-MultiIndex.html#v:toMultiIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe Module \u003ccode\u003e\u003ca\u003eData.TypeList\u003c/a\u003e\u003c/code\u003e is a collection of classes to manipulate lists\n of types, a.k.a. heterogeneous lists.  Check the module\n \u003ccode\u003e\u003ca\u003eData.TypeList.MultiIndex\u003c/a\u003e\u003c/code\u003e for a concrete implementation of \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTypeList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.TypeList",
          "name": "TypeList",
          "package": "tensor",
          "source": "src/Data-TypeList.html",
          "type": "module"
        },
        "index": {
          "description": "The Module Data.TypeList is collection of classes to manipulate lists of types a.k.a heterogeneous lists Check the module Data.TypeList.MultiIndex for concrete implementation of TypeList",
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "TypeList",
          "package": "tensor",
          "partial": "Type List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class for appending two \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTypeList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003es. The result of appending\n \u003ccode\u003el\u003c/code\u003e and \u003ccode\u003el'\u003c/code\u003e has type \u003ccode\u003el \u003ccode\u003e\u003ca\u003e:++:\u003c/a\u003e\u003c/code\u003e l'\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.TypeList",
          "name": "AppendList",
          "package": "tensor",
          "source": "src/Data-TypeList.html#AppendList",
          "type": "class"
        },
        "index": {
          "description": "class for appending two TypeList The result of appending and has type",
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "AppendList",
          "package": "tensor",
          "partial": "Append List",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#t:AppendList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtracts the \u003ccode\u003en\u003c/code\u003e-th component of the list \u003ccode\u003el\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.TypeList",
          "name": "Component",
          "package": "tensor",
          "source": "src/Data-TypeList.html#Component",
          "type": "class"
        },
        "index": {
          "description": "Extracts the th component of the list",
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "Component",
          "package": "tensor",
          "partial": "Component",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#t:Component"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is does for \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTakeList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e what \u003ccode\u003e\u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e does for\n ordinary lists.\n\u003c/p\u003e",
          "module": "Data.TypeList",
          "name": "DropList",
          "package": "tensor",
          "source": "src/Data-TypeList.html#DropList",
          "type": "class"
        },
        "index": {
          "description": "This is does for TakeList what drop does for ordinary lists",
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "DropList",
          "package": "tensor",
          "partial": "Drop List",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#t:DropList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtend the list \u003ccode\u003el\u003c/code\u003e to \u003ccode\u003el'\u003c/code\u003e by adding the necessary extension\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eExt\u003c/a\u003e\u003c/code\u003e l l'\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.TypeList",
          "name": "Extend",
          "package": "tensor",
          "source": "src/Data-TypeList.html#Extend",
          "type": "class"
        },
        "index": {
          "description": "Extend the list to by adding the necessary extension Ext",
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "Extend",
          "package": "tensor",
          "partial": "Extend",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#t:Extend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList",
          "name": "HeadTail",
          "package": "tensor",
          "source": "src/Data-TypeList.html#HeadTail",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "HeadTail",
          "package": "tensor",
          "partial": "Head Tail",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#t:HeadTail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJoin together \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTypeList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003es \u003ccode\u003el\u003c/code\u003e and \u003ccode\u003el'\u003c/code\u003e where the last \u003ccode\u003en\u003c/code\u003e types\n of \u003ccode\u003el\u003c/code\u003e coincide with the first \u003ccode\u003en\u003c/code\u003e types of \u003ccode\u003el'\u003c/code\u003e. The result has a\n the common \u003ccode\u003en\u003c/code\u003e types eliminated.\n\u003c/p\u003e",
          "module": "Data.TypeList",
          "name": "JoinList",
          "package": "tensor",
          "source": "src/Data-TypeList.html#JoinList",
          "type": "class"
        },
        "index": {
          "description": "Join together TypeList and where the last types of coincide with the first types of The result has the common types eliminated",
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "JoinList",
          "package": "tensor",
          "partial": "Join List",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#t:JoinList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse the \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTypeList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e \u003ccode\u003el\u003c/code\u003e, and get \u003ccode\u003e\u003ccode\u003e\u003ca\u003eReverse\u003c/a\u003e\u003c/code\u003e l\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.TypeList",
          "name": "ReverseList",
          "package": "tensor",
          "source": "src/Data-TypeList.html#ReverseList",
          "type": "class"
        },
        "index": {
          "description": "Reverse the TypeList and get Reverse",
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "ReverseList",
          "package": "tensor",
          "partial": "Reverse List",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#t:ReverseList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse \u003ccode\u003el\u003c/code\u003e and append it in front of \u003ccode\u003el'\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.TypeList",
          "name": "TailRevList",
          "package": "tensor",
          "source": "src/Data-TypeList.html#TailRevList",
          "type": "class"
        },
        "index": {
          "description": "Reverse and append it in front of",
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "TailRevList",
          "package": "tensor",
          "partial": "Tail Rev List",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#t:TailRevList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is does for \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTakeList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e what \u003ccode\u003e\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e does for\n ordinary lists.\n\u003c/p\u003e",
          "module": "Data.TypeList",
          "name": "TakeList",
          "package": "tensor",
          "source": "src/Data-TypeList.html#TakeList",
          "type": "class"
        },
        "index": {
          "description": "This is does for TakeList what take does for ordinary lists",
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "TakeList",
          "package": "tensor",
          "partial": "Take List",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#t:TakeList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTypeList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e has a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eLength\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e. The \u003ccode\u003e\u003ccode\u003e\u003ca\u003eLength\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is actually a\n type, and should be a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eCardinal\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e (see \u003ccode\u003e\u003ca\u003eData.Cardinal\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Data.TypeList",
          "name": "TypeList",
          "package": "tensor",
          "source": "src/Data-TypeList.html#TypeList",
          "type": "class"
        },
        "index": {
          "description": "Every TypeList has Length The Length is actually type and should be Cardinal see Data.Cardinal",
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "TypeList",
          "package": "tensor",
          "partial": "Type List",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#t:TypeList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe second argument of \u003ccode\u003e\u003ccode\u003e\u003ca\u003e!!\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e should always be \u003ccode\u003e\u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e\n :: n\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.TypeList",
          "name": "(!!)",
          "package": "tensor",
          "signature": "l -\u003e n -\u003e l :!!: n",
          "source": "src/Data-TypeList.html#%21%21",
          "type": "method"
        },
        "index": {
          "description": "The second argument of should always be undefined",
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "(!!) !!",
          "normalized": "a-\u003eb-\u003ea b",
          "package": "tensor",
          "signature": "l-\u003en-\u003el n",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#v:-33--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList",
          "name": "(\u003c++\u003e)",
          "package": "tensor",
          "signature": "l -\u003e l' -\u003e l :++: l'",
          "source": "src/Data-TypeList.html#%3C%2B%2B%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "(\u003c++\u003e) \u003c++\u003e",
          "normalized": "a-\u003eb-\u003ea b",
          "package": "tensor",
          "signature": "l-\u003el'-\u003el l'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#v:-60--43--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList",
          "name": "(.|.)",
          "package": "tensor",
          "signature": "Head l -\u003e Tail l -\u003e l",
          "source": "src/Data-TypeList.html#.%7C.",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "(.|.) .|.",
          "normalized": "Head a-\u003eTail a-\u003ea",
          "package": "tensor",
          "signature": "Head l-\u003eTail l-\u003el",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#v:.-124-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList",
          "name": "drop",
          "package": "tensor",
          "signature": "n -\u003e l -\u003e Drop n l",
          "source": "src/Data-TypeList.html#drop",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "drop",
          "normalized": "a-\u003eb-\u003eDrop a b",
          "package": "tensor",
          "signature": "n-\u003el-\u003eDrop n l",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList",
          "name": "extend",
          "package": "tensor",
          "signature": "l -\u003e Ext l l' -\u003e l'",
          "source": "src/Data-TypeList.html#extend",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "extend",
          "normalized": "a-\u003eExt a b-\u003eb",
          "package": "tensor",
          "signature": "l-\u003eExt l l'-\u003el'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#v:extend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList",
          "name": "head",
          "package": "tensor",
          "signature": "l -\u003e Head l",
          "source": "src/Data-TypeList.html#head",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "head",
          "normalized": "a-\u003eHead a",
          "package": "tensor",
          "signature": "l-\u003eHead l",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#v:head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList",
          "name": "join",
          "package": "tensor",
          "signature": "n -\u003e l -\u003e l' -\u003e Join n l l'",
          "source": "src/Data-TypeList.html#join",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "join",
          "normalized": "a-\u003eb-\u003ec-\u003eJoin a b c",
          "package": "tensor",
          "signature": "n-\u003el-\u003el'-\u003eJoin n l l'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#v:join"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList",
          "name": "length",
          "package": "tensor",
          "signature": "l -\u003e Length l",
          "source": "src/Data-TypeList.html#length",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "length",
          "normalized": "a-\u003eLength a",
          "package": "tensor",
          "signature": "l-\u003eLength l",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplies the given function to one component of the list.\n\u003c/p\u003e",
          "module": "Data.TypeList",
          "name": "partialMap",
          "package": "tensor",
          "signature": "n -\u003e ((l :!!: n) -\u003e l :!!: n) -\u003e l -\u003e l",
          "source": "src/Data-TypeList.html#partialMap",
          "type": "method"
        },
        "index": {
          "description": "Applies the given function to one component of the list",
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "partialMap",
          "normalized": "a-\u003e((b a)-\u003eb a)-\u003eb-\u003eb",
          "package": "tensor",
          "partial": "Map",
          "signature": "n-\u003e((l n)-\u003el n)-\u003el-\u003el",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#v:partialMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList",
          "name": "rev",
          "package": "tensor",
          "signature": "l -\u003e l' -\u003e TailRev l l'",
          "source": "src/Data-TypeList.html#rev",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "rev",
          "normalized": "a-\u003eb-\u003eTailRev a b",
          "package": "tensor",
          "signature": "l-\u003el'-\u003eTailRev l l'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#v:rev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList",
          "name": "reverse",
          "package": "tensor",
          "signature": "l -\u003e Reverse l",
          "source": "src/Data-TypeList.html#reverse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "reverse",
          "normalized": "a-\u003eReverse a",
          "package": "tensor",
          "signature": "l-\u003eReverse l",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList",
          "name": "tail",
          "package": "tensor",
          "signature": "l -\u003e Tail l",
          "source": "src/Data-TypeList.html#tail",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "tail",
          "normalized": "a-\u003eTail a",
          "package": "tensor",
          "signature": "l-\u003eTail l",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#v:tail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.TypeList",
          "name": "take",
          "package": "tensor",
          "signature": "n -\u003e l -\u003e Take n l",
          "source": "src/Data-TypeList.html#take",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data TypeList",
          "module": "Data.TypeList",
          "name": "take",
          "normalized": "a-\u003eb-\u003eTake a b",
          "package": "tensor",
          "signature": "n-\u003el-\u003eTake n l",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tensor/docs/Data-TypeList.html#v:take"
      }
    }
  ]
]