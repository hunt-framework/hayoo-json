[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "Control-Monad-MultiPass"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "Assembler",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-Assembler.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Assembler",
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "Assembler",
          "package": "Control-Monad-MultiPass",
          "partial": "Assembler",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Assembler.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "Instruction",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-Assembler.html#Instruction",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Assembler",
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "Instruction",
          "package": "Control-Monad-MultiPass",
          "partial": "Instruction",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Assembler.html#t:Instruction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "LabelName",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-Assembler.html#LabelName",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Assembler",
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "LabelName",
          "package": "Control-Monad-MultiPass",
          "partial": "Label Name",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Assembler.html#t:LabelName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "Register",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-Assembler.html#Register",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Assembler",
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "Register",
          "package": "Control-Monad-MultiPass",
          "partial": "Register",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Assembler.html#t:Register"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "AddImm8",
          "package": "Control-Monad-MultiPass",
          "signature": "AddImm8 Register Word8",
          "source": "src/Control-Monad-MultiPass-Example-Assembler.html#Instruction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Assembler",
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "AddImm8",
          "package": "Control-Monad-MultiPass",
          "partial": "Add Imm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Assembler.html#v:AddImm8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "Goto",
          "package": "Control-Monad-MultiPass",
          "signature": "Goto LabelName",
          "source": "src/Control-Monad-MultiPass-Example-Assembler.html#Instruction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Assembler",
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "Goto",
          "package": "Control-Monad-MultiPass",
          "partial": "Goto",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Assembler.html#v:Goto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "Label",
          "package": "Control-Monad-MultiPass",
          "signature": "Label LabelName",
          "source": "src/Control-Monad-MultiPass-Example-Assembler.html#Instruction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Assembler",
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "Label",
          "package": "Control-Monad-MultiPass",
          "partial": "Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Assembler.html#v:Label"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "LabelName",
          "package": "Control-Monad-MultiPass",
          "signature": "LabelName String",
          "source": "src/Control-Monad-MultiPass-Example-Assembler.html#LabelName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Assembler",
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "LabelName",
          "package": "Control-Monad-MultiPass",
          "partial": "Label Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Assembler.html#v:LabelName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "Register",
          "package": "Control-Monad-MultiPass",
          "signature": "Register Int",
          "source": "src/Control-Monad-MultiPass-Example-Assembler.html#Register",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Assembler",
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "Register",
          "package": "Control-Monad-MultiPass",
          "partial": "Register",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Assembler.html#v:Register"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "assemble",
          "package": "Control-Monad-MultiPass",
          "signature": "NumThreads -\u003e ST2Array r w Int Instruction -\u003e ST2 r w (ST2Array r w Addr Word8)",
          "source": "src/Control-Monad-MultiPass-Example-Assembler.html#assemble",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Assembler",
          "module": "Control.Monad.MultiPass.Example.Assembler",
          "name": "assemble",
          "normalized": "NumThreads-\u003eST Array a b Int Instruction-\u003eST a b(ST Array a b Addr Word)",
          "package": "Control-Monad-MultiPass",
          "signature": "NumThreads-\u003eST Array r w Int Instruction-\u003eST r w(ST Array r w Addr Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Assembler.html#v:assemble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis example is a variation on the\n\u003ccode\u003e\u003ca\u003eassembler\u003c/a\u003e\u003c/code\u003e example.  It\nillustrates how one might convert a control flow graph into a linear\nsequence of instructions. The example is less complete than the\n\u003ccode\u003e\u003ca\u003eassembler\u003c/a\u003e\u003c/code\u003e example, so the\noutput is not real machine code. Instead the output is a simple\nserialised representation of the control flow graph.\n\u003c/p\u003e\u003cp\u003eIn this example, the control flow graph is represented as a\n\u003ccode\u003e\u003ca\u003eArray\u003c/a\u003e\u003c/code\u003e, which is an immutable datatype. The example can\nalso be implemented with a mutable representation of the control flow\ngraph, as shown in \u003ca\u003eControl.Monad.MultiPass.Example.CFG2\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Example.CFG",
          "name": "CFG",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-CFG.html",
          "type": "module"
        },
        "index": {
          "description": "This example is variation on the assembler example It illustrates how one might convert control flow graph into linear sequence of instructions The example is less complete than the assembler example so the output is not real machine code Instead the output is simple serialised representation of the control flow graph In this example the control flow graph is represented as Array which is an immutable datatype The example can also be implemented with mutable representation of the control flow graph as shown in Control.Monad.MultiPass.Example.CFG2",
          "hierarchy": "Control Monad MultiPass Example CFG",
          "module": "Control.Monad.MultiPass.Example.CFG",
          "name": "CFG",
          "package": "Control-Monad-MultiPass",
          "partial": "CFG",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-CFG.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.CFG",
          "name": "Node",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-CFG.html#Node",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example CFG",
          "module": "Control.Monad.MultiPass.Example.CFG",
          "name": "Node",
          "package": "Control-Monad-MultiPass",
          "partial": "Node",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-CFG.html#t:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.CFG",
          "name": "Node",
          "package": "Control-Monad-MultiPass",
          "signature": "Node Int",
          "source": "src/Control-Monad-MultiPass-Example-CFG.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example CFG",
          "module": "Control.Monad.MultiPass.Example.CFG",
          "name": "Node",
          "package": "Control-Monad-MultiPass",
          "partial": "Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-CFG.html#v:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.CFG",
          "name": "emitCFG",
          "package": "Control-Monad-MultiPass",
          "signature": "CFG -\u003e ST2 r w (ST2Array r w Position Int)",
          "source": "src/Control-Monad-MultiPass-Example-CFG.html#emitCFG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example CFG",
          "module": "Control.Monad.MultiPass.Example.CFG",
          "name": "emitCFG",
          "normalized": "CFG-\u003eST a b(ST Array a b Position Int)",
          "package": "Control-Monad-MultiPass",
          "partial": "CFG",
          "signature": "CFG-\u003eST r w(ST Array r w Position Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-CFG.html#v:emitCFG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis example is a modified version of the\n\u003ca\u003eControl.Monad.MultiPass.Example.CFG\u003c/a\u003e example, which uses a mutable\n\u003ccode\u003e\u003ca\u003eST2Array\u003c/a\u003e\u003c/code\u003e to represent the control flow graph rather than an\nimmutable \u003ccode\u003e\u003ca\u003eArray\u003c/a\u003e\u003c/code\u003e. This means that it is not possible to\nuse \u003ccode\u003e\u003ca\u003epmapM\u003c/a\u003e\u003c/code\u003e to map over the array.\nInstead \u003ccode\u003e\u003ca\u003epmapST2ArrayMP\u003c/a\u003e\u003c/code\u003e is used\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Example.CFG2",
          "name": "CFG2",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-CFG2.html",
          "type": "module"
        },
        "index": {
          "description": "This example is modified version of the Control.Monad.MultiPass.Example.CFG example which uses mutable ST2Array to represent the control flow graph rather than an immutable Array This means that it is not possible to use pmapM to map over the array Instead pmapST2ArrayMP is used",
          "hierarchy": "Control Monad MultiPass Example CFG2",
          "module": "Control.Monad.MultiPass.Example.CFG2",
          "name": "CFG2",
          "package": "Control-Monad-MultiPass",
          "partial": "CFG",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-CFG2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.CFG2",
          "name": "Node",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-CFG2.html#Node",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example CFG2",
          "module": "Control.Monad.MultiPass.Example.CFG2",
          "name": "Node",
          "package": "Control-Monad-MultiPass",
          "partial": "Node",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-CFG2.html#t:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.CFG2",
          "name": "Node",
          "package": "Control-Monad-MultiPass",
          "signature": "Node Int",
          "source": "src/Control-Monad-MultiPass-Example-CFG2.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example CFG2",
          "module": "Control.Monad.MultiPass.Example.CFG2",
          "name": "Node",
          "package": "Control-Monad-MultiPass",
          "partial": "Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-CFG2.html#v:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.CFG2",
          "name": "emitCFG",
          "package": "Control-Monad-MultiPass",
          "signature": "NumThreads -\u003e CFG r w -\u003e ST2 r w (ST2Array r w Position Int)",
          "source": "src/Control-Monad-MultiPass-Example-CFG2.html#emitCFG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example CFG2",
          "module": "Control.Monad.MultiPass.Example.CFG2",
          "name": "emitCFG",
          "normalized": "NumThreads-\u003eCFG a b-\u003eST a b(ST Array a b Position Int)",
          "package": "Control-Monad-MultiPass",
          "partial": "CFG",
          "signature": "NumThreads-\u003eCFG r w-\u003eST r w(ST Array r w Position Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-CFG2.html#v:emitCFG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn example of the use of the\n\u003ccode\u003e\u003ca\u003eCounter\u003c/a\u003e\u003c/code\u003e instrument.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Example.Counter",
          "name": "Counter",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-Counter.html",
          "type": "module"
        },
        "index": {
          "description": "An example of the use of the Counter instrument",
          "hierarchy": "Control Monad MultiPass Example Counter",
          "module": "Control.Monad.MultiPass.Example.Counter",
          "name": "Counter",
          "package": "Control-Monad-MultiPass",
          "partial": "Counter",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Counter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Counter",
          "name": "Tree",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-Counter.html#Tree",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Counter",
          "module": "Control.Monad.MultiPass.Example.Counter",
          "name": "Tree",
          "package": "Control-Monad-MultiPass",
          "partial": "Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Counter.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Counter",
          "name": "Node",
          "package": "Control-Monad-MultiPass",
          "signature": "Node a (ST2Array r w i (Tree r w i a))",
          "source": "src/Control-Monad-MultiPass-Example-Counter.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Counter",
          "module": "Control.Monad.MultiPass.Example.Counter",
          "name": "Node",
          "package": "Control-Monad-MultiPass",
          "partial": "Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Counter.html#v:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Counter",
          "name": "convertTree",
          "package": "Control-Monad-MultiPass",
          "signature": "Tree r w i a -\u003e ST2 r w (Tree r w i (i, a))",
          "source": "src/Control-Monad-MultiPass-Example-Counter.html#convertTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Counter",
          "module": "Control.Monad.MultiPass.Example.Counter",
          "name": "convertTree",
          "normalized": "Tree a b c d-\u003eST a b(Tree a b c(c,d))",
          "package": "Control-Monad-MultiPass",
          "partial": "Tree",
          "signature": "Tree r w i a-\u003eST r w(Tree r w i(i,a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Counter.html#v:convertTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA variation on the \u003ccode\u003e\u003ca\u003erepmin\u003c/a\u003e\u003c/code\u003e\nexample. This example shows how the\n\u003ccode\u003e\u003ca\u003eKnot3\u003c/a\u003e\u003c/code\u003e can be used in a\nrecursive algorithm.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Example.Localmin",
          "name": "Localmin",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-Localmin.html",
          "type": "module"
        },
        "index": {
          "description": "variation on the repmin example This example shows how the Knot3 can be used in recursive algorithm",
          "hierarchy": "Control Monad MultiPass Example Localmin",
          "module": "Control.Monad.MultiPass.Example.Localmin",
          "name": "Localmin",
          "package": "Control-Monad-MultiPass",
          "partial": "Localmin",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Localmin.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Localmin",
          "name": "Tree",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-Localmin.html#Tree",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Localmin",
          "module": "Control.Monad.MultiPass.Example.Localmin",
          "name": "Tree",
          "package": "Control-Monad-MultiPass",
          "partial": "Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Localmin.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Localmin",
          "name": "Leaf",
          "package": "Control-Monad-MultiPass",
          "signature": "Leaf !a",
          "source": "src/Control-Monad-MultiPass-Example-Localmin.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Localmin",
          "module": "Control.Monad.MultiPass.Example.Localmin",
          "name": "Leaf",
          "package": "Control-Monad-MultiPass",
          "partial": "Leaf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Localmin.html#v:Leaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Localmin",
          "name": "Node",
          "package": "Control-Monad-MultiPass",
          "signature": "Node !(Tree a) !(Tree a)",
          "source": "src/Control-Monad-MultiPass-Example-Localmin.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Localmin",
          "module": "Control.Monad.MultiPass.Example.Localmin",
          "name": "Node",
          "package": "Control-Monad-MultiPass",
          "partial": "Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Localmin.html#v:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVersion using lazy evaluation.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Example.Localmin",
          "name": "localmin",
          "package": "Control-Monad-MultiPass",
          "signature": "Tree a -\u003e Tree [a]",
          "source": "src/Control-Monad-MultiPass-Example-Localmin.html#localmin",
          "type": "function"
        },
        "index": {
          "description": "Version using lazy evaluation",
          "hierarchy": "Control Monad MultiPass Example Localmin",
          "module": "Control.Monad.MultiPass.Example.Localmin",
          "name": "localmin",
          "normalized": "Tree a-\u003eTree[a]",
          "package": "Control-Monad-MultiPass",
          "signature": "Tree a-\u003eTree[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Localmin.html#v:localmin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVersion using the \u003ca\u003eControl.Monad.MultiPass\u003c/a\u003e library.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Example.Localmin",
          "name": "localminMP",
          "package": "Control-Monad-MultiPass",
          "signature": "Tree a -\u003e ST2 r w (Tree [a])",
          "source": "src/Control-Monad-MultiPass-Example-Localmin.html#localminMP",
          "type": "function"
        },
        "index": {
          "description": "Version using the Control.Monad.MultiPass library",
          "hierarchy": "Control Monad MultiPass Example Localmin",
          "module": "Control.Monad.MultiPass.Example.Localmin",
          "name": "localminMP",
          "normalized": "Tree a-\u003eST b c(Tree[a])",
          "package": "Control-Monad-MultiPass",
          "partial": "MP",
          "signature": "Tree a-\u003eST r w(Tree[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Localmin.html#v:localminMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn example of the use of the\n\u003ccode\u003e\u003ca\u003eOrdCons\u003c/a\u003e\u003c/code\u003e instrument.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Example.OrdCons",
          "name": "OrdCons",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-OrdCons.html",
          "type": "module"
        },
        "index": {
          "description": "An example of the use of the OrdCons instrument",
          "hierarchy": "Control Monad MultiPass Example OrdCons",
          "module": "Control.Monad.MultiPass.Example.OrdCons",
          "name": "OrdCons",
          "package": "Control-Monad-MultiPass",
          "partial": "Ord Cons",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-OrdCons.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.OrdCons",
          "name": "convertArray",
          "package": "Control-Monad-MultiPass",
          "signature": "NumThreads -\u003e ST2Array r w i a -\u003e ST2 r w (ST2Array r w i Int)",
          "source": "src/Control-Monad-MultiPass-Example-OrdCons.html#convertArray",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example OrdCons",
          "module": "Control.Monad.MultiPass.Example.OrdCons",
          "name": "convertArray",
          "normalized": "NumThreads-\u003eST Array a b c d-\u003eST a b(ST Array a b c Int)",
          "package": "Control-Monad-MultiPass",
          "partial": "Array",
          "signature": "NumThreads-\u003eST Array r w i a-\u003eST r w(ST Array r w i Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-OrdCons.html#v:convertArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn implementation of the classic \u003ccode\u003erepmin\u003c/code\u003e algorithm, using the\n\u003ca\u003eControl.Monad.MultiPass\u003c/a\u003e library.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "Repmin",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-Repmin.html",
          "type": "module"
        },
        "index": {
          "description": "An implementation of the classic repmin algorithm using the Control.Monad.MultiPass library",
          "hierarchy": "Control Monad MultiPass Example Repmin",
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "Repmin",
          "package": "Control-Monad-MultiPass",
          "partial": "Repmin",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Repmin.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary tree datatype.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "Tree",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-Repmin.html#Tree",
          "type": "data"
        },
        "index": {
          "description": "Binary tree datatype",
          "hierarchy": "Control Monad MultiPass Example Repmin",
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "Tree",
          "package": "Control-Monad-MultiPass",
          "partial": "Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Repmin.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "Leaf",
          "package": "Control-Monad-MultiPass",
          "signature": "Leaf !a",
          "source": "src/Control-Monad-MultiPass-Example-Repmin.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Repmin",
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "Leaf",
          "package": "Control-Monad-MultiPass",
          "partial": "Leaf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Repmin.html#v:Leaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "Node",
          "package": "Control-Monad-MultiPass",
          "signature": "Node !(Tree a) !(Tree a)",
          "source": "src/Control-Monad-MultiPass-Example-Repmin.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example Repmin",
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "Node",
          "package": "Control-Monad-MultiPass",
          "partial": "Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Repmin.html#v:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOriginal algorithm, which uses lazy evaluation.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "repmin",
          "package": "Control-Monad-MultiPass",
          "signature": "Tree a -\u003e Tree a",
          "source": "src/Control-Monad-MultiPass-Example-Repmin.html#repmin",
          "type": "function"
        },
        "index": {
          "description": "Original algorithm which uses lazy evaluation",
          "hierarchy": "Control Monad MultiPass Example Repmin",
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "repmin",
          "normalized": "Tree a-\u003eTree a",
          "package": "Control-Monad-MultiPass",
          "signature": "Tree a-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Repmin.html#v:repmin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNew algorithm, using the \u003ca\u003eControl.Monad.MultiPass\u003c/a\u003e library.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "repminMP",
          "package": "Control-Monad-MultiPass",
          "signature": "Tree a -\u003e ST2 r w (Tree a)",
          "source": "src/Control-Monad-MultiPass-Example-Repmin.html#repminMP",
          "type": "function"
        },
        "index": {
          "description": "New algorithm using the Control.Monad.MultiPass library",
          "hierarchy": "Control Monad MultiPass Example Repmin",
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "repminMP",
          "normalized": "Tree a-\u003eST b c(Tree a)",
          "package": "Control-Monad-MultiPass",
          "partial": "MP",
          "signature": "Tree a-\u003eST r w(Tree a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Repmin.html#v:repminMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSecond version of the new algorithm (\u003ccode\u003e\u003ca\u003erepminMP\u003c/a\u003e\u003c/code\u003e), using the\n \u003ccode\u003e\u003ca\u003eKnot3\u003c/a\u003e\u003c/code\u003e instrument, rather than \u003ccode\u003e\u003ca\u003eTopKnot\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "repminMP2",
          "package": "Control-Monad-MultiPass",
          "signature": "Tree a -\u003e ST2 r w (Tree a)",
          "source": "src/Control-Monad-MultiPass-Example-Repmin.html#repminMP2",
          "type": "function"
        },
        "index": {
          "description": "Second version of the new algorithm repminMP using the Knot3 instrument rather than TopKnot",
          "hierarchy": "Control Monad MultiPass Example Repmin",
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "repminMP2",
          "normalized": "Tree a-\u003eST b c(Tree a)",
          "package": "Control-Monad-MultiPass",
          "partial": "MP",
          "signature": "Tree a-\u003eST r w(Tree a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Repmin.html#v:repminMP2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThird version of the new algorithm (\u003ccode\u003e\u003ca\u003erepminMP\u003c/a\u003e\u003c/code\u003e), using the\n \u003ccode\u003e\u003ca\u003eMonoid2\u003c/a\u003e\u003c/code\u003e instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "repminMP3",
          "package": "Control-Monad-MultiPass",
          "signature": "Tree a -\u003e ST2 r w (Tree a)",
          "source": "src/Control-Monad-MultiPass-Example-Repmin.html#repminMP3",
          "type": "function"
        },
        "index": {
          "description": "Third version of the new algorithm repminMP using the Monoid2 instrument",
          "hierarchy": "Control Monad MultiPass Example Repmin",
          "module": "Control.Monad.MultiPass.Example.Repmin",
          "name": "repminMP3",
          "normalized": "Tree a-\u003eST b c(Tree a)",
          "package": "Control-Monad-MultiPass",
          "partial": "MP",
          "signature": "Tree a-\u003eST r w(Tree a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-Repmin.html#v:repminMP3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn example of the use of the\n\u003ccode\u003e\u003ca\u003eOrdCons\u003c/a\u003e\u003c/code\u003e instrument.\nAn array of strings is converted to an array of integer indices,\nwith one index for each distinct string. This process is commonly\nknown as \u003ca\u003estring interning\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Example.StringInterning",
          "name": "StringInterning",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Example-StringInterning.html",
          "type": "module"
        },
        "index": {
          "description": "An example of the use of the OrdCons instrument An array of strings is converted to an array of integer indices with one index for each distinct string This process is commonly known as string interning",
          "hierarchy": "Control Monad MultiPass Example StringInterning",
          "module": "Control.Monad.MultiPass.Example.StringInterning",
          "name": "StringInterning",
          "package": "Control-Monad-MultiPass",
          "partial": "String Interning",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-StringInterning.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.Example.StringInterning",
          "name": "internStringArray",
          "package": "Control-Monad-MultiPass",
          "signature": "NumThreads -\u003e ST2Array r w Int String -\u003e ST2 r w (ST2Array r w Int Int, OrdConsTable String)",
          "source": "src/Control-Monad-MultiPass-Example-StringInterning.html#internStringArray",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass Example StringInterning",
          "module": "Control.Monad.MultiPass.Example.StringInterning",
          "name": "internStringArray",
          "normalized": "NumThreads-\u003eST Array a b Int String-\u003eST a b(ST Array a b Int Int,OrdConsTable String)",
          "package": "Control-Monad-MultiPass",
          "partial": "String Array",
          "signature": "NumThreads-\u003eST Array r w Int String-\u003eST r w(ST Array r w Int Int,OrdConsTable String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Example-StringInterning.html#v:internStringArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eCounter\u003c/a\u003e\u003c/code\u003e instrument is used to generate an increasing\nsequence of integers. It is particularly useful when the program\nuses parallelism, because the \u003ccode\u003e\u003ca\u003eCounter\u003c/a\u003e\u003c/code\u003e instrument creates the\nillusion of a single-threaded global counter. The first pass\ncounts how many unique integers each thread needs so that the\nintegers can be generated without the use of locks during the\nsecond pass.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Counter",
          "name": "Counter",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-Counter.html",
          "type": "module"
        },
        "index": {
          "description": "The Counter instrument is used to generate an increasing sequence of integers It is particularly useful when the program uses parallelism because the Counter instrument creates the illusion of single-threaded global counter The first pass counts how many unique integers each thread needs so that the integers can be generated without the use of locks during the second pass",
          "hierarchy": "Control Monad MultiPass Instrument Counter",
          "module": "Control.Monad.MultiPass.Instrument.Counter",
          "name": "Counter",
          "package": "Control-Monad-MultiPass",
          "partial": "Counter",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Counter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract datatype for the instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Counter",
          "name": "Counter",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-Counter.html#Counter",
          "type": "data"
        },
        "index": {
          "description": "Abstract datatype for the instrument",
          "hierarchy": "Control Monad MultiPass Instrument Counter",
          "module": "Control.Monad.MultiPass.Instrument.Counter",
          "name": "Counter",
          "package": "Control-Monad-MultiPass",
          "partial": "Counter",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Counter.html#t:Counter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd \u003ccode\u003ek\u003c/code\u003e to the counter.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Counter",
          "name": "addk",
          "package": "Control-Monad-MultiPass",
          "signature": "Counter i r w p1 p2 tc-\u003e p1 i-\u003e MultiPass r w tc ()",
          "type": "function"
        },
        "index": {
          "description": "Add to the counter",
          "hierarchy": "Control Monad MultiPass Instrument Counter",
          "module": "Control.Monad.MultiPass.Instrument.Counter",
          "name": "addk",
          "normalized": "Counter a b c d d e-\u003ed a-\u003eMultiPass b c e()",
          "package": "Control-Monad-MultiPass",
          "signature": "Counter i r w p p tc-\u003ep i-\u003eMultiPass r w tc()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Counter.html#v:addk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrement the counter.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Counter",
          "name": "incr",
          "package": "Control-Monad-MultiPass",
          "signature": "Counter i r w p1 p2 tc -\u003e MultiPass r w tc ()",
          "source": "src/Control-Monad-MultiPass-Instrument-Counter.html#incr",
          "type": "function"
        },
        "index": {
          "description": "Increment the counter",
          "hierarchy": "Control Monad MultiPass Instrument Counter",
          "module": "Control.Monad.MultiPass.Instrument.Counter",
          "name": "incr",
          "normalized": "Counter a b c d d e-\u003eMultiPass b c e()",
          "package": "Control-Monad-MultiPass",
          "signature": "Counter i r w p p tc-\u003eMultiPass r w tc()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Counter.html#v:incr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the current value of the counter.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Counter",
          "name": "peek",
          "package": "Control-Monad-MultiPass",
          "signature": "Counter i r w p1 p2 tc -\u003e MultiPass r w tc (p2 i)",
          "source": "src/Control-Monad-MultiPass-Instrument-Counter.html#peek",
          "type": "function"
        },
        "index": {
          "description": "Get the current value of the counter",
          "hierarchy": "Control Monad MultiPass Instrument Counter",
          "module": "Control.Monad.MultiPass.Instrument.Counter",
          "name": "peek",
          "normalized": "Counter a b c d d e-\u003eMultiPass b c e(d a)",
          "package": "Control-Monad-MultiPass",
          "signature": "Counter i r w p p tc-\u003eMultiPass r w tc(p i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Counter.html#v:peek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead and post-increment the counter. For example, if the current\n value is 17 then \u003ccode\u003e\u003ca\u003epostIncr\u003c/a\u003e\u003c/code\u003e updates the value of the counter to 18\n and returns 17.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Counter",
          "name": "postIncr",
          "package": "Control-Monad-MultiPass",
          "signature": "Counter i r w p1 p2 tc -\u003e MultiPass r w tc (p2 i)",
          "source": "src/Control-Monad-MultiPass-Instrument-Counter.html#postIncr",
          "type": "function"
        },
        "index": {
          "description": "Read and post-increment the counter For example if the current value is then postIncr updates the value of the counter to and returns",
          "hierarchy": "Control Monad MultiPass Instrument Counter",
          "module": "Control.Monad.MultiPass.Instrument.Counter",
          "name": "postIncr",
          "normalized": "Counter a b c d d e-\u003eMultiPass b c e(d a)",
          "package": "Control-Monad-MultiPass",
          "partial": "Incr",
          "signature": "Counter i r w p p tc-\u003eMultiPass r w tc(p i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Counter.html#v:postIncr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead and pre-increment the counter. For example, if the current\n value is 17 then \u003ccode\u003e\u003ca\u003epreIncr\u003c/a\u003e\u003c/code\u003e updates the value of the counter to 18\n and returns 18.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Counter",
          "name": "preIncr",
          "package": "Control-Monad-MultiPass",
          "signature": "Counter i r w p1 p2 tc -\u003e MultiPass r w tc (p2 i)",
          "source": "src/Control-Monad-MultiPass-Instrument-Counter.html#preIncr",
          "type": "function"
        },
        "index": {
          "description": "Read and pre-increment the counter For example if the current value is then preIncr updates the value of the counter to and returns",
          "hierarchy": "Control Monad MultiPass Instrument Counter",
          "module": "Control.Monad.MultiPass.Instrument.Counter",
          "name": "preIncr",
          "normalized": "Counter a b c d d e-\u003eMultiPass b c e(d a)",
          "package": "Control-Monad-MultiPass",
          "partial": "Incr",
          "signature": "Counter i r w p p tc-\u003eMultiPass r w tc(p i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Counter.html#v:preIncr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eCreateST2Array\u003c/a\u003e\u003c/code\u003e instrument is stateless and provides a similar\ninterface to \u003ccode\u003e\u003ca\u003eparallelMP\u003c/a\u003e\u003c/code\u003e. The difference is that it produces the\nnew array in a specific pass.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Instrument.CreateST2Array",
          "name": "CreateST2Array",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-CreateST2Array.html",
          "type": "module"
        },
        "index": {
          "description": "The CreateST2Array instrument is stateless and provides similar interface to parallelMP The difference is that it produces the new array in specific pass",
          "hierarchy": "Control Monad MultiPass Instrument CreateST2Array",
          "module": "Control.Monad.MultiPass.Instrument.CreateST2Array",
          "name": "CreateST2Array",
          "package": "Control-Monad-MultiPass",
          "partial": "Create ST Array",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-CreateST2Array.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract datatype for the instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.CreateST2Array",
          "name": "CreateST2Array",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-CreateST2Array.html#CreateST2Array",
          "type": "data"
        },
        "index": {
          "description": "Abstract datatype for the instrument",
          "hierarchy": "Control Monad MultiPass Instrument CreateST2Array",
          "module": "Control.Monad.MultiPass.Instrument.CreateST2Array",
          "name": "CreateST2Array",
          "package": "Control-Monad-MultiPass",
          "partial": "Create ST Array",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-CreateST2Array.html#t:CreateST2Array"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new array during pass \u003ccode\u003ep1\u003c/code\u003e, using the initialisation\n function to initialise the elements. The initialisation is done in\n parallel, using the specified number of threads.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.CreateST2Array",
          "name": "createST2Array",
          "package": "Control-Monad-MultiPass",
          "signature": "CreateST2Array r w p1 tc-\u003e NumThreads-\u003e (i, i)-\u003e (i -\u003e MultiPass r w tc (p1 a))-\u003e MultiPass r w tc (p1 (ST2Array r w i a))",
          "type": "function"
        },
        "index": {
          "description": "Create new array during pass p1 using the initialisation function to initialise the elements The initialisation is done in parallel using the specified number of threads",
          "hierarchy": "Control Monad MultiPass Instrument CreateST2Array",
          "module": "Control.Monad.MultiPass.Instrument.CreateST2Array",
          "name": "createST2Array",
          "normalized": "CreateST Array a b c d-\u003eNumThreads-\u003e(e,e)-\u003e(e-\u003eMultiPass a b d(c f))-\u003eMultiPass a b d(c(ST Array a b e f))",
          "package": "Control-Monad-MultiPass",
          "partial": "ST Array",
          "signature": "CreateST Array r w p tc-\u003eNumThreads-\u003e(i,i)-\u003e(i-\u003eMultiPass r w tc(p a))-\u003eMultiPass r w tc(p(ST Array r w i a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-CreateST2Array.html#v:createST2Array"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epmapST2ArrayMP\u003c/a\u003e\u003c/code\u003e is a simple application of \u003ccode\u003e\u003ca\u003ecreateST2Array\u003c/a\u003e\u003c/code\u003e.  It\n provides a similar interface to\n \u003ccode\u003e\u003ca\u003emapST2ArrayMP\u003c/a\u003e\u003c/code\u003e. The difference is\n that it only executes the map operation once the specified pass is\n reached.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.CreateST2Array",
          "name": "pmapST2ArrayMP",
          "package": "Control-Monad-MultiPass",
          "signature": "CreateST2Array r w p1 tc-\u003e NumThreads-\u003e ST2Array r w i a-\u003e (a -\u003e MultiPass r w tc (p1 b))-\u003e MultiPass r w tc (p1 (ST2Array r w i b))",
          "type": "function"
        },
        "index": {
          "description": "pmapST2ArrayMP is simple application of createST2Array It provides similar interface to mapST2ArrayMP The difference is that it only executes the map operation once the specified pass is reached",
          "hierarchy": "Control Monad MultiPass Instrument CreateST2Array",
          "module": "Control.Monad.MultiPass.Instrument.CreateST2Array",
          "name": "pmapST2ArrayMP",
          "normalized": "CreateST Array a b c d-\u003eNumThreads-\u003eST Array a b e f-\u003e(f-\u003eMultiPass a b d(c g))-\u003eMultiPass a b d(c(ST Array a b e g))",
          "package": "Control-Monad-MultiPass",
          "partial": "ST Array MP",
          "signature": "CreateST Array r w p tc-\u003eNumThreads-\u003eST Array r w i a-\u003e(a-\u003eMultiPass r w tc(p b))-\u003eMultiPass r w tc(p(ST Array r w i b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-CreateST2Array.html#v:pmapST2ArrayMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eDelay\u003c/a\u003e\u003c/code\u003e instrument is stateless and its implementation is trivial.\nIts purpose is to allow values which were computed in pass \u003ccode\u003ep1\u003c/code\u003e to be\nused in pass \u003ccode\u003ep2\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Delay",
          "name": "Delay",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-Delay.html",
          "type": "module"
        },
        "index": {
          "description": "The Delay instrument is stateless and its implementation is trivial Its purpose is to allow values which were computed in pass p1 to be used in pass p2",
          "hierarchy": "Control Monad MultiPass Instrument Delay",
          "module": "Control.Monad.MultiPass.Instrument.Delay",
          "name": "Delay",
          "package": "Control-Monad-MultiPass",
          "partial": "Delay",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Delay.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract datatype for the instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Delay",
          "name": "Delay",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-Delay.html#Delay",
          "type": "data"
        },
        "index": {
          "description": "Abstract datatype for the instrument",
          "hierarchy": "Control Monad MultiPass Instrument Delay",
          "module": "Control.Monad.MultiPass.Instrument.Delay",
          "name": "Delay",
          "package": "Control-Monad-MultiPass",
          "partial": "Delay",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Delay.html#t:Delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edelay\u003c/a\u003e\u003c/code\u003e enables a value which was computed in pass \u003ccode\u003ep1\u003c/code\u003e to be\n used in pass \u003ccode\u003ep2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Delay",
          "name": "delay",
          "package": "Control-Monad-MultiPass",
          "signature": "Delay p1 p2 tc -\u003e p1 a -\u003e p2 a",
          "source": "src/Control-Monad-MultiPass-Instrument-Delay.html#delay",
          "type": "function"
        },
        "index": {
          "description": "delay enables value which was computed in pass p1 to be used in pass p2",
          "hierarchy": "Control Monad MultiPass Instrument Delay",
          "module": "Control.Monad.MultiPass.Instrument.Delay",
          "name": "delay",
          "normalized": "Delay a a b-\u003ea c-\u003ea c",
          "package": "Control-Monad-MultiPass",
          "signature": "Delay p p tc-\u003ep a-\u003ep a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Delay.html#v:delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eDelayedLift\u003c/a\u003e\u003c/code\u003e instrument is stateless and provides a similar\ninterface to \u003ccode\u003e\u003ca\u003ereadOnlyST2ToMP\u003c/a\u003e\u003c/code\u003e. The difference is that it only\nexecutes the read-only computation once the specified pass is reached.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Instrument.DelayedLift",
          "name": "DelayedLift",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-DelayedLift.html",
          "type": "module"
        },
        "index": {
          "description": "The DelayedLift instrument is stateless and provides similar interface to readOnlyST2ToMP The difference is that it only executes the read-only computation once the specified pass is reached",
          "hierarchy": "Control Monad MultiPass Instrument DelayedLift",
          "module": "Control.Monad.MultiPass.Instrument.DelayedLift",
          "name": "DelayedLift",
          "package": "Control-Monad-MultiPass",
          "partial": "Delayed Lift",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-DelayedLift.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract datatype for the instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.DelayedLift",
          "name": "DelayedLift",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-DelayedLift.html#DelayedLift",
          "type": "data"
        },
        "index": {
          "description": "Abstract datatype for the instrument",
          "hierarchy": "Control Monad MultiPass Instrument DelayedLift",
          "module": "Control.Monad.MultiPass.Instrument.DelayedLift",
          "name": "DelayedLift",
          "package": "Control-Monad-MultiPass",
          "partial": "Delayed Lift",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-DelayedLift.html#t:DelayedLift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExecute the read-only computation during pass \u003ccode\u003ep1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.DelayedLift",
          "name": "delayedLift",
          "package": "Control-Monad-MultiPass",
          "signature": "DelayedLift r w p1 tc -\u003e p1 (ReadOnlyST2 r a) -\u003e MultiPass r w tc (p1 a)",
          "source": "src/Control-Monad-MultiPass-Instrument-DelayedLift.html#delayedLift",
          "type": "function"
        },
        "index": {
          "description": "Execute the read-only computation during pass p1",
          "hierarchy": "Control Monad MultiPass Instrument DelayedLift",
          "module": "Control.Monad.MultiPass.Instrument.DelayedLift",
          "name": "delayedLift",
          "normalized": "DelayedLift a b c d-\u003ec(ReadOnlyST a e)-\u003eMultiPass a b d(c e)",
          "package": "Control-Monad-MultiPass",
          "partial": "Lift",
          "signature": "DelayedLift r w p tc-\u003ep(ReadOnlyST r a)-\u003eMultiPass r w tc(p a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-DelayedLift.html#v:delayedLift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ereadST2ArrayMP\u003c/a\u003e\u003c/code\u003e is a simple application of \u003ccode\u003e\u003ca\u003edelayedLift\u003c/a\u003e\u003c/code\u003e. It\n reads an index of the array during pass \u003ccode\u003ep1\u003c/code\u003e. This is particularly\n useful if the array does not exist in earlier passes, for example\n because it was created by the\n \u003ccode\u003e\u003ca\u003eCreateST2Array\u003c/a\u003e\u003c/code\u003e\n instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.DelayedLift",
          "name": "readST2ArrayMP",
          "package": "Control-Monad-MultiPass",
          "signature": "DelayedLift r w p1 tc -\u003e p1 (ST2Array r w i a) -\u003e i -\u003e MultiPass r w tc (p1 a)",
          "source": "src/Control-Monad-MultiPass-Instrument-DelayedLift.html#readST2ArrayMP",
          "type": "function"
        },
        "index": {
          "description": "readST2ArrayMP is simple application of delayedLift It reads an index of the array during pass p1 This is particularly useful if the array does not exist in earlier passes for example because it was created by the CreateST2Array instrument",
          "hierarchy": "Control Monad MultiPass Instrument DelayedLift",
          "module": "Control.Monad.MultiPass.Instrument.DelayedLift",
          "name": "readST2ArrayMP",
          "normalized": "DelayedLift a b c d-\u003ec(ST Array a b e f)-\u003ee-\u003eMultiPass a b d(c f)",
          "package": "Control-Monad-MultiPass",
          "partial": "ST Array MP",
          "signature": "DelayedLift r w p tc-\u003ep(ST Array r w i a)-\u003ei-\u003eMultiPass r w tc(p a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-DelayedLift.html#v:readST2ArrayMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eEmitST2Array\u003c/a\u003e\u003c/code\u003e instrument is used to emit a sequence of values to\nan \u003ccode\u003e\u003ca\u003eST2Array\u003c/a\u003e\u003c/code\u003e. It has three passes. The first pass counts the number\nof elements that will be written. The second pass is optional: it\nenables the index values to be read before the actual values have been\nwritten. (If this pass is not needed then the second and third passes\ncan be merged by coalescing the type variables for the second and\nthird passes: \u003ccode\u003eEmitST2Array p1 p2 p2\u003c/code\u003e.) The third pass writes the\nvalues to the output array.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2Array",
          "name": "EmitST2Array",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-EmitST2Array.html",
          "type": "module"
        },
        "index": {
          "description": "The EmitST2Array instrument is used to emit sequence of values to an ST2Array It has three passes The first pass counts the number of elements that will be written The second pass is optional it enables the index values to be read before the actual values have been written If this pass is not needed then the second and third passes can be merged by coalescing the type variables for the second and third passes EmitST2Array p1 p2 p2 The third pass writes the values to the output array",
          "hierarchy": "Control Monad MultiPass Instrument EmitST2Array",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2Array",
          "name": "EmitST2Array",
          "package": "Control-Monad-MultiPass",
          "partial": "Emit ST Array",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-EmitST2Array.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract datatype for the instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2Array",
          "name": "EmitST2Array",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-EmitST2Array.html#EmitST2Array",
          "type": "data"
        },
        "index": {
          "description": "Abstract datatype for the instrument",
          "hierarchy": "Control Monad MultiPass Instrument EmitST2Array",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2Array",
          "name": "EmitST2Array",
          "package": "Control-Monad-MultiPass",
          "partial": "Emit ST Array",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-EmitST2Array.html#t:EmitST2Array"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite one element to the output array.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2Array",
          "name": "emit",
          "package": "Control-Monad-MultiPass",
          "signature": "EmitST2Array i a r w p1 p2 p3 tc-\u003e p3 a-\u003e MultiPass r w tc ()",
          "type": "function"
        },
        "index": {
          "description": "Write one element to the output array",
          "hierarchy": "Control Monad MultiPass Instrument EmitST2Array",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2Array",
          "name": "emit",
          "normalized": "EmitST Array a b c d e e e f-\u003ee b-\u003eMultiPass c d f()",
          "package": "Control-Monad-MultiPass",
          "signature": "EmitST Array i a r w p p p tc-\u003ep a-\u003eMultiPass r w tc()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-EmitST2Array.html#v:emit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a list of elements to the output array. The length of the\n list needs to be declared in the first pass so that the correct\n number of elements can be allocated.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2Array",
          "name": "emitList",
          "package": "Control-Monad-MultiPass",
          "signature": "EmitST2Array i a r w p1 p2 p3 tc-\u003e p1 Int-\u003e p3 [a]-\u003e MultiPass r w tc ()",
          "type": "function"
        },
        "index": {
          "description": "Write list of elements to the output array The length of the list needs to be declared in the first pass so that the correct number of elements can be allocated",
          "hierarchy": "Control Monad MultiPass Instrument EmitST2Array",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2Array",
          "name": "emitList",
          "normalized": "EmitST Array a b c d e e e f-\u003ee Int-\u003ee[b]-\u003eMultiPass c d f()",
          "package": "Control-Monad-MultiPass",
          "partial": "List",
          "signature": "EmitST Array i a r w p p p tc-\u003ep Int-\u003ep[a]-\u003eMultiPass r w tc()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-EmitST2Array.html#v:emitList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the current index in the output array.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2Array",
          "name": "getIndex",
          "package": "Control-Monad-MultiPass",
          "signature": "EmitST2Array i a r w p1 p2 p3 tc-\u003e MultiPass r w' tc (p2 i)",
          "type": "function"
        },
        "index": {
          "description": "Get the current index in the output array",
          "hierarchy": "Control Monad MultiPass Instrument EmitST2Array",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2Array",
          "name": "getIndex",
          "normalized": "EmitST Array a b c d e e e f-\u003eMultiPass c g f(e a)",
          "package": "Control-Monad-MultiPass",
          "partial": "Index",
          "signature": "EmitST Array i a r w p p p tc-\u003eMultiPass r w' tc(p i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-EmitST2Array.html#v:getIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the output array.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2Array",
          "name": "getResult",
          "package": "Control-Monad-MultiPass",
          "signature": "EmitST2Array i a r w p1 p2 p3 tc-\u003e MultiPassEpilogue r w tc (p3 (ST2Array r w i a))",
          "type": "function"
        },
        "index": {
          "description": "Get the output array",
          "hierarchy": "Control Monad MultiPass Instrument EmitST2Array",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2Array",
          "name": "getResult",
          "normalized": "EmitST Array a b c d e e e f-\u003eMultiPassEpilogue c d f(e(ST Array c d a b))",
          "package": "Control-Monad-MultiPass",
          "partial": "Result",
          "signature": "EmitST Array i a r w p p p tc-\u003eMultiPassEpilogue r w tc(p(ST Array r w i a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-EmitST2Array.html#v:getResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitialise the base index of the output array. This method is\n optional: if it is not called then the base index defaults to zero.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2Array",
          "name": "setBaseIndex",
          "package": "Control-Monad-MultiPass",
          "signature": "EmitST2Array i a r w p1 p2 p3 tc-\u003e p2 i-\u003e MultiPassPrologue r w tc ()",
          "type": "function"
        },
        "index": {
          "description": "Initialise the base index of the output array This method is optional if it is not called then the base index defaults to zero",
          "hierarchy": "Control Monad MultiPass Instrument EmitST2Array",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2Array",
          "name": "setBaseIndex",
          "normalized": "EmitST Array a b c d e e e f-\u003ee a-\u003eMultiPassPrologue c d f()",
          "package": "Control-Monad-MultiPass",
          "partial": "Base Index",
          "signature": "EmitST Array i a r w p p p tc-\u003ep i-\u003eMultiPassPrologue r w tc()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-EmitST2Array.html#v:setBaseIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eEmitST2ArrayFxp\u003c/a\u003e\u003c/code\u003e instrument has an identical interface to\n\u003ccode\u003e\u003ca\u003eEmitST2Array\u003c/a\u003e\u003c/code\u003e. The only difference\nis that \u003ccode\u003e\u003ca\u003eEmitST2ArrayFxp\u003c/a\u003e\u003c/code\u003e includes support for back-tracking. The\n\u003ccode\u003e\u003ca\u003eemitList\u003c/a\u003e\u003c/code\u003e method of \u003ccode\u003e\u003ca\u003eEmitST2ArrayFxp\u003c/a\u003e\u003c/code\u003e permits the list argument to be\nlonger than the lower bound which was specified during the first\npass. If it is then the algorithm will back-track to the beginning of\nthe second pass and iterate until a fixed point has been reached.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2ArrayFxp",
          "name": "EmitST2ArrayFxp",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-EmitST2ArrayFxp.html",
          "type": "module"
        },
        "index": {
          "description": "The EmitST2ArrayFxp instrument has an identical interface to EmitST2Array The only difference is that EmitST2ArrayFxp includes support for back-tracking The emitList method of EmitST2ArrayFxp permits the list argument to be longer than the lower bound which was specified during the first pass If it is then the algorithm will back-track to the beginning of the second pass and iterate until fixed point has been reached",
          "hierarchy": "Control Monad MultiPass Instrument EmitST2ArrayFxp",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2ArrayFxp",
          "name": "EmitST2ArrayFxp",
          "package": "Control-Monad-MultiPass",
          "partial": "Emit ST Array Fxp",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-EmitST2ArrayFxp.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract datatype for the instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2ArrayFxp",
          "name": "EmitST2ArrayFxp",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-EmitST2ArrayFxp.html#EmitST2ArrayFxp",
          "type": "data"
        },
        "index": {
          "description": "Abstract datatype for the instrument",
          "hierarchy": "Control Monad MultiPass Instrument EmitST2ArrayFxp",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2ArrayFxp",
          "name": "EmitST2ArrayFxp",
          "package": "Control-Monad-MultiPass",
          "partial": "Emit ST Array Fxp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-EmitST2ArrayFxp.html#t:EmitST2ArrayFxp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite one element to the output array.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2ArrayFxp",
          "name": "emit",
          "package": "Control-Monad-MultiPass",
          "signature": "EmitST2ArrayFxp i a r w p1 p2 p3 tc-\u003e p3 a-\u003e MultiPass r w tc ()",
          "type": "function"
        },
        "index": {
          "description": "Write one element to the output array",
          "hierarchy": "Control Monad MultiPass Instrument EmitST2ArrayFxp",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2ArrayFxp",
          "name": "emit",
          "normalized": "EmitST ArrayFxp a b c d e e e f-\u003ee b-\u003eMultiPass c d f()",
          "package": "Control-Monad-MultiPass",
          "signature": "EmitST ArrayFxp i a r w p p p tc-\u003ep a-\u003eMultiPass r w tc()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-EmitST2ArrayFxp.html#v:emit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a list of elements to the output array. The instrument uses\n back-tracking to iterate until the length of the list has been\n determined. It is the client's responsibility to ensure that any\n operations which depend on the length of the list are monotonic so\n that a fixed point will be found. The first argument is used to\n supply a minimum length for the list (zero is always a valid\n input). It can be used to shorten the time to convergence when a\n good lower bound is known.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2ArrayFxp",
          "name": "emitList",
          "package": "Control-Monad-MultiPass",
          "signature": "EmitST2ArrayFxp i a r w p1 p2 p3 tc-\u003e p1 Int-\u003e p3 [a]-\u003e MultiPass r w tc ()",
          "type": "function"
        },
        "index": {
          "description": "Write list of elements to the output array The instrument uses back-tracking to iterate until the length of the list has been determined It is the client responsibility to ensure that any operations which depend on the length of the list are monotonic so that fixed point will be found The first argument is used to supply minimum length for the list zero is always valid input It can be used to shorten the time to convergence when good lower bound is known",
          "hierarchy": "Control Monad MultiPass Instrument EmitST2ArrayFxp",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2ArrayFxp",
          "name": "emitList",
          "normalized": "EmitST ArrayFxp a b c d e e e f-\u003ee Int-\u003ee[b]-\u003eMultiPass c d f()",
          "package": "Control-Monad-MultiPass",
          "partial": "List",
          "signature": "EmitST ArrayFxp i a r w p p p tc-\u003ep Int-\u003ep[a]-\u003eMultiPass r w tc()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-EmitST2ArrayFxp.html#v:emitList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the current index in the output array.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2ArrayFxp",
          "name": "getIndex",
          "package": "Control-Monad-MultiPass",
          "signature": "EmitST2ArrayFxp i a r w p1 p2 p3 tc-\u003e MultiPass r w' tc (p2 i)",
          "type": "function"
        },
        "index": {
          "description": "Get the current index in the output array",
          "hierarchy": "Control Monad MultiPass Instrument EmitST2ArrayFxp",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2ArrayFxp",
          "name": "getIndex",
          "normalized": "EmitST ArrayFxp a b c d e e e f-\u003eMultiPass c g f(e a)",
          "package": "Control-Monad-MultiPass",
          "partial": "Index",
          "signature": "EmitST ArrayFxp i a r w p p p tc-\u003eMultiPass r w' tc(p i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-EmitST2ArrayFxp.html#v:getIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the output array.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2ArrayFxp",
          "name": "getResult",
          "package": "Control-Monad-MultiPass",
          "signature": "EmitST2ArrayFxp i a r w p1 p2 p3 tc-\u003e MultiPassEpilogue r w tc (p3 (ST2Array r w i a))",
          "type": "function"
        },
        "index": {
          "description": "Get the output array",
          "hierarchy": "Control Monad MultiPass Instrument EmitST2ArrayFxp",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2ArrayFxp",
          "name": "getResult",
          "normalized": "EmitST ArrayFxp a b c d e e e f-\u003eMultiPassEpilogue c d f(e(ST Array c d a b))",
          "package": "Control-Monad-MultiPass",
          "partial": "Result",
          "signature": "EmitST ArrayFxp i a r w p p p tc-\u003eMultiPassEpilogue r w tc(p(ST Array r w i a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-EmitST2ArrayFxp.html#v:getResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitialise the base index of the output array. This method is\n optional: if it is not called then the base index defaults to zero.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2ArrayFxp",
          "name": "setBaseIndex",
          "package": "Control-Monad-MultiPass",
          "signature": "EmitST2ArrayFxp i a r w p1 p2 p3 tc-\u003e p2 i-\u003e MultiPassPrologue r w tc ()",
          "type": "function"
        },
        "index": {
          "description": "Initialise the base index of the output array This method is optional if it is not called then the base index defaults to zero",
          "hierarchy": "Control Monad MultiPass Instrument EmitST2ArrayFxp",
          "module": "Control.Monad.MultiPass.Instrument.EmitST2ArrayFxp",
          "name": "setBaseIndex",
          "normalized": "EmitST ArrayFxp a b c d e e e f-\u003ee a-\u003eMultiPassPrologue c d f()",
          "package": "Control-Monad-MultiPass",
          "partial": "Base Index",
          "signature": "EmitST ArrayFxp i a r w p p p tc-\u003ep i-\u003eMultiPassPrologue r w tc()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-EmitST2ArrayFxp.html#v:setBaseIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eKnot3\u003c/a\u003e\u003c/code\u003e instrument is used for knot tying across passes. Knot\ntying is a technique sometimes used in lazy functional programming, in\nwhich the definition of a variable depends on its own value. The lazy\nprogramming technique depends on an implicit two-pass ordering of the\ncomputation. For example, the classic repmin program produces a pair\nof outputs - a tree and an integer - and there is an implicit two-pass\nordering where the integer is computed during the first pass and the\ntree during the second. The \u003ccode\u003e\u003ca\u003eKnot3\u003c/a\u003e\u003c/code\u003e instrument allows the same\ntechnique to be applied, but the ordering of the passes is managed\nexplicitly by the \u003ca\u003eControl.Monad.MultiPass\u003c/a\u003e library, rather than\nimplicitly by lazy evalution.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Knot3",
          "name": "Knot3",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-Knot3.html",
          "type": "module"
        },
        "index": {
          "description": "The Knot3 instrument is used for knot tying across passes Knot tying is technique sometimes used in lazy functional programming in which the definition of variable depends on its own value The lazy programming technique depends on an implicit two-pass ordering of the computation For example the classic repmin program produces pair of outputs tree and an integer and there is an implicit two-pass ordering where the integer is computed during the first pass and the tree during the second The Knot3 instrument allows the same technique to be applied but the ordering of the passes is managed explicitly by the Control.Monad.MultiPass library rather than implicitly by lazy evalution",
          "hierarchy": "Control Monad MultiPass Instrument Knot3",
          "module": "Control.Monad.MultiPass.Instrument.Knot3",
          "name": "Knot3",
          "package": "Control-Monad-MultiPass",
          "partial": "Knot",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Knot3.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract datatype for the instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Knot3",
          "name": "Knot3",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-Knot3.html#Knot3",
          "type": "data"
        },
        "index": {
          "description": "Abstract datatype for the instrument",
          "hierarchy": "Control Monad MultiPass Instrument Knot3",
          "module": "Control.Monad.MultiPass.Instrument.Knot3",
          "name": "Knot3",
          "package": "Control-Monad-MultiPass",
          "partial": "Knot",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Knot3.html#t:Knot3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTie the knot for the supplied function.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Knot3",
          "name": "knot3",
          "package": "Control-Monad-MultiPass",
          "signature": "Knot3 a r w p1 p2 p3 tc -\u003e (p3 a -\u003e MultiPass r w tc (p2 a, b)) -\u003e MultiPass r w tc b",
          "source": "src/Control-Monad-MultiPass-Instrument-Knot3.html#knot3",
          "type": "function"
        },
        "index": {
          "description": "Tie the knot for the supplied function",
          "hierarchy": "Control Monad MultiPass Instrument Knot3",
          "module": "Control.Monad.MultiPass.Instrument.Knot3",
          "name": "knot3",
          "normalized": "Knot a b c d d d e-\u003e(d a-\u003eMultiPass b c e(d a,f))-\u003eMultiPass b c e f",
          "package": "Control-Monad-MultiPass",
          "signature": "Knot a r w p p p tc-\u003e(p a-\u003eMultiPass r w tc(p a,b))-\u003eMultiPass r w tc b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Knot3.html#v:knot3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eMonoid2\u003c/a\u003e\u003c/code\u003e instrument is used to accumulate a global value during\nthe first pass. During the second pass, the global value can be read\nbut not written. The value must be an instance of the\n\u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e class. The names of the methods, \u003ccode\u003e\u003ca\u003etell\u003c/a\u003e\u003c/code\u003e and\n\u003ccode\u003e\u003ca\u003elisten\u003c/a\u003e\u003c/code\u003e, are taken from the \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e\nclass. If this causes a naming conflict, then this module should be\nimported qualified. For example:\n\u003c/p\u003e\u003cpre\u003e import qualified Control.Monad.MultiPass.Instrument.Monoid2 as M\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Monoid2",
          "name": "Monoid2",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-Monoid2.html",
          "type": "module"
        },
        "index": {
          "description": "The Monoid2 instrument is used to accumulate global value during the first pass During the second pass the global value can be read but not written The value must be an instance of the Monoid class The names of the methods tell and listen are taken from the MonadWriter class If this causes naming conflict then this module should be imported qualified For example import qualified Control.Monad.MultiPass.Instrument.Monoid2 as",
          "hierarchy": "Control Monad MultiPass Instrument Monoid2",
          "module": "Control.Monad.MultiPass.Instrument.Monoid2",
          "name": "Monoid2",
          "package": "Control-Monad-MultiPass",
          "partial": "Monoid",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Monoid2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract datatype for the instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Monoid2",
          "name": "Monoid2",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-Monoid2.html#Monoid2",
          "type": "data"
        },
        "index": {
          "description": "Abstract datatype for the instrument",
          "hierarchy": "Control Monad MultiPass Instrument Monoid2",
          "module": "Control.Monad.MultiPass.Instrument.Monoid2",
          "name": "Monoid2",
          "package": "Control-Monad-MultiPass",
          "partial": "Monoid",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Monoid2.html#t:Monoid2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the global value, during the second pass.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Monoid2",
          "name": "listen",
          "package": "Control-Monad-MultiPass",
          "signature": "Monoid2 a r w p1 p2 tc-\u003e MultiPass r w tc (p2 a)",
          "type": "function"
        },
        "index": {
          "description": "Read the global value during the second pass",
          "hierarchy": "Control Monad MultiPass Instrument Monoid2",
          "module": "Control.Monad.MultiPass.Instrument.Monoid2",
          "name": "listen",
          "normalized": "Monoid a b c d d e-\u003eMultiPass b c e(d a)",
          "package": "Control-Monad-MultiPass",
          "signature": "Monoid a r w p p tc-\u003eMultiPass r w tc(p a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Monoid2.html#v:listen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the global value, during the epilogue of the first pass.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Monoid2",
          "name": "listenEpilogue",
          "package": "Control-Monad-MultiPass",
          "signature": "Monoid2 a r w p1 p2 tc-\u003e MultiPassEpilogue r w tc (p1 a)",
          "type": "function"
        },
        "index": {
          "description": "Read the global value during the epilogue of the first pass",
          "hierarchy": "Control Monad MultiPass Instrument Monoid2",
          "module": "Control.Monad.MultiPass.Instrument.Monoid2",
          "name": "listenEpilogue",
          "normalized": "Monoid a b c d d e-\u003eMultiPassEpilogue b c e(d a)",
          "package": "Control-Monad-MultiPass",
          "partial": "Epilogue",
          "signature": "Monoid a r w p p tc-\u003eMultiPassEpilogue r w tc(p a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Monoid2.html#v:listenEpilogue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a value to the global value, during the first pass.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Monoid2",
          "name": "tell",
          "package": "Control-Monad-MultiPass",
          "signature": "Monoid2 a r w p1 p2 tc-\u003e p1 a-\u003e MultiPass r w tc ()",
          "type": "function"
        },
        "index": {
          "description": "Add value to the global value during the first pass",
          "hierarchy": "Control Monad MultiPass Instrument Monoid2",
          "module": "Control.Monad.MultiPass.Instrument.Monoid2",
          "name": "tell",
          "normalized": "Monoid a b c d d e-\u003ed a-\u003eMultiPass b c e()",
          "package": "Control-Monad-MultiPass",
          "signature": "Monoid a r w p p tc-\u003ep a-\u003eMultiPass r w tc()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Monoid2.html#v:tell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a value to the global value, during the prologue of the first\n pass.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.Monoid2",
          "name": "tellPrologue",
          "package": "Control-Monad-MultiPass",
          "signature": "Monoid2 a r w p1 p2 tc-\u003e p1 a-\u003e MultiPassPrologue r w tc ()",
          "type": "function"
        },
        "index": {
          "description": "Add value to the global value during the prologue of the first pass",
          "hierarchy": "Control Monad MultiPass Instrument Monoid2",
          "module": "Control.Monad.MultiPass.Instrument.Monoid2",
          "name": "tellPrologue",
          "normalized": "Monoid a b c d d e-\u003ed a-\u003eMultiPassPrologue b c e()",
          "package": "Control-Monad-MultiPass",
          "partial": "Prologue",
          "signature": "Monoid a r w p p tc-\u003ep a-\u003eMultiPassPrologue r w tc()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-Monoid2.html#v:tellPrologue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eOrdCons\u003c/a\u003e\u003c/code\u003e instrument uses two passes to implement hash-consing.\nThe values are added to the table during the first pass and a unique\nindex for each value is returned during the second pass.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eOrdCons\u003c/a\u003e\u003c/code\u003e is implemented using \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e, so it can be used on any\ndatatype which is an instance of \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "OrdCons",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-OrdCons.html",
          "type": "module"
        },
        "index": {
          "description": "The OrdCons instrument uses two passes to implement hash-consing The values are added to the table during the first pass and unique index for each value is returned during the second pass OrdCons is implemented using Map so it can be used on any datatype which is an instance of Ord",
          "hierarchy": "Control Monad MultiPass Instrument OrdCons",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "OrdCons",
          "package": "Control-Monad-MultiPass",
          "partial": "Ord Cons",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-OrdCons.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract datatype for the instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "OrdCons",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-OrdCons.html#OrdCons",
          "type": "data"
        },
        "index": {
          "description": "Abstract datatype for the instrument",
          "hierarchy": "Control Monad MultiPass Instrument OrdCons",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "OrdCons",
          "package": "Control-Monad-MultiPass",
          "partial": "Ord Cons",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-OrdCons.html#t:OrdCons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis datatype is a newtype around \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e. It maps its\n keys (of type \u003ccode\u003ea\u003c/code\u003e) to a permutation of the integers \u003ccode\u003e0..n-1\u003c/code\u003e, where\n \u003ccode\u003en\u003c/code\u003e is the number of keys.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "OrdConsTable",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-OrdCons.html#OrdConsTable",
          "type": "data"
        },
        "index": {
          "description": "This datatype is newtype around Map Int It maps its keys of type to permutation of the integers n-1 where is the number of keys",
          "hierarchy": "Control Monad MultiPass Instrument OrdCons",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "OrdConsTable",
          "package": "Control-Monad-MultiPass",
          "partial": "Ord Cons Table",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-OrdCons.html#t:OrdConsTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the final \u003ccode\u003e\u003ca\u003eOrdConsTable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "getOrdConsTable",
          "package": "Control-Monad-MultiPass",
          "signature": "OrdCons a r w p1 p2 tc -\u003e MultiPassEpilogue r w tc (p2 (OrdConsTable a))",
          "source": "src/Control-Monad-MultiPass-Instrument-OrdCons.html#getOrdConsTable",
          "type": "function"
        },
        "index": {
          "description": "Get the final OrdConsTable",
          "hierarchy": "Control Monad MultiPass Instrument OrdCons",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "getOrdConsTable",
          "normalized": "OrdCons a b c d d e-\u003eMultiPassEpilogue b c e(d(OrdConsTable a))",
          "package": "Control-Monad-MultiPass",
          "partial": "Ord Cons Table",
          "signature": "OrdCons a r w p p tc-\u003eMultiPassEpilogue r w tc(p(OrdConsTable a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-OrdCons.html#v:getOrdConsTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd multiple elements. The new elements are assigned indices\n \u003ccode\u003en..n+k-1\u003c/code\u003e, where \u003ccode\u003en\u003c/code\u003e is the original size of the table and \u003ccode\u003ek\u003c/code\u003e is\n the number of new elements to be added. This function will assert\n if any of the new elements are already in the table.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "growOrdConsTable",
          "package": "Control-Monad-MultiPass",
          "signature": "OrdConsTable a -\u003e Map a () -\u003e OrdConsTable a",
          "source": "src/Control-Monad-MultiPass-Instrument-OrdCons.html#growOrdConsTable",
          "type": "function"
        },
        "index": {
          "description": "Add multiple elements The new elements are assigned indices n..n k-1 where is the original size of the table and is the number of new elements to be added This function will assert if any of the new elements are already in the table",
          "hierarchy": "Control Monad MultiPass Instrument OrdCons",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "growOrdConsTable",
          "normalized": "OrdConsTable a-\u003eMap a()-\u003eOrdConsTable a",
          "package": "Control-Monad-MultiPass",
          "partial": "Ord Cons Table",
          "signature": "OrdConsTable a-\u003eMap a()-\u003eOrdConsTable a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-OrdCons.html#v:growOrdConsTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitialise the \u003ccode\u003e\u003ca\u003eOrdCons\u003c/a\u003e\u003c/code\u003e instrument with an \u003ccode\u003e\u003ca\u003eOrdConsTable\u003c/a\u003e\u003c/code\u003e.  This\n method is optional. Ff this method is not used then the instrument\n will be initialised with an empty \u003ccode\u003e\u003ca\u003eOrdConsTable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "initOrdCons",
          "package": "Control-Monad-MultiPass",
          "signature": "OrdCons a r w p1 p2 tc-\u003e p1 (OrdConsTable a)-\u003e MultiPassPrologue r w tc ()",
          "type": "function"
        },
        "index": {
          "description": "Initialise the OrdCons instrument with an OrdConsTable This method is optional Ff this method is not used then the instrument will be initialised with an empty OrdConsTable",
          "hierarchy": "Control Monad MultiPass Instrument OrdCons",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "initOrdCons",
          "normalized": "OrdCons a b c d d e-\u003ed(OrdConsTable a)-\u003eMultiPassPrologue b c e()",
          "package": "Control-Monad-MultiPass",
          "partial": "Ord Cons",
          "signature": "OrdCons a r w p p tc-\u003ep(OrdConsTable a)-\u003eMultiPassPrologue r w tc()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-OrdCons.html#v:initOrdCons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert an element. If the element is not in the map yet, then it\n is assigned index \u003ccode\u003en\u003c/code\u003e, where \u003ccode\u003en\u003c/code\u003e is the original size of the table.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "insertOrdConsTable",
          "package": "Control-Monad-MultiPass",
          "signature": "OrdConsTable a -\u003e a -\u003e OrdConsTable a",
          "source": "src/Control-Monad-MultiPass-Instrument-OrdCons.html#insertOrdConsTable",
          "type": "function"
        },
        "index": {
          "description": "Insert an element If the element is not in the map yet then it is assigned index where is the original size of the table",
          "hierarchy": "Control Monad MultiPass Instrument OrdCons",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "insertOrdConsTable",
          "normalized": "OrdConsTable a-\u003ea-\u003eOrdConsTable a",
          "package": "Control-Monad-MultiPass",
          "partial": "Ord Cons Table",
          "signature": "OrdConsTable a-\u003ea-\u003eOrdConsTable a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-OrdCons.html#v:insertOrdConsTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup an element.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "lookupOrdConsTable",
          "package": "Control-Monad-MultiPass",
          "signature": "OrdConsTable a -\u003e a -\u003e Maybe Int",
          "source": "src/Control-Monad-MultiPass-Instrument-OrdCons.html#lookupOrdConsTable",
          "type": "function"
        },
        "index": {
          "description": "Lookup an element",
          "hierarchy": "Control Monad MultiPass Instrument OrdCons",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "lookupOrdConsTable",
          "normalized": "OrdConsTable a-\u003ea-\u003eMaybe Int",
          "package": "Control-Monad-MultiPass",
          "partial": "Ord Cons Table",
          "signature": "OrdConsTable a-\u003ea-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-OrdCons.html#v:lookupOrdConsTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet a unique index for the value.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "ordCons",
          "package": "Control-Monad-MultiPass",
          "signature": "OrdCons a r w p1 p2 tc-\u003e p1 a-\u003e MultiPass r w tc (p2 Int)",
          "type": "function"
        },
        "index": {
          "description": "Get unique index for the value",
          "hierarchy": "Control Monad MultiPass Instrument OrdCons",
          "module": "Control.Monad.MultiPass.Instrument.OrdCons",
          "name": "ordCons",
          "normalized": "OrdCons a b c d d e-\u003ed a-\u003eMultiPass b c e(d Int)",
          "package": "Control-Monad-MultiPass",
          "partial": "Cons",
          "signature": "OrdCons a r w p p tc-\u003ep a-\u003eMultiPass r w tc(p Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-OrdCons.html#v:ordCons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eTopKnot\u003c/a\u003e\u003c/code\u003e instrument is used for knot tying across passes. It\nallows a value to be written during the epilogue of one pass and read\nduring the prologue of a later pass.  Knot tying is a technique\nsometimes used in lazy functional programming, in which the definition\nof a variable depends on its own value. The lazy programming technique\ndepends on an implicit two-pass ordering of the computation. For\nexample, the classic repmin program produces a pair of outputs - a\ntree and an integer - and there is an implicit two-pass ordering where\nthe integer is computed during the first pass and the tree during the\nsecond. The \u003ccode\u003e\u003ca\u003eTopKnot\u003c/a\u003e\u003c/code\u003e instrument allows the same technique to be\napplied, but the ordering of the passes is managed explicitly by the\n\u003ca\u003eControl.Monad.MultiPass\u003c/a\u003e library, rather than implicitly by lazy\nevalution.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Instrument.TopKnot",
          "name": "TopKnot",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-TopKnot.html",
          "type": "module"
        },
        "index": {
          "description": "The TopKnot instrument is used for knot tying across passes It allows value to be written during the epilogue of one pass and read during the prologue of later pass Knot tying is technique sometimes used in lazy functional programming in which the definition of variable depends on its own value The lazy programming technique depends on an implicit two-pass ordering of the computation For example the classic repmin program produces pair of outputs tree and an integer and there is an implicit two-pass ordering where the integer is computed during the first pass and the tree during the second The TopKnot instrument allows the same technique to be applied but the ordering of the passes is managed explicitly by the Control.Monad.MultiPass library rather than implicitly by lazy evalution",
          "hierarchy": "Control Monad MultiPass Instrument TopKnot",
          "module": "Control.Monad.MultiPass.Instrument.TopKnot",
          "name": "TopKnot",
          "package": "Control-Monad-MultiPass",
          "partial": "Top Knot",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-TopKnot.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract datatype for the instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.TopKnot",
          "name": "TopKnot",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Instrument-TopKnot.html#TopKnot",
          "type": "data"
        },
        "index": {
          "description": "Abstract datatype for the instrument",
          "hierarchy": "Control Monad MultiPass Instrument TopKnot",
          "module": "Control.Monad.MultiPass.Instrument.TopKnot",
          "name": "TopKnot",
          "package": "Control-Monad-MultiPass",
          "partial": "Top Knot",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-TopKnot.html#t:TopKnot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLoad the value that was stored during the first pass.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.TopKnot",
          "name": "load",
          "package": "Control-Monad-MultiPass",
          "signature": "TopKnot a r w p1 p2 tc -\u003e MultiPassPrologue r w tc (p2 a)",
          "source": "src/Control-Monad-MultiPass-Instrument-TopKnot.html#load",
          "type": "function"
        },
        "index": {
          "description": "Load the value that was stored during the first pass",
          "hierarchy": "Control Monad MultiPass Instrument TopKnot",
          "module": "Control.Monad.MultiPass.Instrument.TopKnot",
          "name": "load",
          "normalized": "TopKnot a b c d d e-\u003eMultiPassPrologue b c e(d a)",
          "package": "Control-Monad-MultiPass",
          "signature": "TopKnot a r w p p tc-\u003eMultiPassPrologue r w tc(p a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-TopKnot.html#v:load"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStore a value during the epilogue of the first pass. This\n function should be called exactly once.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Instrument.TopKnot",
          "name": "store",
          "package": "Control-Monad-MultiPass",
          "signature": "TopKnot a r w p1 p2 tc -\u003e p1 a -\u003e MultiPassEpilogue r w tc ()",
          "source": "src/Control-Monad-MultiPass-Instrument-TopKnot.html#store",
          "type": "function"
        },
        "index": {
          "description": "Store value during the epilogue of the first pass This function should be called exactly once",
          "hierarchy": "Control Monad MultiPass Instrument TopKnot",
          "module": "Control.Monad.MultiPass.Instrument.TopKnot",
          "name": "store",
          "normalized": "TopKnot a b c d d e-\u003ed a-\u003eMultiPassEpilogue b c e()",
          "package": "Control-Monad-MultiPass",
          "signature": "TopKnot a r w p p tc-\u003ep a-\u003eMultiPassEpilogue r w tc()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Instrument-TopKnot.html#v:store"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eCounterTC\u003c/a\u003e\u003c/code\u003e defines a\n thread context which is used to generate a series of unique\n consecutive numbers. It has two passes. The first pass,\n \u003ccode\u003e\u003ca\u003eCounterTC1\u003c/a\u003e\u003c/code\u003e, creates a log of the number of new values that need\n to be generated in each thread. The second pass, \u003ccode\u003e\u003ca\u003eCounterTC2\u003c/a\u003e\u003c/code\u003e, uses\n the log to compute the correct starting value for each thread, so\n that the threads appear to be incrementing a single global counter,\n even though they are operating concurrently.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "CounterTC",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-ThreadContext-CounterTC.html",
          "type": "module"
        },
        "index": {
          "description": "CounterTC defines thread context which is used to generate series of unique consecutive numbers It has two passes The first pass CounterTC1 creates log of the number of new values that need to be generated in each thread The second pass CounterTC2 uses the log to compute the correct starting value for each thread so that the threads appear to be incrementing single global counter even though they are operating concurrently",
          "hierarchy": "Control Monad MultiPass ThreadContext CounterTC",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "CounterTC",
          "package": "Control-Monad-MultiPass",
          "partial": "Counter TC",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-CounterTC.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eCounterTC1\u003c/a\u003e\u003c/code\u003e is used during the first pass. It builds up a log of\n the parallel tasks that were spawned, which is used during the\n second pass to generate a series of unique consecutive numbers.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "CounterTC1",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-ThreadContext-CounterTC.html#CounterTC1",
          "type": "data"
        },
        "index": {
          "description": "CounterTC1 is used during the first pass It builds up log of the parallel tasks that were spawned which is used during the second pass to generate series of unique consecutive numbers",
          "hierarchy": "Control Monad MultiPass ThreadContext CounterTC",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "CounterTC1",
          "package": "Control-Monad-MultiPass",
          "partial": "Counter TC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-CounterTC.html#t:CounterTC1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eCounterTC2\u003c/a\u003e\u003c/code\u003e is used during the second pass. It uses the log\n which was computed by \u003ccode\u003e\u003ca\u003eCounterTC1\u003c/a\u003e\u003c/code\u003e to generate a series of unique\n consecutive numbers.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "CounterTC2",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-ThreadContext-CounterTC.html#CounterTC2",
          "type": "data"
        },
        "index": {
          "description": "CounterTC2 is used during the second pass It uses the log which was computed by CounterTC1 to generate series of unique consecutive numbers",
          "hierarchy": "Control Monad MultiPass ThreadContext CounterTC",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "CounterTC2",
          "package": "Control-Monad-MultiPass",
          "partial": "Counter TC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-CounterTC.html#t:CounterTC2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd \u003ccode\u003ek\u003c/code\u003e to the counter.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "addkCounterTC1",
          "package": "Control-Monad-MultiPass",
          "signature": "i -\u003e CounterTC1 i r -\u003e CounterTC1 i r",
          "source": "src/Control-Monad-MultiPass-ThreadContext-CounterTC.html#addkCounterTC1",
          "type": "function"
        },
        "index": {
          "description": "Add to the counter",
          "hierarchy": "Control Monad MultiPass ThreadContext CounterTC",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "addkCounterTC1",
          "normalized": "a-\u003eCounterTC a b-\u003eCounterTC a b",
          "package": "Control-Monad-MultiPass",
          "partial": "Counter TC",
          "signature": "i-\u003eCounterTC i r-\u003eCounterTC i r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-CounterTC.html#v:addkCounterTC1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd \u003ccode\u003ek\u003c/code\u003e to the counter.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "addkCounterTC2",
          "package": "Control-Monad-MultiPass",
          "signature": "i -\u003e CounterTC2 i r -\u003e CounterTC2 i r",
          "source": "src/Control-Monad-MultiPass-ThreadContext-CounterTC.html#addkCounterTC2",
          "type": "function"
        },
        "index": {
          "description": "Add to the counter",
          "hierarchy": "Control Monad MultiPass ThreadContext CounterTC",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "addkCounterTC2",
          "normalized": "a-\u003eCounterTC a b-\u003eCounterTC a b",
          "package": "Control-Monad-MultiPass",
          "partial": "Counter TC",
          "signature": "i-\u003eCounterTC i r-\u003eCounterTC i r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-CounterTC.html#v:addkCounterTC2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the current value of the counter.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "counterVal1",
          "package": "Control-Monad-MultiPass",
          "signature": "CounterTC1 i r -\u003e i",
          "source": "src/Control-Monad-MultiPass-ThreadContext-CounterTC.html#counterVal1",
          "type": "function"
        },
        "index": {
          "description": "Get the current value of the counter",
          "hierarchy": "Control Monad MultiPass ThreadContext CounterTC",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "counterVal1",
          "normalized": "CounterTC a b-\u003ea",
          "package": "Control-Monad-MultiPass",
          "partial": "Val",
          "signature": "CounterTC i r-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-CounterTC.html#v:counterVal1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the current value of the counter.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "counterVal2",
          "package": "Control-Monad-MultiPass",
          "signature": "CounterTC2 i r -\u003e i",
          "source": "src/Control-Monad-MultiPass-ThreadContext-CounterTC.html#counterVal2",
          "type": "function"
        },
        "index": {
          "description": "Get the current value of the counter",
          "hierarchy": "Control Monad MultiPass ThreadContext CounterTC",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "counterVal2",
          "normalized": "CounterTC a b-\u003ea",
          "package": "Control-Monad-MultiPass",
          "partial": "Val",
          "signature": "CounterTC i r-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-CounterTC.html#v:counterVal2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrement the counter.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "incrCounterTC1",
          "package": "Control-Monad-MultiPass",
          "signature": "CounterTC1 i r -\u003e CounterTC1 i r",
          "source": "src/Control-Monad-MultiPass-ThreadContext-CounterTC.html#incrCounterTC1",
          "type": "function"
        },
        "index": {
          "description": "Increment the counter",
          "hierarchy": "Control Monad MultiPass ThreadContext CounterTC",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "incrCounterTC1",
          "normalized": "CounterTC a b-\u003eCounterTC a b",
          "package": "Control-Monad-MultiPass",
          "partial": "Counter TC",
          "signature": "CounterTC i r-\u003eCounterTC i r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-CounterTC.html#v:incrCounterTC1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrement the counter.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "incrCounterTC2",
          "package": "Control-Monad-MultiPass",
          "signature": "CounterTC2 i r -\u003e CounterTC2 i r",
          "source": "src/Control-Monad-MultiPass-ThreadContext-CounterTC.html#incrCounterTC2",
          "type": "function"
        },
        "index": {
          "description": "Increment the counter",
          "hierarchy": "Control Monad MultiPass ThreadContext CounterTC",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "incrCounterTC2",
          "normalized": "CounterTC a b-\u003eCounterTC a b",
          "package": "Control-Monad-MultiPass",
          "partial": "Counter TC",
          "signature": "CounterTC i r-\u003eCounterTC i r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-CounterTC.html#v:incrCounterTC2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new counter.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "newCounterTC1",
          "package": "Control-Monad-MultiPass",
          "signature": "CounterTC1 i r",
          "source": "src/Control-Monad-MultiPass-ThreadContext-CounterTC.html#newCounterTC1",
          "type": "function"
        },
        "index": {
          "description": "Create new counter",
          "hierarchy": "Control Monad MultiPass ThreadContext CounterTC",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "newCounterTC1",
          "package": "Control-Monad-MultiPass",
          "partial": "Counter TC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-CounterTC.html#v:newCounterTC1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eCounterTC1\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eCounterTC2\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "newCounterTC2",
          "package": "Control-Monad-MultiPass",
          "signature": "CounterTC1 i r -\u003e ST2 r w (CounterTC2 i r)",
          "source": "src/Control-Monad-MultiPass-ThreadContext-CounterTC.html#newCounterTC2",
          "type": "function"
        },
        "index": {
          "description": "Convert CounterTC1 to CounterTC2",
          "hierarchy": "Control Monad MultiPass ThreadContext CounterTC",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "newCounterTC2",
          "normalized": "CounterTC a b-\u003eST b c(CounterTC a b)",
          "package": "Control-Monad-MultiPass",
          "partial": "Counter TC",
          "signature": "CounterTC i r-\u003eST r w(CounterTC i r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-CounterTC.html#v:newCounterTC2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReset the counter to zero and rewind to the beginning of the log.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "resetCounterTC2",
          "package": "Control-Monad-MultiPass",
          "signature": "CounterTC2 i r -\u003e CounterTC2 i r",
          "source": "src/Control-Monad-MultiPass-ThreadContext-CounterTC.html#resetCounterTC2",
          "type": "function"
        },
        "index": {
          "description": "Reset the counter to zero and rewind to the beginning of the log",
          "hierarchy": "Control Monad MultiPass ThreadContext CounterTC",
          "module": "Control.Monad.MultiPass.ThreadContext.CounterTC",
          "name": "resetCounterTC2",
          "normalized": "CounterTC a b-\u003eCounterTC a b",
          "package": "Control-Monad-MultiPass",
          "partial": "Counter TC",
          "signature": "CounterTC i r-\u003eCounterTC i r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-CounterTC.html#v:resetCounterTC2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eMonoidTC\u003c/a\u003e\u003c/code\u003e defines a thread\n context which is used to gather values from all the threads of the\n program. The values to be gathered must be instances of the\n \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.ThreadContext.MonoidTC",
          "name": "MonoidTC",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-ThreadContext-MonoidTC.html",
          "type": "module"
        },
        "index": {
          "description": "MonoidTC defines thread context which is used to gather values from all the threads of the program The values to be gathered must be instances of the Monoid class",
          "hierarchy": "Control Monad MultiPass ThreadContext MonoidTC",
          "module": "Control.Monad.MultiPass.ThreadContext.MonoidTC",
          "name": "MonoidTC",
          "package": "Control-Monad-MultiPass",
          "partial": "Monoid TC",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-MonoidTC.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonoidTC is a thread context which uses the Monoid interface to\n combine the values from multiple threads. Instances of the Monoid\n class are expected to be associative, so the value computed by\n MonoidTC is invariant under changes to the number of threads that\n are spawned.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.ThreadContext.MonoidTC",
          "name": "MonoidTC",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-ThreadContext-MonoidTC.html#MonoidTC",
          "type": "newtype"
        },
        "index": {
          "description": "MonoidTC is thread context which uses the Monoid interface to combine the values from multiple threads Instances of the Monoid class are expected to be associative so the value computed by MonoidTC is invariant under changes to the number of threads that are spawned",
          "hierarchy": "Control Monad MultiPass ThreadContext MonoidTC",
          "module": "Control.Monad.MultiPass.ThreadContext.MonoidTC",
          "name": "MonoidTC",
          "package": "Control-Monad-MultiPass",
          "partial": "Monoid TC",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-MonoidTC.html#t:MonoidTC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.ThreadContext.MonoidTC",
          "name": "MonoidTC",
          "package": "Control-Monad-MultiPass",
          "signature": "MonoidTC",
          "source": "src/Control-Monad-MultiPass-ThreadContext-MonoidTC.html#MonoidTC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass ThreadContext MonoidTC",
          "module": "Control.Monad.MultiPass.ThreadContext.MonoidTC",
          "name": "MonoidTC",
          "package": "Control-Monad-MultiPass",
          "partial": "Monoid TC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-MonoidTC.html#v:MonoidTC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass.ThreadContext.MonoidTC",
          "name": "unwrapMonoidTC",
          "package": "Control-Monad-MultiPass",
          "signature": "a",
          "source": "src/Control-Monad-MultiPass-ThreadContext-MonoidTC.html#MonoidTC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass ThreadContext MonoidTC",
          "module": "Control.Monad.MultiPass.ThreadContext.MonoidTC",
          "name": "unwrapMonoidTC",
          "package": "Control-Monad-MultiPass",
          "partial": "Monoid TC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-ThreadContext-MonoidTC.html#v:unwrapMonoidTC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFor every new instrument, a number of class instances need to be\ndefined, such as \u003ccode\u003e\u003ca\u003eNextGlobalContext\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eNextThreadContext\u003c/a\u003e\u003c/code\u003e. The\ntests in this module are used to check that all the necessary\ninstances have been defined. Each test defines a trivial algorithm,\nparameterised by an instrument of a specific arity. For example,\n\u003ccode\u003e\u003ca\u003etestInstrument3\u003c/a\u003e\u003c/code\u003e is parameterised by a three-pass instrument. The\ntest is used as follows:\n\u003c/p\u003e\u003cpre\u003e instanceTest :: ST2 r w ()\n instanceTest = run instanceTestBody\n\n instanceTestBody :: TestInstrument3 (MyInstrument r w) r w\n instanceTestBody = testInstrument3\n\u003c/pre\u003e\u003cp\u003eIf this code does not cause any compiler errors, then all the\nnecessary instances have been defined for \u003ccode\u003eMyInstrument\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "InstanceTest",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Utils-InstanceTest.html",
          "type": "module"
        },
        "index": {
          "description": "For every new instrument number of class instances need to be defined such as NextGlobalContext and NextThreadContext The tests in this module are used to check that all the necessary instances have been defined Each test defines trivial algorithm parameterised by an instrument of specific arity For example testInstrument3 is parameterised by three-pass instrument The test is used as follows instanceTest ST2 instanceTest run instanceTestBody instanceTestBody TestInstrument3 MyInstrument instanceTestBody testInstrument3 If this code does not cause any compiler errors then all the necessary instances have been defined for MyInstrument",
          "hierarchy": "Control Monad MultiPass Utils InstanceTest",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "InstanceTest",
          "package": "Control-Monad-MultiPass",
          "partial": "Instance Test",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils-InstanceTest.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest type for a one-pass instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "TestInstrument1",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Utils-InstanceTest.html#TestInstrument1",
          "type": "type"
        },
        "index": {
          "description": "Test type for one-pass instrument",
          "hierarchy": "Control Monad MultiPass Utils InstanceTest",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "TestInstrument1",
          "package": "Control-Monad-MultiPass",
          "partial": "Test Instrument",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils-InstanceTest.html#t:TestInstrument1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest type for a two-pass instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "TestInstrument2",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Utils-InstanceTest.html#TestInstrument2",
          "type": "type"
        },
        "index": {
          "description": "Test type for two-pass instrument",
          "hierarchy": "Control Monad MultiPass Utils InstanceTest",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "TestInstrument2",
          "package": "Control-Monad-MultiPass",
          "partial": "Test Instrument",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils-InstanceTest.html#t:TestInstrument2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest type for a three-pass instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "TestInstrument3",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Utils-InstanceTest.html#TestInstrument3",
          "type": "type"
        },
        "index": {
          "description": "Test type for three-pass instrument",
          "hierarchy": "Control Monad MultiPass Utils InstanceTest",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "TestInstrument3",
          "package": "Control-Monad-MultiPass",
          "partial": "Test Instrument",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils-InstanceTest.html#t:TestInstrument3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest type for a four-pass instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "TestInstrument4",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Utils-InstanceTest.html#TestInstrument4",
          "type": "type"
        },
        "index": {
          "description": "Test type for four-pass instrument",
          "hierarchy": "Control Monad MultiPass Utils InstanceTest",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "TestInstrument4",
          "package": "Control-Monad-MultiPass",
          "partial": "Test Instrument",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils-InstanceTest.html#t:TestInstrument4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest function for a one-pass instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "testInstrument1",
          "package": "Control-Monad-MultiPass",
          "signature": "TestInstrument1 f r w",
          "source": "src/Control-Monad-MultiPass-Utils-InstanceTest.html#testInstrument1",
          "type": "function"
        },
        "index": {
          "description": "Test function for one-pass instrument",
          "hierarchy": "Control Monad MultiPass Utils InstanceTest",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "testInstrument1",
          "package": "Control-Monad-MultiPass",
          "partial": "Instrument",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils-InstanceTest.html#v:testInstrument1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest function for a two-pass instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "testInstrument2",
          "package": "Control-Monad-MultiPass",
          "signature": "TestInstrument2 f r w",
          "source": "src/Control-Monad-MultiPass-Utils-InstanceTest.html#testInstrument2",
          "type": "function"
        },
        "index": {
          "description": "Test function for two-pass instrument",
          "hierarchy": "Control Monad MultiPass Utils InstanceTest",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "testInstrument2",
          "package": "Control-Monad-MultiPass",
          "partial": "Instrument",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils-InstanceTest.html#v:testInstrument2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest function for a three-pass instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "testInstrument3",
          "package": "Control-Monad-MultiPass",
          "signature": "TestInstrument3 f r w",
          "source": "src/Control-Monad-MultiPass-Utils-InstanceTest.html#testInstrument3",
          "type": "function"
        },
        "index": {
          "description": "Test function for three-pass instrument",
          "hierarchy": "Control Monad MultiPass Utils InstanceTest",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "testInstrument3",
          "package": "Control-Monad-MultiPass",
          "partial": "Instrument",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils-InstanceTest.html#v:testInstrument3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest function for a four-pass instrument.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "testInstrument4",
          "package": "Control-Monad-MultiPass",
          "signature": "TestInstrument4 f r w",
          "source": "src/Control-Monad-MultiPass-Utils-InstanceTest.html#testInstrument4",
          "type": "function"
        },
        "index": {
          "description": "Test function for four-pass instrument",
          "hierarchy": "Control Monad MultiPass Utils InstanceTest",
          "module": "Control.Monad.MultiPass.Utils.InstanceTest",
          "name": "testInstrument4",
          "package": "Control-Monad-MultiPass",
          "partial": "Instrument",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils-InstanceTest.html#v:testInstrument4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUtility functions for working with the \u003ccode\u003e\u003ca\u003eUpdateThreadContext\u003c/a\u003e\u003c/code\u003e\nargument of \u003ccode\u003e\u003ca\u003ecreateInstrument\u003c/a\u003e\u003c/code\u003e. This module is only relevant for\nInstrument authoring.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Utils.UpdateCtx",
          "name": "UpdateCtx",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Utils-UpdateCtx.html",
          "type": "module"
        },
        "index": {
          "description": "Utility functions for working with the UpdateThreadContext argument of createInstrument This module is only relevant for Instrument authoring",
          "hierarchy": "Control Monad MultiPass Utils UpdateCtx",
          "module": "Control.Monad.MultiPass.Utils.UpdateCtx",
          "name": "UpdateCtx",
          "package": "Control-Monad-MultiPass",
          "partial": "Update Ctx",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils-UpdateCtx.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the thread context is a pair then \u003ccode\u003e\u003ca\u003eupdateCtxFst\u003c/a\u003e\u003c/code\u003e creates a new\n \u003ccode\u003e\u003ca\u003eUpdateThreadContext\u003c/a\u003e\u003c/code\u003e function which can be used to update the\n first element of the pair.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils.UpdateCtx",
          "name": "updateCtxFst",
          "package": "Control-Monad-MultiPass",
          "signature": "UpdateThreadContext rootTC (x, y) -\u003e UpdateThreadContext rootTC x",
          "source": "src/Control-Monad-MultiPass-Utils-UpdateCtx.html#updateCtxFst",
          "type": "function"
        },
        "index": {
          "description": "If the thread context is pair then updateCtxFst creates new UpdateThreadContext function which can be used to update the first element of the pair",
          "hierarchy": "Control Monad MultiPass Utils UpdateCtx",
          "module": "Control.Monad.MultiPass.Utils.UpdateCtx",
          "name": "updateCtxFst",
          "normalized": "UpdateThreadContext a(b,c)-\u003eUpdateThreadContext a b",
          "package": "Control-Monad-MultiPass",
          "partial": "Ctx Fst",
          "signature": "UpdateThreadContext rootTC(x,y)-\u003eUpdateThreadContext rootTC x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils-UpdateCtx.html#v:updateCtxFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the thread context is an Either of two thread contexts then\n \u003ccode\u003e\u003ca\u003eupdateCtxLeft\u003c/a\u003e\u003c/code\u003e creates a new \u003ccode\u003e\u003ca\u003eUpdateThreadContext\u003c/a\u003e\u003c/code\u003e function which\n can be used to update the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e element. This function will assert\n if the thread context is a \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e element.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils.UpdateCtx",
          "name": "updateCtxLeft",
          "package": "Control-Monad-MultiPass",
          "signature": "UpdateThreadContext rootTC (Either x y) -\u003e UpdateThreadContext rootTC x",
          "source": "src/Control-Monad-MultiPass-Utils-UpdateCtx.html#updateCtxLeft",
          "type": "function"
        },
        "index": {
          "description": "If the thread context is an Either of two thread contexts then updateCtxLeft creates new UpdateThreadContext function which can be used to update the Left element This function will assert if the thread context is Right element",
          "hierarchy": "Control Monad MultiPass Utils UpdateCtx",
          "module": "Control.Monad.MultiPass.Utils.UpdateCtx",
          "name": "updateCtxLeft",
          "normalized": "UpdateThreadContext a(Either b c)-\u003eUpdateThreadContext a b",
          "package": "Control-Monad-MultiPass",
          "partial": "Ctx Left",
          "signature": "UpdateThreadContext rootTC(Either x y)-\u003eUpdateThreadContext rootTC x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils-UpdateCtx.html#v:updateCtxLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the thread context is an Either of two thread contexts then\n \u003ccode\u003e\u003ca\u003eupdateCtxRight\u003c/a\u003e\u003c/code\u003e creates a new \u003ccode\u003e\u003ca\u003eUpdateThreadContext\u003c/a\u003e\u003c/code\u003e function which\n can be used to update the \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e element. This function will assert\n if the thread context is a \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e element.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils.UpdateCtx",
          "name": "updateCtxRight",
          "package": "Control-Monad-MultiPass",
          "signature": "UpdateThreadContext rootTC (Either x y) -\u003e UpdateThreadContext rootTC y",
          "source": "src/Control-Monad-MultiPass-Utils-UpdateCtx.html#updateCtxRight",
          "type": "function"
        },
        "index": {
          "description": "If the thread context is an Either of two thread contexts then updateCtxRight creates new UpdateThreadContext function which can be used to update the Right element This function will assert if the thread context is Left element",
          "hierarchy": "Control Monad MultiPass Utils UpdateCtx",
          "module": "Control.Monad.MultiPass.Utils.UpdateCtx",
          "name": "updateCtxRight",
          "normalized": "UpdateThreadContext a(Either b c)-\u003eUpdateThreadContext a c",
          "package": "Control-Monad-MultiPass",
          "partial": "Ctx Right",
          "signature": "UpdateThreadContext rootTC(Either x y)-\u003eUpdateThreadContext rootTC y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils-UpdateCtx.html#v:updateCtxRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the thread context is a pair then \u003ccode\u003e\u003ca\u003eupdateCtxSnd\u003c/a\u003e\u003c/code\u003e creates a new\n \u003ccode\u003e\u003ca\u003eUpdateThreadContext\u003c/a\u003e\u003c/code\u003e function which can be used to update the\n second element of the pair.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils.UpdateCtx",
          "name": "updateCtxSnd",
          "package": "Control-Monad-MultiPass",
          "signature": "UpdateThreadContext rootTC (x, y) -\u003e UpdateThreadContext rootTC y",
          "source": "src/Control-Monad-MultiPass-Utils-UpdateCtx.html#updateCtxSnd",
          "type": "function"
        },
        "index": {
          "description": "If the thread context is pair then updateCtxSnd creates new UpdateThreadContext function which can be used to update the second element of the pair",
          "hierarchy": "Control Monad MultiPass Utils UpdateCtx",
          "module": "Control.Monad.MultiPass.Utils.UpdateCtx",
          "name": "updateCtxSnd",
          "normalized": "UpdateThreadContext a(b,c)-\u003eUpdateThreadContext a c",
          "package": "Control-Monad-MultiPass",
          "partial": "Ctx Snd",
          "signature": "UpdateThreadContext rootTC(x,y)-\u003eUpdateThreadContext rootTC y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils-UpdateCtx.html#v:updateCtxSnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUtility functions for the \u003ca\u003eControl.Monad.MultiPass\u003c/a\u003e library.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass.Utils",
          "name": "Utils",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass-Utils.html",
          "type": "module"
        },
        "index": {
          "description": "Utility functions for the Control.Monad.MultiPass library",
          "hierarchy": "Control Monad MultiPass Utils",
          "module": "Control.Monad.MultiPass.Utils",
          "name": "Utils",
          "package": "Control-Monad-MultiPass",
          "partial": "Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function provides a similar interface to\n \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e, but is specifically for mapping over the\n \u003ccode\u003e\u003ca\u003eST2Array\u003c/a\u003e\u003c/code\u003e datatype in the \u003ccode\u003e\u003ca\u003eMultiPass\u003c/a\u003e\u003c/code\u003e\n monad.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils",
          "name": "mapST2ArrayMP",
          "package": "Control-Monad-MultiPass",
          "signature": "NumThreads-\u003e ST2Array r w i a-\u003e (a -\u003e MultiPass r w tc b)-\u003e MultiPass r w tc (ST2Array r w i b)",
          "type": "function"
        },
        "index": {
          "description": "This function provides similar interface to mapM but is specifically for mapping over the ST2Array datatype in the MultiPass monad",
          "hierarchy": "Control Monad MultiPass Utils",
          "module": "Control.Monad.MultiPass.Utils",
          "name": "mapST2ArrayMP",
          "normalized": "NumThreads-\u003eST Array a b c d-\u003e(d-\u003eMultiPass a b e f)-\u003eMultiPass a b e(ST Array a b c f)",
          "package": "Control-Monad-MultiPass",
          "partial": "ST Array MP",
          "signature": "NumThreads-\u003eST Array r w i a-\u003e(a-\u003eMultiPass r w tc b)-\u003eMultiPass r w tc(ST Array r w i b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils.html#v:mapST2ArrayMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function provides a similar interface to\n \u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e, but is specifically for mapping over the\n \u003ccode\u003e\u003ca\u003eST2Array\u003c/a\u003e\u003c/code\u003e datatype in the \u003ccode\u003e\u003ca\u003eMultiPass\u003c/a\u003e\u003c/code\u003e\n monad.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils",
          "name": "mapST2ArrayMP_",
          "package": "Control-Monad-MultiPass",
          "signature": "NumThreads-\u003e ST2Array r w i a-\u003e (a -\u003e MultiPass r w tc b)-\u003e MultiPass r w tc ()",
          "type": "function"
        },
        "index": {
          "description": "This function provides similar interface to mapM but is specifically for mapping over the ST2Array datatype in the MultiPass monad",
          "hierarchy": "Control Monad MultiPass Utils",
          "module": "Control.Monad.MultiPass.Utils",
          "name": "mapST2ArrayMP_",
          "normalized": "NumThreads-\u003eST Array a b c d-\u003e(d-\u003eMultiPass a b e f)-\u003eMultiPass a b e()",
          "package": "Control-Monad-MultiPass",
          "partial": "ST Array MP",
          "signature": "NumThreads-\u003eST Array r w i a-\u003e(a-\u003eMultiPass r w tc b)-\u003eMultiPass r w tc()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils.html#v:mapST2ArrayMP_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function provides a similar interface to\n \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e, but is useful for mapping over a datatype in\n a specific pass of the \u003ccode\u003e\u003ca\u003eMultiPass\u003c/a\u003e\u003c/code\u003e monad.\n Note: the \u003ccode\u003em\u003c/code\u003e type is usually the\n \u003ccode\u003e\u003ca\u003eMultiPass\u003c/a\u003e\u003c/code\u003e monad, but the implementation\n does not specifically depend on anything from the\n \u003ca\u003eControl.Monad.MultiPass\u003c/a\u003e library, so its type is more general.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass.Utils",
          "name": "pmapM",
          "package": "Control-Monad-MultiPass",
          "signature": "t a -\u003e (a -\u003e m (p b)) -\u003e m (p (t b))",
          "source": "src/Control-Monad-MultiPass-Utils.html#pmapM",
          "type": "function"
        },
        "index": {
          "description": "This function provides similar interface to mapM but is useful for mapping over datatype in specific pass of the MultiPass monad Note the type is usually the MultiPass monad but the implementation does not specifically depend on anything from the Control.Monad.MultiPass library so its type is more general",
          "hierarchy": "Control Monad MultiPass Utils",
          "module": "Control.Monad.MultiPass.Utils",
          "name": "pmapM",
          "normalized": "a b-\u003e(b-\u003ec(d e))-\u003ec(d(a e))",
          "package": "Control-Monad-MultiPass",
          "signature": "t a-\u003e(a-\u003em(p b))-\u003em(p(t b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass-Utils.html#v:pmapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module implements the core functions, datatypes, and classes of\nthe MultiPass library. Its export list is divided into two halves. The\nfirst half contains the declarations which are relevant to anyone who\nwants to use the MultiPass library. The second contains which are only\nrelevant to people who want to implement new instruments.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "MultiPass",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html",
          "type": "module"
        },
        "index": {
          "description": "This module implements the core functions datatypes and classes of the MultiPass library Its export list is divided into two halves The first half contains the declarations which are relevant to anyone who wants to use the MultiPass library The second contains which are only relevant to people who want to implement new instruments",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "MultiPass",
          "package": "Control-Monad-MultiPass",
          "partial": "Multi Pass",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery instrument must define an instance of this class for each\n of its passes. It is used to tell the evaluator whether it needs to\n back-track. Instruments which do not back-track should use the\n default implementation of backtrack which returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e (which\n means that no back-tracking is necessary.) If more than one\n instrument requests that the evaluator back-tracks then the\n evaluator will back-track to the earliest of the requested passes.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "BackTrack",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#BackTrack",
          "type": "class"
        },
        "index": {
          "description": "Every instrument must define an instance of this class for each of its passes It is used to tell the evaluator whether it needs to back-track Instruments which do not back-track should use the default implementation of backtrack which returns Nothing which means that no back-tracking is necessary If more than one instrument requests that the evaluator back-tracks then the evaluator will back-track to the earliest of the requested passes",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "BackTrack",
          "package": "Control-Monad-MultiPass",
          "partial": "Back Track",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:BackTrack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery instrument must define an instance of this class for each of its\npasses. For example, the\n\u003ccode\u003e\u003ca\u003eCounter\u003c/a\u003e\u003c/code\u003e instrument\ndefines the following instances:\n\u003c/p\u003e\u003cpre\u003e instance Instrument tc () () () (Counter i r w Off Off tc)\n\n instance Num i =\u003e\n          Instrument tc (CounterTC1 i r) () (Counter i r w On Off tc)\n\n instance Num i =\u003e\n          Instrument tc (CounterTC2 i r) () (Counter i r w On On tc)\n\u003c/pre\u003e\u003cp\u003eThe functional dependency from \u003ccode\u003einstr\u003c/code\u003e to \u003ccode\u003etc\u003c/code\u003e and \u003ccode\u003egc\u003c/code\u003e enables the\n\u003ccode\u003e\u003ca\u003erun\u003c/a\u003e\u003c/code\u003e function to automatically deduce the type of the thread context\nand global context for each pass.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "Instrument",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#Instrument",
          "type": "class"
        },
        "index": {
          "description": "Every instrument must define an instance of this class for each of its passes For example the Counter instrument defines the following instances instance Instrument tc Counter Off Off tc instance Num Instrument tc CounterTC1 Counter On Off tc instance Num Instrument tc CounterTC2 Counter On On tc The functional dependency from instr to tc and gc enables the run function to automatically deduce the type of the thread context and global context for each pass",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "Instrument",
          "package": "Control-Monad-MultiPass",
          "partial": "Instrument",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:Instrument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis monad is used to implement the body of a multi-pass\n algorithm.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "MultiPass",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#MultiPass",
          "type": "data"
        },
        "index": {
          "description": "This monad is used to implement the body of multi-pass algorithm",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "MultiPass",
          "package": "Control-Monad-MultiPass",
          "partial": "Multi Pass",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:MultiPass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe main function of a multi-pass algorithm needs to be wrapped\n in a newtype so that it can be packaged with \u003ccode\u003e\u003ca\u003ePassS\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003ePassZ\u003c/a\u003e\u003c/code\u003e. The newtype needs to be made an instance of\n \u003ccode\u003e\u003ca\u003eMultiPassAlgorithm\u003c/a\u003e\u003c/code\u003e so that it can unwrapped by the\n implementation.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "MultiPassAlgorithm",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#MultiPassAlgorithm",
          "type": "class"
        },
        "index": {
          "description": "The main function of multi-pass algorithm needs to be wrapped in newtype so that it can be packaged with PassS and PassZ The newtype needs to be made an instance of MultiPassAlgorithm so that it can unwrapped by the implementation",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "MultiPassAlgorithm",
          "package": "Control-Monad-MultiPass",
          "partial": "Multi Pass Algorithm",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:MultiPassAlgorithm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eMultiPass\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eMultiPassPrologue\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eMultiPassEpilogue\u003c/a\u003e\u003c/code\u003e are\n trivial newtype wrappers around this monad. Instruments can\n construct computations in the \u003ccode\u003e\u003ca\u003eMultiPassBase\u003c/a\u003e\u003c/code\u003e monad, but then use\n \u003ccode\u003e\u003ca\u003emkMultiPass\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003emkMultiPassPrologue\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003emkMultiPassEpilogue\u003c/a\u003e\u003c/code\u003e to\n restrict which of the three stages it is allowed to be used in.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "MultiPassBase",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#MultiPassBase",
          "type": "data"
        },
        "index": {
          "description": "MultiPass MultiPassPrologue and MultiPassEpilogue are trivial newtype wrappers around this monad Instruments can construct computations in the MultiPassBase monad but then use mkMultiPass mkMultiPassPrologue and mkMultiPassEpilogue to restrict which of the three stages it is allowed to be used in",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "MultiPassBase",
          "package": "Control-Monad-MultiPass",
          "partial": "Multi Pass Base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:MultiPassBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis monad is used to implement the epilogue of a multi-pass\n algorithm.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "MultiPassEpilogue",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#MultiPassEpilogue",
          "type": "data"
        },
        "index": {
          "description": "This monad is used to implement the epilogue of multi-pass algorithm",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "MultiPassEpilogue",
          "package": "Control-Monad-MultiPass",
          "partial": "Multi Pass Epilogue",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:MultiPassEpilogue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eMultiPassMain\u003c/a\u003e\u003c/code\u003e is an abstract datatype containing the prologue,\n body, and epilogue of a multi-pass algorithm. Use\n \u003ccode\u003e\u003ca\u003emkMultiPassMain\u003c/a\u003e\u003c/code\u003e to construct an object of type \u003ccode\u003e\u003ca\u003eMultiPassMain\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "MultiPassMain",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#MultiPassMain",
          "type": "data"
        },
        "index": {
          "description": "MultiPassMain is an abstract datatype containing the prologue body and epilogue of multi-pass algorithm Use mkMultiPassMain to construct an object of type MultiPassMain",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "MultiPassMain",
          "package": "Control-Monad-MultiPass",
          "partial": "Multi Pass Main",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:MultiPassMain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis monad is used to implement the prologue of a multi-pass\n algorithm.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "MultiPassPrologue",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#MultiPassPrologue",
          "type": "data"
        },
        "index": {
          "description": "This monad is used to implement the prologue of multi-pass algorithm",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "MultiPassPrologue",
          "package": "Control-Monad-MultiPass",
          "partial": "Multi Pass Prologue",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:MultiPassPrologue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class is used to create the next global context when the\n multi-pass algorithm proceeds to the next pass or back-tracks to\n the previous pass.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "NextGlobalContext",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#NextGlobalContext",
          "type": "class"
        },
        "index": {
          "description": "This class is used to create the next global context when the multi-pass algorithm proceeds to the next pass or back-tracks to the previous pass",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "NextGlobalContext",
          "package": "Control-Monad-MultiPass",
          "partial": "Next Global Context",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:NextGlobalContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class is used to create the next thread context when the\n multi-pass algorithm proceeds to the next pass or back-tracks to\n the previous pass.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "NextThreadContext",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#NextThreadContext",
          "type": "class"
        },
        "index": {
          "description": "This class is used to create the next thread context when the multi-pass algorithm proceeds to the next pass or back-tracks to the previous pass",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "NextThreadContext",
          "package": "Control-Monad-MultiPass",
          "partial": "Next Thread Context",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:NextThreadContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eNumThreads\u003c/a\u003e\u003c/code\u003e is used to specify the number of threads in\n \u003ccode\u003e\u003ca\u003eparallelMP\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eparallelMP_\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "NumThreads",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#NumThreads",
          "type": "newtype"
        },
        "index": {
          "description": "NumThreads is used to specify the number of threads in parallelMP and parallelMP",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "NumThreads",
          "package": "Control-Monad-MultiPass",
          "partial": "Num Threads",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:NumThreads"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrivial monad which computes absolutely nothing. It is used to\n switch off a pass of a multi-pass algorithm.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "Off",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#Off",
          "type": "data"
        },
        "index": {
          "description": "Trivial monad which computes absolutely nothing It is used to switch off pass of multi-pass algorithm",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "Off",
          "package": "Control-Monad-MultiPass",
          "partial": "Off",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:Off"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrivial monad, equivalent to \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e.\n Used to switch on a pass of a multi-pass algorithm.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "On",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#On",
          "type": "newtype"
        },
        "index": {
          "description": "Trivial monad equivalent to Identity Used to switch on pass of multi-pass algorithm",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "On",
          "package": "Control-Monad-MultiPass",
          "partial": "On",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:On"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis datatype is used by the back-tracking mechanism. Instruments\n can request that the evaluator back-tracks to a specific pass\n number. Instruments which use back-tracking store the relevant\n PassNumbers in their global context. The current \u003ccode\u003e\u003ca\u003ePassNumber\u003c/a\u003e\u003c/code\u003e is\n the first argument of \u003ccode\u003e\u003ca\u003enextGlobalContext\u003c/a\u003e\u003c/code\u003e for this\n purpose. \u003ccode\u003e\u003ca\u003ePassNumber\u003c/a\u003e\u003c/code\u003e is an abstract datatype. Instruments should\n never need to create a new \u003ccode\u003e\u003ca\u003ePassNumber\u003c/a\u003e\u003c/code\u003e or modify an existing one,\n so no functions that operate on \u003ccode\u003e\u003ca\u003ePassNumber\u003c/a\u003e\u003c/code\u003e are exported from this\n module.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "PassNumber",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#PassNumber",
          "type": "data"
        },
        "index": {
          "description": "This datatype is used by the back-tracking mechanism Instruments can request that the evaluator back-tracks to specific pass number Instruments which use back-tracking store the relevant PassNumbers in their global context The current PassNumber is the first argument of nextGlobalContext for this purpose PassNumber is an abstract datatype Instruments should never need to create new PassNumber or modify an existing one so no functions that operate on PassNumber are exported from this module",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "PassNumber",
          "package": "Control-Monad-MultiPass",
          "partial": "Pass Number",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:PassNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis datatype is used in conjunction with \u003ccode\u003e\u003ca\u003ePassZ\u003c/a\u003e\u003c/code\u003e to package the\n main function of the multi-pass algorithm. For an example of how\n they are used, see the implementation of\n \u003ccode\u003e\u003ca\u003erepminMP\u003c/a\u003e\u003c/code\u003e or any of the\n other examples in the Example directory.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "PassS",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#PassS",
          "type": "newtype"
        },
        "index": {
          "description": "This datatype is used in conjunction with PassZ to package the main function of the multi-pass algorithm For an example of how they are used see the implementation of repminMP or any of the other examples in the Example directory",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "PassS",
          "package": "Control-Monad-MultiPass",
          "partial": "Pass",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:PassS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in conjunction with \u003ccode\u003e\u003ca\u003ePassS\u003c/a\u003e\u003c/code\u003e to build a Peano number\n corresponding to the number of passes.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "PassZ",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#PassZ",
          "type": "newtype"
        },
        "index": {
          "description": "Used in conjunction with PassS to build Peano number corresponding to the number of passes",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "PassZ",
          "package": "Control-Monad-MultiPass",
          "partial": "Pass",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:PassZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of the first argument of \u003ccode\u003e\u003ca\u003ecreateInstrument\u003c/a\u003e\u003c/code\u003e. It enables\n instruments to run \u003ccode\u003e\u003ca\u003eST2\u003c/a\u003e\u003c/code\u003e in the \u003ccode\u003e\u003ca\u003eMultiPassBase\u003c/a\u003e\u003c/code\u003e monad. (Clearly the\n \u003ccode\u003est2ToMP\u003c/code\u003e argument needs to be used with care.)\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "ST2ToMP",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#ST2ToMP",
          "type": "type"
        },
        "index": {
          "description": "The type of the first argument of createInstrument It enables instruments to run ST2 in the MultiPassBase monad Clearly the st2ToMP argument needs to be used with care",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "ST2ToMP",
          "package": "Control-Monad-MultiPass",
          "partial": "ST To MP",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:ST2ToMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis datatype is used by the \u003ccode\u003e\u003ca\u003eNextThreadContext\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eNextGlobalContext\u003c/a\u003e\u003c/code\u003e classes to specify whether the algorithm is\n progressing to the next pass or back-tracking to a previous\n pass. When back-tracking occurs, the current thread and global\n contexts are first passed the \u003ccode\u003e\u003ca\u003eStepReset\u003c/a\u003e\u003c/code\u003e command. Then they are\n passed the \u003ccode\u003e\u003ca\u003eStepBackward\u003c/a\u003e\u003c/code\u003e command \u003ccode\u003eN\u003c/code\u003e times, where \u003ccode\u003eN\u003c/code\u003e is the\n number of passes that need to be revisited. Note that \u003ccode\u003eN\u003c/code\u003e can be\n zero if only the current pass needs to be revisited, so the\n \u003ccode\u003e\u003ca\u003eStepBackward\u003c/a\u003e\u003c/code\u003e command may not be used. This is the reason why the\n \u003ccode\u003e\u003ca\u003eStepReset\u003c/a\u003e\u003c/code\u003e command is always issued first.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "StepDirection",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#StepDirection",
          "type": "data"
        },
        "index": {
          "description": "This datatype is used by the NextThreadContext and NextGlobalContext classes to specify whether the algorithm is progressing to the next pass or back-tracking to previous pass When back-tracking occurs the current thread and global contexts are first passed the StepReset command Then they are passed the StepBackward command times where is the number of passes that need to be revisited Note that can be zero if only the current pass needs to be revisited so the StepBackward command may not be used This is the reason why the StepReset command is always issued first",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "StepDirection",
          "package": "Control-Monad-MultiPass",
          "partial": "Step Direction",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:StepDirection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class is used when multiple threads are\n spawned. \u003ccode\u003e\u003ca\u003esplitThreadContext\u003c/a\u003e\u003c/code\u003e is used to create a new thread\n context for each of the new threads and \u003ccode\u003e\u003ca\u003emergeThreadContext\u003c/a\u003e\u003c/code\u003e is\n used to merge them back together when the parallel region ends.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "ThreadContext",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#ThreadContext",
          "type": "class"
        },
        "index": {
          "description": "This class is used when multiple threads are spawned splitThreadContext is used to create new thread context for each of the new threads and mergeThreadContext is used to merge them back together when the parallel region ends",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "ThreadContext",
          "package": "Control-Monad-MultiPass",
          "partial": "Thread Context",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:ThreadContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of the first argument of \u003ccode\u003e\u003ca\u003ecreateInstrument\u003c/a\u003e\u003c/code\u003e. It used to\n read and write the thread context.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "UpdateThreadContext",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#UpdateThreadContext",
          "type": "type"
        },
        "index": {
          "description": "The type of the first argument of createInstrument It used to read and write the thread context",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "UpdateThreadContext",
          "package": "Control-Monad-MultiPass",
          "partial": "Update Thread Context",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:UpdateThreadContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis abstract datatype is used as the result type of\n createInstrument. Instrument authors can create it using the\n \u003ccode\u003e\u003ca\u003ewrapInstrument\u003c/a\u003e\u003c/code\u003e function, but cannot unwrap it. This ensures that\n instruments can only be constructed by the \u003ca\u003eControl.Monad.MultiPass\u003c/a\u003e\n library.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "WrapInstrument",
          "package": "Control-Monad-MultiPass",
          "source": "src/Control-Monad-MultiPass.html#WrapInstrument",
          "type": "data"
        },
        "index": {
          "description": "This abstract datatype is used as the result type of createInstrument Instrument authors can create it using the wrapInstrument function but cannot unwrap it This ensures that instruments can only be constructed by the Control.Monad.MultiPass library",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "WrapInstrument",
          "package": "Control-Monad-MultiPass",
          "partial": "Wrap Instrument",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#t:WrapInstrument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "NumThreads",
          "package": "Control-Monad-MultiPass",
          "signature": "NumThreads Int",
          "source": "src/Control-Monad-MultiPass.html#NumThreads",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "NumThreads",
          "package": "Control-Monad-MultiPass",
          "partial": "Num Threads",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:NumThreads"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "Off",
          "package": "Control-Monad-MultiPass",
          "signature": "Off",
          "source": "src/Control-Monad-MultiPass.html#Off",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "Off",
          "package": "Control-Monad-MultiPass",
          "partial": "Off",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:Off"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "On",
          "package": "Control-Monad-MultiPass",
          "signature": "On a",
          "source": "src/Control-Monad-MultiPass.html#On",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "On",
          "package": "Control-Monad-MultiPass",
          "partial": "On",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:On"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "PassS",
          "package": "Control-Monad-MultiPass",
          "signature": "cont (m p))",
          "source": "src/Control-Monad-MultiPass.html#PassS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "PassS",
          "package": "Control-Monad-MultiPass",
          "partial": "Pass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:PassS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "PassZ",
          "package": "Control-Monad-MultiPass",
          "signature": "PassZ (forall tc.  f tc)",
          "source": "src/Control-Monad-MultiPass.html#PassZ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "PassZ",
          "package": "Control-Monad-MultiPass",
          "partial": "Pass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:PassZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "StepBackward",
          "package": "Control-Monad-MultiPass",
          "signature": "StepBackward",
          "source": "src/Control-Monad-MultiPass.html#StepDirection",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "StepBackward",
          "package": "Control-Monad-MultiPass",
          "partial": "Step Backward",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:StepBackward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "StepForward",
          "package": "Control-Monad-MultiPass",
          "signature": "StepForward",
          "source": "src/Control-Monad-MultiPass.html#StepDirection",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "StepForward",
          "package": "Control-Monad-MultiPass",
          "partial": "Step Forward",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:StepForward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "StepReset",
          "package": "Control-Monad-MultiPass",
          "signature": "StepReset",
          "source": "src/Control-Monad-MultiPass.html#StepDirection",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "StepReset",
          "package": "Control-Monad-MultiPass",
          "partial": "Step Reset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:StepReset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "backtrack",
          "package": "Control-Monad-MultiPass",
          "signature": "tc -\u003e gc -\u003e ST2 r w (Maybe PassNumber)",
          "source": "src/Control-Monad-MultiPass.html#backtrack",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "backtrack",
          "normalized": "a-\u003eb-\u003eST c d(Maybe PassNumber)",
          "package": "Control-Monad-MultiPass",
          "signature": "tc-\u003egc-\u003eST r w(Maybe PassNumber)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:backtrack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "createInstrument",
          "package": "Control-Monad-MultiPass",
          "signature": "createInstrument",
          "source": "src/Control-Monad-MultiPass.html#createInstrument",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "createInstrument",
          "package": "Control-Monad-MultiPass",
          "partial": "Instrument",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:createInstrument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "mergeThreadContext",
          "package": "Control-Monad-MultiPass",
          "signature": "Int -\u003e (Int -\u003e ST2 r w tc) -\u003e tc -\u003e ST2 r w tc",
          "source": "src/Control-Monad-MultiPass.html#mergeThreadContext",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "mergeThreadContext",
          "normalized": "Int-\u003e(Int-\u003eST a b c)-\u003ec-\u003eST a b c",
          "package": "Control-Monad-MultiPass",
          "partial": "Thread Context",
          "signature": "Int-\u003e(Int-\u003eST r w tc)-\u003etc-\u003eST r w tc",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:mergeThreadContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRestrict a computation so that it can only be executed during the\n body of the algorithm (not the prologue or epilogue).\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "mkMultiPass",
          "package": "Control-Monad-MultiPass",
          "signature": "MultiPassBase r w tc a -\u003e MultiPass r w tc a",
          "source": "src/Control-Monad-MultiPass.html#mkMultiPass",
          "type": "function"
        },
        "index": {
          "description": "Restrict computation so that it can only be executed during the body of the algorithm not the prologue or epilogue",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "mkMultiPass",
          "normalized": "MultiPassBase a b c d-\u003eMultiPass a b c d",
          "package": "Control-Monad-MultiPass",
          "partial": "Multi Pass",
          "signature": "MultiPassBase r w tc a-\u003eMultiPass r w tc a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:mkMultiPass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRestrict a computation so that it can only be executed during the\n epilogue.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "mkMultiPassEpilogue",
          "package": "Control-Monad-MultiPass",
          "signature": "MultiPassBase r w tc a -\u003e MultiPassEpilogue r w tc a",
          "source": "src/Control-Monad-MultiPass.html#mkMultiPassEpilogue",
          "type": "function"
        },
        "index": {
          "description": "Restrict computation so that it can only be executed during the epilogue",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "mkMultiPassEpilogue",
          "normalized": "MultiPassBase a b c d-\u003eMultiPassEpilogue a b c d",
          "package": "Control-Monad-MultiPass",
          "partial": "Multi Pass Epilogue",
          "signature": "MultiPassBase r w tc a-\u003eMultiPassEpilogue r w tc a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:mkMultiPassEpilogue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine the prologue, body, and epilogue of a multi-pass\n algorithm to create the \u003ccode\u003e\u003ca\u003eMultiPassMain\u003c/a\u003e\u003c/code\u003e object which is required by\n the \u003ccode\u003e\u003ca\u003erun\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "mkMultiPassMain",
          "package": "Control-Monad-MultiPass",
          "signature": "MultiPassPrologue r w tc a-\u003e (a -\u003e MultiPass r w tc b)-\u003e (b -\u003e MultiPassEpilogue r w tc c)-\u003e MultiPassMain r w tc c",
          "type": "function"
        },
        "index": {
          "description": "Combine the prologue body and epilogue of multi-pass algorithm to create the MultiPassMain object which is required by the run function",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "mkMultiPassMain",
          "normalized": "MultiPassPrologue a b c d-\u003e(d-\u003eMultiPass a b c e)-\u003e(e-\u003eMultiPassEpilogue a b c f)-\u003eMultiPassMain a b c f",
          "package": "Control-Monad-MultiPass",
          "partial": "Multi Pass Main",
          "signature": "MultiPassPrologue r w tc a-\u003e(a-\u003eMultiPass r w tc b)-\u003e(b-\u003eMultiPassEpilogue r w tc c)-\u003eMultiPassMain r w tc c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:mkMultiPassMain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRestrict a computation so that it can only be executed during the\n prologue.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "mkMultiPassPrologue",
          "package": "Control-Monad-MultiPass",
          "signature": "MultiPassBase r w tc a -\u003e MultiPassPrologue r w tc a",
          "source": "src/Control-Monad-MultiPass.html#mkMultiPassPrologue",
          "type": "function"
        },
        "index": {
          "description": "Restrict computation so that it can only be executed during the prologue",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "mkMultiPassPrologue",
          "normalized": "MultiPassBase a b c d-\u003eMultiPassPrologue a b c d",
          "package": "Control-Monad-MultiPass",
          "partial": "Multi Pass Prologue",
          "signature": "MultiPassBase r w tc a-\u003eMultiPassPrologue r w tc a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:mkMultiPassPrologue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "nextGlobalContext",
          "package": "Control-Monad-MultiPass",
          "signature": "PassNumber -\u003e StepDirection -\u003e tc -\u003e gc -\u003e ST2 r w gc'",
          "source": "src/Control-Monad-MultiPass.html#nextGlobalContext",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "nextGlobalContext",
          "normalized": "PassNumber-\u003eStepDirection-\u003ea-\u003eb-\u003eST c d e",
          "package": "Control-Monad-MultiPass",
          "partial": "Global Context",
          "signature": "PassNumber-\u003eStepDirection-\u003etc-\u003egc-\u003eST r w gc'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:nextGlobalContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "nextThreadContext",
          "package": "Control-Monad-MultiPass",
          "signature": "PassNumber -\u003e StepDirection -\u003e tc -\u003e gc -\u003e ST2 r w tc'",
          "source": "src/Control-Monad-MultiPass.html#nextThreadContext",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "nextThreadContext",
          "normalized": "PassNumber-\u003eStepDirection-\u003ea-\u003eb-\u003eST c d e",
          "package": "Control-Monad-MultiPass",
          "partial": "Thread Context",
          "signature": "PassNumber-\u003eStepDirection-\u003etc-\u003egc-\u003eST r w tc'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:nextThreadContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse \u003ccode\u003em\u003c/code\u003e threads to run \u003ccode\u003en\u003c/code\u003e instances of the function \u003ccode\u003ef\u003c/code\u003e. The\n results are returned in an array of length \u003ccode\u003en\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "parallelMP",
          "package": "Control-Monad-MultiPass",
          "signature": "NumThreads-\u003e (i, i)-\u003e (i -\u003e MultiPass r w tc a)-\u003e MultiPass r w tc (ST2Array r w i a)",
          "type": "function"
        },
        "index": {
          "description": "Use threads to run instances of the function The results are returned in an array of length",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "parallelMP",
          "normalized": "NumThreads-\u003e(a,a)-\u003e(a-\u003eMultiPass b c d e)-\u003eMultiPass b c d(ST Array b c a e)",
          "package": "Control-Monad-MultiPass",
          "partial": "MP",
          "signature": "NumThreads-\u003e(i,i)-\u003e(i-\u003eMultiPass r w tc a)-\u003eMultiPass r w tc(ST Array r w i a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:parallelMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModified version of \u003ccode\u003e\u003ca\u003eparallelMP\u003c/a\u003e\u003c/code\u003e which discards the result of the\n function, rather than writing it to an array.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "parallelMP_",
          "package": "Control-Monad-MultiPass",
          "signature": "NumThreads-\u003e (i, i)-\u003e (i -\u003e MultiPass r w tc a)-\u003e MultiPass r w tc ()",
          "type": "function"
        },
        "index": {
          "description": "Modified version of parallelMP which discards the result of the function rather than writing it to an array",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "parallelMP_",
          "normalized": "NumThreads-\u003e(a,a)-\u003e(a-\u003eMultiPass b c d e)-\u003eMultiPass b c d()",
          "package": "Control-Monad-MultiPass",
          "partial": "MP",
          "signature": "NumThreads-\u003e(i,i)-\u003e(i-\u003eMultiPass r w tc a)-\u003eMultiPass r w tc()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:parallelMP_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead-only ST2 computations are allowed to be executed in the\n MultiPass monad.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "readOnlyST2ToMP",
          "package": "Control-Monad-MultiPass",
          "signature": "(forall w.  ST2 r w a) -\u003e MultiPass r w' tc a",
          "source": "src/Control-Monad-MultiPass.html#readOnlyST2ToMP",
          "type": "function"
        },
        "index": {
          "description": "Read-only ST2 computations are allowed to be executed in the MultiPass monad",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "readOnlyST2ToMP",
          "normalized": "(a b ST c d e)-\u003eMultiPass c f g e",
          "package": "Control-Monad-MultiPass",
          "partial": "Only ST To MP",
          "signature": "(forall w. ST r w a)-\u003eMultiPass r w' tc a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:readOnlyST2ToMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function is used to run a multi-pass algorithm. Its\n complicated type is mostly an artifact of the internal\n implementation, which uses type classes to generate the code for\n each pass of the algorithm. Therefore, the recommended way to learn\n how to use \u003ccode\u003e\u003ca\u003erun\u003c/a\u003e\u003c/code\u003e is to look at some of the examples in the\n \u003ccode\u003eExample\u003c/code\u003e sub-directory.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "run",
          "package": "Control-Monad-MultiPass",
          "signature": "f -\u003e ST2 r w out",
          "source": "src/Control-Monad-MultiPass.html#run",
          "type": "function"
        },
        "index": {
          "description": "This function is used to run multi-pass algorithm Its complicated type is mostly an artifact of the internal implementation which uses type classes to generate the code for each pass of the algorithm Therefore the recommended way to learn how to use run is to look at some of the examples in the Example sub-directory",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "run",
          "normalized": "a-\u003eST b c d",
          "package": "Control-Monad-MultiPass",
          "signature": "f-\u003eST r w out",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "splitThreadContext",
          "package": "Control-Monad-MultiPass",
          "signature": "Int -\u003e Int -\u003e tc -\u003e ST2 r w tc",
          "source": "src/Control-Monad-MultiPass.html#splitThreadContext",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "splitThreadContext",
          "normalized": "Int-\u003eInt-\u003ea-\u003eST b c a",
          "package": "Control-Monad-MultiPass",
          "partial": "Thread Context",
          "signature": "Int-\u003eInt-\u003etc-\u003eST r w tc",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:splitThreadContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.MultiPass",
          "name": "unwrapMultiPassAlgorithm",
          "package": "Control-Monad-MultiPass",
          "signature": "a -\u003e b",
          "source": "src/Control-Monad-MultiPass.html#unwrapMultiPassAlgorithm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "unwrapMultiPassAlgorithm",
          "normalized": "a-\u003eb",
          "package": "Control-Monad-MultiPass",
          "partial": "Multi Pass Algorithm",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:unwrapMultiPassAlgorithm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an object of type \u003ccode\u003e\u003ca\u003eWrapInstrument\u003c/a\u003e\u003c/code\u003e. It is needed when\n defining a new instance of the \u003ccode\u003e\u003ca\u003eInstrument\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "Control.Monad.MultiPass",
          "name": "wrapInstrument",
          "package": "Control-Monad-MultiPass",
          "signature": "instr -\u003e WrapInstrument instr",
          "source": "src/Control-Monad-MultiPass.html#wrapInstrument",
          "type": "function"
        },
        "index": {
          "description": "Create an object of type WrapInstrument It is needed when defining new instance of the Instrument class",
          "hierarchy": "Control Monad MultiPass",
          "module": "Control.Monad.MultiPass",
          "name": "wrapInstrument",
          "normalized": "a-\u003eWrapInstrument a",
          "package": "Control-Monad-MultiPass",
          "partial": "Instrument",
          "signature": "instr-\u003eWrapInstrument instr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Control-Monad-MultiPass/docs/Control-Monad-MultiPass.html#v:wrapInstrument"
      }
    }
  ]
]