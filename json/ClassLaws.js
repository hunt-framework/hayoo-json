[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "ClassLaws"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTests the Monad ClassLaws for a few example datatypes. Mainly\n instance declarations and QuickCheck tests + a \u003ccode\u003e\u003ca\u003emain\u003c/a\u003e\u003c/code\u003e to run it.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.Laws.Instances",
          "name": "Instances",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws-Instances.html",
          "type": "module"
        },
        "index": {
          "description": "Tests the Monad ClassLaws for few example datatypes Mainly instance declarations and QuickCheck tests main to run it",
          "hierarchy": "Control Monad Laws Instances",
          "module": "Control.Monad.Laws.Instances",
          "name": "Instances",
          "package": "ClassLaws",
          "partial": "Instances",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws-Instances.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws.Instances",
          "name": "expectedFailures",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-Laws-Instances.html#expectedFailures",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws Instances",
          "module": "Control.Monad.Laws.Instances",
          "name": "expectedFailures",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Failures",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws-Instances.html#v:expectedFailures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws.Instances",
          "name": "main",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-Laws-Instances.html#main",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws Instances",
          "module": "Control.Monad.Laws.Instances",
          "name": "main",
          "normalized": "IO()",
          "package": "ClassLaws",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws-Instances.html#v:main"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws.Instances",
          "name": "testFunctorList",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-Laws-Instances.html#testFunctorList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws Instances",
          "module": "Control.Monad.Laws.Instances",
          "name": "testFunctorList",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Functor List",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws-Instances.html#v:testFunctorList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws.Instances",
          "name": "testFunctorMaybe",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-Laws-Instances.html#testFunctorMaybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws Instances",
          "module": "Control.Monad.Laws.Instances",
          "name": "testFunctorMaybe",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Functor Maybe",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws-Instances.html#v:testFunctorMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws.Instances",
          "name": "testFunctorMonadList",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-Laws-Instances.html#testFunctorMonadList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws Instances",
          "module": "Control.Monad.Laws.Instances",
          "name": "testFunctorMonadList",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Functor Monad List",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws-Instances.html#v:testFunctorMonadList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws.Instances",
          "name": "testFunctorMonadMaybe",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-Laws-Instances.html#testFunctorMonadMaybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws Instances",
          "module": "Control.Monad.Laws.Instances",
          "name": "testFunctorMonadMaybe",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Functor Monad Maybe",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws-Instances.html#v:testFunctorMonadMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws.Instances",
          "name": "testFunctorMonadMyList",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-Laws-Instances.html#testFunctorMonadMyList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws Instances",
          "module": "Control.Monad.Laws.Instances",
          "name": "testFunctorMonadMyList",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Functor Monad My List",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws-Instances.html#v:testFunctorMonadMyList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws.Instances",
          "name": "testFunctorMyList",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-Laws-Instances.html#testFunctorMyList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws Instances",
          "module": "Control.Monad.Laws.Instances",
          "name": "testFunctorMyList",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Functor My List",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws-Instances.html#v:testFunctorMyList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws.Instances",
          "name": "testMonadList",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-Laws-Instances.html#testMonadList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws Instances",
          "module": "Control.Monad.Laws.Instances",
          "name": "testMonadList",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Monad List",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws-Instances.html#v:testMonadList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws.Instances",
          "name": "testMonadMaybe",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-Laws-Instances.html#testMonadMaybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws Instances",
          "module": "Control.Monad.Laws.Instances",
          "name": "testMonadMaybe",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Monad Maybe",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws-Instances.html#v:testMonadMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws.Instances",
          "name": "testMonadMyList",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-Laws-Instances.html#testMonadMyList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws Instances",
          "module": "Control.Monad.Laws.Instances",
          "name": "testMonadMyList",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Monad My List",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws-Instances.html#v:testMonadMyList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws.Instances",
          "name": "testMonadState",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-Laws-Instances.html#testMonadState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws Instances",
          "module": "Control.Monad.Laws.Instances",
          "name": "testMonadState",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Monad State",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws-Instances.html#v:testMonadState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module implements the laws in Control.Monad, specified in\nthe Haskell 2010 report, in 6.3.5 for Functor, in 6.3.6 for Monad, and\nin Chapter 13, module Control.Monad.  \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.Laws",
          "name": "Laws",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html",
          "type": "module"
        },
        "index": {
          "description": "This module implements the laws in Control.Monad specified in the Haskell report in for Functor in for Monad and in Chapter module Control.Monad",
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "Laws",
          "package": "ClassLaws",
          "partial": "Laws",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "FunctorLaw1",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#FunctorLaw1",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "FunctorLaw1",
          "package": "ClassLaws",
          "partial": "Functor Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:FunctorLaw1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "FunctorLaw2",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#FunctorLaw2",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "FunctorLaw2",
          "package": "ClassLaws",
          "partial": "Functor Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:FunctorLaw2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "FunctorLaws",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#FunctorLaws",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "FunctorLaws",
          "package": "ClassLaws",
          "partial": "Functor Laws",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:FunctorLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "FunctorMonadLaw",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#FunctorMonadLaw",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "FunctorMonadLaw",
          "package": "ClassLaws",
          "partial": "Functor Monad Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:FunctorMonadLaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "FunctorMonadLaws",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#FunctorMonadLaws",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "FunctorMonadLaws",
          "package": "ClassLaws",
          "partial": "Functor Monad Laws",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:FunctorMonadLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "MonadLaw1",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#MonadLaw1",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "MonadLaw1",
          "package": "ClassLaws",
          "partial": "Monad Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:MonadLaw1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "MonadLaw2",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#MonadLaw2",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "MonadLaw2",
          "package": "ClassLaws",
          "partial": "Monad Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:MonadLaw2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "MonadLaw3",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#MonadLaw3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "MonadLaw3",
          "package": "ClassLaws",
          "partial": "Monad Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:MonadLaw3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "MonadLaws",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#MonadLaws",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "MonadLaws",
          "package": "ClassLaws",
          "partial": "Monad Laws",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:MonadLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe laws for MonadPlus are less prominently declared in the base\nlibraries. \n\u003c/p\u003e",
          "module": "Control.Monad.Laws",
          "name": "MonadPlusLaw1",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#MonadPlusLaw1",
          "type": "data"
        },
        "index": {
          "description": "The laws for MonadPlus are less prominently declared in the base libraries",
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "MonadPlusLaw1",
          "package": "ClassLaws",
          "partial": "Monad Plus Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:MonadPlusLaw1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "MonadPlusLaw2",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#MonadPlusLaw2",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "MonadPlusLaw2",
          "package": "ClassLaws",
          "partial": "Monad Plus Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:MonadPlusLaw2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "MonadPlusLaw3",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#MonadPlusLaw3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "MonadPlusLaw3",
          "package": "ClassLaws",
          "partial": "Monad Plus Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:MonadPlusLaw3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "MonadPlusLaw4",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#MonadPlusLaw4",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "MonadPlusLaw4",
          "package": "ClassLaws",
          "partial": "Monad Plus Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:MonadPlusLaw4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "MonadPlusLaw5",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#MonadPlusLaw5",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "MonadPlusLaw5",
          "package": "ClassLaws",
          "partial": "Monad Plus Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:MonadPlusLaw5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "MonadPlusLaws",
          "package": "ClassLaws",
          "source": "src/Control-Monad-Laws.html#MonadPlusLaws",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "MonadPlusLaws",
          "package": "ClassLaws",
          "partial": "Monad Plus Laws",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#t:MonadPlusLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "defaultFunctorLaw1",
          "package": "ClassLaws",
          "signature": "f b -\u003e Theorem (f b)",
          "source": "src/Control-Monad-Laws.html#defaultFunctorLaw1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "defaultFunctorLaw1",
          "normalized": "a b-\u003eTheorem(a b)",
          "package": "ClassLaws",
          "partial": "Functor Law",
          "signature": "f b-\u003eTheorem(f b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:defaultFunctorLaw1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "defaultFunctorLaw2",
          "package": "ClassLaws",
          "signature": "(b1 -\u003e b, a -\u003e b1, f a) -\u003e Theorem (f b)",
          "source": "src/Control-Monad-Laws.html#defaultFunctorLaw2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "defaultFunctorLaw2",
          "normalized": "(a-\u003ea,b-\u003ea,c b)-\u003eTheorem(c a)",
          "package": "ClassLaws",
          "partial": "Functor Law",
          "signature": "(b-\u003eb,a-\u003eb,f a)-\u003eTheorem(f b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:defaultFunctorLaw2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "defaultFunctorMonadLaw",
          "package": "ClassLaws",
          "signature": "(a -\u003e b, f a) -\u003e Theorem (f b)",
          "source": "src/Control-Monad-Laws.html#defaultFunctorMonadLaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "defaultFunctorMonadLaw",
          "normalized": "(a-\u003eb,c a)-\u003eTheorem(c b)",
          "package": "ClassLaws",
          "partial": "Functor Monad Law",
          "signature": "(a-\u003eb,f a)-\u003eTheorem(f b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:defaultFunctorMonadLaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "defaultMonadLaw1",
          "package": "ClassLaws",
          "signature": "(a, a -\u003e m b) -\u003e Theorem (m b)",
          "source": "src/Control-Monad-Laws.html#defaultMonadLaw1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "defaultMonadLaw1",
          "normalized": "(a,a-\u003eb c)-\u003eTheorem(b c)",
          "package": "ClassLaws",
          "partial": "Monad Law",
          "signature": "(a,a-\u003em b)-\u003eTheorem(m b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:defaultMonadLaw1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "defaultMonadLaw2",
          "package": "ClassLaws",
          "signature": "m b -\u003e Theorem (m b)",
          "source": "src/Control-Monad-Laws.html#defaultMonadLaw2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "defaultMonadLaw2",
          "normalized": "a b-\u003eTheorem(a b)",
          "package": "ClassLaws",
          "partial": "Monad Law",
          "signature": "m b-\u003eTheorem(m b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:defaultMonadLaw2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "defaultMonadLaw3",
          "package": "ClassLaws",
          "signature": "(m a1, a1 -\u003e m a, a -\u003e m b) -\u003e Theorem (m b)",
          "source": "src/Control-Monad-Laws.html#defaultMonadLaw3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "defaultMonadLaw3",
          "normalized": "(a b,b-\u003ea b,b-\u003ea c)-\u003eTheorem(a c)",
          "package": "ClassLaws",
          "partial": "Monad Law",
          "signature": "(m a,a-\u003em a,a-\u003em b)-\u003eTheorem(m b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:defaultMonadLaw3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "defaultMonadPlusLaw1",
          "package": "ClassLaws",
          "signature": "m a -\u003e Theorem (m a)",
          "source": "src/Control-Monad-Laws.html#defaultMonadPlusLaw1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "defaultMonadPlusLaw1",
          "normalized": "a b-\u003eTheorem(a b)",
          "package": "ClassLaws",
          "partial": "Monad Plus Law",
          "signature": "m a-\u003eTheorem(m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:defaultMonadPlusLaw1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "defaultMonadPlusLaw2",
          "package": "ClassLaws",
          "signature": "m a -\u003e Theorem (m a)",
          "source": "src/Control-Monad-Laws.html#defaultMonadPlusLaw2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "defaultMonadPlusLaw2",
          "normalized": "a b-\u003eTheorem(a b)",
          "package": "ClassLaws",
          "partial": "Monad Plus Law",
          "signature": "m a-\u003eTheorem(m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:defaultMonadPlusLaw2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "defaultMonadPlusLaw3",
          "package": "ClassLaws",
          "signature": "(a -\u003e m b) -\u003e Theorem (m b)",
          "source": "src/Control-Monad-Laws.html#defaultMonadPlusLaw3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "defaultMonadPlusLaw3",
          "normalized": "(a-\u003eb c)-\u003eTheorem(b c)",
          "package": "ClassLaws",
          "partial": "Monad Plus Law",
          "signature": "(a-\u003em b)-\u003eTheorem(m b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:defaultMonadPlusLaw3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "defaultMonadPlusLaw4",
          "package": "ClassLaws",
          "signature": "m a -\u003e Theorem (m b)",
          "source": "src/Control-Monad-Laws.html#defaultMonadPlusLaw4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "defaultMonadPlusLaw4",
          "normalized": "a b-\u003eTheorem(a c)",
          "package": "ClassLaws",
          "partial": "Monad Plus Law",
          "signature": "m a-\u003eTheorem(m b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:defaultMonadPlusLaw4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "defaultMonadPlusLaw5",
          "package": "ClassLaws",
          "signature": "(m a, m a, m a) -\u003e Theorem (m a)",
          "source": "src/Control-Monad-Laws.html#defaultMonadPlusLaw5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "defaultMonadPlusLaw5",
          "normalized": "(a b,a b,a b)-\u003eTheorem(a b)",
          "package": "ClassLaws",
          "partial": "Monad Plus Law",
          "signature": "(m a,m a,m a)-\u003eTheorem(m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:defaultMonadPlusLaw5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "functorLaw1",
          "package": "ClassLaws",
          "signature": "Law (FunctorLaw1 a f)",
          "source": "src/Control-Monad-Laws.html#functorLaw1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "functorLaw1",
          "package": "ClassLaws",
          "partial": "Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:functorLaw1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "functorLaw2",
          "package": "ClassLaws",
          "signature": "Law (FunctorLaw2 a b c f)",
          "source": "src/Control-Monad-Laws.html#functorLaw2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "functorLaw2",
          "package": "ClassLaws",
          "partial": "Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:functorLaw2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "functorMonadLaw",
          "package": "ClassLaws",
          "signature": "Law (FunctorMonadLaw a b m)",
          "source": "src/Control-Monad-Laws.html#functorMonadLaw",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "functorMonadLaw",
          "package": "ClassLaws",
          "partial": "Monad Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:functorMonadLaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "monadLaw1",
          "package": "ClassLaws",
          "signature": "Law (MonadLaw1 a b m)",
          "source": "src/Control-Monad-Laws.html#monadLaw1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "monadLaw1",
          "package": "ClassLaws",
          "partial": "Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:monadLaw1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "monadLaw2",
          "package": "ClassLaws",
          "signature": "Law (MonadLaw2 b m)",
          "source": "src/Control-Monad-Laws.html#monadLaw2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "monadLaw2",
          "package": "ClassLaws",
          "partial": "Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:monadLaw2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "monadLaw3",
          "package": "ClassLaws",
          "signature": "Law (MonadLaw3 b c d m)",
          "source": "src/Control-Monad-Laws.html#monadLaw3",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "monadLaw3",
          "package": "ClassLaws",
          "partial": "Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:monadLaw3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "monadPlusLaw1",
          "package": "ClassLaws",
          "signature": "Law (MonadPlusLaw1 a m)",
          "source": "src/Control-Monad-Laws.html#monadPlusLaw1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "monadPlusLaw1",
          "package": "ClassLaws",
          "partial": "Plus Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:monadPlusLaw1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "monadPlusLaw2",
          "package": "ClassLaws",
          "signature": "Law (MonadPlusLaw2 a m)",
          "source": "src/Control-Monad-Laws.html#monadPlusLaw2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "monadPlusLaw2",
          "package": "ClassLaws",
          "partial": "Plus Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:monadPlusLaw2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "monadPlusLaw3",
          "package": "ClassLaws",
          "signature": "Law (MonadPlusLaw3 a b m)",
          "source": "src/Control-Monad-Laws.html#monadPlusLaw3",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "monadPlusLaw3",
          "package": "ClassLaws",
          "partial": "Plus Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:monadPlusLaw3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "monadPlusLaw4",
          "package": "ClassLaws",
          "signature": "Law (MonadPlusLaw4 a m)",
          "source": "src/Control-Monad-Laws.html#monadPlusLaw4",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "monadPlusLaw4",
          "package": "ClassLaws",
          "partial": "Plus Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:monadPlusLaw4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Laws",
          "name": "monadPlusLaw5",
          "package": "ClassLaws",
          "signature": "Law (MonadPlusLaw5 a m)",
          "source": "src/Control-Monad-Laws.html#monadPlusLaw5",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Laws",
          "module": "Control.Monad.Laws",
          "name": "monadPlusLaw5",
          "package": "ClassLaws",
          "partial": "Plus Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-Laws.html#v:monadPlusLaw5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTests of the \u003ccode\u003eMonadState\u003c/code\u003e laws for lazy and strict state monads.\n The laws are one level up in the module hierarchy: \n \u003ccode\u003e\u003ca\u003edefaultMonadStatePutGet\u003c/a\u003e\u003c/code\u003e etc.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.State.Class.Laws.Instances",
          "name": "Instances",
          "package": "ClassLaws",
          "source": "src/Control-Monad-State-Class-Laws-Instances.html",
          "type": "module"
        },
        "index": {
          "description": "Tests of the MonadState laws for lazy and strict state monads The laws are one level up in the module hierarchy defaultMonadStatePutGet etc",
          "hierarchy": "Control Monad State Class Laws Instances",
          "module": "Control.Monad.State.Class.Laws.Instances",
          "name": "Instances",
          "package": "ClassLaws",
          "partial": "Instances",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws-Instances.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws.Instances",
          "name": "main",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-State-Class-Laws-Instances.html#main",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws Instances",
          "module": "Control.Monad.State.Class.Laws.Instances",
          "name": "main",
          "normalized": "IO()",
          "package": "ClassLaws",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws-Instances.html#v:main"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws.Instances",
          "name": "testLawsStateL",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-State-Class-Laws-Instances.html#testLawsStateL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws Instances",
          "module": "Control.Monad.State.Class.Laws.Instances",
          "name": "testLawsStateL",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Laws State",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws-Instances.html#v:testLawsStateL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws.Instances",
          "name": "testLawsStatePartialL",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-State-Class-Laws-Instances.html#testLawsStatePartialL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws Instances",
          "module": "Control.Monad.State.Class.Laws.Instances",
          "name": "testLawsStatePartialL",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Laws State Partial",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws-Instances.html#v:testLawsStatePartialL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws.Instances",
          "name": "testLawsStatePartialS",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-State-Class-Laws-Instances.html#testLawsStatePartialS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws Instances",
          "module": "Control.Monad.State.Class.Laws.Instances",
          "name": "testLawsStatePartialS",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Laws State Partial",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws-Instances.html#v:testLawsStatePartialS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws.Instances",
          "name": "testLawsStateS",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Control-Monad-State-Class-Laws-Instances.html#testLawsStateS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws Instances",
          "module": "Control.Monad.State.Class.Laws.Instances",
          "name": "testLawsStateS",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Laws State",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws-Instances.html#v:testLawsStateS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLaws for the \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e class. A submodule has a\n \u003ccode\u003e\u003ca\u003emain\u003c/a\u003e\u003c/code\u003e which runs quite a\n few tests for the lazy and strict state monads.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.State.Class.Laws",
          "name": "Laws",
          "package": "ClassLaws",
          "source": "src/Control-Monad-State-Class-Laws.html",
          "type": "module"
        },
        "index": {
          "description": "Laws for the MonadState class submodule has main which runs quite few tests for the lazy and strict state monads",
          "hierarchy": "Control Monad State Class Laws",
          "module": "Control.Monad.State.Class.Laws",
          "name": "Laws",
          "package": "ClassLaws",
          "partial": "Laws",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws",
          "name": "MonadStateGetGet",
          "package": "ClassLaws",
          "source": "src/Control-Monad-State-Class-Laws.html#MonadStateGetGet",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws",
          "module": "Control.Monad.State.Class.Laws",
          "name": "MonadStateGetGet",
          "package": "ClassLaws",
          "partial": "Monad State Get Get",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws.html#t:MonadStateGetGet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws",
          "name": "MonadStateGetPut",
          "package": "ClassLaws",
          "source": "src/Control-Monad-State-Class-Laws.html#MonadStateGetPut",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws",
          "module": "Control.Monad.State.Class.Laws",
          "name": "MonadStateGetPut",
          "package": "ClassLaws",
          "partial": "Monad State Get Put",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws.html#t:MonadStateGetPut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws",
          "name": "MonadStateLaws",
          "package": "ClassLaws",
          "source": "src/Control-Monad-State-Class-Laws.html#MonadStateLaws",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws",
          "module": "Control.Monad.State.Class.Laws",
          "name": "MonadStateLaws",
          "package": "ClassLaws",
          "partial": "Monad State Laws",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws.html#t:MonadStateLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws",
          "name": "MonadStatePutGet",
          "package": "ClassLaws",
          "source": "src/Control-Monad-State-Class-Laws.html#MonadStatePutGet",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws",
          "module": "Control.Monad.State.Class.Laws",
          "name": "MonadStatePutGet",
          "package": "ClassLaws",
          "partial": "Monad State Put Get",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws.html#t:MonadStatePutGet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws",
          "name": "MonadStatePutPut",
          "package": "ClassLaws",
          "source": "src/Control-Monad-State-Class-Laws.html#MonadStatePutPut",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws",
          "module": "Control.Monad.State.Class.Laws",
          "name": "MonadStatePutPut",
          "package": "ClassLaws",
          "partial": "Monad State Put Put",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws.html#t:MonadStatePutPut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws",
          "name": "defaultMonadStateGetGet",
          "package": "ClassLaws",
          "signature": "(a -\u003e a -\u003e m b) -\u003e Theorem (m b)",
          "source": "src/Control-Monad-State-Class-Laws.html#defaultMonadStateGetGet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws",
          "module": "Control.Monad.State.Class.Laws",
          "name": "defaultMonadStateGetGet",
          "normalized": "(a-\u003ea-\u003eb c)-\u003eTheorem(b c)",
          "package": "ClassLaws",
          "partial": "Monad State Get Get",
          "signature": "(a-\u003ea-\u003em b)-\u003eTheorem(m b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws.html#v:defaultMonadStateGetGet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws",
          "name": "defaultMonadStateGetPut",
          "package": "ClassLaws",
          "signature": "t -\u003e Theorem (m ())",
          "source": "src/Control-Monad-State-Class-Laws.html#defaultMonadStateGetPut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws",
          "module": "Control.Monad.State.Class.Laws",
          "name": "defaultMonadStateGetPut",
          "normalized": "a-\u003eTheorem(b())",
          "package": "ClassLaws",
          "partial": "Monad State Get Put",
          "signature": "t-\u003eTheorem(m())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws.html#v:defaultMonadStateGetPut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws",
          "name": "defaultMonadStatePutGet",
          "package": "ClassLaws",
          "signature": "b -\u003e Theorem (m b)",
          "source": "src/Control-Monad-State-Class-Laws.html#defaultMonadStatePutGet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws",
          "module": "Control.Monad.State.Class.Laws",
          "name": "defaultMonadStatePutGet",
          "normalized": "a-\u003eTheorem(b a)",
          "package": "ClassLaws",
          "partial": "Monad State Put Get",
          "signature": "b-\u003eTheorem(m b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws.html#v:defaultMonadStatePutGet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws",
          "name": "defaultMonadStatePutPut",
          "package": "ClassLaws",
          "signature": "(s, s) -\u003e Theorem (m ())",
          "source": "src/Control-Monad-State-Class-Laws.html#defaultMonadStatePutPut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws",
          "module": "Control.Monad.State.Class.Laws",
          "name": "defaultMonadStatePutPut",
          "normalized": "(a,a)-\u003eTheorem(b())",
          "package": "ClassLaws",
          "partial": "Monad State Put Put",
          "signature": "(s,s)-\u003eTheorem(m())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws.html#v:defaultMonadStatePutPut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws",
          "name": "monadStateGetGet",
          "package": "ClassLaws",
          "signature": "Law (MonadStateGetGet s a m)",
          "source": "src/Control-Monad-State-Class-Laws.html#monadStateGetGet",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws",
          "module": "Control.Monad.State.Class.Laws",
          "name": "monadStateGetGet",
          "package": "ClassLaws",
          "partial": "State Get Get",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws.html#v:monadStateGetGet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws",
          "name": "monadStateGetPut",
          "package": "ClassLaws",
          "signature": "Law (MonadStateGetPut m)",
          "source": "src/Control-Monad-State-Class-Laws.html#monadStateGetPut",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws",
          "module": "Control.Monad.State.Class.Laws",
          "name": "monadStateGetPut",
          "package": "ClassLaws",
          "partial": "State Get Put",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws.html#v:monadStateGetPut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws",
          "name": "monadStatePutGet",
          "package": "ClassLaws",
          "signature": "Law (MonadStatePutGet s m)",
          "source": "src/Control-Monad-State-Class-Laws.html#monadStatePutGet",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws",
          "module": "Control.Monad.State.Class.Laws",
          "name": "monadStatePutGet",
          "package": "ClassLaws",
          "partial": "State Put Get",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws.html#v:monadStatePutGet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.State.Class.Laws",
          "name": "monadStatePutPut",
          "package": "ClassLaws",
          "signature": "Law (MonadStatePutPut s m)",
          "source": "src/Control-Monad-State-Class-Laws.html#monadStatePutPut",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad State Class Laws",
          "module": "Control.Monad.State.Class.Laws",
          "name": "monadStatePutPut",
          "package": "ClassLaws",
          "partial": "State Put Put",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Control-Monad-State-Class-Laws.html#v:monadStatePutPut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConctrete tests of some instances od the \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e laws (for\n \u003ccode\u003e\u003ca\u003eEndo\u003c/a\u003e\u003c/code\u003e, mainly). The laws themselves are one level up in the module\n hierarchy: \u003ccode\u003e\u003ca\u003edefaultMonoidLaw1\u003c/a\u003e\u003c/code\u003e etc.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Monoid.Laws.Instances",
          "name": "Instances",
          "package": "ClassLaws",
          "source": "src/Data-Monoid-Laws-Instances.html",
          "type": "module"
        },
        "index": {
          "description": "Conctrete tests of some instances od the Monoid laws for Endo mainly The laws themselves are one level up in the module hierarchy defaultMonoidLaw1 etc",
          "hierarchy": "Data Monoid Laws Instances",
          "module": "Data.Monoid.Laws.Instances",
          "name": "Instances",
          "package": "ClassLaws",
          "partial": "Instances",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws-Instances.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws.Instances",
          "name": "b2i",
          "package": "ClassLaws",
          "signature": "Bool -\u003e Int",
          "source": "src/Data-Monoid-Laws-Instances.html#b2i",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid Laws Instances",
          "module": "Data.Monoid.Laws.Instances",
          "name": "b2i",
          "normalized": "Bool-\u003eInt",
          "package": "ClassLaws",
          "signature": "Bool-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws-Instances.html#v:b2i"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws.Instances",
          "name": "main",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Data-Monoid-Laws-Instances.html#main",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid Laws Instances",
          "module": "Data.Monoid.Laws.Instances",
          "name": "main",
          "normalized": "IO()",
          "package": "ClassLaws",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws-Instances.html#v:main"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws.Instances",
          "name": "testMonoidEndo",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Data-Monoid-Laws-Instances.html#testMonoidEndo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid Laws Instances",
          "module": "Data.Monoid.Laws.Instances",
          "name": "testMonoidEndo",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Monoid Endo",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws-Instances.html#v:testMonoidEndo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws.Instances",
          "name": "testMonoidEndoPartial",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Data-Monoid-Laws-Instances.html#testMonoidEndoPartial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid Laws Instances",
          "module": "Data.Monoid.Laws.Instances",
          "name": "testMonoidEndoPartial",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Monoid Endo Partial",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws-Instances.html#v:testMonoidEndoPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws.Instances",
          "name": "testMonoidMyList",
          "package": "ClassLaws",
          "signature": "IO ()",
          "source": "src/Data-Monoid-Laws-Instances.html#testMonoidMyList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid Laws Instances",
          "module": "Data.Monoid.Laws.Instances",
          "name": "testMonoidMyList",
          "normalized": "IO()",
          "package": "ClassLaws",
          "partial": "Monoid My List",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws-Instances.html#v:testMonoidMyList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws.Instances",
          "name": "test_roundtrip",
          "package": "ClassLaws",
          "signature": "Bool",
          "source": "src/Data-Monoid-Laws-Instances.html#test_roundtrip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid Laws Instances",
          "module": "Data.Monoid.Laws.Instances",
          "name": "test_roundtrip",
          "package": "ClassLaws",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws-Instances.html#v:test_roundtrip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eClassLaws for the \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e class. Actual tests are defined in the Instances submodule and can be run from \u003ccode\u003e\u003ca\u003emain\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Monoid.Laws",
          "name": "Laws",
          "package": "ClassLaws",
          "source": "src/Data-Monoid-Laws.html",
          "type": "module"
        },
        "index": {
          "description": "ClassLaws for the Monoid class Actual tests are defined in the Instances submodule and can be run from main",
          "hierarchy": "Data Monoid Laws",
          "module": "Data.Monoid.Laws",
          "name": "Laws",
          "package": "ClassLaws",
          "partial": "Laws",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws",
          "name": "MonoidLaw1",
          "package": "ClassLaws",
          "source": "src/Data-Monoid-Laws.html#MonoidLaw1",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Monoid Laws",
          "module": "Data.Monoid.Laws",
          "name": "MonoidLaw1",
          "package": "ClassLaws",
          "partial": "Monoid Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws.html#t:MonoidLaw1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws",
          "name": "MonoidLaw2",
          "package": "ClassLaws",
          "source": "src/Data-Monoid-Laws.html#MonoidLaw2",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Monoid Laws",
          "module": "Data.Monoid.Laws",
          "name": "MonoidLaw2",
          "package": "ClassLaws",
          "partial": "Monoid Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws.html#t:MonoidLaw2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws",
          "name": "MonoidLaw3",
          "package": "ClassLaws",
          "source": "src/Data-Monoid-Laws.html#MonoidLaw3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Monoid Laws",
          "module": "Data.Monoid.Laws",
          "name": "MonoidLaw3",
          "package": "ClassLaws",
          "partial": "Monoid Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws.html#t:MonoidLaw3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws",
          "name": "MonoidLaws",
          "package": "ClassLaws",
          "source": "src/Data-Monoid-Laws.html#MonoidLaws",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Monoid Laws",
          "module": "Data.Monoid.Laws",
          "name": "MonoidLaws",
          "package": "ClassLaws",
          "partial": "Monoid Laws",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws.html#t:MonoidLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws",
          "name": "defaultMonoidLaw1",
          "package": "ClassLaws",
          "signature": "a -\u003e Theorem a",
          "source": "src/Data-Monoid-Laws.html#defaultMonoidLaw1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid Laws",
          "module": "Data.Monoid.Laws",
          "name": "defaultMonoidLaw1",
          "normalized": "a-\u003eTheorem a",
          "package": "ClassLaws",
          "partial": "Monoid Law",
          "signature": "a-\u003eTheorem a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws.html#v:defaultMonoidLaw1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws",
          "name": "defaultMonoidLaw2",
          "package": "ClassLaws",
          "signature": "a -\u003e Theorem a",
          "source": "src/Data-Monoid-Laws.html#defaultMonoidLaw2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid Laws",
          "module": "Data.Monoid.Laws",
          "name": "defaultMonoidLaw2",
          "normalized": "a-\u003eTheorem a",
          "package": "ClassLaws",
          "partial": "Monoid Law",
          "signature": "a-\u003eTheorem a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws.html#v:defaultMonoidLaw2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws",
          "name": "defaultMonoidLaw3",
          "package": "ClassLaws",
          "signature": "(a, a, a) -\u003e Theorem a",
          "source": "src/Data-Monoid-Laws.html#defaultMonoidLaw3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid Laws",
          "module": "Data.Monoid.Laws",
          "name": "defaultMonoidLaw3",
          "normalized": "(a,a,a)-\u003eTheorem a",
          "package": "ClassLaws",
          "partial": "Monoid Law",
          "signature": "(a,a,a)-\u003eTheorem a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws.html#v:defaultMonoidLaw3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws",
          "name": "monoidLaw1",
          "package": "ClassLaws",
          "signature": "Law (MonoidLaw1 m)",
          "source": "src/Data-Monoid-Laws.html#monoidLaw1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Monoid Laws",
          "module": "Data.Monoid.Laws",
          "name": "monoidLaw1",
          "package": "ClassLaws",
          "partial": "Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws.html#v:monoidLaw1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws",
          "name": "monoidLaw2",
          "package": "ClassLaws",
          "signature": "Law (MonoidLaw2 m)",
          "source": "src/Data-Monoid-Laws.html#monoidLaw2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Monoid Laws",
          "module": "Data.Monoid.Laws",
          "name": "monoidLaw2",
          "package": "ClassLaws",
          "partial": "Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws.html#v:monoidLaw2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.Laws",
          "name": "monoidLaw3",
          "package": "ClassLaws",
          "signature": "Law (MonoidLaw3 m)",
          "source": "src/Data-Monoid-Laws.html#monoidLaw3",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Monoid Laws",
          "module": "Data.Monoid.Laws",
          "name": "monoidLaw3",
          "package": "ClassLaws",
          "partial": "Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Data-Monoid-Laws.html#v:monoidLaw3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe core of ClassLaws are the type families \u003ccode\u003e\u003ca\u003eLawArgs\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLawBody\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eParam\u003c/a\u003e\u003c/code\u003e, tied together by the type class \u003ccode\u003e\u003ca\u003eLawTest\u003c/a\u003e\u003c/code\u003e. \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "Core",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-Core.html",
          "type": "module"
        },
        "index": {
          "description": "The core of ClassLaws are the type families LawArgs LawBody and Param tied together by the type class LawTest",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "Core",
          "package": "ClassLaws",
          "partial": "Core",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn equality proof is represented as a list of (at least two) equal values.\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "Equal",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-Core.html#Equal",
          "type": "type"
        },
        "index": {
          "description": "An equality proof is represented as list of at least two equal values",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "Equal",
          "package": "ClassLaws",
          "partial": "Equal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#t:Equal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eLaw\u003c/a\u003e\u003c/code\u003es we handle are of this form.\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "Law",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-Core.html#Law",
          "type": "type"
        },
        "index": {
          "description": "The Law we handle are of this form",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "Law",
          "package": "ClassLaws",
          "partial": "Law",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#t:Law"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe forall quantified part on the top level of the law\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "LawArgs",
          "package": "ClassLaws",
          "signature": "LawArgs",
          "type": "function"
        },
        "index": {
          "description": "The forall quantified part on the top level of the law",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "LawArgs",
          "package": "ClassLaws",
          "partial": "Law Args",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#t:LawArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type in the body of the forall\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "LawBody",
          "package": "ClassLaws",
          "signature": "LawBody",
          "type": "function"
        },
        "index": {
          "description": "The type in the body of the forall",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "LawBody",
          "package": "ClassLaws",
          "partial": "Law Body",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#t:LawBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass LawTest defines a test method, which returns a testable property, which we\ncan use to test a law for a type t. This class is independent of the actual laws\nto test - it can be used for Monoid, Monad, ...\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "LawTest",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-Core.html#LawTest",
          "type": "class"
        },
        "index": {
          "description": "Class LawTest defines test method which returns testable property which we can use to test law for type This class is independent of the actual laws to test it can be used for Monoid Monad",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "LawTest",
          "package": "ClassLaws",
          "partial": "Law Test",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#t:LawTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParameters needed for \u003ccode\u003e\u003ca\u003eEqual\u003c/a\u003e\u003c/code\u003e checking of the body\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "Param",
          "package": "ClassLaws",
          "signature": "Param",
          "type": "function"
        },
        "index": {
          "description": "Parameters needed for Equal checking of the body",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "Param",
          "package": "ClassLaws",
          "partial": "Param",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#t:Param"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Theorem is a claim that a LHS equals a RHS - an \u003ccode\u003e\u003ca\u003eEqual\u003c/a\u003e\u003c/code\u003e of length two.\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "Theorem",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-Core.html#Theorem",
          "type": "type"
        },
        "index": {
          "description": "Theorem is claim that LHS equals RHS an Equal of length two",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "Theorem",
          "package": "ClassLaws",
          "partial": "Theorem",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#t:Theorem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContructing an equality theorem: \u003ccode\u003elhs =.= rhs  =  [lhs, rhs]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "(=.=)",
          "package": "ClassLaws",
          "signature": "a -\u003e a -\u003e Theorem a",
          "source": "src/Test-ClassLaws-Core.html#%3D.%3D",
          "type": "function"
        },
        "index": {
          "description": "Contructing an equality theorem lhs rhs lhs rhs",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "(=.=) =.=",
          "normalized": "a-\u003ea-\u003eTheorem a",
          "package": "ClassLaws",
          "signature": "a-\u003ea-\u003eTheorem a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#v:-61-.-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake a two-element \u003ca\u003etheorem\u003c/a\u003e and an equality proof chain to splice in the middle.\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "addSteps",
          "package": "ClassLaws",
          "signature": "Theorem a -\u003e Equal a -\u003e Equal a",
          "source": "src/Test-ClassLaws-Core.html#addSteps",
          "type": "function"
        },
        "index": {
          "description": "Take two-element theorem and an equality proof chain to splice in the middle",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "addSteps",
          "normalized": "Theorem a-\u003eEqual a-\u003eEqual a",
          "package": "ClassLaws",
          "partial": "Steps",
          "signature": "Theorem a-\u003eEqual a-\u003eEqual a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#v:addSteps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper function to test laws where arguments lack a Show instance.\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "blindlawtest",
          "package": "ClassLaws",
          "signature": "t -\u003e Blind (LawArgs t) -\u003e Param (LawBody t) -\u003e Property",
          "source": "src/Test-ClassLaws-Core.html#blindlawtest",
          "type": "function"
        },
        "index": {
          "description": "Helper function to test laws where arguments lack Show instance",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "blindlawtest",
          "normalized": "a-\u003eBlind(LawArgs a)-\u003eParam(LawBody a)-\u003eProperty",
          "package": "ClassLaws",
          "signature": "t-\u003eBlind(LawArgs t)-\u003eParam(LawBody t)-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#v:blindlawtest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.Core",
          "name": "lawtest",
          "package": "ClassLaws",
          "signature": "t -\u003e LawArgs t -\u003e Param (LawBody t) -\u003e Property",
          "source": "src/Test-ClassLaws-Core.html#lawtest",
          "type": "method"
        },
        "index": {
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "lawtest",
          "normalized": "a-\u003eLawArgs a-\u003eParam(LawBody a)-\u003eProperty",
          "package": "ClassLaws",
          "signature": "t-\u003eLawArgs t-\u003eParam(LawBody t)-\u003eProperty",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#v:lawtest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper function to test laws where we should care about partial values.\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "partiallawtest",
          "package": "ClassLaws",
          "signature": "t -\u003e Partial (LawArgs t -\u003e Param (LawBody t) -\u003e Property)",
          "source": "src/Test-ClassLaws-Core.html#partiallawtest",
          "type": "function"
        },
        "index": {
          "description": "Helper function to test laws where we should care about partial values",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "partiallawtest",
          "normalized": "a-\u003ePartial(LawArgs a-\u003eParam(LawBody a)-\u003eProperty)",
          "package": "ClassLaws",
          "signature": "t-\u003ePartial(LawArgs t-\u003eParam(LawBody t)-\u003eProperty)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#v:partiallawtest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant not needing a Show instance for the \u003ccode\u003eLawArg\u003c/code\u003es\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "quickFLawCheck",
          "package": "ClassLaws",
          "signature": "t -\u003e IO ()",
          "source": "src/Test-ClassLaws-Core.html#quickFLawCheck",
          "type": "function"
        },
        "index": {
          "description": "Variant not needing Show instance for the LawArg",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "quickFLawCheck",
          "normalized": "a-\u003eIO()",
          "package": "ClassLaws",
          "partial": "FLaw Check",
          "signature": "t-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#v:quickFLawCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTop level use of ClassLaws is often \u003ccode\u003e\u003ccode\u003e\u003ca\u003equickLawCheck\u003c/a\u003e\u003c/code\u003e someLaw\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "quickLawCheck",
          "package": "ClassLaws",
          "signature": "t -\u003e IO ()",
          "source": "src/Test-ClassLaws-Core.html#quickLawCheck",
          "type": "function"
        },
        "index": {
          "description": "Top level use of ClassLaws is often quickLawCheck someLaw",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "quickLawCheck",
          "normalized": "a-\u003eIO()",
          "package": "ClassLaws",
          "partial": "Law Check",
          "signature": "t-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#v:quickLawCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecking laws in the precense of partial values\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Core",
          "name": "quickLawCheckPartial",
          "package": "ClassLaws",
          "signature": "t -\u003e IO ()",
          "source": "src/Test-ClassLaws-Core.html#quickLawCheckPartial",
          "type": "function"
        },
        "index": {
          "description": "Checking laws in the precense of partial values",
          "hierarchy": "Test ClassLaws Core",
          "module": "Test.ClassLaws.Core",
          "name": "quickLawCheckPartial",
          "normalized": "a-\u003eIO()",
          "package": "ClassLaws",
          "partial": "Law Check Partial",
          "signature": "t-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Core.html#v:quickLawCheckPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module collects the infrastructure used to easily switch\n between testing ClassLaws with or without partial values. Built\n around QuickCheck and ChasingBottoms.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Test.ClassLaws.Partial",
          "name": "Partial",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-Partial.html",
          "type": "module"
        },
        "index": {
          "description": "This module collects the infrastructure used to easily switch between testing ClassLaws with or without partial values Built around QuickCheck and ChasingBottoms",
          "hierarchy": "Test ClassLaws Partial",
          "module": "Test.ClassLaws.Partial",
          "name": "Partial",
          "package": "ClassLaws",
          "partial": "Partial",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Partial.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe copy the QuickCheck structure to make sure generators of\n partial values and equality checks handling partial values are\n used.\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Partial",
          "name": "ArbitraryPartial",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-Partial.html#ArbitraryPartial",
          "type": "class"
        },
        "index": {
          "description": "We copy the QuickCheck structure to make sure generators of partial values and equality checks handling partial values are used",
          "hierarchy": "Test ClassLaws Partial",
          "module": "Test.ClassLaws.Partial",
          "name": "ArbitraryPartial",
          "package": "ClassLaws",
          "partial": "Arbitrary Partial",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Partial.html#t:ArbitraryPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA modifier to indicate that partial values should be generated\n (or tested, or both).\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Partial",
          "name": "Partial",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-Partial.html#Partial",
          "type": "newtype"
        },
        "index": {
          "description": "modifier to indicate that partial values should be generated or tested or both",
          "hierarchy": "Test ClassLaws Partial",
          "module": "Test.ClassLaws.Partial",
          "name": "Partial",
          "package": "ClassLaws",
          "partial": "Partial",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Partial.html#t:Partial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclaring a property for possibly partial values.\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Partial",
          "name": "TestablePartial",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-Partial.html#TestablePartial",
          "type": "class"
        },
        "index": {
          "description": "Declaring property for possibly partial values",
          "hierarchy": "Test ClassLaws Partial",
          "module": "Test.ClassLaws.Partial",
          "name": "TestablePartial",
          "package": "ClassLaws",
          "partial": "Testable Partial",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Partial.html#t:TestablePartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.Partial",
          "name": "Partial",
          "package": "ClassLaws",
          "signature": "Partial",
          "source": "src/Test-ClassLaws-Partial.html#Partial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws Partial",
          "module": "Test.ClassLaws.Partial",
          "name": "Partial",
          "package": "ClassLaws",
          "partial": "Partial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Partial.html#v:Partial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.Partial",
          "name": "arbitraryPartial",
          "package": "ClassLaws",
          "signature": "Gen a",
          "source": "src/Test-ClassLaws-Partial.html#arbitraryPartial",
          "type": "method"
        },
        "index": {
          "hierarchy": "Test ClassLaws Partial",
          "module": "Test.ClassLaws.Partial",
          "name": "arbitraryPartial",
          "package": "ClassLaws",
          "partial": "Partial",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Partial.html#v:arbitraryPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper for generating partial values: \u003ccode\u003egenPartial ib ia ga\u003c/code\u003e\n generates \u003ccode\u003e\u003ca\u003ebottom\u003c/a\u003e\u003c/code\u003e with frequence \u003ccode\u003eib\u003c/code\u003e and \u003ccode\u003ega\u003c/code\u003e with frequency\n \u003ccode\u003eia\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Partial",
          "name": "genPartial",
          "package": "ClassLaws",
          "signature": "Int -\u003e Int -\u003e Gen a -\u003e Gen a",
          "source": "src/Test-ClassLaws-Partial.html#genPartial",
          "type": "function"
        },
        "index": {
          "description": "Helper for generating partial values genPartial ib ia ga generates bottom with frequence ib and ga with frequency ia",
          "hierarchy": "Test ClassLaws Partial",
          "module": "Test.ClassLaws.Partial",
          "name": "genPartial",
          "normalized": "Int-\u003eInt-\u003eGen a-\u003eGen a",
          "package": "ClassLaws",
          "partial": "Partial",
          "signature": "Int-\u003eInt-\u003eGen a-\u003eGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Partial.html#v:genPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.Partial",
          "name": "propertyPartial",
          "package": "ClassLaws",
          "signature": "prop -\u003e Property",
          "source": "src/Test-ClassLaws-Partial.html#propertyPartial",
          "type": "method"
        },
        "index": {
          "hierarchy": "Test ClassLaws Partial",
          "module": "Test.ClassLaws.Partial",
          "name": "propertyPartial",
          "normalized": "a-\u003eProperty",
          "package": "ClassLaws",
          "partial": "Partial",
          "signature": "prop-\u003eProperty",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Partial.html#v:propertyPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper for showing partial values\n\u003c/p\u003e",
          "module": "Test.ClassLaws.Partial",
          "name": "showPartial",
          "package": "ClassLaws",
          "signature": "String -\u003e (a -\u003e String) -\u003e a -\u003e String",
          "source": "src/Test-ClassLaws-Partial.html#showPartial",
          "type": "function"
        },
        "index": {
          "description": "Helper for showing partial values",
          "hierarchy": "Test ClassLaws Partial",
          "module": "Test.ClassLaws.Partial",
          "name": "showPartial",
          "normalized": "String-\u003e(a-\u003eString)-\u003ea-\u003eString",
          "package": "ClassLaws",
          "partial": "Partial",
          "signature": "String-\u003e(a-\u003eString)-\u003ea-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Partial.html#v:showPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.Partial",
          "name": "shrinkPartial",
          "package": "ClassLaws",
          "signature": "a -\u003e [a]",
          "source": "src/Test-ClassLaws-Partial.html#shrinkPartial",
          "type": "method"
        },
        "index": {
          "hierarchy": "Test ClassLaws Partial",
          "module": "Test.ClassLaws.Partial",
          "name": "shrinkPartial",
          "normalized": "a-\u003e[a]",
          "package": "ClassLaws",
          "partial": "Partial",
          "signature": "a-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Partial.html#v:shrinkPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.Partial",
          "name": "unPartial",
          "package": "ClassLaws",
          "signature": "a",
          "source": "src/Test-ClassLaws-Partial.html#Partial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws Partial",
          "module": "Test.ClassLaws.Partial",
          "name": "unPartial",
          "package": "ClassLaws",
          "partial": "Partial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-Partial.html#v:unPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSome example usage of the ClassLaws framework\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "TestingDatatypes",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-TestingDatatypes.html",
          "type": "module"
        },
        "index": {
          "description": "Some example usage of the ClassLaws framework",
          "hierarchy": "Test ClassLaws TestingDatatypes",
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "TestingDatatypes",
          "package": "ClassLaws",
          "partial": "Testing Datatypes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingDatatypes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe use the MyList datatype to provide instances that do not\n satisfy some class laws.\n\u003c/p\u003e",
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "MyList",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-TestingDatatypes.html#MyList",
          "type": "data"
        },
        "index": {
          "description": "We use the MyList datatype to provide instances that do not satisfy some class laws",
          "hierarchy": "Test ClassLaws TestingDatatypes",
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "MyList",
          "package": "ClassLaws",
          "partial": "My List",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingDatatypes.html#t:MyList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "(+++)",
          "package": "ClassLaws",
          "signature": "MyList a -\u003e MyList a -\u003e MyList a",
          "source": "src/Test-ClassLaws-TestingDatatypes.html#%2B%2B%2B",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingDatatypes",
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "(+++) +++",
          "normalized": "MyList a-\u003eMyList a-\u003eMyList a",
          "package": "ClassLaws",
          "signature": "MyList a-\u003eMyList a-\u003eMyList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingDatatypes.html#v:-43--43--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "Cons",
          "package": "ClassLaws",
          "signature": "Cons a (MyList a)",
          "source": "src/Test-ClassLaws-TestingDatatypes.html#MyList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingDatatypes",
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "Cons",
          "package": "ClassLaws",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingDatatypes.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "Nil",
          "package": "ClassLaws",
          "signature": "Nil",
          "source": "src/Test-ClassLaws-TestingDatatypes.html#MyList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingDatatypes",
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "Nil",
          "package": "ClassLaws",
          "partial": "Nil",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingDatatypes.html#v:Nil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "foldrMyList",
          "package": "ClassLaws",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e MyList a -\u003e b",
          "source": "src/Test-ClassLaws-TestingDatatypes.html#foldrMyList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingDatatypes",
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "foldrMyList",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eMyList a-\u003eb",
          "package": "ClassLaws",
          "partial": "My List",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eMyList a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingDatatypes.html#v:foldrMyList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "list2MyList",
          "package": "ClassLaws",
          "signature": "[a] -\u003e MyList a",
          "source": "src/Test-ClassLaws-TestingDatatypes.html#list2MyList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingDatatypes",
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "list2MyList",
          "normalized": "[a]-\u003eMyList a",
          "package": "ClassLaws",
          "partial": "My List",
          "signature": "[a]-\u003eMyList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingDatatypes.html#v:list2MyList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "myList2List",
          "package": "ClassLaws",
          "signature": "MyList a -\u003e [a]",
          "source": "src/Test-ClassLaws-TestingDatatypes.html#myList2List",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingDatatypes",
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "myList2List",
          "normalized": "MyList a-\u003e[a]",
          "package": "ClassLaws",
          "partial": "List List",
          "signature": "MyList a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingDatatypes.html#v:myList2List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "snoc",
          "package": "ClassLaws",
          "signature": "a -\u003e MyList a -\u003e MyList a",
          "source": "src/Test-ClassLaws-TestingDatatypes.html#snoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingDatatypes",
          "module": "Test.ClassLaws.TestingDatatypes",
          "name": "snoc",
          "normalized": "a-\u003eMyList a-\u003eMyList a",
          "package": "ClassLaws",
          "signature": "a-\u003eMyList a-\u003eMyList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingDatatypes.html#v:snoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe following class + helper functions implement law-agnostic testing\nfunctionality that is used to test laws for various classes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "TestingEquality",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-TestingEquality.html",
          "type": "module"
        },
        "index": {
          "description": "The following class helper functions implement law-agnostic testing functionality that is used to test laws for various classes",
          "hierarchy": "Test ClassLaws TestingEquality",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "TestingEquality",
          "package": "ClassLaws",
          "partial": "Testing Equality",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingEquality.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePosition in an equality proof\n\u003c/p\u003e",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "Pos",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-TestingEquality.html#Pos",
          "type": "type"
        },
        "index": {
          "description": "Position in an equality proof",
          "hierarchy": "Test ClassLaws TestingEquality",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "Pos",
          "package": "ClassLaws",
          "partial": "Pos",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingEquality.html#t:Pos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class for types which can be checked for \u003ccode\u003e\u003ca\u003eEqual\u003c/a\u003e\u003c/code\u003eity, possibly\n needing some extra \u003ccode\u003e\u003ca\u003eParam\u003c/a\u003e\u003c/code\u003eeters.\n\u003c/p\u003e",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "TestEqual",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-TestingEquality.html#TestEqual",
          "type": "class"
        },
        "index": {
          "description": "class for types which can be checked for Equal ity possibly needing some extra Param eters",
          "hierarchy": "Test ClassLaws TestingEquality",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "TestEqual",
          "package": "ClassLaws",
          "partial": "Test Equal",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingEquality.html#t:TestEqual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLocal helper\n\u003c/p\u003e",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "failingPair",
          "package": "ClassLaws",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e Equal a -\u003e (Pos, a, a)",
          "source": "src/Test-ClassLaws-TestingEquality.html#failingPair",
          "type": "function"
        },
        "index": {
          "description": "Local helper",
          "hierarchy": "Test ClassLaws TestingEquality",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "failingPair",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eEqual a-\u003e(Pos,a,a)",
          "package": "ClassLaws",
          "partial": "Pair",
          "signature": "(a-\u003ea-\u003eBool)-\u003eEqual a-\u003e(Pos,a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingEquality.html#v:failingPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLocal helper\n\u003c/p\u003e",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "failingPair'",
          "package": "ClassLaws",
          "signature": "t -\u003e (t1 -\u003e t1 -\u003e Bool) -\u003e [t1] -\u003e (t, t1, t1)",
          "source": "src/Test-ClassLaws-TestingEquality.html#failingPair%27",
          "type": "function"
        },
        "index": {
          "description": "Local helper",
          "hierarchy": "Test ClassLaws TestingEquality",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "failingPair'",
          "normalized": "a-\u003e(a-\u003ea-\u003eBool)-\u003e[a]-\u003e(a,a,a)",
          "package": "ClassLaws",
          "partial": "Pair'",
          "signature": "t-\u003e(t-\u003et-\u003eBool)-\u003e[t]-\u003e(t,t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingEquality.html#v:failingPair-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLocal helper\n\u003c/p\u003e",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "pairwiseEq",
          "package": "ClassLaws",
          "signature": "(r -\u003e r -\u003e Bool) -\u003e [r] -\u003e Bool",
          "source": "src/Test-ClassLaws-TestingEquality.html#pairwiseEq",
          "type": "function"
        },
        "index": {
          "description": "Local helper",
          "hierarchy": "Test ClassLaws TestingEquality",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "pairwiseEq",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003eBool",
          "package": "ClassLaws",
          "partial": "Eq",
          "signature": "(r-\u003er-\u003eBool)-\u003e[r]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingEquality.html#v:pairwiseEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe second function, \u003ccode\u003e\u003ca\u003etestEq\u003c/a\u003e\u003c/code\u003e, does the same, but now for pairs\n that are not necessarily runnable.\n\u003c/p\u003e",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "testEq",
          "package": "ClassLaws",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e Equal a -\u003e Property",
          "source": "src/Test-ClassLaws-TestingEquality.html#testEq",
          "type": "function"
        },
        "index": {
          "description": "The second function testEq does the same but now for pairs that are not necessarily runnable",
          "hierarchy": "Test ClassLaws TestingEquality",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "testEq",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eEqual a-\u003eProperty",
          "package": "ClassLaws",
          "partial": "Eq",
          "signature": "(a-\u003ea-\u003eBool)-\u003eEqual a-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingEquality.html#v:testEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar variant of \u003ccode\u003e\u003ca\u003etestEq\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003ePartial\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "testEqPartial",
          "package": "ClassLaws",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e Equal a -\u003e Property",
          "source": "src/Test-ClassLaws-TestingEquality.html#testEqPartial",
          "type": "function"
        },
        "index": {
          "description": "Similar variant of testEq for Partial values",
          "hierarchy": "Test ClassLaws TestingEquality",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "testEqPartial",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eEqual a-\u003eProperty",
          "package": "ClassLaws",
          "partial": "Eq Partial",
          "signature": "(a-\u003ea-\u003eBool)-\u003eEqual a-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingEquality.html#v:testEqPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingEquality",
          "name": "testEqual",
          "package": "ClassLaws",
          "signature": "Equal b -\u003e Param b -\u003e Property",
          "source": "src/Test-ClassLaws-TestingEquality.html#testEqual",
          "type": "method"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingEquality",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "testEqual",
          "normalized": "Equal a-\u003eParam a-\u003eProperty",
          "package": "ClassLaws",
          "partial": "Equal",
          "signature": "Equal b-\u003eParam b-\u003eProperty",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingEquality.html#v:testEqual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe first function, \u003ccode\u003e\u003ca\u003etestRunEq\u003c/a\u003e\u003c/code\u003e, returns a property implementing\n an equality check.  It takes a function that can \u003ccode\u003erun\u003c/code\u003e a value and a\n comparison operator to a predicate (which in turn takes some\n supposedly equal values, and a parameter needed for the run\n function, and returns a \u003ccode\u003e\u003ca\u003eProperty\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "testRunEq",
          "package": "ClassLaws",
          "signature": "(t -\u003e p -\u003e r) -\u003e (r -\u003e r -\u003e Bool) -\u003e Equal t -\u003e p -\u003e Property",
          "source": "src/Test-ClassLaws-TestingEquality.html#testRunEq",
          "type": "function"
        },
        "index": {
          "description": "The first function testRunEq returns property implementing an equality check It takes function that can run value and comparison operator to predicate which in turn takes some supposedly equal values and parameter needed for the run function and returns Property",
          "hierarchy": "Test ClassLaws TestingEquality",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "testRunEq",
          "normalized": "(a-\u003eb-\u003ec)-\u003e(c-\u003ec-\u003eBool)-\u003eEqual a-\u003eb-\u003eProperty",
          "package": "ClassLaws",
          "partial": "Run Eq",
          "signature": "(t-\u003ep-\u003er)-\u003e(r-\u003er-\u003eBool)-\u003eEqual t-\u003ep-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingEquality.html#v:testRunEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003etestRunEq\u003c/a\u003e\u003c/code\u003e intended for \u003ccode\u003e\u003ca\u003ePartial\u003c/a\u003e\u003c/code\u003e values. (Only the\n Show part differs - the user also needs to supply an equality\n operator handling \u003ccode\u003e\u003ca\u003ePartial\u003c/a\u003e\u003c/code\u003e values.)\n\u003c/p\u003e",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "testRunEqPartial",
          "package": "ClassLaws",
          "signature": "(t -\u003e p -\u003e r) -\u003e (r -\u003e r -\u003e Bool) -\u003e Equal t -\u003e p -\u003e Property",
          "source": "src/Test-ClassLaws-TestingEquality.html#testRunEqPartial",
          "type": "function"
        },
        "index": {
          "description": "Variant of testRunEq intended for Partial values Only the Show part differs the user also needs to supply an equality operator handling Partial values",
          "hierarchy": "Test ClassLaws TestingEquality",
          "module": "Test.ClassLaws.TestingEquality",
          "name": "testRunEqPartial",
          "normalized": "(a-\u003eb-\u003ec)-\u003e(c-\u003ec-\u003eBool)-\u003eEqual a-\u003eb-\u003eProperty",
          "package": "ClassLaws",
          "partial": "Run Eq Partial",
          "signature": "(t-\u003ep-\u003er)-\u003e(r-\u003er-\u003eBool)-\u003eEqual t-\u003ep-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingEquality.html#v:testRunEqPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions from a finite type can be shown, checked for equality,\n and generated. We provide variants both for total and for partial\n values.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "TestingFinFuns",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-TestingFinFuns.html",
          "type": "module"
        },
        "index": {
          "description": "Functions from finite type can be shown checked for equality and generated We provide variants both for total and for partial values",
          "hierarchy": "Test ClassLaws TestingFinFuns",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "TestingFinFuns",
          "package": "ClassLaws",
          "partial": "Testing Fin Funs",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingFinFuns.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "FunTab",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-TestingFinFuns.html#FunTab",
          "type": "type"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingFinFuns",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "FunTab",
          "package": "ClassLaws",
          "partial": "Fun Tab",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingFinFuns.html#t:FunTab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "SemEq",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-TestingFinFuns.html#SemEq",
          "type": "type"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingFinFuns",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "SemEq",
          "package": "ClassLaws",
          "partial": "Sem Eq",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingFinFuns.html#t:SemEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "arbitraryPartialFun",
          "package": "ClassLaws",
          "signature": "Gen a -\u003e Gen (e -\u003e a)",
          "source": "src/Test-ClassLaws-TestingFinFuns.html#arbitraryPartialFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingFinFuns",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "arbitraryPartialFun",
          "normalized": "Gen a-\u003eGen(b-\u003ea)",
          "package": "ClassLaws",
          "partial": "Partial Fun",
          "signature": "Gen a-\u003eGen(e-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingFinFuns.html#v:arbitraryPartialFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "enumElems",
          "package": "ClassLaws",
          "signature": "[a]",
          "source": "src/Test-ClassLaws-TestingFinFuns.html#enumElems",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingFinFuns",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "enumElems",
          "normalized": "[a]",
          "package": "ClassLaws",
          "partial": "Elems",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingFinFuns.html#v:enumElems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "eqPartial",
          "package": "ClassLaws",
          "signature": "Bool -\u003e a -\u003e a1 -\u003e Bool",
          "source": "src/Test-ClassLaws-TestingFinFuns.html#eqPartial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingFinFuns",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "eqPartial",
          "normalized": "Bool-\u003ea-\u003ea-\u003eBool",
          "package": "ClassLaws",
          "partial": "Partial",
          "signature": "Bool-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingFinFuns.html#v:eqPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "lMeet",
          "package": "ClassLaws",
          "signature": "[a] -\u003e a",
          "source": "src/Test-ClassLaws-TestingFinFuns.html#lMeet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingFinFuns",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "lMeet",
          "normalized": "[a]-\u003ea",
          "package": "ClassLaws",
          "partial": "Meet",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingFinFuns.html#v:lMeet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "lessEqPartial",
          "package": "ClassLaws",
          "signature": "Bool -\u003e a -\u003e a1 -\u003e Bool",
          "source": "src/Test-ClassLaws-TestingFinFuns.html#lessEqPartial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingFinFuns",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "lessEqPartial",
          "normalized": "Bool-\u003ea-\u003ea-\u003eBool",
          "package": "ClassLaws",
          "partial": "Eq Partial",
          "signature": "Bool-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingFinFuns.html#v:lessEqPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "meetPartial",
          "package": "ClassLaws",
          "signature": "a2 -\u003e a -\u003e a1 -\u003e a2",
          "source": "src/Test-ClassLaws-TestingFinFuns.html#meetPartial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingFinFuns",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "meetPartial",
          "normalized": "a-\u003ea-\u003ea-\u003ea",
          "package": "ClassLaws",
          "partial": "Partial",
          "signature": "a-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingFinFuns.html#v:meetPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "semEqFun",
          "package": "ClassLaws",
          "signature": "SemEq b -\u003e SemEq (a -\u003e b)",
          "source": "src/Test-ClassLaws-TestingFinFuns.html#semEqFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingFinFuns",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "semEqFun",
          "normalized": "SemEq a-\u003eSemEq(b-\u003ea)",
          "package": "ClassLaws",
          "partial": "Eq Fun",
          "signature": "SemEq b-\u003eSemEq(a-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingFinFuns.html#v:semEqFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "semanticLE",
          "package": "ClassLaws",
          "signature": "t -\u003e a -\u003e a1 -\u003e Bool",
          "source": "src/Test-ClassLaws-TestingFinFuns.html#semanticLE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingFinFuns",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "semanticLE",
          "normalized": "a-\u003eb-\u003eb-\u003eBool",
          "package": "ClassLaws",
          "partial": "LE",
          "signature": "t-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingFinFuns.html#v:semanticLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "showFun",
          "package": "ClassLaws",
          "signature": "(a -\u003e b) -\u003e String",
          "source": "src/Test-ClassLaws-TestingFinFuns.html#showFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingFinFuns",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "showFun",
          "normalized": "(a-\u003eb)-\u003eString",
          "package": "ClassLaws",
          "partial": "Fun",
          "signature": "(a-\u003eb)-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingFinFuns.html#v:showFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "showPartialFun",
          "package": "ClassLaws",
          "signature": "(a -\u003e b) -\u003e String",
          "source": "src/Test-ClassLaws-TestingFinFuns.html#showPartialFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingFinFuns",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "showPartialFun",
          "normalized": "(a-\u003eb)-\u003eString",
          "package": "ClassLaws",
          "partial": "Partial Fun",
          "signature": "(a-\u003eb)-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingFinFuns.html#v:showPartialFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "table2fun",
          "package": "ClassLaws",
          "signature": "FunTab e a -\u003e e -\u003e a",
          "source": "src/Test-ClassLaws-TestingFinFuns.html#table2fun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingFinFuns",
          "module": "Test.ClassLaws.TestingFinFuns",
          "name": "table2fun",
          "normalized": "FunTab a b-\u003ea-\u003eb",
          "package": "ClassLaws",
          "signature": "FunTab e a-\u003ee-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingFinFuns.html#v:table2fun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImplementations of the infrastructure needed to test state monad\n laws.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Test.ClassLaws.TestingState",
          "name": "TestingState",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-TestingState.html",
          "type": "module"
        },
        "index": {
          "description": "Implementations of the infrastructure needed to test state monad laws",
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "TestingState",
          "package": "ClassLaws",
          "partial": "Testing State",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "Pair",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-TestingState.html#Pair",
          "type": "data"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "Pair",
          "package": "ClassLaws",
          "partial": "Pair",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#t:Pair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "SS",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-TestingState.html#SS",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "SS",
          "package": "ClassLaws",
          "partial": "SS",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#t:SS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "State",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws-TestingState.html#State",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "State",
          "package": "ClassLaws",
          "partial": "State",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#t:State"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "Pair",
          "package": "ClassLaws",
          "signature": "Pair a b",
          "source": "src/Test-ClassLaws-TestingState.html#Pair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "Pair",
          "package": "ClassLaws",
          "partial": "Pair",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:Pair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "S",
          "package": "ClassLaws",
          "signature": "S",
          "source": "src/Test-ClassLaws-TestingState.html#State",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "S",
          "package": "ClassLaws",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "SS",
          "package": "ClassLaws",
          "signature": "SS",
          "source": "src/Test-ClassLaws-TestingState.html#SS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "SS",
          "package": "ClassLaws",
          "partial": "SS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:SS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "basicPairShow",
          "package": "ClassLaws",
          "signature": "(a -\u003e String) -\u003e (b -\u003e String) -\u003e Pair a b -\u003e String",
          "source": "src/Test-ClassLaws-TestingState.html#basicPairShow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "basicPairShow",
          "normalized": "(a-\u003eString)-\u003e(b-\u003eString)-\u003ePair a b-\u003eString",
          "package": "ClassLaws",
          "partial": "Pair Show",
          "signature": "(a-\u003eString)-\u003e(b-\u003eString)-\u003ePair a b-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:basicPairShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "bindStateL",
          "package": "ClassLaws",
          "signature": "State t1 t -\u003e (t -\u003e State t1 a) -\u003e State t1 a",
          "source": "src/Test-ClassLaws-TestingState.html#bindStateL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "bindStateL",
          "normalized": "State a a-\u003e(a-\u003eState a b)-\u003eState a b",
          "package": "ClassLaws",
          "partial": "State",
          "signature": "State t t-\u003e(t-\u003eState t a)-\u003eState t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:bindStateL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "bindStateS",
          "package": "ClassLaws",
          "signature": "State s a1 -\u003e (a1 -\u003e State s a) -\u003e State s a",
          "source": "src/Test-ClassLaws-TestingState.html#bindStateS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "bindStateS",
          "normalized": "State a b-\u003e(b-\u003eState a b)-\u003eState a b",
          "package": "ClassLaws",
          "partial": "State",
          "signature": "State s a-\u003e(a-\u003eState s a)-\u003eState s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:bindStateS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "enumShowBot_auxLst",
          "package": "ClassLaws",
          "signature": "[String] -\u003e a -\u003e String",
          "source": "src/Test-ClassLaws-TestingState.html#enumShowBot_auxLst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "enumShowBot_auxLst",
          "normalized": "[String]-\u003ea-\u003eString",
          "package": "ClassLaws",
          "partial": "Show Bot Lst",
          "signature": "[String]-\u003ea-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:enumShowBot_auxLst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "enumTotArb",
          "package": "ClassLaws",
          "signature": "[(Int, a)] -\u003e Gen a",
          "source": "src/Test-ClassLaws-TestingState.html#enumTotArb",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "enumTotArb",
          "normalized": "[(Int,a)]-\u003eGen a",
          "package": "ClassLaws",
          "partial": "Tot Arb",
          "signature": "[(Int,a)]-\u003eGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:enumTotArb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "fmapStateL",
          "package": "ClassLaws",
          "signature": "(t -\u003e a) -\u003e State t1 t -\u003e State t1 a",
          "source": "src/Test-ClassLaws-TestingState.html#fmapStateL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "fmapStateL",
          "normalized": "(a-\u003eb)-\u003eState a a-\u003eState a b",
          "package": "ClassLaws",
          "partial": "State",
          "signature": "(t-\u003ea)-\u003eState t t-\u003eState t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:fmapStateL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "fmapStateS",
          "package": "ClassLaws",
          "signature": "(a1 -\u003e a) -\u003e State s a1 -\u003e State s a",
          "source": "src/Test-ClassLaws-TestingState.html#fmapStateS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "fmapStateS",
          "normalized": "(a-\u003ea)-\u003eState b a-\u003eState b a",
          "package": "ClassLaws",
          "partial": "State",
          "signature": "(a-\u003ea)-\u003eState s a-\u003eState s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:fmapStateS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "fstP",
          "package": "ClassLaws",
          "signature": "Pair t t1 -\u003e t",
          "source": "src/Test-ClassLaws-TestingState.html#fstP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "fstP",
          "normalized": "Pair a a-\u003ea",
          "package": "ClassLaws",
          "signature": "Pair t t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:fstP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "getState",
          "package": "ClassLaws",
          "signature": "State s s",
          "source": "src/Test-ClassLaws-TestingState.html#getState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "getState",
          "package": "ClassLaws",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:getState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "pairFromGen",
          "package": "ClassLaws",
          "signature": "Gen a -\u003e Gen b -\u003e Gen (Pair a b)",
          "source": "src/Test-ClassLaws-TestingState.html#pairFromGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "pairFromGen",
          "normalized": "Gen a-\u003eGen b-\u003eGen(Pair a b)",
          "package": "ClassLaws",
          "partial": "From Gen",
          "signature": "Gen a-\u003eGen b-\u003eGen(Pair a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:pairFromGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "pairRecPatt",
          "package": "ClassLaws",
          "signature": "(a -\u003e a -\u003e ta) -\u003e (b -\u003e b -\u003e tb) -\u003e (ta -\u003e tb -\u003e t) -\u003e Pair a b -\u003e Pair a b -\u003e t",
          "source": "src/Test-ClassLaws-TestingState.html#pairRecPatt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "pairRecPatt",
          "normalized": "(a-\u003ea-\u003eb)-\u003e(c-\u003ec-\u003ed)-\u003e(b-\u003ed-\u003ee)-\u003ePair a c-\u003ePair a c-\u003ee",
          "package": "ClassLaws",
          "partial": "Rec Patt",
          "signature": "(a-\u003ea-\u003eta)-\u003e(b-\u003eb-\u003etb)-\u003e(ta-\u003etb-\u003et)-\u003ePair a b-\u003ePair a b-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:pairRecPatt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "pairShowPartial",
          "package": "ClassLaws",
          "signature": "String -\u003e Pair a b -\u003e String",
          "source": "src/Test-ClassLaws-TestingState.html#pairShowPartial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "pairShowPartial",
          "normalized": "String-\u003ePair a b-\u003eString",
          "package": "ClassLaws",
          "partial": "Show Partial",
          "signature": "String-\u003ePair a b-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:pairShowPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "putState",
          "package": "ClassLaws",
          "signature": "s -\u003e State s ()",
          "source": "src/Test-ClassLaws-TestingState.html#putState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "putState",
          "normalized": "a-\u003eState a()",
          "package": "ClassLaws",
          "partial": "State",
          "signature": "s-\u003eState s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:putState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "returnState",
          "package": "ClassLaws",
          "signature": "a -\u003e State s a",
          "source": "src/Test-ClassLaws-TestingState.html#returnState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "returnState",
          "normalized": "a-\u003eState b a",
          "package": "ClassLaws",
          "partial": "State",
          "signature": "a-\u003eState s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:returnState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "runS",
          "package": "ClassLaws",
          "signature": "s -\u003e Pair a s",
          "source": "src/Test-ClassLaws-TestingState.html#State",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "runS",
          "normalized": "a-\u003ePair b a",
          "package": "ClassLaws",
          "signature": "s-\u003ePair a s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:runS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "sndP",
          "package": "ClassLaws",
          "signature": "Pair t t1 -\u003e t1",
          "source": "src/Test-ClassLaws-TestingState.html#sndP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "sndP",
          "normalized": "Pair a a-\u003ea",
          "package": "ClassLaws",
          "signature": "Pair t t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:sndP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "statePatt",
          "package": "ClassLaws",
          "signature": "((t1 -\u003e Pair t2 t1) -\u003e (t3 -\u003e Pair t4 t3) -\u003e t) -\u003e State t1 t2 -\u003e State t3 t4 -\u003e t",
          "source": "src/Test-ClassLaws-TestingState.html#statePatt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "statePatt",
          "normalized": "((a-\u003ePair a a)-\u003e(a-\u003ePair a a)-\u003ea)-\u003eState a a-\u003eState a a-\u003ea",
          "package": "ClassLaws",
          "partial": "Patt",
          "signature": "((t-\u003ePair t t)-\u003e(t-\u003ePair t t)-\u003et)-\u003eState t t-\u003eState t t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:statePatt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Test.ClassLaws.TestingState",
          "name": "unSS",
          "package": "ClassLaws",
          "signature": "State s a",
          "source": "src/Test-ClassLaws-TestingState.html#SS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Test ClassLaws TestingState",
          "module": "Test.ClassLaws.TestingState",
          "name": "unSS",
          "package": "ClassLaws",
          "partial": "SS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws-TestingState.html#v:unSS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe central part of ClassLaws is defined in the .Core, .Partial\n and .TestingEquality. Some more helper functions and examples\n reside in Test.ClassLaws.*. Finally, laws for the Monoid, Monad and\n MonadState classes live under their definitions in the hierarchy:\n Data.Monoid.Laws, Control.Monad.Laws, etc.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Test.ClassLaws",
          "name": "ClassLaws",
          "package": "ClassLaws",
          "source": "src/Test-ClassLaws.html",
          "type": "module"
        },
        "index": {
          "description": "The central part of ClassLaws is defined in the Core Partial and TestingEquality Some more helper functions and examples reside in Test.ClassLaws Finally laws for the Monoid Monad and MonadState classes live under their definitions in the hierarchy Data.Monoid.Laws Control.Monad.Laws etc",
          "hierarchy": "Test ClassLaws",
          "module": "Test.ClassLaws",
          "name": "ClassLaws",
          "package": "ClassLaws",
          "partial": "Class Laws",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Test-ClassLaws.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Show.Laws",
          "name": "Laws",
          "package": "ClassLaws",
          "source": "src/Text-Show-Laws.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Show Laws",
          "module": "Text.Show.Laws",
          "name": "Laws",
          "package": "ClassLaws",
          "partial": "Laws",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Text-Show-Laws.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Show.Laws",
          "name": "ShowLaw",
          "package": "ClassLaws",
          "source": "src/Text-Show-Laws.html#ShowLaw",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Show Laws",
          "module": "Text.Show.Laws",
          "name": "ShowLaw",
          "package": "ClassLaws",
          "partial": "Show Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Text-Show-Laws.html#t:ShowLaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Show.Laws",
          "name": "ShowLaws",
          "package": "ClassLaws",
          "source": "src/Text-Show-Laws.html#ShowLaws",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text Show Laws",
          "module": "Text.Show.Laws",
          "name": "ShowLaws",
          "package": "ClassLaws",
          "partial": "Show Laws",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Text-Show-Laws.html#t:ShowLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Show.Laws",
          "name": "defaultShowLaw",
          "package": "ClassLaws",
          "signature": "(Int, a, String, [Char]) -\u003e Theorem [Char]",
          "source": "src/Text-Show-Laws.html#defaultShowLaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Show Laws",
          "module": "Text.Show.Laws",
          "name": "defaultShowLaw",
          "normalized": "(Int,a,String,[Char])-\u003eTheorem[Char]",
          "package": "ClassLaws",
          "partial": "Show Law",
          "signature": "(Int,a,String,[Char])-\u003eTheorem[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Text-Show-Laws.html#v:defaultShowLaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Show.Laws",
          "name": "showLaw",
          "package": "ClassLaws",
          "signature": "Law (ShowLaw s)",
          "source": "src/Text-Show-Laws.html#showLaw",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Show Laws",
          "module": "Text.Show.Laws",
          "name": "showLaw",
          "package": "ClassLaws",
          "partial": "Law",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ClassLaws/docs/Text-Show-Laws.html#v:showLaw"
      }
    }
  ]
]