[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "sparse"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix.Internal.Array",
          "name": "Array",
          "package": "sparse",
          "source": "src/Sparse-Matrix-Internal-Array.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Array",
          "module": "Sparse.Matrix.Internal.Array",
          "name": "Array",
          "package": "sparse",
          "partial": "Array",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Array.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix.Internal.Array",
          "name": "Array",
          "package": "sparse",
          "source": "src/Sparse-Matrix-Internal-Array.html#Array",
          "type": "type"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Array",
          "module": "Sparse.Matrix.Internal.Array",
          "name": "Array",
          "package": "sparse",
          "partial": "Array",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Array.html#t:Array"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix.Internal.Array",
          "name": "Arrayed",
          "package": "sparse",
          "source": "src/Sparse-Matrix-Internal-Array.html#Arrayed",
          "type": "class"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Array",
          "module": "Sparse.Matrix.Internal.Array",
          "name": "Arrayed",
          "package": "sparse",
          "partial": "Arrayed",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Array.html#t:Arrayed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix.Internal.Array",
          "name": "MV_Complex",
          "package": "sparse",
          "source": "src/Sparse-Matrix-Internal-Array.html#MV_Complex",
          "type": "data"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Array",
          "module": "Sparse.Matrix.Internal.Array",
          "name": "MV_Complex",
          "package": "sparse",
          "partial": "MV Complex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Array.html#t:MV_Complex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix.Internal.Array",
          "name": "MV_Pair",
          "package": "sparse",
          "source": "src/Sparse-Matrix-Internal-Array.html#MV_Pair",
          "type": "data"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Array",
          "module": "Sparse.Matrix.Internal.Array",
          "name": "MV_Pair",
          "package": "sparse",
          "partial": "MV Pair",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Array.html#t:MV_Pair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix.Internal.Array",
          "name": "V_Complex",
          "package": "sparse",
          "source": "src/Sparse-Matrix-Internal-Array.html#V_Complex",
          "type": "data"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Array",
          "module": "Sparse.Matrix.Internal.Array",
          "name": "V_Complex",
          "package": "sparse",
          "partial": "Complex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Array.html#t:V_Complex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix.Internal.Array",
          "name": "V_Pair",
          "package": "sparse",
          "source": "src/Sparse-Matrix-Internal-Array.html#V_Pair",
          "type": "data"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Array",
          "module": "Sparse.Matrix.Internal.Array",
          "name": "V_Pair",
          "package": "sparse",
          "partial": "Pair",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Array.html#t:V_Pair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix.Internal.Array",
          "name": "MV_Complex",
          "package": "sparse",
          "signature": "Int -\u003e !(Mutable (Arr a) s a) -\u003e !(Mutable (Arr a) s a) -\u003e MV_Complex s (Complex a)",
          "source": "src/Sparse-Matrix-Internal-Array.html#MV_Complex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Array",
          "module": "Sparse.Matrix.Internal.Array",
          "name": "MV_Complex",
          "normalized": "Int-\u003e(Mutable(Arr a)b a)-\u003e(Mutable(Arr a)b a)-\u003eMV_Complex b(Complex a)",
          "package": "sparse",
          "partial": "MV Complex",
          "signature": "Int-\u003e(Mutable(Arr a)s a)-\u003e(Mutable(Arr a)s a)-\u003eMV_Complex s(Complex a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Array.html#v:MV_Complex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix.Internal.Array",
          "name": "MV_Pair",
          "package": "sparse",
          "signature": "Int -\u003e !(Mutable (Arr a) s a) -\u003e !(Mutable (Arr b) s b) -\u003e MV_Pair s (a, b)",
          "source": "src/Sparse-Matrix-Internal-Array.html#MV_Pair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Array",
          "module": "Sparse.Matrix.Internal.Array",
          "name": "MV_Pair",
          "normalized": "Int-\u003e(Mutable(Arr a)b a)-\u003e(Mutable(Arr c)b c)-\u003eMV_Pair b(a,c)",
          "package": "sparse",
          "partial": "MV Pair",
          "signature": "Int-\u003e(Mutable(Arr a)s a)-\u003e(Mutable(Arr b)s b)-\u003eMV_Pair s(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Array.html#v:MV_Pair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix.Internal.Array",
          "name": "V_Complex",
          "package": "sparse",
          "signature": "Int -\u003e !(Array a) -\u003e !(Array a) -\u003e V_Complex (Complex a)",
          "source": "src/Sparse-Matrix-Internal-Array.html#V_Complex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Array",
          "module": "Sparse.Matrix.Internal.Array",
          "name": "V_Complex",
          "normalized": "Int-\u003e(Array a)-\u003e(Array a)-\u003eV_Complex(Complex a)",
          "package": "sparse",
          "partial": "Complex",
          "signature": "Int-\u003e(Array a)-\u003e(Array a)-\u003eV_Complex(Complex a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Array.html#v:V_Complex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix.Internal.Array",
          "name": "V_Pair",
          "package": "sparse",
          "signature": "Int -\u003e !(Array a) -\u003e !(Array b) -\u003e V_Pair (a, b)",
          "source": "src/Sparse-Matrix-Internal-Array.html#V_Pair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Array",
          "module": "Sparse.Matrix.Internal.Array",
          "name": "V_Pair",
          "normalized": "Int-\u003e(Array a)-\u003e(Array b)-\u003eV_Pair(a,b)",
          "package": "sparse",
          "partial": "Pair",
          "signature": "Int-\u003e(Array a)-\u003e(Array b)-\u003eV_Pair(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Array.html#v:V_Pair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMatrix stream fusion internals\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sparse.Matrix.Internal.Fusion",
          "name": "Fusion",
          "package": "sparse",
          "source": "src/Sparse-Matrix-Internal-Fusion.html",
          "type": "module"
        },
        "index": {
          "description": "Matrix stream fusion internals",
          "hierarchy": "Sparse Matrix Internal Fusion",
          "module": "Sparse.Matrix.Internal.Fusion",
          "name": "Fusion",
          "package": "sparse",
          "partial": "Fusion",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Fusion.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the internal stream fusion combinator used to merge streams for addition.\n\u003c/p\u003e",
          "module": "Sparse.Matrix.Internal.Fusion",
          "name": "mergeStreamsWith",
          "package": "sparse",
          "signature": "(a -\u003e a -\u003e a) -\u003e Stream m (Key, a) -\u003e Stream m (Key, a) -\u003e Stream m (Key, a)",
          "source": "src/Sparse-Matrix-Internal-Fusion.html#mergeStreamsWith",
          "type": "function"
        },
        "index": {
          "description": "This is the internal stream fusion combinator used to merge streams for addition",
          "hierarchy": "Sparse Matrix Internal Fusion",
          "module": "Sparse.Matrix.Internal.Fusion",
          "name": "mergeStreamsWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eStream b(Key,a)-\u003eStream b(Key,a)-\u003eStream b(Key,a)",
          "package": "sparse",
          "partial": "Streams With",
          "signature": "(a-\u003ea-\u003ea)-\u003eStream m(Key,a)-\u003eStream m(Key,a)-\u003eStream m(Key,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Fusion.html#v:mergeStreamsWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the internal stream fusion combinator used to merge streams for addition.\n\u003c/p\u003e\u003cp\u003eThis form permits cancellative addition.\n\u003c/p\u003e",
          "module": "Sparse.Matrix.Internal.Fusion",
          "name": "mergeStreamsWith0",
          "package": "sparse",
          "signature": "(a -\u003e a -\u003e Maybe a) -\u003e Stream m (Key, a) -\u003e Stream m (Key, a) -\u003e Stream m (Key, a)",
          "source": "src/Sparse-Matrix-Internal-Fusion.html#mergeStreamsWith0",
          "type": "function"
        },
        "index": {
          "description": "This is the internal stream fusion combinator used to merge streams for addition This form permits cancellative addition",
          "hierarchy": "Sparse Matrix Internal Fusion",
          "module": "Sparse.Matrix.Internal.Fusion",
          "name": "mergeStreamsWith0",
          "normalized": "(a-\u003ea-\u003eMaybe a)-\u003eStream b(Key,a)-\u003eStream b(Key,a)-\u003eStream b(Key,a)",
          "package": "sparse",
          "partial": "Streams With",
          "signature": "(a-\u003ea-\u003eMaybe a)-\u003eStream m(Key,a)-\u003eStream m(Key,a)-\u003eStream m(Key,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Fusion.html#v:mergeStreamsWith0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBootstrapped \u003cem\u003ecatenable\u003c/em\u003e non-empty pairing heaps as described in\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttps://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication/part-5\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "Heap",
          "package": "sparse",
          "source": "src/Sparse-Matrix-Internal-Heap.html",
          "type": "module"
        },
        "index": {
          "description": "Bootstrapped catenable non-empty pairing heaps as described in https www.fpcomplete.com user edwardk revisiting-matrix-multiplication part-5",
          "hierarchy": "Sparse Matrix Internal Heap",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "Heap",
          "package": "sparse",
          "partial": "Heap",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Heap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBootstrapped catenable non-empty pairing heaps\n\u003c/p\u003e",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "Heap",
          "package": "sparse",
          "source": "src/Sparse-Matrix-Internal-Heap.html#Heap",
          "type": "data"
        },
        "index": {
          "description": "Bootstrapped catenable non-empty pairing heaps",
          "hierarchy": "Sparse Matrix Internal Heap",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "Heap",
          "package": "sparse",
          "partial": "Heap",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Heap.html#t:Heap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "Heap",
          "package": "sparse",
          "signature": "Heap !Key a [Heap a] [Heap a] [Heap a]",
          "source": "src/Sparse-Matrix-Internal-Heap.html#Heap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Heap",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "Heap",
          "normalized": "Heap Key a[Heap a][Heap a][Heap a]",
          "package": "sparse",
          "partial": "Heap",
          "signature": "Heap Key a[Heap a][Heap a][Heap a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Heap.html#v:Heap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAppend two heaps where we know every key in the first occurs before every key in the second\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehead $ singleton (Key 1 1) 1 `fby` singleton (Key 2 2) 2\n\u003c/code\u003e\u003c/strong\u003e(Key 1 1,1)\n\u003c/pre\u003e",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "fby",
          "package": "sparse",
          "signature": "Heap a -\u003e Heap a -\u003e Heap a",
          "source": "src/Sparse-Matrix-Internal-Heap.html#fby",
          "type": "function"
        },
        "index": {
          "description": "Append two heaps where we know every key in the first occurs before every key in the second head singleton Key fby singleton Key Key",
          "hierarchy": "Sparse Matrix Internal Heap",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "fby",
          "normalized": "Heap a-\u003eHeap a-\u003eHeap a",
          "package": "sparse",
          "signature": "Heap a-\u003eHeap a-\u003eHeap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Heap.html#v:fby"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a \u003ccode\u003e\u003ca\u003eHeap\u003c/a\u003e\u003c/code\u003e from an list of elements that must be in strictly ascending Morton order.\n\u003c/p\u003e",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "fromAscList",
          "package": "sparse",
          "signature": "[(Key, a)] -\u003e Heap a",
          "source": "src/Sparse-Matrix-Internal-Heap.html#fromAscList",
          "type": "function"
        },
        "index": {
          "description": "Build Heap from an list of elements that must be in strictly ascending Morton order",
          "hierarchy": "Sparse Matrix Internal Heap",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "fromAscList",
          "normalized": "[(Key,a)]-\u003eHeap a",
          "package": "sparse",
          "partial": "Asc List",
          "signature": "[(Key,a)]-\u003eHeap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Heap.html#v:fromAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a \u003ccode\u003e\u003ca\u003eHeap\u003c/a\u003e\u003c/code\u003e from a jumbled up list of elements.\n\u003c/p\u003e",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "fromList",
          "package": "sparse",
          "signature": "[(Key, a)] -\u003e Heap a",
          "source": "src/Sparse-Matrix-Internal-Heap.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "Build Heap from jumbled up list of elements",
          "hierarchy": "Sparse Matrix Internal Heap",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "fromList",
          "normalized": "[(Key,a)]-\u003eHeap a",
          "package": "sparse",
          "partial": "List",
          "signature": "[(Key,a)]-\u003eHeap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Heap.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehead $ singleton (Key 1 1) 1\n\u003c/code\u003e\u003c/strong\u003e(Key 1 1,1)\n\u003c/pre\u003e",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "head",
          "package": "sparse",
          "signature": "Heap a -\u003e (Key, a)",
          "source": "src/Sparse-Matrix-Internal-Heap.html#head",
          "type": "function"
        },
        "index": {
          "description": "head singleton Key Key",
          "hierarchy": "Sparse Matrix Internal Heap",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "head",
          "normalized": "Heap a-\u003e(Key,a)",
          "package": "sparse",
          "signature": "Heap a-\u003e(Key,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Heap.html#v:head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterleave two heaps making a new \u003ccode\u003e\u003ca\u003eHeap\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehead $ singleton (Key 1 1) 1 `mix` singleton (Key 2 2) 2\n\u003c/code\u003e\u003c/strong\u003e(Key 1 1,1)\n\u003c/pre\u003e",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "mix",
          "package": "sparse",
          "signature": "Heap a -\u003e Heap a -\u003e Heap a",
          "source": "src/Sparse-Matrix-Internal-Heap.html#mix",
          "type": "function"
        },
        "index": {
          "description": "Interleave two heaps making new Heap head singleton Key mix singleton Key Key",
          "hierarchy": "Sparse Matrix Internal Heap",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "mix",
          "normalized": "Heap a-\u003eHeap a-\u003eHeap a",
          "package": "sparse",
          "signature": "Heap a-\u003eHeap a-\u003eHeap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Heap.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esingleton (Key 1 1) 1\n\u003c/code\u003e\u003c/strong\u003eHeap (Key 1 1) 1 [] [] []\n\u003c/pre\u003e",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "singleton",
          "package": "sparse",
          "signature": "Key -\u003e a -\u003e Heap a",
          "source": "src/Sparse-Matrix-Internal-Heap.html#singleton",
          "type": "function"
        },
        "index": {
          "description": "singleton Key Heap Key",
          "hierarchy": "Sparse Matrix Internal Heap",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "singleton",
          "normalized": "Key-\u003ea-\u003eHeap a",
          "package": "sparse",
          "signature": "Key-\u003ea-\u003eHeap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Heap.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eHeap\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e folding together values with identical keys using the supplied\n addition operator.\n\u003c/p\u003e",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "streamHeapWith",
          "package": "sparse",
          "signature": "(a -\u003e a -\u003e a) -\u003e Maybe (Heap a) -\u003e Stream m (Key, a)",
          "source": "src/Sparse-Matrix-Internal-Heap.html#streamHeapWith",
          "type": "function"
        },
        "index": {
          "description": "Convert Heap into Stream folding together values with identical keys using the supplied addition operator",
          "hierarchy": "Sparse Matrix Internal Heap",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "streamHeapWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eMaybe(Heap a)-\u003eStream b(Key,a)",
          "package": "sparse",
          "partial": "Heap With",
          "signature": "(a-\u003ea-\u003ea)-\u003eMaybe(Heap a)-\u003eStream m(Key,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Heap.html#v:streamHeapWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eHeap\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e folding together values with identical keys using the supplied\n addition operator that is allowed to return a sparse 0, by returning \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "streamHeapWith0",
          "package": "sparse",
          "signature": "(a -\u003e a -\u003e Maybe a) -\u003e Maybe (Heap a) -\u003e Stream m (Key, a)",
          "source": "src/Sparse-Matrix-Internal-Heap.html#streamHeapWith0",
          "type": "function"
        },
        "index": {
          "description": "Convert Heap into Stream folding together values with identical keys using the supplied addition operator that is allowed to return sparse by returning Nothing",
          "hierarchy": "Sparse Matrix Internal Heap",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "streamHeapWith0",
          "normalized": "(a-\u003ea-\u003eMaybe a)-\u003eMaybe(Heap a)-\u003eStream b(Key,a)",
          "package": "sparse",
          "partial": "Heap With",
          "signature": "(a-\u003ea-\u003eMaybe a)-\u003eMaybe(Heap a)-\u003eStream m(Key,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Heap.html#v:streamHeapWith0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etail $ singleton (Key 1 1) 1\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "tail",
          "package": "sparse",
          "signature": "Heap a -\u003e Maybe (Heap a)",
          "source": "src/Sparse-Matrix-Internal-Heap.html#tail",
          "type": "function"
        },
        "index": {
          "description": "tail singleton Key Nothing",
          "hierarchy": "Sparse Matrix Internal Heap",
          "module": "Sparse.Matrix.Internal.Heap",
          "name": "tail",
          "normalized": "Heap a-\u003eMaybe(Heap a)",
          "package": "sparse",
          "signature": "Heap a-\u003eMaybe(Heap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Heap.html#v:tail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eKeys in Morton order\n\u003c/p\u003e\u003cp\u003eThis module provides combinators for shuffling together the bits of two\n key components to get a key that is based on their interleaved bits.\n\u003c/p\u003e\u003cp\u003eSee \u003ca\u003ehttp://en.wikipedia.org/wiki/Z-order_curve\u003c/a\u003e for more information\n about Morton order.\n\u003c/p\u003e\u003cp\u003eHow to perform the comparison without interleaving is described in\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttps://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication/part-2\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "Key",
          "package": "sparse",
          "source": "src/Sparse-Matrix-Internal-Key.html",
          "type": "module"
        },
        "index": {
          "description": "Keys in Morton order This module provides combinators for shuffling together the bits of two key components to get key that is based on their interleaved bits See http en.wikipedia.org wiki Z-order curve for more information about Morton order How to perform the comparison without interleaving is described in https www.fpcomplete.com user edwardk revisiting-matrix-multiplication part-2",
          "hierarchy": "Sparse Matrix Internal Key",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "Key",
          "package": "sparse",
          "partial": "Key",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Key.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eKey i j\u003c/code\u003e logically orders the keys as if the bits of the keys \u003ccode\u003ei\u003c/code\u003e and \u003ccode\u003ej\u003c/code\u003e\n were interleaved. This is equivalent to storing the keys in \"Morton Order\".\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eKey 100 200 ^. _1\n\u003c/code\u003e\u003c/strong\u003e100\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eKey 100 200 ^. _2\n\u003c/code\u003e\u003c/strong\u003e200\n\u003c/pre\u003e",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "Key",
          "package": "sparse",
          "source": "src/Sparse-Matrix-Internal-Key.html#Key",
          "type": "data"
        },
        "index": {
          "description": "Key logically orders the keys as if the bits of the keys and were interleaved This is equivalent to storing the keys in Morton Order Key Key",
          "hierarchy": "Sparse Matrix Internal Key",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "Key",
          "package": "sparse",
          "partial": "Key",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Key.html#t:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix.Internal.Key",
          "name": "MVector",
          "package": "sparse",
          "signature": "MVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Key",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "MVector",
          "package": "sparse",
          "partial": "MVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Key.html#t:MVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix.Internal.Key",
          "name": "Vector",
          "package": "sparse",
          "signature": "Vector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Key",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "Vector",
          "package": "sparse",
          "partial": "Vector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Key.html#t:Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Sparse.Matrix.Internal.Key\",\"Sparse.Matrix\"]",
          "name": "Key",
          "package": "sparse",
          "signature": "Key !Word !Word",
          "source": "src/Sparse-Matrix-Internal-Key.html#Key",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Key.html#v:Key\",\"http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:Key\"]"
        },
        "index": {
          "hierarchy": "Sparse Matrix Internal Key",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "Key",
          "package": "sparse",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Key.html#v:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecompare the position of the most significant bit of two words\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ecompares 4 7\n\u003c/code\u003e\u003c/strong\u003eEQ\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ecompares 7 9\n\u003c/code\u003e\u003c/strong\u003eLT\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ecompares 9 7\n\u003c/code\u003e\u003c/strong\u003eGT\n\u003c/pre\u003e",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "compares",
          "package": "sparse",
          "signature": "Word -\u003e Word -\u003e Ordering",
          "source": "src/Sparse-Matrix-Internal-Key.html#compares",
          "type": "function"
        },
        "index": {
          "description": "compare the position of the most significant bit of two words compares EQ compares LT compares GT",
          "hierarchy": "Sparse Matrix Internal Key",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "compares",
          "normalized": "Word-\u003eWord-\u003eOrdering",
          "package": "sparse",
          "signature": "Word-\u003eWord-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Key.html#v:compares"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eeqs\u003c/a\u003e\u003c/code\u003e a b\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when the position of the most significant bit of \u003ccode\u003ea\u003c/code\u003e is equal to the position of the most signficant bit of \u003ccode\u003eb\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eeqs 4 7\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eeqs 4 8\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eeqs 7 4\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eeqs 8 4\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "eqs",
          "package": "sparse",
          "signature": "Word -\u003e Word -\u003e Bool",
          "source": "src/Sparse-Matrix-Internal-Key.html#eqs",
          "type": "function"
        },
        "index": {
          "description": "eqs returns True when the position of the most significant bit of is equal to the position of the most signficant bit of eqs True eqs False eqs True eqs False",
          "hierarchy": "Sparse Matrix Internal Key",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "eqs",
          "normalized": "Word-\u003eWord-\u003eBool",
          "package": "sparse",
          "signature": "Word-\u003eWord-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Key.html#v:eqs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003egts\u003c/a\u003e\u003c/code\u003e a b\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when the position of the most significant bit of \u003ccode\u003ea\u003c/code\u003e is greater than or equal to the position of the most signficant bit of \u003ccode\u003eb\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eges 4 10\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eges 4 7\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eges 7 4\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eges 10 4\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "ges",
          "package": "sparse",
          "signature": "Word -\u003e Word -\u003e Bool",
          "source": "src/Sparse-Matrix-Internal-Key.html#ges",
          "type": "function"
        },
        "index": {
          "description": "gts returns True when the position of the most significant bit of is greater than or equal to the position of the most signficant bit of ges False ges True ges True ges True",
          "hierarchy": "Sparse Matrix Internal Key",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "ges",
          "normalized": "Word-\u003eWord-\u003eBool",
          "package": "sparse",
          "signature": "Word-\u003eWord-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Key.html#v:ges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003egts\u003c/a\u003e\u003c/code\u003e a b\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when the position of the most significant bit of \u003ccode\u003ea\u003c/code\u003e is greater than to the position of the most signficant bit of \u003ccode\u003eb\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003egts 4 10\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003egts 4 7\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003egts 7 4\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003egts 10 4\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "gts",
          "package": "sparse",
          "signature": "Word -\u003e Word -\u003e Bool",
          "source": "src/Sparse-Matrix-Internal-Key.html#gts",
          "type": "function"
        },
        "index": {
          "description": "gts returns True when the position of the most significant bit of is greater than to the position of the most signficant bit of gts False gts False gts False gts True",
          "hierarchy": "Sparse Matrix Internal Key",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "gts",
          "normalized": "Word-\u003eWord-\u003eBool",
          "package": "sparse",
          "signature": "Word-\u003eWord-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Key.html#v:gts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eles\u003c/a\u003e\u003c/code\u003e a b\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when the position of the most significant bit of \u003ccode\u003ea\u003c/code\u003e is less than or equal to the position of the most signficant bit of \u003ccode\u003eb\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eles 4 10\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eles 4 7\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eles 7 4\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eles 10 4\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "les",
          "package": "sparse",
          "signature": "Word -\u003e Word -\u003e Bool",
          "source": "src/Sparse-Matrix-Internal-Key.html#les",
          "type": "function"
        },
        "index": {
          "description": "les returns True when the position of the most significant bit of is less than or equal to the position of the most signficant bit of les True les True les True les False",
          "hierarchy": "Sparse Matrix Internal Key",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "les",
          "normalized": "Word-\u003eWord-\u003eBool",
          "package": "sparse",
          "signature": "Word-\u003eWord-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Key.html#v:les"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003elts\u003c/a\u003e\u003c/code\u003e a b\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when the position of the most significant bit of \u003ccode\u003ea\u003c/code\u003e is less than the position of the most signficant bit of \u003ccode\u003eb\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elts 4 10\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elts 4 7\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elts 7 8\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "lts",
          "package": "sparse",
          "signature": "Word -\u003e Word -\u003e Bool",
          "source": "src/Sparse-Matrix-Internal-Key.html#lts",
          "type": "function"
        },
        "index": {
          "description": "lts returns True when the position of the most significant bit of is less than the position of the most signficant bit of lts True lts False lts True",
          "hierarchy": "Sparse Matrix Internal Key",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "lts",
          "normalized": "Word-\u003eWord-\u003eBool",
          "package": "sparse",
          "signature": "Word-\u003eWord-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Key.html#v:lts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003enes\u003c/a\u003e\u003c/code\u003e a b\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when the position of the most significant bit of \u003ccode\u003ea\u003c/code\u003e is not equal to the position of the most signficant bit of \u003ccode\u003eb\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enes 4 7\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enes 4 8\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enes 7 4\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enes 8 4\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "nes",
          "package": "sparse",
          "signature": "Word -\u003e Word -\u003e Bool",
          "source": "src/Sparse-Matrix-Internal-Key.html#nes",
          "type": "function"
        },
        "index": {
          "description": "nes returns True when the position of the most significant bit of is not equal to the position of the most signficant bit of nes False nes True nes False nes True",
          "hierarchy": "Sparse Matrix Internal Key",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "nes",
          "normalized": "Word-\u003eWord-\u003eBool",
          "package": "sparse",
          "signature": "Word-\u003eWord-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Key.html#v:nes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwaps the key components around\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eswap (Key 100 200)\n\u003c/code\u003e\u003c/strong\u003eKey 200 100\n\u003c/pre\u003e",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "swap",
          "package": "sparse",
          "signature": "Key -\u003e Key",
          "source": "src/Sparse-Matrix-Internal-Key.html#swap",
          "type": "function"
        },
        "index": {
          "description": "Swaps the key components around swap Key Key",
          "hierarchy": "Sparse Matrix Internal Key",
          "module": "Sparse.Matrix.Internal.Key",
          "name": "swap",
          "normalized": "Key-\u003eKey",
          "package": "sparse",
          "signature": "Key-\u003eKey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix-Internal-Key.html#v:swap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSparse Matrices in Morton order\n\u003c/p\u003e\u003cp\u003eThe design of this library is described in the series \"Revisiting Matrix Multiplication\" on FP Complete's School of Haskell.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttps://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sparse.Matrix",
          "name": "Matrix",
          "package": "sparse",
          "source": "src/Sparse-Matrix.html",
          "type": "module"
        },
        "index": {
          "description": "Sparse Matrices in Morton order The design of this library is described in the series Revisiting Matrix Multiplication on FP Complete School of Haskell https www.fpcomplete.com user edwardk revisiting-matrix-multiplication",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "Matrix",
          "package": "sparse",
          "partial": "Matrix",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix",
          "name": "Arrayed",
          "package": "sparse",
          "source": "src/Sparse-Matrix-Internal-Array.html#Arrayed",
          "type": "class"
        },
        "index": {
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "Arrayed",
          "package": "sparse",
          "partial": "Arrayed",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#t:Arrayed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix",
          "name": "Eq0",
          "package": "sparse",
          "source": "src/Sparse-Matrix.html#Eq0",
          "type": "class"
        },
        "index": {
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "Eq0",
          "package": "sparse",
          "partial": "Eq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#t:Eq0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eKey i j\u003c/code\u003e logically orders the keys as if the bits of the keys \u003ccode\u003ei\u003c/code\u003e and \u003ccode\u003ej\u003c/code\u003e\n were interleaved. This is equivalent to storing the keys in \"Morton Order\".\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eKey 100 200 ^. _1\n\u003c/code\u003e\u003c/strong\u003e100\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eKey 100 200 ^. _2\n\u003c/code\u003e\u003c/strong\u003e200\n\u003c/pre\u003e",
          "module": "Sparse.Matrix",
          "name": "Key",
          "package": "sparse",
          "source": "src/Sparse-Matrix-Internal-Key.html#Key",
          "type": "data"
        },
        "index": {
          "description": "Key logically orders the keys as if the bits of the keys and were interleaved This is equivalent to storing the keys in Morton Order Key Key",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "Key",
          "package": "sparse",
          "partial": "Key",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#t:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix",
          "name": "Mat",
          "package": "sparse",
          "source": "src/Sparse-Matrix.html#Mat",
          "type": "data"
        },
        "index": {
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "Mat",
          "package": "sparse",
          "partial": "Mat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#t:Mat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sparse.Matrix",
          "name": "Mat",
          "package": "sparse",
          "signature": "Mat !Int !(Vector Word) !(Vector Word) !(Array a)",
          "source": "src/Sparse-Matrix.html#Mat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "Mat",
          "package": "sparse",
          "partial": "Mat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:Mat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebundle up the matrix in a form suitable for vector-algorithms\n\u003c/p\u003e",
          "module": "Sparse.Matrix",
          "name": "_Mat",
          "package": "sparse",
          "signature": "Iso' (Mat a) (Vector Vector (Arr a) (Key, a))",
          "source": "src/Sparse-Matrix.html#_Mat",
          "type": "function"
        },
        "index": {
          "description": "bundle up the matrix in form suitable for vector-algorithms",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "_Mat",
          "normalized": "Iso'(Mat a)(Vector Vector(Arr a)(Key,a))",
          "package": "sparse",
          "partial": "Mat",
          "signature": "Iso'(Mat a)(Vector Vector(Arr a)(Key,a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:_Mat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from a \u003ccode\u003e\u003ca\u003eHeap\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf addition of non-zero valus in your ring-like structure\n cannot yield zero, then you can use\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eaddHeap\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003estreamHeapWith\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e+\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e\u003cp\u003einstead of the default definition:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eaddHeap\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003estreamHeapWith0\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003enonZero\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e+\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e",
          "module": "Sparse.Matrix",
          "name": "addHeap",
          "package": "sparse",
          "signature": "Maybe (Heap a) -\u003e Stream (Key, a)",
          "source": "src/Sparse-Matrix.html#addHeap",
          "type": "method"
        },
        "index": {
          "description": "Convert from Heap to Stream If addition of non-zero valus in your ring-like structure cannot yield zero then you can use addHeap streamHeapWith instead of the default definition addHeap streamHeapWith0 nonZero",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "addHeap",
          "normalized": "Maybe(Heap a)-\u003eStream(Key,a)",
          "package": "sparse",
          "partial": "Heap",
          "signature": "Maybe(Heap a)-\u003eStream(Key,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:addHeap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd two matrices. By default this assumes \u003ccode\u003e\u003ca\u003eisZero\u003c/a\u003e\u003c/code\u003e can\n possibly return \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e after an addition. For some\n ring-like structures, this doesn't hold. There you can\n use:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eaddMats\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eaddWith\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e+\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e\u003cp\u003eBy default this will use\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eaddMats\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003eaddWith0\u003c/code\u003e \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003enonZero\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e+\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e",
          "module": "Sparse.Matrix",
          "name": "addMats",
          "package": "sparse",
          "signature": "Mat a -\u003e Mat a -\u003e Mat a",
          "source": "src/Sparse-Matrix.html#addMats",
          "type": "method"
        },
        "index": {
          "description": "Add two matrices By default this assumes isZero can possibly return True after an addition For some ring-like structures this doesn hold There you can use addMats addWith By default this will use addMats addWith0 nonZero",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "addMats",
          "normalized": "Mat a-\u003eMat a-\u003eMat a",
          "package": "sparse",
          "partial": "Mats",
          "signature": "Mat a-\u003eMat a-\u003eMat a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:addMats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMerge two matrices where the indices coincide into a new matrix. This provides for generalized\n addition, but where the summation of two non-zero entries is necessarily non-zero.\n\u003c/p\u003e",
          "module": "Sparse.Matrix",
          "name": "addWith",
          "package": "sparse",
          "signature": "(a -\u003e a -\u003e a) -\u003e Mat a -\u003e Mat a -\u003e Mat a",
          "source": "src/Sparse-Matrix.html#addWith",
          "type": "function"
        },
        "index": {
          "description": "Merge two matrices where the indices coincide into new matrix This provides for generalized addition but where the summation of two non-zero entries is necessarily non-zero",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "addWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eMat a-\u003eMat a-\u003eMat a",
          "package": "sparse",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003eMat a-\u003eMat a-\u003eMat a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:addWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty matrix\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eempty :: Mat Int\n\u003c/code\u003e\u003c/strong\u003efromList []\n\u003c/pre\u003e",
          "module": "Sparse.Matrix",
          "name": "empty",
          "package": "sparse",
          "signature": "Mat a",
          "source": "src/Sparse-Matrix.html#empty",
          "type": "function"
        },
        "index": {
          "description": "The empty matrix empty Mat Int fromList",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "empty",
          "package": "sparse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a sparse matrix.\n\u003c/p\u003e",
          "module": "Sparse.Matrix",
          "name": "fromList",
          "package": "sparse",
          "signature": "[(Key, a)] -\u003e Mat a",
          "source": "src/Sparse-Matrix.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "Build sparse matrix",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "fromList",
          "normalized": "[(Key,a)]-\u003eMat a",
          "package": "sparse",
          "partial": "List",
          "signature": "[(Key,a)]-\u003eMat a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eident n\u003c/code\u003e makes an \u003ccode\u003en\u003c/code\u003e x \u003ccode\u003en\u003c/code\u003e identity matrix\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eident 4\n\u003c/code\u003e\u003c/strong\u003efromList [(Key 0 0,1),(Key 1 1,1),(Key 2 2,1),(Key 3 3,1)]\n\u003c/pre\u003e",
          "module": "Sparse.Matrix",
          "name": "ident",
          "package": "sparse",
          "signature": "Int -\u003e Mat a",
          "source": "src/Sparse-Matrix.html#ident",
          "type": "function"
        },
        "index": {
          "description": "ident makes an identity matrix ident fromList Key Key Key Key",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "ident",
          "normalized": "Int-\u003eMat a",
          "package": "sparse",
          "signature": "Int-\u003eMat a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:ident"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn whether or not the element is 0.\n\u003c/p\u003e\u003cp\u003eIt may be okay to never return \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, but you won't be\n able to thin spurious zeroes introduced into your matrix.\n\u003c/p\u003e",
          "module": "Sparse.Matrix",
          "name": "isZero",
          "package": "sparse",
          "signature": "a -\u003e Bool",
          "source": "src/Sparse-Matrix.html#isZero",
          "type": "method"
        },
        "index": {
          "description": "Return whether or not the element is It may be okay to never return True but you won be able to thin spurious zeroes introduced into your matrix",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "isZero",
          "normalized": "a-\u003eBool",
          "package": "sparse",
          "partial": "Zero",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:isZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the keys of a matrix\n\u003c/p\u003e",
          "module": "Sparse.Matrix",
          "name": "keys",
          "package": "sparse",
          "signature": "Lens' (Mat a) (Vector Key)",
          "source": "src/Sparse-Matrix.html#keys",
          "type": "function"
        },
        "index": {
          "description": "Access the keys of matrix",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "keys",
          "package": "sparse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:keys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiply two matrices using the specified multiplication and addition operation.\n\u003c/p\u003e",
          "module": "Sparse.Matrix",
          "name": "multiplyWith",
          "package": "sparse",
          "signature": "(a -\u003e a -\u003e a) -\u003e (Maybe (Heap a) -\u003e Stream (Key, a)) -\u003e Mat a -\u003e Mat a -\u003e Mat a",
          "source": "src/Sparse-Matrix.html#multiplyWith",
          "type": "function"
        },
        "index": {
          "description": "Multiply two matrices using the specified multiplication and addition operation",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "multiplyWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e(Maybe(Heap a)-\u003eStream(Key,a))-\u003eMat a-\u003eMat a-\u003eMat a",
          "package": "sparse",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003e(Maybe(Heap a)-\u003eStream(Key,a))-\u003eMat a-\u003eMat a-\u003eMat a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:multiplyWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove results that are equal to zero from a simpler function.\n\u003c/p\u003e\u003cp\u003eWhen used with \u003ccode\u003eaddWith\u003c/code\u003e or \u003ccode\u003emultiplyWith\u003c/code\u003e's additive argument\n this can help retain the sparsity of the matrix.\n\u003c/p\u003e",
          "module": "Sparse.Matrix",
          "name": "nonZero",
          "package": "sparse",
          "signature": "(x -\u003e y -\u003e a) -\u003e x -\u003e y -\u003e Maybe a",
          "source": "src/Sparse-Matrix.html#nonZero",
          "type": "method"
        },
        "index": {
          "description": "Remove results that are equal to zero from simpler function When used with addWith or multiplyWith additive argument this can help retain the sparsity of the matrix",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "nonZero",
          "normalized": "(a-\u003eb-\u003ec)-\u003ea-\u003eb-\u003eMaybe c",
          "package": "sparse",
          "partial": "Zero",
          "signature": "(x-\u003ey-\u003ea)-\u003ex-\u003ey-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:nonZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enull (empty :: Mat Int)\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e",
          "module": "Sparse.Matrix",
          "name": "null",
          "package": "sparse",
          "signature": "Mat a -\u003e Bool",
          "source": "src/Sparse-Matrix.html#null",
          "type": "function"
        },
        "index": {
          "description": "null empty Mat Int True",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "null",
          "normalized": "Mat a-\u003eBool",
          "package": "sparse",
          "signature": "Mat a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esingleton\u003c/code\u003e makes a matrix with a singleton value at a given location\n\u003c/p\u003e",
          "module": "Sparse.Matrix",
          "name": "singleton",
          "package": "sparse",
          "signature": "Key -\u003e a -\u003e Mat a",
          "source": "src/Sparse-Matrix.html#singleton",
          "type": "function"
        },
        "index": {
          "description": "singleton makes matrix with singleton value at given location",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "singleton",
          "normalized": "Key-\u003ea-\u003eMat a",
          "package": "sparse",
          "signature": "Key-\u003ea-\u003eMat a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCount the number of non-zero entries in the matrix\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esize (ident 4)\n\u003c/code\u003e\u003c/strong\u003e4\n\u003c/pre\u003e",
          "module": "Sparse.Matrix",
          "name": "size",
          "package": "sparse",
          "signature": "Mat a -\u003e Int",
          "source": "src/Sparse-Matrix.html#size",
          "type": "function"
        },
        "index": {
          "description": "Count the number of non-zero entries in the matrix size ident",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "size",
          "normalized": "Mat a-\u003eInt",
          "package": "sparse",
          "signature": "Mat a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranspose a matrix\n\u003c/p\u003e",
          "module": "Sparse.Matrix",
          "name": "transpose",
          "package": "sparse",
          "signature": "Mat a -\u003e Mat a",
          "source": "src/Sparse-Matrix.html#transpose",
          "type": "function"
        },
        "index": {
          "description": "Transpose matrix",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "transpose",
          "normalized": "Mat a-\u003eMat a",
          "package": "sparse",
          "signature": "Mat a-\u003eMat a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the keys of a matrix\n\u003c/p\u003e",
          "module": "Sparse.Matrix",
          "name": "values",
          "package": "sparse",
          "signature": "Lens (Mat a) (Mat b) (Array a) (Array b)",
          "source": "src/Sparse-Matrix.html#values",
          "type": "function"
        },
        "index": {
          "description": "Access the keys of matrix",
          "hierarchy": "Sparse Matrix",
          "module": "Sparse.Matrix",
          "name": "values",
          "package": "sparse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/sparse/docs/Sparse-Matrix.html#v:values"
      }
    }
  ]
]