[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "regex-pcre-builtin"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis exports instances of the high level API and the medium level\nAPI of \u003ccode\u003e\u003ca\u003ecompile\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eexecute\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eregexec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "Lazy",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-ByteString-Lazy.html",
          "type": "module"
        },
        "index": {
          "description": "This exports instances of the high level API and the medium level API of compile execute and regexec",
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "Lazy",
          "package": "regex-pcre-builtin",
          "partial": "Lazy",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "CompOption",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#CompOption",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "CompOption",
          "package": "regex-pcre-builtin",
          "partial": "Comp Option",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "ExecOption",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#ExecOption",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "ExecOption",
          "package": "regex-pcre-builtin",
          "partial": "Exec Option",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-negative length of a match\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "MatchLength",
          "package": "regex-pcre-builtin",
          "type": "type"
        },
        "index": {
          "description": "non-negative length of match",
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "MatchLength",
          "package": "regex-pcre-builtin",
          "partial": "Match Length",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#t:MatchLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e0 based index from start of source, or (-1) for unused\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "MatchOffset",
          "package": "regex-pcre-builtin",
          "type": "type"
        },
        "index": {
          "description": "based index from start of source or for unused",
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "MatchOffset",
          "package": "regex-pcre-builtin",
          "partial": "Match Offset",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#t:MatchOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA compiled regular expression\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "Regex",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "compiled regular expression",
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "Regex",
          "package": "regex-pcre-builtin",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "ReturnCode",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#ReturnCode",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "ReturnCode",
          "package": "regex-pcre-builtin",
          "partial": "Return Code",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#t:ReturnCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "WrapError",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#WrapError",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "WrapError",
          "package": "regex-pcre-builtin",
          "partial": "Wrap Error",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#t:WrapError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "CompOption",
          "package": "regex-pcre-builtin",
          "signature": "CompOption CInt",
          "source": "src/Text-Regex-PCRE-Wrap.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:CompOption\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:CompOption\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:CompOption\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:CompOption\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:CompOption\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "CompOption",
          "package": "regex-pcre-builtin",
          "partial": "Comp Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "ExecOption",
          "package": "regex-pcre-builtin",
          "signature": "ExecOption CInt",
          "source": "src/Text-Regex-PCRE-Wrap.html#ExecOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:ExecOption\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:ExecOption\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:ExecOption\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:ExecOption\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:ExecOption\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "ExecOption",
          "package": "regex-pcre-builtin",
          "partial": "Exec Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "compAnchored",
          "package": "regex-pcre-builtin",
          "signature": "CompOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#compAnchored",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compAnchored\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compAnchored\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compAnchored\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compAnchored\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:compAnchored\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compAnchored",
          "package": "regex-pcre-builtin",
          "partial": "Anchored",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compAnchored"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "compAutoCallout",
          "package": "regex-pcre-builtin",
          "signature": "CompOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#compAutoCallout",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compAutoCallout\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compAutoCallout\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compAutoCallout\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compAutoCallout\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:compAutoCallout\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compAutoCallout",
          "package": "regex-pcre-builtin",
          "partial": "Auto Callout",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compAutoCallout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "compBlank",
          "package": "regex-pcre-builtin",
          "signature": "CompOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#compBlank",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compBlank\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compBlank\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compBlank\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compBlank\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:compBlank\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compBlank",
          "package": "regex-pcre-builtin",
          "partial": "Blank",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compBlank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "compCaseless",
          "package": "regex-pcre-builtin",
          "signature": "CompOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#compCaseless",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compCaseless\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compCaseless\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compCaseless\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compCaseless\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:compCaseless\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compCaseless",
          "package": "regex-pcre-builtin",
          "partial": "Caseless",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compCaseless"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "compDollarEndOnly",
          "package": "regex-pcre-builtin",
          "signature": "CompOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#compDollarEndOnly",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compDollarEndOnly\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compDollarEndOnly\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compDollarEndOnly\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compDollarEndOnly\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:compDollarEndOnly\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compDollarEndOnly",
          "package": "regex-pcre-builtin",
          "partial": "Dollar End Only",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compDollarEndOnly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "compDotAll",
          "package": "regex-pcre-builtin",
          "signature": "CompOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#compDotAll",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compDotAll\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compDotAll\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compDotAll\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compDotAll\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:compDotAll\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compDotAll",
          "package": "regex-pcre-builtin",
          "partial": "Dot All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compDotAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "compExtended",
          "package": "regex-pcre-builtin",
          "signature": "CompOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#compExtended",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compExtended\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compExtended\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compExtended\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compExtended\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:compExtended\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compExtended",
          "package": "regex-pcre-builtin",
          "partial": "Extended",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compExtended"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "compExtra",
          "package": "regex-pcre-builtin",
          "signature": "CompOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#compExtra",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compExtra\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compExtra\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compExtra\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compExtra\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:compExtra\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compExtra",
          "package": "regex-pcre-builtin",
          "partial": "Extra",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compExtra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "compFirstLine",
          "package": "regex-pcre-builtin",
          "signature": "CompOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#compFirstLine",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compFirstLine\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compFirstLine\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compFirstLine\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compFirstLine\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:compFirstLine\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compFirstLine",
          "package": "regex-pcre-builtin",
          "partial": "First Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compFirstLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "compMultiline",
          "package": "regex-pcre-builtin",
          "signature": "CompOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#compMultiline",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compMultiline\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compMultiline\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compMultiline\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compMultiline\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:compMultiline\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compMultiline",
          "package": "regex-pcre-builtin",
          "partial": "Multiline",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compMultiline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "compNoAutoCapture",
          "package": "regex-pcre-builtin",
          "signature": "CompOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#compNoAutoCapture",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compNoAutoCapture\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compNoAutoCapture\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compNoAutoCapture\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compNoAutoCapture\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:compNoAutoCapture\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compNoAutoCapture",
          "package": "regex-pcre-builtin",
          "partial": "No Auto Capture",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compNoAutoCapture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "compNoUTF8Check",
          "package": "regex-pcre-builtin",
          "signature": "CompOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#compNoUTF8Check",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compNoUTF8Check\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compNoUTF8Check\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compNoUTF8Check\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compNoUTF8Check\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:compNoUTF8Check\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compNoUTF8Check",
          "package": "regex-pcre-builtin",
          "partial": "No UTF Check",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compNoUTF8Check"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "compUTF8",
          "package": "regex-pcre-builtin",
          "signature": "CompOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#compUTF8",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compUTF8\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compUTF8\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compUTF8\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compUTF8\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:compUTF8\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compUTF8",
          "package": "regex-pcre-builtin",
          "partial": "UTF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compUTF8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "compUngreedy",
          "package": "regex-pcre-builtin",
          "signature": "CompOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#compUngreedy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compUngreedy\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compUngreedy\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compUngreedy\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compUngreedy\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:compUngreedy\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compUngreedy",
          "package": "regex-pcre-builtin",
          "partial": "Ungreedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compUngreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompiles a regular expression\n\u003c/p\u003e",
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\"]",
          "name": "compile",
          "package": "regex-pcre-builtin",
          "signature": "CompOption-\u003e ExecOption-\u003e ByteString-\u003e IO (Either (MatchOffset, String) Regex)",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compile\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:compile\"]"
        },
        "index": {
          "description": "Compiles regular expression",
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "compile",
          "normalized": "CompOption-\u003eExecOption-\u003eByteString-\u003eIO(Either(MatchOffset,String)Regex)",
          "package": "regex-pcre-builtin",
          "signature": "CompOption-\u003eExecOption-\u003eByteString-\u003eIO(Either(MatchOffset,String)Regex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:compile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "execAnchored",
          "package": "regex-pcre-builtin",
          "signature": "ExecOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#execAnchored",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execAnchored\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:execAnchored\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:execAnchored\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:execAnchored\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:execAnchored\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "execAnchored",
          "package": "regex-pcre-builtin",
          "partial": "Anchored",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execAnchored"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "execBlank",
          "package": "regex-pcre-builtin",
          "signature": "ExecOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#execBlank",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execBlank\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:execBlank\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:execBlank\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:execBlank\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:execBlank\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "execBlank",
          "package": "regex-pcre-builtin",
          "partial": "Blank",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execBlank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "execNoUTF8Check",
          "package": "regex-pcre-builtin",
          "signature": "ExecOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#execNoUTF8Check",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execNoUTF8Check\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:execNoUTF8Check\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:execNoUTF8Check\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:execNoUTF8Check\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:execNoUTF8Check\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "execNoUTF8Check",
          "package": "regex-pcre-builtin",
          "partial": "No UTF Check",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execNoUTF8Check"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "execNotBOL",
          "package": "regex-pcre-builtin",
          "signature": "ExecOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#execNotBOL",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execNotBOL\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:execNotBOL\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:execNotBOL\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:execNotBOL\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:execNotBOL\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "execNotBOL",
          "package": "regex-pcre-builtin",
          "partial": "Not BOL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execNotBOL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "execNotEOL",
          "package": "regex-pcre-builtin",
          "signature": "ExecOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#execNotEOL",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execNotEOL\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:execNotEOL\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:execNotEOL\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:execNotEOL\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:execNotEOL\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "execNotEOL",
          "package": "regex-pcre-builtin",
          "partial": "Not EOL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execNotEOL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "execNotEmpty",
          "package": "regex-pcre-builtin",
          "signature": "ExecOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#execNotEmpty",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execNotEmpty\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:execNotEmpty\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:execNotEmpty\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:execNotEmpty\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:execNotEmpty\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "execNotEmpty",
          "package": "regex-pcre-builtin",
          "partial": "Not Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execNotEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "execPartial",
          "package": "regex-pcre-builtin",
          "signature": "ExecOption",
          "source": "src/Text-Regex-PCRE-Wrap.html#execPartial",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execPartial\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:execPartial\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:execPartial\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:execPartial\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:execPartial\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "execPartial",
          "package": "regex-pcre-builtin",
          "partial": "Partial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execPartial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatches a regular expression against a buffer, returning the buffer\n indicies of the match, and any submatches\n\u003c/p\u003e\u003cp\u003e| Matches a regular expression against a string\n\u003c/p\u003e",
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\"]",
          "name": "execute",
          "package": "regex-pcre-builtin",
          "signature": "Regex-\u003e ByteString-\u003e IO (Either WrapError (Maybe (Array Int (MatchOffset, MatchLength))))",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execute\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:execute\"]"
        },
        "index": {
          "description": "Matches regular expression against buffer returning the buffer indicies of the match and any submatches Matches regular expression against string",
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "execute",
          "normalized": "Regex-\u003eByteString-\u003eIO(Either WrapError(Maybe(Array Int(MatchOffset,MatchLength))))",
          "package": "regex-pcre-builtin",
          "signature": "Regex-\u003eByteString-\u003eIO(Either WrapError(Maybe(Array Int(MatchOffset,MatchLength))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:execute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturn version of pcre used or Nothing if pcre is not available.\n\u003c/p\u003e",
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "getVersion",
          "package": "regex-pcre-builtin",
          "signature": "Maybe String",
          "source": "src/Text-Regex-PCRE-Wrap.html#getVersion",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:getVersion\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:getVersion\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:getVersion\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:getVersion\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:getVersion\"]"
        },
        "index": {
          "description": "return version of pcre used or Nothing if pcre is not available",
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "getVersion",
          "package": "regex-pcre-builtin",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:getVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\"]",
          "name": "regexec",
          "package": "regex-pcre-builtin",
          "signature": "Regex-\u003e ByteString-\u003e IO (Either WrapError (Maybe (ByteString, ByteString, ByteString, [ByteString])))",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:regexec\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:regexec\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "regexec",
          "normalized": "Regex-\u003eByteString-\u003eIO(Either WrapError(Maybe(ByteString,ByteString,ByteString,[ByteString])))",
          "package": "regex-pcre-builtin",
          "signature": "Regex-\u003eByteString-\u003eIO(Either WrapError(Maybe(ByteString,ByteString,ByteString,[ByteString])))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:regexec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PCRE.ByteString.Lazy\",\"Text.Regex.PCRE.ByteString\",\"Text.Regex.PCRE.Sequence\",\"Text.Regex.PCRE.String\",\"Text.Regex.PCRE.Wrap\"]",
          "name": "unusedOffset",
          "package": "regex-pcre-builtin",
          "signature": "MatchOffset",
          "source": "src/Text-Regex-PCRE-Wrap.html#unusedOffset",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:unusedOffset\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#v:unusedOffset\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:unusedOffset\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:unusedOffset\",\"http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:unusedOffset\"]"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString Lazy",
          "module": "Text.Regex.PCRE.ByteString.Lazy",
          "name": "unusedOffset",
          "package": "regex-pcre-builtin",
          "partial": "Offset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString-Lazy.html#v:unusedOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis exports instances of the high level API and the medium level\nAPI of \u003ccode\u003e\u003ca\u003ecompile\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eexecute\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eregexec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.PCRE.ByteString",
          "name": "ByteString",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-ByteString.html",
          "type": "module"
        },
        "index": {
          "description": "This exports instances of the high level API and the medium level API of compile execute and regexec",
          "hierarchy": "Text Regex PCRE ByteString",
          "module": "Text.Regex.PCRE.ByteString",
          "name": "ByteString",
          "package": "regex-pcre-builtin",
          "partial": "Byte String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.ByteString",
          "name": "CompOption",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#CompOption",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString",
          "module": "Text.Regex.PCRE.ByteString",
          "name": "CompOption",
          "package": "regex-pcre-builtin",
          "partial": "Comp Option",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.ByteString",
          "name": "ExecOption",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#ExecOption",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString",
          "module": "Text.Regex.PCRE.ByteString",
          "name": "ExecOption",
          "package": "regex-pcre-builtin",
          "partial": "Exec Option",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-negative length of a match\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.ByteString",
          "name": "MatchLength",
          "package": "regex-pcre-builtin",
          "type": "type"
        },
        "index": {
          "description": "non-negative length of match",
          "hierarchy": "Text Regex PCRE ByteString",
          "module": "Text.Regex.PCRE.ByteString",
          "name": "MatchLength",
          "package": "regex-pcre-builtin",
          "partial": "Match Length",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#t:MatchLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e0 based index from start of source, or (-1) for unused\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.ByteString",
          "name": "MatchOffset",
          "package": "regex-pcre-builtin",
          "type": "type"
        },
        "index": {
          "description": "based index from start of source or for unused",
          "hierarchy": "Text Regex PCRE ByteString",
          "module": "Text.Regex.PCRE.ByteString",
          "name": "MatchOffset",
          "package": "regex-pcre-builtin",
          "partial": "Match Offset",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#t:MatchOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA compiled regular expression\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.ByteString",
          "name": "Regex",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "compiled regular expression",
          "hierarchy": "Text Regex PCRE ByteString",
          "module": "Text.Regex.PCRE.ByteString",
          "name": "Regex",
          "package": "regex-pcre-builtin",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.ByteString",
          "name": "ReturnCode",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#ReturnCode",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString",
          "module": "Text.Regex.PCRE.ByteString",
          "name": "ReturnCode",
          "package": "regex-pcre-builtin",
          "partial": "Return Code",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#t:ReturnCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.ByteString",
          "name": "WrapError",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#WrapError",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex PCRE ByteString",
          "module": "Text.Regex.PCRE.ByteString",
          "name": "WrapError",
          "package": "regex-pcre-builtin",
          "partial": "Wrap Error",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-ByteString.html#t:WrapError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis exports instances of the high level API and the medium level\nAPI of \u003ccode\u003e\u003ca\u003ecompile\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eexecute\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eregexec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "Sequence",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Sequence.html",
          "type": "module"
        },
        "index": {
          "description": "This exports instances of the high level API and the medium level API of compile execute and regexec",
          "hierarchy": "Text Regex PCRE Sequence",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "Sequence",
          "package": "regex-pcre-builtin",
          "partial": "Sequence",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Sequence",
          "name": "CompOption",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#CompOption",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Sequence",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "CompOption",
          "package": "regex-pcre-builtin",
          "partial": "Comp Option",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Sequence",
          "name": "ExecOption",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#ExecOption",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Sequence",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "ExecOption",
          "package": "regex-pcre-builtin",
          "partial": "Exec Option",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-negative length of a match\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "MatchLength",
          "package": "regex-pcre-builtin",
          "type": "type"
        },
        "index": {
          "description": "non-negative length of match",
          "hierarchy": "Text Regex PCRE Sequence",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "MatchLength",
          "package": "regex-pcre-builtin",
          "partial": "Match Length",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#t:MatchLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e0 based index from start of source, or (-1) for unused\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "MatchOffset",
          "package": "regex-pcre-builtin",
          "type": "type"
        },
        "index": {
          "description": "based index from start of source or for unused",
          "hierarchy": "Text Regex PCRE Sequence",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "MatchOffset",
          "package": "regex-pcre-builtin",
          "partial": "Match Offset",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#t:MatchOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA compiled regular expression\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "Regex",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "compiled regular expression",
          "hierarchy": "Text Regex PCRE Sequence",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "Regex",
          "package": "regex-pcre-builtin",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Sequence",
          "name": "ReturnCode",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#ReturnCode",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Sequence",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "ReturnCode",
          "package": "regex-pcre-builtin",
          "partial": "Return Code",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#t:ReturnCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Sequence",
          "name": "WrapError",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#WrapError",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Sequence",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "WrapError",
          "package": "regex-pcre-builtin",
          "partial": "Wrap Error",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#t:WrapError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompiles a regular expression\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "compile",
          "package": "regex-pcre-builtin",
          "signature": "CompOption-\u003e ExecOption-\u003e Seq Char-\u003e IO (Either (MatchOffset, String) Regex)",
          "type": "function"
        },
        "index": {
          "description": "Compiles regular expression",
          "hierarchy": "Text Regex PCRE Sequence",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "compile",
          "normalized": "CompOption-\u003eExecOption-\u003eSeq Char-\u003eIO(Either(MatchOffset,String)Regex)",
          "package": "regex-pcre-builtin",
          "signature": "CompOption-\u003eExecOption-\u003eSeq Char-\u003eIO(Either(MatchOffset,String)Regex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:compile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatches a regular expression against a string\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "execute",
          "package": "regex-pcre-builtin",
          "signature": "Regex-\u003e Seq Char-\u003e IO (Either WrapError (Maybe (Array Int (MatchOffset, MatchLength))))",
          "type": "function"
        },
        "index": {
          "description": "Matches regular expression against string",
          "hierarchy": "Text Regex PCRE Sequence",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "execute",
          "normalized": "Regex-\u003eSeq Char-\u003eIO(Either WrapError(Maybe(Array Int(MatchOffset,MatchLength))))",
          "package": "regex-pcre-builtin",
          "signature": "Regex-\u003eSeq Char-\u003eIO(Either WrapError(Maybe(Array Int(MatchOffset,MatchLength))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:execute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexecute match and extract substrings rather than just offsets\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "regexec",
          "package": "regex-pcre-builtin",
          "signature": "Regex-\u003e Seq Char-\u003e IO (Either WrapError (Maybe (Seq Char, Seq Char, Seq Char, [Seq Char])))",
          "type": "function"
        },
        "index": {
          "description": "execute match and extract substrings rather than just offsets",
          "hierarchy": "Text Regex PCRE Sequence",
          "module": "Text.Regex.PCRE.Sequence",
          "name": "regexec",
          "normalized": "Regex-\u003eSeq Char-\u003eIO(Either WrapError(Maybe(Seq Char,Seq Char,Seq Char,[Seq Char])))",
          "package": "regex-pcre-builtin",
          "signature": "Regex-\u003eSeq Char-\u003eIO(Either WrapError(Maybe(Seq Char,Seq Char,Seq Char,[Seq Char])))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Sequence.html#v:regexec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis exports instances of the high level API and the medium level\nAPI of \u003ccode\u003e\u003ca\u003ecompile\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eexecute\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eregexec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.PCRE.String",
          "name": "String",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-String.html",
          "type": "module"
        },
        "index": {
          "description": "This exports instances of the high level API and the medium level API of compile execute and regexec",
          "hierarchy": "Text Regex PCRE String",
          "module": "Text.Regex.PCRE.String",
          "name": "String",
          "package": "regex-pcre-builtin",
          "partial": "String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.String",
          "name": "CompOption",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#CompOption",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex PCRE String",
          "module": "Text.Regex.PCRE.String",
          "name": "CompOption",
          "package": "regex-pcre-builtin",
          "partial": "Comp Option",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.String",
          "name": "ExecOption",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#ExecOption",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex PCRE String",
          "module": "Text.Regex.PCRE.String",
          "name": "ExecOption",
          "package": "regex-pcre-builtin",
          "partial": "Exec Option",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-negative length of a match\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.String",
          "name": "MatchLength",
          "package": "regex-pcre-builtin",
          "type": "type"
        },
        "index": {
          "description": "non-negative length of match",
          "hierarchy": "Text Regex PCRE String",
          "module": "Text.Regex.PCRE.String",
          "name": "MatchLength",
          "package": "regex-pcre-builtin",
          "partial": "Match Length",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#t:MatchLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e0 based index from start of source, or (-1) for unused\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.String",
          "name": "MatchOffset",
          "package": "regex-pcre-builtin",
          "type": "type"
        },
        "index": {
          "description": "based index from start of source or for unused",
          "hierarchy": "Text Regex PCRE String",
          "module": "Text.Regex.PCRE.String",
          "name": "MatchOffset",
          "package": "regex-pcre-builtin",
          "partial": "Match Offset",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#t:MatchOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA compiled regular expression\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.String",
          "name": "Regex",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "compiled regular expression",
          "hierarchy": "Text Regex PCRE String",
          "module": "Text.Regex.PCRE.String",
          "name": "Regex",
          "package": "regex-pcre-builtin",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.String",
          "name": "ReturnCode",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#ReturnCode",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex PCRE String",
          "module": "Text.Regex.PCRE.String",
          "name": "ReturnCode",
          "package": "regex-pcre-builtin",
          "partial": "Return Code",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#t:ReturnCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.String",
          "name": "WrapError",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#WrapError",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex PCRE String",
          "module": "Text.Regex.PCRE.String",
          "name": "WrapError",
          "package": "regex-pcre-builtin",
          "partial": "Wrap Error",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#t:WrapError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompiles a regular expression\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.String",
          "name": "compile",
          "package": "regex-pcre-builtin",
          "signature": "CompOption-\u003e ExecOption-\u003e String-\u003e IO (Either (MatchOffset, String) Regex)",
          "type": "function"
        },
        "index": {
          "description": "Compiles regular expression",
          "hierarchy": "Text Regex PCRE String",
          "module": "Text.Regex.PCRE.String",
          "name": "compile",
          "normalized": "CompOption-\u003eExecOption-\u003eString-\u003eIO(Either(MatchOffset,String)Regex)",
          "package": "regex-pcre-builtin",
          "signature": "CompOption-\u003eExecOption-\u003eString-\u003eIO(Either(MatchOffset,String)Regex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:compile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatches a regular expression against a string\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.String",
          "name": "execute",
          "package": "regex-pcre-builtin",
          "signature": "Regex-\u003e String-\u003e IO (Either WrapError (Maybe (Array Int (MatchOffset, MatchLength))))",
          "type": "function"
        },
        "index": {
          "description": "Matches regular expression against string",
          "hierarchy": "Text Regex PCRE String",
          "module": "Text.Regex.PCRE.String",
          "name": "execute",
          "normalized": "Regex-\u003eString-\u003eIO(Either WrapError(Maybe(Array Int(MatchOffset,MatchLength))))",
          "package": "regex-pcre-builtin",
          "signature": "Regex-\u003eString-\u003eIO(Either WrapError(Maybe(Array Int(MatchOffset,MatchLength))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:execute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexecute match and extract substrings rather than just offsets\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.String",
          "name": "regexec",
          "package": "regex-pcre-builtin",
          "signature": "Regex-\u003e String-\u003e IO (Either WrapError (Maybe (String, String, String, [String])))",
          "type": "function"
        },
        "index": {
          "description": "execute match and extract substrings rather than just offsets",
          "hierarchy": "Text Regex PCRE String",
          "module": "Text.Regex.PCRE.String",
          "name": "regexec",
          "normalized": "Regex-\u003eString-\u003eIO(Either WrapError(Maybe(String,String,String,[String])))",
          "package": "regex-pcre-builtin",
          "signature": "Regex-\u003eString-\u003eIO(Either WrapError(Maybe(String,String,String,[String])))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-String.html#v:regexec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis will fail or error only if allocation fails or a nullPtr is passed in.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "Wrap",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html",
          "type": "module"
        },
        "index": {
          "description": "This will fail or error only if allocation fails or nullPtr is passed in",
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "Wrap",
          "package": "regex-pcre-builtin",
          "partial": "Wrap",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "CompOption",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#CompOption",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "CompOption",
          "package": "regex-pcre-builtin",
          "partial": "Comp Option",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "EndOffset",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#EndOffset",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "EndOffset",
          "package": "regex-pcre-builtin",
          "partial": "End Offset",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#t:EndOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "ExecOption",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#ExecOption",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "ExecOption",
          "package": "regex-pcre-builtin",
          "partial": "Exec Option",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA compiled regular expression\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "Regex",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "compiled regular expression",
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "Regex",
          "package": "regex-pcre-builtin",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "ReturnCode",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#ReturnCode",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "ReturnCode",
          "package": "regex-pcre-builtin",
          "partial": "Return Code",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#t:ReturnCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "StartOffset",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#StartOffset",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "StartOffset",
          "package": "regex-pcre-builtin",
          "partial": "Start Offset",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#t:StartOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "WrapError",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE-Wrap.html#WrapError",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "WrapError",
          "package": "regex-pcre-builtin",
          "partial": "Wrap Error",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#t:WrapError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "(=~)",
          "package": "regex-pcre-builtin",
          "signature": "source1 -\u003e source -\u003e target",
          "source": "src/Text-Regex-PCRE-Wrap.html#%3D~",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "(=~) =~",
          "normalized": "a-\u003ea-\u003eb",
          "package": "regex-pcre-builtin",
          "signature": "source-\u003esource-\u003etarget",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:-61--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "(=~~)",
          "package": "regex-pcre-builtin",
          "signature": "source1 -\u003e source -\u003e m target",
          "source": "src/Text-Regex-PCRE-Wrap.html#%3D~~",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "(=~~) =~~",
          "normalized": "a-\u003ea-\u003eb c",
          "package": "regex-pcre-builtin",
          "signature": "source-\u003esource-\u003em target",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:-61--126--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "ReturnCode",
          "package": "regex-pcre-builtin",
          "signature": "ReturnCode CInt",
          "source": "src/Text-Regex-PCRE-Wrap.html#ReturnCode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "ReturnCode",
          "package": "regex-pcre-builtin",
          "partial": "Return Code",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:ReturnCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "configUTF8",
          "package": "regex-pcre-builtin",
          "signature": "Bool",
          "source": "src/Text-Regex-PCRE-Wrap.html#configUTF8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "configUTF8",
          "package": "regex-pcre-builtin",
          "partial": "UTF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:configUTF8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "getNumSubs",
          "package": "regex-pcre-builtin",
          "signature": "Regex -\u003e Int",
          "source": "src/Text-Regex-PCRE-Wrap.html#getNumSubs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "getNumSubs",
          "normalized": "Regex-\u003eInt",
          "package": "regex-pcre-builtin",
          "partial": "Num Subs",
          "signature": "Regex-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:getNumSubs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retBadMagic",
          "package": "regex-pcre-builtin",
          "signature": "ReturnCode",
          "source": "src/Text-Regex-PCRE-Wrap.html#retBadMagic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retBadMagic",
          "package": "regex-pcre-builtin",
          "partial": "Bad Magic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:retBadMagic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retBadOption",
          "package": "regex-pcre-builtin",
          "signature": "ReturnCode",
          "source": "src/Text-Regex-PCRE-Wrap.html#retBadOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retBadOption",
          "package": "regex-pcre-builtin",
          "partial": "Bad Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:retBadOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retNoMatch",
          "package": "regex-pcre-builtin",
          "signature": "ReturnCode",
          "source": "src/Text-Regex-PCRE-Wrap.html#retNoMatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retNoMatch",
          "package": "regex-pcre-builtin",
          "partial": "No Match",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:retNoMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retNoMemory",
          "package": "regex-pcre-builtin",
          "signature": "ReturnCode",
          "source": "src/Text-Regex-PCRE-Wrap.html#retNoMemory",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retNoMemory",
          "package": "regex-pcre-builtin",
          "partial": "No Memory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:retNoMemory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retNoSubstring",
          "package": "regex-pcre-builtin",
          "signature": "ReturnCode",
          "source": "src/Text-Regex-PCRE-Wrap.html#retNoSubstring",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retNoSubstring",
          "package": "regex-pcre-builtin",
          "partial": "No Substring",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:retNoSubstring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retNull",
          "package": "regex-pcre-builtin",
          "signature": "ReturnCode",
          "source": "src/Text-Regex-PCRE-Wrap.html#retNull",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retNull",
          "package": "regex-pcre-builtin",
          "partial": "Null",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:retNull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retOk",
          "package": "regex-pcre-builtin",
          "signature": "ReturnCode",
          "source": "src/Text-Regex-PCRE-Wrap.html#retOk",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retOk",
          "package": "regex-pcre-builtin",
          "partial": "Ok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:retOk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retUnknownNode",
          "package": "regex-pcre-builtin",
          "signature": "ReturnCode",
          "source": "src/Text-Regex-PCRE-Wrap.html#retUnknownNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "retUnknownNode",
          "package": "regex-pcre-builtin",
          "partial": "Unknown Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:retUnknownNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompiles a regular expression\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "wrapCompile",
          "package": "regex-pcre-builtin",
          "signature": "CompOption-\u003e ExecOption-\u003e CString-\u003e IO (Either (MatchOffset, String) Regex)",
          "type": "function"
        },
        "index": {
          "description": "Compiles regular expression",
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "wrapCompile",
          "normalized": "CompOption-\u003eExecOption-\u003eCString-\u003eIO(Either(MatchOffset,String)Regex)",
          "package": "regex-pcre-builtin",
          "partial": "Compile",
          "signature": "CompOption-\u003eExecOption-\u003eCString-\u003eIO(Either(MatchOffset,String)Regex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:wrapCompile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "wrapCount",
          "package": "regex-pcre-builtin",
          "signature": "Regex -\u003e CStringLen -\u003e IO (Either WrapError Int)",
          "source": "src/Text-Regex-PCRE-Wrap.html#wrapCount",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "wrapCount",
          "normalized": "Regex-\u003eCStringLen-\u003eIO(Either WrapError Int)",
          "package": "regex-pcre-builtin",
          "partial": "Count",
          "signature": "Regex-\u003eCStringLen-\u003eIO(Either WrapError Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:wrapCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatches a regular expression against a string\n\u003c/p\u003e\u003cp\u003eShould never return (Right (Just []))\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "wrapMatch",
          "package": "regex-pcre-builtin",
          "signature": "StartOffset-\u003e Regex-\u003e CStringLen-\u003e IO (Either WrapError (Maybe [(StartOffset, EndOffset)]))",
          "type": "function"
        },
        "index": {
          "description": "Matches regular expression against string Should never return Right Just",
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "wrapMatch",
          "normalized": "StartOffset-\u003eRegex-\u003eCStringLen-\u003eIO(Either WrapError(Maybe[(StartOffset,EndOffset)]))",
          "package": "regex-pcre-builtin",
          "partial": "Match",
          "signature": "StartOffset-\u003eRegex-\u003eCStringLen-\u003eIO(Either WrapError(Maybe[(StartOffset,EndOffset)]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:wrapMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewrapMatchAll is an improvement over wrapMatch since it only\n allocates memory with allocaBytes once at the start.\n\u003c/p\u003e",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "wrapMatchAll",
          "package": "regex-pcre-builtin",
          "signature": "Regex -\u003e CStringLen -\u003e IO (Either WrapError [MatchArray])",
          "source": "src/Text-Regex-PCRE-Wrap.html#wrapMatchAll",
          "type": "function"
        },
        "index": {
          "description": "wrapMatchAll is an improvement over wrapMatch since it only allocates memory with allocaBytes once at the start",
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "wrapMatchAll",
          "normalized": "Regex-\u003eCStringLen-\u003eIO(Either WrapError[MatchArray])",
          "package": "regex-pcre-builtin",
          "partial": "Match All",
          "signature": "Regex-\u003eCStringLen-\u003eIO(Either WrapError[MatchArray])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:wrapMatchAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE.Wrap",
          "name": "wrapTest",
          "package": "regex-pcre-builtin",
          "signature": "StartOffset-\u003e Regex-\u003e CStringLen-\u003e IO (Either WrapError Bool)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE Wrap",
          "module": "Text.Regex.PCRE.Wrap",
          "name": "wrapTest",
          "normalized": "StartOffset-\u003eRegex-\u003eCStringLen-\u003eIO(Either WrapError Bool)",
          "package": "regex-pcre-builtin",
          "partial": "Test",
          "signature": "StartOffset-\u003eRegex-\u003eCStringLen-\u003eIO(Either WrapError Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE-Wrap.html#v:wrapTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ca\u003eText.Regex.PCRE\u003c/a\u003e module provides a backend for regular\nexpressions.  If you import this along with other backends, then\nyou should do so with qualified imports, perhaps renamed for\nconvenience.\n\u003c/p\u003e\u003cp\u003eYou will need to have libpcre, from www.pcre.org, to use\nthis module.  The haskell must be compiled with -DHAVE_PCRE_H and\nlinked with pcre.  This is the default in the cabal file.\n\u003c/p\u003e\u003cp\u003eIf you do not compile with 1 then the functions will still\nexist, but using them will create a run time error.  You can test for\nthe existance of PCRE by checking \u003ccode\u003e\u003ca\u003egetVersion\u003c/a\u003e\u003c/code\u003e which is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if\nnot compiled with PCRE or \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e if PCRE is present.\n\u003c/p\u003e\u003cp\u003eUsing the provided \u003ccode\u003e\u003ca\u003eCompOption\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eExecOption\u003c/a\u003e\u003c/code\u003e values and if\n\u003ccode\u003e\u003ca\u003econfigUTF8\u003c/a\u003e\u003c/code\u003e is True, then you might be able to send UTF8 encoded\nByteStrings to PCRE and get sensible results.  This is currently\nuntested.\n\u003c/p\u003e\u003cp\u003eThe regular expression can be provided as a \u003ccode\u003eByteString\u003c/code\u003e, but it will\nbe copied and a NUL byte appended to make a \u003ccode\u003eCString\u003c/code\u003e unless such a\nbyte is already present.  Thus the regular expression cannot contain\nan explicit NUL byte. The search string is passed as a \u003ccode\u003eCStringLen\u003c/code\u003e\nand may contain NUL bytes and does not need to end in a NUL\nbyte. \u003ccode\u003eByteString\u003c/code\u003es are searched in place (via unsafeUseAsCStringLen).\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e will be converted into a \u003ccode\u003eCString\u003c/code\u003e or \u003ccode\u003eCStringLen\u003c/code\u003e for\nprocessing.  Doing this repeatedly will be very inefficient.\n\u003c/p\u003e\u003cp\u003eThe \u003ca\u003eText.Regex.PCRE.String\u003c/a\u003e, \u003ca\u003eText.Regex.PCRE.ByteString\u003c/a\u003e, and\n\u003ca\u003eText.Regex.PCRE.Wrap\u003c/a\u003e modules provides both the high level interface\nexported by this module and medium- and low-level interfaces that\nreturns error using Either structures.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.PCRE",
          "name": "PCRE",
          "package": "regex-pcre-builtin",
          "source": "src/Text-Regex-PCRE.html",
          "type": "module"
        },
        "index": {
          "description": "The Text.Regex.PCRE module provides backend for regular expressions If you import this along with other backends then you should do so with qualified imports perhaps renamed for convenience You will need to have libpcre from www.pcre.org to use this module The haskell must be compiled with DHAVE PCRE and linked with pcre This is the default in the cabal file If you do not compile with then the functions will still exist but using them will create run time error You can test for the existance of PCRE by checking getVersion which is Nothing if not compiled with PCRE or Just String if PCRE is present Using the provided CompOption and ExecOption values and if configUTF8 is True then you might be able to send UTF8 encoded ByteStrings to PCRE and get sensible results This is currently untested The regular expression can be provided as ByteString but it will be copied and NUL byte appended to make CString unless such byte is already present Thus the regular expression cannot contain an explicit NUL byte The search string is passed as CStringLen and may contain NUL bytes and does not need to end in NUL byte ByteString are searched in place via unsafeUseAsCStringLen String will be converted into CString or CStringLen for processing Doing this repeatedly will be very inefficient The Text.Regex.PCRE.String Text.Regex.PCRE.ByteString and Text.Regex.PCRE.Wrap modules provides both the high level interface exported by this module and medium and low-level interfaces that returns error using Either structures",
          "hierarchy": "Text Regex PCRE",
          "module": "Text.Regex.PCRE",
          "name": "PCRE",
          "package": "regex-pcre-builtin",
          "partial": "PCRE",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PCRE",
          "name": "getVersion_Text_Regex_PCRE",
          "package": "regex-pcre-builtin",
          "signature": "Version",
          "source": "src/Text-Regex-PCRE.html#getVersion_Text_Regex_PCRE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PCRE",
          "module": "Text.Regex.PCRE",
          "name": "getVersion_Text_Regex_PCRE",
          "package": "regex-pcre-builtin",
          "partial": "Version Text Regex PCRE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pcre-builtin/docs/Text-Regex-PCRE.html#v:getVersion_Text_Regex_PCRE"
      }
    }
  ]
]