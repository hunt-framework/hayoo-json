[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "regex-pderiv"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "LeftToRight",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRight.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "LeftToRight",
          "package": "regex-pderiv",
          "partial": "Left To Right",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "CompOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRight.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "CompOption",
          "package": "regex-pderiv",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRight.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe PDeriv backend spepcific \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e type\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "Regex",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRight.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "The PDeriv backend spepcific Regex type",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "Regex",
          "package": "regex-pderiv",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "CompOption",
          "package": "regex-pderiv",
          "signature": "CompOption",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRight.html#CompOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "CompOption",
          "package": "regex-pderiv",
          "partial": "Comp Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "signature": "ExecOption",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRight.html#ExecOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "partial": "Exec Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue by default.  Set to False to improve speed (and space).\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "captureGroups",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRight.html#ExecOption",
          "type": "function"
        },
        "index": {
          "description": "True by default Set to False to improve speed and space",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "captureGroups",
          "package": "regex-pderiv",
          "partial": "Groups",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:captureGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "caseSensitive",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRight.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "True in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "caseSensitive",
          "package": "regex-pderiv",
          "partial": "Sensitive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:caseSensitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PDeriv.ByteString.LeftToRight\",\"Text.Regex.PDeriv.ByteString.LeftToRightD\",\"Text.Regex.PDeriv.ByteString.Posix\",\"Text.Regex.PDeriv.ByteString.RightToLeft\",\"Text.Regex.PDeriv.ByteString.TwoPasses\",\"Text.Regex.PDeriv.ByteString\"]",
          "name": "compile",
          "package": "regex-pderiv",
          "signature": "CompOption-\u003e ExecOption-\u003e ByteString-\u003e Either String Regex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:compile\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:compile\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#v:compile\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:compile\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#v:compile\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#v:compile\"]"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "compile",
          "normalized": "CompOption-\u003eExecOption-\u003eByteString-\u003eEither String Regex",
          "package": "regex-pderiv",
          "signature": "CompOption-\u003eExecOption-\u003eByteString-\u003eEither String Regex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:compile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PDeriv.ByteString.LeftToRight\",\"Text.Regex.PDeriv.ByteString.LeftToRightD\",\"Text.Regex.PDeriv.ByteString.Posix\",\"Text.Regex.PDeriv.ByteString.RightToLeft\",\"Text.Regex.PDeriv.ByteString.TwoPasses\",\"Text.Regex.PDeriv.ByteString\",\"Text.Regex.PDeriv.String.LeftToRightD\",\"Text.Regex.PDeriv.String\"]",
          "name": "defaultCompOpt",
          "package": "regex-pderiv",
          "signature": "compOpt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:defaultCompOpt\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:defaultCompOpt\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#v:defaultCompOpt\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:defaultCompOpt\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#v:defaultCompOpt\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#v:defaultCompOpt\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:defaultCompOpt\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#v:defaultCompOpt\"]"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "defaultCompOpt",
          "package": "regex-pderiv",
          "partial": "Comp Opt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:defaultCompOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PDeriv.ByteString.LeftToRight\",\"Text.Regex.PDeriv.ByteString.LeftToRightD\",\"Text.Regex.PDeriv.ByteString.Posix\",\"Text.Regex.PDeriv.ByteString.RightToLeft\",\"Text.Regex.PDeriv.ByteString.TwoPasses\",\"Text.Regex.PDeriv.ByteString\",\"Text.Regex.PDeriv.String.LeftToRightD\",\"Text.Regex.PDeriv.String\"]",
          "name": "defaultExecOpt",
          "package": "regex-pderiv",
          "signature": "execOpt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:defaultExecOpt\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:defaultExecOpt\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#v:defaultExecOpt\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:defaultExecOpt\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#v:defaultExecOpt\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#v:defaultExecOpt\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:defaultExecOpt\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#v:defaultExecOpt\"]"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "defaultExecOpt",
          "package": "regex-pderiv",
          "partial": "Exec Opt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:defaultExecOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PDeriv.ByteString.LeftToRight\",\"Text.Regex.PDeriv.ByteString.LeftToRightD\",\"Text.Regex.PDeriv.ByteString.Posix\",\"Text.Regex.PDeriv.ByteString.RightToLeft\",\"Text.Regex.PDeriv.ByteString.TwoPasses\",\"Text.Regex.PDeriv.ByteString\"]",
          "name": "execute",
          "package": "regex-pderiv",
          "signature": "Regex-\u003e ByteString-\u003e Either String (Maybe Env)",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:execute\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:execute\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#v:execute\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:execute\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#v:execute\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#v:execute\"]"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "execute",
          "normalized": "Regex-\u003eByteString-\u003eEither String(Maybe Env)",
          "package": "regex-pderiv",
          "signature": "Regex-\u003eByteString-\u003eEither String(Maybe Env)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:execute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse by default.  This is POSIX correct but it takes space and is slower.\n Setting this to true will improve performance, and should be done\n if you plan to set the captureGroups execoption to False.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "lastStarGreedy",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRight.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False by default This is POSIX correct but it takes space and is slower Setting this to true will improve performance and should be done if you plan to set the captureGroups execoption to False",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "lastStarGreedy",
          "package": "regex-pderiv",
          "partial": "Star Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:lastStarGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Compile for\n    newline-sensitive matching.  \u003ca\u003eBy default, newline is a completely ordinary\n    character with no special meaning in either REs or strings.  With this flag,\n    inverted bracket expressions and . never match newline, a ^ anchor matches the\n    null string after any newline in the string in addition to its normal\n    function, and the $ anchor matches the null string before any newline in the\n    string in addition to its normal function.\u003c/a\u003e \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "multiline",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRight.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Compile for newline-sensitive matching By default newline is completely ordinary character with no special meaning in either REs or strings With this flag inverted bracket expressions and never match newline anchor matches the null string after any newline in the string in addition to its normal function and the anchor matches the null string before any newline in the string in addition to its normal function",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "multiline",
          "package": "regex-pderiv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:multiline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "newSyntax",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRight.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "newSyntax",
          "package": "regex-pderiv",
          "partial": "Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:newSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PDeriv.ByteString.LeftToRight\",\"Text.Regex.PDeriv.ByteString.LeftToRightD\",\"Text.Regex.PDeriv.ByteString.Posix\",\"Text.Regex.PDeriv.ByteString.RightToLeft\",\"Text.Regex.PDeriv.ByteString.TwoPasses\",\"Text.Regex.PDeriv.ByteString\"]",
          "name": "regexec",
          "package": "regex-pderiv",
          "signature": "Regex-\u003e ByteString-\u003e Either String (Maybe (ByteString, ByteString, ByteString, [ByteString]))",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:regexec\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:regexec\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#v:regexec\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:regexec\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#v:regexec\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#v:regexec\"]"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "regexec",
          "normalized": "Regex-\u003eByteString-\u003eEither String(Maybe(ByteString,ByteString,ByteString,[ByteString]))",
          "package": "regex-pderiv",
          "signature": "Regex-\u003eByteString-\u003eEither String(Maybe(ByteString,ByteString,ByteString,[ByteString]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:regexec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue (and therefore Right associative) in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "rightAssoc",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRight.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "True and therefore Right associative in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRight",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRight",
          "name": "rightAssoc",
          "package": "regex-pderiv",
          "partial": "Assoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRight.html#v:rightAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "LeftToRightD",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString LeftToRightD",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "LeftToRightD",
          "package": "regex-pderiv",
          "partial": "Left To Right",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "CompOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRightD",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "CompOption",
          "package": "regex-pderiv",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString LeftToRightD",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe PDeriv backend spepcific \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e type\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "Regex",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "The PDeriv backend spepcific Regex type",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRightD",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "Regex",
          "package": "regex-pderiv",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PDeriv.ByteString.LeftToRightD\",\"Text.Regex.PDeriv.ByteString\"]",
          "name": "CompOption",
          "package": "regex-pderiv",
          "signature": "CompOption",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:CompOption\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#v:CompOption\"]"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString LeftToRightD",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "CompOption",
          "package": "regex-pderiv",
          "partial": "Comp Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PDeriv.ByteString.LeftToRightD\",\"Text.Regex.PDeriv.ByteString\"]",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "signature": "ExecOption",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html#ExecOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:ExecOption\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#v:ExecOption\"]"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString LeftToRightD",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "partial": "Exec Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue by default.  Set to False to improve speed (and space).\n\u003c/p\u003e",
          "module": "[\"Text.Regex.PDeriv.ByteString.LeftToRightD\",\"Text.Regex.PDeriv.ByteString\"]",
          "name": "captureGroups",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html#ExecOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:captureGroups\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#v:captureGroups\"]"
        },
        "index": {
          "description": "True by default Set to False to improve speed and space",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRightD",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "captureGroups",
          "package": "regex-pderiv",
          "partial": "Groups",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:captureGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "[\"Text.Regex.PDeriv.ByteString.LeftToRightD\",\"Text.Regex.PDeriv.ByteString\"]",
          "name": "caseSensitive",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:caseSensitive\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#v:caseSensitive\"]"
        },
        "index": {
          "description": "True in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRightD",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "caseSensitive",
          "package": "regex-pderiv",
          "partial": "Sensitive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:caseSensitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse by default.  This is POSIX correct but it takes space and is slower.\n Setting this to true will improve performance, and should be done\n if you plan to set the captureGroups execoption to False.\n\u003c/p\u003e",
          "module": "[\"Text.Regex.PDeriv.ByteString.LeftToRightD\",\"Text.Regex.PDeriv.ByteString\"]",
          "name": "lastStarGreedy",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:lastStarGreedy\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#v:lastStarGreedy\"]"
        },
        "index": {
          "description": "False by default This is POSIX correct but it takes space and is slower Setting this to true will improve performance and should be done if you plan to set the captureGroups execoption to False",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRightD",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "lastStarGreedy",
          "package": "regex-pderiv",
          "partial": "Star Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:lastStarGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Compile for\n    newline-sensitive matching.  \u003ca\u003eBy default, newline is a completely ordinary\n    character with no special meaning in either REs or strings.  With this flag,\n    inverted bracket expressions and . never match newline, a ^ anchor matches the\n    null string after any newline in the string in addition to its normal\n    function, and the $ anchor matches the null string before any newline in the\n    string in addition to its normal function.\u003c/a\u003e \n\u003c/p\u003e",
          "module": "[\"Text.Regex.PDeriv.ByteString.LeftToRightD\",\"Text.Regex.PDeriv.ByteString\"]",
          "name": "multiline",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:multiline\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#v:multiline\"]"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Compile for newline-sensitive matching By default newline is completely ordinary character with no special meaning in either REs or strings With this flag inverted bracket expressions and never match newline anchor matches the null string after any newline in the string in addition to its normal function and the anchor matches the null string before any newline in the string in addition to its normal function",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRightD",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "multiline",
          "package": "regex-pderiv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:multiline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. \n\u003c/p\u003e",
          "module": "[\"Text.Regex.PDeriv.ByteString.LeftToRightD\",\"Text.Regex.PDeriv.ByteString\"]",
          "name": "newSyntax",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:newSyntax\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#v:newSyntax\"]"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRightD",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "newSyntax",
          "package": "regex-pderiv",
          "partial": "Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:newSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue (and therefore Right associative) in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "[\"Text.Regex.PDeriv.ByteString.LeftToRightD\",\"Text.Regex.PDeriv.ByteString\"]",
          "name": "rightAssoc",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:rightAssoc\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#v:rightAssoc\"]"
        },
        "index": {
          "description": "True and therefore Right associative in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex PDeriv ByteString LeftToRightD",
          "module": "Text.Regex.PDeriv.ByteString.LeftToRightD",
          "name": "rightAssoc",
          "package": "regex-pderiv",
          "partial": "Assoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-LeftToRightD.html#v:rightAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "Posix",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-Posix.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString Posix",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "Posix",
          "package": "regex-pderiv",
          "partial": "Posix",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "CompOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-Posix.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex PDeriv ByteString Posix",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "CompOption",
          "package": "regex-pderiv",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-Posix.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString Posix",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe PDeriv backend spepcific \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e type\n | the IntMap keeps track of the auxillary binder generated because of posix matching, i.e. all sub expressions need to be tag\n | the FollowBy keeps track of the order of the pattern binder \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "Regex",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-Posix.html#Regex",
          "type": "type"
        },
        "index": {
          "description": "The PDeriv backend spepcific Regex type the IntMap keeps track of the auxillary binder generated because of posix matching i.e all sub expressions need to be tag the FollowBy keeps track of the order of the pattern binder",
          "hierarchy": "Text Regex PDeriv ByteString Posix",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "Regex",
          "package": "regex-pderiv",
          "partial": "Regex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "CompOption",
          "package": "regex-pderiv",
          "signature": "CompOption",
          "source": "src/Text-Regex-PDeriv-ByteString-Posix.html#CompOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString Posix",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "CompOption",
          "package": "regex-pderiv",
          "partial": "Comp Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#v:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "signature": "ExecOption",
          "source": "src/Text-Regex-PDeriv-ByteString-Posix.html#ExecOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString Posix",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "partial": "Exec Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#v:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue by default.  Set to False to improve speed (and space).\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "captureGroups",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-Posix.html#ExecOption",
          "type": "function"
        },
        "index": {
          "description": "True by default Set to False to improve speed and space",
          "hierarchy": "Text Regex PDeriv ByteString Posix",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "captureGroups",
          "package": "regex-pderiv",
          "partial": "Groups",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#v:captureGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "caseSensitive",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-Posix.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "True in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex PDeriv ByteString Posix",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "caseSensitive",
          "package": "regex-pderiv",
          "partial": "Sensitive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#v:caseSensitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse by default.  This is POSIX correct but it takes space and is slower.\n Setting this to true will improve performance, and should be done\n if you plan to set the captureGroups execoption to False.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "lastStarGreedy",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-Posix.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False by default This is POSIX correct but it takes space and is slower Setting this to true will improve performance and should be done if you plan to set the captureGroups execoption to False",
          "hierarchy": "Text Regex PDeriv ByteString Posix",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "lastStarGreedy",
          "package": "regex-pderiv",
          "partial": "Star Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#v:lastStarGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Compile for\n    newline-sensitive matching.  \u003ca\u003eBy default, newline is a completely ordinary\n    character with no special meaning in either REs or strings.  With this flag,\n    inverted bracket expressions and . never match newline, a ^ anchor matches the\n    null string after any newline in the string in addition to its normal\n    function, and the $ anchor matches the null string before any newline in the\n    string in addition to its normal function.\u003c/a\u003e \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "multiline",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-Posix.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Compile for newline-sensitive matching By default newline is completely ordinary character with no special meaning in either REs or strings With this flag inverted bracket expressions and never match newline anchor matches the null string after any newline in the string in addition to its normal function and the anchor matches the null string before any newline in the string in addition to its normal function",
          "hierarchy": "Text Regex PDeriv ByteString Posix",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "multiline",
          "package": "regex-pderiv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#v:multiline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Add the extended non-POSIX syntax described in \u003ca\u003eText.Regex.TDFA\u003c/a\u003e haddock documentation.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "newSyntax",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-Posix.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Add the extended non-POSIX syntax described in Text.Regex.TDFA haddock documentation",
          "hierarchy": "Text Regex PDeriv ByteString Posix",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "newSyntax",
          "package": "regex-pderiv",
          "partial": "Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#v:newSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue (and therefore Right associative) in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "rightAssoc",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-Posix.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "True and therefore Right associative in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex PDeriv ByteString Posix",
          "module": "Text.Regex.PDeriv.ByteString.Posix",
          "name": "rightAssoc",
          "package": "regex-pderiv",
          "partial": "Assoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-Posix.html#v:rightAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "RightToLeft",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-RightToLeft.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString RightToLeft",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "RightToLeft",
          "package": "regex-pderiv",
          "partial": "Right To Left",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "CompOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-RightToLeft.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex PDeriv ByteString RightToLeft",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "CompOption",
          "package": "regex-pderiv",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-RightToLeft.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString RightToLeft",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe PDeriv backend spepcific \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e type\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "Regex",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-RightToLeft.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "The PDeriv backend spepcific Regex type",
          "hierarchy": "Text Regex PDeriv ByteString RightToLeft",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "Regex",
          "package": "regex-pderiv",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "CompOption",
          "package": "regex-pderiv",
          "signature": "CompOption",
          "source": "src/Text-Regex-PDeriv-ByteString-RightToLeft.html#CompOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString RightToLeft",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "CompOption",
          "package": "regex-pderiv",
          "partial": "Comp Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "signature": "ExecOption",
          "source": "src/Text-Regex-PDeriv-ByteString-RightToLeft.html#ExecOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString RightToLeft",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "partial": "Exec Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue by default.  Set to False to improve speed (and space).\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "captureGroups",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-RightToLeft.html#ExecOption",
          "type": "function"
        },
        "index": {
          "description": "True by default Set to False to improve speed and space",
          "hierarchy": "Text Regex PDeriv ByteString RightToLeft",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "captureGroups",
          "package": "regex-pderiv",
          "partial": "Groups",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:captureGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "caseSensitive",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-RightToLeft.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "True in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex PDeriv ByteString RightToLeft",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "caseSensitive",
          "package": "regex-pderiv",
          "partial": "Sensitive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:caseSensitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse by default.  This is POSIX correct but it takes space and is slower.\n Setting this to true will improve performance, and should be done\n if you plan to set the captureGroups execoption to False.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "lastStarGreedy",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-RightToLeft.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False by default This is POSIX correct but it takes space and is slower Setting this to true will improve performance and should be done if you plan to set the captureGroups execoption to False",
          "hierarchy": "Text Regex PDeriv ByteString RightToLeft",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "lastStarGreedy",
          "package": "regex-pderiv",
          "partial": "Star Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:lastStarGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Compile for\n    newline-sensitive matching.  \u003ca\u003eBy default, newline is a completely ordinary\n    character with no special meaning in either REs or strings.  With this flag,\n    inverted bracket expressions and . never match newline, a ^ anchor matches the\n    null string after any newline in the string in addition to its normal\n    function, and the $ anchor matches the null string before any newline in the\n    string in addition to its normal function.\u003c/a\u003e \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "multiline",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-RightToLeft.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Compile for newline-sensitive matching By default newline is completely ordinary character with no special meaning in either REs or strings With this flag inverted bracket expressions and never match newline anchor matches the null string after any newline in the string in addition to its normal function and the anchor matches the null string before any newline in the string in addition to its normal function",
          "hierarchy": "Text Regex PDeriv ByteString RightToLeft",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "multiline",
          "package": "regex-pderiv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:multiline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Add the extended non-POSIX syntax described in \u003ca\u003eText.Regex.TDFA\u003c/a\u003e haddock documentation.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "newSyntax",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-RightToLeft.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Add the extended non-POSIX syntax described in Text.Regex.TDFA haddock documentation",
          "hierarchy": "Text Regex PDeriv ByteString RightToLeft",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "newSyntax",
          "package": "regex-pderiv",
          "partial": "Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:newSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PDeriv.ByteString.RightToLeft\",\"Text.Regex.PDeriv.Parse\"]",
          "name": "parsePat",
          "package": "regex-pderiv",
          "signature": "String -\u003e Either ParseError Pat",
          "source": "src/Text-Regex-PDeriv-Parse.html#parsePat",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:parsePat\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Parse.html#v:parsePat\"]"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString RightToLeft",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "parsePat",
          "normalized": "String-\u003eEither ParseError Pat",
          "package": "regex-pderiv",
          "partial": "Pat",
          "signature": "String-\u003eEither ParseError Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:parsePat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue (and therefore Right associative) in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "rightAssoc",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-RightToLeft.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "True and therefore Right associative in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex PDeriv ByteString RightToLeft",
          "module": "Text.Regex.PDeriv.ByteString.RightToLeft",
          "name": "rightAssoc",
          "package": "regex-pderiv",
          "partial": "Assoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-RightToLeft.html#v:rightAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "TwoPasses",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-TwoPasses.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString TwoPasses",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "TwoPasses",
          "package": "regex-pderiv",
          "partial": "Two Passes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "CompOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-TwoPasses.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex PDeriv ByteString TwoPasses",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "CompOption",
          "package": "regex-pderiv",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-TwoPasses.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString TwoPasses",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "Regex",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-TwoPasses.html#Regex",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString TwoPasses",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "Regex",
          "package": "regex-pderiv",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "CompOption",
          "package": "regex-pderiv",
          "signature": "CompOption",
          "source": "src/Text-Regex-PDeriv-ByteString-TwoPasses.html#CompOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString TwoPasses",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "CompOption",
          "package": "regex-pderiv",
          "partial": "Comp Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#v:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "signature": "ExecOption",
          "source": "src/Text-Regex-PDeriv-ByteString-TwoPasses.html#ExecOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString TwoPasses",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "partial": "Exec Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#v:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue by default.  Set to False to improve speed (and space).\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "captureGroups",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-TwoPasses.html#ExecOption",
          "type": "function"
        },
        "index": {
          "description": "True by default Set to False to improve speed and space",
          "hierarchy": "Text Regex PDeriv ByteString TwoPasses",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "captureGroups",
          "package": "regex-pderiv",
          "partial": "Groups",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#v:captureGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "caseSensitive",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-TwoPasses.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "True in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex PDeriv ByteString TwoPasses",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "caseSensitive",
          "package": "regex-pderiv",
          "partial": "Sensitive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#v:caseSensitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse by default.  This is POSIX correct but it takes space and is slower.\n Setting this to true will improve performance, and should be done\n if you plan to set the captureGroups execoption to False.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "lastStarGreedy",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-TwoPasses.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False by default This is POSIX correct but it takes space and is slower Setting this to true will improve performance and should be done if you plan to set the captureGroups execoption to False",
          "hierarchy": "Text Regex PDeriv ByteString TwoPasses",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "lastStarGreedy",
          "package": "regex-pderiv",
          "partial": "Star Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#v:lastStarGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Compile for\n    newline-sensitive matching.  \u003ca\u003eBy default, newline is a completely ordinary\n    character with no special meaning in either REs or strings.  With this flag,\n    inverted bracket expressions and . never match newline, a ^ anchor matches the\n    null string after any newline in the string in addition to its normal\n    function, and the $ anchor matches the null string before any newline in the\n    string in addition to its normal function.\u003c/a\u003e \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "multiline",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-TwoPasses.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Compile for newline-sensitive matching By default newline is completely ordinary character with no special meaning in either REs or strings With this flag inverted bracket expressions and never match newline anchor matches the null string after any newline in the string in addition to its normal function and the anchor matches the null string before any newline in the string in addition to its normal function",
          "hierarchy": "Text Regex PDeriv ByteString TwoPasses",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "multiline",
          "package": "regex-pderiv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#v:multiline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Add the extended non-POSIX syntax described in \u003ca\u003eText.Regex.TDFA\u003c/a\u003e haddock documentation.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "newSyntax",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-TwoPasses.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Add the extended non-POSIX syntax described in Text.Regex.TDFA haddock documentation",
          "hierarchy": "Text Regex PDeriv ByteString TwoPasses",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "newSyntax",
          "package": "regex-pderiv",
          "partial": "Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#v:newSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue (and therefore Right associative) in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "rightAssoc",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-ByteString-TwoPasses.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "True and therefore Right associative in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex PDeriv ByteString TwoPasses",
          "module": "Text.Regex.PDeriv.ByteString.TwoPasses",
          "name": "rightAssoc",
          "package": "regex-pderiv",
          "partial": "Assoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString-TwoPasses.html#v:rightAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString",
          "name": "ByteString",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString",
          "module": "Text.Regex.PDeriv.ByteString",
          "name": "ByteString",
          "package": "regex-pderiv",
          "partial": "Byte String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString",
          "name": "CompOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex PDeriv ByteString",
          "module": "Text.Regex.PDeriv.ByteString",
          "name": "CompOption",
          "package": "regex-pderiv",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ByteString",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ByteString",
          "module": "Text.Regex.PDeriv.ByteString",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe PDeriv backend spepcific \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e type\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ByteString",
          "name": "Regex",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ByteString-LeftToRightD.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "The PDeriv backend spepcific Regex type",
          "hierarchy": "Text Regex PDeriv ByteString",
          "module": "Text.Regex.PDeriv.ByteString",
          "name": "Regex",
          "package": "regex-pderiv",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ByteString.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ethis module contains the defs of common data types and type classes\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.PDeriv.Common",
          "name": "Common",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Common.html",
          "type": "module"
        },
        "index": {
          "description": "this module contains the defs of common data types and type classes",
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "Common",
          "package": "regex-pderiv",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe greediness flag\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Common",
          "name": "GFlag",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Common.html#GFlag",
          "type": "data"
        },
        "index": {
          "description": "The greediness flag",
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "GFlag",
          "package": "regex-pderiv",
          "partial": "GFlag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#t:GFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for epsilon == a\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Common",
          "name": "IsEpsilon",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Common.html#IsEpsilon",
          "type": "class"
        },
        "index": {
          "description": "test for epsilon",
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "IsEpsilon",
          "package": "regex-pderiv",
          "partial": "Is Epsilon",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#t:IsEpsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "IsGreedy",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Common.html#IsGreedy",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "IsGreedy",
          "package": "regex-pderiv",
          "partial": "Is Greedy",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#t:IsGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for phi == a\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Common",
          "name": "IsPhi",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Common.html#IsPhi",
          "type": "class"
        },
        "index": {
          "description": "test for phi",
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "IsPhi",
          "package": "regex-pderiv",
          "partial": "Is Phi",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#t:IsPhi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea character and its index (position)\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Common",
          "name": "Letter",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Common.html#Letter",
          "type": "type"
        },
        "index": {
          "description": "character and its index position",
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "Letter",
          "package": "regex-pderiv",
          "partial": "Letter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#t:Letter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for 'epsilon in a' epsilon-possession\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Common",
          "name": "PosEpsilon",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Common.html#PosEpsilon",
          "type": "class"
        },
        "index": {
          "description": "test for epsilon in epsilon-possession",
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "PosEpsilon",
          "package": "regex-pderiv",
          "partial": "Pos Epsilon",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#t:PosEpsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(sub)words represent by range\n type Range  = (Int,Int)      \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Common",
          "name": "Range",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Common.html#Range",
          "type": "data"
        },
        "index": {
          "description": "sub words represent by range type Range Int Int",
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "Range",
          "package": "regex-pderiv",
          "partial": "Range",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#t:Range"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "Simplifiable",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Common.html#Simplifiable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "Simplifiable",
          "package": "regex-pderiv",
          "partial": "Simplifiable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#t:Simplifiable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egreedy\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Common",
          "name": "Greedy",
          "package": "regex-pderiv",
          "signature": "Greedy",
          "source": "src/Text-Regex-PDeriv-Common.html#GFlag",
          "type": "function"
        },
        "index": {
          "description": "greedy",
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "Greedy",
          "package": "regex-pderiv",
          "partial": "Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:Greedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enot greedy\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Common",
          "name": "NotGreedy",
          "package": "regex-pderiv",
          "signature": "NotGreedy",
          "source": "src/Text-Regex-PDeriv-Common.html#GFlag",
          "type": "function"
        },
        "index": {
          "description": "not greedy",
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "NotGreedy",
          "package": "regex-pderiv",
          "partial": "Not Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:NotGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "Range",
          "package": "regex-pderiv",
          "signature": "Range !Int !Int",
          "source": "src/Text-Regex-PDeriv-Common.html#Range",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "Range",
          "package": "regex-pderiv",
          "partial": "Range",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:Range"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "isEpsilon",
          "package": "regex-pderiv",
          "signature": "a -\u003e Bool",
          "source": "src/Text-Regex-PDeriv-Common.html#isEpsilon",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "isEpsilon",
          "normalized": "a-\u003eBool",
          "package": "regex-pderiv",
          "partial": "Epsilon",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:isEpsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "isGreedy",
          "package": "regex-pderiv",
          "signature": "a -\u003e Bool",
          "source": "src/Text-Regex-PDeriv-Common.html#isGreedy",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "isGreedy",
          "normalized": "a-\u003eBool",
          "package": "regex-pderiv",
          "partial": "Greedy",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:isGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "isPhi",
          "package": "regex-pderiv",
          "signature": "a -\u003e Bool",
          "source": "src/Text-Regex-PDeriv-Common.html#isPhi",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "isPhi",
          "normalized": "a-\u003eBool",
          "package": "regex-pderiv",
          "partial": "Phi",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:isPhi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "mainBinder",
          "package": "regex-pderiv",
          "signature": "Int",
          "source": "src/Text-Regex-PDeriv-Common.html#mainBinder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "mainBinder",
          "package": "regex-pderiv",
          "partial": "Binder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:mainBinder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "maxRange",
          "package": "regex-pderiv",
          "signature": "(a, b) -\u003e b",
          "source": "src/Text-Regex-PDeriv-Common.html#maxRange",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "maxRange",
          "normalized": "(a,b)-\u003eb",
          "package": "regex-pderiv",
          "partial": "Range",
          "signature": "(a,b)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:maxRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "minRange",
          "package": "regex-pderiv",
          "signature": "(a, b) -\u003e a",
          "source": "src/Text-Regex-PDeriv-Common.html#minRange",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "minRange",
          "normalized": "(a,b)-\u003ea",
          "package": "regex-pderiv",
          "partial": "Range",
          "signature": "(a,b)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:minRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "my_hash",
          "package": "regex-pderiv",
          "signature": "Int -\u003e Char -\u003e Int",
          "source": "src/Text-Regex-PDeriv-Common.html#my_hash",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "my_hash",
          "normalized": "Int-\u003eChar-\u003eInt",
          "package": "regex-pderiv",
          "signature": "Int-\u003eChar-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:my_hash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "my_lookup",
          "package": "regex-pderiv",
          "signature": "Int -\u003e Char -\u003e IntMap [Int] -\u003e [Int]",
          "source": "src/Text-Regex-PDeriv-Common.html#my_lookup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "my_lookup",
          "normalized": "Int-\u003eChar-\u003eIntMap[Int]-\u003e[Int]",
          "package": "regex-pderiv",
          "signature": "Int-\u003eChar-\u003eIntMap[Int]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:my_lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremove duplications in a list of pairs, using the first components as key.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Common",
          "name": "nub2",
          "package": "regex-pderiv",
          "signature": "[(Int, a)] -\u003e [(Int, a)]",
          "source": "src/Text-Regex-PDeriv-Common.html#nub2",
          "type": "function"
        },
        "index": {
          "description": "remove duplications in list of pairs using the first components as key",
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "nub2",
          "normalized": "[(Int,a)]-\u003e[(Int,a)]",
          "package": "regex-pderiv",
          "signature": "[(Int,a)]-\u003e[(Int,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:nub2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "nub3",
          "package": "regex-pderiv",
          "signature": "[(Int, a, Int)] -\u003e [(Int, a, Int)]",
          "source": "src/Text-Regex-PDeriv-Common.html#nub3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "nub3",
          "normalized": "[(Int,a,Int)]-\u003e[(Int,a,Int)]",
          "package": "regex-pderiv",
          "signature": "[(Int,a,Int)]-\u003e[(Int,a,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:nub3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "posEpsilon",
          "package": "regex-pderiv",
          "signature": "a -\u003e Bool",
          "source": "src/Text-Regex-PDeriv-Common.html#posEpsilon",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "posEpsilon",
          "normalized": "a-\u003eBool",
          "package": "regex-pderiv",
          "partial": "Epsilon",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:posEpsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "preBinder",
          "package": "regex-pderiv",
          "signature": "Int",
          "source": "src/Text-Regex-PDeriv-Common.html#preBinder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "preBinder",
          "package": "regex-pderiv",
          "partial": "Binder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:preBinder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "preBinder_",
          "package": "regex-pderiv",
          "signature": "Int",
          "source": "src/Text-Regex-PDeriv-Common.html#preBinder_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "preBinder_",
          "package": "regex-pderiv",
          "partial": "Binder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:preBinder_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "range",
          "package": "regex-pderiv",
          "signature": "Int -\u003e Int -\u003e Range",
          "source": "src/Text-Regex-PDeriv-Common.html#range",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "range",
          "normalized": "Int-\u003eInt-\u003eRange",
          "package": "regex-pderiv",
          "signature": "Int-\u003eInt-\u003eRange",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:range"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "simplify",
          "package": "regex-pderiv",
          "signature": "a -\u003e a",
          "source": "src/Text-Regex-PDeriv-Common.html#simplify",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "simplify",
          "normalized": "a-\u003ea",
          "package": "regex-pderiv",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:simplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Common",
          "name": "subBinder",
          "package": "regex-pderiv",
          "signature": "Int",
          "source": "src/Text-Regex-PDeriv-Common.html#subBinder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Common",
          "module": "Text.Regex.PDeriv.Common",
          "name": "subBinder",
          "package": "regex-pderiv",
          "partial": "Binder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Common.html#v:subBinder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module that implements a dictionary/hash table\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "Dictionary",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Dictionary.html",
          "type": "module"
        },
        "index": {
          "description": "module that implements dictionary hash table",
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "Dictionary",
          "package": "regex-pderiv",
          "partial": "Dictionary",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "Dictionary",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#Dictionary",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "Dictionary",
          "package": "regex-pderiv",
          "partial": "Dictionary",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#t:Dictionary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "Key",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#Key",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "Key",
          "package": "regex-pderiv",
          "partial": "Key",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#t:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "Trie",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#Trie",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "Trie",
          "package": "regex-pderiv",
          "partial": "Trie",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#t:Trie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "Dictionary",
          "package": "regex-pderiv",
          "signature": "Dictionary (Trie a)",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#Dictionary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "Dictionary",
          "package": "regex-pderiv",
          "partial": "Dictionary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:Dictionary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "Trie",
          "package": "regex-pderiv",
          "signature": "Trie ![a] !(IntMap (Trie a))",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#Trie",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "Trie",
          "normalized": "Trie[a](IntMap(Trie a))",
          "package": "regex-pderiv",
          "partial": "Trie",
          "signature": "Trie[a](IntMap(Trie a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:Trie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "empty",
          "package": "regex-pderiv",
          "signature": "Dictionary a",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#empty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "empty",
          "package": "regex-pderiv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "emptyTrie",
          "package": "regex-pderiv",
          "signature": "Trie a",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#emptyTrie",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "emptyTrie",
          "package": "regex-pderiv",
          "partial": "Trie",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:emptyTrie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "fromList",
          "package": "regex-pderiv",
          "signature": "[(k, a)] -\u003e Dictionary a",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "fromList",
          "normalized": "[(a,b)]-\u003eDictionary b",
          "package": "regex-pderiv",
          "partial": "List",
          "signature": "[(k,a)]-\u003eDictionary a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "fromListNotOverwrite",
          "package": "regex-pderiv",
          "signature": "[(k, a)] -\u003e Dictionary a",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#fromListNotOverwrite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "fromListNotOverwrite",
          "normalized": "[(a,b)]-\u003eDictionary b",
          "package": "regex-pderiv",
          "partial": "List Not Overwrite",
          "signature": "[(k,a)]-\u003eDictionary a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:fromListNotOverwrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "hash",
          "package": "regex-pderiv",
          "signature": "a -\u003e [Int]",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#hash",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "hash",
          "normalized": "a-\u003e[Int]",
          "package": "regex-pderiv",
          "signature": "a-\u003e[Int]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:hash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "insert",
          "package": "regex-pderiv",
          "signature": "k -\u003e a -\u003e Dictionary a -\u003e Dictionary a",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#insert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "insert",
          "normalized": "a-\u003eb-\u003eDictionary b-\u003eDictionary b",
          "package": "regex-pderiv",
          "signature": "k-\u003ea-\u003eDictionary a-\u003eDictionary a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "insertNotOverwrite",
          "package": "regex-pderiv",
          "signature": "k -\u003e a -\u003e Dictionary a -\u003e Dictionary a",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#insertNotOverwrite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "insertNotOverwrite",
          "normalized": "a-\u003eb-\u003eDictionary b-\u003eDictionary b",
          "package": "regex-pderiv",
          "partial": "Not Overwrite",
          "signature": "k-\u003ea-\u003eDictionary a-\u003eDictionary a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:insertNotOverwrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "insertTrie",
          "package": "regex-pderiv",
          "signature": "Bool -\u003e [Int] -\u003e a -\u003e Trie a -\u003e Trie a",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#insertTrie",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "insertTrie",
          "normalized": "Bool-\u003e[Int]-\u003ea-\u003eTrie a-\u003eTrie a",
          "package": "regex-pderiv",
          "partial": "Trie",
          "signature": "Bool-\u003e[Int]-\u003ea-\u003eTrie a-\u003eTrie a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:insertTrie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "isIn",
          "package": "regex-pderiv",
          "signature": "k -\u003e Dictionary (k, a) -\u003e Bool",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#isIn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "isIn",
          "normalized": "a-\u003eDictionary(a,b)-\u003eBool",
          "package": "regex-pderiv",
          "partial": "In",
          "signature": "k-\u003eDictionary(k,a)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:isIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "lookup",
          "package": "regex-pderiv",
          "signature": "k -\u003e Dictionary a -\u003e Maybe a",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#lookup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "lookup",
          "normalized": "a-\u003eDictionary b-\u003eMaybe b",
          "package": "regex-pderiv",
          "signature": "k-\u003eDictionary a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "lookupAll",
          "package": "regex-pderiv",
          "signature": "k -\u003e Dictionary a -\u003e [a]",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#lookupAll",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "lookupAll",
          "normalized": "a-\u003eDictionary b-\u003e[b]",
          "package": "regex-pderiv",
          "partial": "All",
          "signature": "k-\u003eDictionary a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:lookupAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "lookupTrie",
          "package": "regex-pderiv",
          "signature": "[Int] -\u003e Trie a -\u003e Maybe (Trie a)",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#lookupTrie",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "lookupTrie",
          "normalized": "[Int]-\u003eTrie a-\u003eMaybe(Trie a)",
          "package": "regex-pderiv",
          "partial": "Trie",
          "signature": "[Int]-\u003eTrie a-\u003eMaybe(Trie a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:lookupTrie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "nub",
          "package": "regex-pderiv",
          "signature": "[k] -\u003e [k]",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#nub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "nub",
          "normalized": "[a]-\u003e[a]",
          "package": "regex-pderiv",
          "signature": "[k]-\u003e[k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:nub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "nubSub",
          "package": "regex-pderiv",
          "signature": "[k] -\u003e Dictionary (k, ()) -\u003e [k]",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#nubSub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "nubSub",
          "normalized": "[a]-\u003eDictionary(a,())-\u003e[a]",
          "package": "regex-pderiv",
          "partial": "Sub",
          "signature": "[k]-\u003eDictionary(k,())-\u003e[k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:nubSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "primeL",
          "package": "regex-pderiv",
          "signature": "Int",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#primeL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "primeL",
          "package": "regex-pderiv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:primeL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "primeR",
          "package": "regex-pderiv",
          "signature": "Int",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#primeR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "primeR",
          "package": "regex-pderiv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:primeR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe dictionary (k,a) version of elem\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "update",
          "package": "regex-pderiv",
          "signature": "k -\u003e a -\u003e Dictionary a -\u003e Dictionary a",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#update",
          "type": "function"
        },
        "index": {
          "description": "the dictionary version of elem",
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "update",
          "normalized": "a-\u003eb-\u003eDictionary b-\u003eDictionary b",
          "package": "regex-pderiv",
          "signature": "k-\u003ea-\u003eDictionary a-\u003eDictionary a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "updateTrie",
          "package": "regex-pderiv",
          "signature": "[Int] -\u003e a -\u003e Trie a -\u003e Trie a",
          "source": "src/Text-Regex-PDeriv-Dictionary.html#updateTrie",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Dictionary",
          "module": "Text.Regex.PDeriv.Dictionary",
          "name": "updateTrie",
          "normalized": "[Int]-\u003ea-\u003eTrie a-\u003eTrie a",
          "package": "regex-pderiv",
          "partial": "Trie",
          "signature": "[Int]-\u003ea-\u003eTrie a-\u003eTrie a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Dictionary.html#v:updateTrie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "ExtPattern",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "ExtPattern",
          "package": "regex-pderiv",
          "partial": "Ext Pattern",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe external pattern syntax (ERE syntax)\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EPat",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "data"
        },
        "index": {
          "description": "The external pattern syntax ERE syntax",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EPat",
          "package": "regex-pderiv",
          "partial": "EPat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#t:EPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe character class [ a-z ] \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EAny",
          "package": "regex-pderiv",
          "signature": "EAny [Char]",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the character class a-z",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EAny",
          "normalized": "EAny[Char]",
          "package": "regex-pderiv",
          "partial": "EAny",
          "signature": "EAny[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:EAny"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ere{1:10}\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EBound",
          "package": "regex-pderiv",
          "signature": "EBound EPat Int (Maybe Int) Bool",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "re",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EBound",
          "package": "regex-pderiv",
          "partial": "EBound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:EBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe ^ NOTE:shouldn't this must be top level?\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "ECarat",
          "package": "regex-pderiv",
          "signature": "ECarat",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the NOTE shouldn this must be top level",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "ECarat",
          "package": "regex-pderiv",
          "partial": "ECarat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:ECarat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe non-escaped char\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EChar",
          "package": "regex-pderiv",
          "signature": "EChar Char",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the non-escaped char",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EChar",
          "package": "regex-pderiv",
          "partial": "EChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:EChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe concantenation rere\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EConcat",
          "package": "regex-pderiv",
          "signature": "EConcat [EPat]",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the concantenation rere",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EConcat",
          "normalized": "EConcat[EPat]",
          "package": "regex-pderiv",
          "partial": "EConcat",
          "signature": "EConcat[EPat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:EConcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe $\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EDollar",
          "package": "regex-pderiv",
          "signature": "EDollar",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EDollar",
          "package": "regex-pderiv",
          "partial": "EDollar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:EDollar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe any char .\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EDot",
          "package": "regex-pderiv",
          "signature": "EDot",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the any char",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EDot",
          "package": "regex-pderiv",
          "partial": "EDot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:EDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EEmpty",
          "package": "regex-pderiv",
          "signature": "EEmpty",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EEmpty",
          "package": "regex-pderiv",
          "partial": "EEmpty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:EEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebackslash char\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EEscape",
          "package": "regex-pderiv",
          "signature": "EEscape Char",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "backslash char",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EEscape",
          "package": "regex-pderiv",
          "partial": "EEscape",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:EEscape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe group ( re )\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EGroup",
          "package": "regex-pderiv",
          "signature": "EGroup EPat",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the group re",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EGroup",
          "package": "regex-pderiv",
          "partial": "EGroup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:EGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon marking group (?: re )\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EGroupNonMarking",
          "package": "regex-pderiv",
          "signature": "EGroupNonMarking EPat",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "non marking group re",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EGroupNonMarking",
          "package": "regex-pderiv",
          "partial": "EGroup Non Marking",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:EGroupNonMarking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe negative character class [^a-z]\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "ENoneOf",
          "package": "regex-pderiv",
          "signature": "ENoneOf [Char]",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the negative character class a-z",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "ENoneOf",
          "normalized": "ENoneOf[Char]",
          "package": "regex-pderiv",
          "partial": "ENone Of",
          "signature": "ENoneOf[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:ENoneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe option re?, the last boolean flag indicates whether it is greedy\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EOpt",
          "package": "regex-pderiv",
          "signature": "EOpt EPat Bool",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the option re the last boolean flag indicates whether it is greedy",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EOpt",
          "package": "regex-pderiv",
          "partial": "EOpt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:EOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe union re|re\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EOr",
          "package": "regex-pderiv",
          "signature": "EOr [EPat]",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the union re re",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EOr",
          "normalized": "EOr[EPat]",
          "package": "regex-pderiv",
          "partial": "EOr",
          "signature": "EOr[EPat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:EOr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe plus re+\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EPlus",
          "package": "regex-pderiv",
          "signature": "EPlus EPat Bool",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the plus re",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EPlus",
          "package": "regex-pderiv",
          "partial": "EPlus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:EPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe star re*\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EStar",
          "package": "regex-pderiv",
          "signature": "EStar EPat Bool",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the star re",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "EStar",
          "package": "regex-pderiv",
          "partial": "EStar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:EStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction \u003ccode\u003e\u003ca\u003ehasGroup\u003c/a\u003e\u003c/code\u003e tests whether an external pattern has ( ... ) (i.e. variable patterns in the internal pattern)\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "hasGroup",
          "package": "regex-pderiv",
          "signature": "EPat -\u003e Bool",
          "source": "src/Text-Regex-PDeriv-ExtPattern.html#hasGroup",
          "type": "function"
        },
        "index": {
          "description": "Function hasGroup tests whether an external pattern has i.e variable patterns in the internal pattern",
          "hierarchy": "Text Regex PDeriv ExtPattern",
          "module": "Text.Regex.PDeriv.ExtPattern",
          "name": "hasGroup",
          "normalized": "EPat-\u003eBool",
          "package": "regex-pderiv",
          "partial": "Group",
          "signature": "EPat-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-ExtPattern.html#v:hasGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the data type of internal regular expression pattern, \n | as well as the partial derivative operations for regular expression patterns.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "IntPattern",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-IntPattern.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the data type of internal regular expression pattern as well as the partial derivative operations for regular expression patterns",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "IntPattern",
          "package": "regex-pderiv",
          "partial": "Int Pattern",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eBinder\u003c/a\u003e\u003c/code\u003e type denotes a set of (pattern var * range) pairs\n type Binder = [(Int, [Range])]\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "Binder",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-IntPattern.html#Binder",
          "type": "type"
        },
        "index": {
          "description": "The Binder type denotes set of pattern var range pairs type Binder Int Range",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "Binder",
          "package": "regex-pderiv",
          "partial": "Binder",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#t:Binder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eregular expression patterns\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "Pat",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-IntPattern.html#Pat",
          "type": "data"
        },
        "index": {
          "description": "regular expression patterns",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "Pat",
          "package": "regex-pderiv",
          "partial": "Pat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#t:Pat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echoice pattern \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "PChoice",
          "package": "regex-pderiv",
          "signature": "PChoice Pat Pat GFlag",
          "source": "src/Text-Regex-PDeriv-IntPattern.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "choice pattern",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "PChoice",
          "package": "regex-pderiv",
          "partial": "PChoice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#v:PChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epattern without binder\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "PE",
          "package": "regex-pderiv",
          "signature": "PE RE",
          "source": "src/Text-Regex-PDeriv-IntPattern.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "pattern without binder",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "PE",
          "package": "regex-pderiv",
          "partial": "PE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#v:PE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eempty pattern, it is used intermally to indicate that mkEmpty function has been applied.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "PEmpty",
          "package": "regex-pderiv",
          "signature": "PEmpty Pat",
          "source": "src/Text-Regex-PDeriv-IntPattern.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "empty pattern it is used intermally to indicate that mkEmpty function has been applied",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "PEmpty",
          "package": "regex-pderiv",
          "partial": "PEmpty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#v:PEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epair pattern\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "PPair",
          "package": "regex-pderiv",
          "signature": "PPair Pat Pat",
          "source": "src/Text-Regex-PDeriv-IntPattern.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "pair pattern",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "PPair",
          "package": "regex-pderiv",
          "partial": "PPair",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#v:PPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eplus pattern, it is used internally to indicate that it is unrolled from a PStar\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "PPlus",
          "package": "regex-pderiv",
          "signature": "PPlus Pat Pat",
          "source": "src/Text-Regex-PDeriv-IntPattern.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "plus pattern it is used internally to indicate that it is unrolled from PStar",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "PPlus",
          "package": "regex-pderiv",
          "partial": "PPlus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#v:PPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estar pattern \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "PStar",
          "package": "regex-pderiv",
          "signature": "PStar Pat GFlag",
          "source": "src/Text-Regex-PDeriv-IntPattern.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "star pattern",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "PStar",
          "package": "regex-pderiv",
          "partial": "PStar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#v:PStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable pattern \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "PVar",
          "package": "regex-pderiv",
          "signature": "PVar Int [Range] Pat",
          "source": "src/Text-Regex-PDeriv-IntPattern.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "variable pattern",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "PVar",
          "normalized": "PVar Int[Range]Pat",
          "package": "regex-pderiv",
          "partial": "PVar",
          "signature": "PVar Int[Range]Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#v:PVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "listifyBinder",
          "package": "regex-pderiv",
          "signature": "Binder -\u003e [(Int, [Range])]",
          "source": "src/Text-Regex-PDeriv-IntPattern.html#listifyBinder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "listifyBinder",
          "normalized": "Binder-\u003e[(Int,[Range])]",
          "package": "regex-pderiv",
          "partial": "Binder",
          "signature": "Binder-\u003e[(Int,[Range])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#v:listifyBinder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "nub2",
          "package": "regex-pderiv",
          "signature": "[(a, b)] -\u003e [(a, b)]",
          "source": "src/Text-Regex-PDeriv-IntPattern.html#nub2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "nub2",
          "normalized": "[(a,b)]-\u003e[(a,b)]",
          "package": "regex-pderiv",
          "signature": "[(a,b)]-\u003e[(a,b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#v:nub2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction \u003ccode\u003e\u003ca\u003epdPat\u003c/a\u003e\u003c/code\u003e computes the partial derivatives of a pattern w.r.t. a letter.\n     Integrating non-greedy operator with PStar\n     For p*, we need to unroll it into a special construct\n     say PPlus p' p* where p' in p/l.\n     When we push another label, say l' to PPlus p' p*, and\n     p' is emptiable, naively, we would do \n     [ PPlus p'' p* | p'' \u003c- p' \u003cem\u003e l ] ++ [ PPlus (mkE p') (PPlus p''' p*) | (PPlus p''' p*) \u003c- p*\u003c/em\u003el ]\n     Now the problem here is the shape of the pdpat are infinite, which \n     breaks the requirement of getting a compilation scheme.\n     The fix here is to simplify the second component, by combining the binding, of (mkE p') and p'''\n     since they share the same set of variables.\n     [ PPlus p'' p* | p'' \u003c- p' \u003cem\u003e l ] ++ [ PPlus p4 p* | (PPlus p''' p*) \u003c- p*\u003c/em\u003el ] \n     where p4 = combineBinding (mkE p') p'''\n     For pdPat0 approach, we do not need to do this explicitly, we simply drop \n     (mkE p') even in the PPair case. see the definitely of pdPat0 below\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "pdPat",
          "package": "regex-pderiv",
          "signature": "Pat -\u003e Letter -\u003e [Pat]",
          "source": "src/Text-Regex-PDeriv-IntPattern.html#pdPat",
          "type": "function"
        },
        "index": {
          "description": "function pdPat computes the partial derivatives of pattern w.r.t letter Integrating non-greedy operator with PStar For we need to unroll it into special construct say PPlus where in When we push another label say to PPlus and is emptiable naively we would do PPlus PPlus mkE PPlus PPlus Now the problem here is the shape of the pdpat are infinite which breaks the requirement of getting compilation scheme The fix here is to simplify the second component by combining the binding of mkE and since they share the same set of variables PPlus PPlus p4 PPlus where p4 combineBinding mkE For pdPat0 approach we do not need to do this explicitly we simply drop mkE even in the PPair case see the definitely of pdPat0 below",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "pdPat",
          "normalized": "Pat-\u003eLetter-\u003e[Pat]",
          "package": "regex-pderiv",
          "partial": "Pat",
          "signature": "Pat-\u003eLetter-\u003e[Pat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#v:pdPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction \u003ccode\u003e\u003ca\u003epdPat0\u003c/a\u003e\u003c/code\u003e is the \u003ccode\u003eabstracted\u003c/code\u003e form of the \u003ccode\u003e\u003ca\u003epdPat\u003c/a\u003e\u003c/code\u003e function\n      It computes a set of pairs. Each pair consists a \u003ccode\u003eshape\u003c/code\u003e of the partial derivative, and\n      an update function which defines the change of the pattern bindings from the \u003ccode\u003esource\u003c/code\u003e pattern to \n      the resulting partial derivative. This is used in the compilation of the regular expression pattern \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "pdPat0",
          "package": "regex-pderiv",
          "signature": "Pat-\u003e Letter-\u003e [(Pat, Int -\u003e Binder -\u003e Binder)]",
          "type": "function"
        },
        "index": {
          "description": "Function pdPat0 is the abstracted form of the pdPat function It computes set of pairs Each pair consists shape of the partial derivative and an update function which defines the change of the pattern bindings from the source pattern to the resulting partial derivative This is used in the compilation of the regular expression pattern",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "pdPat0",
          "normalized": "Pat-\u003eLetter-\u003e[(Pat,Int-\u003eBinder-\u003eBinder)]",
          "package": "regex-pderiv",
          "partial": "Pat",
          "signature": "Pat-\u003eLetter-\u003e[(Pat,Int-\u003eBinder-\u003eBinder)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#v:pdPat0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction \u003ccode\u003e\u003ca\u003epdPat0Sim\u003c/a\u003e\u003c/code\u003e applies simplification to the results of \u003ccode\u003e\u003ca\u003epdPat0\u003c/a\u003e\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "pdPat0Sim",
          "package": "regex-pderiv",
          "signature": "Pat-\u003e Letter-\u003e [(Pat, Int -\u003e Binder -\u003e Binder)]",
          "type": "function"
        },
        "index": {
          "description": "Function pdPat0Sim applies simplification to the results of pdPat0",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "pdPat0Sim",
          "normalized": "Pat-\u003eLetter-\u003e[(Pat,Int-\u003eBinder-\u003eBinder)]",
          "package": "regex-pderiv",
          "partial": "Pat Sim",
          "signature": "Pat-\u003eLetter-\u003e[(Pat,Int-\u003eBinder-\u003eBinder)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#v:pdPat0Sim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction \u003ccode\u003e\u003ca\u003estrip\u003c/a\u003e\u003c/code\u003e strips away the bindings from a pattern\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "strip",
          "package": "regex-pderiv",
          "signature": "Pat -\u003e RE",
          "source": "src/Text-Regex-PDeriv-IntPattern.html#strip",
          "type": "function"
        },
        "index": {
          "description": "function strip strips away the bindings from pattern",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "strip",
          "normalized": "Pat-\u003eRE",
          "package": "regex-pderiv",
          "signature": "Pat-\u003eRE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#v:strip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction \u003ccode\u003e\u003ca\u003etoBinder\u003c/a\u003e\u003c/code\u003e turns a pattern into a binder\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "toBinder",
          "package": "regex-pderiv",
          "signature": "Pat -\u003e Binder",
          "source": "src/Text-Regex-PDeriv-IntPattern.html#toBinder",
          "type": "function"
        },
        "index": {
          "description": "Function toBinder turns pattern into binder",
          "hierarchy": "Text Regex PDeriv IntPattern",
          "module": "Text.Regex.PDeriv.IntPattern",
          "name": "toBinder",
          "normalized": "Pat-\u003eBinder",
          "package": "regex-pderiv",
          "partial": "Binder",
          "signature": "Pat-\u003eBinder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-IntPattern.html#v:toBinder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines data types, type classes and instances for NFA\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "Nfa",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Nfa.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines data types type classes and instances for NFA",
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "Nfa",
          "package": "regex-pderiv",
          "partial": "Nfa",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe NFA data type\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "NFA",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Nfa.html#NFA",
          "type": "data"
        },
        "index": {
          "description": "the NFA data type",
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "NFA",
          "package": "regex-pderiv",
          "partial": "NFA",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#t:NFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type class of Nfa\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "Nfa",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Nfa.html#Nfa",
          "type": "class"
        },
        "index": {
          "description": "The type class of Nfa",
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "Nfa",
          "package": "regex-pderiv",
          "partial": "Nfa",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#t:Nfa"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe optimized NFA using Int to represent states, IntMap to represent delta\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "SNFA",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Nfa.html#SNFA",
          "type": "data"
        },
        "index": {
          "description": "the optimized NFA using Int to represent states IntMap to represent delta",
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "SNFA",
          "package": "regex-pderiv",
          "partial": "SNFA",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#t:SNFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "NFA",
          "package": "regex-pderiv",
          "signature": "NFA",
          "source": "src/Text-Regex-PDeriv-Nfa.html#NFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "NFA",
          "package": "regex-pderiv",
          "partial": "NFA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:NFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "SNFA",
          "package": "regex-pderiv",
          "signature": "SNFA",
          "source": "src/Text-Regex-PDeriv-Nfa.html#SNFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "SNFA",
          "package": "regex-pderiv",
          "partial": "SNFA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:SNFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "all_states",
          "package": "regex-pderiv",
          "signature": "[s]",
          "source": "src/Text-Regex-PDeriv-Nfa.html#NFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "all_states",
          "normalized": "[a]",
          "package": "regex-pderiv",
          "signature": "[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:all_states"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function that builds an NFA \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "buildNFA",
          "package": "regex-pderiv",
          "signature": "s -\u003e NFA s a",
          "source": "src/Text-Regex-PDeriv-Nfa.html#buildNFA",
          "type": "function"
        },
        "index": {
          "description": "function that builds an NFA",
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "buildNFA",
          "normalized": "a-\u003eNFA a b",
          "package": "regex-pderiv",
          "partial": "NFA",
          "signature": "s-\u003eNFA s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:buildNFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "delta_states",
          "package": "regex-pderiv",
          "signature": "[(s, a, s)]",
          "source": "src/Text-Regex-PDeriv-Nfa.html#NFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "delta_states",
          "normalized": "[(a,b,a)]",
          "package": "regex-pderiv",
          "signature": "[(s,a,s)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:delta_states"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "empty",
          "package": "regex-pderiv",
          "signature": "s -\u003e Bool",
          "source": "src/Text-Regex-PDeriv-Nfa.html#empty",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "empty",
          "normalized": "a-\u003eBool",
          "package": "regex-pderiv",
          "signature": "s-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "final_states",
          "package": "regex-pderiv",
          "signature": "[s]",
          "source": "src/Text-Regex-PDeriv-Nfa.html#NFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "final_states",
          "normalized": "[a]",
          "package": "regex-pderiv",
          "signature": "[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:final_states"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "init_states",
          "package": "regex-pderiv",
          "signature": "[s]",
          "source": "src/Text-Regex-PDeriv-Nfa.html#NFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "init_states",
          "normalized": "[a]",
          "package": "regex-pderiv",
          "signature": "[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:init_states"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "mapping_states",
          "package": "regex-pderiv",
          "signature": "s -\u003e Int",
          "source": "src/Text-Regex-PDeriv-Nfa.html#SNFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "mapping_states",
          "normalized": "a-\u003eInt",
          "package": "regex-pderiv",
          "signature": "s-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:mapping_states"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "nofAllStates",
          "package": "regex-pderiv",
          "signature": "NFA a t -\u003e Int",
          "source": "src/Text-Regex-PDeriv-Nfa.html#nofAllStates",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "nofAllStates",
          "normalized": "NFA a b-\u003eInt",
          "package": "regex-pderiv",
          "partial": "All States",
          "signature": "NFA a t-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:nofAllStates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "nofDelta",
          "package": "regex-pderiv",
          "signature": "NFA t t1 -\u003e Int",
          "source": "src/Text-Regex-PDeriv-Nfa.html#nofDelta",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "nofDelta",
          "normalized": "NFA a a-\u003eInt",
          "package": "regex-pderiv",
          "partial": "Delta",
          "signature": "NFA t t-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:nofDelta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "nofFinalStates",
          "package": "regex-pderiv",
          "signature": "NFA a t -\u003e Int",
          "source": "src/Text-Regex-PDeriv-Nfa.html#nofFinalStates",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "nofFinalStates",
          "normalized": "NFA a b-\u003eInt",
          "package": "regex-pderiv",
          "partial": "Final States",
          "signature": "NFA a t-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:nofFinalStates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "nofInitStates",
          "package": "regex-pderiv",
          "signature": "NFA a t -\u003e Int",
          "source": "src/Text-Regex-PDeriv-Nfa.html#nofInitStates",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "nofInitStates",
          "normalized": "NFA a b-\u003eInt",
          "package": "regex-pderiv",
          "partial": "Init States",
          "signature": "NFA a t-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:nofInitStates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "pDeriv",
          "package": "regex-pderiv",
          "signature": "s -\u003e a -\u003e [s]",
          "source": "src/Text-Regex-PDeriv-Nfa.html#pDeriv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "pDeriv",
          "normalized": "a-\u003eb-\u003e[a]",
          "package": "regex-pderiv",
          "partial": "Deriv",
          "signature": "s-\u003ea-\u003e[s]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:pDeriv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "sall_states",
          "package": "regex-pderiv",
          "signature": "[Int]",
          "source": "src/Text-Regex-PDeriv-Nfa.html#SNFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "sall_states",
          "normalized": "[Int]",
          "package": "regex-pderiv",
          "signature": "[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:sall_states"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "sdelta_states",
          "package": "regex-pderiv",
          "signature": "[(Int, a, Int)]",
          "source": "src/Text-Regex-PDeriv-Nfa.html#SNFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "sdelta_states",
          "normalized": "[(Int,a,Int)]",
          "package": "regex-pderiv",
          "signature": "[(Int,a,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:sdelta_states"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "sfinal_states",
          "package": "regex-pderiv",
          "signature": "[Int]",
          "source": "src/Text-Regex-PDeriv-Nfa.html#SNFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "sfinal_states",
          "normalized": "[Int]",
          "package": "regex-pderiv",
          "signature": "[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:sfinal_states"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "sigma",
          "package": "regex-pderiv",
          "signature": "s -\u003e [a]",
          "source": "src/Text-Regex-PDeriv-Nfa.html#sigma",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "sigma",
          "normalized": "a-\u003e[b]",
          "package": "regex-pderiv",
          "signature": "s-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:sigma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "sinit_states",
          "package": "regex-pderiv",
          "signature": "[Int]",
          "source": "src/Text-Regex-PDeriv-Nfa.html#SNFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "sinit_states",
          "normalized": "[Int]",
          "package": "regex-pderiv",
          "signature": "[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:sinit_states"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003etoSNFA\u003c/a\u003e\u003c/code\u003e converts from an NFA to an SNFA\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "toSNFA",
          "package": "regex-pderiv",
          "signature": "NFA s a -\u003e SNFA s a",
          "source": "src/Text-Regex-PDeriv-Nfa.html#toSNFA",
          "type": "function"
        },
        "index": {
          "description": "The function toSNFA converts from an NFA to an SNFA",
          "hierarchy": "Text Regex PDeriv Nfa",
          "module": "Text.Regex.PDeriv.Nfa",
          "name": "toSNFA",
          "normalized": "NFA a b-\u003eSNFA a b",
          "package": "regex-pderiv",
          "partial": "SNFA",
          "signature": "NFA s a-\u003eSNFA s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Nfa.html#v:toSNFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Parse",
          "name": "Parse",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Parse.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Parse",
          "module": "Text.Regex.PDeriv.Parse",
          "name": "Parse",
          "package": "regex-pderiv",
          "partial": "Parse",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Parse.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Parse",
          "name": "parsePatPosix",
          "package": "regex-pderiv",
          "signature": "String -\u003e Either ParseError (Pat, IntMap ())",
          "source": "src/Text-Regex-PDeriv-Parse.html#parsePatPosix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Parse",
          "module": "Text.Regex.PDeriv.Parse",
          "name": "parsePatPosix",
          "normalized": "String-\u003eEither ParseError(Pat,IntMap())",
          "package": "regex-pderiv",
          "partial": "Pat Posix",
          "signature": "String-\u003eEither ParseError(Pat,IntMap())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Parse.html#v:parsePatPosix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Pretty",
          "name": "Pretty",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Pretty.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Pretty",
          "module": "Text.Regex.PDeriv.Pretty",
          "name": "Pretty",
          "package": "regex-pderiv",
          "partial": "Pretty",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Pretty.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Pretty",
          "name": "Pretty",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Pretty.html#Pretty",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Pretty",
          "module": "Text.Regex.PDeriv.Pretty",
          "name": "Pretty",
          "package": "regex-pderiv",
          "partial": "Pretty",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Pretty.html#t:Pretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Pretty",
          "name": "pretty",
          "package": "regex-pderiv",
          "signature": "a -\u003e String",
          "source": "src/Text-Regex-PDeriv-Pretty.html#pretty",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Pretty",
          "module": "Text.Regex.PDeriv.Pretty",
          "name": "pretty",
          "normalized": "a-\u003eString",
          "package": "regex-pderiv",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Pretty.html#v:pretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.RE",
          "name": "RE",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-RE.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "RE",
          "package": "regex-pderiv",
          "partial": "RE",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edata type of the regular expresions\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.RE",
          "name": "RE",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-RE.html#RE",
          "type": "data"
        },
        "index": {
          "description": "data type of the regular expresions",
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "RE",
          "package": "regex-pderiv",
          "partial": "RE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#t:RE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.RE",
          "name": "Any",
          "package": "regex-pderiv",
          "signature": "Any",
          "source": "src/Text-Regex-PDeriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "Any",
          "package": "regex-pderiv",
          "partial": "Any",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#v:Any"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea choice exp 'r1 + r2'\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.RE",
          "name": "Choice",
          "package": "regex-pderiv",
          "signature": "Choice RE RE GFlag",
          "source": "src/Text-Regex-PDeriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "description": "choice exp r1 r2",
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "Choice",
          "package": "regex-pderiv",
          "partial": "Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#v:Choice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean empty exp\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.RE",
          "name": "Empty",
          "package": "regex-pderiv",
          "signature": "Empty",
          "source": "src/Text-Regex-PDeriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "description": "an empty exp",
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "Empty",
          "package": "regex-pderiv",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#v:Empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea literal / a character\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.RE",
          "name": "L",
          "package": "regex-pderiv",
          "signature": "L Char",
          "source": "src/Text-Regex-PDeriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "description": "literal character",
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "L",
          "package": "regex-pderiv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexcluding characters e.g. [^abc]\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.RE",
          "name": "Not",
          "package": "regex-pderiv",
          "signature": "Not [Char]",
          "source": "src/Text-Regex-PDeriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "description": "excluding characters e.g abc",
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "Not",
          "normalized": "Not[Char]",
          "package": "regex-pderiv",
          "partial": "Not",
          "signature": "Not[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#v:Not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.RE",
          "name": "Phi",
          "package": "regex-pderiv",
          "signature": "Phi",
          "source": "src/Text-Regex-PDeriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "Phi",
          "package": "regex-pderiv",
          "partial": "Phi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#v:Phi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea pair exp '(r1,r2)'\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.RE",
          "name": "Seq",
          "package": "regex-pderiv",
          "signature": "Seq RE RE",
          "source": "src/Text-Regex-PDeriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "description": "pair exp r1 r2",
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "Seq",
          "package": "regex-pderiv",
          "partial": "Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#v:Seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea kleene's star exp 'r*'\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.RE",
          "name": "Star",
          "package": "regex-pderiv",
          "signature": "Star RE GFlag",
          "source": "src/Text-Regex-PDeriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "description": "kleene star exp",
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "Star",
          "package": "regex-pderiv",
          "partial": "Star",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#v:Star"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction \u003ccode\u003e\u003ca\u003epartDeriv\u003c/a\u003e\u003c/code\u003e implements the partial derivative operations for regular expressions. We don't pay attention to the greediness flag here.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.RE",
          "name": "partDeriv",
          "package": "regex-pderiv",
          "signature": "RE -\u003e Char -\u003e [RE]",
          "source": "src/Text-Regex-PDeriv-RE.html#partDeriv",
          "type": "function"
        },
        "index": {
          "description": "function partDeriv implements the partial derivative operations for regular expressions We don pay attention to the greediness flag here",
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "partDeriv",
          "normalized": "RE-\u003eChar-\u003e[RE]",
          "package": "regex-pderiv",
          "partial": "Deriv",
          "signature": "RE-\u003eChar-\u003e[RE]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#v:partDeriv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.RE",
          "name": "partDerivSub",
          "package": "regex-pderiv",
          "signature": "RE -\u003e Char -\u003e [RE]",
          "source": "src/Text-Regex-PDeriv-RE.html#partDerivSub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "partDerivSub",
          "normalized": "RE-\u003eChar-\u003e[RE]",
          "package": "regex-pderiv",
          "partial": "Deriv Sub",
          "signature": "RE-\u003eChar-\u003e[RE]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#v:partDerivSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction \u003ccode\u003e\u003ca\u003eresToRE\u003c/a\u003e\u003c/code\u003e sums up a list of regular expressions with the choice operation.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.RE",
          "name": "resToRE",
          "package": "regex-pderiv",
          "signature": "[RE] -\u003e RE",
          "source": "src/Text-Regex-PDeriv-RE.html#resToRE",
          "type": "function"
        },
        "index": {
          "description": "function resToRE sums up list of regular expressions with the choice operation",
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "resToRE",
          "normalized": "[RE]-\u003eRE",
          "package": "regex-pderiv",
          "partial": "To RE",
          "signature": "[RE]-\u003eRE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#v:resToRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction \u003ccode\u003e\u003ca\u003esigmaRE\u003c/a\u003e\u003c/code\u003e returns all characters appearing in a reg exp.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.RE",
          "name": "sigmaRE",
          "package": "regex-pderiv",
          "signature": "RE -\u003e [Char]",
          "source": "src/Text-Regex-PDeriv-RE.html#sigmaRE",
          "type": "function"
        },
        "index": {
          "description": "function sigmaRE returns all characters appearing in reg exp",
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "sigmaRE",
          "normalized": "RE-\u003e[Char]",
          "package": "regex-pderiv",
          "partial": "RE",
          "signature": "RE-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#v:sigmaRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.RE",
          "name": "sigmaREsub",
          "package": "regex-pderiv",
          "signature": "RE -\u003e [Char]",
          "source": "src/Text-Regex-PDeriv-RE.html#sigmaREsub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv RE",
          "module": "Text.Regex.PDeriv.RE",
          "name": "sigmaREsub",
          "normalized": "RE-\u003e[Char]",
          "package": "regex-pderiv",
          "partial": "REsub",
          "signature": "RE-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-RE.html#v:sigmaREsub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "LeftToRightD",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "LeftToRightD",
          "package": "regex-pderiv",
          "partial": "Left To Right",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "CompOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "CompOption",
          "package": "regex-pderiv",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe PDeriv backend spepcific \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e type\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "Regex",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "The PDeriv backend spepcific Regex type",
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "Regex",
          "package": "regex-pderiv",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PDeriv.String.LeftToRightD\",\"Text.Regex.PDeriv.String\"]",
          "name": "CompOption",
          "package": "regex-pderiv",
          "signature": "CompOption",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:CompOption\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#v:CompOption\"]"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "CompOption",
          "package": "regex-pderiv",
          "partial": "Comp Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PDeriv.String.LeftToRightD\",\"Text.Regex.PDeriv.String\"]",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "signature": "ExecOption",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html#ExecOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:ExecOption\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#v:ExecOption\"]"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "partial": "Exec Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue by default.  Set to False to improve speed (and space).\n\u003c/p\u003e",
          "module": "[\"Text.Regex.PDeriv.String.LeftToRightD\",\"Text.Regex.PDeriv.String\"]",
          "name": "captureGroups",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html#ExecOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:captureGroups\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#v:captureGroups\"]"
        },
        "index": {
          "description": "True by default Set to False to improve speed and space",
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "captureGroups",
          "package": "regex-pderiv",
          "partial": "Groups",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:captureGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "[\"Text.Regex.PDeriv.String.LeftToRightD\",\"Text.Regex.PDeriv.String\"]",
          "name": "caseSensitive",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:caseSensitive\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#v:caseSensitive\"]"
        },
        "index": {
          "description": "True in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "caseSensitive",
          "package": "regex-pderiv",
          "partial": "Sensitive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:caseSensitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PDeriv.String.LeftToRightD\",\"Text.Regex.PDeriv.String\"]",
          "name": "compile",
          "package": "regex-pderiv",
          "signature": "CompOption-\u003e ExecOption-\u003e String-\u003e Either String Regex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:compile\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#v:compile\"]"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "compile",
          "normalized": "CompOption-\u003eExecOption-\u003eString-\u003eEither String Regex",
          "package": "regex-pderiv",
          "signature": "CompOption-\u003eExecOption-\u003eString-\u003eEither String Regex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:compile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PDeriv.String.LeftToRightD\",\"Text.Regex.PDeriv.String\"]",
          "name": "execute",
          "package": "regex-pderiv",
          "signature": "Regex-\u003e String-\u003e Either String (Maybe Env)",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:execute\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#v:execute\"]"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "execute",
          "normalized": "Regex-\u003eString-\u003eEither String(Maybe Env)",
          "package": "regex-pderiv",
          "signature": "Regex-\u003eString-\u003eEither String(Maybe Env)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:execute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse by default.  This is POSIX correct but it takes space and is slower.\n Setting this to true will improve performance, and should be done\n if you plan to set the captureGroups execoption to False.\n\u003c/p\u003e",
          "module": "[\"Text.Regex.PDeriv.String.LeftToRightD\",\"Text.Regex.PDeriv.String\"]",
          "name": "lastStarGreedy",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:lastStarGreedy\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#v:lastStarGreedy\"]"
        },
        "index": {
          "description": "False by default This is POSIX correct but it takes space and is slower Setting this to true will improve performance and should be done if you plan to set the captureGroups execoption to False",
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "lastStarGreedy",
          "package": "regex-pderiv",
          "partial": "Star Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:lastStarGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Compile for\n    newline-sensitive matching.  \u003ca\u003eBy default, newline is a completely ordinary\n    character with no special meaning in either REs or strings.  With this flag,\n    inverted bracket expressions and . never match newline, a ^ anchor matches the\n    null string after any newline in the string in addition to its normal\n    function, and the $ anchor matches the null string before any newline in the\n    string in addition to its normal function.\u003c/a\u003e \n\u003c/p\u003e",
          "module": "[\"Text.Regex.PDeriv.String.LeftToRightD\",\"Text.Regex.PDeriv.String\"]",
          "name": "multiline",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:multiline\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#v:multiline\"]"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Compile for newline-sensitive matching By default newline is completely ordinary character with no special meaning in either REs or strings With this flag inverted bracket expressions and never match newline anchor matches the null string after any newline in the string in addition to its normal function and the anchor matches the null string before any newline in the string in addition to its normal function",
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "multiline",
          "package": "regex-pderiv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:multiline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. \n\u003c/p\u003e",
          "module": "[\"Text.Regex.PDeriv.String.LeftToRightD\",\"Text.Regex.PDeriv.String\"]",
          "name": "newSyntax",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:newSyntax\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#v:newSyntax\"]"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt",
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "newSyntax",
          "package": "regex-pderiv",
          "partial": "Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:newSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.PDeriv.String.LeftToRightD\",\"Text.Regex.PDeriv.String\"]",
          "name": "regexec",
          "package": "regex-pderiv",
          "signature": "Regex-\u003e String-\u003e Either String (Maybe (String, String, String, [String]))",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:regexec\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#v:regexec\"]"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "regexec",
          "normalized": "Regex-\u003eString-\u003eEither String(Maybe(String,String,String,[String]))",
          "package": "regex-pderiv",
          "signature": "Regex-\u003eString-\u003eEither String(Maybe(String,String,String,[String]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:regexec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue (and therefore Right associative) in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "[\"Text.Regex.PDeriv.String.LeftToRightD\",\"Text.Regex.PDeriv.String\"]",
          "name": "rightAssoc",
          "package": "regex-pderiv",
          "signature": "Bool",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:rightAssoc\",\"http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#v:rightAssoc\"]"
        },
        "index": {
          "description": "True and therefore Right associative in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex PDeriv String LeftToRightD",
          "module": "Text.Regex.PDeriv.String.LeftToRightD",
          "name": "rightAssoc",
          "package": "regex-pderiv",
          "partial": "Assoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String-LeftToRightD.html#v:rightAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.String",
          "name": "String",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-String.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv String",
          "module": "Text.Regex.PDeriv.String",
          "name": "String",
          "package": "regex-pderiv",
          "partial": "String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.String",
          "name": "CompOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex PDeriv String",
          "module": "Text.Regex.PDeriv.String",
          "name": "CompOption",
          "package": "regex-pderiv",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.String",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv String",
          "module": "Text.Regex.PDeriv.String",
          "name": "ExecOption",
          "package": "regex-pderiv",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe PDeriv backend spepcific \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e type\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.String",
          "name": "Regex",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-String-LeftToRightD.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "The PDeriv backend spepcific Regex type",
          "hierarchy": "Text Regex PDeriv String",
          "module": "Text.Regex.PDeriv.String",
          "name": "Regex",
          "package": "regex-pderiv",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-String.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA translation schema from the external syntax (ERE) to our interal syntax (xhaskell style pattern)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.PDeriv.Translate",
          "name": "Translate",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Translate.html",
          "type": "module"
        },
        "index": {
          "description": "translation schema from the external syntax ERE to our interal syntax xhaskell style pattern",
          "hierarchy": "Text Regex PDeriv Translate",
          "module": "Text.Regex.PDeriv.Translate",
          "name": "Translate",
          "package": "regex-pderiv",
          "partial": "Translate",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Translate.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslating external pattern to internal pattern\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Translate",
          "name": "translate",
          "package": "regex-pderiv",
          "signature": "EPat -\u003e Pat",
          "source": "src/Text-Regex-PDeriv-Translate.html#translate",
          "type": "function"
        },
        "index": {
          "description": "Translating external pattern to internal pattern",
          "hierarchy": "Text Regex PDeriv Translate",
          "module": "Text.Regex.PDeriv.Translate",
          "name": "translate",
          "normalized": "EPat-\u003ePat",
          "package": "regex-pderiv",
          "signature": "EPat-\u003ePat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Translate.html#v:translate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efor posix \n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Translate",
          "name": "translatePosix",
          "package": "regex-pderiv",
          "signature": "EPat -\u003e (Pat, IntMap ())",
          "source": "src/Text-Regex-PDeriv-Translate.html#translatePosix",
          "type": "function"
        },
        "index": {
          "description": "for posix",
          "hierarchy": "Text Regex PDeriv Translate",
          "module": "Text.Regex.PDeriv.Translate",
          "name": "translatePosix",
          "normalized": "EPat-\u003e(Pat,IntMap())",
          "package": "regex-pderiv",
          "partial": "Posix",
          "signature": "EPat-\u003e(Pat,IntMap())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Translate.html#v:translatePosix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Word",
          "name": "Word",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Word.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Word",
          "module": "Text.Regex.PDeriv.Word",
          "name": "Word",
          "package": "regex-pderiv",
          "partial": "Word",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Word.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe Word type class\n\u003c/p\u003e",
          "module": "Text.Regex.PDeriv.Word",
          "name": "Word",
          "package": "regex-pderiv",
          "source": "src/Text-Regex-PDeriv-Word.html#Word",
          "type": "class"
        },
        "index": {
          "description": "the Word type class",
          "hierarchy": "Text Regex PDeriv Word",
          "module": "Text.Regex.PDeriv.Word",
          "name": "Word",
          "package": "regex-pderiv",
          "partial": "Word",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Word.html#t:Word"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Word",
          "name": "append",
          "package": "regex-pderiv",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Text-Regex-PDeriv-Word.html#append",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Word",
          "module": "Text.Regex.PDeriv.Word",
          "name": "append",
          "normalized": "a-\u003ea-\u003ea",
          "package": "regex-pderiv",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Word.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Word",
          "name": "drop",
          "package": "regex-pderiv",
          "signature": "Int -\u003e a -\u003e a",
          "source": "src/Text-Regex-PDeriv-Word.html#drop",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Word",
          "module": "Text.Regex.PDeriv.Word",
          "name": "drop",
          "normalized": "Int-\u003ea-\u003ea",
          "package": "regex-pderiv",
          "signature": "Int-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Word.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Word",
          "name": "empty",
          "package": "regex-pderiv",
          "signature": "a",
          "source": "src/Text-Regex-PDeriv-Word.html#empty",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Word",
          "module": "Text.Regex.PDeriv.Word",
          "name": "empty",
          "package": "regex-pderiv",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Word.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Word",
          "name": "length",
          "package": "regex-pderiv",
          "signature": "a -\u003e Int",
          "source": "src/Text-Regex-PDeriv-Word.html#length",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Word",
          "module": "Text.Regex.PDeriv.Word",
          "name": "length",
          "normalized": "a-\u003eInt",
          "package": "regex-pderiv",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Word.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Word",
          "name": "reverse",
          "package": "regex-pderiv",
          "signature": "a -\u003e a",
          "source": "src/Text-Regex-PDeriv-Word.html#reverse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Word",
          "module": "Text.Regex.PDeriv.Word",
          "name": "reverse",
          "normalized": "a-\u003ea",
          "package": "regex-pderiv",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Word.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Word",
          "name": "take",
          "package": "regex-pderiv",
          "signature": "Int -\u003e a -\u003e a",
          "source": "src/Text-Regex-PDeriv-Word.html#take",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Word",
          "module": "Text.Regex.PDeriv.Word",
          "name": "take",
          "normalized": "Int-\u003ea-\u003ea",
          "package": "regex-pderiv",
          "signature": "Int-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Word.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.PDeriv.Word",
          "name": "uncons",
          "package": "regex-pderiv",
          "signature": "a -\u003e Maybe (Char, a)",
          "source": "src/Text-Regex-PDeriv-Word.html#uncons",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex PDeriv Word",
          "module": "Text.Regex.PDeriv.Word",
          "name": "uncons",
          "normalized": "a-\u003eMaybe(Char,a)",
          "package": "regex-pderiv",
          "signature": "a-\u003eMaybe(Char,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-pderiv/docs/Text-Regex-PDeriv-Word.html#v:uncons"
      }
    }
  ]
]