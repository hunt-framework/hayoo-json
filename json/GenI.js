[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "GenI"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "BoolExp",
          "name": "BoolExp",
          "package": "GenI",
          "source": "src/BoolExp.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "BoolExp",
          "module": "BoolExp",
          "name": "BoolExp",
          "package": "GenI",
          "partial": "Bool Exp",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/BoolExp.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "BoolExp",
          "name": "BoolExp",
          "package": "GenI",
          "source": "src/BoolExp.html#BoolExp",
          "type": "data"
        },
        "index": {
          "hierarchy": "BoolExp",
          "module": "BoolExp",
          "name": "BoolExp",
          "package": "GenI",
          "partial": "Bool Exp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/BoolExp.html#t:BoolExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "BoolExp",
          "name": "And",
          "package": "GenI",
          "signature": "And (BoolExp a) (BoolExp a)",
          "source": "src/BoolExp.html#BoolExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "BoolExp",
          "module": "BoolExp",
          "name": "And",
          "package": "GenI",
          "partial": "And",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/BoolExp.html#v:And"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "BoolExp",
          "name": "Cond",
          "package": "GenI",
          "signature": "Cond a",
          "source": "src/BoolExp.html#BoolExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "BoolExp",
          "module": "BoolExp",
          "name": "Cond",
          "package": "GenI",
          "partial": "Cond",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/BoolExp.html#v:Cond"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "BoolExp",
          "name": "Not",
          "package": "GenI",
          "signature": "Not (BoolExp a)",
          "source": "src/BoolExp.html#BoolExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "BoolExp",
          "module": "BoolExp",
          "name": "Not",
          "package": "GenI",
          "partial": "Not",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/BoolExp.html#v:Not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "BoolExp",
          "name": "Or",
          "package": "GenI",
          "signature": "Or (BoolExp a) (BoolExp a)",
          "source": "src/BoolExp.html#BoolExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "BoolExp",
          "module": "BoolExp",
          "name": "Or",
          "package": "GenI",
          "partial": "Or",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/BoolExp.html#v:Or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "BoolExp",
          "name": "check",
          "package": "GenI",
          "signature": "(a -\u003e Bool) -\u003e BoolExp a -\u003e Bool",
          "source": "src/BoolExp.html#check",
          "type": "function"
        },
        "index": {
          "hierarchy": "BoolExp",
          "module": "BoolExp",
          "name": "check",
          "normalized": "(a-\u003eBool)-\u003eBoolExp a-\u003eBool",
          "package": "GenI",
          "signature": "(a-\u003eBool)-\u003eBoolExp a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/BoolExp.html#v:check"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FullList.Internal",
          "name": "Internal",
          "package": "GenI",
          "source": "src/Data-FullList-Internal.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data FullList Internal",
          "module": "Data.FullList.Internal",
          "name": "Internal",
          "package": "GenI",
          "partial": "Internal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FullList.Internal",
          "name": "FullList",
          "package": "GenI",
          "source": "src/Data-FullList-Internal.html#FullList",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Data FullList Internal",
          "module": "Data.FullList.Internal",
          "name": "FullList",
          "package": "GenI",
          "partial": "Full List",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#t:FullList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FullList.Internal",
          "name": "Listable",
          "package": "GenI",
          "source": "src/Data-FullList-Internal.html#Listable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data FullList Internal",
          "module": "Data.FullList.Internal",
          "name": "Listable",
          "package": "GenI",
          "partial": "Listable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#t:Listable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FullList.Internal",
          "name": "(!:)",
          "package": "GenI",
          "signature": "a -\u003e l a -\u003e FullList a",
          "source": "src/Data-FullList-Internal.html#%21%3A",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data FullList Internal",
          "module": "Data.FullList.Internal",
          "name": "(!:) !:",
          "normalized": "a-\u003eb a-\u003eFullList a",
          "package": "GenI",
          "signature": "a-\u003el a-\u003eFullList a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#v:-33-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.FullList.Internal\",\"Data.FullList\"]",
          "name": "(++)",
          "package": "GenI",
          "signature": "FullList a -\u003e FullList a -\u003e FullList a",
          "source": "src/Data-FullList-Internal.html#%2B%2B",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#v:-43--43-\",\"http://hackage.haskell.org/package/GenI/docs/Data-FullList.html#v:-43--43-\"]"
        },
        "index": {
          "hierarchy": "Data FullList Internal",
          "module": "Data.FullList.Internal",
          "name": "(++) ++",
          "normalized": "FullList a-\u003eFullList a-\u003eFullList a",
          "package": "GenI",
          "signature": "FullList a-\u003eFullList a-\u003eFullList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#v:-43--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FullList.Internal",
          "name": "FullList",
          "package": "GenI",
          "signature": "FullList [a]",
          "source": "src/Data-FullList-Internal.html#FullList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FullList Internal",
          "module": "Data.FullList.Internal",
          "name": "FullList",
          "normalized": "FullList[a]",
          "package": "GenI",
          "partial": "Full List",
          "signature": "FullList[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#v:FullList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.FullList.Internal\",\"Data.FullList\"]",
          "name": "fromFL",
          "package": "GenI",
          "signature": "FullList a -\u003e [a]",
          "source": "src/Data-FullList-Internal.html#fromFL",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#v:fromFL\",\"http://hackage.haskell.org/package/GenI/docs/Data-FullList.html#v:fromFL\"]"
        },
        "index": {
          "hierarchy": "Data FullList Internal",
          "module": "Data.FullList.Internal",
          "name": "fromFL",
          "normalized": "FullList a-\u003e[a]",
          "package": "GenI",
          "partial": "FL",
          "signature": "FullList a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#v:fromFL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.FullList.Internal\",\"Data.FullList\"]",
          "name": "head",
          "package": "GenI",
          "signature": "FullList a -\u003e a",
          "source": "src/Data-FullList-Internal.html#head",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#v:head\",\"http://hackage.haskell.org/package/GenI/docs/Data-FullList.html#v:head\"]"
        },
        "index": {
          "hierarchy": "Data FullList Internal",
          "module": "Data.FullList.Internal",
          "name": "head",
          "normalized": "FullList a-\u003ea",
          "package": "GenI",
          "signature": "FullList a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#v:head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.FullList.Internal\",\"Data.FullList\"]",
          "name": "indeedFL",
          "package": "GenI",
          "signature": "[a] -\u003e w -\u003e (FullList a -\u003e w) -\u003e w",
          "source": "src/Data-FullList-Internal.html#indeedFL",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#v:indeedFL\",\"http://hackage.haskell.org/package/GenI/docs/Data-FullList.html#v:indeedFL\"]"
        },
        "index": {
          "hierarchy": "Data FullList Internal",
          "module": "Data.FullList.Internal",
          "name": "indeedFL",
          "normalized": "[a]-\u003eb-\u003e(FullList a-\u003eb)-\u003eb",
          "package": "GenI",
          "partial": "FL",
          "signature": "[a]-\u003ew-\u003e(FullList a-\u003ew)-\u003ew",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#v:indeedFL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.FullList.Internal\",\"Data.FullList\"]",
          "name": "sortNub",
          "package": "GenI",
          "signature": "FullList a -\u003e FullList a",
          "source": "src/Data-FullList-Internal.html#sortNub",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#v:sortNub\",\"http://hackage.haskell.org/package/GenI/docs/Data-FullList.html#v:sortNub\"]"
        },
        "index": {
          "hierarchy": "Data FullList Internal",
          "module": "Data.FullList.Internal",
          "name": "sortNub",
          "normalized": "FullList a-\u003eFullList a",
          "package": "GenI",
          "partial": "Nub",
          "signature": "FullList a-\u003eFullList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#v:sortNub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.FullList.Internal\",\"Data.FullList\"]",
          "name": "tail",
          "package": "GenI",
          "signature": "FullList a -\u003e [a]",
          "source": "src/Data-FullList-Internal.html#tail",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#v:tail\",\"http://hackage.haskell.org/package/GenI/docs/Data-FullList.html#v:tail\"]"
        },
        "index": {
          "hierarchy": "Data FullList Internal",
          "module": "Data.FullList.Internal",
          "name": "tail",
          "normalized": "FullList a-\u003e[a]",
          "package": "GenI",
          "signature": "FullList a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList-Internal.html#v:tail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FullList",
          "name": "FullList",
          "package": "GenI",
          "source": "src/Data-FullList.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data FullList",
          "module": "Data.FullList",
          "name": "FullList",
          "package": "GenI",
          "partial": "Full List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FullList",
          "name": "FullList",
          "package": "GenI",
          "source": "src/Data-FullList-Internal.html#FullList",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data FullList",
          "module": "Data.FullList",
          "name": "FullList",
          "package": "GenI",
          "partial": "Full List",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList.html#t:FullList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FullList",
          "name": "Listable",
          "package": "GenI",
          "source": "src/Data-FullList-Internal.html#Listable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data FullList",
          "module": "Data.FullList",
          "name": "Listable",
          "package": "GenI",
          "partial": "Listable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList.html#t:Listable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FullList",
          "name": "(!:)",
          "package": "GenI",
          "signature": "a -\u003e l a -\u003e FullList a",
          "source": "src/Data-FullList-Internal.html#%21%3A",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data FullList",
          "module": "Data.FullList",
          "name": "(!:) !:",
          "normalized": "a-\u003eb a-\u003eFullList a",
          "package": "GenI",
          "signature": "a-\u003el a-\u003eFullList a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/Data-FullList.html#v:-33-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides a simple, naive implementation of nondeterministic\n   finite automata (NFA).\n\u003c/p\u003e\u003cp\u003eThe transition function consists of a \u003ccode\u003eMap\u003c/code\u003e, but there are also accessor\n   function which help you query the automaton without worrying about how\n   it's implemented.\n\u003c/p\u003e\u003col\u003e\u003cli\u003e  The states are a list of lists, not just a simple flat list as\n        you might expect.  This allows you to optionally group your\n        states into \"columns\" which is something we use in the\n        GenI polarity automaton optimisation.\n\u003c/li\u003e\u003cli\u003e  We model the empty an empty transition as the transition on\n        \u003ccode\u003eNothing\u003c/code\u003e.  All other transitions are \u003ccode\u003eJust\u003c/code\u003e something.\n\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e",
          "module": "NLP.GenI.Automaton",
          "name": "Automaton",
          "package": "GenI",
          "source": "src/NLP-GenI-Automaton.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides simple naive implementation of nondeterministic finite automata NFA The transition function consists of Map but there are also accessor function which help you query the automaton without worrying about how it implemented The states are list of lists not just simple flat list as you might expect This allows you to optionally group your states into columns which is something we use in the GenI polarity automaton optimisation We model the empty an empty transition as the transition on Nothing All other transitions are Just something",
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "Automaton",
          "package": "GenI",
          "partial": "Automaton",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNote: you can define the final state either by setting \u003ccode\u003e\u003ca\u003eisFinalSt\u003c/a\u003e\u003c/code\u003e\n   to \u003ccode\u003eJust f\u003c/code\u003e where \u003ccode\u003ef\u003c/code\u003e is some function or by putting them in\n   \u003ccode\u003e\u003ca\u003efinalStList\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.Automaton",
          "name": "NFA",
          "package": "GenI",
          "source": "src/NLP-GenI-Automaton.html#NFA",
          "type": "data"
        },
        "index": {
          "description": "Note you can define the final state either by setting isFinalSt to Just where is some function or by putting them in finalStList",
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "NFA",
          "package": "GenI",
          "partial": "NFA",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#t:NFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Automaton",
          "name": "NFA",
          "package": "GenI",
          "signature": "NFA",
          "source": "src/NLP-GenI-Automaton.html#NFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "NFA",
          "package": "GenI",
          "partial": "NFA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:NFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Automaton",
          "name": "addTrans",
          "package": "GenI",
          "signature": "NFA st ab-\u003e st-\u003e Maybe ab-\u003e st-\u003e NFA st ab",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "addTrans",
          "normalized": "NFA a b-\u003ea-\u003eMaybe b-\u003ea-\u003eNFA a b",
          "package": "GenI",
          "partial": "Trans",
          "signature": "NFA st ab-\u003est-\u003eMaybe ab-\u003est-\u003eNFA st ab",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:addTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of all bundled paths.  A bundled path is a sequence of\n   states through the automaton from the start state to any dead\n   end.  Any two neighbouring states can have more than one\n   possible transition between them, so the bundles can multiply\n   out to a lot of different possible paths.\n\u003c/p\u003e\u003cp\u003eThe output is a list of lists of lists:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Each item in the outer list is a bundled path through the\n   automaton, i.e. without distinguishing between the possible\n   transitions from any two neighbouring states\n\u003c/li\u003e\u003cli\u003e Each item in the middle list is represents the set of\n   transitions between two given neighbouring states\n\u003c/li\u003e\u003cli\u003e Each item in the inner list represents a transition\n   between two given states\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "NLP.GenI.Automaton",
          "name": "automatonPathSets",
          "package": "GenI",
          "signature": "NFA st ab -\u003e [[[ab]]]",
          "source": "src/NLP-GenI-Automaton.html#automatonPathSets",
          "type": "function"
        },
        "index": {
          "description": "The set of all bundled paths bundled path is sequence of states through the automaton from the start state to any dead end Any two neighbouring states can have more than one possible transition between them so the bundles can multiply out to lot of different possible paths The output is list of lists of lists Each item in the outer list is bundled path through the automaton i.e without distinguishing between the possible transitions from any two neighbouring states Each item in the middle list is represents the set of transitions between two given neighbouring states Each item in the inner list represents transition between two given states",
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "automatonPathSets",
          "normalized": "NFA a b-\u003e[[[b]]]",
          "package": "GenI",
          "partial": "Path Sets",
          "signature": "NFA st ab-\u003e[[[ab]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:automatonPathSets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns all possible paths through an automaton from the\n   start state to any dead-end.\n\u003c/p\u003e\u003cp\u003eEach path is represented as a list of labels.\n\u003c/p\u003e\u003cp\u003eWe assume that the automaton does not have any loops\n   in it.\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.Automaton\",\"NLP.GenI.Polarity\"]",
          "name": "automatonPaths",
          "package": "GenI",
          "signature": "NFA st ab -\u003e [[ab]]",
          "source": "src/NLP-GenI-Automaton.html#automatonPaths",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:automatonPaths\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:automatonPaths\"]"
        },
        "index": {
          "description": "Returns all possible paths through an automaton from the start state to any dead-end Each path is represented as list of labels We assume that the automaton does not have any loops in it",
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "automatonPaths",
          "normalized": "NFA a b-\u003e[[b]]",
          "package": "GenI",
          "partial": "Paths",
          "signature": "NFA st ab-\u003e[[ab]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:automatonPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efinalSt\u003c/a\u003e\u003c/code\u003e returns all the final states of an automaton\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.Automaton\",\"NLP.GenI.Polarity\"]",
          "name": "finalSt",
          "package": "GenI",
          "signature": "NFA st ab -\u003e [st]",
          "source": "src/NLP-GenI-Automaton.html#finalSt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:finalSt\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:finalSt\"]"
        },
        "index": {
          "description": "finalSt returns all the final states of an automaton",
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "finalSt",
          "normalized": "NFA a b-\u003e[a]",
          "package": "GenI",
          "partial": "St",
          "signature": "NFA st ab-\u003e[st]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:finalSt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecan be ignored if \u003ccode\u003e\u003ca\u003eisFinalSt\u003c/a\u003e\u003c/code\u003e is defined\n\u003c/p\u003e",
          "module": "NLP.GenI.Automaton",
          "name": "finalStList",
          "package": "GenI",
          "signature": "[st]",
          "source": "src/NLP-GenI-Automaton.html#NFA",
          "type": "function"
        },
        "index": {
          "description": "can be ignored if isFinalSt is defined",
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "finalStList",
          "normalized": "[a]",
          "package": "GenI",
          "partial": "St List",
          "signature": "[st]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:finalStList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efinalSt\u003c/a\u003e\u003c/code\u003e will use this if defined\n\u003c/p\u003e",
          "module": "NLP.GenI.Automaton",
          "name": "isFinalSt",
          "package": "GenI",
          "signature": "Maybe (st -\u003e Bool)",
          "source": "src/NLP-GenI-Automaton.html#NFA",
          "type": "function"
        },
        "index": {
          "description": "finalSt will use this if defined",
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "isFinalSt",
          "normalized": "Maybe(a-\u003eBool)",
          "package": "GenI",
          "partial": "Final St",
          "signature": "Maybe(st-\u003eBool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:isFinalSt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003elookupTrans\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eaut st1 ab\u003c/code\u003e returns the states that \u003ccode\u003est1\u003c/code\u003e transitions\n   to via \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "NLP.GenI.Automaton",
          "name": "lookupTrans",
          "package": "GenI",
          "signature": "NFA st ab -\u003e st -\u003e Maybe ab -\u003e [st]",
          "source": "src/NLP-GenI-Automaton.html#lookupTrans",
          "type": "function"
        },
        "index": {
          "description": "lookupTrans aut st1 ab returns the states that st1 transitions to via",
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "lookupTrans",
          "normalized": "NFA a b-\u003ea-\u003eMaybe b-\u003e[a]",
          "package": "GenI",
          "partial": "Trans",
          "signature": "NFA st ab-\u003est-\u003eMaybe ab-\u003e[st]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:lookupTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Automaton",
          "name": "numStates",
          "package": "GenI",
          "signature": "NFA st ab -\u003e Int",
          "source": "src/NLP-GenI-Automaton.html#numStates",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "numStates",
          "normalized": "NFA a b-\u003eInt",
          "package": "GenI",
          "partial": "States",
          "signature": "NFA st ab-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:numStates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Automaton",
          "name": "numTransitions",
          "package": "GenI",
          "signature": "NFA st ab -\u003e Int",
          "source": "src/NLP-GenI-Automaton.html#numTransitions",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "numTransitions",
          "normalized": "NFA a b-\u003eInt",
          "package": "GenI",
          "partial": "Transitions",
          "signature": "NFA st ab-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:numTransitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Automaton",
          "name": "startSt",
          "package": "GenI",
          "signature": "st",
          "source": "src/NLP-GenI-Automaton.html#NFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "startSt",
          "package": "GenI",
          "partial": "St",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:startSt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eif you don't care about grouping states into columns\n   you can just dump everything in one big list\n\u003c/p\u003e",
          "module": "NLP.GenI.Automaton",
          "name": "states",
          "package": "GenI",
          "signature": "[[st]]",
          "source": "src/NLP-GenI-Automaton.html#NFA",
          "type": "function"
        },
        "index": {
          "description": "if you don care about grouping states into columns you can just dump everything in one big list",
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "states",
          "normalized": "[[a]]",
          "package": "GenI",
          "signature": "[[st]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:states"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethere can be more than one transition between any two states\n   and a transition could be the empty symbol\n\u003c/p\u003e",
          "module": "NLP.GenI.Automaton",
          "name": "transitions",
          "package": "GenI",
          "signature": "Map st (Map st [Maybe ab])",
          "source": "src/NLP-GenI-Automaton.html#NFA",
          "type": "function"
        },
        "index": {
          "description": "there can be more than one transition between any two states and transition could be the empty symbol",
          "hierarchy": "NLP GenI Automaton",
          "module": "NLP.GenI.Automaton",
          "name": "transitions",
          "normalized": "Map a(Map a[Maybe b])",
          "package": "GenI",
          "signature": "Map st(Map st[Maybe ab])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Automaton.html#v:transitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe heavy lifting of GenI, the whole chart/agenda mechanism, can be\nimplemented in many ways.  To make it easier to write different\nalgorithms for GenI and compare them, we provide a single interface\nfor what we call Builders.\n\u003c/p\u003e\u003cp\u003eThis interface is then used called by the Geni module and by the\ngraphical interface.  Note that each builder has its own graphical\ninterface and that we do a similar thing in the graphical interface\ncode to make it possible to use these GUIs.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.Builder",
          "name": "Builder",
          "package": "GenI",
          "source": "src/NLP-GenI-Builder.html",
          "type": "module"
        },
        "index": {
          "description": "The heavy lifting of GenI the whole chart agenda mechanism can be implemented in many ways To make it easier to write different algorithms for GenI and compare them we provide single interface for what we call Builders This interface is then used called by the Geni module and by the graphical interface Note that each builder has its own graphical interface and that we do similar thing in the graphical interface code to make it possible to use these GUIs",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "Builder",
          "package": "GenI",
          "partial": "Builder",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "Builder",
          "package": "GenI",
          "source": "src/NLP-GenI-Builder.html#Builder",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "Builder",
          "package": "GenI",
          "partial": "Builder",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#t:Builder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "BuilderState",
          "package": "GenI",
          "source": "src/NLP-GenI-Builder.html#BuilderState",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "BuilderState",
          "package": "GenI",
          "partial": "Builder State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#t:BuilderState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDispatching consists of assigning a chart item to the right part of the\n   chart (agenda, trash, results list, etc).  This is implemented as a\n   series of filters which can either fail or succeed.  If a filter fails,\n   it may modify the item before passing it on to future filters.\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "DispatchFilter",
          "package": "GenI",
          "source": "src/NLP-GenI-Builder.html#DispatchFilter",
          "type": "type"
        },
        "index": {
          "description": "Dispatching consists of assigning chart item to the right part of the chart agenda trash results list etc This is implemented as series of filters which can either fail or succeed If filter fails it may modify the item before passing it on to future filters",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "DispatchFilter",
          "package": "GenI",
          "partial": "Dispatch Filter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#t:DispatchFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "FilterStatus",
          "package": "GenI",
          "source": "src/NLP-GenI-Builder.html#FilterStatus",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "FilterStatus",
          "package": "GenI",
          "partial": "Filter Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#t:FilterStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "GenStatus",
          "package": "GenI",
          "source": "src/NLP-GenI-Builder.html#GenStatus",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "GenStatus",
          "package": "GenI",
          "partial": "Gen Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#t:GenStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eInput\u003c/a\u003e\u003c/code\u003e represents the set of inputs a backend could take\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "Input",
          "package": "GenI",
          "source": "src/NLP-GenI-Builder.html#Input",
          "type": "data"
        },
        "index": {
          "description": "Input represents the set of inputs backend could take",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "Input",
          "package": "GenI",
          "partial": "Input",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#t:Input"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "Output",
          "package": "GenI",
          "source": "src/NLP-GenI-Builder.html#Output",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "Output",
          "package": "GenI",
          "partial": "Output",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#t:Output"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "SemBitMap",
          "package": "GenI",
          "source": "src/NLP-GenI-Builder.html#SemBitMap",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "SemBitMap",
          "package": "GenI",
          "partial": "Sem Bit Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#t:SemBitMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA SentenceAut represents a set of sentences in the form of an automaton.\n   The labels of the automaton are the words of the sentence.  But note!\n   &#8220;word&#8220; in the sentence is in fact a tuple (lemma, inflectional feature\n   structures).  Normally, the states are defined as integers, with the\n   only requirement being that each one, naturally enough, is unique.\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "SentenceAut",
          "package": "GenI",
          "source": "src/NLP-GenI-Builder.html#SentenceAut",
          "type": "type"
        },
        "index": {
          "description": "SentenceAut represents set of sentences in the form of an automaton The labels of the automaton are the words of the sentence But note word in the sentence is in fact tuple lemma inflectional feature structures Normally the states are defined as integers with the only requirement being that each one naturally enough is unique",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "SentenceAut",
          "package": "GenI",
          "partial": "Sentence Aut",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#t:SentenceAut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "TagDerivation",
          "package": "GenI",
          "source": "src/NLP-GenI-Tag.html#TagDerivation",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "TagDerivation",
          "package": "GenI",
          "partial": "Tag Derivation",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#t:TagDerivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "UninflectedDisjunction",
          "package": "GenI",
          "source": "src/NLP-GenI-Builder.html#UninflectedDisjunction",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "UninflectedDisjunction",
          "package": "GenI",
          "partial": "Uninflected Disjunction",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#t:UninflectedDisjunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequence two dispatch filters.\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "(\u003e--\u003e)",
          "package": "GenI",
          "signature": "DispatchFilter s a -\u003e DispatchFilter s a -\u003e DispatchFilter s a",
          "source": "src/NLP-GenI-Builder.html#%3E--%3E",
          "type": "function"
        },
        "index": {
          "description": "Sequence two dispatch filters",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "(\u003e--\u003e) \u003e--\u003e",
          "normalized": "DispatchFilter a b-\u003eDispatchFilter a b-\u003eDispatchFilter a b",
          "package": "GenI",
          "signature": "DispatchFilter s a-\u003eDispatchFilter s a-\u003eDispatchFilter s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:-62--45--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "Active",
          "package": "GenI",
          "signature": "Active",
          "source": "src/NLP-GenI-Builder.html#GenStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "Active",
          "package": "GenI",
          "partial": "Active",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:Active"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "Builder",
          "package": "GenI",
          "signature": "Builder",
          "source": "src/NLP-GenI-Builder.html#Builder",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "Builder",
          "package": "GenI",
          "partial": "Builder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:Builder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "Error",
          "package": "GenI",
          "signature": "Error Text",
          "source": "src/NLP-GenI-Builder.html#GenStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "Error",
          "package": "GenI",
          "partial": "Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:Error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "Filtered",
          "package": "GenI",
          "signature": "Filtered",
          "source": "src/NLP-GenI-Builder.html#FilterStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "Filtered",
          "package": "GenI",
          "partial": "Filtered",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:Filtered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "Finished",
          "package": "GenI",
          "signature": "Finished",
          "source": "src/NLP-GenI-Builder.html#GenStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "Finished",
          "package": "GenI",
          "partial": "Finished",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:Finished"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "Input",
          "package": "GenI",
          "signature": "Input",
          "source": "src/NLP-GenI-Builder.html#Input",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "Input",
          "package": "GenI",
          "partial": "Input",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:Input"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "NotFiltered",
          "package": "GenI",
          "signature": "NotFiltered a",
          "source": "src/NLP-GenI-Builder.html#FilterStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "NotFiltered",
          "package": "GenI",
          "partial": "Not Filtered",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:NotFiltered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "UninflectedDisjunction",
          "package": "GenI",
          "signature": "UninflectedDisjunction [Text] (Flist GeniVal)",
          "source": "src/NLP-GenI-Builder.html#UninflectedDisjunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "UninflectedDisjunction",
          "normalized": "UninflectedDisjunction[Text](Flist GeniVal)",
          "package": "GenI",
          "partial": "Uninflected Disjunction",
          "signature": "UninflectedDisjunction[Text](Flist GeniVal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:UninflectedDisjunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "bitVectorToSem",
          "package": "GenI",
          "signature": "SemBitMap -\u003e BitVector -\u003e Sem",
          "source": "src/NLP-GenI-Builder.html#bitVectorToSem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "bitVectorToSem",
          "normalized": "SemBitMap-\u003eBitVector-\u003eSem",
          "package": "GenI",
          "partial": "Vector To Sem",
          "signature": "SemBitMap-\u003eBitVector-\u003eSem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:bitVectorToSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "chart_size",
          "package": "GenI",
          "signature": "String",
          "source": "src/NLP-GenI-Builder.html#chart_size",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "chart_size",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:chart_size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the item meets some condition, use the first filter, otherwise\n   use the second one.\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "condFilter",
          "package": "GenI",
          "signature": "(a -\u003e Bool) -\u003e DispatchFilter s a -\u003e DispatchFilter s a -\u003e DispatchFilter s a",
          "source": "src/NLP-GenI-Builder.html#condFilter",
          "type": "function"
        },
        "index": {
          "description": "If the item meets some condition use the first filter otherwise use the second one",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "condFilter",
          "normalized": "(a-\u003eBool)-\u003eDispatchFilter b a-\u003eDispatchFilter b a-\u003eDispatchFilter b a",
          "package": "GenI",
          "partial": "Filter",
          "signature": "(a-\u003eBool)-\u003eDispatchFilter s a-\u003eDispatchFilter s a-\u003eDispatchFilter s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:condFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "defaultMetricNames",
          "package": "GenI",
          "signature": "[String]",
          "source": "src/NLP-GenI-Builder.html#defaultMetricNames",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "defaultMetricNames",
          "normalized": "[String]",
          "package": "GenI",
          "partial": "Metric Names",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:defaultMetricNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault implementation for the \u003ccode\u003e\u003ca\u003estepAll\u003c/a\u003e\u003c/code\u003e function in \u003ccode\u003e\u003ca\u003eBuilder\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "defaultStepAll",
          "package": "GenI",
          "signature": "Builder st it -\u003e BuilderState st ()",
          "source": "src/NLP-GenI-Builder.html#defaultStepAll",
          "type": "function"
        },
        "index": {
          "description": "Default implementation for the stepAll function in Builder",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "defaultStepAll",
          "normalized": "Builder a b-\u003eBuilderState a()",
          "package": "GenI",
          "partial": "Step All",
          "signature": "Builder st it-\u003eBuilderState st()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:defaultStepAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eassign a bit vector value to each literal in the semantics\n the resulting map can then be used to construct a bit vector\n representation of the semantics\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "defineSemanticBits",
          "package": "GenI",
          "signature": "Sem -\u003e SemBitMap",
          "source": "src/NLP-GenI-Builder.html#defineSemanticBits",
          "type": "function"
        },
        "index": {
          "description": "assign bit vector value to each literal in the semantics the resulting map can then be used to construct bit vector representation of the semantics",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "defineSemanticBits",
          "normalized": "Sem-\u003eSemBitMap",
          "package": "GenI",
          "partial": "Semantic Bits",
          "signature": "Sem-\u003eSemBitMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:defineSemanticBits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edetermine if realisation is finished\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "finished",
          "package": "GenI",
          "signature": "st -\u003e GenStatus",
          "source": "src/NLP-GenI-Builder.html#Builder",
          "type": "function"
        },
        "index": {
          "description": "determine if realisation is finished",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "finished",
          "normalized": "a-\u003eGenStatus",
          "package": "GenI",
          "signature": "st-\u003eGenStatus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:finished"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etag tree\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "inCands",
          "package": "GenI",
          "signature": "[(TagElem, PolPathSet)]",
          "source": "src/NLP-GenI-Builder.html#Input",
          "type": "function"
        },
        "index": {
          "description": "tag tree",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "inCands",
          "normalized": "[(TagElem,PolPathSet)]",
          "package": "GenI",
          "partial": "Cands",
          "signature": "[(TagElem,PolPathSet)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:inCands"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efor the debugger\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "inLex",
          "package": "GenI",
          "signature": "[LexEntry]",
          "source": "src/NLP-GenI-Builder.html#Input",
          "type": "function"
        },
        "index": {
          "description": "for the debugger",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "inLex",
          "normalized": "[LexEntry]",
          "package": "GenI",
          "partial": "Lex",
          "signature": "[LexEntry]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:inLex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "inSemInput",
          "package": "GenI",
          "signature": "SemInput",
          "source": "src/NLP-GenI-Builder.html#Input",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "inSemInput",
          "package": "GenI",
          "partial": "Sem Input",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:inSemInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "incrCounter",
          "package": "GenI",
          "signature": "String -\u003e Int -\u003e BuilderState st ()",
          "source": "src/NLP-GenI-Builder.html#incrCounter",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "incrCounter",
          "normalized": "String-\u003eInt-\u003eBuilderState a()",
          "package": "GenI",
          "partial": "Counter",
          "signature": "String-\u003eInt-\u003eBuilderState st()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:incrCounter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einitialise the machine from the semantics and lexical selection\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "init",
          "package": "GenI",
          "signature": "Input -\u003e [Flag] -\u003e (st, Statistics)",
          "source": "src/NLP-GenI-Builder.html#Builder",
          "type": "function"
        },
        "index": {
          "description": "initialise the machine from the semantics and lexical selection",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "init",
          "normalized": "Input-\u003e[Flag]-\u003e(a,Statistics)",
          "package": "GenI",
          "signature": "Input-\u003e[Flag]-\u003e(st,Statistics)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:init"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "initStats",
          "package": "GenI",
          "signature": "[Flag] -\u003e Statistics",
          "source": "src/NLP-GenI-Builder.html#initStats",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "initStats",
          "normalized": "[Flag]-\u003eStatistics",
          "package": "GenI",
          "partial": "Stats",
          "signature": "[Flag]-\u003eStatistics",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:initStats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe names of lexically selected chart items used in a derivation\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "lexicalSelection",
          "package": "GenI",
          "signature": "TagDerivation -\u003e [Text]",
          "source": "src/NLP-GenI-Builder.html#lexicalSelection",
          "type": "function"
        },
        "index": {
          "description": "The names of lexically selected chart items used in derivation",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "lexicalSelection",
          "normalized": "TagDerivation-\u003e[Text]",
          "package": "GenI",
          "partial": "Selection",
          "signature": "TagDerivation-\u003e[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:lexicalSelection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "num_comparisons",
          "package": "GenI",
          "signature": "String",
          "source": "src/NLP-GenI-Builder.html#num_comparisons",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "num_comparisons",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:num_comparisons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "num_iterations",
          "package": "GenI",
          "signature": "String",
          "source": "src/NLP-GenI-Builder.html#num_iterations",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "num_iterations",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:num_iterations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "partial",
          "package": "GenI",
          "signature": "st -\u003e [Output]",
          "source": "src/NLP-GenI-Builder.html#Builder",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "partial",
          "normalized": "a-\u003e[Output]",
          "package": "GenI",
          "signature": "st-\u003e[Output]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:partial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "preInit",
          "package": "GenI",
          "signature": "Input -\u003e [Flag] -\u003e (Input, PolResult)",
          "source": "src/NLP-GenI-Builder.html#preInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "preInit",
          "normalized": "Input-\u003e[Flag]-\u003e(Input,PolResult)",
          "package": "GenI",
          "partial": "Init",
          "signature": "Input-\u003e[Flag]-\u003e(Input,PolResult)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:preInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "queryCounter",
          "package": "GenI",
          "signature": "String -\u003e Statistics -\u003e Maybe Int",
          "source": "src/NLP-GenI-Builder.html#queryCounter",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "queryCounter",
          "normalized": "String-\u003eStatistics-\u003eMaybe Int",
          "package": "GenI",
          "partial": "Counter",
          "signature": "String-\u003eStatistics-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:queryCounter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerforms surface realisation from an input semantics and a lexical selection.\n\u003c/p\u003e\u003cp\u003eStatistics tracked\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e pol_used_bundles - number of bundled paths through the polarity automaton.\n                         see \u003ccode\u003e\u003ca\u003eautomatonPathSets\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e pol_used_paths - number of paths through the final automaton\n\u003c/li\u003e\u003cli\u003e pol_seed_paths - number of paths through the seed automaton (i.e. with no polarities).\n                       This is normally just 1, unless you have multi-literal semantics\n\u003c/li\u003e\u003cli\u003e pol_total_states - combined number of states in the all the polarity automata\n\u003c/li\u003e\u003cli\u003e pol_total_tras - combined number of transitions in all polarity automata\n\u003c/li\u003e\u003cli\u003e pol_max_states - number of states in the polarity automaton with the most states\n\u003c/li\u003e\u003cli\u003e pol_total_tras - number of transitions in the polarity automata with the most transitions\n\u003c/li\u003e\u003cli\u003e sem_literals    - number of literals in the input semantics\n\u003c/li\u003e\u003cli\u003e lex_trees       - total number of lexically selected trees\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "NLP.GenI.Builder",
          "name": "run",
          "package": "GenI",
          "signature": "Builder st it -\u003e Input -\u003e [Flag] -\u003e (st, Statistics)",
          "source": "src/NLP-GenI-Builder.html#run",
          "type": "function"
        },
        "index": {
          "description": "Performs surface realisation from an input semantics and lexical selection Statistics tracked pol used bundles number of bundled paths through the polarity automaton see automatonPathSets pol used paths number of paths through the final automaton pol seed paths number of paths through the seed automaton i.e with no polarities This is normally just unless you have multi-literal semantics pol total states combined number of states in the all the polarity automata pol total tras combined number of transitions in all polarity automata pol max states number of states in the polarity automaton with the most states pol total tras number of transitions in the polarity automata with the most transitions sem literals number of literals in the input semantics lex trees total number of lexically selected trees",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "run",
          "normalized": "Builder a b-\u003eInput-\u003e[Flag]-\u003e(a,Statistics)",
          "package": "GenI",
          "signature": "Builder st it-\u003eInput-\u003e[Flag]-\u003e(st,Statistics)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Builder",
          "name": "semToBitVector",
          "package": "GenI",
          "signature": "SemBitMap -\u003e Sem -\u003e BitVector",
          "source": "src/NLP-GenI-Builder.html#semToBitVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "semToBitVector",
          "normalized": "SemBitMap-\u003eSem-\u003eBitVector",
          "package": "GenI",
          "partial": "To Bit Vector",
          "signature": "SemBitMap-\u003eSem-\u003eBitVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:semToBitVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erun a realisation step\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "step",
          "package": "GenI",
          "signature": "BuilderState st ()",
          "source": "src/NLP-GenI-Builder.html#Builder",
          "type": "function"
        },
        "index": {
          "description": "run realisation step",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "step",
          "normalized": "BuilderState a()",
          "package": "GenI",
          "signature": "BuilderState st()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erun all realisations steps until completion\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "stepAll",
          "package": "GenI",
          "signature": "BuilderState st ()",
          "source": "src/NLP-GenI-Builder.html#Builder",
          "type": "function"
        },
        "index": {
          "description": "run all realisations steps until completion",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "stepAll",
          "normalized": "BuilderState a()",
          "package": "GenI",
          "partial": "All",
          "signature": "BuilderState st()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:stepAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent to \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e unless the input contains an empty or uninstatiated\n   semantics\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "unlessEmptySem",
          "package": "GenI",
          "signature": "Input -\u003e [Flag] -\u003e a -\u003e a",
          "source": "src/NLP-GenI-Builder.html#unlessEmptySem",
          "type": "function"
        },
        "index": {
          "description": "Equivalent to id unless the input contains an empty or uninstatiated semantics",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "unlessEmptySem",
          "normalized": "Input-\u003e[Flag]-\u003ea-\u003ea",
          "package": "GenI",
          "partial": "Empty Sem",
          "signature": "Input-\u003e[Flag]-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:unlessEmptySem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunpack chart results into a list of sentences\n\u003c/p\u003e",
          "module": "NLP.GenI.Builder",
          "name": "unpack",
          "package": "GenI",
          "signature": "st -\u003e [Output]",
          "source": "src/NLP-GenI-Builder.html#Builder",
          "type": "function"
        },
        "index": {
          "description": "unpack chart results into list of sentences",
          "hierarchy": "NLP GenI Builder",
          "module": "NLP.GenI.Builder",
          "name": "unpack",
          "normalized": "a-\u003e[Output]",
          "package": "GenI",
          "signature": "st-\u003e[Output]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Builder.html#v:unpack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "Configuration",
          "package": "GenI",
          "source": "src/NLP-GenI-Configuration.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "Configuration",
          "package": "GenI",
          "partial": "Configuration",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e allows a concrete representation of a type to\n be calculated.\n\u003c/p\u003e",
          "module": "NLP.GenI.Configuration",
          "name": "Typeable",
          "package": "GenI",
          "type": "class"
        },
        "index": {
          "description": "The class Typeable allows concrete representation of type to be calculated",
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "Typeable",
          "package": "GenI",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#t:Typeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "basicSections",
          "package": "GenI",
          "signature": "[OptSection]",
          "source": "src/NLP-GenI-Configuration.html#basicSections",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "basicSections",
          "normalized": "[OptSection]",
          "package": "GenI",
          "partial": "Sections",
          "signature": "[OptSection]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:basicSections"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "defineParams",
          "package": "GenI",
          "signature": "[Flag] -\u003e Params -\u003e Params",
          "source": "src/NLP-GenI-Configuration.html#defineParams",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "defineParams",
          "normalized": "[Flag]-\u003eParams-\u003eParams",
          "package": "GenI",
          "partial": "Params",
          "signature": "[Flag]-\u003eParams-\u003eParams",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:defineParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default parameters configuration\n\u003c/p\u003e",
          "module": "NLP.GenI.Configuration",
          "name": "emptyParams",
          "package": "GenI",
          "signature": "Params",
          "source": "src/NLP-GenI-Configuration.html#emptyParams",
          "type": "function"
        },
        "index": {
          "description": "The default parameters configuration",
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "emptyParams",
          "package": "GenI",
          "partial": "Params",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:emptyParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "getBuilderType",
          "package": "GenI",
          "signature": "Params -\u003e BuilderType",
          "source": "src/NLP-GenI-Configuration.html#getBuilderType",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "getBuilderType",
          "normalized": "Params-\u003eBuilderType",
          "package": "GenI",
          "partial": "Builder Type",
          "signature": "Params-\u003eBuilderType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:getBuilderType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "getRanking",
          "package": "GenI",
          "signature": "Params -\u003e OtRanking",
          "source": "src/NLP-GenI-Configuration.html#getRanking",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "getRanking",
          "normalized": "Params-\u003eOtRanking",
          "package": "GenI",
          "partial": "Ranking",
          "signature": "Params-\u003eOtRanking",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:getRanking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "helpOption",
          "package": "GenI",
          "signature": "OptDescr Flag",
          "source": "src/NLP-GenI-Configuration.html#helpOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "helpOption",
          "package": "GenI",
          "partial": "Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:helpOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "lexiconOption",
          "package": "GenI",
          "signature": "OptDescr Flag",
          "source": "src/NLP-GenI-Configuration.html#lexiconOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "lexiconOption",
          "package": "GenI",
          "partial": "Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:lexiconOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "macrosOption",
          "package": "GenI",
          "signature": "OptDescr Flag",
          "source": "src/NLP-GenI-Configuration.html#macrosOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "macrosOption",
          "package": "GenI",
          "partial": "Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:macrosOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "mainBuilderTypes",
          "package": "GenI",
          "signature": "[BuilderType]",
          "source": "src/NLP-GenI-Configuration.html#mainBuilderTypes",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "mainBuilderTypes",
          "normalized": "[BuilderType]",
          "package": "GenI",
          "partial": "Builder Types",
          "signature": "[BuilderType]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:mainBuilderTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "noArg",
          "package": "GenI",
          "signature": "(() -\u003e f) -\u003e ArgDescr Flag",
          "source": "src/NLP-GenI-Configuration.html#noArg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "noArg",
          "normalized": "(()-\u003ea)-\u003eArgDescr Flag",
          "package": "GenI",
          "partial": "Arg",
          "signature": "(()-\u003ef)-\u003eArgDescr Flag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:noArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "nubBySwitches",
          "package": "GenI",
          "signature": "[OptDescr a] -\u003e [OptDescr a]",
          "source": "src/NLP-GenI-Configuration.html#nubBySwitches",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "nubBySwitches",
          "normalized": "[OptDescr a]-\u003e[OptDescr a]",
          "package": "GenI",
          "partial": "By Switches",
          "signature": "[OptDescr a]-\u003e[OptDescr a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:nubBySwitches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "optArg",
          "package": "GenI",
          "signature": "(x -\u003e f)-\u003e x-\u003e (String -\u003e x)-\u003e String-\u003e ArgDescr Flag",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "optArg",
          "normalized": "(a-\u003eb)-\u003ea-\u003e(String-\u003ea)-\u003eString-\u003eArgDescr Flag",
          "package": "GenI",
          "partial": "Arg",
          "signature": "(x-\u003ef)-\u003ex-\u003e(String-\u003ex)-\u003eString-\u003eArgDescr Flag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:optArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "optionsForBasicStuff",
          "package": "GenI",
          "signature": "[OptDescr Flag]",
          "source": "src/NLP-GenI-Configuration.html#optionsForBasicStuff",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "optionsForBasicStuff",
          "normalized": "[OptDescr Flag]",
          "package": "GenI",
          "partial": "For Basic Stuff",
          "signature": "[OptDescr Flag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:optionsForBasicStuff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "optionsForBuilder",
          "package": "GenI",
          "signature": "[OptDescr Flag]",
          "source": "src/NLP-GenI-Configuration.html#optionsForBuilder",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "optionsForBuilder",
          "normalized": "[OptDescr Flag]",
          "package": "GenI",
          "partial": "For Builder",
          "signature": "[OptDescr Flag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:optionsForBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "optionsForInputFiles",
          "package": "GenI",
          "signature": "[OptDescr Flag]",
          "source": "src/NLP-GenI-Configuration.html#optionsForInputFiles",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "optionsForInputFiles",
          "normalized": "[OptDescr Flag]",
          "package": "GenI",
          "partial": "For Input Files",
          "signature": "[OptDescr Flag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:optionsForInputFiles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "optionsForMorphology",
          "package": "GenI",
          "signature": "[OptDescr Flag]",
          "source": "src/NLP-GenI-Configuration.html#optionsForMorphology",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "optionsForMorphology",
          "normalized": "[OptDescr Flag]",
          "package": "GenI",
          "partial": "For Morphology",
          "signature": "[OptDescr Flag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:optionsForMorphology"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "optionsForOptimisation",
          "package": "GenI",
          "signature": "[OptDescr Flag]",
          "source": "src/NLP-GenI-Configuration.html#optionsForOptimisation",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "optionsForOptimisation",
          "normalized": "[OptDescr Flag]",
          "package": "GenI",
          "partial": "For Optimisation",
          "signature": "[OptDescr Flag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:optionsForOptimisation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUses the GetOpt library to process the command line arguments.\n Note that we divide them into basic and advanced usage.\n\u003c/p\u003e",
          "module": "NLP.GenI.Configuration",
          "name": "optionsForStandardGenI",
          "package": "GenI",
          "signature": "[OptDescr Flag]",
          "source": "src/NLP-GenI-Configuration.html#optionsForStandardGenI",
          "type": "function"
        },
        "index": {
          "description": "Uses the GetOpt library to process the command line arguments Note that we divide them into basic and advanced usage",
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "optionsForStandardGenI",
          "normalized": "[OptDescr Flag]",
          "package": "GenI",
          "partial": "For Standard Gen",
          "signature": "[OptDescr Flag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:optionsForStandardGenI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "optionsForTesting",
          "package": "GenI",
          "signature": "[OptDescr Flag]",
          "source": "src/NLP-GenI-Configuration.html#optionsForTesting",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "optionsForTesting",
          "normalized": "[OptDescr Flag]",
          "package": "GenI",
          "partial": "For Testing",
          "signature": "[OptDescr Flag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:optionsForTesting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "optionsSections",
          "package": "GenI",
          "signature": "[OptSection]",
          "source": "src/NLP-GenI-Configuration.html#optionsSections",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "optionsSections",
          "normalized": "[OptSection]",
          "package": "GenI",
          "partial": "Sections",
          "signature": "[OptSection]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:optionsSections"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTODO: This is a horrible and abusive use of \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.Configuration",
          "name": "parseFlagWithParsec",
          "package": "GenI",
          "signature": "String -\u003e Parser b -\u003e Text -\u003e b",
          "source": "src/NLP-GenI-Configuration.html#parseFlagWithParsec",
          "type": "function"
        },
        "index": {
          "description": "TODO This is horrible and abusive use of error",
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "parseFlagWithParsec",
          "normalized": "String-\u003eParser a-\u003eText-\u003ea",
          "package": "GenI",
          "partial": "Flag With Parsec",
          "signature": "String-\u003eParser b-\u003eText-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:parseFlagWithParsec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the internal instructions list, test suite and case\n   according to the contents of an instructions file.\n\u003c/p\u003e\u003cp\u003eBasic approach\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e we always have instructions: if no instructions file, is specified\n     we infer virtual instructions from the test suite flag\n   * the testsuite and testcase flags are focusing tools, they pick out\n     a subset from the instructions\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "NLP.GenI.Configuration",
          "name": "processInstructions",
          "package": "GenI",
          "signature": "Params -\u003e IO Params",
          "source": "src/NLP-GenI-Configuration.html#processInstructions",
          "type": "function"
        },
        "index": {
          "description": "Update the internal instructions list test suite and case according to the contents of an instructions file Basic approach we always have instructions if no instructions file is specified we infer virtual instructions from the test suite flag the testsuite and testcase flags are focusing tools they pick out subset from the instructions",
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "processInstructions",
          "normalized": "Params-\u003eIO Params",
          "package": "GenI",
          "partial": "Instructions",
          "signature": "Params-\u003eIO Params",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:processInstructions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "readGlobalConfig",
          "package": "GenI",
          "signature": "IO (Maybe YamlLight)",
          "source": "src/NLP-GenI-Configuration.html#readGlobalConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "readGlobalConfig",
          "package": "GenI",
          "partial": "Global Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:readGlobalConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "reqArg",
          "package": "GenI",
          "signature": "(x -\u003e f)-\u003e (String -\u003e x)-\u003e String-\u003e ArgDescr Flag",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "reqArg",
          "normalized": "(a-\u003eb)-\u003e(String-\u003ea)-\u003eString-\u003eArgDescr Flag",
          "package": "GenI",
          "partial": "Arg",
          "signature": "(x-\u003ef)-\u003e(String-\u003ex)-\u003eString-\u003eArgDescr Flag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:reqArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "setLoggers",
          "package": "GenI",
          "signature": "YamlLight -\u003e IO ()",
          "source": "src/NLP-GenI-Configuration.html#setLoggers",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "setLoggers",
          "normalized": "YamlLight-\u003eIO()",
          "package": "GenI",
          "partial": "Loggers",
          "signature": "YamlLight-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:setLoggers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "treatArgs",
          "package": "GenI",
          "signature": "[OptDescr Flag] -\u003e [String] -\u003e IO Params",
          "source": "src/NLP-GenI-Configuration.html#treatArgs",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "treatArgs",
          "normalized": "[OptDescr Flag]-\u003e[String]-\u003eIO Params",
          "package": "GenI",
          "partial": "Args",
          "signature": "[OptDescr Flag]-\u003e[String]-\u003eIO Params",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:treatArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "treatArgsWithParams",
          "package": "GenI",
          "signature": "[OptDescr Flag] -\u003e [String] -\u003e Params -\u003e IO Params",
          "source": "src/NLP-GenI-Configuration.html#treatArgsWithParams",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "treatArgsWithParams",
          "normalized": "[OptDescr Flag]-\u003e[String]-\u003eParams-\u003eIO Params",
          "package": "GenI",
          "partial": "Args With Params",
          "signature": "[OptDescr Flag]-\u003e[String]-\u003eParams-\u003eIO Params",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:treatArgsWithParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint out a GenI-style usage message with options divided into sections\n\u003c/p\u003e",
          "module": "NLP.GenI.Configuration",
          "name": "usage",
          "package": "GenI",
          "signature": "[OptSection]-\u003e String-\u003e String",
          "type": "function"
        },
        "index": {
          "description": "Print out GenI-style usage message with options divided into sections",
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "usage",
          "normalized": "[OptSection]-\u003eString-\u003eString",
          "package": "GenI",
          "signature": "[OptSection]-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:usage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Configuration",
          "name": "verboseOption",
          "package": "GenI",
          "signature": "OptDescr Flag",
          "source": "src/NLP-GenI-Configuration.html#verboseOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Configuration",
          "module": "NLP.GenI.Configuration",
          "name": "verboseOption",
          "package": "GenI",
          "partial": "Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Configuration.html#v:verboseOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe console user interface including batch processing on entire\n   test suites.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.Console",
          "name": "Console",
          "package": "GenI",
          "source": "src/NLP-GenI-Console.html",
          "type": "module"
        },
        "index": {
          "description": "The console user interface including batch processing on entire test suites",
          "hierarchy": "NLP GenI Console",
          "module": "NLP.GenI.Console",
          "name": "Console",
          "package": "GenI",
          "partial": "Console",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Console.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Console",
          "name": "RunAs",
          "package": "GenI",
          "source": "src/NLP-GenI-Console.html#RunAs",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Console",
          "module": "NLP.GenI.Console",
          "name": "RunAs",
          "package": "GenI",
          "partial": "Run As",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Console.html#t:RunAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Console",
          "name": "PartOfSuite",
          "package": "GenI",
          "signature": "PartOfSuite Text FilePath",
          "source": "src/NLP-GenI-Console.html#RunAs",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Console",
          "module": "NLP.GenI.Console",
          "name": "PartOfSuite",
          "package": "GenI",
          "partial": "Part Of Suite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Console.html#v:PartOfSuite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Console",
          "name": "Standalone",
          "package": "GenI",
          "signature": "Standalone FilePath FilePath",
          "source": "src/NLP-GenI-Console.html#RunAs",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Console",
          "module": "NLP.GenI.Console",
          "name": "Standalone",
          "package": "GenI",
          "partial": "Standalone",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Console.html#v:Standalone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Console",
          "name": "consoleGeni",
          "package": "GenI",
          "signature": "ProgStateRef -\u003e CustomSem sem -\u003e IO ()",
          "source": "src/NLP-GenI-Console.html#consoleGeni",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Console",
          "module": "NLP.GenI.Console",
          "name": "consoleGeni",
          "normalized": "ProgStateRef-\u003eCustomSem a-\u003eIO()",
          "package": "GenI",
          "partial": "Geni",
          "signature": "ProgStateRef-\u003eCustomSem sem-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Console.html#v:consoleGeni"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the batch directory or a temporary directory if unset\n\u003c/p\u003e",
          "module": "NLP.GenI.Console",
          "name": "getBatchDir",
          "package": "GenI",
          "signature": "fs -\u003e IO FilePath",
          "source": "src/NLP-GenI-Console.html#getBatchDir",
          "type": "function"
        },
        "index": {
          "description": "Return the batch directory or temporary directory if unset",
          "hierarchy": "NLP GenI Console",
          "module": "NLP.GenI.Console",
          "name": "getBatchDir",
          "normalized": "a-\u003eIO FilePath",
          "package": "GenI",
          "partial": "Batch Dir",
          "signature": "fs-\u003eIO FilePath",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Console.html#v:getBatchDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in processing instructions files. Each instruction consists of a\n   suite file and a list of test case names from that file\n\u003c/p\u003e\u003cp\u003eSee \u003ca\u003ehttp://projects.haskell.org/GenI/manual/command-line.html\u003c/a\u003e for\n   how testsuite, testcase, and instructions are expected to interact\n\u003c/p\u003e\u003cp\u003e(Exported for use by regression testing code)\n\u003c/p\u003e",
          "module": "NLP.GenI.Console",
          "name": "loadNextSuite",
          "package": "GenI",
          "signature": "ProgStateRef -\u003e CustomSem sem -\u003e (FilePath, Maybe [Text]) -\u003e IO [TestCase sem]",
          "source": "src/NLP-GenI-Console.html#loadNextSuite",
          "type": "function"
        },
        "index": {
          "description": "Used in processing instructions files Each instruction consists of suite file and list of test case names from that file See http projects.haskell.org GenI manual command-line.html for how testsuite testcase and instructions are expected to interact Exported for use by regression testing code",
          "hierarchy": "NLP GenI Console",
          "module": "NLP.GenI.Console",
          "name": "loadNextSuite",
          "normalized": "ProgStateRef-\u003eCustomSem a-\u003e(FilePath,Maybe[Text])-\u003eIO[TestCase a]",
          "package": "GenI",
          "partial": "Next Suite",
          "signature": "ProgStateRef-\u003eCustomSem sem-\u003e(FilePath,Maybe[Text])-\u003eIO[TestCase sem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Console.html#v:loadNextSuite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Console",
          "name": "writeResults",
          "package": "GenI",
          "signature": "ProgState-\u003e RunAs-\u003e CustomSem sem-\u003e Text-\u003e sem-\u003e GeniResults-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Console",
          "module": "NLP.GenI.Console",
          "name": "writeResults",
          "normalized": "ProgState-\u003eRunAs-\u003eCustomSem a-\u003eText-\u003ea-\u003eGeniResults-\u003eIO()",
          "package": "GenI",
          "partial": "Results",
          "signature": "ProgState-\u003eRunAs-\u003eCustomSem sem-\u003eText-\u003esem-\u003eGeniResults-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Console.html#v:writeResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Control",
          "name": "Control",
          "package": "GenI",
          "source": "src/NLP-GenI-Control.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI Control",
          "module": "NLP.GenI.Control",
          "name": "Control",
          "package": "GenI",
          "partial": "Control",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Control.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInputs that go around a single testcase/input\n\u003c/p\u003e",
          "module": "NLP.GenI.Control",
          "name": "Params",
          "package": "GenI",
          "source": "src/NLP-GenI-Control.html#Params",
          "type": "data"
        },
        "index": {
          "description": "Inputs that go around single testcase input",
          "hierarchy": "NLP GenI Control",
          "module": "NLP.GenI.Control",
          "name": "Params",
          "package": "GenI",
          "partial": "Params",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Control.html#t:Params"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Control",
          "name": "Params",
          "package": "GenI",
          "signature": "Params",
          "source": "src/NLP-GenI-Control.html#Params",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Control",
          "module": "NLP.GenI.Control",
          "name": "Params",
          "package": "GenI",
          "partial": "Params",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Control.html#v:Params"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Control",
          "name": "builderType",
          "package": "GenI",
          "signature": "Maybe BuilderType",
          "source": "src/NLP-GenI-Control.html#Params",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Control",
          "module": "NLP.GenI.Control",
          "name": "builderType",
          "package": "GenI",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Control.html#v:builderType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Control",
          "name": "geniFlags",
          "package": "GenI",
          "signature": "[Flag]",
          "source": "src/NLP-GenI-Control.html#Params",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Control",
          "module": "NLP.GenI.Control",
          "name": "geniFlags",
          "normalized": "[Flag]",
          "package": "GenI",
          "partial": "Flags",
          "signature": "[Flag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Control.html#v:geniFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCustom morph realiser may define a custom set of flags\n   that it accepts\n\u003c/p\u003e",
          "module": "NLP.GenI.Control",
          "name": "morphFlags",
          "package": "GenI",
          "signature": "[Flag]",
          "source": "src/NLP-GenI-Control.html#Params",
          "type": "function"
        },
        "index": {
          "description": "Custom morph realiser may define custom set of flags that it accepts",
          "hierarchy": "NLP GenI Control",
          "module": "NLP.GenI.Control",
          "name": "morphFlags",
          "normalized": "[Flag]",
          "package": "GenI",
          "partial": "Flags",
          "signature": "[Flag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Control.html#v:morphFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOT constraints (optional, uses global if unset)\n\u003c/p\u003e",
          "module": "NLP.GenI.Control",
          "name": "ranking",
          "package": "GenI",
          "signature": "Maybe OtRanking",
          "source": "src/NLP-GenI-Control.html#Params",
          "type": "function"
        },
        "index": {
          "description": "OT constraints optional uses global if unset",
          "hierarchy": "NLP GenI Control",
          "module": "NLP.GenI.Control",
          "name": "ranking",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Control.html#v:ranking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Control",
          "name": "updateParams",
          "package": "GenI",
          "signature": "Params-\u003e Params-\u003e Params",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Control",
          "module": "NLP.GenI.Control",
          "name": "updateParams",
          "normalized": "Params-\u003eParams-\u003eParams",
          "package": "GenI",
          "partial": "Params",
          "signature": "Params-\u003eParams-\u003eParams",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Control.html#v:updateParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.ErrorIO",
          "name": "ErrorIO",
          "package": "GenI",
          "source": "src/NLP-GenI-ErrorIO.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI ErrorIO",
          "module": "NLP.GenI.ErrorIO",
          "name": "ErrorIO",
          "package": "GenI",
          "partial": "Error IO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-ErrorIO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.ErrorIO",
          "name": "ErrorIO",
          "package": "GenI",
          "source": "src/NLP-GenI-ErrorIO.html#ErrorIO",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI ErrorIO",
          "module": "NLP.GenI.ErrorIO",
          "name": "ErrorIO",
          "package": "GenI",
          "partial": "Error IO",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-ErrorIO.html#t:ErrorIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.ErrorIO",
          "name": "liftEither",
          "package": "GenI",
          "signature": "Either e a -\u003e ErrorT e m a",
          "source": "src/NLP-GenI-ErrorIO.html#liftEither",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI ErrorIO",
          "module": "NLP.GenI.ErrorIO",
          "name": "liftEither",
          "normalized": "Either a b-\u003eErrorT a c b",
          "package": "GenI",
          "partial": "Either",
          "signature": "Either e a-\u003eErrorT e m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-ErrorIO.html#v:liftEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFeature structures in GenI can be seen as a simple mapping from\n   attributes to values (no fancy recursion).\n\u003c/p\u003e\u003cp\u003eFrom an implementation standpoint, we do truck around lists of\n   \u003ccode\u003e\u003ca\u003eAvPair\u003c/a\u003e\u003c/code\u003e quite a bit which unfortunately means we don't\n   guarantee things like uniqueness of attributes.  We may phase\n   this out over time in favour of \u003ccode\u003e\u003ca\u003eFeatStruct\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.FeatureStructure",
          "name": "FeatureStructure",
          "package": "GenI",
          "source": "src/NLP-GenI-FeatureStructure.html",
          "type": "module"
        },
        "index": {
          "description": "Feature structures in GenI can be seen as simple mapping from attributes to values no fancy recursion From an implementation standpoint we do truck around lists of AvPair quite bit which unfortunately means we don guarantee things like uniqueness of attributes We may phase this out over time in favour of FeatStruct",
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "FeatureStructure",
          "package": "GenI",
          "partial": "Feature Structure",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn attribute-value pair, the typical use being\n   \u003ccode\u003eAvPair GeniVal\u003c/code\u003e or if you have something even simpler\n   \u003ccode\u003eAvPair Text\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.FeatureStructure",
          "name": "AvPair",
          "package": "GenI",
          "source": "src/NLP-GenI-FeatureStructure.html#AvPair",
          "type": "data"
        },
        "index": {
          "description": "An attribute-value pair the typical use being AvPair GeniVal or if you have something even simpler AvPair Text",
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "AvPair",
          "package": "GenI",
          "partial": "Av Pair",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#t:AvPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExperimental, alternative representation of Flist\n   which guarantees uniqueness of keys\n\u003c/p\u003e",
          "module": "NLP.GenI.FeatureStructure",
          "name": "FeatStruct",
          "package": "GenI",
          "source": "src/NLP-GenI-FeatureStructure.html#FeatStruct",
          "type": "type"
        },
        "index": {
          "description": "Experimental alternative representation of Flist which guarantees uniqueness of keys",
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "FeatStruct",
          "package": "GenI",
          "partial": "Feat Struct",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#t:FeatStruct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list of attribute-value pairs. It's not a great idea to represent\n   feature structures with this because it allows for duplicates in the\n   attributes. But maybe sometimes you really do mean a list.\n\u003c/p\u003e",
          "module": "NLP.GenI.FeatureStructure",
          "name": "Flist",
          "package": "GenI",
          "source": "src/NLP-GenI-FeatureStructure.html#Flist",
          "type": "type"
        },
        "index": {
          "description": "list of attribute-value pairs It not great idea to represent feature structures with this because it allows for duplicates in the attributes But maybe sometimes you really do mean list",
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "Flist",
          "package": "GenI",
          "partial": "Flist",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#t:Flist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.FeatureStructure",
          "name": "AvPair",
          "package": "GenI",
          "signature": "AvPair",
          "source": "src/NLP-GenI-FeatureStructure.html#AvPair",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "AvPair",
          "package": "GenI",
          "partial": "Av Pair",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#v:AvPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealignFeat\u003c/a\u003e\u003c/code\u003e is a pre-procesing step used to ensure that feature structures\n   have the same set of keys.  If a key is missing in one, we copy it to the\n   other with an anonymous value.\n\u003c/p\u003e\u003cp\u003eThe two feature structures must be sorted for this to work\n\u003c/p\u003e",
          "module": "NLP.GenI.FeatureStructure",
          "name": "alignFeat",
          "package": "GenI",
          "signature": "Flist GeniVal -\u003e Flist GeniVal -\u003e [(Text, GeniVal, GeniVal)]",
          "source": "src/NLP-GenI-FeatureStructure.html#alignFeat",
          "type": "function"
        },
        "index": {
          "description": "alignFeat is pre-procesing step used to ensure that feature structures have the same set of keys If key is missing in one we copy it to the other with an anonymous value The two feature structures must be sorted for this to work",
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "alignFeat",
          "normalized": "Flist GeniVal-\u003eFlist GeniVal-\u003e[(Text,GeniVal,GeniVal)]",
          "package": "GenI",
          "partial": "Feat",
          "signature": "Flist GeniVal-\u003eFlist GeniVal-\u003e[(Text,GeniVal,GeniVal)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#v:alignFeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper for \u003ccode\u003e\u003ca\u003ealignFeat\u003c/a\u003e\u003c/code\u003e; ignore\n\u003c/p\u003e",
          "module": "NLP.GenI.FeatureStructure",
          "name": "alignFeatH",
          "package": "GenI",
          "signature": "Flist GeniVal -\u003e Flist GeniVal -\u003e [(Text, GeniVal, GeniVal)] -\u003e [(Text, GeniVal, GeniVal)]",
          "source": "src/NLP-GenI-FeatureStructure.html#alignFeatH",
          "type": "function"
        },
        "index": {
          "description": "Helper for alignFeat ignore",
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "alignFeatH",
          "normalized": "Flist GeniVal-\u003eFlist GeniVal-\u003e[(Text,GeniVal,GeniVal)]-\u003e[(Text,GeniVal,GeniVal)]",
          "package": "GenI",
          "partial": "Feat",
          "signature": "Flist GeniVal-\u003eFlist GeniVal-\u003e[(Text,GeniVal,GeniVal)]-\u003e[(Text,GeniVal,GeniVal)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#v:alignFeatH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.FeatureStructure",
          "name": "avAtt",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-FeatureStructure.html#AvPair",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "avAtt",
          "package": "GenI",
          "partial": "Att",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#v:avAtt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.FeatureStructure",
          "name": "avVal",
          "package": "GenI",
          "signature": "a",
          "source": "src/NLP-GenI-FeatureStructure.html#AvPair",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "avVal",
          "package": "GenI",
          "partial": "Val",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#v:avVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten a fancy disjunction attribute-value pair\n\u003c/p\u003e\u003cp\u003eSee \u003ccode\u003e\u003ca\u003ecrushOne\u003c/a\u003e\u003c/code\u003e for details\n\u003c/p\u003e",
          "module": "NLP.GenI.FeatureStructure",
          "name": "crushAvPair",
          "package": "GenI",
          "signature": "AvPair SchemaVal -\u003e Maybe (AvPair GeniVal)",
          "source": "src/NLP-GenI-FeatureStructure.html#crushAvPair",
          "type": "function"
        },
        "index": {
          "description": "Flatten fancy disjunction attribute-value pair See crushOne for details",
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "crushAvPair",
          "normalized": "AvPair SchemaVal-\u003eMaybe(AvPair GeniVal)",
          "package": "GenI",
          "partial": "Av Pair",
          "signature": "AvPair SchemaVal-\u003eMaybe(AvPair GeniVal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#v:crushAvPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten a fancy-disjunction feature structure\n\u003c/p\u003e\u003cp\u003eSee \u003ccode\u003e\u003ca\u003ecrushOne\u003c/a\u003e\u003c/code\u003e for details\n\u003c/p\u003e",
          "module": "NLP.GenI.FeatureStructure",
          "name": "crushFlist",
          "package": "GenI",
          "signature": "Flist SchemaVal -\u003e Maybe (Flist GeniVal)",
          "source": "src/NLP-GenI-FeatureStructure.html#crushFlist",
          "type": "function"
        },
        "index": {
          "description": "Flatten fancy-disjunction feature structure See crushOne for details",
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "crushFlist",
          "normalized": "Flist SchemaVal-\u003eMaybe(Flist GeniVal)",
          "package": "GenI",
          "partial": "Flist",
          "signature": "Flist SchemaVal-\u003eMaybe(Flist GeniVal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#v:crushFlist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA feature structure with no pairs\n\u003c/p\u003e",
          "module": "NLP.GenI.FeatureStructure",
          "name": "emptyFeatStruct",
          "package": "GenI",
          "signature": "FeatStruct a",
          "source": "src/NLP-GenI-FeatureStructure.html#emptyFeatStruct",
          "type": "function"
        },
        "index": {
          "description": "feature structure with no pairs",
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "emptyFeatStruct",
          "package": "GenI",
          "partial": "Feat Struct",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#v:emptyFeatStruct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an \u003ccode\u003e\u003ca\u003eFeatStruct\u003c/a\u003e\u003c/code\u003e to a simpler to process \u003ccode\u003e\u003ca\u003eFlist\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.FeatureStructure",
          "name": "fromFeatStruct",
          "package": "GenI",
          "signature": "FeatStruct a -\u003e Flist a",
          "source": "src/NLP-GenI-FeatureStructure.html#fromFeatStruct",
          "type": "function"
        },
        "index": {
          "description": "Convert an FeatStruct to simpler to process Flist",
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "fromFeatStruct",
          "normalized": "FeatStruct a-\u003eFlist a",
          "package": "GenI",
          "partial": "Feat Struct",
          "signature": "FeatStruct a-\u003eFlist a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#v:fromFeatStruct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an \u003ccode\u003e\u003ca\u003eFlist\u003c/a\u003e\u003c/code\u003e to a proper \u003ccode\u003e\u003ca\u003eFeatStruct\u003c/a\u003e\u003c/code\u003e\n   Unsafely assumes the keys are unique\n\u003c/p\u003e",
          "module": "NLP.GenI.FeatureStructure",
          "name": "mkFeatStruct",
          "package": "GenI",
          "signature": "Flist GeniVal -\u003e FeatStruct GeniVal",
          "source": "src/NLP-GenI-FeatureStructure.html#mkFeatStruct",
          "type": "function"
        },
        "index": {
          "description": "Convert an Flist to proper FeatStruct Unsafely assumes the keys are unique",
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "mkFeatStruct",
          "normalized": "Flist GeniVal-\u003eFeatStruct GeniVal",
          "package": "GenI",
          "partial": "Feat Struct",
          "signature": "Flist GeniVal-\u003eFeatStruct GeniVal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#v:mkFeatStruct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSort an Flist according with its attributes\n\u003c/p\u003e",
          "module": "NLP.GenI.FeatureStructure",
          "name": "sortFlist",
          "package": "GenI",
          "signature": "Flist a -\u003e Flist a",
          "source": "src/NLP-GenI-FeatureStructure.html#sortFlist",
          "type": "function"
        },
        "index": {
          "description": "Sort an Flist according with its attributes",
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "sortFlist",
          "normalized": "Flist a-\u003eFlist a",
          "package": "GenI",
          "partial": "Flist",
          "signature": "Flist a-\u003eFlist a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#v:sortFlist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunifyFeat\u003c/a\u003e\u003c/code\u003e performs feature structure unification, under the\n   these assumptions about the input:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Features are ordered\n\u003c/li\u003e\u003cli\u003e The Flists do not share variables (renaming has already\n      been done.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe features are allowed to have different sets of attributes,\n   beacuse we use \u003ccode\u003e\u003ca\u003ealignFeat\u003c/a\u003e\u003c/code\u003e to realign them.\n\u003c/p\u003e",
          "module": "NLP.GenI.FeatureStructure",
          "name": "unifyFeat",
          "package": "GenI",
          "signature": "Flist GeniVal -\u003e Flist GeniVal -\u003e m (Flist GeniVal, Subst)",
          "source": "src/NLP-GenI-FeatureStructure.html#unifyFeat",
          "type": "function"
        },
        "index": {
          "description": "unifyFeat performs feature structure unification under the these assumptions about the input Features are ordered The Flists do not share variables renaming has already been done The features are allowed to have different sets of attributes beacuse we use alignFeat to realign them",
          "hierarchy": "NLP GenI FeatureStructure",
          "module": "NLP.GenI.FeatureStructure",
          "name": "unifyFeat",
          "normalized": "Flist GeniVal-\u003eFlist GeniVal-\u003ea(Flist GeniVal,Subst)",
          "package": "GenI",
          "partial": "Feat",
          "signature": "Flist GeniVal-\u003eFlist GeniVal-\u003em(Flist GeniVal,Subst)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-FeatureStructure.html#v:unifyFeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInternal representation of GenI configuration options, typically\n   passed in through the command line or via the GUI.\n\u003c/p\u003e\u003cp\u003eWe don't yet use the record based approach, or something like\n   cmdargs because our use case involves\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e sharing lots of options between different programs\n     (batch processing, gui, server)\n\u003c/li\u003e\u003cli\u003e supporting library users who want to build GenI-like applications\n     that share a good chunk of our flag set, and add configuration\n     options of their own.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWhat we have is fairly clunky, but it seems to be quite\n   flexible for that need.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.Flag",
          "name": "Flag",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html",
          "type": "module"
        },
        "index": {
          "description": "Internal representation of GenI configuration options typically passed in through the command line or via the GUI We don yet use the record based approach or something like cmdargs because our use case involves sharing lots of options between different programs batch processing gui server supporting library users who want to build GenI-like applications that share good chunk of our flag set and add configuration options of their own What we have is fairly clunky but it seems to be quite flexible for that need",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "Flag",
          "package": "GenI",
          "partial": "Flag",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "BatchDirFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#BatchDirFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "BatchDirFlg",
          "package": "GenI",
          "partial": "Batch Dir Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:BatchDirFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "BuilderFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#BuilderFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "BuilderFlg",
          "package": "GenI",
          "partial": "Builder Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:BuilderFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe tree assembly algorithm we want to use\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "BuilderType",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#BuilderType",
          "type": "data"
        },
        "index": {
          "description": "The tree assembly algorithm we want to use",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "BuilderType",
          "package": "GenI",
          "partial": "Builder Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:BuilderType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "DetectPolaritiesFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#DetectPolaritiesFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "DetectPolaritiesFlg",
          "package": "GenI",
          "partial": "Detect Polarities Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:DetectPolaritiesFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "DisableGuiFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#DisableGuiFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "DisableGuiFlg",
          "package": "GenI",
          "partial": "Disable Gui Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:DisableGuiFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "DumpDerivationFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#DumpDerivationFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "DumpDerivationFlg",
          "package": "GenI",
          "partial": "Dump Derivation Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:DumpDerivationFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "EarlyDeathFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#EarlyDeathFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "EarlyDeathFlg",
          "package": "GenI",
          "partial": "Early Death Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:EarlyDeathFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlags are GenI's internal representation of command line arguments.  We\nuse phantom existential types (?) for representing GenI flags.  This\nmakes it simpler to do things such as ``get the value of the MacrosFlg''\nwhilst preserving type safety (we always know that MacrosFlg is\nassociated with String).  The alternative would be writing getters and\nsetters for each flag, and that gets really boring after a while.\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "Flag",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#Flag",
          "type": "data"
        },
        "index": {
          "description": "Flags are GenI internal representation of command line arguments We use phantom existential types for representing GenI flags This makes it simpler to do things such as get the value of the MacrosFlg whilst preserving type safety we always know that MacrosFlg is associated with String The alternative would be writing getters and setters for each flag and that gets really boring after while",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "Flag",
          "package": "GenI",
          "partial": "Flag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:Flag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "FromStdinFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#FromStdinFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "FromStdinFlg",
          "package": "GenI",
          "partial": "From Stdin Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:FromStdinFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhat kind of elementary trees we're getting.  The typical use case is\n   to provide tree schemata with \u003ccode\u003e\u003ca\u003eGeniHand\u003c/a\u003e\u003c/code\u003e (which then get anchored into\n   the lexicon to give us elmentary trees).  You can also have precompiled\n   trees hardcoded into your GenI-like program, or read preanchored\n   elementary trees from somewhere else.\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "GrammarType",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#GrammarType",
          "type": "data"
        },
        "index": {
          "description": "What kind of elementary trees we re getting The typical use case is to provide tree schemata with GeniHand which then get anchored into the lexicon to give us elmentary trees You can also have precompiled trees hardcoded into your GenI-like program or read preanchored elementary trees from somewhere else",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "GrammarType",
          "package": "GenI",
          "partial": "Grammar Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:GrammarType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "GrammarTypeFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#GrammarTypeFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "GrammarTypeFlg",
          "package": "GenI",
          "partial": "Grammar Type Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:GrammarTypeFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "HasFlags",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#HasFlags",
          "type": "class"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "HasFlags",
          "package": "GenI",
          "partial": "Has Flags",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:HasFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "HelpFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#HelpFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "HelpFlg",
          "package": "GenI",
          "partial": "Help Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:HelpFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA test suite and any test cases within that we want to pick out\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "Instruction",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#Instruction",
          "type": "type"
        },
        "index": {
          "description": "test suite and any test cases within that we want to pick out",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "Instruction",
          "package": "GenI",
          "partial": "Instruction",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:Instruction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "InstructionsFileFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#InstructionsFileFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "InstructionsFileFlg",
          "package": "GenI",
          "partial": "Instructions File Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:InstructionsFileFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "LexiconFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#LexiconFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "LexiconFlg",
          "package": "GenI",
          "partial": "Lexicon Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:LexiconFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "MacrosFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#MacrosFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "MacrosFlg",
          "package": "GenI",
          "partial": "Macros Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:MacrosFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "MaxResultsFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#MaxResultsFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "MaxResultsFlg",
          "package": "GenI",
          "partial": "Max Results Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:MaxResultsFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "MaxStepsFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#MaxStepsFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "MaxStepsFlg",
          "package": "GenI",
          "partial": "Max Steps Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:MaxStepsFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "MetricsFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#MetricsFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "MetricsFlg",
          "package": "GenI",
          "partial": "Metrics Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:MetricsFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "MorphCmdFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#MorphCmdFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "MorphCmdFlg",
          "package": "GenI",
          "partial": "Morph Cmd Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:MorphCmdFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "MorphInfoFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#MorphInfoFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "MorphInfoFlg",
          "package": "GenI",
          "partial": "Morph Info Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:MorphInfoFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "NoLoadTestSuiteFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#NoLoadTestSuiteFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "NoLoadTestSuiteFlg",
          "package": "GenI",
          "partial": "No Load Test Suite Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:NoLoadTestSuiteFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRequested optimisations\n\u003c/p\u003e\u003cp\u003eAt the time of this writing (2012-08-21), this is fairly sparse as\n   a lot of proposed optimisations have just been absorbed into GenI\n   as mandatory things.\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "Optimisation",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#Optimisation",
          "type": "data"
        },
        "index": {
          "description": "Requested optimisations At the time of this writing this is fairly sparse as lot of proposed optimisations have just been absorbed into GenI as mandatory things",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "Optimisation",
          "package": "GenI",
          "partial": "Optimisation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:Optimisation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "OptimisationsFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#OptimisationsFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "OptimisationsFlg",
          "package": "GenI",
          "partial": "Optimisations Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:OptimisationsFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "OutputFileFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#OutputFileFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "OutputFileFlg",
          "package": "GenI",
          "partial": "Output File Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:OutputFileFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "PartialFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#PartialFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "PartialFlg",
          "package": "GenI",
          "partial": "Partial Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:PartialFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "RankingConstraintsFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#RankingConstraintsFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "RankingConstraintsFlg",
          "package": "GenI",
          "partial": "Ranking Constraints Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:RankingConstraintsFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "RootFeatureFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#RootFeatureFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "RootFeatureFlg",
          "package": "GenI",
          "partial": "Root Feature Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:RootFeatureFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "StatsFileFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#StatsFileFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "StatsFileFlg",
          "package": "GenI",
          "partial": "Stats File Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:StatsFileFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "TestCaseFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#TestCaseFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "TestCaseFlg",
          "package": "GenI",
          "partial": "Test Case Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:TestCaseFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "TestInstructionsFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#TestInstructionsFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "TestInstructionsFlg",
          "package": "GenI",
          "partial": "Test Instructions Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:TestInstructionsFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "TestSuiteFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#TestSuiteFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "TestSuiteFlg",
          "package": "GenI",
          "partial": "Test Suite Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:TestSuiteFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "TimeoutFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#TimeoutFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "TimeoutFlg",
          "package": "GenI",
          "partial": "Timeout Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:TimeoutFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "TracesFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#TracesFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "TracesFlg",
          "package": "GenI",
          "partial": "Traces Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:TracesFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "VerboseModeFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#VerboseModeFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "VerboseModeFlg",
          "package": "GenI",
          "partial": "Verbose Mode Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:VerboseModeFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "VersionFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#VersionFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "VersionFlg",
          "package": "GenI",
          "partial": "Version Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:VersionFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "ViewCmdFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#ViewCmdFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "ViewCmdFlg",
          "package": "GenI",
          "partial": "View Cmd Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:ViewCmdFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "WeirdFlg",
          "package": "GenI",
          "source": "src/NLP-GenI-Flag.html#WeirdFlg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "WeirdFlg",
          "package": "GenI",
          "partial": "Weird Flg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#t:WeirdFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eall adjunction-related optimisations\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "AdjOpts",
          "package": "GenI",
          "signature": "AdjOpts",
          "source": "src/NLP-GenI-Flag.html#Optimisation",
          "type": "function"
        },
        "index": {
          "description": "all adjunction-related optimisations",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "AdjOpts",
          "package": "GenI",
          "partial": "Adj Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:AdjOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "BatchDirFlg",
          "package": "GenI",
          "signature": "BatchDirFlg FilePath",
          "source": "src/NLP-GenI-Flag.html#BatchDirFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "BatchDirFlg",
          "package": "GenI",
          "partial": "Batch Dir Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:BatchDirFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "BuilderFlg",
          "package": "GenI",
          "signature": "BuilderFlg BuilderType",
          "source": "src/NLP-GenI-Flag.html#BuilderFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "BuilderFlg",
          "package": "GenI",
          "partial": "Builder Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:BuilderFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "DetectPolaritiesFlg",
          "package": "GenI",
          "signature": "DetectPolaritiesFlg (Set PolarityAttr)",
          "source": "src/NLP-GenI-Flag.html#DetectPolaritiesFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "DetectPolaritiesFlg",
          "package": "GenI",
          "partial": "Detect Polarities Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:DetectPolaritiesFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "DisableGuiFlg",
          "package": "GenI",
          "signature": "DisableGuiFlg ()",
          "source": "src/NLP-GenI-Flag.html#DisableGuiFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "DisableGuiFlg",
          "normalized": "DisableGuiFlg()",
          "package": "GenI",
          "partial": "Disable Gui Flg",
          "signature": "DisableGuiFlg()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:DisableGuiFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "DumpDerivationFlg",
          "package": "GenI",
          "signature": "DumpDerivationFlg ()",
          "source": "src/NLP-GenI-Flag.html#DumpDerivationFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "DumpDerivationFlg",
          "normalized": "DumpDerivationFlg()",
          "package": "GenI",
          "partial": "Dump Derivation Flg",
          "signature": "DumpDerivationFlg()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:DumpDerivationFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "EarlyDeathFlg",
          "package": "GenI",
          "signature": "EarlyDeathFlg ()",
          "source": "src/NLP-GenI-Flag.html#EarlyDeathFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "EarlyDeathFlg",
          "normalized": "EarlyDeathFlg()",
          "package": "GenI",
          "partial": "Early Death Flg",
          "signature": "EarlyDeathFlg()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:EarlyDeathFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "Flag",
          "package": "GenI",
          "signature": "Flag (x -\u003e f) x",
          "source": "src/NLP-GenI-Flag.html#Flag",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "Flag",
          "normalized": "Flag(a-\u003eb)a",
          "package": "GenI",
          "partial": "Flag",
          "signature": "Flag(x-\u003ef)x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:Flag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "FromStdinFlg",
          "package": "GenI",
          "signature": "FromStdinFlg ()",
          "source": "src/NLP-GenI-Flag.html#FromStdinFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "FromStdinFlg",
          "normalized": "FromStdinFlg()",
          "package": "GenI",
          "partial": "From Stdin Flg",
          "signature": "FromStdinFlg()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:FromStdinFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeni's text format\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "GeniHand",
          "package": "GenI",
          "signature": "GeniHand",
          "source": "src/NLP-GenI-Flag.html#GrammarType",
          "type": "function"
        },
        "index": {
          "description": "geni text format",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "GeniHand",
          "package": "GenI",
          "partial": "Geni Hand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:GeniHand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "GrammarTypeFlg",
          "package": "GenI",
          "signature": "GrammarTypeFlg GrammarType",
          "source": "src/NLP-GenI-Flag.html#GrammarTypeFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "GrammarTypeFlg",
          "package": "GenI",
          "partial": "Grammar Type Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:GrammarTypeFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eguided realisation (needs polarity filtering)\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "Guided",
          "package": "GenI",
          "signature": "Guided",
          "source": "src/NLP-GenI-Flag.html#Optimisation",
          "type": "function"
        },
        "index": {
          "description": "guided realisation needs polarity filtering",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "Guided",
          "package": "GenI",
          "partial": "Guided",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:Guided"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "HelpFlg",
          "package": "GenI",
          "signature": "HelpFlg ()",
          "source": "src/NLP-GenI-Flag.html#HelpFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "HelpFlg",
          "normalized": "HelpFlg()",
          "package": "GenI",
          "partial": "Help Flg",
          "signature": "HelpFlg()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:HelpFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "InstructionsFileFlg",
          "package": "GenI",
          "signature": "InstructionsFileFlg FilePath",
          "source": "src/NLP-GenI-Flag.html#InstructionsFileFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "InstructionsFileFlg",
          "package": "GenI",
          "partial": "Instructions File Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:InstructionsFileFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "LexiconFlg",
          "package": "GenI",
          "signature": "LexiconFlg FilePath",
          "source": "src/NLP-GenI-Flag.html#LexiconFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "LexiconFlg",
          "package": "GenI",
          "partial": "Lexicon Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:LexiconFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "MacrosFlg",
          "package": "GenI",
          "signature": "MacrosFlg FilePath",
          "source": "src/NLP-GenI-Flag.html#MacrosFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "MacrosFlg",
          "package": "GenI",
          "partial": "Macros Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:MacrosFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "MaxResultsFlg",
          "package": "GenI",
          "signature": "MaxResultsFlg Integer",
          "source": "src/NLP-GenI-Flag.html#MaxResultsFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "MaxResultsFlg",
          "package": "GenI",
          "partial": "Max Results Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:MaxResultsFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "MaxStepsFlg",
          "package": "GenI",
          "signature": "MaxStepsFlg Integer",
          "source": "src/NLP-GenI-Flag.html#MaxStepsFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "MaxStepsFlg",
          "package": "GenI",
          "partial": "Max Steps Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:MaxStepsFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "MetricsFlg",
          "package": "GenI",
          "signature": "MetricsFlg [String]",
          "source": "src/NLP-GenI-Flag.html#MetricsFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "MetricsFlg",
          "normalized": "MetricsFlg[String]",
          "package": "GenI",
          "partial": "Metrics Flg",
          "signature": "MetricsFlg[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:MetricsFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "MorphCmdFlg",
          "package": "GenI",
          "signature": "MorphCmdFlg String",
          "source": "src/NLP-GenI-Flag.html#MorphCmdFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "MorphCmdFlg",
          "package": "GenI",
          "partial": "Morph Cmd Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:MorphCmdFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "MorphInfoFlg",
          "package": "GenI",
          "signature": "MorphInfoFlg FilePath",
          "source": "src/NLP-GenI-Flag.html#MorphInfoFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "MorphInfoFlg",
          "package": "GenI",
          "partial": "Morph Info Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:MorphInfoFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eignore literal constraints (pessimisation?)\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "NoConstraints",
          "package": "GenI",
          "signature": "NoConstraints",
          "source": "src/NLP-GenI-Flag.html#Optimisation",
          "type": "function"
        },
        "index": {
          "description": "ignore literal constraints pessimisation",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "NoConstraints",
          "package": "GenI",
          "partial": "No Constraints",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:NoConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "NoLoadTestSuiteFlg",
          "package": "GenI",
          "signature": "NoLoadTestSuiteFlg ()",
          "source": "src/NLP-GenI-Flag.html#NoLoadTestSuiteFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "NoLoadTestSuiteFlg",
          "normalized": "NoLoadTestSuiteFlg()",
          "package": "GenI",
          "partial": "No Load Test Suite Flg",
          "signature": "NoLoadTestSuiteFlg()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:NoLoadTestSuiteFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "OptimisationsFlg",
          "package": "GenI",
          "signature": "OptimisationsFlg [Optimisation]",
          "source": "src/NLP-GenI-Flag.html#OptimisationsFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "OptimisationsFlg",
          "normalized": "OptimisationsFlg[Optimisation]",
          "package": "GenI",
          "partial": "Optimisations Flg",
          "signature": "OptimisationsFlg[Optimisation]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:OptimisationsFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "OutputFileFlg",
          "package": "GenI",
          "signature": "OutputFileFlg String",
          "source": "src/NLP-GenI-Flag.html#OutputFileFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "OutputFileFlg",
          "package": "GenI",
          "partial": "Output File Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:OutputFileFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "PartialFlg",
          "package": "GenI",
          "signature": "PartialFlg ()",
          "source": "src/NLP-GenI-Flag.html#PartialFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "PartialFlg",
          "normalized": "PartialFlg()",
          "package": "GenI",
          "partial": "Partial Flg",
          "signature": "PartialFlg()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:PartialFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eall polarity-related   optimisations\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "PolOpts",
          "package": "GenI",
          "signature": "PolOpts",
          "source": "src/NLP-GenI-Flag.html#Optimisation",
          "type": "function"
        },
        "index": {
          "description": "all polarity-related optimisations",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "PolOpts",
          "package": "GenI",
          "partial": "Pol Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:PolOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epolarity filtering\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "Polarised",
          "package": "GenI",
          "signature": "Polarised",
          "source": "src/NLP-GenI-Flag.html#Optimisation",
          "type": "function"
        },
        "index": {
          "description": "polarity filtering",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "Polarised",
          "package": "GenI",
          "partial": "Polarised",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:Polarised"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elexical selection already done\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "PreAnchored",
          "package": "GenI",
          "signature": "PreAnchored",
          "source": "src/NLP-GenI-Flag.html#GrammarType",
          "type": "function"
        },
        "index": {
          "description": "lexical selection already done",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "PreAnchored",
          "package": "GenI",
          "partial": "Pre Anchored",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:PreAnchored"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebuilt into geni, no parsing needed\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "PreCompiled",
          "package": "GenI",
          "signature": "PreCompiled",
          "source": "src/NLP-GenI-Flag.html#GrammarType",
          "type": "function"
        },
        "index": {
          "description": "built into geni no parsing needed",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "PreCompiled",
          "package": "GenI",
          "partial": "Pre Compiled",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:PreCompiled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "RankingConstraintsFlg",
          "package": "GenI",
          "signature": "RankingConstraintsFlg FilePath",
          "source": "src/NLP-GenI-Flag.html#RankingConstraintsFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "RankingConstraintsFlg",
          "package": "GenI",
          "partial": "Ranking Constraints Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:RankingConstraintsFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "RootFeatureFlg",
          "package": "GenI",
          "signature": "RootFeatureFlg (Flist GeniVal)",
          "source": "src/NLP-GenI-Flag.html#RootFeatureFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "RootFeatureFlg",
          "package": "GenI",
          "partial": "Root Feature Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:RootFeatureFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "SimpleBuilder",
          "package": "GenI",
          "signature": "SimpleBuilder",
          "source": "src/NLP-GenI-Flag.html#BuilderType",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "SimpleBuilder",
          "package": "GenI",
          "partial": "Simple Builder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:SimpleBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "SimpleOnePhaseBuilder",
          "package": "GenI",
          "signature": "SimpleOnePhaseBuilder",
          "source": "src/NLP-GenI-Flag.html#BuilderType",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "SimpleOnePhaseBuilder",
          "package": "GenI",
          "partial": "Simple One Phase Builder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:SimpleOnePhaseBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "StatsFileFlg",
          "package": "GenI",
          "signature": "StatsFileFlg FilePath",
          "source": "src/NLP-GenI-Flag.html#StatsFileFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "StatsFileFlg",
          "package": "GenI",
          "partial": "Stats File Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:StatsFileFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "TestCaseFlg",
          "package": "GenI",
          "signature": "TestCaseFlg Text",
          "source": "src/NLP-GenI-Flag.html#TestCaseFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "TestCaseFlg",
          "package": "GenI",
          "partial": "Test Case Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:TestCaseFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "TestInstructionsFlg",
          "package": "GenI",
          "signature": "TestInstructionsFlg [Instruction]",
          "source": "src/NLP-GenI-Flag.html#TestInstructionsFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "TestInstructionsFlg",
          "normalized": "TestInstructionsFlg[Instruction]",
          "package": "GenI",
          "partial": "Test Instructions Flg",
          "signature": "TestInstructionsFlg[Instruction]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:TestInstructionsFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "TestSuiteFlg",
          "package": "GenI",
          "signature": "TestSuiteFlg FilePath",
          "source": "src/NLP-GenI-Flag.html#TestSuiteFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "TestSuiteFlg",
          "package": "GenI",
          "partial": "Test Suite Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:TestSuiteFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "TimeoutFlg",
          "package": "GenI",
          "signature": "TimeoutFlg Int",
          "source": "src/NLP-GenI-Flag.html#TimeoutFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "TimeoutFlg",
          "package": "GenI",
          "partial": "Timeout Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:TimeoutFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "TracesFlg",
          "package": "GenI",
          "signature": "TracesFlg FilePath",
          "source": "src/NLP-GenI-Flag.html#TracesFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "TracesFlg",
          "package": "GenI",
          "partial": "Traces Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:TracesFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "VerboseModeFlg",
          "package": "GenI",
          "signature": "VerboseModeFlg ()",
          "source": "src/NLP-GenI-Flag.html#VerboseModeFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "VerboseModeFlg",
          "normalized": "VerboseModeFlg()",
          "package": "GenI",
          "partial": "Verbose Mode Flg",
          "signature": "VerboseModeFlg()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:VerboseModeFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "VersionFlg",
          "package": "GenI",
          "signature": "VersionFlg ()",
          "source": "src/NLP-GenI-Flag.html#VersionFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "VersionFlg",
          "normalized": "VersionFlg()",
          "package": "GenI",
          "partial": "Version Flg",
          "signature": "VersionFlg()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:VersionFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "ViewCmdFlg",
          "package": "GenI",
          "signature": "ViewCmdFlg String",
          "source": "src/NLP-GenI-Flag.html#ViewCmdFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "ViewCmdFlg",
          "package": "GenI",
          "partial": "View Cmd Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:ViewCmdFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "WeirdFlg",
          "package": "GenI",
          "signature": "WeirdFlg String",
          "source": "src/NLP-GenI-Flag.html#WeirdFlg",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "WeirdFlg",
          "package": "GenI",
          "partial": "Weird Flg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:WeirdFlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "defaultGrammarType",
          "package": "GenI",
          "signature": "GrammarType",
          "source": "src/NLP-GenI-Flag.html#defaultGrammarType",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "defaultGrammarType",
          "package": "GenI",
          "partial": "Grammar Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:defaultGrammarType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "deleteFlag",
          "package": "GenI",
          "signature": "(x -\u003e f) -\u003e flags -\u003e flags",
          "source": "src/NLP-GenI-Flag.html#deleteFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "deleteFlag",
          "normalized": "(a-\u003eb)-\u003ec-\u003ec",
          "package": "GenI",
          "partial": "Flag",
          "signature": "(x-\u003ef)-\u003eflags-\u003eflags",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:deleteFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "flags",
          "package": "GenI",
          "signature": "x -\u003e [Flag]",
          "source": "src/NLP-GenI-Flag.html#flags",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "flags",
          "normalized": "a-\u003e[Flag]",
          "package": "GenI",
          "signature": "x-\u003e[Flag]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:flags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "getAllFlags",
          "package": "GenI",
          "signature": "(x -\u003e f) -\u003e flags -\u003e [x]",
          "source": "src/NLP-GenI-Flag.html#getAllFlags",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "getAllFlags",
          "normalized": "(a-\u003eb)-\u003ec-\u003e[a]",
          "package": "GenI",
          "partial": "All Flags",
          "signature": "(x-\u003ef)-\u003eflags-\u003e[x]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:getAllFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "getFlag",
          "package": "GenI",
          "signature": "(x -\u003e f) -\u003e flags -\u003e Maybe x",
          "source": "src/NLP-GenI-Flag.html#getFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "getFlag",
          "normalized": "(a-\u003eb)-\u003ec-\u003eMaybe a",
          "package": "GenI",
          "partial": "Flag",
          "signature": "(x-\u003ef)-\u003eflags-\u003eMaybe x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:getFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "getGrammarType",
          "package": "GenI",
          "signature": "[Flag] -\u003e GrammarType",
          "source": "src/NLP-GenI-Flag.html#getGrammarType",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "getGrammarType",
          "normalized": "[Flag]-\u003eGrammarType",
          "package": "GenI",
          "partial": "Grammar Type",
          "signature": "[Flag]-\u003eGrammarType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:getGrammarType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "getListFlag",
          "package": "GenI",
          "signature": "([x] -\u003e f) -\u003e flags -\u003e [x]",
          "source": "src/NLP-GenI-Flag.html#getListFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "getListFlag",
          "normalized": "([a]-\u003eb)-\u003ec-\u003e[a]",
          "package": "GenI",
          "partial": "List Flag",
          "signature": "([x]-\u003ef)-\u003eflags-\u003e[x]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:getListFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "hasFlag",
          "package": "GenI",
          "signature": "(x -\u003e f) -\u003e flags -\u003e Bool",
          "source": "src/NLP-GenI-Flag.html#hasFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "hasFlag",
          "normalized": "(a-\u003eb)-\u003ec-\u003eBool",
          "package": "GenI",
          "partial": "Flag",
          "signature": "(x-\u003ef)-\u003eflags-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:hasFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "hasOpt",
          "package": "GenI",
          "signature": "Optimisation -\u003e [Flag] -\u003e Bool",
          "source": "src/NLP-GenI-Flag.html#hasOpt",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "hasOpt",
          "normalized": "Optimisation-\u003e[Flag]-\u003eBool",
          "package": "GenI",
          "partial": "Opt",
          "signature": "Optimisation-\u003e[Flag]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:hasOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "isFlag",
          "package": "GenI",
          "signature": "(x -\u003e f) -\u003e Flag -\u003e Bool",
          "source": "src/NLP-GenI-Flag.html#isFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "isFlag",
          "normalized": "(a-\u003eb)-\u003eFlag-\u003eBool",
          "package": "GenI",
          "partial": "Flag",
          "signature": "(x-\u003ef)-\u003eFlag-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:isFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis only has an effect if the flag is set\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "modifyFlag",
          "package": "GenI",
          "signature": "(x -\u003e f)-\u003e (x -\u003e x)-\u003e flags-\u003e flags",
          "type": "function"
        },
        "index": {
          "description": "This only has an effect if the flag is set",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "modifyFlag",
          "normalized": "(a-\u003eb)-\u003e(a-\u003ea)-\u003ec-\u003ec",
          "package": "GenI",
          "partial": "Flag",
          "signature": "(x-\u003ef)-\u003e(x-\u003ex)-\u003eflags-\u003eflags",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:modifyFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "onFlags",
          "package": "GenI",
          "signature": "([Flag] -\u003e [Flag]) -\u003e x -\u003e x",
          "source": "src/NLP-GenI-Flag.html#onFlags",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "onFlags",
          "normalized": "([Flag]-\u003e[Flag])-\u003ea-\u003ea",
          "package": "GenI",
          "partial": "Flags",
          "signature": "([Flag]-\u003e[Flag])-\u003ex-\u003ex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:onFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Flag",
          "name": "setFlag",
          "package": "GenI",
          "signature": "(x -\u003e f) -\u003e x -\u003e flags -\u003e flags",
          "source": "src/NLP-GenI-Flag.html#setFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "setFlag",
          "normalized": "(a-\u003eb)-\u003ea-\u003ec-\u003ec",
          "package": "GenI",
          "partial": "Flag",
          "signature": "(x-\u003ef)-\u003ex-\u003eflags-\u003eflags",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:setFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eupdateFlags new old\u003c/code\u003e takes the flags from \u003ccode\u003enew\u003c/code\u003e plus any from \u003ccode\u003eold\u003c/code\u003e that\n   aren't mentioned in it\n\u003c/p\u003e",
          "module": "NLP.GenI.Flag",
          "name": "updateFlags",
          "package": "GenI",
          "signature": "flags-\u003e flags-\u003e flags",
          "type": "function"
        },
        "index": {
          "description": "updateFlags new old takes the flags from new plus any from old that aren mentioned in it",
          "hierarchy": "NLP GenI Flag",
          "module": "NLP.GenI.Flag",
          "name": "updateFlags",
          "normalized": "a-\u003ea-\u003ea",
          "package": "GenI",
          "partial": "Flags",
          "signature": "flags-\u003eflags-\u003eflags",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Flag.html#v:updateFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides some very generic, non-GenI specific functions on strings,\n   trees and other miscellaneous odds and ends.  Whenever possible, one should try\n   to replace these functions with versions that are available in the standard\n   libraries, or the Haskell platform ones, or on hackage.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.General",
          "name": "General",
          "package": "GenI",
          "source": "src/NLP-GenI-General.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides some very generic non-GenI specific functions on strings trees and other miscellaneous odds and ends Whenever possible one should try to replace these functions with versions that are available in the standard libraries or the Haskell platform ones or on hackage",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "General",
          "package": "GenI",
          "partial": "General",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "BitVector",
          "package": "GenI",
          "source": "src/NLP-GenI-General.html#BitVector",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "BitVector",
          "package": "GenI",
          "partial": "Bit Vector",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#t:BitVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "Interval",
          "package": "GenI",
          "source": "src/NLP-GenI-General.html#Interval",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "Interval",
          "package": "GenI",
          "partial": "Interval",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#t:Interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd two intervals\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "(!+!)",
          "package": "GenI",
          "signature": "Interval -\u003e Interval -\u003e Interval",
          "source": "src/NLP-GenI-General.html#%21%2B%21",
          "type": "function"
        },
        "index": {
          "description": "Add two intervals",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "(!+!) !+!",
          "normalized": "Interval-\u003eInterval-\u003eInterval",
          "package": "GenI",
          "signature": "Interval-\u003eInterval-\u003eInterval",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:-33--43--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "BitVector",
          "package": "GenI",
          "signature": "BitVector Integer",
          "source": "src/NLP-GenI-General.html#BitVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "BitVector",
          "package": "GenI",
          "partial": "Bit Vector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:BitVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "buckets",
          "package": "GenI",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e [(b, [a])]",
          "source": "src/NLP-GenI-General.html#buckets",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "buckets",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003e[(b,[a])]",
          "package": "GenI",
          "signature": "(a-\u003eb)-\u003e[a]-\u003e[(b,[a])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:buckets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebreak a list of items into sublists of length \u003c the clump\n   size, taking into consideration that each item in the clump\n   will have a single gap of padding interspersed\n\u003c/p\u003e\u003cp\u003eany item whose length is greater than the clump size\n   is put into a clump by itself\n\u003c/p\u003e\u003cp\u003egiven a length function\n   \u003ccode\u003eclumpBy (length.show) 8 [\u003ca\u003ehello\u003c/a\u003e, \u003ca\u003ethis\u003c/a\u003e, \u003ca\u003eis\u003c/a\u003e, \u003ca\u003ea\u003c/a\u003e, \u003ca\u003elist\u003c/a\u003e]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "clumpBy",
          "package": "GenI",
          "signature": "(a -\u003e Int) -\u003e Int -\u003e [a] -\u003e [[a]]",
          "source": "src/NLP-GenI-General.html#clumpBy",
          "type": "function"
        },
        "index": {
          "description": "break list of items into sublists of length the clump size taking into consideration that each item in the clump will have single gap of padding interspersed any item whose length is greater than the clump size is put into clump by itself given length function clumpBy length.show hello this is list",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "clumpBy",
          "normalized": "(a-\u003eInt)-\u003eInt-\u003e[a]-\u003e[[a]]",
          "package": "GenI",
          "partial": "By",
          "signature": "(a-\u003eInt)-\u003eInt-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:clumpBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "combinations",
          "package": "GenI",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/NLP-GenI-General.html#combinations",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "combinations",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "GenI",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:combinations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDrop all characters up to and including the one in question\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "dropTillIncluding",
          "package": "GenI",
          "signature": "Char -\u003e String -\u003e String",
          "source": "src/NLP-GenI-General.html#dropTillIncluding",
          "type": "function"
        },
        "index": {
          "description": "Drop all characters up to and including the one in question",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "dropTillIncluding",
          "normalized": "Char-\u003eString-\u003eString",
          "package": "GenI",
          "partial": "Till Including",
          "signature": "Char-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:dropTillIncluding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "eFlush",
          "package": "GenI",
          "signature": "IO ()",
          "source": "src/NLP-GenI-General.html#eFlush",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "eFlush",
          "normalized": "IO()",
          "package": "GenI",
          "partial": "Flush",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:eFlush"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eputStr on stderr\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "ePutStr",
          "package": "GenI",
          "signature": "String -\u003e IO ()",
          "source": "src/NLP-GenI-General.html#ePutStr",
          "type": "function"
        },
        "index": {
          "description": "putStr on stderr",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "ePutStr",
          "normalized": "String-\u003eIO()",
          "package": "GenI",
          "partial": "Put Str",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:ePutStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "ePutStrLn",
          "package": "GenI",
          "signature": "String -\u003e IO ()",
          "source": "src/NLP-GenI-General.html#ePutStrLn",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "ePutStrLn",
          "normalized": "String-\u003eIO()",
          "package": "GenI",
          "partial": "Put Str Ln",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:ePutStrLn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003efilter\u003c/a\u003e\u003c/code\u003e, except on Trees.  Filter might not be a good name, though,\n   because we return a list of nodes, not a tree.\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "filterTree",
          "package": "GenI",
          "signature": "(a -\u003e Bool) -\u003e Tree a -\u003e [a]",
          "source": "src/NLP-GenI-General.html#filterTree",
          "type": "function"
        },
        "index": {
          "description": "Like filter except on Trees Filter might not be good name though because we return list of nodes not tree",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "filterTree",
          "normalized": "(a-\u003eBool)-\u003eTree a-\u003e[a]",
          "package": "GenI",
          "partial": "Tree",
          "signature": "(a-\u003eBool)-\u003eTree a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:filterTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "first3",
          "package": "GenI",
          "signature": "(a -\u003e a2) -\u003e (a, b, c) -\u003e (a2, b, c)",
          "source": "src/NLP-GenI-General.html#first3",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "first3",
          "normalized": "(a-\u003ea)-\u003e(a,b,c)-\u003e(a,b,c)",
          "package": "GenI",
          "signature": "(a-\u003ea)-\u003e(a,b,c)-\u003e(a,b,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:first3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "fst3",
          "package": "GenI",
          "signature": "(a, b, c) -\u003e a",
          "source": "src/NLP-GenI-General.html#fst3",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "fst3",
          "normalized": "(a,b,c)-\u003ea",
          "package": "GenI",
          "signature": "(a,b,c)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:fst3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eerrors specifically in GenI, which is very likely NOT the user's fault.\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "geniBug",
          "package": "GenI",
          "signature": "String -\u003e a",
          "source": "src/NLP-GenI-General.html#geniBug",
          "type": "function"
        },
        "index": {
          "description": "errors specifically in GenI which is very likely NOT the user fault",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "geniBug",
          "normalized": "String-\u003ea",
          "package": "GenI",
          "partial": "Bug",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:geniBug"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eServes the same function as \u003ccode\u003e\u003ca\u003egroupBy\u003c/a\u003e\u003c/code\u003e.  It groups together\n   items by some property they have in common. The difference is that the\n   property is used as a key to a Map that you can lookup.\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "groupByFM",
          "package": "GenI",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e Map b [a]",
          "source": "src/NLP-GenI-General.html#groupByFM",
          "type": "function"
        },
        "index": {
          "description": "Serves the same function as groupBy It groups together items by some property they have in common The difference is that the property is used as key to Map that you can lookup",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "groupByFM",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003eMap b[a]",
          "package": "GenI",
          "partial": "By FM",
          "signature": "(a-\u003eb)-\u003e[a]-\u003eMap b[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:groupByFM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"NLP.GenI.General\",\"NLP.GenI\"]",
          "name": "histogram",
          "package": "GenI",
          "signature": "[a] -\u003e Map a Int",
          "source": "src/NLP-GenI-General.html#histogram",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:histogram\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:histogram\"]"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "histogram",
          "normalized": "[a]-\u003eMap a Int",
          "package": "GenI",
          "signature": "[a]-\u003eMap a Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:histogram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "insertToListMap",
          "package": "GenI",
          "signature": "b -\u003e a -\u003e Map b [a] -\u003e Map b [a]",
          "source": "src/NLP-GenI-General.html#insertToListMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "insertToListMap",
          "normalized": "a-\u003eb-\u003eMap a[b]-\u003eMap a[b]",
          "package": "GenI",
          "partial": "To List Map",
          "signature": "b-\u003ea-\u003eMap b[a]-\u003eMap b[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:insertToListMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue if the intersection of two lists is empty.\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "isEmptyIntersect",
          "package": "GenI",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/NLP-GenI-General.html#isEmptyIntersect",
          "type": "function"
        },
        "index": {
          "description": "True if the intersection of two lists is empty",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "isEmptyIntersect",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "GenI",
          "partial": "Empty Intersect",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:isEmptyIntersect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "isGeniIdentLetter",
          "package": "GenI",
          "signature": "Char -\u003e Bool",
          "source": "src/NLP-GenI-General.html#isGeniIdentLetter",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "isGeniIdentLetter",
          "normalized": "Char-\u003eBool",
          "package": "GenI",
          "partial": "Geni Ident Letter",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:isGeniIdentLetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eival\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ex\u003c/code\u003e builds a trivial interval from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ex\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "ival",
          "package": "GenI",
          "signature": "Int -\u003e Interval",
          "source": "src/NLP-GenI-General.html#ival",
          "type": "function"
        },
        "index": {
          "description": "ival builds trivial interval from to",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "ival",
          "normalized": "Int-\u003eInterval",
          "package": "GenI",
          "signature": "Int-\u003eInterval",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:ival"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003erepNode\u003c/a\u003e\u003c/code\u003e but on a list of tree nodes\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "listRepNode",
          "package": "GenI",
          "signature": "(Tree a -\u003e Tree a)-\u003e (Tree a -\u003e Bool)-\u003e [Tree a]-\u003e ([Tree a], Bool)",
          "type": "function"
        },
        "index": {
          "description": "Like repNode but on list of tree nodes",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "listRepNode",
          "normalized": "(Tree a-\u003eTree a)-\u003e(Tree a-\u003eBool)-\u003e[Tree a]-\u003e([Tree a],Bool)",
          "package": "GenI",
          "partial": "Rep Node",
          "signature": "(Tree a-\u003eTree a)-\u003e(Tree a-\u003eBool)-\u003e[Tree a]-\u003e([Tree a],Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:listRepNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA strict version of \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "map'",
          "package": "GenI",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e [b]",
          "source": "src/NLP-GenI-General.html#map%27",
          "type": "function"
        },
        "index": {
          "description": "strict version of map",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "map'",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003e[b]",
          "package": "GenI",
          "signature": "(a-\u003eb)-\u003e[a]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:map-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "mapMaybeM",
          "package": "GenI",
          "signature": "(a -\u003e m (Maybe b)) -\u003e [a] -\u003e m [b]",
          "source": "src/NLP-GenI-General.html#mapMaybeM",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "mapMaybeM",
          "normalized": "(a-\u003eb(Maybe c))-\u003e[a]-\u003eb[c]",
          "package": "GenI",
          "partial": "Maybe",
          "signature": "(a-\u003em(Maybe b))-\u003e[a]-\u003em[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:mapMaybeM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrict version of \u003ccode\u003emapTree\u003c/code\u003e (for non-strict, just use fmap)\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "mapTree'",
          "package": "GenI",
          "signature": "(a -\u003e b) -\u003e Tree a -\u003e Tree b",
          "source": "src/NLP-GenI-General.html#mapTree%27",
          "type": "function"
        },
        "index": {
          "description": "Strict version of mapTree for non-strict just use fmap",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "mapTree'",
          "normalized": "(a-\u003eb)-\u003eTree a-\u003eTree b",
          "package": "GenI",
          "partial": "Tree'",
          "signature": "(a-\u003eb)-\u003eTree a-\u003eTree b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:mapTree-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003equoteText\u003c/a\u003e\u003c/code\u003e but only if it contains characters that are not\n   used in GenI identifiers\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "maybeQuoteText",
          "package": "GenI",
          "signature": "Text -\u003e Text",
          "source": "src/NLP-GenI-General.html#maybeQuoteText",
          "type": "function"
        },
        "index": {
          "description": "quoteText but only if it contains characters that are not used in GenI identifiers",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "maybeQuoteText",
          "normalized": "Text-\u003eText",
          "package": "GenI",
          "partial": "Quote Text",
          "signature": "Text-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:maybeQuoteText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe module name for an arbitrary data type\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "mkLogname",
          "package": "GenI",
          "signature": "a -\u003e String",
          "source": "src/NLP-GenI-General.html#mkLogname",
          "type": "function"
        },
        "index": {
          "description": "The module name for an arbitrary data type",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "mkLogname",
          "normalized": "a-\u003eString",
          "package": "GenI",
          "partial": "Logname",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:mkLogname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn pairs of (parent, terminal)\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "preTerminals",
          "package": "GenI",
          "signature": "Tree a -\u003e [(a, a)]",
          "source": "src/NLP-GenI-General.html#preTerminals",
          "type": "function"
        },
        "index": {
          "description": "Return pairs of parent terminal",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "preTerminals",
          "normalized": "Tree a-\u003e[(a,a)]",
          "package": "GenI",
          "partial": "Terminals",
          "signature": "Tree a-\u003e[(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:preTerminals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "prettyException",
          "package": "GenI",
          "signature": "IOException -\u003e String",
          "source": "src/NLP-GenI-General.html#prettyException",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "prettyException",
          "normalized": "IOException-\u003eString",
          "package": "GenI",
          "partial": "Exception",
          "signature": "IOException-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:prettyException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "quoteString",
          "package": "GenI",
          "signature": "String -\u003e String",
          "source": "src/NLP-GenI-General.html#quoteString",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "quoteString",
          "normalized": "String-\u003eString",
          "package": "GenI",
          "partial": "String",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:quoteString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "quoteText",
          "package": "GenI",
          "signature": "Text -\u003e Text",
          "source": "src/NLP-GenI-General.html#quoteText",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "quoteText",
          "normalized": "Text-\u003eText",
          "package": "GenI",
          "partial": "Text",
          "signature": "Text-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:quoteText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003erepNode\u003c/a\u003e\u003c/code\u003e except that it performs the operations on\n   all nodes that match and doesn't care if any nodes match\n   or not\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "repAllNode",
          "package": "GenI",
          "signature": "(Tree a -\u003e Tree a) -\u003e (Tree a -\u003e Bool) -\u003e Tree a -\u003e Tree a",
          "source": "src/NLP-GenI-General.html#repAllNode",
          "type": "function"
        },
        "index": {
          "description": "Like repNode except that it performs the operations on all nodes that match and doesn care if any nodes match or not",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "repAllNode",
          "normalized": "(Tree a-\u003eTree a)-\u003e(Tree a-\u003eBool)-\u003eTree a-\u003eTree a",
          "package": "GenI",
          "partial": "All Node",
          "signature": "(Tree a-\u003eTree a)-\u003e(Tree a-\u003eBool)-\u003eTree a-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:repAllNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the list, modifying only the first matching item.\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "repList",
          "package": "GenI",
          "signature": "(a -\u003e Bool) -\u003e (a -\u003e a) -\u003e [a] -\u003e [a]",
          "source": "src/NLP-GenI-General.html#repList",
          "type": "function"
        },
        "index": {
          "description": "Return the list modifying only the first matching item",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "repList",
          "normalized": "(a-\u003eBool)-\u003e(a-\u003ea)-\u003e[a]-\u003e[a]",
          "package": "GenI",
          "partial": "List",
          "signature": "(a-\u003eBool)-\u003e(a-\u003ea)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:repList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003erepNode\u003c/a\u003e\u003c/code\u003e \u003ccode\u003efn filt t\u003c/code\u003e returns a version of \u003ccode\u003et\u003c/code\u003e in which the first\n   node which \u003ccode\u003efilt\u003c/code\u003e matches is transformed using \u003ccode\u003efn\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "repNode",
          "package": "GenI",
          "signature": "(Tree a -\u003e Tree a)-\u003e (Tree a -\u003e Bool)-\u003e Tree a-\u003e Maybe (Tree a)",
          "type": "function"
        },
        "index": {
          "description": "repNode fn filt returns version of in which the first node which filt matches is transformed using fn",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "repNode",
          "normalized": "(Tree a-\u003eTree a)-\u003e(Tree a-\u003eBool)-\u003eTree a-\u003eMaybe(Tree a)",
          "package": "GenI",
          "partial": "Node",
          "signature": "(Tree a-\u003eTree a)-\u003e(Tree a-\u003eBool)-\u003eTree a-\u003eMaybe(Tree a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:repNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace a node in the tree in-place with another node; keep the\n   children the same.  If the node is not found in the tree, or if\n   there are multiple instances of the node, this is treated as an\n   error.\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "repNodeByNode",
          "package": "GenI",
          "signature": "(a -\u003e Bool)-\u003e a-\u003e Tree a-\u003e Tree a",
          "type": "function"
        },
        "index": {
          "description": "Replace node in the tree in-place with another node keep the children the same If the node is not found in the tree or if there are multiple instances of the node this is treated as an error",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "repNodeByNode",
          "normalized": "(a-\u003eBool)-\u003ea-\u003eTree a-\u003eTree a",
          "package": "GenI",
          "partial": "Node By Node",
          "signature": "(a-\u003eBool)-\u003ea-\u003eTree a-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:repNodeByNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "second3",
          "package": "GenI",
          "signature": "(b -\u003e b2) -\u003e (a, b, c) -\u003e (a, b2, c)",
          "source": "src/NLP-GenI-General.html#second3",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "second3",
          "normalized": "(a-\u003ea)-\u003e(b,a,c)-\u003e(b,a,c)",
          "package": "GenI",
          "signature": "(b-\u003eb)-\u003e(a,b,c)-\u003e(a,b,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:second3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edisplays a bit vector, using a minimum number of bits\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "showBitVector",
          "package": "GenI",
          "signature": "Int -\u003e BitVector -\u003e String",
          "source": "src/NLP-GenI-General.html#showBitVector",
          "type": "function"
        },
        "index": {
          "description": "displays bit vector using minimum number of bits",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "showBitVector",
          "normalized": "Int-\u003eBitVector-\u003eString",
          "package": "GenI",
          "partial": "Bit Vector",
          "signature": "Int-\u003eBitVector-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:showBitVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "showInterval",
          "package": "GenI",
          "signature": "Interval -\u003e String",
          "source": "src/NLP-GenI-General.html#showInterval",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "showInterval",
          "normalized": "Interval-\u003eString",
          "package": "GenI",
          "partial": "Interval",
          "signature": "Interval-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:showInterval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "snd3",
          "package": "GenI",
          "signature": "(a, b, c) -\u003e b",
          "source": "src/NLP-GenI-General.html#snd3",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "snd3",
          "normalized": "(a,b,c)-\u003eb",
          "package": "GenI",
          "signature": "(a,b,c)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:snd3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "thd3",
          "package": "GenI",
          "signature": "(a, b, c) -\u003e c",
          "source": "src/NLP-GenI-General.html#thd3",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "thd3",
          "normalized": "(a,b,c)-\u003ec",
          "package": "GenI",
          "signature": "(a,b,c)-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:thd3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "third3",
          "package": "GenI",
          "signature": "(c -\u003e c2) -\u003e (a, b, c) -\u003e (a, b, c2)",
          "source": "src/NLP-GenI-General.html#third3",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "third3",
          "normalized": "(a-\u003ea)-\u003e(b,c,a)-\u003e(b,c,a)",
          "package": "GenI",
          "signature": "(c-\u003ec)-\u003e(a,b,c)-\u003e(a,b,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:third3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn alphanumeric sort is one where you treat the numbers in the string\n   as actual numbers.  An alphanumeric sort would put x2 before x100,\n   because 2 \u003c 10, wheraeas a naive sort would put it the other way\n   around because the characters 1 \u003c 2.  To sort alphanumerically, just\n   'sortBy (comparing toAlphaNum)'\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "toAlphaNum",
          "package": "GenI",
          "signature": "String -\u003e [AlphaNum]",
          "source": "src/NLP-GenI-General.html#toAlphaNum",
          "type": "function"
        },
        "index": {
          "description": "An alphanumeric sort is one where you treat the numbers in the string as actual numbers An alphanumeric sort would put x2 before x100 because wheraeas naive sort would put it the other way around because the characters To sort alphanumerically just sortBy comparing toAlphaNum",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "toAlphaNum",
          "normalized": "String-\u003e[AlphaNum]",
          "package": "GenI",
          "partial": "Alpha Num",
          "signature": "String-\u003e[AlphaNum]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:toAlphaNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake the first character of a string lower case\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "toLowerHead",
          "package": "GenI",
          "signature": "String -\u003e String",
          "source": "src/NLP-GenI-General.html#toLowerHead",
          "type": "function"
        },
        "index": {
          "description": "Make the first character of string lower case",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "toLowerHead",
          "normalized": "String-\u003eString",
          "package": "GenI",
          "partial": "Lower Head",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:toLowerHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake the first character of a string upper case\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "toUpperHead",
          "package": "GenI",
          "signature": "String -\u003e String",
          "source": "src/NLP-GenI-General.html#toUpperHead",
          "type": "function"
        },
        "index": {
          "description": "Make the first character of string upper case",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "toUpperHead",
          "normalized": "String-\u003eString",
          "package": "GenI",
          "partial": "Upper Head",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:toUpperHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe leaf nodes of a Tree\n\u003c/p\u003e",
          "module": "NLP.GenI.General",
          "name": "treeLeaves",
          "package": "GenI",
          "signature": "Tree a -\u003e [a]",
          "source": "src/NLP-GenI-General.html#treeLeaves",
          "type": "function"
        },
        "index": {
          "description": "The leaf nodes of Tree",
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "treeLeaves",
          "normalized": "Tree a-\u003e[a]",
          "package": "GenI",
          "partial": "Leaves",
          "signature": "Tree a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:treeLeaves"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.General",
          "name": "trim",
          "package": "GenI",
          "signature": "String -\u003e String",
          "source": "src/NLP-GenI-General.html#trim",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI General",
          "module": "NLP.GenI.General",
          "name": "trim",
          "normalized": "String-\u003eString",
          "package": "GenI",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-General.html#v:trim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.GeniShow",
          "name": "GeniShow",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniShow.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI GeniShow",
          "module": "NLP.GenI.GeniShow",
          "name": "GeniShow",
          "package": "GenI",
          "partial": "Geni Show",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniShow.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenI format; should round-trip with \u003ccode\u003e\u003ca\u003eParser\u003c/a\u003e\u003c/code\u003e by rights\n\u003c/p\u003e\u003cp\u003eMinimal definition, either one of \u003ccode\u003e\u003ca\u003egeniShow\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003egeniShowText\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniShow",
          "name": "GeniShow",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniShow.html#GeniShow",
          "type": "class"
        },
        "index": {
          "description": "GenI format should round-trip with Parser by rights Minimal definition either one of geniShow or geniShowText",
          "hierarchy": "NLP GenI GeniShow",
          "module": "NLP.GenI.GeniShow",
          "name": "GeniShow",
          "package": "GenI",
          "partial": "Geni Show",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniShow.html#t:GeniShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.GeniShow",
          "name": "geniKeyword",
          "package": "GenI",
          "signature": "Text -\u003e Text -\u003e Text",
          "source": "src/NLP-GenI-GeniShow.html#geniKeyword",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI GeniShow",
          "module": "NLP.GenI.GeniShow",
          "name": "geniKeyword",
          "normalized": "Text-\u003eText-\u003eText",
          "package": "GenI",
          "partial": "Keyword",
          "signature": "Text-\u003eText-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniShow.html#v:geniKeyword"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.GeniShow",
          "name": "geniShow",
          "package": "GenI",
          "signature": "a -\u003e String",
          "source": "src/NLP-GenI-GeniShow.html#geniShow",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI GeniShow",
          "module": "NLP.GenI.GeniShow",
          "name": "geniShow",
          "normalized": "a-\u003eString",
          "package": "GenI",
          "partial": "Show",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniShow.html#v:geniShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.GeniShow",
          "name": "geniShowText",
          "package": "GenI",
          "signature": "a -\u003e Text",
          "source": "src/NLP-GenI-GeniShow.html#geniShowText",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI GeniShow",
          "module": "NLP.GenI.GeniShow",
          "name": "geniShowText",
          "normalized": "a-\u003eText",
          "package": "GenI",
          "partial": "Show Text",
          "signature": "a-\u003eText",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniShow.html#v:geniShowText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.GeniShow",
          "name": "geniShowTree",
          "package": "GenI",
          "signature": "Int -\u003e Tree a -\u003e Text",
          "source": "src/NLP-GenI-GeniShow.html#geniShowTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI GeniShow",
          "module": "NLP.GenI.GeniShow",
          "name": "geniShowTree",
          "normalized": "Int-\u003eTree a-\u003eText",
          "package": "GenI",
          "partial": "Show Tree",
          "signature": "Int-\u003eTree a-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniShow.html#v:geniShowTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGory details for \u003ccode\u003e\u003ca\u003eGeniVal\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "Internal",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html",
          "type": "module"
        },
        "index": {
          "description": "Gory details for GeniVal",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "Internal",
          "package": "GenI",
          "partial": "Internal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eCollectable\u003c/a\u003e\u003c/code\u003e is something which can return its variables as a\n   map from the variable to the number of times that variable occurs\n   in it.\n\u003c/p\u003e\u003cp\u003eImportant invariant: if the variable does not occur, then it does\n   not appear in the map (ie. all counts must be \u003e= 1 or the item\n   does not occur at all)\n\u003c/p\u003e\u003cp\u003eBy variables, what I most had in mind was the GVar values in a\n   GeniVal.  This notion is probably not very useful outside the context of\n   alpha-conversion task, but it seems general enough that I'll keep it\n   around for a good bit, until either some use for it creeps up, or I find\n   a more general notion that I can transform this into.\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "Collectable",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#Collectable",
          "type": "class"
        },
        "index": {
          "description": "Collectable is something which can return its variables as map from the variable to the number of times that variable occurs in it Important invariant if the variable does not occur then it does not appear in the map ie all counts must be or the item does not occur at all By variables what most had in mind was the GVar values in GeniVal This notion is probably not very useful outside the context of alpha-conversion task but it seems general enough that ll keep it around for good bit until either some use for it creeps up or find more general notion that can transform this into",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "Collectable",
          "package": "GenI",
          "partial": "Collectable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#t:Collectable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variable label and its constraints\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "CollectedVar",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#CollectedVar",
          "type": "type"
        },
        "index": {
          "description": "variable label and its constraints",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "CollectedVar",
          "package": "GenI",
          "partial": "Collected Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#t:CollectedVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA structure that can be traversed with a \u003ccode\u003e\u003ca\u003eGeniVal\u003c/a\u003e\u003c/code\u003e-replacing\n   function (typical use case: substitution after unification)\n\u003c/p\u003e\u003cp\u003eApproach suggested by Neil Mitchell after I found that Uniplate\n   seemed to hurt GenI performance a bit.\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "DescendGeniVal",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#DescendGeniVal",
          "type": "class"
        },
        "index": {
          "description": "structure that can be traversed with GeniVal replacing function typical use case substitution after unification Approach suggested by Neil Mitchell after found that Uniplate seemed to hurt GenI performance bit",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "DescendGeniVal",
          "package": "GenI",
          "partial": "Descend Geni Val",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#t:DescendGeniVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e constant : no label, just constraints\n\u003c/li\u003e\u003cli\u003e variable : label, with or without constraints\n\u003c/li\u003e\u003cli\u003e anonymous : no label, no constraints\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "GeniVal",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#GeniVal",
          "type": "data"
        },
        "index": {
          "description": "constant no label just constraints variable label with or without constraints anonymous no label no constraints",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "GeniVal",
          "package": "GenI",
          "partial": "Geni Val",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#t:GeniVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn Idable is something that can be mapped to a unique id.\n   You might consider using this to implement Ord, but I won't.\n   Note that the only use I have for this so far (20 dec 2005)\n  is in alpha-conversion.\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "Idable",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#Idable",
          "type": "class"
        },
        "index": {
          "description": "An Idable is something that can be mapped to unique id You might consider using this to implement Ord but won Note that the only use have for this so far dec is in alpha-conversion",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "Idable",
          "package": "GenI",
          "partial": "Idable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#t:Idable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "MonadUnify",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#MonadUnify",
          "type": "class"
        },
        "index": {
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "MonadUnify",
          "package": "GenI",
          "partial": "Monad Unify",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#t:MonadUnify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA schema value is a disjunction of GenI values.  It allows us to express\n   &#8220;fancy&#8221; disjunctions in tree schemata, ie. disjunctions over variables\n   and not just atoms (\u003ccode\u003e?X;?Y\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eOur rule is that that when a tree schema is instantiated, any fancy\n   disjunctions must be &#8220;crushed&#8221; into a single \u003ccode\u003e\u003ca\u003eGeniVal\u003c/a\u003e\u003c/code\u003e lest it be\n   rejected (see \u003ccode\u003e\u003ca\u003ecrushOne\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e\u003cp\u003eNote that this is still not recursive; we don't have disjunction over\n   schema values, nor can schema values refer to schema values.  It just\n   allows us to express the idea that in tree schemata, you can have\n   either variable \u003ccode\u003e?X\u003c/code\u003e or \u003ccode\u003e?Y\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "SchemaVal",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#SchemaVal",
          "type": "newtype"
        },
        "index": {
          "description": "schema value is disjunction of GenI values It allows us to express fancy disjunctions in tree schemata ie disjunctions over variables and not just atoms Our rule is that that when tree schema is instantiated any fancy disjunctions must be crushed into single GeniVal lest it be rejected see crushOne Note that this is still not recursive we don have disjunction over schema values nor can schema values refer to schema values It just allows us to express the idea that in tree schemata you can have either variable or",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "SchemaVal",
          "package": "GenI",
          "partial": "Schema Val",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#t:SchemaVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variable substitution map.\n   GenI unification works by rewriting variables\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "Subst",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#Subst",
          "type": "type"
        },
        "index": {
          "description": "variable substitution map GenI unification works by rewriting variables",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "Subst",
          "package": "GenI",
          "partial": "Subst",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#t:Subst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnification can either&#8230;\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "UnificationResult",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#UnificationResult",
          "type": "data"
        },
        "index": {
          "description": "Unification can either",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "UnificationResult",
          "package": "GenI",
          "partial": "Unification Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#t:UnificationResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eor fail\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "Failure",
          "package": "GenI",
          "signature": "Failure",
          "source": "src/NLP-GenI-GeniVal-Internal.html#UnificationResult",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:Failure\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:Failure\"]"
        },
        "index": {
          "description": "or fail",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "Failure",
          "package": "GenI",
          "partial": "Failure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:Failure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "GeniVal",
          "package": "GenI",
          "signature": "GeniVal",
          "source": "src/NLP-GenI-GeniVal-Internal.html#GeniVal",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "GeniVal",
          "package": "GenI",
          "partial": "Geni Val",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:GeniVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "SchemaVal",
          "package": "GenI",
          "signature": "SchemaVal [GeniVal]",
          "source": "src/NLP-GenI-GeniVal-Internal.html#SchemaVal",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:SchemaVal\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:SchemaVal\"]"
        },
        "index": {
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "SchemaVal",
          "normalized": "SchemaVal[GeniVal]",
          "package": "GenI",
          "partial": "Schema Val",
          "signature": "SchemaVal[GeniVal]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:SchemaVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esucceed with a one-way substitution,\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "SuccessRep",
          "package": "GenI",
          "signature": "SuccessRep Text GeniVal",
          "source": "src/NLP-GenI-GeniVal-Internal.html#UnificationResult",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:SuccessRep\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:SuccessRep\"]"
        },
        "index": {
          "description": "succeed with one-way substitution",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "SuccessRep",
          "package": "GenI",
          "partial": "Success Rep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:SuccessRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esucceed w both vars needing substitution\n   (constraint intersection),\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "SuccessRep2",
          "package": "GenI",
          "signature": "SuccessRep2 Text Text GeniVal",
          "source": "src/NLP-GenI-GeniVal-Internal.html#UnificationResult",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:SuccessRep2\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:SuccessRep2\"]"
        },
        "index": {
          "description": "succeed both vars needing substitution constraint intersection",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "SuccessRep2",
          "package": "GenI",
          "partial": "Success Rep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:SuccessRep2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esucceed for free (no substitutions),\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "SuccessSans",
          "package": "GenI",
          "signature": "SuccessSans GeniVal",
          "source": "src/NLP-GenI-GeniVal-Internal.html#UnificationResult",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:SuccessSans\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:SuccessSans\"]"
        },
        "index": {
          "description": "succeed for free no substitutions",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "SuccessSans",
          "package": "GenI",
          "partial": "Success Sans",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:SuccessSans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003el1 \u003ccode\u003e\u003ca\u003eallSubsume\u003c/a\u003e\u003c/code\u003e l2\u003c/code\u003e returns the result of \u003ccode\u003el1 \u003ccode\u003e\u003ca\u003eunify\u003c/a\u003e\u003c/code\u003e l2\u003c/code\u003e if\n   doing a simultaneous traversal of both lists, each item in\n   \u003ccode\u003el1\u003c/code\u003e subsumes the corresponding item in \u003ccode\u003el2\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "allSubsume",
          "package": "GenI",
          "signature": "[GeniVal] -\u003e [GeniVal] -\u003e m ([GeniVal], Subst)",
          "source": "src/NLP-GenI-GeniVal-Internal.html#allSubsume",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:allSubsume\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:allSubsume\"]"
        },
        "index": {
          "description": "l1 allSubsume l2 returns the result of l1 unify l2 if doing simultaneous traversal of both lists each item in l1 subsumes the corresponding item in l2",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "allSubsume",
          "normalized": "[GeniVal]-\u003e[GeniVal]-\u003ea([GeniVal],Subst)",
          "package": "GenI",
          "partial": "Subsume",
          "signature": "[GeniVal]-\u003e[GeniVal]-\u003em([GeniVal],Subst)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:allSubsume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnonymise any variable that occurs only once in the object\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "anonymiseSingletons",
          "package": "GenI",
          "signature": "a -\u003e a",
          "source": "src/NLP-GenI-GeniVal-Internal.html#anonymiseSingletons",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:anonymiseSingletons\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:anonymiseSingletons\"]"
        },
        "index": {
          "description": "Anonymise any variable that occurs only once in the object",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "anonymiseSingletons",
          "normalized": "a-\u003ea",
          "package": "GenI",
          "partial": "Singletons",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:anonymiseSingletons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNote that the first Subst is assumed to come chronologically\n   before the second one; so merging \u003ccode\u003e{ X -\u003e Y }\u003c/code\u003e and \u003ccode\u003e{ Y -\u003e 3 }\u003c/code\u003e\n   should give us \u003ccode\u003e{ X -\u003e 3; Y -\u003e 3 }\u003c/code\u003e;\n\u003c/p\u003e\u003cp\u003eSee \u003ccode\u003e\u003ca\u003eprependToSubst\u003c/a\u003e\u003c/code\u003e for a warning!\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "appendSubst",
          "package": "GenI",
          "signature": "Subst -\u003e Subst -\u003e Subst",
          "source": "src/NLP-GenI-GeniVal-Internal.html#appendSubst",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:appendSubst\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:appendSubst\"]"
        },
        "index": {
          "description": "Note that the first Subst is assumed to come chronologically before the second one so merging and should give us See prependToSubst for warning",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "appendSubst",
          "normalized": "Subst-\u003eSubst-\u003eSubst",
          "package": "GenI",
          "partial": "Subst",
          "signature": "Subst-\u003eSubst-\u003eSubst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:appendSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecollect x m\u003c/code\u003e increments our count for any variables in \u003ccode\u003ex\u003c/code\u003e\n   (adds not-yet-seen variables as needed)\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "collect",
          "package": "GenI",
          "signature": "a -\u003e Map CollectedVar Int -\u003e Map CollectedVar Int",
          "source": "src/NLP-GenI-GeniVal-Internal.html#collect",
          "type": "method"
        },
        "index": {
          "description": "collect increments our count for any variables in adds not-yet-seen variables as needed",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "collect",
          "normalized": "a-\u003eMap CollectedVar Int-\u003eMap CollectedVar Int",
          "package": "GenI",
          "signature": "a-\u003eMap CollectedVar Int-\u003eMap CollectedVar Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:collect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a list of fancy disjunctions\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "crushList",
          "package": "GenI",
          "signature": "[SchemaVal] -\u003e Maybe [GeniVal]",
          "source": "src/NLP-GenI-GeniVal-Internal.html#crushList",
          "type": "function"
        },
        "index": {
          "description": "Convert list of fancy disjunctions",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "crushList",
          "normalized": "[SchemaVal]-\u003eMaybe[GeniVal]",
          "package": "GenI",
          "partial": "List",
          "signature": "[SchemaVal]-\u003eMaybe[GeniVal]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:crushList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a fancy disjunction (allowing disjunction over variables) value\n   into a plain old atomic disjunction. The idea is to support a limited\n   notion of fancy disjunction by requiring that there be a single point\n   where this disjunction can be converted into a plain old variable.\n   Note that we currently convert these to constants only.\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "crushOne",
          "package": "GenI",
          "signature": "SchemaVal -\u003e Maybe GeniVal",
          "source": "src/NLP-GenI-GeniVal-Internal.html#crushOne",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:crushOne\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:crushOne\"]"
        },
        "index": {
          "description": "Convert fancy disjunction allowing disjunction over variables value into plain old atomic disjunction The idea is to support limited notion of fancy disjunction by requiring that there be single point where this disjunction can be converted into plain old variable Note that we currently convert these to constants only",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "crushOne",
          "normalized": "SchemaVal-\u003eMaybe GeniVal",
          "package": "GenI",
          "partial": "One",
          "signature": "SchemaVal-\u003eMaybe GeniVal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:crushOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edescendGeniVal f x\u003c/code\u003e applies \u003ccode\u003ef\u003c/code\u003e to all \u003ccode\u003e\u003ca\u003eGeniVal\u003c/a\u003e\u003c/code\u003e in \u003ccode\u003ex\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "descendGeniVal",
          "package": "GenI",
          "signature": "(GeniVal -\u003e GeniVal) -\u003e a -\u003e a",
          "source": "src/NLP-GenI-GeniVal-Internal.html#descendGeniVal",
          "type": "method"
        },
        "index": {
          "description": "descendGeniVal applies to all GeniVal in",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "descendGeniVal",
          "normalized": "(GeniVal-\u003eGeniVal)-\u003ea-\u003ea",
          "package": "GenI",
          "partial": "Geni Val",
          "signature": "(GeniVal-\u003eGeniVal)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:descendGeniVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efinaliseVars\u003c/a\u003e\u003c/code\u003e does the following:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e (if suffix is non-null) appends a suffix to all variable names\n     to ensure global uniqueness\n\u003c/li\u003e\u003cli\u003e intersects constraints for for all variables within the same\n     object\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "finaliseVars",
          "package": "GenI",
          "signature": "Text -\u003e a -\u003e a",
          "source": "src/NLP-GenI-GeniVal-Internal.html#finaliseVars",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:finaliseVars\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:finaliseVars\"]"
        },
        "index": {
          "description": "finaliseVars does the following if suffix is non-null appends suffix to all variable names to ensure global uniqueness intersects constraints for for all variables within the same object",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "finaliseVars",
          "normalized": "Text-\u003ea-\u003ea",
          "package": "GenI",
          "partial": "Vars",
          "signature": "Text-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:finaliseVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efinaliseVarsById\u003c/a\u003e\u003c/code\u003e appends a unique suffix to all variables in\n an object.  This avoids us having to alpha convert all the time\n and relies on the assumption finding that a unique suffix is\n possible.\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "finaliseVarsById",
          "package": "GenI",
          "signature": "a -\u003e a",
          "source": "src/NLP-GenI-GeniVal-Internal.html#finaliseVarsById",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:finaliseVarsById\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:finaliseVarsById\"]"
        },
        "index": {
          "description": "finaliseVarsById appends unique suffix to all variables in an object This avoids us having to alpha convert all the time and relies on the assumption finding that unique suffix is possible",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "finaliseVarsById",
          "normalized": "a-\u003ea",
          "package": "GenI",
          "partial": "Vars By Id",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:finaliseVarsById"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptional values/constraints\n   Must have at least one if at all\n\u003c/p\u003e\u003cp\u003eThough it may seem a bit redudant, this is not quite the same\n   as having '[Text]' because \u003ccode\u003eNothing\u003c/code\u003e means no constraints;\n   whereas \u003ccode\u003eJust []\u003c/code\u003e (impossible here) would mean bottom.\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "gConstraints",
          "package": "GenI",
          "signature": "Maybe (FullList Text)",
          "source": "src/NLP-GenI-GeniVal-Internal.html#GeniVal",
          "type": "function"
        },
        "index": {
          "description": "Optional values constraints Must have at least one if at all Though it may seem bit redudant this is not quite the same as having Text because Nothing means no constraints whereas Just impossible here would mean bottom",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "gConstraints",
          "package": "GenI",
          "partial": "Constraints",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:gConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptional label (\u003ccode\u003e?X\u003c/code\u003e would have \u003ccode\u003eJust \u003ca\u003eX\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "gLabel",
          "package": "GenI",
          "signature": "Maybe Text",
          "source": "src/NLP-GenI-GeniVal-Internal.html#GeniVal",
          "type": "function"
        },
        "index": {
          "description": "Optional label would have Just",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "gLabel",
          "package": "GenI",
          "partial": "Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:gLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "idOf",
          "package": "GenI",
          "signature": "idOf",
          "source": "src/NLP-GenI-GeniVal-Internal.html#idOf",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "idOf",
          "package": "GenI",
          "partial": "Of",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:idOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eintersectConstraints (Just cs1) (Just cs2)\u003c/code\u003e returns the intersection of\n   \u003ccode\u003ecs1\u003c/code\u003e and \u003ccode\u003ecs2\u003c/code\u003e if non-empty (or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there's nothing in common)\n\u003c/p\u003e\u003cp\u003eIf any of the arguments is unconstrained (\u003ccode\u003eNothing\u003c/code\u003e), we simply return\n   the other.\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "intersectConstraints",
          "package": "GenI",
          "signature": "Maybe (FullList a) -\u003e Maybe (FullList a) -\u003e Maybe (Maybe (FullList a))",
          "source": "src/NLP-GenI-GeniVal-Internal.html#intersectConstraints",
          "type": "function"
        },
        "index": {
          "description": "intersectConstraints Just cs1 Just cs2 returns the intersection of cs1 and cs2 if non-empty or Nothing if there nothing in common If any of the arguments is unconstrained Nothing we simply return the other",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "intersectConstraints",
          "normalized": "Maybe(FullList a)-\u003eMaybe(FullList a)-\u003eMaybe(Maybe(FullList a))",
          "package": "GenI",
          "partial": "Constraints",
          "signature": "Maybe(FullList a)-\u003eMaybe(FullList a)-\u003eMaybe(Maybe(FullList a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:intersectConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn anonymous \u003ccode\u003e\u003ca\u003eGeniVal\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e_\u003c/code\u003e or \u003ccode\u003e?_\u003c/code\u003e) has no labels/constraints\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "isAnon",
          "package": "GenI",
          "signature": "GeniVal -\u003e Bool",
          "source": "src/NLP-GenI-GeniVal-Internal.html#isAnon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:isAnon\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:isAnon\"]"
        },
        "index": {
          "description": "An anonymous GeniVal or has no labels constraints",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "isAnon",
          "normalized": "GeniVal-\u003eBool",
          "package": "GenI",
          "partial": "Anon",
          "signature": "GeniVal-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:isAnon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an anonymous value\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "mkGAnon",
          "package": "GenI",
          "signature": "GeniVal",
          "source": "src/NLP-GenI-GeniVal-Internal.html#mkGAnon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:mkGAnon\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:mkGAnon\"]"
        },
        "index": {
          "description": "Create an anonymous value",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "mkGAnon",
          "package": "GenI",
          "partial": "GAnon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:mkGAnon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emkGConst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ex :! []\u003c/code\u003e creates a single constant.  \u003ccode\u003e\u003ca\u003emkGConst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ex :! xs\u003c/code\u003e\n   creates an atomic disjunction.  It makes no difference which of the values\n   you supply for \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003exs\u003c/code\u003e as they will be sorted and nubed anyway.\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "mkGConst",
          "package": "GenI",
          "signature": "FullList Text-\u003e GeniVal",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:mkGConst\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:mkGConst\"]"
        },
        "index": {
          "description": "mkGConst creates single constant mkGConst xs creates an atomic disjunction It makes no difference which of the values you supply for and xs as they will be sorted and nubed anyway",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "mkGConst",
          "normalized": "FullList Text-\u003eGeniVal",
          "package": "GenI",
          "partial": "GConst",
          "signature": "FullList Text-\u003eGeniVal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:mkGConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a singleton constant (no disjunction here)\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "mkGConstNone",
          "package": "GenI",
          "signature": "Text -\u003e GeniVal",
          "source": "src/NLP-GenI-GeniVal-Internal.html#mkGConstNone",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:mkGConstNone\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:mkGConstNone\"]"
        },
        "index": {
          "description": "Create singleton constant no disjunction here",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "mkGConstNone",
          "normalized": "Text-\u003eGeniVal",
          "package": "GenI",
          "partial": "GConst None",
          "signature": "Text-\u003eGeniVal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:mkGConstNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a variable\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "mkGVar",
          "package": "GenI",
          "signature": "Text-\u003e Maybe (FullList Text)-\u003e GeniVal",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:mkGVar\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:mkGVar\"]"
        },
        "index": {
          "description": "Create variable",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "mkGVar",
          "normalized": "Text-\u003eMaybe(FullList Text)-\u003eGeniVal",
          "package": "GenI",
          "partial": "GVar",
          "signature": "Text-\u003eMaybe(FullList Text)-\u003eGeniVal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:mkGVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a variable with no constraints\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "mkGVarNone",
          "package": "GenI",
          "signature": "Text -\u003e GeniVal",
          "source": "src/NLP-GenI-GeniVal-Internal.html#mkGVarNone",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:mkGVarNone\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:mkGVarNone\"]"
        },
        "index": {
          "description": "Create variable with no constraints",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "mkGVarNone",
          "normalized": "Text-\u003eGeniVal",
          "package": "GenI",
          "partial": "GVar None",
          "signature": "Text-\u003eGeniVal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:mkGVarNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd to variable replacement to a \u003ccode\u003e\u003ca\u003eSubst\u003c/a\u003e\u003c/code\u003e that logical comes before\n   the other stuff in it.  So for example, if we have \u003ccode\u003eY -\u003e foo\u003c/code\u003e\n   and we want to insert \u003ccode\u003eX -\u003e Y\u003c/code\u003e, we notice that, in fact, \u003ccode\u003eY\u003c/code\u003e has\n   already been replaced by \u003ccode\u003efoo\u003c/code\u003e, so we add \u003ccode\u003eX -\u003e foo\u003c/code\u003e instead\n\u003c/p\u003e\u003cp\u003eNote that it is undefined if you try to append something like\n   \u003ccode\u003eY -\u003e foo\u003c/code\u003e to \u003ccode\u003eY -\u003e bar\u003c/code\u003e, because that would mean that unification\n   is broken\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "prependToSubst",
          "package": "GenI",
          "signature": "(Text, GeniVal) -\u003e Subst -\u003e Subst",
          "source": "src/NLP-GenI-GeniVal-Internal.html#prependToSubst",
          "type": "function"
        },
        "index": {
          "description": "Add to variable replacement to Subst that logical comes before the other stuff in it So for example if we have foo and we want to insert we notice that in fact has already been replaced by foo so we add foo instead Note that it is undefined if you try to append something like foo to bar because that would mean that unification is broken",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "prependToSubst",
          "normalized": "(Text,GeniVal)-\u003eSubst-\u003eSubst",
          "package": "GenI",
          "partial": "To Subst",
          "signature": "(Text,GeniVal)-\u003eSubst-\u003eSubst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:prependToSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor debugging\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "prettySubst",
          "package": "GenI",
          "signature": "Subst -\u003e Text",
          "source": "src/NLP-GenI-GeniVal-Internal.html#prettySubst",
          "type": "function"
        },
        "index": {
          "description": "For debugging",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "prettySubst",
          "normalized": "Subst-\u003eText",
          "package": "GenI",
          "partial": "Subst",
          "signature": "Subst-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:prettySubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply variable substitutions\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "replace",
          "package": "GenI",
          "signature": "Subst -\u003e a -\u003e a",
          "source": "src/NLP-GenI-GeniVal-Internal.html#replace",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:replace\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:replace\"]"
        },
        "index": {
          "description": "Apply variable substitutions",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "replace",
          "normalized": "Subst-\u003ea-\u003ea",
          "package": "GenI",
          "signature": "Subst-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:replace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHere it is safe to say (X -\u003e Y; Y -\u003e Z) because this would be crushed\n   down into a final value of (X -\u003e Z; Y -\u003e Z)\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "replaceList",
          "package": "GenI",
          "signature": "[(Text, GeniVal)] -\u003e a -\u003e a",
          "source": "src/NLP-GenI-GeniVal-Internal.html#replaceList",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:replaceList\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:replaceList\"]"
        },
        "index": {
          "description": "Here it is safe to say because this would be crushed down into final value of",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "replaceList",
          "normalized": "[(Text,GeniVal)]-\u003ea-\u003ea",
          "package": "GenI",
          "partial": "List",
          "signature": "[(Text,GeniVal)]-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:replaceList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCore implementation for \u003ccode\u003e\u003ca\u003ereplace\u003c/a\u003e\u003c/code\u003e\n   For use by the Uniplate-esq \u003ccode\u003e\u003ca\u003edescendGeniVal\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "replaceMapG",
          "package": "GenI",
          "signature": "Subst -\u003e GeniVal -\u003e GeniVal",
          "source": "src/NLP-GenI-GeniVal-Internal.html#replaceMapG",
          "type": "function"
        },
        "index": {
          "description": "Core implementation for replace For use by the Uniplate-esq descendGeniVal",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "replaceMapG",
          "normalized": "Subst-\u003eGeniVal-\u003eGeniVal",
          "package": "GenI",
          "partial": "Map",
          "signature": "Subst-\u003eGeniVal-\u003eGeniVal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:replaceMapG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a single variable substitution\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "replaceOne",
          "package": "GenI",
          "signature": "(Text, GeniVal) -\u003e a -\u003e a",
          "source": "src/NLP-GenI-GeniVal-Internal.html#replaceOne",
          "type": "function"
        },
        "index": {
          "description": "Apply single variable substitution",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "replaceOne",
          "normalized": "(Text,GeniVal)-\u003ea-\u003ea",
          "package": "GenI",
          "partial": "One",
          "signature": "(Text,GeniVal)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:replaceOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCore implementation for \u003ccode\u003e\u003ca\u003ereplaceOne\u003c/a\u003e\u003c/code\u003e\n   For use by the Uniplate-esq \u003ccode\u003e\u003ca\u003edescendGeniVal\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "replaceOneG",
          "package": "GenI",
          "signature": "(Text, GeniVal) -\u003e GeniVal -\u003e GeniVal",
          "source": "src/NLP-GenI-GeniVal-Internal.html#replaceOneG",
          "type": "function"
        },
        "index": {
          "description": "Core implementation for replaceOne For use by the Uniplate-esq descendGeniVal",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "replaceOneG",
          "normalized": "(Text,GeniVal)-\u003eGeniVal-\u003eGeniVal",
          "package": "GenI",
          "partial": "One",
          "signature": "(Text,GeniVal)-\u003eGeniVal-\u003eGeniVal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:replaceOneG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf \u003ccode\u003ev\u003c/code\u003e has exactly one value/constraint, returns it\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "singletonVal",
          "package": "GenI",
          "signature": "GeniVal -\u003e Maybe Text",
          "source": "src/NLP-GenI-GeniVal-Internal.html#singletonVal",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:singletonVal\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:singletonVal\"]"
        },
        "index": {
          "description": "If has exactly one value constraint returns it",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "singletonVal",
          "normalized": "GeniVal-\u003eMaybe Text",
          "package": "GenI",
          "partial": "Val",
          "signature": "GeniVal-\u003eMaybe Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:singletonVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esubsumeOne\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ex y\u003c/code\u003e returns the same result as \u003ccode\u003eunifyOne x y\u003c/code\u003e if \u003ccode\u003ex\u003c/code\u003e\n   subsumes \u003ccode\u003ey\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eFailure\u003c/a\u003e\u003c/code\u003e otherwise\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "subsumeOne",
          "package": "GenI",
          "signature": "GeniVal -\u003e GeniVal -\u003e UnificationResult",
          "source": "src/NLP-GenI-GeniVal-Internal.html#subsumeOne",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:subsumeOne\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:subsumeOne\"]"
        },
        "index": {
          "description": "subsumeOne returns the same result as unifyOne if subsumes or Failure otherwise",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "subsumeOne",
          "normalized": "GeniVal-\u003eGeniVal-\u003eUnificationResult",
          "package": "GenI",
          "partial": "One",
          "signature": "GeniVal-\u003eGeniVal-\u003eUnificationResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:subsumeOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunify\u003c/a\u003e\u003c/code\u003e performs unification on two lists of \u003ccode\u003e\u003ca\u003eGeniVal\u003c/a\u003e\u003c/code\u003e.  If\n   unification succeeds, it returns \u003ccode\u003eJust (r,s)\u003c/code\u003e where \u003ccode\u003er\u003c/code\u003e is\n   the result of unification and verb!s! is a list of substitutions that\n   this unification results in.\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.GeniVal.Internal\",\"NLP.GenI.GeniVal\"]",
          "name": "unify",
          "package": "GenI",
          "signature": "[GeniVal] -\u003e [GeniVal] -\u003e m ([GeniVal], Subst)",
          "source": "src/NLP-GenI-GeniVal-Internal.html#unify",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:unify\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:unify\"]"
        },
        "index": {
          "description": "unify performs unification on two lists of GeniVal If unification succeeds it returns Just where is the result of unification and verb is list of substitutions that this unification results in",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "unify",
          "normalized": "[GeniVal]-\u003e[GeniVal]-\u003ea([GeniVal],Subst)",
          "package": "GenI",
          "signature": "[GeniVal]-\u003e[GeniVal]-\u003em([GeniVal],Subst)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:unify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eunifyHelper unf gs1 gs2\u003c/code\u003e zips two lists with some unification function.\n\u003c/p\u003e\u003cp\u003eIt's meant to serve as a helper to \u003ccode\u003e\u003ca\u003eunify\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eallSubsume\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "unifyHelper",
          "package": "GenI",
          "signature": "(GeniVal -\u003e GeniVal -\u003e UnificationResult) -\u003e [GeniVal] -\u003e [GeniVal] -\u003e m ([GeniVal], Subst)",
          "source": "src/NLP-GenI-GeniVal-Internal.html#unifyHelper",
          "type": "function"
        },
        "index": {
          "description": "unifyHelper unf gs1 gs2 zips two lists with some unification function It meant to serve as helper to unify and allSubsume",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "unifyHelper",
          "normalized": "(GeniVal-\u003eGeniVal-\u003eUnificationResult)-\u003e[GeniVal]-\u003e[GeniVal]-\u003ea([GeniVal],Subst)",
          "package": "GenI",
          "partial": "Helper",
          "signature": "(GeniVal-\u003eGeniVal-\u003eUnificationResult)-\u003e[GeniVal]-\u003e[GeniVal]-\u003em([GeniVal],Subst)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:unifyHelper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSee source code for details\n\u003c/p\u003e\u003cp\u003eNote that we assume that it's acceptable to generate new\n   variable names by appending an \u003ccode\u003ex\u003c/code\u003e to them; this assumption\n   is only safe if the variables have gone through the function\n   \u003ccode\u003e\u003ca\u003efinaliseVarsById\u003c/a\u003e\u003c/code\u003e or have been pre-processed and rewritten\n   with some kind of common suffix to avoid an accidental match\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "unifyOne",
          "package": "GenI",
          "signature": "GeniVal -\u003e GeniVal -\u003e UnificationResult",
          "source": "src/NLP-GenI-GeniVal-Internal.html#unifyOne",
          "type": "function"
        },
        "index": {
          "description": "See source code for details Note that we assume that it acceptable to generate new variable names by appending an to them this assumption is only safe if the variables have gone through the function finaliseVarsById or have been pre-processed and rewritten with some kind of common suffix to avoid an accidental match",
          "hierarchy": "NLP GenI GeniVal Internal",
          "module": "NLP.GenI.GeniVal.Internal",
          "name": "unifyOne",
          "normalized": "GeniVal-\u003eGeniVal-\u003eUnificationResult",
          "package": "GenI",
          "partial": "One",
          "signature": "GeniVal-\u003eGeniVal-\u003eUnificationResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal-Internal.html#v:unifyOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGenI values (variables, constants)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.GeniVal",
          "name": "GeniVal",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal.html",
          "type": "module"
        },
        "index": {
          "description": "GenI values variables constants",
          "hierarchy": "NLP GenI GeniVal",
          "module": "NLP.GenI.GeniVal",
          "name": "GeniVal",
          "package": "GenI",
          "partial": "Geni Val",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eCollectable\u003c/a\u003e\u003c/code\u003e is something which can return its variables as a\n   map from the variable to the number of times that variable occurs\n   in it.\n\u003c/p\u003e\u003cp\u003eImportant invariant: if the variable does not occur, then it does\n   not appear in the map (ie. all counts must be \u003e= 1 or the item\n   does not occur at all)\n\u003c/p\u003e\u003cp\u003eBy variables, what I most had in mind was the GVar values in a\n   GeniVal.  This notion is probably not very useful outside the context of\n   alpha-conversion task, but it seems general enough that I'll keep it\n   around for a good bit, until either some use for it creeps up, or I find\n   a more general notion that I can transform this into.\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal",
          "name": "Collectable",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#Collectable",
          "type": "class"
        },
        "index": {
          "description": "Collectable is something which can return its variables as map from the variable to the number of times that variable occurs in it Important invariant if the variable does not occur then it does not appear in the map ie all counts must be or the item does not occur at all By variables what most had in mind was the GVar values in GeniVal This notion is probably not very useful outside the context of alpha-conversion task but it seems general enough that ll keep it around for good bit until either some use for it creeps up or find more general notion that can transform this into",
          "hierarchy": "NLP GenI GeniVal",
          "module": "NLP.GenI.GeniVal",
          "name": "Collectable",
          "package": "GenI",
          "partial": "Collectable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#t:Collectable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA structure that can be traversed with a \u003ccode\u003e\u003ca\u003eGeniVal\u003c/a\u003e\u003c/code\u003e-replacing\n   function (typical use case: substitution after unification)\n\u003c/p\u003e\u003cp\u003eApproach suggested by Neil Mitchell after I found that Uniplate\n   seemed to hurt GenI performance a bit.\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal",
          "name": "DescendGeniVal",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#DescendGeniVal",
          "type": "class"
        },
        "index": {
          "description": "structure that can be traversed with GeniVal replacing function typical use case substitution after unification Approach suggested by Neil Mitchell after found that Uniplate seemed to hurt GenI performance bit",
          "hierarchy": "NLP GenI GeniVal",
          "module": "NLP.GenI.GeniVal",
          "name": "DescendGeniVal",
          "package": "GenI",
          "partial": "Descend Geni Val",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#t:DescendGeniVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e constant : no label, just constraints\n\u003c/li\u003e\u003cli\u003e variable : label, with or without constraints\n\u003c/li\u003e\u003cli\u003e anonymous : no label, no constraints\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "NLP.GenI.GeniVal",
          "name": "GeniVal",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#GeniVal",
          "type": "data"
        },
        "index": {
          "description": "constant no label just constraints variable label with or without constraints anonymous no label no constraints",
          "hierarchy": "NLP GenI GeniVal",
          "module": "NLP.GenI.GeniVal",
          "name": "GeniVal",
          "package": "GenI",
          "partial": "Geni Val",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#t:GeniVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn Idable is something that can be mapped to a unique id.\n   You might consider using this to implement Ord, but I won't.\n   Note that the only use I have for this so far (20 dec 2005)\n  is in alpha-conversion.\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal",
          "name": "Idable",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#Idable",
          "type": "class"
        },
        "index": {
          "description": "An Idable is something that can be mapped to unique id You might consider using this to implement Ord but won Note that the only use have for this so far dec is in alpha-conversion",
          "hierarchy": "NLP GenI GeniVal",
          "module": "NLP.GenI.GeniVal",
          "name": "Idable",
          "package": "GenI",
          "partial": "Idable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#t:Idable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.GeniVal",
          "name": "MonadUnify",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#MonadUnify",
          "type": "class"
        },
        "index": {
          "hierarchy": "NLP GenI GeniVal",
          "module": "NLP.GenI.GeniVal",
          "name": "MonadUnify",
          "package": "GenI",
          "partial": "Monad Unify",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#t:MonadUnify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA schema value is a disjunction of GenI values.  It allows us to express\n   &#8220;fancy&#8221; disjunctions in tree schemata, ie. disjunctions over variables\n   and not just atoms (\u003ccode\u003e?X;?Y\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eOur rule is that that when a tree schema is instantiated, any fancy\n   disjunctions must be &#8220;crushed&#8221; into a single \u003ccode\u003e\u003ca\u003eGeniVal\u003c/a\u003e\u003c/code\u003e lest it be\n   rejected (see \u003ccode\u003e\u003ca\u003ecrushOne\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e\u003cp\u003eNote that this is still not recursive; we don't have disjunction over\n   schema values, nor can schema values refer to schema values.  It just\n   allows us to express the idea that in tree schemata, you can have\n   either variable \u003ccode\u003e?X\u003c/code\u003e or \u003ccode\u003e?Y\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal",
          "name": "SchemaVal",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#SchemaVal",
          "type": "newtype"
        },
        "index": {
          "description": "schema value is disjunction of GenI values It allows us to express fancy disjunctions in tree schemata ie disjunctions over variables and not just atoms Our rule is that that when tree schema is instantiated any fancy disjunctions must be crushed into single GeniVal lest it be rejected see crushOne Note that this is still not recursive we don have disjunction over schema values nor can schema values refer to schema values It just allows us to express the idea that in tree schemata you can have either variable or",
          "hierarchy": "NLP GenI GeniVal",
          "module": "NLP.GenI.GeniVal",
          "name": "SchemaVal",
          "package": "GenI",
          "partial": "Schema Val",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#t:SchemaVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variable substitution map.\n   GenI unification works by rewriting variables\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal",
          "name": "Subst",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#Subst",
          "type": "type"
        },
        "index": {
          "description": "variable substitution map GenI unification works by rewriting variables",
          "hierarchy": "NLP GenI GeniVal",
          "module": "NLP.GenI.GeniVal",
          "name": "Subst",
          "package": "GenI",
          "partial": "Subst",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#t:Subst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnification can either&#8230;\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal",
          "name": "UnificationResult",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#UnificationResult",
          "type": "data"
        },
        "index": {
          "description": "Unification can either",
          "hierarchy": "NLP GenI GeniVal",
          "module": "NLP.GenI.GeniVal",
          "name": "UnificationResult",
          "package": "GenI",
          "partial": "Unification Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#t:UnificationResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecollect x m\u003c/code\u003e increments our count for any variables in \u003ccode\u003ex\u003c/code\u003e\n   (adds not-yet-seen variables as needed)\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal",
          "name": "collect",
          "package": "GenI",
          "signature": "a -\u003e Map CollectedVar Int -\u003e Map CollectedVar Int",
          "source": "src/NLP-GenI-GeniVal-Internal.html#collect",
          "type": "method"
        },
        "index": {
          "description": "collect increments our count for any variables in adds not-yet-seen variables as needed",
          "hierarchy": "NLP GenI GeniVal",
          "module": "NLP.GenI.GeniVal",
          "name": "collect",
          "normalized": "a-\u003eMap CollectedVar Int-\u003eMap CollectedVar Int",
          "package": "GenI",
          "signature": "a-\u003eMap CollectedVar Int-\u003eMap CollectedVar Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:collect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edescendGeniVal f x\u003c/code\u003e applies \u003ccode\u003ef\u003c/code\u003e to all \u003ccode\u003e\u003ca\u003eGeniVal\u003c/a\u003e\u003c/code\u003e in \u003ccode\u003ex\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal",
          "name": "descendGeniVal",
          "package": "GenI",
          "signature": "(GeniVal -\u003e GeniVal) -\u003e a -\u003e a",
          "source": "src/NLP-GenI-GeniVal-Internal.html#descendGeniVal",
          "type": "method"
        },
        "index": {
          "description": "descendGeniVal applies to all GeniVal in",
          "hierarchy": "NLP GenI GeniVal",
          "module": "NLP.GenI.GeniVal",
          "name": "descendGeniVal",
          "normalized": "(GeniVal-\u003eGeniVal)-\u003ea-\u003ea",
          "package": "GenI",
          "partial": "Geni Val",
          "signature": "(GeniVal-\u003eGeniVal)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:descendGeniVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptional values/constraints\n   Must have at least one if at all\n\u003c/p\u003e\u003cp\u003eThough it may seem a bit redudant, this is not quite the same\n   as having '[Text]' because \u003ccode\u003eNothing\u003c/code\u003e means no constraints;\n   whereas \u003ccode\u003eJust []\u003c/code\u003e (impossible here) would mean bottom.\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal",
          "name": "gConstraints",
          "package": "GenI",
          "signature": "GeniVal -\u003e Maybe (FullList Text)",
          "source": "src/NLP-GenI-GeniVal-Internal.html#gConstraints",
          "type": "function"
        },
        "index": {
          "description": "Optional values constraints Must have at least one if at all Though it may seem bit redudant this is not quite the same as having Text because Nothing means no constraints whereas Just impossible here would mean bottom",
          "hierarchy": "NLP GenI GeniVal",
          "module": "NLP.GenI.GeniVal",
          "name": "gConstraints",
          "normalized": "GeniVal-\u003eMaybe(FullList Text)",
          "package": "GenI",
          "partial": "Constraints",
          "signature": "GeniVal-\u003eMaybe(FullList Text)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:gConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptional label (\u003ccode\u003e?X\u003c/code\u003e would have \u003ccode\u003eJust \u003ca\u003eX\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "NLP.GenI.GeniVal",
          "name": "gLabel",
          "package": "GenI",
          "signature": "GeniVal -\u003e Maybe Text",
          "source": "src/NLP-GenI-GeniVal-Internal.html#gLabel",
          "type": "function"
        },
        "index": {
          "description": "Optional label would have Just",
          "hierarchy": "NLP GenI GeniVal",
          "module": "NLP.GenI.GeniVal",
          "name": "gLabel",
          "normalized": "GeniVal-\u003eMaybe Text",
          "package": "GenI",
          "partial": "Label",
          "signature": "GeniVal-\u003eMaybe Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:gLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.GeniVal",
          "name": "idOf",
          "package": "GenI",
          "signature": "idOf",
          "source": "src/NLP-GenI-GeniVal-Internal.html#idOf",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI GeniVal",
          "module": "NLP.GenI.GeniVal",
          "name": "idOf",
          "package": "GenI",
          "partial": "Of",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-GeniVal.html#v:idOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "Types",
          "package": "GenI",
          "source": "src/NLP-GenI-LexicalSelection-Types.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "Types",
          "package": "GenI",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "LexCombineError",
          "package": "GenI",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#LexCombineError",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "LexCombineError",
          "package": "GenI",
          "partial": "Lex Combine Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#t:LexCombineError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "LexCombineError2",
          "package": "GenI",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#LexCombineError2",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "LexCombineError2",
          "package": "GenI",
          "partial": "Lex Combine Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#t:LexCombineError2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePath equations can either hit a feature or a node's lexeme attribute\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "NodePathEqLhs",
          "package": "GenI",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#NodePathEqLhs",
          "type": "data"
        },
        "index": {
          "description": "Path equations can either hit feature or node lexeme attribute",
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "NodePathEqLhs",
          "package": "GenI",
          "partial": "Node Path Eq Lhs",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#t:NodePathEqLhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft hand side of a path equation\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "PathEqLhs",
          "package": "GenI",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#PathEqLhs",
          "type": "data"
        },
        "index": {
          "description": "Left hand side of path equation",
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "PathEqLhs",
          "package": "GenI",
          "partial": "Path Eq Lhs",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#t:PathEqLhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "PathEqPair",
          "package": "GenI",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#PathEqPair",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "PathEqPair",
          "package": "GenI",
          "partial": "Path Eq Pair",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#t:PathEqPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "TopBottom",
          "package": "GenI",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#TopBottom",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "TopBottom",
          "package": "GenI",
          "partial": "Top Bottom",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#t:TopBottom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "BoringError",
          "package": "GenI",
          "signature": "BoringError Text",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#LexCombineError",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "BoringError",
          "package": "GenI",
          "partial": "Boring Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:BoringError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "Bottom",
          "package": "GenI",
          "signature": "Bottom",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#TopBottom",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "Bottom",
          "package": "GenI",
          "partial": "Bottom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:Bottom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "EnrichError",
          "package": "GenI",
          "signature": "EnrichError PathEqLhs",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#LexCombineError2",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "EnrichError",
          "package": "GenI",
          "partial": "Enrich Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:EnrichError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "FamilyNotFoundError",
          "package": "GenI",
          "signature": "FamilyNotFoundError Text",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#LexCombineError",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "FamilyNotFoundError",
          "package": "GenI",
          "partial": "Family Not Found Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:FamilyNotFoundError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "PeqFeat",
          "package": "GenI",
          "signature": "PeqFeat Text TopBottom Text",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#NodePathEqLhs",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "PeqFeat",
          "package": "GenI",
          "partial": "Peq Feat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:PeqFeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "PeqInterface",
          "package": "GenI",
          "signature": "PeqInterface Text",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#PathEqLhs",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "PeqInterface",
          "package": "GenI",
          "partial": "Peq Interface",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:PeqInterface"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "PeqJust",
          "package": "GenI",
          "signature": "PeqJust NodePathEqLhs",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#PathEqLhs",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "PeqJust",
          "package": "GenI",
          "partial": "Peq Just",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:PeqJust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "PeqLex",
          "package": "GenI",
          "signature": "PeqLex Text",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#NodePathEqLhs",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "PeqLex",
          "package": "GenI",
          "partial": "Peq Lex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:PeqLex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "PeqUnknown",
          "package": "GenI",
          "signature": "PeqUnknown Text",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#PathEqLhs",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "PeqUnknown",
          "package": "GenI",
          "partial": "Peq Unknown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:PeqUnknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "SchemaError",
          "package": "GenI",
          "signature": "SchemaError [Text] LexCombineError2",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#LexCombineError",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "SchemaError",
          "normalized": "SchemaError[Text]LexCombineError",
          "package": "GenI",
          "partial": "Schema Error",
          "signature": "SchemaError[Text]LexCombineError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:SchemaError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "StringError",
          "package": "GenI",
          "signature": "StringError Text",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#LexCombineError2",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "StringError",
          "package": "GenI",
          "partial": "String Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:StringError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "Top",
          "package": "GenI",
          "signature": "Top",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#TopBottom",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "Top",
          "package": "GenI",
          "partial": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:Top"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "compressLexCombineErrors",
          "package": "GenI",
          "signature": "[LexCombineError] -\u003e [LexCombineError]",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#compressLexCombineErrors",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "compressLexCombineErrors",
          "normalized": "[LexCombineError]-\u003e[LexCombineError]",
          "package": "GenI",
          "partial": "Lex Combine Errors",
          "signature": "[LexCombineError]-\u003e[LexCombineError]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:compressLexCombineErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a path equation using the GenI conventions\n   This always succeeds, but can return \u003ccode\u003eJust warning\u003c/code\u003e\n   if anything anomalous comes up\n   FIXME : make more efficient\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "parsePathEq",
          "package": "GenI",
          "signature": "Text -\u003e Writer [LexCombineError] PathEqLhs",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#parsePathEq",
          "type": "function"
        },
        "index": {
          "description": "Parse path equation using the GenI conventions This always succeeds but can return Just warning if anything anomalous comes up FIXME make more efficient",
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "parsePathEq",
          "normalized": "Text-\u003eWriter[LexCombineError]PathEqLhs",
          "package": "GenI",
          "partial": "Path Eq",
          "signature": "Text-\u003eWriter[LexCombineError]PathEqLhs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:parsePathEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "showLexCombineError",
          "package": "GenI",
          "signature": "LexCombineError -\u003e (Text, Text)",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#showLexCombineError",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "showLexCombineError",
          "normalized": "LexCombineError-\u003e(Text,Text)",
          "package": "GenI",
          "partial": "Lex Combine Error",
          "signature": "LexCombineError-\u003e(Text,Text)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:showLexCombineError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "showPathEqLhs",
          "package": "GenI",
          "signature": "PathEqLhs -\u003e Text",
          "source": "src/NLP-GenI-LexicalSelection-Types.html#showPathEqLhs",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection Types",
          "module": "NLP.GenI.LexicalSelection.Types",
          "name": "showPathEqLhs",
          "normalized": "PathEqLhs-\u003eText",
          "package": "GenI",
          "partial": "Path Eq Lhs",
          "signature": "PathEqLhs-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection-Types.html#v:showPathEqLhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module performs the core of lexical selection and anchoring.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "LexicalSelection",
          "package": "GenI",
          "source": "src/NLP-GenI-LexicalSelection.html",
          "type": "module"
        },
        "index": {
          "description": "This module performs the core of lexical selection and anchoring",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "LexicalSelection",
          "package": "GenI",
          "partial": "Lexical Selection",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis aims to support users who want to do lexical selection\n   directly from an input other than GenI style flat semantics.\n\u003c/p\u003e\u003cp\u003eThe requirement here is for you to provide some means of\n   converting the custom semantics to a GenI semantics\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "CustomSem",
          "package": "GenI",
          "source": "src/NLP-GenI-LexicalSelection.html#CustomSem",
          "type": "data"
        },
        "index": {
          "description": "This aims to support users who want to do lexical selection directly from an input other than GenI style flat semantics The requirement here is for you to provide some means of converting the custom semantics to GenI semantics",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "CustomSem",
          "package": "GenI",
          "partial": "Custom Sem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#t:CustomSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection",
          "name": "EnrichmentResult",
          "package": "GenI",
          "source": "src/NLP-GenI-LexicalSelection.html#EnrichmentResult",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "EnrichmentResult",
          "package": "GenI",
          "partial": "Enrichment Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#t:EnrichmentResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eLexCombine\u003c/a\u003e\u003c/code\u003e monad supports warnings during lexical selection\n   and also failure via Maybe\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "LexCombine",
          "package": "GenI",
          "source": "src/NLP-GenI-LexicalSelection.html#LexCombine",
          "type": "type"
        },
        "index": {
          "description": "The LexCombine monad supports warnings during lexical selection and also failure via Maybe",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "LexCombine",
          "package": "GenI",
          "partial": "Lex Combine",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#t:LexCombine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe result of the lexical selection process\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "LexicalSelection",
          "package": "GenI",
          "source": "src/NLP-GenI-LexicalSelection.html#LexicalSelection",
          "type": "data"
        },
        "index": {
          "description": "The result of the lexical selection process",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "LexicalSelection",
          "package": "GenI",
          "partial": "Lexical Selection",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#t:LexicalSelection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSee \u003ccode\u003e\u003ca\u003eConfiguration\u003c/a\u003e\u003c/code\u003e if you want to use GenI with a custom\n   lexical selection function.\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "LexicalSelector",
          "package": "GenI",
          "source": "src/NLP-GenI-LexicalSelection.html#LexicalSelector",
          "type": "type"
        },
        "index": {
          "description": "See Configuration if you want to use GenI with custom lexical selection function",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "LexicalSelector",
          "package": "GenI",
          "partial": "Lexical Selector",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#t:LexicalSelector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection",
          "name": "CustomSem",
          "package": "GenI",
          "signature": "CustomSem",
          "source": "src/NLP-GenI-LexicalSelection.html#CustomSem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "CustomSem",
          "package": "GenI",
          "partial": "Custom Sem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:CustomSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection",
          "name": "EnrFailed",
          "package": "GenI",
          "signature": "EnrFailed",
          "source": "src/NLP-GenI-LexicalSelection.html#EnrichmentResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "EnrFailed",
          "package": "GenI",
          "partial": "Enr Failed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:EnrFailed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection",
          "name": "EnrNotFound",
          "package": "GenI",
          "signature": "EnrNotFound",
          "source": "src/NLP-GenI-LexicalSelection.html#EnrichmentResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "EnrNotFound",
          "package": "GenI",
          "partial": "Enr Not Found",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:EnrNotFound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection",
          "name": "EnrSuccess",
          "package": "GenI",
          "signature": "EnrSuccess SchemaTree Subst",
          "source": "src/NLP-GenI-LexicalSelection.html#EnrichmentResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "EnrSuccess",
          "package": "GenI",
          "partial": "Enr Success",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:EnrSuccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection",
          "name": "LexicalSelection",
          "package": "GenI",
          "signature": "LexicalSelection",
          "source": "src/NLP-GenI-LexicalSelection.html#LexicalSelection",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "LexicalSelection",
          "package": "GenI",
          "partial": "Lexical Selection",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:LexicalSelection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of the lemanchor attribute (by convention; see source)\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "_lemanchor",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-LexicalSelection.html#_lemanchor",
          "type": "function"
        },
        "index": {
          "description": "The name of the lemanchor attribute by convention see source",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "_lemanchor",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:_lemanchor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003echooseCandI\u003c/a\u003e\u003c/code\u003e \u003ccode\u003esem l\u003c/code\u003e attempts to unify the semantics of \u003ccode\u003el\u003c/code\u003e with \u003ccode\u003esem\u003c/code\u003e\n   If this succeeds, we use return the result(s); if it fails, we reject\n   \u003ccode\u003el\u003c/code\u003e as a lexical selection candidate.\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "chooseCandI",
          "package": "GenI",
          "signature": "Sem -\u003e [LexEntry] -\u003e [LexEntry]",
          "source": "src/NLP-GenI-LexicalSelection.html#chooseCandI",
          "type": "function"
        },
        "index": {
          "description": "chooseCandI sem attempts to unify the semantics of with sem If this succeeds we use return the result if it fails we reject as lexical selection candidate",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "chooseCandI",
          "normalized": "Sem-\u003e[LexEntry]-\u003e[LexEntry]",
          "package": "GenI",
          "partial": "Cand",
          "signature": "Sem-\u003e[LexEntry]-\u003e[LexEntry]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:chooseCandI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a lexical item, looks up the tree families for that item, and\n   anchor the item to the trees.\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "combineList",
          "package": "GenI",
          "signature": "Sem-\u003e Macros-\u003e LexEntry-\u003e ([LexCombineError], [TagElem])",
          "type": "function"
        },
        "index": {
          "description": "Given lexical item looks up the tree families for that item and anchor the item to the trees",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "combineList",
          "normalized": "Sem-\u003eMacros-\u003eLexEntry-\u003e([LexCombineError],[TagElem])",
          "package": "GenI",
          "partial": "List",
          "signature": "Sem-\u003eMacros-\u003eLexEntry-\u003e([LexCombineError],[TagElem])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:combineList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine a single tree with its lexical item to form a bonafide TagElem.\n   This process can fail, however, because of filtering or enrichement\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "combineOne",
          "package": "GenI",
          "signature": "Sem -\u003e LexEntry -\u003e SchemaTree -\u003e LexCombine [TagElem]",
          "source": "src/NLP-GenI-LexicalSelection.html#combineOne",
          "type": "function"
        },
        "index": {
          "description": "Combine single tree with its lexical item to form bonafide TagElem This process can fail however because of filtering or enrichement",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "combineOne",
          "normalized": "Sem-\u003eLexEntry-\u003eSchemaTree-\u003eLexCombine[TagElem]",
          "package": "GenI",
          "partial": "One",
          "signature": "Sem-\u003eLexEntry-\u003eSchemaTree-\u003eLexCombine[TagElem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:combineOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection",
          "name": "customRenderSem",
          "package": "GenI",
          "signature": "sem -\u003e Text",
          "source": "src/NLP-GenI-LexicalSelection.html#CustomSem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "customRenderSem",
          "normalized": "a-\u003eText",
          "package": "GenI",
          "partial": "Render Sem",
          "signature": "sem-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:customRenderSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLexical selection function\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "customSelector",
          "package": "GenI",
          "signature": "LexicalSelector sem",
          "source": "src/NLP-GenI-LexicalSelection.html#CustomSem",
          "type": "function"
        },
        "index": {
          "description": "Lexical selection function",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "customSelector",
          "package": "GenI",
          "partial": "Selector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:customSelector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection",
          "name": "customSemParser",
          "package": "GenI",
          "signature": "Text -\u003e Either Text (TestCase sem)",
          "source": "src/NLP-GenI-LexicalSelection.html#CustomSem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "customSemParser",
          "normalized": "Text-\u003eEither Text(TestCase a)",
          "package": "GenI",
          "partial": "Sem Parser",
          "signature": "Text-\u003eEither Text(TestCase sem)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:customSemParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of named inputs intended to act as a substitute for\n   test suites\n   (\u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e argument is for reporting error messages only)\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "customSuiteParser",
          "package": "GenI",
          "signature": "FilePath -\u003e Text -\u003e Either Text [TestCase sem]",
          "source": "src/NLP-GenI-LexicalSelection.html#CustomSem",
          "type": "function"
        },
        "index": {
          "description": "List of named inputs intended to act as substitute for test suites FilePath argument is for reporting error messages only",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "customSuiteParser",
          "normalized": "FilePath-\u003eText-\u003eEither Text[TestCase a]",
          "package": "GenI",
          "partial": "Suite Parser",
          "signature": "FilePath-\u003eText-\u003eEither Text[TestCase sem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:customSuiteParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edefaultAnchoring schemata lex sem\u003c/code\u003e  implements the later half of lexical\n   selection (tree anchoring and enrichement).  It assumes that \u003ccode\u003elex\u003c/code\u003e consists\n   just of the lexical items that have been selected, and tries to combine them\n   with the tree schemata.\n\u003c/p\u003e\u003cp\u003eThis function may be useful if you are implementing your own lexical selection\n   functions, and you want GenI to take over after you've given it a \u003ccode\u003e[LexEntry]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "defaultAnchoring",
          "package": "GenI",
          "signature": "SemInput -\u003e Macros -\u003e [LexEntry] -\u003e LexicalSelection",
          "source": "src/NLP-GenI-LexicalSelection.html#defaultAnchoring",
          "type": "function"
        },
        "index": {
          "description": "defaultAnchoring schemata lex sem implements the later half of lexical selection tree anchoring and enrichement It assumes that lex consists just of the lexical items that have been selected and tries to combine them with the tree schemata This function may be useful if you are implementing your own lexical selection functions and you want GenI to take over after you ve given it LexEntry",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "defaultAnchoring",
          "normalized": "SemInput-\u003eMacros-\u003e[LexEntry]-\u003eLexicalSelection",
          "package": "GenI",
          "partial": "Anchoring",
          "signature": "SemInput-\u003eMacros-\u003e[LexEntry]-\u003eLexicalSelection",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:defaultAnchoring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect and returns the set of entries from the lexicon whose semantics\n   subsumes the input semantics.\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "defaultLexicalChoice",
          "package": "GenI",
          "signature": "Lexicon -\u003e SemInput -\u003e [LexEntry]",
          "source": "src/NLP-GenI-LexicalSelection.html#defaultLexicalChoice",
          "type": "function"
        },
        "index": {
          "description": "Select and returns the set of entries from the lexicon whose semantics subsumes the input semantics",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "defaultLexicalChoice",
          "normalized": "Lexicon-\u003eSemInput-\u003e[LexEntry]",
          "package": "GenI",
          "partial": "Lexical Choice",
          "signature": "Lexicon-\u003eSemInput-\u003e[LexEntry]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:defaultLexicalChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper for \u003ccode\u003e\u003ca\u003edefaultLexicalSelector\u003c/a\u003e\u003c/code\u003e\n   (Standard GenI lexical selection is actually pure)\n\u003c/p\u003e\u003cp\u003eThis is just\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003edefaultLexicalChoice\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003edefaultAnchoring\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003edefaultPostProcessing\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "defaultLexicalSelection",
          "package": "GenI",
          "signature": "Macros -\u003e Lexicon -\u003e SemInput -\u003e LexicalSelection",
          "source": "src/NLP-GenI-LexicalSelection.html#defaultLexicalSelection",
          "type": "function"
        },
        "index": {
          "description": "Helper for defaultLexicalSelector Standard GenI lexical selection is actually pure This is just defaultLexicalChoice defaultAnchoring defaultPostProcessing",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "defaultLexicalSelection",
          "normalized": "Macros-\u003eLexicon-\u003eSemInput-\u003eLexicalSelection",
          "package": "GenI",
          "partial": "Lexical Selection",
          "signature": "Macros-\u003eLexicon-\u003eSemInput-\u003eLexicalSelection",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:defaultLexicalSelection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerforms standard GenI lexical selection as described in\n   \u003ca\u003ehttp://projects.haskell.org/GenI/manual/lexical-selection.html\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThis is just \u003ccode\u003e\u003ca\u003edefaultLexicalSelection\u003c/a\u003e\u003c/code\u003e lifted into IO\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "defaultLexicalSelector",
          "package": "GenI",
          "signature": "Macros -\u003e Lexicon -\u003e SemInput -\u003e IO LexicalSelection",
          "source": "src/NLP-GenI-LexicalSelection.html#defaultLexicalSelector",
          "type": "function"
        },
        "index": {
          "description": "Performs standard GenI lexical selection as described in http projects.haskell.org GenI manual lexical-selection.html This is just defaultLexicalSelection lifted into IO",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "defaultLexicalSelector",
          "normalized": "Macros-\u003eLexicon-\u003eSemInput-\u003eIO LexicalSelection",
          "package": "GenI",
          "partial": "Lexical Selector",
          "signature": "Macros-\u003eLexicon-\u003eSemInput-\u003eIO LexicalSelection",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:defaultLexicalSelector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard post-processing/filtering steps that can take place\n   after lexical selection.  Right now, this only consists of\n   paraphrase selection\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "defaultPostProcessing",
          "package": "GenI",
          "signature": "SemInput -\u003e LexicalSelection -\u003e LexicalSelection",
          "source": "src/NLP-GenI-LexicalSelection.html#defaultPostProcessing",
          "type": "function"
        },
        "index": {
          "description": "Standard post-processing filtering steps that can take place after lexical selection Right now this only consists of paraphrase selection",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "defaultPostProcessing",
          "normalized": "SemInput-\u003eLexicalSelection-\u003eLexicalSelection",
          "package": "GenI",
          "partial": "Post Processing",
          "signature": "SemInput-\u003eLexicalSelection-\u003eLexicalSelection",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:defaultPostProcessing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSee \u003ca\u003ehttp://kowey.github.io/GenI/manual/lexical-selection.html\u003c/a\u003e\n   on enrichement\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "enrich",
          "package": "GenI",
          "signature": "LexEntry -\u003e SchemaTree -\u003e LexCombine SchemaTree",
          "source": "src/NLP-GenI-LexicalSelection.html#enrich",
          "type": "function"
        },
        "index": {
          "description": "See http kowey.github.io GenI manual lexical-selection.html on enrichement",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "enrich",
          "normalized": "LexEntry-\u003eSchemaTree-\u003eLexCombine SchemaTree",
          "package": "GenI",
          "signature": "LexEntry-\u003eSchemaTree-\u003eLexCombine SchemaTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:enrich"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper for \u003ccode\u003e\u003ca\u003eenrich\u003c/a\u003e\u003c/code\u003e (enrich by single path equation)\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "enrichBy",
          "package": "GenI",
          "signature": "SchemaTree -\u003e PathEqPair -\u003e LexCombine SchemaTree",
          "source": "src/NLP-GenI-LexicalSelection.html#enrichBy",
          "type": "function"
        },
        "index": {
          "description": "Helper for enrich enrich by single path equation",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "enrichBy",
          "normalized": "SchemaTree-\u003ePathEqPair-\u003eLexCombine SchemaTree",
          "package": "GenI",
          "partial": "By",
          "signature": "SchemaTree-\u003ePathEqPair-\u003eLexCombine SchemaTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:enrichBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eenrichFeat av fs\u003c/code\u003e attempts to unify \u003ccode\u003eav\u003c/code\u003e with \u003ccode\u003efs\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eNote here that \u003ccode\u003efs\u003c/code\u003e is an \u003ccode\u003eFlist [GeniVal]\u003c/code\u003e rather than the usual\n   \u003ccode\u003eFlist GeniVal\u003c/code\u003e you may expect.  This is because it comes from\n   \u003ccode\u003e\u003ca\u003eSchemaTree\u003c/a\u003e\u003c/code\u003e which allows non-atomic disjunctions of \u003ccode\u003eGeniVal\u003c/code\u003e\n   which have to be flatten down to at most atomic disjunctions once\n   lexical selection is complete.\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "enrichFeat",
          "package": "GenI",
          "signature": "AvPair GeniVal -\u003e Flist SchemaVal -\u003e m (Flist SchemaVal, Subst)",
          "source": "src/NLP-GenI-LexicalSelection.html#enrichFeat",
          "type": "function"
        },
        "index": {
          "description": "enrichFeat av fs attempts to unify av with fs Note here that fs is an Flist GeniVal rather than the usual Flist GeniVal you may expect This is because it comes from SchemaTree which allows non-atomic disjunctions of GeniVal which have to be flatten down to at most atomic disjunctions once lexical selection is complete",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "enrichFeat",
          "normalized": "AvPair GeniVal-\u003eFlist SchemaVal-\u003ea(Flist SchemaVal,Subst)",
          "package": "GenI",
          "partial": "Feat",
          "signature": "AvPair GeniVal-\u003eFlist SchemaVal-\u003em(Flist SchemaVal,Subst)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:enrichFeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion from custom semantics to GenI semantic input\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "fromCustomSemInput",
          "package": "GenI",
          "signature": "sem -\u003e Either Text SemInput",
          "source": "src/NLP-GenI-LexicalSelection.html#CustomSem",
          "type": "function"
        },
        "index": {
          "description": "Conversion from custom semantics to GenI semantic input",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "fromCustomSemInput",
          "normalized": "a-\u003eEither Text SemInput",
          "package": "GenI",
          "partial": "Custom Sem Input",
          "signature": "sem-\u003eEither Text SemInput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:fromCustomSemInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit a lex entry's path equations into interface enrichement equations\n   or (co-)anchor modifiers\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "lexEquations",
          "package": "GenI",
          "signature": "LexEntry -\u003e Writer [LexCombineError] ([AvPair GeniVal], [PathEqPair])",
          "source": "src/NLP-GenI-LexicalSelection.html#lexEquations",
          "type": "function"
        },
        "index": {
          "description": "Split lex entry path equations into interface enrichement equations or co anchor modifiers",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "lexEquations",
          "normalized": "LexEntry-\u003eWriter[LexCombineError]([AvPair GeniVal],[PathEqPair])",
          "package": "GenI",
          "partial": "Equations",
          "signature": "LexEntry-\u003eWriter[LexCombineError]([AvPair GeniVal],[PathEqPair])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:lexEquations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNote an anchoring error\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "lexTell",
          "package": "GenI",
          "signature": "LexCombineError -\u003e LexCombine ()",
          "source": "src/NLP-GenI-LexicalSelection.html#lexTell",
          "type": "function"
        },
        "index": {
          "description": "Note an anchoring error",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "lexTell",
          "normalized": "LexCombineError-\u003eLexCombine()",
          "package": "GenI",
          "partial": "Tell",
          "signature": "LexCombineError-\u003eLexCombine()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:lexTell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe main result: a set of elementary trees (ie. anchored trees)\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "lsAnchored",
          "package": "GenI",
          "signature": "[TagElem]",
          "source": "src/NLP-GenI-LexicalSelection.html#LexicalSelection",
          "type": "function"
        },
        "index": {
          "description": "the main result set of elementary trees ie anchored trees",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "lsAnchored",
          "normalized": "[TagElem]",
          "package": "GenI",
          "partial": "Anchored",
          "signature": "[TagElem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:lsAnchored"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eif available, lexical entries that were used to produce anchored\n   trees (useful for identifying anchoring failure)\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "lsLexEntries",
          "package": "GenI",
          "signature": "[LexEntry]",
          "source": "src/NLP-GenI-LexicalSelection.html#LexicalSelection",
          "type": "function"
        },
        "index": {
          "description": "if available lexical entries that were used to produce anchored trees useful for identifying anchoring failure",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "lsLexEntries",
          "normalized": "[LexEntry]",
          "package": "GenI",
          "partial": "Lex Entries",
          "signature": "[LexEntry]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:lsLexEntries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHINT: use \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e to initialise to empty\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "lsWarnings",
          "package": "GenI",
          "signature": "GeniWarnings",
          "source": "src/NLP-GenI-LexicalSelection.html#LexicalSelection",
          "type": "function"
        },
        "index": {
          "description": "HINT use mempty to initialise to empty",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "lsWarnings",
          "package": "GenI",
          "partial": "Warnings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:lsWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ematchNodeName lhs n\u003c/code\u003e is \u003ccode\u003eTrue\u003c/code\u003e if the \u003ccode\u003elhs\u003c/code\u003e refers to the node \u003ccode\u003en\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "matchNodeName",
          "package": "GenI",
          "signature": "NodePathEqLhs -\u003e GNode SchemaVal -\u003e Bool",
          "source": "src/NLP-GenI-LexicalSelection.html#matchNodeName",
          "type": "function"
        },
        "index": {
          "description": "matchNodeName lhs is True if the lhs refers to the node",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "matchNodeName",
          "normalized": "NodePathEqLhs-\u003eGNode SchemaVal-\u003eBool",
          "package": "GenI",
          "partial": "Node Name",
          "signature": "NodePathEqLhs-\u003eGNode SchemaVal-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:matchNodeName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ematchNodeNameHelper\u003c/code\u003e recognises &#8220;anchor&#8220; by convention; otherwise,\n   it does a name match\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "matchNodeNameHelper",
          "package": "GenI",
          "signature": "Text -\u003e GNode SchemaVal -\u003e Bool",
          "source": "src/NLP-GenI-LexicalSelection.html#matchNodeNameHelper",
          "type": "function"
        },
        "index": {
          "description": "matchNodeNameHelper recognises anchor by convention otherwise it does name match",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "matchNodeNameHelper",
          "normalized": "Text-\u003eGNode SchemaVal-\u003eBool",
          "package": "GenI",
          "partial": "Node Name Helper",
          "signature": "Text-\u003eGNode SchemaVal-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:matchNodeNameHelper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper for \u003ccode\u003e\u003ca\u003eenrichBy\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "maybeEnrichBy",
          "package": "GenI",
          "signature": "SchemaTree -\u003e PathEqPair -\u003e EnrichmentResult",
          "source": "src/NLP-GenI-LexicalSelection.html#maybeEnrichBy",
          "type": "function"
        },
        "index": {
          "description": "Helper for enrichBy",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "maybeEnrichBy",
          "normalized": "SchemaTree-\u003ePathEqPair-\u003eEnrichmentResult",
          "package": "GenI",
          "partial": "Enrich By",
          "signature": "SchemaTree-\u003ePathEqPair-\u003eEnrichmentResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:maybeEnrichBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emergeSynonyms\u003c/a\u003e\u003c/code\u003e is a factorisation technique that uses\n   atomic disjunction to merge all synonyms into a single lexical\n   entry.  Two lexical entries are considered synonyms if their\n   semantics match and they point to the same tree families.\n\u003c/p\u003e\u003cp\u003eFIXME: 2006-10-11 - note that this is no longer being used,\n  because it breaks the case where two lexical entries differ\n  only by their use of path equations.  Perhaps it's worthwhile\n  just to add a check that the path equations match exactly.\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "mergeSynonyms",
          "package": "GenI",
          "signature": "[LexEntry] -\u003e [LexEntry]",
          "source": "src/NLP-GenI-LexicalSelection.html#mergeSynonyms",
          "type": "function"
        },
        "index": {
          "description": "mergeSynonyms is factorisation technique that uses atomic disjunction to merge all synonyms into single lexical entry Two lexical entries are considered synonyms if their semantics match and they point to the same tree families FIXME note that this is no longer being used because it breaks the case where two lexical entries differ only by their use of path equations Perhaps it worthwhile just to add check that the path equations match exactly",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "mergeSynonyms",
          "normalized": "[LexEntry]-\u003e[LexEntry]",
          "package": "GenI",
          "partial": "Synonyms",
          "signature": "[LexEntry]-\u003e[LexEntry]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:mergeSynonyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emissingCoanchors l t\u003c/code\u003e returns the list of coanchor node names from \u003ccode\u003el\u003c/code\u003e\n   that were not found in \u003ccode\u003et\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "missingCoanchors",
          "package": "GenI",
          "signature": "LexEntry -\u003e SchemaTree -\u003e [Text]",
          "source": "src/NLP-GenI-LexicalSelection.html#missingCoanchors",
          "type": "function"
        },
        "index": {
          "description": "missingCoanchors returns the list of coanchor node names from that were not found in",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "missingCoanchors",
          "normalized": "LexEntry-\u003eSchemaTree-\u003e[Text]",
          "package": "GenI",
          "partial": "Coanchors",
          "signature": "LexEntry-\u003eSchemaTree-\u003e[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:missingCoanchors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emissingLexEntries ts lexs\u003c/code\u003e returns any of the lexical candidates\n   \u003ccode\u003elexs\u003c/code\u003e that were apparently not anchored succesfully.\n\u003c/p\u003e\u003cp\u003eTODO: it does this by (wrongly) checking for each lexical item\n   to see if any of the anchored trees in \u003ccode\u003ets\u003c/code\u003e have identical\n   semantics to that lexical item.  The better way to do this would\n   be to throw a subsumption check on top of items reported missing,\n   because it's possible for the trees to add semantics through\n   unification.\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "missingLexEntries",
          "package": "GenI",
          "signature": "[TagElem] -\u003e [LexEntry] -\u003e [LexEntry]",
          "source": "src/NLP-GenI-LexicalSelection.html#missingLexEntries",
          "type": "function"
        },
        "index": {
          "description": "missingLexEntries ts lexs returns any of the lexical candidates lexs that were apparently not anchored succesfully TODO it does this by wrongly checking for each lexical item to see if any of the anchored trees in ts have identical semantics to that lexical item The better way to do this would be to throw subsumption check on top of items reported missing because it possible for the trees to add semantics through unification",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "missingLexEntries",
          "normalized": "[TagElem]-\u003e[LexEntry]-\u003e[LexEntry]",
          "package": "GenI",
          "partial": "Lex Entries",
          "signature": "[TagElem]-\u003e[LexEntry]-\u003e[LexEntry]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:missingLexEntries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRule out lexical selection results that violate trace constraints\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "preselectParaphrases",
          "package": "GenI",
          "signature": "[LitConstr] -\u003e [TagElem] -\u003e [TagElem]",
          "source": "src/NLP-GenI-LexicalSelection.html#preselectParaphrases",
          "type": "function"
        },
        "index": {
          "description": "Rule out lexical selection results that violate trace constraints",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "preselectParaphrases",
          "normalized": "[LitConstr]-\u003e[TagElem]-\u003e[TagElem]",
          "package": "GenI",
          "partial": "Paraphrases",
          "signature": "[LitConstr]-\u003e[TagElem]-\u003e[TagElem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:preselectParaphrases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the tree fulfills the supplied trace constraints\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "respectsConstraints",
          "package": "GenI",
          "signature": "[LitConstr] -\u003e TagElem -\u003e Bool",
          "source": "src/NLP-GenI-LexicalSelection.html#respectsConstraints",
          "type": "function"
        },
        "index": {
          "description": "True if the tree fulfills the supplied trace constraints",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "respectsConstraints",
          "normalized": "[LitConstr]-\u003eTagElem-\u003eBool",
          "package": "GenI",
          "partial": "Constraints",
          "signature": "[LitConstr]-\u003eTagElem-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:respectsConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.LexicalSelection",
          "name": "runLexCombine",
          "package": "GenI",
          "signature": "LexCombine a -\u003e (Maybe a, [LexCombineError])",
          "source": "src/NLP-GenI-LexicalSelection.html#runLexCombine",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "runLexCombine",
          "normalized": "LexCombine a-\u003e(Maybe a,[LexCombineError])",
          "package": "GenI",
          "partial": "Lex Combine",
          "signature": "LexCombine a-\u003e(Maybe a,[LexCombineError])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:runLexCombine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eseekCoanchor lhs t\u003c/code\u003e returns \u003ccode\u003eJust node\u003c/code\u003e if \u003ccode\u003et\u003c/code\u003e contains exactly one\n   node that can be identified by \u003ccode\u003elhs\u003c/code\u003e, \u003ccode\u003eNothing\u003c/code\u003e if it contains none.\n\u003c/p\u003e\u003cp\u003eIt crashes if there is more than one such node, because this should\n   have been caught earlier by GenI.\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "seekCoanchor",
          "package": "GenI",
          "signature": "NodePathEqLhs -\u003e SchemaTree -\u003e Maybe (GNode SchemaVal)",
          "source": "src/NLP-GenI-LexicalSelection.html#seekCoanchor",
          "type": "function"
        },
        "index": {
          "description": "seekCoanchor lhs returns Just node if contains exactly one node that can be identified by lhs Nothing if it contains none It crashes if there is more than one such node because this should have been caught earlier by GenI",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "seekCoanchor",
          "normalized": "NodePathEqLhs-\u003eSchemaTree-\u003eMaybe(GNode SchemaVal)",
          "package": "GenI",
          "partial": "Coanchor",
          "signature": "NodePathEqLhs-\u003eSchemaTree-\u003eMaybe(GNode SchemaVal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:seekCoanchor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe lemanchor mechanism is described in\n   \u003ca\u003ehttp://projects.haskell.org/manual/lexical-selection\u003c/a\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "setLemAnchors",
          "package": "GenI",
          "signature": "Tree (GNode GeniVal) -\u003e Tree (GNode GeniVal)",
          "source": "src/NLP-GenI-LexicalSelection.html#setLemAnchors",
          "type": "function"
        },
        "index": {
          "description": "The lemanchor mechanism is described in http projects.haskell.org manual lexical-selection",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "setLemAnchors",
          "normalized": "Tree(GNode GeniVal)-\u003eTree(GNode GeniVal)",
          "package": "GenI",
          "partial": "Lem Anchors",
          "signature": "Tree(GNode GeniVal)-\u003eTree(GNode GeniVal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:setLemAnchors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esetOrigin n t\u003c/code\u003e marks the nodes in \u003ccode\u003et\u003c/code\u003e as having come from\n   a tree named \u003ccode\u003en\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.LexicalSelection",
          "name": "setOrigin",
          "package": "GenI",
          "signature": "Text -\u003e Tree (GNode v) -\u003e Tree (GNode v)",
          "source": "src/NLP-GenI-LexicalSelection.html#setOrigin",
          "type": "function"
        },
        "index": {
          "description": "setOrigin marks the nodes in as having come from tree named",
          "hierarchy": "NLP GenI LexicalSelection",
          "module": "NLP.GenI.LexicalSelection",
          "name": "setOrigin",
          "normalized": "Text-\u003eTree(GNode a)-\u003eTree(GNode a)",
          "package": "GenI",
          "partial": "Origin",
          "signature": "Text-\u003eTree(GNode v)-\u003eTree(GNode v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-LexicalSelection.html#v:setOrigin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInternals of lexical entry manipulation\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "Internal",
          "package": "GenI",
          "source": "src/NLP-GenI-Lexicon-Internal.html",
          "type": "module"
        },
        "index": {
          "description": "Internals of lexical entry manipulation",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "Internal",
          "package": "GenI",
          "partial": "Internal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLexical entry\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "LexEntry",
          "package": "GenI",
          "source": "src/NLP-GenI-Lexicon-Internal.html#LexEntry",
          "type": "data"
        },
        "index": {
          "description": "Lexical entry",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "LexEntry",
          "package": "GenI",
          "partial": "Lex Entry",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#t:LexEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCollection of lexical entries\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "Lexicon",
          "package": "GenI",
          "source": "src/NLP-GenI-Lexicon-Internal.html#Lexicon",
          "type": "type"
        },
        "index": {
          "description": "Collection of lexical entries",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "Lexicon",
          "package": "GenI",
          "partial": "Lexicon",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#t:Lexicon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn annotated GeniVal. This is for a rather old, obscure\n   variant on the polarity filtering optimisation. To account\n   for zero literal semantics, we annotate each value in the\n   semantics with a positive/negative marker.  These markers\n   are then counted up to determine with we need to insert\n   more literals into the semantics or not.  See the manual\n   on polarity filtering for more details\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "PolValue",
          "package": "GenI",
          "source": "src/NLP-GenI-Lexicon-Internal.html#PolValue",
          "type": "type"
        },
        "index": {
          "description": "An annotated GeniVal This is for rather old obscure variant on the polarity filtering optimisation To account for zero literal semantics we annotate each value in the semantics with positive negative marker These markers are then counted up to determine with we need to insert more literals into the semantics or not See the manual on polarity filtering for more details",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "PolValue",
          "package": "GenI",
          "partial": "Pol Value",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#t:PolValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "LexEntry",
          "package": "GenI",
          "signature": "LexEntry",
          "source": "src/NLP-GenI-Lexicon-Internal.html#LexEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "LexEntry",
          "package": "GenI",
          "partial": "Lex Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:LexEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNote that by convention we ignore the polarity associated\n   with the predicate itself\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.Lexicon.Internal\",\"NLP.GenI.Lexicon\"]",
          "name": "fromLexLiteral",
          "package": "GenI",
          "signature": "Literal PolValue -\u003e (Literal GeniVal, SemPols)",
          "source": "src/NLP-GenI-Lexicon-Internal.html#fromLexLiteral",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:fromLexLiteral\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#v:fromLexLiteral\"]"
        },
        "index": {
          "description": "Note that by convention we ignore the polarity associated with the predicate itself",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "fromLexLiteral",
          "normalized": "Literal PolValue-\u003e(Literal GeniVal,SemPols)",
          "package": "GenI",
          "partial": "Lex Literal",
          "signature": "Literal PolValue-\u003e(Literal GeniVal,SemPols)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:fromLexLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSeparate an input lexical semantics into the actual semantics\n   and the semantic polarity entries (which aren't used very much\n   in practice, being a sort of experimental feature to solve an\n   obscure-ish technical problem)\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.Lexicon.Internal\",\"NLP.GenI.Lexicon\"]",
          "name": "fromLexSem",
          "package": "GenI",
          "signature": "[Literal PolValue] -\u003e (Sem, [SemPols])",
          "source": "src/NLP-GenI-Lexicon-Internal.html#fromLexSem",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:fromLexSem\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#v:fromLexSem\"]"
        },
        "index": {
          "description": "Separate an input lexical semantics into the actual semantics and the semantic polarity entries which aren used very much in practice being sort of experimental feature to solve an obscure-ish technical problem",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "fromLexSem",
          "normalized": "[Literal PolValue]-\u003e(Sem,[SemPols])",
          "package": "GenI",
          "partial": "Lex Sem",
          "signature": "[Literal PolValue]-\u003e(Sem,[SemPols])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:fromLexSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epath equations\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "iequations",
          "package": "GenI",
          "signature": "Flist GeniVal",
          "source": "src/NLP-GenI-Lexicon-Internal.html#LexEntry",
          "type": "function"
        },
        "index": {
          "description": "path equations",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "iequations",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:iequations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etree family to anchor to\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "ifamname",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-Lexicon-Internal.html#LexEntry",
          "type": "function"
        },
        "index": {
          "description": "tree family to anchor to",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "ifamname",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:ifamname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efeatures to pick out family members we want\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "ifilters",
          "package": "GenI",
          "signature": "Flist GeniVal",
          "source": "src/NLP-GenI-Lexicon-Internal.html#LexEntry",
          "type": "function"
        },
        "index": {
          "description": "features to pick out family members we want",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "ifilters",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:ifilters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efeatures to unify with tree schema interface\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "iinterface",
          "package": "GenI",
          "signature": "Flist GeniVal",
          "source": "src/NLP-GenI-Lexicon-Internal.html#LexEntry",
          "type": "function"
        },
        "index": {
          "description": "features to unify with tree schema interface",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "iinterface",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:iinterface"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparameters (deprecrated; use the interface)\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "iparams",
          "package": "GenI",
          "signature": "[GeniVal]",
          "source": "src/NLP-GenI-Lexicon-Internal.html#LexEntry",
          "type": "function"
        },
        "index": {
          "description": "parameters deprecrated use the interface",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "iparams",
          "normalized": "[GeniVal]",
          "package": "GenI",
          "signature": "[GeniVal]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:iparams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elexical semantics\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "isemantics",
          "package": "GenI",
          "signature": "Sem",
          "source": "src/NLP-GenI-Lexicon-Internal.html#LexEntry",
          "type": "function"
        },
        "index": {
          "description": "lexical semantics",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "isemantics",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:isemantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epolarities (must be same length as \u003ccode\u003e\u003ca\u003eisemantics\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "isempols",
          "package": "GenI",
          "signature": "[SemPols]",
          "source": "src/NLP-GenI-Lexicon-Internal.html#LexEntry",
          "type": "function"
        },
        "index": {
          "description": "polarities must be same length as isemantics",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "isempols",
          "normalized": "[SemPols]",
          "package": "GenI",
          "signature": "[SemPols]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:isempols"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enormally just a singleton,\n   useful for merging synonyms\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "iword",
          "package": "GenI",
          "signature": "FullList Text",
          "source": "src/NLP-GenI-Lexicon-Internal.html#LexEntry",
          "type": "function"
        },
        "index": {
          "description": "normally just singleton useful for merging synonyms",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "iword",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:iword"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003emkLexEntry\u003c/a\u003e\u003c/code\u003e but with more control\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.Lexicon.Internal\",\"NLP.GenI.Lexicon\"]",
          "name": "mkFullLexEntry",
          "package": "GenI",
          "signature": "FullList Text-\u003e Text-\u003e [GeniVal]-\u003e Flist GeniVal-\u003e Flist GeniVal-\u003e Flist GeniVal-\u003e Sem-\u003e [SemPols]-\u003e LexEntry",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:mkFullLexEntry\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#v:mkFullLexEntry\"]"
        },
        "index": {
          "description": "Variant of mkLexEntry but with more control",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "mkFullLexEntry",
          "normalized": "FullList Text-\u003eText-\u003e[GeniVal]-\u003eFlist GeniVal-\u003eFlist GeniVal-\u003eFlist GeniVal-\u003eSem-\u003e[SemPols]-\u003eLexEntry",
          "package": "GenI",
          "partial": "Full Lex Entry",
          "signature": "FullList Text-\u003eText-\u003e[GeniVal]-\u003eFlist GeniVal-\u003eFlist GeniVal-\u003eFlist GeniVal-\u003eSem-\u003e[SemPols]-\u003eLexEntry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:mkFullLexEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSee also \u003ccode\u003e\u003ca\u003emkFullLexEntry\u003c/a\u003e\u003c/code\u003e\n   This version comes with some sensible defaults.\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.Lexicon.Internal\",\"NLP.GenI.Lexicon\"]",
          "name": "mkLexEntry",
          "package": "GenI",
          "signature": "FullList Text-\u003e Text-\u003e [GeniVal]-\u003e Flist GeniVal-\u003e Flist GeniVal-\u003e Flist GeniVal-\u003e Sem-\u003e LexEntry",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:mkLexEntry\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#v:mkLexEntry\"]"
        },
        "index": {
          "description": "See also mkFullLexEntry This version comes with some sensible defaults",
          "hierarchy": "NLP GenI Lexicon Internal",
          "module": "NLP.GenI.Lexicon.Internal",
          "name": "mkLexEntry",
          "normalized": "FullList Text-\u003eText-\u003e[GeniVal]-\u003eFlist GeniVal-\u003eFlist GeniVal-\u003eFlist GeniVal-\u003eSem-\u003eLexEntry",
          "package": "GenI",
          "partial": "Lex Entry",
          "signature": "FullList Text-\u003eText-\u003e[GeniVal]-\u003eFlist GeniVal-\u003eFlist GeniVal-\u003eFlist GeniVal-\u003eSem-\u003eLexEntry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon-Internal.html#v:mkLexEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLexical entries\n\u003c/p\u003e\u003cp\u003eAs a factorisation technique, LTAG grammars are commonly separated into\n   tree schemata (see \u003ccode\u003e\u003ca\u003eTreeSchema\u003c/a\u003e\u003c/code\u003e) and lexical entries.  The\n   grammar is what you get by &#8220;anchoring&#8221; each lexical entry to the relevant\n   tree schemata.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.Lexicon",
          "name": "Lexicon",
          "package": "GenI",
          "source": "src/NLP-GenI-Lexicon.html",
          "type": "module"
        },
        "index": {
          "description": "Lexical entries As factorisation technique LTAG grammars are commonly separated into tree schemata see TreeSchema and lexical entries The grammar is what you get by anchoring each lexical entry to the relevant tree schemata",
          "hierarchy": "NLP GenI Lexicon",
          "module": "NLP.GenI.Lexicon",
          "name": "Lexicon",
          "package": "GenI",
          "partial": "Lexicon",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLexical entry\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon",
          "name": "LexEntry",
          "package": "GenI",
          "source": "src/NLP-GenI-Lexicon-Internal.html#LexEntry",
          "type": "data"
        },
        "index": {
          "description": "Lexical entry",
          "hierarchy": "NLP GenI Lexicon",
          "module": "NLP.GenI.Lexicon",
          "name": "LexEntry",
          "package": "GenI",
          "partial": "Lex Entry",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#t:LexEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCollection of lexical entries\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon",
          "name": "Lexicon",
          "package": "GenI",
          "source": "src/NLP-GenI-Lexicon-Internal.html#Lexicon",
          "type": "type"
        },
        "index": {
          "description": "Collection of lexical entries",
          "hierarchy": "NLP GenI Lexicon",
          "module": "NLP.GenI.Lexicon",
          "name": "Lexicon",
          "package": "GenI",
          "partial": "Lexicon",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#t:Lexicon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn annotated GeniVal. This is for a rather old, obscure\n   variant on the polarity filtering optimisation. To account\n   for zero literal semantics, we annotate each value in the\n   semantics with a positive/negative marker.  These markers\n   are then counted up to determine with we need to insert\n   more literals into the semantics or not.  See the manual\n   on polarity filtering for more details\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon",
          "name": "PolValue",
          "package": "GenI",
          "source": "src/NLP-GenI-Lexicon-Internal.html#PolValue",
          "type": "type"
        },
        "index": {
          "description": "An annotated GeniVal This is for rather old obscure variant on the polarity filtering optimisation To account for zero literal semantics we annotate each value in the semantics with positive negative marker These markers are then counted up to determine with we need to insert more literals into the semantics or not See the manual on polarity filtering for more details",
          "hierarchy": "NLP GenI Lexicon",
          "module": "NLP.GenI.Lexicon",
          "name": "PolValue",
          "package": "GenI",
          "partial": "Pol Value",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#t:PolValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epath equations\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon",
          "name": "iequations",
          "package": "GenI",
          "signature": "LexEntry -\u003e Flist GeniVal",
          "source": "src/NLP-GenI-Lexicon-Internal.html#iequations",
          "type": "function"
        },
        "index": {
          "description": "path equations",
          "hierarchy": "NLP GenI Lexicon",
          "module": "NLP.GenI.Lexicon",
          "name": "iequations",
          "normalized": "LexEntry-\u003eFlist GeniVal",
          "package": "GenI",
          "signature": "LexEntry-\u003eFlist GeniVal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#v:iequations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etree family to anchor to\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon",
          "name": "ifamname",
          "package": "GenI",
          "signature": "LexEntry -\u003e Text",
          "source": "src/NLP-GenI-Lexicon-Internal.html#ifamname",
          "type": "function"
        },
        "index": {
          "description": "tree family to anchor to",
          "hierarchy": "NLP GenI Lexicon",
          "module": "NLP.GenI.Lexicon",
          "name": "ifamname",
          "normalized": "LexEntry-\u003eText",
          "package": "GenI",
          "signature": "LexEntry-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#v:ifamname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efeatures to pick out family members we want\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon",
          "name": "ifilters",
          "package": "GenI",
          "signature": "LexEntry -\u003e Flist GeniVal",
          "source": "src/NLP-GenI-Lexicon-Internal.html#ifilters",
          "type": "function"
        },
        "index": {
          "description": "features to pick out family members we want",
          "hierarchy": "NLP GenI Lexicon",
          "module": "NLP.GenI.Lexicon",
          "name": "ifilters",
          "normalized": "LexEntry-\u003eFlist GeniVal",
          "package": "GenI",
          "signature": "LexEntry-\u003eFlist GeniVal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#v:ifilters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efeatures to unify with tree schema interface\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon",
          "name": "iinterface",
          "package": "GenI",
          "signature": "LexEntry -\u003e Flist GeniVal",
          "source": "src/NLP-GenI-Lexicon-Internal.html#iinterface",
          "type": "function"
        },
        "index": {
          "description": "features to unify with tree schema interface",
          "hierarchy": "NLP GenI Lexicon",
          "module": "NLP.GenI.Lexicon",
          "name": "iinterface",
          "normalized": "LexEntry-\u003eFlist GeniVal",
          "package": "GenI",
          "signature": "LexEntry-\u003eFlist GeniVal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#v:iinterface"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparameters (deprecrated; use the interface)\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon",
          "name": "iparams",
          "package": "GenI",
          "signature": "LexEntry -\u003e [GeniVal]",
          "source": "src/NLP-GenI-Lexicon-Internal.html#iparams",
          "type": "function"
        },
        "index": {
          "description": "parameters deprecrated use the interface",
          "hierarchy": "NLP GenI Lexicon",
          "module": "NLP.GenI.Lexicon",
          "name": "iparams",
          "normalized": "LexEntry-\u003e[GeniVal]",
          "package": "GenI",
          "signature": "LexEntry-\u003e[GeniVal]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#v:iparams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elexical semantics\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon",
          "name": "isemantics",
          "package": "GenI",
          "signature": "LexEntry -\u003e Sem",
          "source": "src/NLP-GenI-Lexicon-Internal.html#isemantics",
          "type": "function"
        },
        "index": {
          "description": "lexical semantics",
          "hierarchy": "NLP GenI Lexicon",
          "module": "NLP.GenI.Lexicon",
          "name": "isemantics",
          "normalized": "LexEntry-\u003eSem",
          "package": "GenI",
          "signature": "LexEntry-\u003eSem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#v:isemantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epolarities (must be same length as \u003ccode\u003e\u003ca\u003eisemantics\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon",
          "name": "isempols",
          "package": "GenI",
          "signature": "LexEntry -\u003e [SemPols]",
          "source": "src/NLP-GenI-Lexicon-Internal.html#isempols",
          "type": "function"
        },
        "index": {
          "description": "polarities must be same length as isemantics",
          "hierarchy": "NLP GenI Lexicon",
          "module": "NLP.GenI.Lexicon",
          "name": "isempols",
          "normalized": "LexEntry-\u003e[SemPols]",
          "package": "GenI",
          "signature": "LexEntry-\u003e[SemPols]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#v:isempols"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enormally just a singleton,\n   useful for merging synonyms\n\u003c/p\u003e",
          "module": "NLP.GenI.Lexicon",
          "name": "iword",
          "package": "GenI",
          "signature": "LexEntry -\u003e FullList Text",
          "source": "src/NLP-GenI-Lexicon-Internal.html#iword",
          "type": "function"
        },
        "index": {
          "description": "normally just singleton useful for merging synonyms",
          "hierarchy": "NLP GenI Lexicon",
          "module": "NLP.GenI.Lexicon",
          "name": "iword",
          "normalized": "LexEntry-\u003eFullList Text",
          "package": "GenI",
          "signature": "LexEntry-\u003eFullList Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Lexicon.html#v:iword"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Main",
          "name": "Main",
          "package": "GenI",
          "source": "src/NLP-GenI-Main.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI Main",
          "module": "NLP.GenI.Main",
          "name": "Main",
          "package": "GenI",
          "partial": "Main",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Main.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Main",
          "name": "forceGuiFlag",
          "package": "GenI",
          "signature": "Params -\u003e Params",
          "source": "src/NLP-GenI-Main.html#forceGuiFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Main",
          "module": "NLP.GenI.Main",
          "name": "forceGuiFlag",
          "normalized": "Params-\u003eParams",
          "package": "GenI",
          "partial": "Gui Flag",
          "signature": "Params-\u003eParams",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Main.html#v:forceGuiFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Main",
          "name": "main",
          "package": "GenI",
          "signature": "IO ()",
          "source": "src/NLP-GenI-Main.html#main",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Main",
          "module": "NLP.GenI.Main",
          "name": "main",
          "normalized": "IO()",
          "package": "GenI",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Main.html#v:main"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Main",
          "name": "mainWithState",
          "package": "GenI",
          "signature": "ProgState -\u003e CustomSem sem -\u003e IO ()",
          "source": "src/NLP-GenI-Main.html#mainWithState",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Main",
          "module": "NLP.GenI.Main",
          "name": "mainWithState",
          "normalized": "ProgState-\u003eCustomSem a-\u003eIO()",
          "package": "GenI",
          "partial": "With State",
          "signature": "ProgState-\u003eCustomSem sem-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Main.html#v:mainWithState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Morphology.Types",
          "name": "Types",
          "package": "GenI",
          "source": "src/NLP-GenI-Morphology-Types.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI Morphology Types",
          "module": "NLP.GenI.Morphology.Types",
          "name": "Types",
          "package": "GenI",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA lemma plus its morphological features\n\u003c/p\u003e",
          "module": "NLP.GenI.Morphology.Types",
          "name": "LemmaPlus",
          "package": "GenI",
          "source": "src/NLP-GenI-Morphology-Types.html#LemmaPlus",
          "type": "data"
        },
        "index": {
          "description": "lemma plus its morphological features",
          "hierarchy": "NLP GenI Morphology Types",
          "module": "NLP.GenI.Morphology.Types",
          "name": "LemmaPlus",
          "package": "GenI",
          "partial": "Lemma Plus",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology-Types.html#t:LemmaPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA sentence composed of \u003ccode\u003e\u003ca\u003eLemmaPlus\u003c/a\u003e\u003c/code\u003e instead of plain old words\n\u003c/p\u003e",
          "module": "NLP.GenI.Morphology.Types",
          "name": "LemmaPlusSentence",
          "package": "GenI",
          "source": "src/NLP-GenI-Morphology-Types.html#LemmaPlusSentence",
          "type": "type"
        },
        "index": {
          "description": "sentence composed of LemmaPlus instead of plain old words",
          "hierarchy": "NLP GenI Morphology Types",
          "module": "NLP.GenI.Morphology.Types",
          "name": "LemmaPlusSentence",
          "package": "GenI",
          "partial": "Lemma Plus Sentence",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology-Types.html#t:LemmaPlusSentence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Morphology.Types",
          "name": "MorphInputFn",
          "package": "GenI",
          "source": "src/NLP-GenI-Morphology-Types.html#MorphInputFn",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Morphology Types",
          "module": "NLP.GenI.Morphology.Types",
          "name": "MorphInputFn",
          "package": "GenI",
          "partial": "Morph Input Fn",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology-Types.html#t:MorphInputFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Morphology.Types",
          "name": "MorphOutput",
          "package": "GenI",
          "source": "src/NLP-GenI-Morphology-Types.html#MorphOutput",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Morphology Types",
          "module": "NLP.GenI.Morphology.Types",
          "name": "MorphOutput",
          "package": "GenI",
          "partial": "Morph Output",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology-Types.html#t:MorphOutput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Morphology.Types",
          "name": "MorphRealiser",
          "package": "GenI",
          "source": "src/NLP-GenI-Morphology-Types.html#MorphRealiser",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Morphology Types",
          "module": "NLP.GenI.Morphology.Types",
          "name": "MorphRealiser",
          "package": "GenI",
          "partial": "Morph Realiser",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology-Types.html#t:MorphRealiser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Morphology.Types",
          "name": "LemmaPlus",
          "package": "GenI",
          "signature": "LemmaPlus",
          "source": "src/NLP-GenI-Morphology-Types.html#LemmaPlus",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Morphology Types",
          "module": "NLP.GenI.Morphology.Types",
          "name": "LemmaPlus",
          "package": "GenI",
          "partial": "Lemma Plus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology-Types.html#v:LemmaPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Morphology.Types",
          "name": "MorphOutput",
          "package": "GenI",
          "signature": "MorphOutput",
          "source": "src/NLP-GenI-Morphology-Types.html#MorphOutput",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Morphology Types",
          "module": "NLP.GenI.Morphology.Types",
          "name": "MorphOutput",
          "package": "GenI",
          "partial": "Morph Output",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology-Types.html#v:MorphOutput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Morphology.Types",
          "name": "lpFeats",
          "package": "GenI",
          "signature": "Flist GeniVal",
          "source": "src/NLP-GenI-Morphology-Types.html#LemmaPlus",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Morphology Types",
          "module": "NLP.GenI.Morphology.Types",
          "name": "lpFeats",
          "package": "GenI",
          "partial": "Feats",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology-Types.html#v:lpFeats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Morphology.Types",
          "name": "lpLemma",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-Morphology-Types.html#LemmaPlus",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Morphology Types",
          "module": "NLP.GenI.Morphology.Types",
          "name": "lpLemma",
          "package": "GenI",
          "partial": "Lemma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology-Types.html#v:lpLemma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Morphology.Types",
          "name": "moRealisations",
          "package": "GenI",
          "signature": "[Text]",
          "source": "src/NLP-GenI-Morphology-Types.html#MorphOutput",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Morphology Types",
          "module": "NLP.GenI.Morphology.Types",
          "name": "moRealisations",
          "normalized": "[Text]",
          "package": "GenI",
          "partial": "Realisations",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology-Types.html#v:moRealisations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Morphology.Types",
          "name": "moWarnings",
          "package": "GenI",
          "signature": "[Text]",
          "source": "src/NLP-GenI-Morphology-Types.html#MorphOutput",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Morphology Types",
          "module": "NLP.GenI.Morphology.Types",
          "name": "moWarnings",
          "normalized": "[Text]",
          "package": "GenI",
          "partial": "Warnings",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology-Types.html#v:moWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module handles mostly everything to do with morphology in Geni.\nThere are two basic tasks: morphological input and output.\nGenI farms out morphology to whatever third party program you\nspecify on the command line.  Note that a simple and stupid\n`\u003ccode\u003esillymorph'\u003c/code\u003e realiser is provided either in the GenI repository\nor on hackage.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.Morphology",
          "name": "Morphology",
          "package": "GenI",
          "source": "src/NLP-GenI-Morphology.html",
          "type": "module"
        },
        "index": {
          "description": "This module handles mostly everything to do with morphology in Geni There are two basic tasks morphological input and output GenI farms out morphology to whatever third party program you specify on the command line Note that simple and stupid sillymorph realiser is provided either in the GenI repository or on hackage",
          "hierarchy": "NLP GenI Morphology",
          "module": "NLP.GenI.Morphology",
          "name": "Morphology",
          "package": "GenI",
          "partial": "Morphology",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eattachMorph\u003c/a\u003e\u003c/code\u003e \u003ccode\u003emorphfn sem cands\u003c/code\u003e does the bulk of the morphological\n   input processing.  We use \u003ccode\u003emorphfn\u003c/code\u003e to determine which literals in\n   \u003ccode\u003esem\u003c/code\u003e contain morphological information and what information they contain.\n   Then we attach this morphological information to the relevant trees in\n   \u003ccode\u003ecand\u003c/code\u003e.  A tree is considered relevant w.r.t to a morphological\n   literal if its semantics contains at least one literal whose first index\n   is the same as the first index of the morphological literal.\n\u003c/p\u003e",
          "module": "NLP.GenI.Morphology",
          "name": "attachMorph",
          "package": "GenI",
          "signature": "MorphInputFn -\u003e Sem -\u003e [TagElem] -\u003e [TagElem]",
          "source": "src/NLP-GenI-Morphology.html#attachMorph",
          "type": "function"
        },
        "index": {
          "description": "attachMorph morphfn sem cands does the bulk of the morphological input processing We use morphfn to determine which literals in sem contain morphological information and what information they contain Then we attach this morphological information to the relevant trees in cand tree is considered relevant w.r.t to morphological literal if its semantics contains at least one literal whose first index is the same as the first index of the morphological literal",
          "hierarchy": "NLP GenI Morphology",
          "module": "NLP.GenI.Morphology",
          "name": "attachMorph",
          "normalized": "MorphInputFn-\u003eSem-\u003e[TagElem]-\u003e[TagElem]",
          "package": "GenI",
          "partial": "Morph",
          "signature": "MorphInputFn-\u003eSem-\u003e[TagElem]-\u003e[TagElem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology.html#v:attachMorph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a list of uninflected sentences into inflected ones by calling\n\u003c/p\u003e",
          "module": "NLP.GenI.Morphology",
          "name": "inflectSentencesUsingCmd",
          "package": "GenI",
          "signature": "String -\u003e [LemmaPlusSentence] -\u003e IO [(LemmaPlusSentence, MorphOutput)]",
          "source": "src/NLP-GenI-Morphology.html#inflectSentencesUsingCmd",
          "type": "function"
        },
        "index": {
          "description": "Converts list of uninflected sentences into inflected ones by calling",
          "hierarchy": "NLP GenI Morphology",
          "module": "NLP.GenI.Morphology",
          "name": "inflectSentencesUsingCmd",
          "normalized": "String-\u003e[LemmaPlusSentence]-\u003eIO[(LemmaPlusSentence,MorphOutput)]",
          "package": "GenI",
          "partial": "Sentences Using Cmd",
          "signature": "String-\u003e[LemmaPlusSentence]-\u003eIO[(LemmaPlusSentence,MorphOutput)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology.html#v:inflectSentencesUsingCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts information from a morphological information file into GenI's\n   internal format.\n\u003c/p\u003e",
          "module": "NLP.GenI.Morphology",
          "name": "readMorph",
          "package": "GenI",
          "signature": "[(Text, [AvPair GeniVal])] -\u003e MorphInputFn",
          "source": "src/NLP-GenI-Morphology.html#readMorph",
          "type": "function"
        },
        "index": {
          "description": "Converts information from morphological information file into GenI internal format",
          "hierarchy": "NLP GenI Morphology",
          "module": "NLP.GenI.Morphology",
          "name": "readMorph",
          "normalized": "[(Text,[AvPair GeniVal])]-\u003eMorphInputFn",
          "package": "GenI",
          "partial": "Morph",
          "signature": "[(Text,[AvPair GeniVal])]-\u003eMorphInputFn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology.html#v:readMorph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtracts the lemmas from a list of uninflected sentences.  This is used\n   when the morphological generator is unavailable, doesn't work, etc.\n\u003c/p\u003e",
          "module": "NLP.GenI.Morphology",
          "name": "sansMorph",
          "package": "GenI",
          "signature": "LemmaPlusSentence -\u003e MorphOutput",
          "source": "src/NLP-GenI-Morphology.html#sansMorph",
          "type": "function"
        },
        "index": {
          "description": "Extracts the lemmas from list of uninflected sentences This is used when the morphological generator is unavailable doesn work etc",
          "hierarchy": "NLP GenI Morphology",
          "module": "NLP.GenI.Morphology",
          "name": "sansMorph",
          "normalized": "LemmaPlusSentence-\u003eMorphOutput",
          "package": "GenI",
          "partial": "Morph",
          "signature": "LemmaPlusSentence-\u003eMorphOutput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology.html#v:sansMorph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esetMorphAnchor n t\u003c/code\u003e replaces the anchor node of a tree with \u003ccode\u003en\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWe assume the tree has exactly one anchor node.  If it has none,\n   this explodes; if it has more than one, they all get replaced.\n\u003c/p\u003e",
          "module": "NLP.GenI.Morphology",
          "name": "setMorphAnchor",
          "package": "GenI",
          "signature": "GNode GeniVal -\u003e Tree (GNode GeniVal) -\u003e Tree (GNode GeniVal)",
          "source": "src/NLP-GenI-Morphology.html#setMorphAnchor",
          "type": "function"
        },
        "index": {
          "description": "setMorphAnchor replaces the anchor node of tree with We assume the tree has exactly one anchor node If it has none this explodes if it has more than one they all get replaced",
          "hierarchy": "NLP GenI Morphology",
          "module": "NLP.GenI.Morphology",
          "name": "setMorphAnchor",
          "normalized": "GNode GeniVal-\u003eTree(GNode GeniVal)-\u003eTree(GNode GeniVal)",
          "package": "GenI",
          "partial": "Morph Anchor",
          "signature": "GNode GeniVal-\u003eTree(GNode GeniVal)-\u003eTree(GNode GeniVal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology.html#v:setMorphAnchor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFilters away from an input semantics any literals whose realisation is\n   strictly morphological.  The first argument tells us helps identify the\n   morphological literals -- it associates literals with morphological stuff;\n   if it returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, then it is non-morphological\n\u003c/p\u003e",
          "module": "NLP.GenI.Morphology",
          "name": "stripMorphSem",
          "package": "GenI",
          "signature": "MorphInputFn -\u003e Sem -\u003e Sem",
          "source": "src/NLP-GenI-Morphology.html#stripMorphSem",
          "type": "function"
        },
        "index": {
          "description": "Filters away from an input semantics any literals whose realisation is strictly morphological The first argument tells us helps identify the morphological literals it associates literals with morphological stuff if it returns Nothing then it is non-morphological",
          "hierarchy": "NLP GenI Morphology",
          "module": "NLP.GenI.Morphology",
          "name": "stripMorphSem",
          "normalized": "MorphInputFn-\u003eSem-\u003eSem",
          "package": "GenI",
          "partial": "Morph Sem",
          "signature": "MorphInputFn-\u003eSem-\u003eSem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Morphology.html#v:stripMorphSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.OptimalityTheory",
          "name": "OptimalityTheory",
          "package": "GenI",
          "source": "src/NLP-GenI-OptimalityTheory.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "OptimalityTheory",
          "package": "GenI",
          "partial": "Optimality Theory",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.OptimalityTheory",
          "name": "GetTraces",
          "package": "GenI",
          "source": "src/NLP-GenI-OptimalityTheory.html#GetTraces",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "GetTraces",
          "package": "GenI",
          "partial": "Get Traces",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#t:GetTraces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.OptimalityTheory",
          "name": "OtConstraint",
          "package": "GenI",
          "source": "src/NLP-GenI-OptimalityTheory.html#OtConstraint",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "OtConstraint",
          "package": "GenI",
          "partial": "Ot Constraint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#t:OtConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.OptimalityTheory",
          "name": "OtRanking",
          "package": "GenI",
          "source": "src/NLP-GenI-OptimalityTheory.html#OtRanking",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "OtRanking",
          "package": "GenI",
          "partial": "Ot Ranking",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#t:OtRanking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.OptimalityTheory",
          "name": "OtResult",
          "package": "GenI",
          "source": "src/NLP-GenI-OptimalityTheory.html#OtResult",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "OtResult",
          "package": "GenI",
          "partial": "Ot Result",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#t:OtResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.OptimalityTheory",
          "name": "OtViolation",
          "package": "GenI",
          "source": "src/NLP-GenI-OptimalityTheory.html#OtViolation",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "OtViolation",
          "package": "GenI",
          "partial": "Ot Violation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#t:OtViolation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.OptimalityTheory",
          "name": "RankedOtConstraint",
          "package": "GenI",
          "source": "src/NLP-GenI-OptimalityTheory.html#RankedOtConstraint",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "RankedOtConstraint",
          "package": "GenI",
          "partial": "Ranked Ot Constraint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#t:RankedOtConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe trace must NOT appear\n\u003c/p\u003e",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "NegativeC",
          "package": "GenI",
          "signature": "NegativeC Text",
          "source": "src/NLP-GenI-OptimalityTheory.html#OtConstraint",
          "type": "function"
        },
        "index": {
          "description": "the trace must NOT appear",
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "NegativeC",
          "package": "GenI",
          "partial": "Negative",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#v:NegativeC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethese traces must not appear AT THE SAME TIME\n\u003c/p\u003e",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "NegativeConjC",
          "package": "GenI",
          "signature": "NegativeConjC [Text]",
          "source": "src/NLP-GenI-OptimalityTheory.html#OtConstraint",
          "type": "function"
        },
        "index": {
          "description": "these traces must not appear AT THE SAME TIME",
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "NegativeConjC",
          "normalized": "NegativeConjC[Text]",
          "package": "GenI",
          "partial": "Negative Conj",
          "signature": "NegativeConjC[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#v:NegativeConjC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe trace must appear\n\u003c/p\u003e",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "PositiveC",
          "package": "GenI",
          "signature": "PositiveC Text",
          "source": "src/NLP-GenI-OptimalityTheory.html#OtConstraint",
          "type": "function"
        },
        "index": {
          "description": "the trace must appear",
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "PositiveC",
          "package": "GenI",
          "partial": "Positive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#v:PositiveC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.OptimalityTheory",
          "name": "RankedOtConstraint",
          "package": "GenI",
          "signature": "RankedOtConstraint Int OtConstraint",
          "source": "src/NLP-GenI-OptimalityTheory.html#RankedOtConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "RankedOtConstraint",
          "package": "GenI",
          "partial": "Ranked Ot Constraint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#v:RankedOtConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.OptimalityTheory",
          "name": "otWarnings",
          "package": "GenI",
          "signature": "Macros -\u003e OtRanking -\u003e [OtViolation] -\u003e [Text]",
          "source": "src/NLP-GenI-OptimalityTheory.html#otWarnings",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "otWarnings",
          "normalized": "Macros-\u003eOtRanking-\u003e[OtViolation]-\u003e[Text]",
          "package": "GenI",
          "partial": "Warnings",
          "signature": "Macros-\u003eOtRanking-\u003e[OtViolation]-\u003e[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#v:otWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.OptimalityTheory",
          "name": "prettyRank",
          "package": "GenI",
          "signature": "Int -\u003e Text",
          "source": "src/NLP-GenI-OptimalityTheory.html#prettyRank",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "prettyRank",
          "normalized": "Int-\u003eText",
          "package": "GenI",
          "partial": "Rank",
          "signature": "Int-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#v:prettyRank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.OptimalityTheory",
          "name": "prettyViolations",
          "package": "GenI",
          "signature": "GetTraces -\u003e Bool -\u003e [OtViolation] -\u003e Text",
          "source": "src/NLP-GenI-OptimalityTheory.html#prettyViolations",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "prettyViolations",
          "normalized": "GetTraces-\u003eBool-\u003e[OtViolation]-\u003eText",
          "package": "GenI",
          "partial": "Violations",
          "signature": "GetTraces-\u003eBool-\u003e[OtViolation]-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#v:prettyViolations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.OptimalityTheory",
          "name": "rankResults",
          "package": "GenI",
          "signature": "GetTraces -\u003e (a -\u003e TagDerivation) -\u003e OtRanking -\u003e [a] -\u003e [OtResult a]",
          "source": "src/NLP-GenI-OptimalityTheory.html#rankResults",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI OptimalityTheory",
          "module": "NLP.GenI.OptimalityTheory",
          "name": "rankResults",
          "normalized": "GetTraces-\u003e(a-\u003eTagDerivation)-\u003eOtRanking-\u003e[a]-\u003e[OtResult a]",
          "package": "GenI",
          "partial": "Results",
          "signature": "GetTraces-\u003e(a-\u003eTagDerivation)-\u003eOtRanking-\u003e[a]-\u003e[OtResult a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-OptimalityTheory.html#v:rankResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Parser",
          "name": "Parser",
          "package": "GenI",
          "source": "src/NLP-GenI-Parser.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "Parser",
          "package": "GenI",
          "partial": "Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is only used by the script genimakesuite\n\u003c/p\u003e",
          "module": "NLP.GenI.Parser",
          "name": "geniDerivations",
          "package": "GenI",
          "signature": "Parser [TestCaseOutput]",
          "source": "src/NLP-GenI-Parser.html#geniDerivations",
          "type": "function"
        },
        "index": {
          "description": "This is only used by the script genimakesuite",
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "geniDerivations",
          "normalized": "Parser[TestCaseOutput]",
          "package": "GenI",
          "partial": "Derivations",
          "signature": "Parser[TestCaseOutput]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:geniDerivations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Parser",
          "name": "geniFeats",
          "package": "GenI",
          "signature": "Parser (Flist v)",
          "source": "src/NLP-GenI-Parser.html#geniFeats",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "geniFeats",
          "package": "GenI",
          "partial": "Feats",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:geniFeats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Parser",
          "name": "geniLanguageDef",
          "package": "GenI",
          "signature": "GenLanguageDef Text () Identity",
          "source": "src/NLP-GenI-Parser.html#geniLanguageDef",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "geniLanguageDef",
          "normalized": "GenLanguageDef Text()Identity",
          "package": "GenI",
          "partial": "Language Def",
          "signature": "GenLanguageDef Text()Identity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:geniLanguageDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Parser",
          "name": "geniLexicon",
          "package": "GenI",
          "signature": "Parser [LexEntry]",
          "source": "src/NLP-GenI-Parser.html#geniLexicon",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "geniLexicon",
          "normalized": "Parser[LexEntry]",
          "package": "GenI",
          "partial": "Lexicon",
          "signature": "Parser[LexEntry]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:geniLexicon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Parser",
          "name": "geniMacros",
          "package": "GenI",
          "signature": "Parser [SchemaTree]",
          "source": "src/NLP-GenI-Parser.html#geniMacros",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "geniMacros",
          "normalized": "Parser[SchemaTree]",
          "package": "GenI",
          "partial": "Macros",
          "signature": "Parser[SchemaTree]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:geniMacros"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Parser",
          "name": "geniMorphInfo",
          "package": "GenI",
          "signature": "Parser [(Text, Flist GeniVal)]",
          "source": "src/NLP-GenI-Parser.html#geniMorphInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "geniMorphInfo",
          "normalized": "Parser[(Text,Flist GeniVal)]",
          "package": "GenI",
          "partial": "Morph Info",
          "signature": "Parser[(Text,Flist GeniVal)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:geniMorphInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Parser",
          "name": "geniSemanticInput",
          "package": "GenI",
          "signature": "Parser (Sem, Flist GeniVal, [LitConstr])",
          "source": "src/NLP-GenI-Parser.html#geniSemanticInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "geniSemanticInput",
          "normalized": "Parser(Sem,Flist GeniVal,[LitConstr])",
          "package": "GenI",
          "partial": "Semantic Input",
          "signature": "Parser(Sem,Flist GeniVal,[LitConstr])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:geniSemanticInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Parser",
          "name": "geniSemantics",
          "package": "GenI",
          "signature": "Parser Sem",
          "source": "src/NLP-GenI-Parser.html#geniSemantics",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "geniSemantics",
          "package": "GenI",
          "partial": "Semantics",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:geniSemantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis makes it possible to read anchored trees, which may be\n   useful for debugging purposes.\n\u003c/p\u003e\u003cp\u003eFIXME: note that this is very rudimentary; we do not set id numbers,\n   parse polarities. You'll have to call\n   some of our helper functions if you want that functionality.\n\u003c/p\u003e",
          "module": "NLP.GenI.Parser",
          "name": "geniTagElems",
          "package": "GenI",
          "signature": "Parser [TagElem]",
          "source": "src/NLP-GenI-Parser.html#geniTagElems",
          "type": "function"
        },
        "index": {
          "description": "This makes it possible to read anchored trees which may be useful for debugging purposes FIXME note that this is very rudimentary we do not set id numbers parse polarities You ll have to call some of our helper functions if you want that functionality",
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "geniTagElems",
          "normalized": "Parser[TagElem]",
          "package": "GenI",
          "partial": "Tag Elems",
          "signature": "Parser[TagElem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:geniTagElems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Parser",
          "name": "geniTestSuite",
          "package": "GenI",
          "signature": "Parser [TestCase SemInput]",
          "source": "src/NLP-GenI-Parser.html#geniTestSuite",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "geniTestSuite",
          "normalized": "Parser[TestCase SemInput]",
          "package": "GenI",
          "partial": "Test Suite",
          "signature": "Parser[TestCase SemInput]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:geniTestSuite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJust the String representations of the semantics\n   in the test suite\n\u003c/p\u003e",
          "module": "NLP.GenI.Parser",
          "name": "geniTestSuiteString",
          "package": "GenI",
          "signature": "Parser [Text]",
          "source": "src/NLP-GenI-Parser.html#geniTestSuiteString",
          "type": "function"
        },
        "index": {
          "description": "Just the String representations of the semantics in the test suite",
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "geniTestSuiteString",
          "normalized": "Parser[Text]",
          "package": "GenI",
          "partial": "Test Suite String",
          "signature": "Parser[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:geniTestSuiteString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Parser",
          "name": "geniValue",
          "package": "GenI",
          "signature": "Parser GeniVal",
          "source": "src/NLP-GenI-Parser.html#geniValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "geniValue",
          "package": "GenI",
          "partial": "Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:geniValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Parser",
          "name": "geniWord",
          "package": "GenI",
          "signature": "Parser Text",
          "source": "src/NLP-GenI-Parser.html#geniWord",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "geniWord",
          "package": "GenI",
          "partial": "Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:geniWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Parser",
          "name": "geniWords",
          "package": "GenI",
          "signature": "Parser Text",
          "source": "src/NLP-GenI-Parser.html#geniWords",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "geniWords",
          "package": "GenI",
          "partial": "Words",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:geniWords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Parser",
          "name": "parseFromFile",
          "package": "GenI",
          "signature": "Parser a -\u003e SourceName -\u003e IO (Either ParseError a)",
          "source": "src/NLP-GenI-Parser.html#parseFromFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "parseFromFile",
          "normalized": "Parser a-\u003eSourceName-\u003eIO(Either ParseError a)",
          "package": "GenI",
          "partial": "From File",
          "signature": "Parser a-\u003eSourceName-\u003eIO(Either ParseError a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:parseFromFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Parser",
          "name": "tillEof",
          "package": "GenI",
          "signature": "Parser a -\u003e Parser a",
          "source": "src/NLP-GenI-Parser.html#tillEof",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Parser",
          "module": "NLP.GenI.Parser",
          "name": "tillEof",
          "normalized": "Parser a-\u003eParser a",
          "package": "GenI",
          "partial": "Eof",
          "signature": "Parser a-\u003eParser a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Parser.html#v:tillEof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "Internal",
          "package": "GenI",
          "source": "src/NLP-GenI-Polarity-Internal.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "Internal",
          "package": "GenI",
          "partial": "Internal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "PolMap",
          "package": "GenI",
          "source": "src/NLP-GenI-Polarity-Internal.html#PolMap",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "PolMap",
          "package": "GenI",
          "partial": "Pol Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#t:PolMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "PolarityDetectionResult",
          "package": "GenI",
          "source": "src/NLP-GenI-Polarity-Internal.html#PolarityDetectionResult",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "PolarityDetectionResult",
          "package": "GenI",
          "partial": "Polarity Detection Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#t:PolarityDetectionResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "SemMap",
          "package": "GenI",
          "source": "src/NLP-GenI-Polarity-Internal.html#SemMap",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "SemMap",
          "package": "GenI",
          "partial": "Sem Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#t:SemMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "PD_Just",
          "package": "GenI",
          "signature": "PD_Just [(PolarityKey, Interval)]",
          "source": "src/NLP-GenI-Polarity-Internal.html#PolarityDetectionResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "PD_Just",
          "normalized": "PD_Just[(PolarityKey,Interval)]",
          "package": "GenI",
          "partial": "PD Just",
          "signature": "PD_Just[(PolarityKey,Interval)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:PD_Just"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "PD_Nothing",
          "package": "GenI",
          "signature": "PD_Nothing",
          "source": "src/NLP-GenI-Polarity-Internal.html#PolarityDetectionResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "PD_Nothing",
          "package": "GenI",
          "partial": "PD Nothing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:PD_Nothing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "PD_Unconstrained",
          "package": "GenI",
          "signature": "PD_Unconstrained (Text, Interval)",
          "source": "src/NLP-GenI-Polarity-Internal.html#PolarityDetectionResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "PD_Unconstrained",
          "normalized": "PD_Unconstrained(Text,Interval)",
          "package": "GenI",
          "partial": "PD Unconstrained",
          "signature": "PD_Unconstrained(Text,Interval)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:PD_Unconstrained"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "PD_UserError",
          "package": "GenI",
          "signature": "PD_UserError String",
          "source": "src/NLP-GenI-Polarity-Internal.html#PolarityDetectionResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "PD_UserError",
          "package": "GenI",
          "partial": "PD User Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:PD_UserError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "__cat__",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-Polarity-Internal.html#__cat__",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "__cat__",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:__cat__"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "__idx__",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-Polarity-Internal.html#__idx__",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "__idx__",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:__idx__"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "addPols",
          "package": "GenI",
          "signature": "[(PolarityKey, Interval)] -\u003e PolMap -\u003e PolMap",
          "source": "src/NLP-GenI-Polarity-Internal.html#addPols",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "addPols",
          "normalized": "[(PolarityKey,Interval)]-\u003ePolMap-\u003ePolMap",
          "package": "GenI",
          "partial": "Pols",
          "signature": "[(PolarityKey,Interval)]-\u003ePolMap-\u003ePolMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:addPols"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert any unconstrained polarities in a \u003ccode\u003e\u003ca\u003ePolMap\u003c/a\u003e\u003c/code\u003e to constrained\n   ones, assuming a global list of known constrained keys.\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "convertUnconstrainedPolarities",
          "package": "GenI",
          "signature": "[PolarityKey] -\u003e PolMap -\u003e PolMap",
          "source": "src/NLP-GenI-Polarity-Internal.html#convertUnconstrainedPolarities",
          "type": "function"
        },
        "index": {
          "description": "Convert any unconstrained polarities in PolMap to constrained ones assuming global list of known constrained keys",
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "convertUnconstrainedPolarities",
          "normalized": "[PolarityKey]-\u003ePolMap-\u003ePolMap",
          "package": "GenI",
          "partial": "Unconstrained Polarities",
          "signature": "[PolarityKey]-\u003ePolMap-\u003ePolMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:convertUnconstrainedPolarities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "detectPolarity",
          "package": "GenI",
          "signature": "Int-\u003e PolarityAttr-\u003e FeatStruct GeniVal-\u003e FeatStruct GeniVal-\u003e PolarityDetectionResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "detectPolarity",
          "normalized": "Int-\u003ePolarityAttr-\u003eFeatStruct GeniVal-\u003eFeatStruct GeniVal-\u003ePolarityDetectionResult",
          "package": "GenI",
          "partial": "Polarity",
          "signature": "Int-\u003ePolarityAttr-\u003eFeatStruct GeniVal-\u003eFeatStruct GeniVal-\u003ePolarityDetectionResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:detectPolarity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "detectPolsH",
          "package": "GenI",
          "signature": "Set PolarityAttr -\u003e TagElem -\u003e [(PolarityKey, Interval)]",
          "source": "src/NLP-GenI-Polarity-Internal.html#detectPolsH",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "detectPolsH",
          "normalized": "Set PolarityAttr-\u003eTagElem-\u003e[(PolarityKey,Interval)]",
          "package": "GenI",
          "partial": "Pols",
          "signature": "Set PolarityAttr-\u003eTagElem-\u003e[(PolarityKey,Interval)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:detectPolsH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a description of what the root feature should unify with\n   return a -1 polarity for all relevant polarity keys. This allows\n   us to compensate for the root node of any derived tree.\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "detectRootCompensation",
          "package": "GenI",
          "signature": "Set PolarityAttr -\u003e FeatStruct GeniVal -\u003e PolMap",
          "source": "src/NLP-GenI-Polarity-Internal.html#detectRootCompensation",
          "type": "function"
        },
        "index": {
          "description": "Given description of what the root feature should unify with return polarity for all relevant polarity keys This allows us to compensate for the root node of any derived tree",
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "detectRootCompensation",
          "normalized": "Set PolarityAttr-\u003eFeatStruct GeniVal-\u003ePolMap",
          "package": "GenI",
          "partial": "Root Compensation",
          "signature": "Set PolarityAttr-\u003eFeatStruct GeniVal-\u003ePolMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:detectRootCompensation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnsures that all states and transitions in the polarity automaton\n   are unique.  This is a slight optimisation so that we don't have to\n   repeatedly check the automaton for state uniqueness during its\n   construction, but it is essential that this check be done after\n   construction\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "nubAut",
          "package": "GenI",
          "signature": "NFA st ab -\u003e NFA st ab",
          "source": "src/NLP-GenI-Polarity-Internal.html#nubAut",
          "type": "function"
        },
        "index": {
          "description": "Ensures that all states and transitions in the polarity automaton are unique This is slight optimisation so that we don have to repeatedly check the automaton for state uniqueness during its construction but it is essential that this check be done after construction",
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "nubAut",
          "normalized": "NFA a b-\u003eNFA a b",
          "package": "GenI",
          "partial": "Aut",
          "signature": "NFA st ab-\u003eNFA st ab",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:nubAut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNote that this will crash if any of the entries are errors\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "pdResults",
          "package": "GenI",
          "signature": "[PolarityDetectionResult] -\u003e [(PolarityKey, Interval)]",
          "source": "src/NLP-GenI-Polarity-Internal.html#pdResults",
          "type": "function"
        },
        "index": {
          "description": "Note that this will crash if any of the entries are errors",
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "pdResults",
          "normalized": "[PolarityDetectionResult]-\u003e[(PolarityKey,Interval)]",
          "package": "GenI",
          "partial": "Results",
          "signature": "[PolarityDetectionResult]-\u003e[(PolarityKey,Interval)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:pdResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNote that this will crash if any of the entries are errors\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "pdToList",
          "package": "GenI",
          "signature": "(String -\u003e String)-\u003e PolarityDetectionResult-\u003e [(PolarityKey, Interval)]",
          "type": "function"
        },
        "index": {
          "description": "Note that this will crash if any of the entries are errors",
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "pdToList",
          "normalized": "(String-\u003eString)-\u003ePolarityDetectionResult-\u003e[(PolarityKey,Interval)]",
          "package": "GenI",
          "partial": "To List",
          "signature": "(String-\u003eString)-\u003ePolarityDetectionResult-\u003e[(PolarityKey,Interval)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:pdToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "polarityKeys",
          "package": "GenI",
          "signature": "[TagElem] -\u003e PolMap -\u003e [PolarityKey]",
          "source": "src/NLP-GenI-Polarity-Internal.html#polarityKeys",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "polarityKeys",
          "normalized": "[TagElem]-\u003ePolMap-\u003e[PolarityKey]",
          "package": "GenI",
          "partial": "Keys",
          "signature": "[TagElem]-\u003ePolMap-\u003e[PolarityKey]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:polarityKeys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "substNodes",
          "package": "GenI",
          "signature": "TagElem -\u003e [GNode GeniVal]",
          "source": "src/NLP-GenI-Polarity-Internal.html#substNodes",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "substNodes",
          "normalized": "TagElem-\u003e[GNode GeniVal]",
          "package": "GenI",
          "partial": "Nodes",
          "signature": "TagElem-\u003e[GNode GeniVal]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:substNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "substTops",
          "package": "GenI",
          "signature": "TagElem -\u003e [Flist GeniVal]",
          "source": "src/NLP-GenI-Polarity-Internal.html#substTops",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "substTops",
          "normalized": "TagElem-\u003e[Flist GeniVal]",
          "package": "GenI",
          "partial": "Tops",
          "signature": "TagElem-\u003e[Flist GeniVal]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:substTops"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Internal",
          "name": "toZero",
          "package": "GenI",
          "signature": "Int -\u003e Interval",
          "source": "src/NLP-GenI-Polarity-Internal.html#toZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Internal",
          "module": "NLP.GenI.Polarity.Internal",
          "name": "toZero",
          "normalized": "Int-\u003eInterval",
          "package": "GenI",
          "partial": "Zero",
          "signature": "Int-\u003eInterval",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Internal.html#v:toZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Types",
          "name": "Types",
          "package": "GenI",
          "source": "src/NLP-GenI-Polarity-Types.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Types",
          "module": "NLP.GenI.Polarity.Types",
          "name": "Types",
          "package": "GenI",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ePolarityAttr\u003c/a\u003e\u003c/code\u003e is something you want to perform detect polarities on.\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity.Types",
          "name": "PolarityAttr",
          "package": "GenI",
          "source": "src/NLP-GenI-Polarity-Types.html#PolarityAttr",
          "type": "data"
        },
        "index": {
          "description": "PolarityAttr is something you want to perform detect polarities on",
          "hierarchy": "NLP GenI Polarity Types",
          "module": "NLP.GenI.Polarity.Types",
          "name": "PolarityAttr",
          "package": "GenI",
          "partial": "Polarity Attr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Types.html#t:PolarityAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Types",
          "name": "PolarityKey",
          "package": "GenI",
          "source": "src/NLP-GenI-Polarity-Types.html#PolarityKey",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Types",
          "module": "NLP.GenI.Polarity.Types",
          "name": "PolarityKey",
          "package": "GenI",
          "partial": "Polarity Key",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Types.html#t:PolarityKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Types",
          "name": "SemPols",
          "package": "GenI",
          "source": "src/NLP-GenI-Polarity-Types.html#SemPols",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Types",
          "module": "NLP.GenI.Polarity.Types",
          "name": "SemPols",
          "package": "GenI",
          "partial": "Sem Pols",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Types.html#t:SemPols"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Types",
          "name": "PolarityKeyAv",
          "package": "GenI",
          "signature": "PolarityKeyAv Text Text",
          "source": "src/NLP-GenI-Polarity-Types.html#PolarityKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Types",
          "module": "NLP.GenI.Polarity.Types",
          "name": "PolarityKeyAv",
          "package": "GenI",
          "partial": "Polarity Key Av",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Types.html#v:PolarityKeyAv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Types",
          "name": "PolarityKeyStr",
          "package": "GenI",
          "signature": "PolarityKeyStr Text",
          "source": "src/NLP-GenI-Polarity-Types.html#PolarityKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Types",
          "module": "NLP.GenI.Polarity.Types",
          "name": "PolarityKeyStr",
          "package": "GenI",
          "partial": "Polarity Key Str",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Types.html#v:PolarityKeyStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eattribute\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity.Types",
          "name": "PolarityKeyVar",
          "package": "GenI",
          "signature": "PolarityKeyVar Text",
          "source": "src/NLP-GenI-Polarity-Types.html#PolarityKey",
          "type": "function"
        },
        "index": {
          "description": "attribute",
          "hierarchy": "NLP GenI Polarity Types",
          "module": "NLP.GenI.Polarity.Types",
          "name": "PolarityKeyVar",
          "package": "GenI",
          "partial": "Polarity Key Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Types.html#v:PolarityKeyVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eRestrictedPolarityKey\u003c/code\u003e \u003ccode\u003ec att\u003c/code\u003e is a polarity key in which we only pay\n   attention to nodes that have the category \u003ccode\u003ec\u003c/code\u003e.  This makes it possible\n   to have polarities for a just a small subset of nodes\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity.Types",
          "name": "RestrictedPolarityAttr",
          "package": "GenI",
          "signature": "RestrictedPolarityAttr",
          "source": "src/NLP-GenI-Polarity-Types.html#PolarityAttr",
          "type": "function"
        },
        "index": {
          "description": "RestrictedPolarityKey att is polarity key in which we only pay attention to nodes that have the category This makes it possible to have polarities for just small subset of nodes",
          "hierarchy": "NLP GenI Polarity Types",
          "module": "NLP.GenI.Polarity.Types",
          "name": "RestrictedPolarityAttr",
          "package": "GenI",
          "partial": "Restricted Polarity Attr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Types.html#v:RestrictedPolarityAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Types",
          "name": "SimplePolarityAttr",
          "package": "GenI",
          "signature": "SimplePolarityAttr",
          "source": "src/NLP-GenI-Polarity-Types.html#PolarityAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Types",
          "module": "NLP.GenI.Polarity.Types",
          "name": "SimplePolarityAttr",
          "package": "GenI",
          "partial": "Simple Polarity Attr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Types.html#v:SimplePolarityAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Types",
          "name": "_rpkCat",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-Polarity-Types.html#PolarityAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Types",
          "module": "NLP.GenI.Polarity.Types",
          "name": "_rpkCat",
          "package": "GenI",
          "partial": "Cat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Types.html#v:_rpkCat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Types",
          "name": "readPolarityAttrs",
          "package": "GenI",
          "signature": "String -\u003e Set PolarityAttr",
          "source": "src/NLP-GenI-Polarity-Types.html#readPolarityAttrs",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Types",
          "module": "NLP.GenI.Polarity.Types",
          "name": "readPolarityAttrs",
          "normalized": "String-\u003eSet PolarityAttr",
          "package": "GenI",
          "partial": "Polarity Attrs",
          "signature": "String-\u003eSet PolarityAttr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Types.html#v:readPolarityAttrs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Types",
          "name": "rpkAtt",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-Polarity-Types.html#PolarityAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Types",
          "module": "NLP.GenI.Polarity.Types",
          "name": "rpkAtt",
          "package": "GenI",
          "partial": "Att",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Types.html#v:rpkAtt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Types",
          "name": "showPolarityAttrs",
          "package": "GenI",
          "signature": "Set PolarityAttr -\u003e String",
          "source": "src/NLP-GenI-Polarity-Types.html#showPolarityAttrs",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Types",
          "module": "NLP.GenI.Polarity.Types",
          "name": "showPolarityAttrs",
          "normalized": "Set PolarityAttr-\u003eString",
          "package": "GenI",
          "partial": "Polarity Attrs",
          "signature": "Set PolarityAttr-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Types.html#v:showPolarityAttrs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity.Types",
          "name": "spkAtt",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-Polarity-Types.html#PolarityAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity Types",
          "module": "NLP.GenI.Polarity.Types",
          "name": "spkAtt",
          "package": "GenI",
          "partial": "Att",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity-Types.html#v:spkAtt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "Polarity",
          "package": "GenI",
          "source": "src/NLP-GenI-Polarity.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "Polarity",
          "package": "GenI",
          "partial": "Polarity",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "AutDebug",
          "package": "GenI",
          "source": "src/NLP-GenI-Polarity.html#AutDebug",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "AutDebug",
          "package": "GenI",
          "partial": "Aut Debug",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#t:AutDebug"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNote: you can define the final state either by setting \u003ccode\u003e\u003ca\u003eisFinalSt\u003c/a\u003e\u003c/code\u003e\n   to \u003ccode\u003eJust f\u003c/code\u003e where \u003ccode\u003ef\u003c/code\u003e is some function or by putting them in\n   \u003ccode\u003e\u003ca\u003efinalStList\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity",
          "name": "NFA",
          "package": "GenI",
          "source": "src/NLP-GenI-Automaton.html#NFA",
          "type": "data"
        },
        "index": {
          "description": "Note you can define the final state either by setting isFinalSt to Just where is some function or by putting them in finalStList",
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "NFA",
          "package": "GenI",
          "partial": "NFA",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#t:NFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "PolAut",
          "package": "GenI",
          "source": "src/NLP-GenI-Polarity.html#PolAut",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "PolAut",
          "package": "GenI",
          "partial": "Pol Aut",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#t:PolAut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "PolPathSet",
          "package": "GenI",
          "source": "src/NLP-GenI-Polarity.html#PolPathSet",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "PolPathSet",
          "package": "GenI",
          "partial": "Pol Path Set",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#t:PolPathSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eintermediate auts, seed aut, final aut, potentially modified sem\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity",
          "name": "PolResult",
          "package": "GenI",
          "source": "src/NLP-GenI-Polarity.html#PolResult",
          "type": "data"
        },
        "index": {
          "description": "intermediate auts seed aut final aut potentially modified sem",
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "PolResult",
          "package": "GenI",
          "partial": "Pol Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#t:PolResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "PolState",
          "package": "GenI",
          "source": "src/NLP-GenI-Polarity.html#PolState",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "PolState",
          "package": "GenI",
          "partial": "Pol State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#t:PolState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "PolResult",
          "package": "GenI",
          "signature": "PolResult",
          "source": "src/NLP-GenI-Polarity.html#PolResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "PolResult",
          "package": "GenI",
          "partial": "Pol Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:PolResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eposition in the input semantics, extra semantics,\n   polarity interval\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity",
          "name": "PolSt",
          "package": "GenI",
          "signature": "PolSt Int [Literal GeniVal] [(Int, Int)]",
          "source": "src/NLP-GenI-Polarity.html#PolState",
          "type": "function"
        },
        "index": {
          "description": "position in the input semantics extra semantics polarity interval",
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "PolSt",
          "normalized": "PolSt Int[Literal GeniVal][(Int,Int)]",
          "package": "GenI",
          "partial": "Pol St",
          "signature": "PolSt Int[Literal GeniVal][(Int,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:PolSt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs a polarity automaton.  For debugging purposes, it returns\n   all the intermediate automata produced by the construction algorithm.\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity",
          "name": "buildAutomaton",
          "package": "GenI",
          "signature": "Set PolarityAttr-\u003e FeatStruct GeniVal-\u003e PolMap-\u003e SemInput-\u003e [TagElem]-\u003e PolResult",
          "type": "function"
        },
        "index": {
          "description": "Constructs polarity automaton For debugging purposes it returns all the intermediate automata produced by the construction algorithm",
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "buildAutomaton",
          "normalized": "Set PolarityAttr-\u003eFeatStruct GeniVal-\u003ePolMap-\u003eSemInput-\u003e[TagElem]-\u003ePolResult",
          "package": "GenI",
          "partial": "Automaton",
          "signature": "Set PolarityAttr-\u003eFeatStruct GeniVal-\u003ePolMap-\u003eSemInput-\u003e[TagElem]-\u003ePolResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:buildAutomaton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "declareIdxConstraints",
          "package": "GenI",
          "signature": "Flist GeniVal -\u003e PolMap",
          "source": "src/NLP-GenI-Polarity.html#declareIdxConstraints",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "declareIdxConstraints",
          "normalized": "Flist GeniVal-\u003ePolMap",
          "package": "GenI",
          "partial": "Idx Constraints",
          "signature": "Flist GeniVal-\u003ePolMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:declareIdxConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "detectIdxConstraints",
          "package": "GenI",
          "signature": "Flist GeniVal -\u003e Flist GeniVal -\u003e PolMap",
          "source": "src/NLP-GenI-Polarity.html#detectIdxConstraints",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "detectIdxConstraints",
          "normalized": "Flist GeniVal-\u003eFlist GeniVal-\u003ePolMap",
          "package": "GenI",
          "partial": "Idx Constraints",
          "signature": "Flist GeniVal-\u003eFlist GeniVal-\u003ePolMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:detectIdxConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list of paths (i.e. a list of list of trees)\n   return a list of trees such that each tree is annotated with the paths it\n   belongs to.\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity",
          "name": "detectPolPaths",
          "package": "GenI",
          "signature": "[[TagElem]] -\u003e [(TagElem, PolPathSet)]",
          "source": "src/NLP-GenI-Polarity.html#detectPolPaths",
          "type": "function"
        },
        "index": {
          "description": "Given list of paths i.e list of list of trees return list of trees such that each tree is annotated with the paths it belongs to",
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "detectPolPaths",
          "normalized": "[[TagElem]]-\u003e[(TagElem,PolPathSet)]",
          "package": "GenI",
          "partial": "Pol Paths",
          "signature": "[[TagElem]]-\u003e[(TagElem,PolPathSet)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:detectPolPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "detectPols",
          "package": "GenI",
          "signature": "Set PolarityAttr -\u003e TagElem -\u003e TagElem",
          "source": "src/NLP-GenI-Polarity.html#detectPols",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "detectPols",
          "normalized": "Set PolarityAttr-\u003eTagElem-\u003eTagElem",
          "package": "GenI",
          "partial": "Pols",
          "signature": "Set PolarityAttr-\u003eTagElem-\u003eTagElem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:detectPols"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "detectSansIdx",
          "package": "GenI",
          "signature": "[TagElem] -\u003e [TagElem]",
          "source": "src/NLP-GenI-Polarity.html#detectSansIdx",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "detectSansIdx",
          "normalized": "[TagElem]-\u003e[TagElem]",
          "package": "GenI",
          "partial": "Sans Idx",
          "signature": "[TagElem]-\u003e[TagElem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:detectSansIdx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "emptyPolPaths",
          "package": "GenI",
          "signature": "PolPathSet",
          "source": "src/NLP-GenI-Polarity.html#emptyPolPaths",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "emptyPolPaths",
          "package": "GenI",
          "partial": "Pol Paths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:emptyPolPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a modified input semantics and lexical selection in which pronouns\n   are properly accounted for.\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity",
          "name": "fixPronouns",
          "package": "GenI",
          "signature": "(Sem, [TagElem]) -\u003e (Sem, [TagElem])",
          "source": "src/NLP-GenI-Polarity.html#fixPronouns",
          "type": "function"
        },
        "index": {
          "description": "Returns modified input semantics and lexical selection in which pronouns are properly accounted for",
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "fixPronouns",
          "normalized": "(Sem,[TagElem])-\u003e(Sem,[TagElem])",
          "package": "GenI",
          "partial": "Pronouns",
          "signature": "(Sem,[TagElem])-\u003e(Sem,[TagElem])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:fixPronouns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "hasSharedPolPaths",
          "package": "GenI",
          "signature": "PolPathSet -\u003e PolPathSet -\u003e Bool",
          "source": "src/NLP-GenI-Polarity.html#hasSharedPolPaths",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "hasSharedPolPaths",
          "normalized": "PolPathSet-\u003ePolPathSet-\u003eBool",
          "package": "GenI",
          "partial": "Shared Pol Paths",
          "signature": "PolPathSet-\u003ePolPathSet-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:hasSharedPolPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "intersectPolPaths",
          "package": "GenI",
          "signature": "PolPathSet -\u003e PolPathSet -\u003e PolPathSet",
          "source": "src/NLP-GenI-Polarity.html#intersectPolPaths",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "intersectPolPaths",
          "normalized": "PolPathSet-\u003ePolPathSet-\u003ePolPathSet",
          "package": "GenI",
          "partial": "Pol Paths",
          "signature": "PolPathSet-\u003ePolPathSet-\u003ePolPathSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:intersectPolPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "makePolAut",
          "package": "GenI",
          "signature": "[TagElem] -\u003e Sem -\u003e PolMap -\u003e [PolarityKey] -\u003e PolResult",
          "source": "src/NLP-GenI-Polarity.html#makePolAut",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "makePolAut",
          "normalized": "[TagElem]-\u003eSem-\u003ePolMap-\u003e[PolarityKey]-\u003ePolResult",
          "package": "GenI",
          "partial": "Pol Aut",
          "signature": "[TagElem]-\u003eSem-\u003ePolMap-\u003e[PolarityKey]-\u003ePolResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:makePolAut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "polPathsNull",
          "package": "GenI",
          "signature": "PolPathSet -\u003e Bool",
          "source": "src/NLP-GenI-Polarity.html#polPathsNull",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "polPathsNull",
          "normalized": "PolPathSet-\u003eBool",
          "package": "GenI",
          "partial": "Paths Null",
          "signature": "PolPathSet-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:polPathsNull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "polPathsToList",
          "package": "GenI",
          "signature": "PolPathSet -\u003e [Int]",
          "source": "src/NLP-GenI-Polarity.html#polPathsToList",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "polPathsToList",
          "normalized": "PolPathSet-\u003e[Int]",
          "package": "GenI",
          "partial": "Paths To List",
          "signature": "PolPathSet-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:polPathsToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "prFinal",
          "package": "GenI",
          "signature": "PolAut",
          "source": "src/NLP-GenI-Polarity.html#PolResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "prFinal",
          "package": "GenI",
          "partial": "Final",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:prFinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "prInitial",
          "package": "GenI",
          "signature": "PolAut",
          "source": "src/NLP-GenI-Polarity.html#PolResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "prInitial",
          "package": "GenI",
          "partial": "Initial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:prInitial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "prIntermediate",
          "package": "GenI",
          "signature": "[AutDebug]",
          "source": "src/NLP-GenI-Polarity.html#PolResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "prIntermediate",
          "normalized": "[AutDebug]",
          "package": "GenI",
          "partial": "Intermediate",
          "signature": "[AutDebug]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:prIntermediate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "prSem",
          "package": "GenI",
          "signature": "Sem",
          "source": "src/NLP-GenI-Polarity.html#PolResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "prSem",
          "package": "GenI",
          "partial": "Sem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:prSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender the list of polarity automaton paths as a string\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity",
          "name": "prettyPolPaths",
          "package": "GenI",
          "signature": "PolPathSet -\u003e Text",
          "source": "src/NLP-GenI-Polarity.html#prettyPolPaths",
          "type": "function"
        },
        "index": {
          "description": "Render the list of polarity automaton paths as string",
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "prettyPolPaths",
          "normalized": "PolPathSet-\u003eText",
          "package": "GenI",
          "partial": "Pol Paths",
          "signature": "PolPathSet-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:prettyPolPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA (trivially) packed representation of the singleton\n   set containing a single polarity path\n\u003c/p\u003e",
          "module": "NLP.GenI.Polarity",
          "name": "singletonPolPath",
          "package": "GenI",
          "signature": "Int -\u003e PolPathSet",
          "source": "src/NLP-GenI-Polarity.html#singletonPolPath",
          "type": "function"
        },
        "index": {
          "description": "trivially packed representation of the singleton set containing single polarity path",
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "singletonPolPath",
          "normalized": "Int-\u003ePolPathSet",
          "package": "GenI",
          "partial": "Pol Path",
          "signature": "Int-\u003ePolPathSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:singletonPolPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "suggestPolFeatures",
          "package": "GenI",
          "signature": "[TagElem] -\u003e [Text]",
          "source": "src/NLP-GenI-Polarity.html#suggestPolFeatures",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "suggestPolFeatures",
          "normalized": "[TagElem]-\u003e[Text]",
          "package": "GenI",
          "partial": "Pol Features",
          "signature": "[TagElem]-\u003e[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:suggestPolFeatures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Polarity",
          "name": "unionPolPaths",
          "package": "GenI",
          "signature": "PolPathSet -\u003e PolPathSet -\u003e PolPathSet",
          "source": "src/NLP-GenI-Polarity.html#unionPolPaths",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Polarity",
          "module": "NLP.GenI.Polarity",
          "name": "unionPolPaths",
          "normalized": "PolPathSet-\u003ePolPathSet-\u003ePolPathSet",
          "package": "GenI",
          "partial": "Pol Paths",
          "signature": "PolPathSet-\u003ePolPathSet-\u003ePolPathSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Polarity.html#v:unionPolPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is not a proper pretty printer. I aim is to replace this with a\n   (de-facto) standard library if one should appear\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.Pretty",
          "name": "Pretty",
          "package": "GenI",
          "source": "src/NLP-GenI-Pretty.html",
          "type": "module"
        },
        "index": {
          "description": "This is not proper pretty printer aim is to replace this with de-facto standard library if one should appear",
          "hierarchy": "NLP GenI Pretty",
          "module": "NLP.GenI.Pretty",
          "name": "Pretty",
          "package": "GenI",
          "partial": "Pretty",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Pretty.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn alternative \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instance (the idea being that we\n   should reserve \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e for outputting actual Haskell)\n\u003c/p\u003e\u003cp\u003eMinimal implementation is \u003ccode\u003e\u003ca\u003epretty\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eprettyStr\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.Pretty",
          "name": "Pretty",
          "package": "GenI",
          "source": "src/NLP-GenI-Pretty.html#Pretty",
          "type": "class"
        },
        "index": {
          "description": "An alternative Show instance the idea being that we should reserve Show for outputting actual Haskell Minimal implementation is pretty or prettyStr",
          "hierarchy": "NLP GenI Pretty",
          "module": "NLP.GenI.Pretty",
          "name": "Pretty",
          "package": "GenI",
          "partial": "Pretty",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Pretty.html#t:Pretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSeparated by space unless one of them is empty (in which case just\n   the non-empty one)\n\u003c/p\u003e",
          "module": "NLP.GenI.Pretty",
          "name": "(\u003c+\u003e)",
          "package": "GenI",
          "signature": "Text -\u003e Text -\u003e Text",
          "source": "src/NLP-GenI-Pretty.html#%3C%2B%3E",
          "type": "function"
        },
        "index": {
          "description": "Separated by space unless one of them is empty in which case just the non-empty one",
          "hierarchy": "NLP GenI Pretty",
          "module": "NLP.GenI.Pretty",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "Text-\u003eText-\u003eText",
          "package": "GenI",
          "signature": "Text-\u003eText-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Pretty.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn infix synonym for \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "NLP.GenI.Pretty",
          "name": "(\u003c\u003e)",
          "package": "GenI",
          "signature": "m -\u003e m -\u003e m",
          "type": "function"
        },
        "index": {
          "description": "An infix synonym for mappend",
          "hierarchy": "NLP GenI Pretty",
          "module": "NLP.GenI.Pretty",
          "name": "(\u003c\u003e) \u003c\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "GenI",
          "signature": "m-\u003em-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Pretty.html#v:-60--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI think I want ($+$) here but I'm not sure I understand the\n   documentation from the pretty package.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003et1 \u003ccode\u003e\u003ca\u003eabove\u003c/a\u003e\u003c/code\u003e t2\u003c/code\u003e separates the two by a newline, unless one\n   of them is empty. The vertical equivalent to '(\u003ca\u003e+\u003c/a\u003e)'\n\u003c/p\u003e",
          "module": "NLP.GenI.Pretty",
          "name": "above",
          "package": "GenI",
          "signature": "Text -\u003e Text -\u003e Text",
          "source": "src/NLP-GenI-Pretty.html#above",
          "type": "function"
        },
        "index": {
          "description": "think want here but not sure understand the documentation from the pretty package t1 above t2 separates the two by newline unless one of them is empty The vertical equivalent to",
          "hierarchy": "NLP GenI Pretty",
          "module": "NLP.GenI.Pretty",
          "name": "above",
          "normalized": "Text-\u003eText-\u003eText",
          "package": "GenI",
          "signature": "Text-\u003eText-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Pretty.html#v:above"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003ebetween l r t == l \u003ca/\u003e t \u003ca/\u003e r\u003c/pre\u003e",
          "module": "NLP.GenI.Pretty",
          "name": "between",
          "package": "GenI",
          "signature": "Text -\u003e Text -\u003e Text -\u003e Text",
          "source": "src/NLP-GenI-Pretty.html#between",
          "type": "function"
        },
        "index": {
          "description": "between",
          "hierarchy": "NLP GenI Pretty",
          "module": "NLP.GenI.Pretty",
          "name": "between",
          "normalized": "Text-\u003eText-\u003eText-\u003eText",
          "package": "GenI",
          "signature": "Text-\u003eText-\u003eText-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Pretty.html#v:between"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eparens t\u003c/code\u003e puts \u003ccode\u003et\u003c/code\u003e between parentheses (\u003ccode\u003e()\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "NLP.GenI.Pretty",
          "name": "parens",
          "package": "GenI",
          "signature": "Text -\u003e Text",
          "source": "src/NLP-GenI-Pretty.html#parens",
          "type": "function"
        },
        "index": {
          "description": "parens puts between parentheses",
          "hierarchy": "NLP GenI Pretty",
          "module": "NLP.GenI.Pretty",
          "name": "parens",
          "normalized": "Text-\u003eText",
          "package": "GenI",
          "signature": "Text-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Pretty.html#v:parens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Pretty",
          "name": "pretty",
          "package": "GenI",
          "signature": "a -\u003e Text",
          "source": "src/NLP-GenI-Pretty.html#pretty",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI Pretty",
          "module": "NLP.GenI.Pretty",
          "name": "pretty",
          "normalized": "a-\u003eText",
          "package": "GenI",
          "signature": "a-\u003eText",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Pretty.html#v:pretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e prettyCount toBlah \"\"     (x,1) == \"blah\"\n prettyCount toBlah \"foos\" (x,1) == \"blah\"\n prettyCount toBlah \"\"     (x,4) == \"blah &#215;4\"\n prettyCount toBlah \"foos\" (x,4) == \"blah &#215;4 foos\"\n\u003c/pre\u003e",
          "module": "NLP.GenI.Pretty",
          "name": "prettyCount",
          "package": "GenI",
          "signature": "(a -\u003e Text) -\u003e Text -\u003e (a, Int) -\u003e Text",
          "source": "src/NLP-GenI-Pretty.html#prettyCount",
          "type": "function"
        },
        "index": {
          "description": "prettyCount toBlah blah prettyCount toBlah foos blah prettyCount toBlah blah prettyCount toBlah foos blah foos",
          "hierarchy": "NLP GenI Pretty",
          "module": "NLP.GenI.Pretty",
          "name": "prettyCount",
          "normalized": "(a-\u003eText)-\u003eText-\u003e(a,Int)-\u003eText",
          "package": "GenI",
          "partial": "Count",
          "signature": "(a-\u003eText)-\u003eText-\u003e(a,Int)-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Pretty.html#v:prettyCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Pretty",
          "name": "prettyStr",
          "package": "GenI",
          "signature": "a -\u003e String",
          "source": "src/NLP-GenI-Pretty.html#prettyStr",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI Pretty",
          "module": "NLP.GenI.Pretty",
          "name": "prettyStr",
          "normalized": "a-\u003eString",
          "package": "GenI",
          "partial": "Str",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Pretty.html#v:prettyStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esquares t\u003c/code\u003e puts \u003ccode\u003et\u003c/code\u003e between square brackets (\u003ccode\u003e[]\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "NLP.GenI.Pretty",
          "name": "squares",
          "package": "GenI",
          "signature": "Text -\u003e Text",
          "source": "src/NLP-GenI-Pretty.html#squares",
          "type": "function"
        },
        "index": {
          "description": "squares puts between square brackets",
          "hierarchy": "NLP GenI Pretty",
          "module": "NLP.GenI.Pretty",
          "name": "squares",
          "normalized": "Text-\u003eText",
          "package": "GenI",
          "signature": "Text-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Pretty.html#v:squares"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePuts list items on the same line if they are smaller than a certain width\n   otherwise, puts a newline in between them\n\u003c/p\u003e",
          "module": "NLP.GenI.Pretty",
          "name": "squeezed",
          "package": "GenI",
          "signature": "Int -\u003e [Text] -\u003e Text",
          "source": "src/NLP-GenI-Pretty.html#squeezed",
          "type": "function"
        },
        "index": {
          "description": "Puts list items on the same line if they are smaller than certain width otherwise puts newline in between them",
          "hierarchy": "NLP GenI Pretty",
          "module": "NLP.GenI.Pretty",
          "name": "squeezed",
          "normalized": "Int-\u003e[Text]-\u003eText",
          "package": "GenI",
          "signature": "Int-\u003e[Text]-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Pretty.html#v:squeezed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eWe use a flat semantics in GenI (bag of literals).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "Semantics",
          "package": "GenI",
          "source": "src/NLP-GenI-Semantics.html",
          "type": "module"
        },
        "index": {
          "description": "We use flat semantics in GenI bag of literals",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "Semantics",
          "package": "GenI",
          "partial": "Semantics",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnything that we would want to count the number constants in\n   (as opposed to variables)\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "HasConstants",
          "package": "GenI",
          "source": "src/NLP-GenI-Semantics.html#HasConstants",
          "type": "class"
        },
        "index": {
          "description": "Anything that we would want to count the number constants in as opposed to variables",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "HasConstants",
          "package": "GenI",
          "partial": "Has Constants",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#t:HasConstants"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal and any constraints associated with it (semantic input)\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "LitConstr",
          "package": "GenI",
          "source": "src/NLP-GenI-Semantics.html#LitConstr",
          "type": "type"
        },
        "index": {
          "description": "literal and any constraints associated with it semantic input",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "LitConstr",
          "package": "GenI",
          "partial": "Lit Constr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#t:LitConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single semantic literal containing its handle, predicate, and arguments\n\u003c/p\u003e\u003cp\u003eThis can be paramaterised on the kinds of variables it uses, for example,\n   \u003ccode\u003e\u003ca\u003eGeniVal\u003c/a\u003e\u003c/code\u003e for a semantics that you might still want to do unification on\n   or \u003ccode\u003eText\u003c/code\u003e if it's supposed to be ground.\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "Literal",
          "package": "GenI",
          "source": "src/NLP-GenI-Semantics.html#Literal",
          "type": "data"
        },
        "index": {
          "description": "single semantic literal containing its handle predicate and arguments This can be paramaterised on the kinds of variables it uses for example GeniVal for semantics that you might still want to do unification on or Text if it supposed to be ground",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "Literal",
          "package": "GenI",
          "partial": "Literal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#t:Literal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA semantics is just a set of literals.\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "Sem",
          "package": "GenI",
          "source": "src/NLP-GenI-Semantics.html#Sem",
          "type": "type"
        },
        "index": {
          "description": "semantics is just set of literals",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "Sem",
          "package": "GenI",
          "partial": "Sem",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#t:Sem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSemantics, index constraints, literal constraints\n\u003c/p\u003e\u003cp\u003eThe intention here is that for \u003ccode\u003e(sem, icons, lcons)\u003c/code\u003e\n   \u003ccode\u003eall (\u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e sem) lcons\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "SemInput",
          "package": "GenI",
          "source": "src/NLP-GenI-Semantics.html#SemInput",
          "type": "type"
        },
        "index": {
          "description": "Semantics index constraints literal constraints The intention here is that for sem icons lcons all elem sem lcons",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "SemInput",
          "package": "GenI",
          "partial": "Sem Input",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#t:SemInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Semantics",
          "name": "Literal",
          "package": "GenI",
          "signature": "Literal",
          "source": "src/NLP-GenI-Semantics.html#Literal",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "Literal",
          "package": "GenI",
          "partial": "Literal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:Literal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault comparison for a literal\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "compareOnLiteral",
          "package": "GenI",
          "signature": "Literal a -\u003e Literal a -\u003e Ordering",
          "source": "src/NLP-GenI-Semantics.html#compareOnLiteral",
          "type": "function"
        },
        "index": {
          "description": "Default comparison for literal",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "compareOnLiteral",
          "normalized": "Literal a-\u003eLiteral a-\u003eOrdering",
          "package": "GenI",
          "partial": "On Literal",
          "signature": "Literal a-\u003eLiteral a-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:compareOnLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of constants\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "constants",
          "package": "GenI",
          "signature": "a -\u003e Int",
          "source": "src/NLP-GenI-Semantics.html#constants",
          "type": "method"
        },
        "index": {
          "description": "Number of constants",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "constants",
          "normalized": "a-\u003eInt",
          "package": "GenI",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:constants"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper for displaying or pretty printing a semantic input\n\u003c/p\u003e\u003cp\u003eThis gives you a bit of control over how each literal is\n   displayed\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "displaySemInput",
          "package": "GenI",
          "signature": "([LitConstr] -\u003e Text) -\u003e SemInput -\u003e Text",
          "source": "src/NLP-GenI-Semantics.html#displaySemInput",
          "type": "function"
        },
        "index": {
          "description": "Helper for displaying or pretty printing semantic input This gives you bit of control over how each literal is displayed",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "displaySemInput",
          "normalized": "([LitConstr]-\u003eText)-\u003eSemInput-\u003eText",
          "package": "GenI",
          "partial": "Sem Input",
          "signature": "([LitConstr]-\u003eText)-\u003eSemInput-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:displaySemInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn empty literal, not sure you should really be using this\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "emptyLiteral",
          "package": "GenI",
          "signature": "Literal GeniVal",
          "source": "src/NLP-GenI-Semantics.html#emptyLiteral",
          "type": "function"
        },
        "index": {
          "description": "An empty literal not sure you should really be using this",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "emptyLiteral",
          "package": "GenI",
          "partial": "Literal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:emptyLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs a handle generated by GenI. GenI lets you write literals without\n   a handle; in these cases a unique handle is generated and hidden\n   from the UI.\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "isInternalHandle",
          "package": "GenI",
          "signature": "Text -\u003e Bool",
          "source": "src/NLP-GenI-Semantics.html#isInternalHandle",
          "type": "function"
        },
        "index": {
          "description": "Is handle generated by GenI GenI lets you write literals without handle in these cases unique handle is generated and hidden from the UI",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "isInternalHandle",
          "normalized": "Text-\u003eBool",
          "package": "GenI",
          "partial": "Internal Handle",
          "signature": "Text-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:isInternalHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Semantics",
          "name": "lArgs",
          "package": "GenI",
          "signature": "[gv]",
          "source": "src/NLP-GenI-Semantics.html#Literal",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "lArgs",
          "normalized": "[a]",
          "package": "GenI",
          "partial": "Args",
          "signature": "[gv]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:lArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe handle can be seen as a special kind of argument; stored separately\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "lHandle",
          "package": "GenI",
          "signature": "gv",
          "source": "src/NLP-GenI-Semantics.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "the handle can be seen as special kind of argument stored separately",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "lHandle",
          "package": "GenI",
          "partial": "Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:lHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Semantics",
          "name": "lPredicate",
          "package": "GenI",
          "signature": "gv",
          "source": "src/NLP-GenI-Semantics.html#Literal",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "lPredicate",
          "package": "GenI",
          "partial": "Predicate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:lPredicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrip any index or literal constraints from an input.\n   Use with care.\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "removeConstraints",
          "package": "GenI",
          "signature": "SemInput -\u003e SemInput",
          "source": "src/NLP-GenI-Semantics.html#removeConstraints",
          "type": "function"
        },
        "index": {
          "description": "Strip any index or literal constraints from an input Use with care",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "removeConstraints",
          "normalized": "SemInput-\u003eSemInput",
          "package": "GenI",
          "partial": "Constraints",
          "signature": "SemInput-\u003eSemInput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:removeConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSort primarily putting the ones with the most constants first\n and secondarily by the number of instances a predicate occurs\n (if plain string; atomic disjunction/vars treated as infinite)\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "sortByAmbiguity",
          "package": "GenI",
          "signature": "Sem -\u003e Sem",
          "source": "src/NLP-GenI-Semantics.html#sortByAmbiguity",
          "type": "function"
        },
        "index": {
          "description": "Sort primarily putting the ones with the most constants first and secondarily by the number of instances predicate occurs if plain string atomic disjunction vars treated as infinite",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "sortByAmbiguity",
          "normalized": "Sem-\u003eSem",
          "package": "GenI",
          "partial": "By Ambiguity",
          "signature": "Sem-\u003eSem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:sortByAmbiguity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault sorting for a semantics\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "sortSem",
          "package": "GenI",
          "signature": "[Literal a] -\u003e [Literal a]",
          "source": "src/NLP-GenI-Semantics.html#sortSem",
          "type": "function"
        },
        "index": {
          "description": "Default sorting for semantics",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "sortSem",
          "normalized": "[Literal a]-\u003e[Literal a]",
          "package": "GenI",
          "partial": "Sem",
          "signature": "[Literal a]-\u003e[Literal a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:sortSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ep1 \u003ccode\u003e\u003ca\u003esubsumeLiteral\u003c/a\u003e\u003c/code\u003e p2\u003c/code\u003e is the unification of \u003ccode\u003ep1\u003c/code\u003e and \u003ccode\u003ep2\u003c/code\u003e if\n   both literals have the same arity, and the handles, predicates,\n   and arguments in \u003ccode\u003ep1\u003c/code\u003e all subsume their counterparts in \u003ccode\u003ep2\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "subsumeLiteral",
          "package": "GenI",
          "signature": "Literal GeniVal -\u003e Literal GeniVal -\u003e m (Literal GeniVal, Subst)",
          "source": "src/NLP-GenI-Semantics.html#subsumeLiteral",
          "type": "function"
        },
        "index": {
          "description": "p1 subsumeLiteral p2 is the unification of p1 and p2 if both literals have the same arity and the handles predicates and arguments in p1 all subsume their counterparts in p2",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "subsumeLiteral",
          "normalized": "Literal GeniVal-\u003eLiteral GeniVal-\u003ea(Literal GeniVal,Subst)",
          "package": "GenI",
          "partial": "Literal",
          "signature": "Literal GeniVal-\u003eLiteral GeniVal-\u003em(Literal GeniVal,Subst)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:subsumeLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ex \u003ccode\u003e\u003ca\u003esubsumeSem\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e returns all the possible ways to unify\n   \u003ccode\u003ex\u003c/code\u003e with some SUBSET of \u003ccode\u003ey\u003c/code\u003e so that \u003ccode\u003ex\u003c/code\u003e subsumes \u003ccode\u003ey\u003c/code\u003e.\n   If \u003ccode\u003ex\u003c/code\u003e does NOT subsume \u003ccode\u003ey\u003c/code\u003e, we return the empty list.\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "subsumeSem",
          "package": "GenI",
          "signature": "Sem -\u003e Sem -\u003e [(Sem, Subst)]",
          "source": "src/NLP-GenI-Semantics.html#subsumeSem",
          "type": "function"
        },
        "index": {
          "description": "subsumeSem returns all the possible ways to unify with some SUBSET of so that subsumes If does NOT subsume we return the empty list",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "subsumeSem",
          "normalized": "Sem-\u003eSem-\u003e[(Sem,Subst)]",
          "package": "GenI",
          "partial": "Sem",
          "signature": "Sem-\u003eSem-\u003e[(Sem,Subst)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:subsumeSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper for \u003ccode\u003e\u003ca\u003esubsumeSem\u003c/a\u003e\u003c/code\u003e traversal\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "subsumeSemH",
          "package": "GenI",
          "signature": "Sem -\u003e Sem -\u003e [(Sem, Subst)]",
          "source": "src/NLP-GenI-Semantics.html#subsumeSemH",
          "type": "function"
        },
        "index": {
          "description": "Helper for subsumeSem traversal",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "subsumeSemH",
          "normalized": "Sem-\u003eSem-\u003e[(Sem,Subst)]",
          "package": "GenI",
          "partial": "Sem",
          "signature": "Sem-\u003eSem-\u003e[(Sem,Subst)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:subsumeSemH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo literals unify if they have the same arity, and their\n   handles, predicates, and arguments also unify\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "unifyLiteral",
          "package": "GenI",
          "signature": "Literal GeniVal -\u003e Literal GeniVal -\u003e m (Literal GeniVal, Subst)",
          "source": "src/NLP-GenI-Semantics.html#unifyLiteral",
          "type": "function"
        },
        "index": {
          "description": "Two literals unify if they have the same arity and their handles predicates and arguments also unify",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "unifyLiteral",
          "normalized": "Literal GeniVal-\u003eLiteral GeniVal-\u003ea(Literal GeniVal,Subst)",
          "package": "GenI",
          "partial": "Literal",
          "signature": "Literal GeniVal-\u003eLiteral GeniVal-\u003em(Literal GeniVal,Subst)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:unifyLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the list of minimal ways to unify two semantics, ie.\n where any literals that are not the product of a succesful unification\n really do not unify with anything else.\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "unifySem",
          "package": "GenI",
          "signature": "Sem -\u003e Sem -\u003e [(Sem, Subst)]",
          "source": "src/NLP-GenI-Semantics.html#unifySem",
          "type": "function"
        },
        "index": {
          "description": "Return the list of minimal ways to unify two semantics ie where any literals that are not the product of succesful unification really do not unify with anything else",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "unifySem",
          "normalized": "Sem-\u003eSem-\u003e[(Sem,Subst)]",
          "package": "GenI",
          "partial": "Sem",
          "signature": "Sem-\u003eSem-\u003e[(Sem,Subst)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:unifySem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper traversal for \u003ccode\u003e\u003ca\u003eunifySem\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI.Semantics",
          "name": "unifySemH",
          "package": "GenI",
          "signature": "Sem -\u003e Sem -\u003e [(Sem, Subst)]",
          "source": "src/NLP-GenI-Semantics.html#unifySemH",
          "type": "function"
        },
        "index": {
          "description": "Helper traversal for unifySem",
          "hierarchy": "NLP GenI Semantics",
          "module": "NLP.GenI.Semantics",
          "name": "unifySemH",
          "normalized": "Sem-\u003eSem-\u003e[(Sem,Subst)]",
          "package": "GenI",
          "partial": "Sem",
          "signature": "Sem-\u003eSem-\u003e[(Sem,Subst)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Semantics.html#v:unifySemH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "SimpleBuilder",
          "package": "GenI",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "SimpleBuilder",
          "package": "GenI",
          "partial": "Simple Builder",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "Agenda",
          "package": "GenI",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#Agenda",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "Agenda",
          "package": "GenI",
          "partial": "Agenda",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#t:Agenda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "AuxAgenda",
          "package": "GenI",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#AuxAgenda",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "AuxAgenda",
          "package": "GenI",
          "partial": "Aux Agenda",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#t:AuxAgenda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "Chart",
          "package": "GenI",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#Chart",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "Chart",
          "package": "GenI",
          "partial": "Chart",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#t:Chart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThings whose only use is within the graphical debugger\n\u003c/p\u003e",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "SimpleGuiItem",
          "package": "GenI",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleGuiItem",
          "type": "data"
        },
        "index": {
          "description": "Things whose only use is within the graphical debugger",
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "SimpleGuiItem",
          "package": "GenI",
          "partial": "Simple Gui Item",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#t:SimpleGuiItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "SimpleItem",
          "package": "GenI",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleItem",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "SimpleItem",
          "package": "GenI",
          "partial": "Simple Item",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#t:SimpleItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "SimpleState",
          "package": "GenI",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleState",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "SimpleState",
          "package": "GenI",
          "partial": "Simple State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#t:SimpleState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "SimpleStatus",
          "package": "GenI",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleStatus",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "SimpleStatus",
          "package": "GenI",
          "partial": "Simple Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#t:SimpleStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "SimpleGuiItem",
          "package": "GenI",
          "signature": "SimpleGuiItem",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleGuiItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "SimpleGuiItem",
          "package": "GenI",
          "partial": "Simple Gui Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:SimpleGuiItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "SimpleItem",
          "package": "GenI",
          "signature": "SimpleItem",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "SimpleItem",
          "package": "GenI",
          "partial": "Simple Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:SimpleItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "addToAgenda",
          "package": "GenI",
          "signature": "SimpleItem -\u003e SimpleState ()",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#addToAgenda",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "addToAgenda",
          "normalized": "SimpleItem-\u003eSimpleState()",
          "package": "GenI",
          "partial": "To Agenda",
          "signature": "SimpleItem-\u003eSimpleState()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:addToAgenda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "addToChart",
          "package": "GenI",
          "signature": "SimpleItem -\u003e SimpleState ()",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#addToChart",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "addToChart",
          "normalized": "SimpleItem-\u003eSimpleState()",
          "package": "GenI",
          "partial": "To Chart",
          "signature": "SimpleItem-\u003eSimpleState()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:addToChart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "genconfig",
          "package": "GenI",
          "signature": "SimpleStatus -\u003e [Flag]",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#genconfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "genconfig",
          "normalized": "SimpleStatus-\u003e[Flag]",
          "package": "GenI",
          "signature": "SimpleStatus-\u003e[Flag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:genconfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates an initial SimpleStatus.\n\u003c/p\u003e",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "initSimpleBuilder",
          "package": "GenI",
          "signature": "Bool-\u003e Input-\u003e [Flag]-\u003e (SimpleStatus, Statistics)",
          "type": "function"
        },
        "index": {
          "description": "Creates an initial SimpleStatus",
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "initSimpleBuilder",
          "normalized": "Bool-\u003eInput-\u003e[Flag]-\u003e(SimpleStatus,Statistics)",
          "package": "GenI",
          "partial": "Simple Builder",
          "signature": "Bool-\u003eInput-\u003e[Flag]-\u003e(SimpleStatus,Statistics)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:initSimpleBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siAdjnodes",
          "package": "GenI",
          "signature": "[NodeName]",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siAdjnodes",
          "normalized": "[NodeName]",
          "package": "GenI",
          "partial": "Adjnodes",
          "signature": "[NodeName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siAdjnodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siDerivation",
          "package": "GenI",
          "signature": "TagDerivation",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siDerivation",
          "package": "GenI",
          "partial": "Derivation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siDerivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siDerived",
          "package": "GenI",
          "signature": "Tree Text",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siDerived",
          "package": "GenI",
          "partial": "Derived",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siDerived"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siDiagnostic",
          "package": "GenI",
          "signature": "[Text]",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleGuiItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siDiagnostic",
          "normalized": "[Text]",
          "package": "GenI",
          "partial": "Diagnostic",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siDiagnostic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siFoot_",
          "package": "GenI",
          "signature": "Maybe NodeName",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siFoot_",
          "package": "GenI",
          "partial": "Foot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siFoot_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siFullSem",
          "package": "GenI",
          "signature": "Sem",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleGuiItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siFullSem",
          "package": "GenI",
          "partial": "Full Sem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siFullSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siGuiStuff",
          "package": "GenI",
          "signature": "SimpleGuiItem",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siGuiStuff",
          "package": "GenI",
          "partial": "Gui Stuff",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siGuiStuff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enodes to highlight\n if there are things wrong with this item, what?\n\u003c/p\u003e",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siHighlight",
          "package": "GenI",
          "signature": "[Text]",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleGuiItem",
          "type": "function"
        },
        "index": {
          "description": "nodes to highlight if there are things wrong with this item what",
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siHighlight",
          "normalized": "[Text]",
          "package": "GenI",
          "partial": "Highlight",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siHighlight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siId",
          "package": "GenI",
          "signature": "ChartId",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siId",
          "package": "GenI",
          "partial": "Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siIdname",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleGuiItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siIdname",
          "package": "GenI",
          "partial": "Idname",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siIdname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eactually a set\n\u003c/p\u003e",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siNodes",
          "package": "GenI",
          "signature": "[GNode GeniVal]",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleItem",
          "type": "function"
        },
        "index": {
          "description": "actually set",
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siNodes",
          "normalized": "[GNode GeniVal]",
          "package": "GenI",
          "partial": "Nodes",
          "signature": "[GNode GeniVal]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siPendingTb",
          "package": "GenI",
          "signature": "[NodeName]",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siPendingTb",
          "normalized": "[NodeName]",
          "package": "GenI",
          "partial": "Pending Tb",
          "signature": "[NodeName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siPendingTb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siPolpaths",
          "package": "GenI",
          "signature": "PolPathSet",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siPolpaths",
          "package": "GenI",
          "partial": "Polpaths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siPolpaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siRoot_",
          "package": "GenI",
          "signature": "NodeName",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siRoot_",
          "package": "GenI",
          "partial": "Root",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siRoot_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siSemantics",
          "package": "GenI",
          "signature": "BitVector",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siSemantics",
          "package": "GenI",
          "partial": "Semantics",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siSemantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siSubstnodes",
          "package": "GenI",
          "signature": "[NodeName]",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#SimpleItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "siSubstnodes",
          "normalized": "[NodeName]",
          "package": "GenI",
          "partial": "Substnodes",
          "signature": "[NodeName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:siSubstnodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "simpleBuilder",
          "package": "GenI",
          "signature": "Bool -\u003e SimpleBuilder",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#simpleBuilder",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "simpleBuilder",
          "normalized": "Bool-\u003eSimpleBuilder",
          "package": "GenI",
          "partial": "Builder",
          "signature": "Bool-\u003eSimpleBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:simpleBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "simpleBuilder_1p",
          "package": "GenI",
          "signature": "SimpleBuilder",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#simpleBuilder_1p",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "simpleBuilder_1p",
          "package": "GenI",
          "partial": "Builder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:simpleBuilder_1p"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "simpleBuilder_2p",
          "package": "GenI",
          "signature": "SimpleBuilder",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#simpleBuilder_2p",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "simpleBuilder_2p",
          "package": "GenI",
          "partial": "Builder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:simpleBuilder_2p"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "step",
          "package": "GenI",
          "signature": "SimpleStatus -\u003e GenerationPhase",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#step",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "step",
          "normalized": "SimpleStatus-\u003eGenerationPhase",
          "package": "GenI",
          "signature": "SimpleStatus-\u003eGenerationPhase",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "testCanAdjoin",
          "package": "GenI",
          "signature": "SimpleItem -\u003e TagSite -\u003e Maybe (TagSite, TagSite, Subst)",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#testCanAdjoin",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "testCanAdjoin",
          "normalized": "SimpleItem-\u003eTagSite-\u003eMaybe(TagSite,TagSite,Subst)",
          "package": "GenI",
          "partial": "Can Adjoin",
          "signature": "SimpleItem-\u003eTagSite-\u003eMaybe(TagSite,TagSite,Subst)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:testCanAdjoin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "testEmptySimpleGuiItem",
          "package": "GenI",
          "signature": "SimpleGuiItem",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#testEmptySimpleGuiItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "testEmptySimpleGuiItem",
          "package": "GenI",
          "partial": "Empty Simple Gui Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:testEmptySimpleGuiItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "testIapplyAdjNode",
          "package": "GenI",
          "signature": "Bool -\u003e SimpleItem -\u003e SimpleItem -\u003e Maybe SimpleItem",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#testIapplyAdjNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "testIapplyAdjNode",
          "normalized": "Bool-\u003eSimpleItem-\u003eSimpleItem-\u003eMaybe SimpleItem",
          "package": "GenI",
          "partial": "Iapply Adj Node",
          "signature": "Bool-\u003eSimpleItem-\u003eSimpleItem-\u003eMaybe SimpleItem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:testIapplyAdjNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "theAgenda",
          "package": "GenI",
          "signature": "SimpleStatus -\u003e Agenda",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#theAgenda",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "theAgenda",
          "normalized": "SimpleStatus-\u003eAgenda",
          "package": "GenI",
          "partial": "Agenda",
          "signature": "SimpleStatus-\u003eAgenda",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:theAgenda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "theChart",
          "package": "GenI",
          "signature": "SimpleStatus -\u003e Chart",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#theChart",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "theChart",
          "normalized": "SimpleStatus-\u003eChart",
          "package": "GenI",
          "partial": "Chart",
          "signature": "SimpleStatus-\u003eChart",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:theChart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "theHoldingPen",
          "package": "GenI",
          "signature": "SimpleStatus -\u003e AuxAgenda",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#theHoldingPen",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "theHoldingPen",
          "normalized": "SimpleStatus-\u003eAuxAgenda",
          "package": "GenI",
          "partial": "Holding Pen",
          "signature": "SimpleStatus-\u003eAuxAgenda",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:theHoldingPen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "theResults",
          "package": "GenI",
          "signature": "SimpleStatus -\u003e [SimpleItem]",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#theResults",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "theResults",
          "normalized": "SimpleStatus-\u003e[SimpleItem]",
          "package": "GenI",
          "partial": "Results",
          "signature": "SimpleStatus-\u003e[SimpleItem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:theResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "theTrash",
          "package": "GenI",
          "signature": "SimpleStatus -\u003e Trash",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#theTrash",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "theTrash",
          "normalized": "SimpleStatus-\u003eTrash",
          "package": "GenI",
          "partial": "Trash",
          "signature": "SimpleStatus-\u003eTrash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:theTrash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "unpackResult",
          "package": "GenI",
          "signature": "SimpleItem -\u003e [Output]",
          "source": "src/NLP-GenI-Simple-SimpleBuilder.html#unpackResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Simple SimpleBuilder",
          "module": "NLP.GenI.Simple.SimpleBuilder",
          "name": "unpackResult",
          "normalized": "SimpleItem-\u003e[Output]",
          "package": "GenI",
          "partial": "Result",
          "signature": "SimpleItem-\u003e[Output]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Simple-SimpleBuilder.html#v:unpackResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Statistics",
          "name": "Statistics",
          "package": "GenI",
          "source": "src/NLP-GenI-Statistics.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI Statistics",
          "module": "NLP.GenI.Statistics",
          "name": "Statistics",
          "package": "GenI",
          "partial": "Statistics",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Statistics.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Statistics",
          "name": "Metric",
          "package": "GenI",
          "source": "src/NLP-GenI-Statistics.html#Metric",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Statistics",
          "module": "NLP.GenI.Statistics",
          "name": "Metric",
          "package": "GenI",
          "partial": "Metric",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Statistics.html#t:Metric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Statistics",
          "name": "Statistics",
          "package": "GenI",
          "source": "src/NLP-GenI-Statistics.html#Statistics",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Statistics",
          "module": "NLP.GenI.Statistics",
          "name": "Statistics",
          "package": "GenI",
          "partial": "Statistics",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Statistics.html#t:Statistics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Statistics",
          "name": "StatisticsState",
          "package": "GenI",
          "source": "src/NLP-GenI-Statistics.html#StatisticsState",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Statistics",
          "module": "NLP.GenI.Statistics",
          "name": "StatisticsState",
          "package": "GenI",
          "partial": "Statistics State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Statistics.html#t:StatisticsState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Statistics",
          "name": "IntMetric",
          "package": "GenI",
          "signature": "IntMetric String Int",
          "source": "src/NLP-GenI-Statistics.html#Metric",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Statistics",
          "module": "NLP.GenI.Statistics",
          "name": "IntMetric",
          "package": "GenI",
          "partial": "Int Metric",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Statistics.html#v:IntMetric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdds a metric at the beginning of the list\n   (note we reverse the order whene we want to print the metrics)\n\u003c/p\u003e",
          "module": "NLP.GenI.Statistics",
          "name": "addMetric",
          "package": "GenI",
          "signature": "Metric -\u003e StatisticsState ()",
          "source": "src/NLP-GenI-Statistics.html#addMetric",
          "type": "function"
        },
        "index": {
          "description": "Adds metric at the beginning of the list note we reverse the order whene we want to print the metrics",
          "hierarchy": "NLP GenI Statistics",
          "module": "NLP.GenI.Statistics",
          "name": "addMetric",
          "normalized": "Metric-\u003eStatisticsState()",
          "package": "GenI",
          "partial": "Metric",
          "signature": "Metric-\u003eStatisticsState()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Statistics.html#v:addMetric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Statistics",
          "name": "emptyStats",
          "package": "GenI",
          "signature": "Statistics",
          "source": "src/NLP-GenI-Statistics.html#emptyStats",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Statistics",
          "module": "NLP.GenI.Statistics",
          "name": "emptyStats",
          "package": "GenI",
          "partial": "Stats",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Statistics.html#v:emptyStats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Statistics",
          "name": "incrIntMetric",
          "package": "GenI",
          "signature": "String -\u003e Int -\u003e Metric -\u003e Metric",
          "source": "src/NLP-GenI-Statistics.html#incrIntMetric",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Statistics",
          "module": "NLP.GenI.Statistics",
          "name": "incrIntMetric",
          "normalized": "String-\u003eInt-\u003eMetric-\u003eMetric",
          "package": "GenI",
          "partial": "Int Metric",
          "signature": "String-\u003eInt-\u003eMetric-\u003eMetric",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Statistics.html#v:incrIntMetric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Statistics",
          "name": "initialStatisticsStateFor",
          "package": "GenI",
          "signature": "(m a -\u003e Statistics -\u003e b) -\u003e m a -\u003e b",
          "source": "src/NLP-GenI-Statistics.html#initialStatisticsStateFor",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Statistics",
          "module": "NLP.GenI.Statistics",
          "name": "initialStatisticsStateFor",
          "normalized": "(a b-\u003eStatistics-\u003ec)-\u003ea b-\u003ec",
          "package": "GenI",
          "partial": "Statistics State For",
          "signature": "(m a-\u003eStatistics-\u003eb)-\u003em a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Statistics.html#v:initialStatisticsStateFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Statistics",
          "name": "queryIntMetric",
          "package": "GenI",
          "signature": "String -\u003e Metric -\u003e Maybe Int",
          "source": "src/NLP-GenI-Statistics.html#queryIntMetric",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Statistics",
          "module": "NLP.GenI.Statistics",
          "name": "queryIntMetric",
          "normalized": "String-\u003eMetric-\u003eMaybe Int",
          "package": "GenI",
          "partial": "Int Metric",
          "signature": "String-\u003eMetric-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Statistics.html#v:queryIntMetric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Statistics",
          "name": "queryMetrics",
          "package": "GenI",
          "signature": "(Metric -\u003e Maybe a) -\u003e Statistics -\u003e [a]",
          "source": "src/NLP-GenI-Statistics.html#queryMetrics",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Statistics",
          "module": "NLP.GenI.Statistics",
          "name": "queryMetrics",
          "normalized": "(Metric-\u003eMaybe a)-\u003eStatistics-\u003e[a]",
          "package": "GenI",
          "partial": "Metrics",
          "signature": "(Metric-\u003eMaybe a)-\u003eStatistics-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Statistics.html#v:queryMetrics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Statistics",
          "name": "showFinalStats",
          "package": "GenI",
          "signature": "Statistics -\u003e String",
          "source": "src/NLP-GenI-Statistics.html#showFinalStats",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Statistics",
          "module": "NLP.GenI.Statistics",
          "name": "showFinalStats",
          "normalized": "Statistics-\u003eString",
          "package": "GenI",
          "partial": "Final Stats",
          "signature": "Statistics-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Statistics.html#v:showFinalStats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Statistics",
          "name": "updateMetrics",
          "package": "GenI",
          "signature": "(Metric -\u003e Metric) -\u003e Statistics -\u003e Statistics",
          "source": "src/NLP-GenI-Statistics.html#updateMetrics",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Statistics",
          "module": "NLP.GenI.Statistics",
          "name": "updateMetrics",
          "normalized": "(Metric-\u003eMetric)-\u003eStatistics-\u003eStatistics",
          "package": "GenI",
          "partial": "Metrics",
          "signature": "(Metric-\u003eMetric)-\u003eStatistics-\u003eStatistics",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Statistics.html#v:updateMetrics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides basic datatypes specific to Tree Adjoining Grammar\n (TAG) elementary trees and some low-level operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.Tag",
          "name": "Tag",
          "package": "GenI",
          "source": "src/NLP-GenI-Tag.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides basic datatypes specific to Tree Adjoining Grammar TAG elementary trees and some low-level operations",
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "Tag",
          "package": "GenI",
          "partial": "Tag",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "DerivationStep",
          "package": "GenI",
          "source": "src/NLP-GenI-Tag.html#DerivationStep",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "DerivationStep",
          "package": "GenI",
          "partial": "Derivation Step",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#t:DerivationStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "TagDerivation",
          "package": "GenI",
          "source": "src/NLP-GenI-Tag.html#TagDerivation",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "TagDerivation",
          "package": "GenI",
          "partial": "Tag Derivation",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#t:TagDerivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "TagElem",
          "package": "GenI",
          "source": "src/NLP-GenI-Tag.html#TagElem",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "TagElem",
          "package": "GenI",
          "partial": "Tag Elem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#t:TagElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTagItem\u003c/a\u003e\u003c/code\u003e is a generalisation of \u003ccode\u003e\u003ca\u003eTagElem\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "NLP.GenI.Tag",
          "name": "TagItem",
          "package": "GenI",
          "source": "src/NLP-GenI-Tag.html#TagItem",
          "type": "class"
        },
        "index": {
          "description": "TagItem is generalisation of TagElem",
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "TagItem",
          "package": "GenI",
          "partial": "Tag Item",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#t:TagItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "TagSite",
          "package": "GenI",
          "source": "src/NLP-GenI-Tag.html#TagSite",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "TagSite",
          "package": "GenI",
          "partial": "Tag Site",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#t:TagSite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn anchored grammar.\n   The grammar associates a set of semantic predicates to a list of trees each.\n\u003c/p\u003e",
          "module": "NLP.GenI.Tag",
          "name": "Tags",
          "package": "GenI",
          "source": "src/NLP-GenI-Tag.html#Tags",
          "type": "type"
        },
        "index": {
          "description": "An anchored grammar The grammar associates set of semantic predicates to list of trees each",
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "Tags",
          "package": "GenI",
          "partial": "Tags",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#t:Tags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "AdjunctionStep",
          "package": "GenI",
          "signature": "AdjunctionStep Text Text Text",
          "source": "src/NLP-GenI-Tag.html#DerivationStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "AdjunctionStep",
          "package": "GenI",
          "partial": "Adjunction Step",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:AdjunctionStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "InitStep",
          "package": "GenI",
          "signature": "InitStep Text",
          "source": "src/NLP-GenI-Tag.html#DerivationStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "InitStep",
          "package": "GenI",
          "partial": "Init Step",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:InitStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "SubstitutionStep",
          "package": "GenI",
          "signature": "SubstitutionStep Text Text Text",
          "source": "src/NLP-GenI-Tag.html#DerivationStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "SubstitutionStep",
          "package": "GenI",
          "partial": "Substitution Step",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:SubstitutionStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "TE",
          "package": "GenI",
          "signature": "TE",
          "source": "src/NLP-GenI-Tag.html#TagElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "TE",
          "package": "GenI",
          "partial": "TE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:TE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "TagSite",
          "package": "GenI",
          "signature": "TagSite",
          "source": "src/NLP-GenI-Tag.html#TagSite",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "TagSite",
          "package": "GenI",
          "partial": "Tag Site",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:TagSite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eaddTags\u003c/code\u003e \u003ccode\u003etags key elem\u003c/code\u003e adds \u003ccode\u003eelem\u003c/code\u003e to the the list of elements associated\n   to the key\n\u003c/p\u003e",
          "module": "NLP.GenI.Tag",
          "name": "addToTags",
          "package": "GenI",
          "signature": "Tags -\u003e String -\u003e TagElem -\u003e Tags",
          "source": "src/NLP-GenI-Tag.html#addToTags",
          "type": "function"
        },
        "index": {
          "description": "addTags tags key elem adds elem to the the list of elements associated to the key",
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "addToTags",
          "normalized": "Tags-\u003eString-\u003eTagElem-\u003eTags",
          "package": "GenI",
          "partial": "To Tags",
          "signature": "Tags-\u003eString-\u003eTagElem-\u003eTags",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:addToTags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecollect x m\u003c/code\u003e increments our count for any variables in \u003ccode\u003ex\u003c/code\u003e\n   (adds not-yet-seen variables as needed)\n\u003c/p\u003e",
          "module": "NLP.GenI.Tag",
          "name": "collect",
          "package": "GenI",
          "signature": "a -\u003e Map CollectedVar Int -\u003e Map CollectedVar Int",
          "source": "src/NLP-GenI-GeniVal-Internal.html#collect",
          "type": "function"
        },
        "index": {
          "description": "collect increments our count for any variables in adds not-yet-seen variables as needed",
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "collect",
          "normalized": "a-\u003eMap CollectedVar Int-\u003eMap CollectedVar Int",
          "package": "GenI",
          "signature": "a-\u003eMap CollectedVar Int-\u003eMap CollectedVar Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:collect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a tree(GNode) returns a list of substitution or adjunction\n   nodes, as well as remaining nodes with a null adjunction constraint.\n\u003c/p\u003e",
          "module": "NLP.GenI.Tag",
          "name": "detectSites",
          "package": "GenI",
          "signature": "Tree (GNode GeniVal) -\u003e ([NodeName], [NodeName], [NodeName])",
          "source": "src/NLP-GenI-Tag.html#detectSites",
          "type": "function"
        },
        "index": {
          "description": "Given tree GNode returns list of substitution or adjunction nodes as well as remaining nodes with null adjunction constraint",
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "detectSites",
          "normalized": "Tree(GNode GeniVal)-\u003e([NodeName],[NodeName],[NodeName])",
          "package": "GenI",
          "partial": "Sites",
          "signature": "Tree(GNode GeniVal)-\u003e([NodeName],[NodeName],[NodeName])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:detectSites"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "dsChild",
          "package": "GenI",
          "signature": "DerivationStep -\u003e Text",
          "source": "src/NLP-GenI-Tag.html#dsChild",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "dsChild",
          "normalized": "DerivationStep-\u003eText",
          "package": "GenI",
          "partial": "Child",
          "signature": "DerivationStep-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:dsChild"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "dsParent",
          "package": "GenI",
          "signature": "DerivationStep -\u003e Maybe Text",
          "source": "src/NLP-GenI-Tag.html#dsParent",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "dsParent",
          "normalized": "DerivationStep-\u003eMaybe Text",
          "package": "GenI",
          "partial": "Parent",
          "signature": "DerivationStep-\u003eMaybe Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:dsParent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "dsParentSite",
          "package": "GenI",
          "signature": "DerivationStep -\u003e Maybe Text",
          "source": "src/NLP-GenI-Tag.html#dsParentSite",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "dsParentSite",
          "normalized": "DerivationStep-\u003eMaybe Text",
          "package": "GenI",
          "partial": "Parent Site",
          "signature": "DerivationStep-\u003eMaybe Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:dsParentSite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry in order: lexeme, lexeme attributes, node name\n\u003c/p\u003e",
          "module": "NLP.GenI.Tag",
          "name": "getLexeme",
          "package": "GenI",
          "signature": "GNode GeniVal -\u003e [Text]",
          "source": "src/NLP-GenI-Tag.html#getLexeme",
          "type": "function"
        },
        "index": {
          "description": "Try in order lexeme lexeme attributes node name",
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "getLexeme",
          "normalized": "GNode GeniVal-\u003e[Text]",
          "package": "GenI",
          "partial": "Lexeme",
          "signature": "GNode GeniVal-\u003e[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:getLexeme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "idname",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-Tag.html#TagElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "idname",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:idname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSorts trees into a Map.Map organised by the first literal of their\n   semantics.  This is useful in at least three places: the polarity\n   optimisation, the gui display code, and code for measuring the efficiency\n   of GenI.  Note: trees with a null semantics are filed under an empty\n   predicate, if any.\n\u003c/p\u003e",
          "module": "NLP.GenI.Tag",
          "name": "mapBySem",
          "package": "GenI",
          "signature": "[t] -\u003e Map (Literal GeniVal) [t]",
          "source": "src/NLP-GenI-Tag.html#mapBySem",
          "type": "function"
        },
        "index": {
          "description": "Sorts trees into Map.Map organised by the first literal of their semantics This is useful in at least three places the polarity optimisation the gui display code and code for measuring the efficiency of GenI Note trees with null semantics are filed under an empty predicate if any",
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "mapBySem",
          "normalized": "[a]-\u003eMap(Literal GeniVal)[a]",
          "package": "GenI",
          "partial": "By Sem",
          "signature": "[t]-\u003eMap(Literal GeniVal)[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:mapBySem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePlug the first tree into the second tree at the specified node.\n   Anything below the second node is silently discarded.\n   We assume the trees are pluggable; it is treated as a bug if\n   they are not!\n\u003c/p\u003e",
          "module": "NLP.GenI.Tag",
          "name": "plugTree",
          "package": "GenI",
          "signature": "Tree NodeName -\u003e NodeName -\u003e Tree NodeName -\u003e Tree NodeName",
          "source": "src/NLP-GenI-Tag.html#plugTree",
          "type": "function"
        },
        "index": {
          "description": "Plug the first tree into the second tree at the specified node Anything below the second node is silently discarded We assume the trees are pluggable it is treated as bug if they are not",
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "plugTree",
          "normalized": "Tree NodeName-\u003eNodeName-\u003eTree NodeName-\u003eTree NodeName",
          "package": "GenI",
          "partial": "Tree",
          "signature": "Tree NodeName-\u003eNodeName-\u003eTree NodeName-\u003eTree NodeName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:plugTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAssigns a unique id to each element of this list, that is, an integer\n   between 1 and the size of the list.\n\u003c/p\u003e",
          "module": "NLP.GenI.Tag",
          "name": "setTidnums",
          "package": "GenI",
          "signature": "[TagElem] -\u003e [TagElem]",
          "source": "src/NLP-GenI-Tag.html#setTidnums",
          "type": "function"
        },
        "index": {
          "description": "Assigns unique id to each element of this list that is an integer between and the size of the list",
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "setTidnums",
          "normalized": "[TagElem]-\u003e[TagElem]",
          "package": "GenI",
          "partial": "Tidnums",
          "signature": "[TagElem]-\u003e[TagElem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:setTidnums"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven two trees \u003ccode\u003eauxt\u003c/code\u003e and \u003ccode\u003et\u003c/code\u003e, splice the tree \u003ccode\u003eauxt\u003c/code\u003e into\n   \u003ccode\u003et\u003c/code\u003e via the TAG adjunction rule.\n\u003c/p\u003e",
          "module": "NLP.GenI.Tag",
          "name": "spliceTree",
          "package": "GenI",
          "signature": "NodeName-\u003e Tree NodeName-\u003e NodeName-\u003e Tree NodeName-\u003e Tree NodeName",
          "type": "function"
        },
        "index": {
          "description": "Given two trees auxt and splice the tree auxt into via the TAG adjunction rule",
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "spliceTree",
          "normalized": "NodeName-\u003eTree NodeName-\u003eNodeName-\u003eTree NodeName-\u003eTree NodeName",
          "package": "GenI",
          "partial": "Tree",
          "signature": "NodeName-\u003eTree NodeName-\u003eNodeName-\u003eTree NodeName-\u003eTree NodeName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:spliceTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormally, extracting the sentences from a TAG tree would just\n   consist of reading its leaves.  But if you want the generator to\n   return inflected forms instead of just lemmas, you also need to\n   return the relevant features for each leaf.  In TAG, or at least our\n   use of it, the features come from the *pre-terminal* nodes, that is,\n   not the leaves themselves but their parents.  Another bit of\n   trickiness: because of atomic disjunction, leaves might have more\n   than one value, so we can't just return a String lemma but a list of\n   String, one for each possibility.\n\u003c/p\u003e",
          "module": "NLP.GenI.Tag",
          "name": "tagLeaves",
          "package": "GenI",
          "signature": "TagElem -\u003e [(NodeName, UninflectedDisjunction)]",
          "source": "src/NLP-GenI-Tag.html#tagLeaves",
          "type": "function"
        },
        "index": {
          "description": "Normally extracting the sentences from TAG tree would just consist of reading its leaves But if you want the generator to return inflected forms instead of just lemmas you also need to return the relevant features for each leaf In TAG or at least our use of it the features come from the pre-terminal nodes that is not the leaves themselves but their parents Another bit of trickiness because of atomic disjunction leaves might have more than one value so we can just return String lemma but list of String one for each possibility",
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "tagLeaves",
          "normalized": "TagElem-\u003e[(NodeName,UninflectedDisjunction)]",
          "package": "GenI",
          "partial": "Leaves",
          "signature": "TagElem-\u003e[(NodeName,UninflectedDisjunction)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:tagLeaves"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "tgIdName",
          "package": "GenI",
          "signature": "t -\u003e Text",
          "source": "src/NLP-GenI-Tag.html#tgIdName",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "tgIdName",
          "normalized": "a-\u003eText",
          "package": "GenI",
          "partial": "Id Name",
          "signature": "t-\u003eText",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:tgIdName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "tgIdNum",
          "package": "GenI",
          "signature": "t -\u003e Integer",
          "source": "src/NLP-GenI-Tag.html#tgIdNum",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "tgIdNum",
          "normalized": "a-\u003eInteger",
          "package": "GenI",
          "partial": "Id Num",
          "signature": "t-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:tgIdNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "tgSemantics",
          "package": "GenI",
          "signature": "t -\u003e Sem",
          "source": "src/NLP-GenI-Tag.html#tgSemantics",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "tgSemantics",
          "normalized": "a-\u003eSem",
          "package": "GenI",
          "partial": "Semantics",
          "signature": "t-\u003eSem",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:tgSemantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "tgTree",
          "package": "GenI",
          "signature": "t -\u003e Tree (GNode GeniVal)",
          "source": "src/NLP-GenI-Tag.html#tgTree",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "tgTree",
          "normalized": "a-\u003eTree(GNode GeniVal)",
          "package": "GenI",
          "partial": "Tree",
          "signature": "t-\u003eTree(GNode GeniVal)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:tgTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "tidnum",
          "package": "GenI",
          "signature": "Integer",
          "source": "src/NLP-GenI-Tag.html#TagElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "tidnum",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:tidnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "tinterface",
          "package": "GenI",
          "signature": "Flist GeniVal",
          "source": "src/NLP-GenI-Tag.html#TagElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "tinterface",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:tinterface"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "toTagSite",
          "package": "GenI",
          "signature": "GNode GeniVal -\u003e TagSite",
          "source": "src/NLP-GenI-Tag.html#toTagSite",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "toTagSite",
          "normalized": "GNode GeniVal-\u003eTagSite",
          "package": "GenI",
          "partial": "Tag Site",
          "signature": "GNode GeniVal-\u003eTagSite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:toTagSite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "tpolarities",
          "package": "GenI",
          "signature": "Map PolarityKey (Int, Int)",
          "source": "src/NLP-GenI-Tag.html#TagElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "tpolarities",
          "normalized": "Map PolarityKey(Int,Int)",
          "package": "GenI",
          "signature": "Map PolarityKey(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:tpolarities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "tsDown",
          "package": "GenI",
          "signature": "Flist GeniVal",
          "source": "src/NLP-GenI-Tag.html#TagSite",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "tsDown",
          "package": "GenI",
          "partial": "Down",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:tsDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "tsName",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-Tag.html#TagSite",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "tsName",
          "package": "GenI",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:tsName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "tsOrigin",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-Tag.html#TagSite",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "tsOrigin",
          "package": "GenI",
          "partial": "Origin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:tsOrigin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "tsUp",
          "package": "GenI",
          "signature": "Flist GeniVal",
          "source": "src/NLP-GenI-Tag.html#TagSite",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "tsUp",
          "package": "GenI",
          "partial": "Up",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:tsUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "ts_rootFeatureMismatch",
          "package": "GenI",
          "signature": "Flist GeniVal -\u003e Text",
          "source": "src/NLP-GenI-Tag.html#ts_rootFeatureMismatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "ts_rootFeatureMismatch",
          "normalized": "Flist GeniVal-\u003eText",
          "package": "GenI",
          "partial": "Feature Mismatch",
          "signature": "Flist GeniVal-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:ts_rootFeatureMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "ts_semIncomplete",
          "package": "GenI",
          "signature": "[Literal GeniVal] -\u003e Text",
          "source": "src/NLP-GenI-Tag.html#ts_semIncomplete",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "ts_semIncomplete",
          "normalized": "[Literal GeniVal]-\u003eText",
          "package": "GenI",
          "partial": "Incomplete",
          "signature": "[Literal GeniVal]-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:ts_semIncomplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "ts_synIncomplete",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-Tag.html#ts_synIncomplete",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "ts_synIncomplete",
          "package": "GenI",
          "partial": "Incomplete",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:ts_synIncomplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "ts_tbUnificationFailure",
          "package": "GenI",
          "signature": "Text -\u003e Text",
          "source": "src/NLP-GenI-Tag.html#ts_tbUnificationFailure",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "ts_tbUnificationFailure",
          "normalized": "Text-\u003eText",
          "package": "GenI",
          "partial": "Unification Failure",
          "signature": "Text-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:ts_tbUnificationFailure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "tsemantics",
          "package": "GenI",
          "signature": "Sem",
          "source": "src/NLP-GenI-Tag.html#TagElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "tsemantics",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:tsemantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecan be empty\n\u003c/p\u003e",
          "module": "NLP.GenI.Tag",
          "name": "tsempols",
          "package": "GenI",
          "signature": "[SemPols]",
          "source": "src/NLP-GenI-Tag.html#TagElem",
          "type": "function"
        },
        "index": {
          "description": "can be empty",
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "tsempols",
          "normalized": "[SemPols]",
          "package": "GenI",
          "signature": "[SemPols]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:tsempols"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "ttrace",
          "package": "GenI",
          "signature": "[Text]",
          "source": "src/NLP-GenI-Tag.html#TagElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "ttrace",
          "normalized": "[Text]",
          "package": "GenI",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:ttrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "ttree",
          "package": "GenI",
          "signature": "Tree (GNode GeniVal)",
          "source": "src/NLP-GenI-Tag.html#TagElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "ttree",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:ttree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "ttreename",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-Tag.html#TagElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "ttreename",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:ttreename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Tag",
          "name": "ttype",
          "package": "GenI",
          "signature": "Ptype",
          "source": "src/NLP-GenI-Tag.html#TagElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Tag",
          "module": "NLP.GenI.Tag",
          "name": "ttype",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Tag.html#v:ttype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TestSuite",
          "name": "TestSuite",
          "package": "GenI",
          "source": "src/NLP-GenI-TestSuite.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI TestSuite",
          "module": "NLP.GenI.TestSuite",
          "name": "TestSuite",
          "package": "GenI",
          "partial": "Test Suite",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TestSuite.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TestSuite",
          "name": "TestCase",
          "package": "GenI",
          "source": "src/NLP-GenI-TestSuite.html#TestCase",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI TestSuite",
          "module": "NLP.GenI.TestSuite",
          "name": "TestCase",
          "package": "GenI",
          "partial": "Test Case",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TestSuite.html#t:TestCase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TestSuite",
          "name": "TestCase",
          "package": "GenI",
          "signature": "TestCase",
          "source": "src/NLP-GenI-TestSuite.html#TestCase",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TestSuite",
          "module": "NLP.GenI.TestSuite",
          "name": "TestCase",
          "package": "GenI",
          "partial": "Test Case",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TestSuite.html#v:TestCase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexpected results (for testing)\n\u003c/p\u003e",
          "module": "NLP.GenI.TestSuite",
          "name": "tcExpected",
          "package": "GenI",
          "signature": "[Text]",
          "source": "src/NLP-GenI-TestSuite.html#TestCase",
          "type": "function"
        },
        "index": {
          "description": "expected results for testing",
          "hierarchy": "NLP GenI TestSuite",
          "module": "NLP.GenI.TestSuite",
          "name": "tcExpected",
          "normalized": "[Text]",
          "package": "GenI",
          "partial": "Expected",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TestSuite.html#v:tcExpected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TestSuite",
          "name": "tcName",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-TestSuite.html#TestCase",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TestSuite",
          "module": "NLP.GenI.TestSuite",
          "name": "tcName",
          "package": "GenI",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TestSuite.html#v:tcName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TestSuite",
          "name": "tcParams",
          "package": "GenI",
          "signature": "Maybe Params",
          "source": "src/NLP-GenI-TestSuite.html#TestCase",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TestSuite",
          "module": "NLP.GenI.TestSuite",
          "name": "tcParams",
          "package": "GenI",
          "partial": "Params",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TestSuite.html#v:tcParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TestSuite",
          "name": "tcSem",
          "package": "GenI",
          "signature": "sem",
          "source": "src/NLP-GenI-TestSuite.html#TestCase",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TestSuite",
          "module": "NLP.GenI.TestSuite",
          "name": "tcSem",
          "package": "GenI",
          "partial": "Sem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TestSuite.html#v:tcSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efor gui\n\u003c/p\u003e",
          "module": "NLP.GenI.TestSuite",
          "name": "tcSemString",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-TestSuite.html#TestCase",
          "type": "function"
        },
        "index": {
          "description": "for gui",
          "hierarchy": "NLP GenI TestSuite",
          "module": "NLP.GenI.TestSuite",
          "name": "tcSemString",
          "package": "GenI",
          "partial": "Sem String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TestSuite.html#v:tcSemString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides basic datatypes specific to Tree Adjoining Grammar\n   tree schemata.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "TreeSchema",
          "package": "GenI",
          "source": "src/NLP-GenI-TreeSchema.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides basic datatypes specific to Tree Adjoining Grammar tree schemata",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "TreeSchema",
          "package": "GenI",
          "partial": "Tree Schema",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEssentially boolean representation of adjunction constraint\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "AdjunctionConstraint",
          "package": "GenI",
          "source": "src/NLP-GenI-TreeSchema.html#AdjunctionConstraint",
          "type": "data"
        },
        "index": {
          "description": "Essentially boolean representation of adjunction constraint",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "AdjunctionConstraint",
          "package": "GenI",
          "partial": "Adjunction Constraint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#t:AdjunctionConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single node of a TAG tree.\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "GNode",
          "package": "GenI",
          "source": "src/NLP-GenI-TreeSchema.html#GNode",
          "type": "data"
        },
        "index": {
          "description": "single node of TAG tree",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "GNode",
          "package": "GenI",
          "partial": "GNode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#t:GNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "GType",
          "package": "GenI",
          "source": "src/NLP-GenI-TreeSchema.html#GType",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "GType",
          "package": "GenI",
          "partial": "GType",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#t:GType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "Macros",
          "package": "GenI",
          "source": "src/NLP-GenI-TreeSchema.html#Macros",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "Macros",
          "package": "GenI",
          "partial": "Macros",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#t:Macros"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "NodeName",
          "package": "GenI",
          "source": "src/NLP-GenI-TreeSchema.html#NodeName",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "NodeName",
          "package": "GenI",
          "partial": "Node Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#t:NodeName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "Ptype",
          "package": "GenI",
          "source": "src/NLP-GenI-TreeSchema.html#Ptype",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "Ptype",
          "package": "GenI",
          "partial": "Ptype",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#t:Ptype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "SchemaTree",
          "package": "GenI",
          "source": "src/NLP-GenI-TreeSchema.html#SchemaTree",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "SchemaTree",
          "package": "GenI",
          "partial": "Schema Tree",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#t:SchemaTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA schema value is a disjunction of GenI values.  It allows us to express\n   &#8220;fancy&#8221; disjunctions in tree schemata, ie. disjunctions over variables\n   and not just atoms (\u003ccode\u003e?X;?Y\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eOur rule is that that when a tree schema is instantiated, any fancy\n   disjunctions must be &#8220;crushed&#8221; into a single \u003ccode\u003e\u003ca\u003eGeniVal\u003c/a\u003e\u003c/code\u003e lest it be\n   rejected (see \u003ccode\u003e\u003ca\u003ecrushOne\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e\u003cp\u003eNote that this is still not recursive; we don't have disjunction over\n   schema values, nor can schema values refer to schema values.  It just\n   allows us to express the idea that in tree schemata, you can have\n   either variable \u003ccode\u003e?X\u003c/code\u003e or \u003ccode\u003e?Y\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "SchemaVal",
          "package": "GenI",
          "source": "src/NLP-GenI-GeniVal-Internal.html#SchemaVal",
          "type": "data"
        },
        "index": {
          "description": "schema value is disjunction of GenI values It allows us to express fancy disjunctions in tree schemata ie disjunctions over variables and not just atoms Our rule is that that when tree schema is instantiated any fancy disjunctions must be crushed into single GeniVal lest it be rejected see crushOne Note that this is still not recursive we don have disjunction over schema values nor can schema values refer to schema values It just allows us to express the idea that in tree schemata you can have either variable or",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "SchemaVal",
          "package": "GenI",
          "partial": "Schema Val",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#t:SchemaVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "Ttree",
          "package": "GenI",
          "source": "src/NLP-GenI-TreeSchema.html#Ttree",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "Ttree",
          "package": "GenI",
          "partial": "Ttree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#t:Ttree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "Auxiliar",
          "package": "GenI",
          "signature": "Auxiliar",
          "source": "src/NLP-GenI-TreeSchema.html#Ptype",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "Auxiliar",
          "package": "GenI",
          "partial": "Auxiliar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:Auxiliar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehard-coded null-adjunction constraint\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "ExplicitNoAdj",
          "package": "GenI",
          "signature": "ExplicitNoAdj",
          "source": "src/NLP-GenI-TreeSchema.html#AdjunctionConstraint",
          "type": "function"
        },
        "index": {
          "description": "hard-coded null-adjunction constraint",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "ExplicitNoAdj",
          "package": "GenI",
          "partial": "Explicit No Adj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:ExplicitNoAdj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "Foot",
          "package": "GenI",
          "signature": "Foot",
          "source": "src/NLP-GenI-TreeSchema.html#GType",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "Foot",
          "package": "GenI",
          "partial": "Foot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:Foot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "GN",
          "package": "GenI",
          "signature": "GN",
          "source": "src/NLP-GenI-TreeSchema.html#GNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "GN",
          "package": "GenI",
          "partial": "GN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:GN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einferred by GenI to be adjunction free\n   (ie. during realisation)\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "InferredNoAdj",
          "package": "GenI",
          "signature": "InferredNoAdj",
          "source": "src/NLP-GenI-TreeSchema.html#AdjunctionConstraint",
          "type": "function"
        },
        "index": {
          "description": "inferred by GenI to be adjunction free ie during realisation",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "InferredNoAdj",
          "package": "GenI",
          "partial": "Inferred No Adj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:InferredNoAdj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "Initial",
          "package": "GenI",
          "signature": "Initial",
          "source": "src/NLP-GenI-TreeSchema.html#Ptype",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "Initial",
          "package": "GenI",
          "partial": "Initial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:Initial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "Lex",
          "package": "GenI",
          "signature": "Lex",
          "source": "src/NLP-GenI-TreeSchema.html#GType",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "Lex",
          "package": "GenI",
          "partial": "Lex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:Lex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "MaybeAdj",
          "package": "GenI",
          "signature": "MaybeAdj",
          "source": "src/NLP-GenI-TreeSchema.html#AdjunctionConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "MaybeAdj",
          "package": "GenI",
          "partial": "Maybe Adj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:MaybeAdj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "Other",
          "package": "GenI",
          "signature": "Other",
          "source": "src/NLP-GenI-TreeSchema.html#GType",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "Other",
          "package": "GenI",
          "partial": "Other",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:Other"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "Subs",
          "package": "GenI",
          "signature": "Subs",
          "source": "src/NLP-GenI-TreeSchema.html#GType",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "Subs",
          "package": "GenI",
          "partial": "Subs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:Subs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "TT",
          "package": "GenI",
          "signature": "TT",
          "source": "src/NLP-GenI-TreeSchema.html#Ttree",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "TT",
          "package": "GenI",
          "partial": "TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:TT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an inferred adjunction constraint marker unless we already\n   see an explicit one\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "addInferredAdjConstraint",
          "package": "GenI",
          "signature": "GNode gv -\u003e GNode gv",
          "source": "src/NLP-GenI-TreeSchema.html#addInferredAdjConstraint",
          "type": "function"
        },
        "index": {
          "description": "Add an inferred adjunction constraint marker unless we already see an explicit one",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "addInferredAdjConstraint",
          "normalized": "GNode a-\u003eGNode a",
          "package": "GenI",
          "partial": "Inferred Adj Constraint",
          "signature": "GNode gv-\u003eGNode gv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:addInferredAdjConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "crushGNode",
          "package": "GenI",
          "signature": "GNode SchemaVal -\u003e Maybe (GNode GeniVal)",
          "source": "src/NLP-GenI-TreeSchema.html#crushGNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "crushGNode",
          "normalized": "GNode SchemaVal-\u003eMaybe(GNode GeniVal)",
          "package": "GenI",
          "partial": "GNode",
          "signature": "GNode SchemaVal-\u003eMaybe(GNode GeniVal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:crushGNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "crushTreeGNode",
          "package": "GenI",
          "signature": "Tree (GNode SchemaVal) -\u003e Maybe (Tree (GNode GeniVal))",
          "source": "src/NLP-GenI-TreeSchema.html#crushTreeGNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "crushTreeGNode",
          "normalized": "Tree(GNode SchemaVal)-\u003eMaybe(Tree(GNode GeniVal))",
          "package": "GenI",
          "partial": "Tree GNode",
          "signature": "Tree(GNode SchemaVal)-\u003eMaybe(Tree(GNode GeniVal))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:crushTreeGNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "foot",
          "package": "GenI",
          "signature": "Tree (GNode a) -\u003e GNode a",
          "source": "src/NLP-GenI-TreeSchema.html#foot",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "foot",
          "normalized": "Tree(GNode a)-\u003eGNode a",
          "package": "GenI",
          "signature": "Tree(GNode a)-\u003eGNode a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:foot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the value of the \u003ca\u003ecat\u003c/a\u003e attribute, if available\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "gCategory",
          "package": "GenI",
          "signature": "Flist GeniVal -\u003e Maybe GeniVal",
          "source": "src/NLP-GenI-TreeSchema.html#gCategory",
          "type": "function"
        },
        "index": {
          "description": "Return the value of the cat attribute if available",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "gCategory",
          "normalized": "Flist GeniVal-\u003eMaybe GeniVal",
          "package": "GenI",
          "partial": "Category",
          "signature": "Flist GeniVal-\u003eMaybe GeniVal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:gCategory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "gaconstr",
          "package": "GenI",
          "signature": "AdjunctionConstraint",
          "source": "src/NLP-GenI-TreeSchema.html#GNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "gaconstr",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:gaconstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eFalse\u003c/code\u003e for na nodes\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "ganchor",
          "package": "GenI",
          "signature": "Bool",
          "source": "src/NLP-GenI-TreeSchema.html#GNode",
          "type": "function"
        },
        "index": {
          "description": "False for na nodes",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "ganchor",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:ganchor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebottom feature structure\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "gdown",
          "package": "GenI",
          "signature": "Flist gv",
          "source": "src/NLP-GenI-TreeSchema.html#GNode",
          "type": "function"
        },
        "index": {
          "description": "bottom feature structure",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "gdown",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:gdown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e[]\u003c/code\u003e for na nodes\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "glexeme",
          "package": "GenI",
          "signature": "[Text]",
          "source": "src/NLP-GenI-TreeSchema.html#GNode",
          "type": "function"
        },
        "index": {
          "description": "for na nodes",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "glexeme",
          "normalized": "[Text]",
          "package": "GenI",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:glexeme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "gnname",
          "package": "GenI",
          "signature": "NodeName",
          "source": "src/NLP-GenI-TreeSchema.html#GNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "gnname",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:gnname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "gnnameIs",
          "package": "GenI",
          "signature": "NodeName -\u003e GNode gv -\u003e Bool",
          "source": "src/NLP-GenI-TreeSchema.html#gnnameIs",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "gnnameIs",
          "normalized": "NodeName-\u003eGNode a-\u003eBool",
          "package": "GenI",
          "partial": "Is",
          "signature": "NodeName-\u003eGNode gv-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:gnnameIs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efor TAG, this would be the elementary tree\n   that this node originally came from\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "gorigin",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-TreeSchema.html#GNode",
          "type": "function"
        },
        "index": {
          "description": "for TAG this would be the elementary tree that this node originally came from",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "gorigin",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:gorigin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "gtype",
          "package": "GenI",
          "signature": "GType",
          "source": "src/NLP-GenI-TreeSchema.html#GNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "gtype",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:gtype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etop feature structure\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "gup",
          "package": "GenI",
          "signature": "Flist gv",
          "source": "src/NLP-GenI-TreeSchema.html#GNode",
          "type": "function"
        },
        "index": {
          "description": "top feature structure",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "gup",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:gup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "isAdjConstrained",
          "package": "GenI",
          "signature": "GNode gv -\u003e Bool",
          "source": "src/NLP-GenI-TreeSchema.html#isAdjConstrained",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "isAdjConstrained",
          "normalized": "GNode a-\u003eBool",
          "package": "GenI",
          "partial": "Adj Constrained",
          "signature": "GNode gv-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:isAdjConstrained"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttributes recognised as lexemes, in order of preference\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "lexemeAttributes",
          "package": "GenI",
          "signature": "[Text]",
          "source": "src/NLP-GenI-TreeSchema.html#lexemeAttributes",
          "type": "function"
        },
        "index": {
          "description": "Attributes recognised as lexemes in order of preference",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "lexemeAttributes",
          "normalized": "[Text]",
          "package": "GenI",
          "partial": "Attributes",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:lexemeAttributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "params",
          "package": "GenI",
          "signature": "[GeniVal]",
          "source": "src/NLP-GenI-TreeSchema.html#Ttree",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "params",
          "normalized": "[GeniVal]",
          "package": "GenI",
          "signature": "[GeniVal]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:params"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "pfamily",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-TreeSchema.html#Ttree",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "pfamily",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:pfamily"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "pidname",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI-TreeSchema.html#Ttree",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "pidname",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:pidname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "pinterface",
          "package": "GenI",
          "signature": "Flist GeniVal",
          "source": "src/NLP-GenI-TreeSchema.html#Ttree",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "pinterface",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:pinterface"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "psemantics",
          "package": "GenI",
          "signature": "Maybe Sem",
          "source": "src/NLP-GenI-TreeSchema.html#Ttree",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "psemantics",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:psemantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "ptrace",
          "package": "GenI",
          "signature": "[Text]",
          "source": "src/NLP-GenI-TreeSchema.html#Ttree",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "ptrace",
          "normalized": "[Text]",
          "package": "GenI",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:ptrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "ptype",
          "package": "GenI",
          "signature": "Ptype",
          "source": "src/NLP-GenI-TreeSchema.html#Ttree",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "ptype",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:ptype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "root",
          "package": "GenI",
          "signature": "Tree a -\u003e a",
          "source": "src/NLP-GenI-TreeSchema.html#root",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "root",
          "normalized": "Tree a-\u003ea",
          "package": "GenI",
          "signature": "Tree a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "rootUpd",
          "package": "GenI",
          "signature": "Tree a -\u003e a -\u003e Tree a",
          "source": "src/NLP-GenI-TreeSchema.html#rootUpd",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "rootUpd",
          "normalized": "Tree a-\u003ea-\u003eTree a",
          "package": "GenI",
          "partial": "Upd",
          "signature": "Tree a-\u003ea-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:rootUpd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a lexical item \u003ccode\u003es\u003c/code\u003e and a Tree GNode t, returns the tree t'\n   where l has been assigned to the anchor node in t'\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "setAnchor",
          "package": "GenI",
          "signature": "FullList Text -\u003e Tree (GNode a) -\u003e Tree (GNode a)",
          "source": "src/NLP-GenI-TreeSchema.html#setAnchor",
          "type": "function"
        },
        "index": {
          "description": "Given lexical item and Tree GNode returns the tree where has been assigned to the anchor node in",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "setAnchor",
          "normalized": "FullList Text-\u003eTree(GNode a)-\u003eTree(GNode a)",
          "package": "GenI",
          "partial": "Anchor",
          "signature": "FullList Text-\u003eTree(GNode a)-\u003eTree(GNode a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:setAnchor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a lexical item \u003ccode\u003el\u003c/code\u003e and a tree node \u003ccode\u003en\u003c/code\u003e (actually a subtree\n   with no children), return the same node with the lexical item as\n   its unique child.  The idea is that it converts terminal lexeme nodes\n   into preterminal nodes where the actual terminal is the given lexical\n   item\n\u003c/p\u003e",
          "module": "NLP.GenI.TreeSchema",
          "name": "setLexeme",
          "package": "GenI",
          "signature": "[Text] -\u003e Tree (GNode a) -\u003e Tree (GNode a)",
          "source": "src/NLP-GenI-TreeSchema.html#setLexeme",
          "type": "function"
        },
        "index": {
          "description": "Given lexical item and tree node actually subtree with no children return the same node with the lexical item as its unique child The idea is that it converts terminal lexeme nodes into preterminal nodes where the actual terminal is the given lexical item",
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "setLexeme",
          "normalized": "[Text]-\u003eTree(GNode a)-\u003eTree(GNode a)",
          "package": "GenI",
          "partial": "Lexeme",
          "signature": "[Text]-\u003eTree(GNode a)-\u003eTree(GNode a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:setLexeme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "showLexeme",
          "package": "GenI",
          "signature": "[Text] -\u003e Text",
          "source": "src/NLP-GenI-TreeSchema.html#showLexeme",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "showLexeme",
          "normalized": "[Text]-\u003eText",
          "package": "GenI",
          "partial": "Lexeme",
          "signature": "[Text]-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:showLexeme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.TreeSchema",
          "name": "tree",
          "package": "GenI",
          "signature": "Tree a",
          "source": "src/NLP-GenI-TreeSchema.html#Ttree",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI TreeSchema",
          "module": "NLP.GenI.TreeSchema",
          "name": "tree",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-TreeSchema.html#v:tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Warning.Internal",
          "name": "Internal",
          "package": "GenI",
          "source": "src/NLP-GenI-Warning-Internal.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "Internal",
          "package": "GenI",
          "partial": "Internal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Warning.Internal",
          "name": "GeniWarning",
          "package": "GenI",
          "source": "src/NLP-GenI-Warning-Internal.html#GeniWarning",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "GeniWarning",
          "package": "GenI",
          "partial": "Geni Warning",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#t:GeniWarning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis exists because we want the \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e instance, providing a\n   GenI-specific notion of appending which merges instances of the\n   same error\n\u003c/p\u003e",
          "module": "NLP.GenI.Warning.Internal",
          "name": "GeniWarnings",
          "package": "GenI",
          "source": "src/NLP-GenI-Warning-Internal.html#GeniWarnings",
          "type": "newtype"
        },
        "index": {
          "description": "This exists because we want the Monoid instance providing GenI-specific notion of appending which merges instances of the same error",
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "GeniWarnings",
          "package": "GenI",
          "partial": "Geni Warnings",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#t:GeniWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Warning.Internal",
          "name": "LexWarning",
          "package": "GenI",
          "source": "src/NLP-GenI-Warning-Internal.html#LexWarning",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "LexWarning",
          "package": "GenI",
          "partial": "Lex Warning",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#t:LexWarning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Warning.Internal",
          "name": "WordFamilyCount",
          "package": "GenI",
          "source": "src/NLP-GenI-Warning-Internal.html#WordFamilyCount",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "WordFamilyCount",
          "package": "GenI",
          "partial": "Word Family Count",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#t:WordFamilyCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single custom warning\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.Warning.Internal\",\"NLP.GenI.Warning\"]",
          "name": "CustomLexWarning",
          "package": "GenI",
          "signature": "CustomLexWarning Text",
          "source": "src/NLP-GenI-Warning-Internal.html#GeniWarning",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:CustomLexWarning\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#v:CustomLexWarning\"]"
        },
        "index": {
          "description": "single custom warning",
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "CustomLexWarning",
          "package": "GenI",
          "partial": "Custom Lex Warning",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:CustomLexWarning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Warning.Internal",
          "name": "GeniWarnings",
          "package": "GenI",
          "signature": "GeniWarnings",
          "source": "src/NLP-GenI-Warning-Internal.html#GeniWarnings",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "GeniWarnings",
          "package": "GenI",
          "partial": "Geni Warnings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:GeniWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"NLP.GenI.Warning.Internal\",\"NLP.GenI.Warning\"]",
          "name": "LexCombineAllSchemataFailed",
          "package": "GenI",
          "signature": "LexCombineAllSchemataFailed",
          "source": "src/NLP-GenI-Warning-Internal.html#LexWarning",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:LexCombineAllSchemataFailed\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#v:LexCombineAllSchemataFailed\"]"
        },
        "index": {
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "LexCombineAllSchemataFailed",
          "package": "GenI",
          "partial": "Lex Combine All Schemata Failed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:LexCombineAllSchemataFailed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"NLP.GenI.Warning.Internal\",\"NLP.GenI.Warning\"]",
          "name": "LexCombineOneSchemaFailed",
          "package": "GenI",
          "signature": "LexCombineOneSchemaFailed LexCombineError",
          "source": "src/NLP-GenI-Warning-Internal.html#LexWarning",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:LexCombineOneSchemaFailed\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#v:LexCombineOneSchemaFailed\"]"
        },
        "index": {
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "LexCombineOneSchemaFailed",
          "package": "GenI",
          "partial": "Lex Combine One Schema Failed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:LexCombineOneSchemaFailed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA warning that should be repeated for each lexical entry affected\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.Warning.Internal\",\"NLP.GenI.Warning\"]",
          "name": "LexWarning",
          "package": "GenI",
          "signature": "LexWarning [LexEntry] LexWarning",
          "source": "src/NLP-GenI-Warning-Internal.html#GeniWarning",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:LexWarning\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#v:LexWarning\"]"
        },
        "index": {
          "description": "warning that should be repeated for each lexical entry affected",
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "LexWarning",
          "normalized": "LexWarning[LexEntry]LexWarning",
          "package": "GenI",
          "partial": "Lex Warning",
          "signature": "LexWarning[LexEntry]LexWarning",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:LexWarning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"NLP.GenI.Warning.Internal\",\"NLP.GenI.Warning\"]",
          "name": "MissingCoanchors",
          "package": "GenI",
          "signature": "MissingCoanchors Text Int",
          "source": "src/NLP-GenI-Warning-Internal.html#LexWarning",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:MissingCoanchors\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#v:MissingCoanchors\"]"
        },
        "index": {
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "MissingCoanchors",
          "package": "GenI",
          "partial": "Missing Coanchors",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:MissingCoanchors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWarnings from the morphological realiser\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.Warning.Internal\",\"NLP.GenI.Warning\"]",
          "name": "MorphWarning",
          "package": "GenI",
          "signature": "MorphWarning [Text]",
          "source": "src/NLP-GenI-Warning-Internal.html#GeniWarning",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:MorphWarning\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#v:MorphWarning\"]"
        },
        "index": {
          "description": "Warnings from the morphological realiser",
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "MorphWarning",
          "normalized": "MorphWarning[Text]",
          "package": "GenI",
          "partial": "Morph Warning",
          "signature": "MorphWarning[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:MorphWarning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLiterals which did not receive any lexical selection\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.Warning.Internal\",\"NLP.GenI.Warning\"]",
          "name": "NoLexSelection",
          "package": "GenI",
          "signature": "NoLexSelection [Literal GeniVal]",
          "source": "src/NLP-GenI-Warning-Internal.html#GeniWarning",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:NoLexSelection\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#v:NoLexSelection\"]"
        },
        "index": {
          "description": "Literals which did not receive any lexical selection",
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "NoLexSelection",
          "normalized": "NoLexSelection[Literal GeniVal]",
          "package": "GenI",
          "partial": "No Lex Selection",
          "signature": "NoLexSelection[Literal GeniVal]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:NoLexSelection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Warning.Internal",
          "name": "appendWarning",
          "package": "GenI",
          "signature": "GeniWarning -\u003e [GeniWarning] -\u003e [GeniWarning]",
          "source": "src/NLP-GenI-Warning-Internal.html#appendWarning",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "appendWarning",
          "normalized": "GeniWarning-\u003e[GeniWarning]-\u003e[GeniWarning]",
          "package": "GenI",
          "partial": "Warning",
          "signature": "GeniWarning-\u003e[GeniWarning]-\u003e[GeniWarning]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:appendWarning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Warning.Internal",
          "name": "fromGeniWarnings",
          "package": "GenI",
          "signature": "[GeniWarning]",
          "source": "src/NLP-GenI-Warning-Internal.html#GeniWarnings",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "fromGeniWarnings",
          "normalized": "[GeniWarning]",
          "package": "GenI",
          "partial": "Geni Warnings",
          "signature": "[GeniWarning]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:fromGeniWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Warning.Internal",
          "name": "mergeWarning",
          "package": "GenI",
          "signature": "GeniWarning -\u003e GeniWarning -\u003e Maybe GeniWarning",
          "source": "src/NLP-GenI-Warning-Internal.html#mergeWarning",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "mergeWarning",
          "normalized": "GeniWarning-\u003eGeniWarning-\u003eMaybe GeniWarning",
          "package": "GenI",
          "partial": "Warning",
          "signature": "GeniWarning-\u003eGeniWarning-\u003eMaybe GeniWarning",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:mergeWarning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"NLP.GenI.Warning.Internal\",\"NLP.GenI.Warning\"]",
          "name": "mkGeniWarnings",
          "package": "GenI",
          "signature": "[GeniWarning] -\u003e GeniWarnings",
          "source": "src/NLP-GenI-Warning-Internal.html#mkGeniWarnings",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:mkGeniWarnings\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#v:mkGeniWarnings\"]"
        },
        "index": {
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "mkGeniWarnings",
          "normalized": "[GeniWarning]-\u003eGeniWarnings",
          "package": "GenI",
          "partial": "Geni Warnings",
          "signature": "[GeniWarning]-\u003eGeniWarnings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:mkGeniWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSort, treating non-comporable items as equal\n\u003c/p\u003e",
          "module": "NLP.GenI.Warning.Internal",
          "name": "posort",
          "package": "GenI",
          "signature": "[a] -\u003e [a]",
          "source": "src/NLP-GenI-Warning-Internal.html#posort",
          "type": "function"
        },
        "index": {
          "description": "Sort treating non-comporable items as equal",
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "posort",
          "normalized": "[a]-\u003e[a]",
          "package": "GenI",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:posort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA warning may be displayed over several lines\n\u003c/p\u003e",
          "module": "[\"NLP.GenI.Warning.Internal\",\"NLP.GenI.Warning\"]",
          "name": "showGeniWarning",
          "package": "GenI",
          "signature": "GeniWarning -\u003e [Text]",
          "source": "src/NLP-GenI-Warning-Internal.html#showGeniWarning",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:showGeniWarning\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#v:showGeniWarning\"]"
        },
        "index": {
          "description": "warning may be displayed over several lines",
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "showGeniWarning",
          "normalized": "GeniWarning-\u003e[Text]",
          "package": "GenI",
          "partial": "Geni Warning",
          "signature": "GeniWarning-\u003e[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:showGeniWarning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"NLP.GenI.Warning.Internal\",\"NLP.GenI.Warning\"]",
          "name": "sortWarnings",
          "package": "GenI",
          "signature": "GeniWarnings -\u003e GeniWarnings",
          "source": "src/NLP-GenI-Warning-Internal.html#sortWarnings",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:sortWarnings\",\"http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#v:sortWarnings\"]"
        },
        "index": {
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "sortWarnings",
          "normalized": "GeniWarnings-\u003eGeniWarnings",
          "package": "GenI",
          "partial": "Warnings",
          "signature": "GeniWarnings-\u003eGeniWarnings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:sortWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Warning.Internal",
          "name": "toWfCount",
          "package": "GenI",
          "signature": "[LexEntry] -\u003e WordFamilyCount",
          "source": "src/NLP-GenI-Warning-Internal.html#toWfCount",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Warning Internal",
          "module": "NLP.GenI.Warning.Internal",
          "name": "toWfCount",
          "normalized": "[LexEntry]-\u003eWordFamilyCount",
          "package": "GenI",
          "partial": "Wf Count",
          "signature": "[LexEntry]-\u003eWordFamilyCount",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning-Internal.html#v:toWfCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTyped warnings as an easier alternative to strings.\n\u003c/p\u003e\u003cp\u003eThis makes it easier to recognise repeated warnings and print them\n   out in a reasonable way\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI.Warning",
          "name": "Warning",
          "package": "GenI",
          "source": "src/NLP-GenI-Warning.html",
          "type": "module"
        },
        "index": {
          "description": "Typed warnings as an easier alternative to strings This makes it easier to recognise repeated warnings and print them out in reasonable way",
          "hierarchy": "NLP GenI Warning",
          "module": "NLP.GenI.Warning",
          "name": "Warning",
          "package": "GenI",
          "partial": "Warning",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Warning",
          "name": "GeniWarning",
          "package": "GenI",
          "source": "src/NLP-GenI-Warning-Internal.html#GeniWarning",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Warning",
          "module": "NLP.GenI.Warning",
          "name": "GeniWarning",
          "package": "GenI",
          "partial": "Geni Warning",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#t:GeniWarning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis exists because we want the \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e instance, providing a\n   GenI-specific notion of appending which merges instances of the\n   same error\n\u003c/p\u003e",
          "module": "NLP.GenI.Warning",
          "name": "GeniWarnings",
          "package": "GenI",
          "source": "src/NLP-GenI-Warning-Internal.html#GeniWarnings",
          "type": "data"
        },
        "index": {
          "description": "This exists because we want the Monoid instance providing GenI-specific notion of appending which merges instances of the same error",
          "hierarchy": "NLP GenI Warning",
          "module": "NLP.GenI.Warning",
          "name": "GeniWarnings",
          "package": "GenI",
          "partial": "Geni Warnings",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#t:GeniWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Warning",
          "name": "LexWarning",
          "package": "GenI",
          "source": "src/NLP-GenI-Warning-Internal.html#LexWarning",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI Warning",
          "module": "NLP.GenI.Warning",
          "name": "LexWarning",
          "package": "GenI",
          "partial": "Lex Warning",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#t:LexWarning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI.Warning",
          "name": "fromGeniWarnings",
          "package": "GenI",
          "signature": "GeniWarnings -\u003e [GeniWarning]",
          "source": "src/NLP-GenI-Warning-Internal.html#fromGeniWarnings",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI Warning",
          "module": "NLP.GenI.Warning",
          "name": "fromGeniWarnings",
          "normalized": "GeniWarnings-\u003e[GeniWarning]",
          "package": "GenI",
          "partial": "Geni Warnings",
          "signature": "GeniWarnings-\u003e[GeniWarning]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI-Warning.html#v:fromGeniWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is the interface between the front and backends of the generator. The GUI\n   and the console interface both talk to this module, and in turn, this module\n   talks to the input file parsers and the surface realisation engine.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.GenI",
          "name": "GenI",
          "package": "GenI",
          "source": "src/NLP-GenI.html",
          "type": "module"
        },
        "index": {
          "description": "This is the interface between the front and backends of the generator The GUI and the console interface both talk to this module and in turn this module talks to the input file parsers and the surface realisation engine",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "GenI",
          "package": "GenI",
          "partial": "Gen",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "BadInputException",
          "package": "GenI",
          "source": "src/NLP-GenI.html#BadInputException",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "BadInputException",
          "package": "GenI",
          "partial": "Bad Input Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#t:BadInputException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "GeniError",
          "package": "GenI",
          "source": "src/NLP-GenI.html#GeniError",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "GeniError",
          "package": "GenI",
          "partial": "Geni Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#t:GeniError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "GeniLexSel",
          "package": "GenI",
          "source": "src/NLP-GenI.html#GeniLexSel",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "GeniLexSel",
          "package": "GenI",
          "partial": "Geni Lex Sel",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#t:GeniLexSel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "GeniResult",
          "package": "GenI",
          "source": "src/NLP-GenI.html#GeniResult",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "GeniResult",
          "package": "GenI",
          "partial": "Geni Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#t:GeniResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eGeniResults\u003c/a\u003e\u003c/code\u003e is the outcome of running GenI on a single input semantics.\n   Each distinct result is returned as a single \u003ccode\u003e\u003ca\u003eGeniResult\u003c/a\u003e\u003c/code\u003e (NB: a single\n   result may expand into multiple strings through morphological\n   post-processing),\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "GeniResults",
          "package": "GenI",
          "source": "src/NLP-GenI.html#GeniResults",
          "type": "data"
        },
        "index": {
          "description": "GeniResults is the outcome of running GenI on single input semantics Each distinct result is returned as single GeniResult NB single result may expand into multiple strings through morphological post-processing",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "GeniResults",
          "package": "GenI",
          "partial": "Geni Results",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#t:GeniResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "GeniSuccess",
          "package": "GenI",
          "source": "src/NLP-GenI.html#GeniSuccess",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "GeniSuccess",
          "package": "GenI",
          "partial": "Geni Success",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#t:GeniSuccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSee \u003ccode\u003e\u003ca\u003eConfiguration\u003c/a\u003e\u003c/code\u003e if you want to use GenI with a custom\n   lexical selection function.\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "LexicalSelector",
          "package": "GenI",
          "source": "src/NLP-GenI-LexicalSelection.html#LexicalSelector",
          "type": "type"
        },
        "index": {
          "description": "See Configuration if you want to use GenI with custom lexical selection function",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "LexicalSelector",
          "package": "GenI",
          "partial": "Lexical Selector",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#t:LexicalSelector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe file loading functions all work the same way: we load the file,\n   and try to parse it.  If this doesn't work, we just fail in IO, and\n   GenI dies.  If we succeed, we update the program state passed in as\n   an IORef.\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "Loadable",
          "package": "GenI",
          "source": "src/NLP-GenI.html#Loadable",
          "type": "class"
        },
        "index": {
          "description": "The file loading functions all work the same way we load the file and try to parse it If this doesn work we just fail in IO and GenI dies If we succeed we update the program state passed in as an IORef",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "Loadable",
          "package": "GenI",
          "partial": "Loadable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#t:Loadable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe program state consists of its configuration options and abstract,\n   cleaned up representations of all the data it's had to load into memory\n   (tree schemata files, lexicon files, etc).  The intention is for the\n   state to stay static until the next time something triggers some file\n   loading.\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "ProgState",
          "package": "GenI",
          "source": "src/NLP-GenI.html#ProgState",
          "type": "data"
        },
        "index": {
          "description": "The program state consists of its configuration options and abstract cleaned up representations of all the data it had to load into memory tree schemata files lexicon files etc The intention is for the state to stay static until the next time something triggers some file loading",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "ProgState",
          "package": "GenI",
          "partial": "Prog State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#t:ProgState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "ProgStateRef",
          "package": "GenI",
          "source": "src/NLP-GenI.html#ProgStateRef",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "ProgStateRef",
          "package": "GenI",
          "partial": "Prog State Ref",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#t:ProgStateRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "ResultType",
          "package": "GenI",
          "source": "src/NLP-GenI.html#ResultType",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "ResultType",
          "package": "GenI",
          "partial": "Result Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#t:ResultType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "BadInputException",
          "package": "GenI",
          "signature": "BadInputException String Text",
          "source": "src/NLP-GenI.html#BadInputException",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "BadInputException",
          "package": "GenI",
          "partial": "Bad Input Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:BadInputException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "CompleteResult",
          "package": "GenI",
          "signature": "CompleteResult",
          "source": "src/NLP-GenI.html#ResultType",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "CompleteResult",
          "package": "GenI",
          "partial": "Complete Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:CompleteResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "GError",
          "package": "GenI",
          "signature": "GError GeniError",
          "source": "src/NLP-GenI.html#GeniResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "GError",
          "package": "GenI",
          "partial": "GError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:GError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "GSuccess",
          "package": "GenI",
          "signature": "GSuccess GeniSuccess",
          "source": "src/NLP-GenI.html#GeniResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "GSuccess",
          "package": "GenI",
          "partial": "GSuccess",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:GSuccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "GeniError",
          "package": "GenI",
          "signature": "GeniError [Text]",
          "source": "src/NLP-GenI.html#GeniError",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "GeniError",
          "normalized": "GeniError[Text]",
          "package": "GenI",
          "partial": "Geni Error",
          "signature": "GeniError[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:GeniError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "GeniLexSel",
          "package": "GenI",
          "signature": "GeniLexSel",
          "source": "src/NLP-GenI.html#GeniLexSel",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "GeniLexSel",
          "package": "GenI",
          "partial": "Geni Lex Sel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:GeniLexSel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "GeniResults",
          "package": "GenI",
          "signature": "GeniResults",
          "source": "src/NLP-GenI.html#GeniResults",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "GeniResults",
          "package": "GenI",
          "partial": "Geni Results",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:GeniResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "GeniSuccess",
          "package": "GenI",
          "signature": "GeniSuccess",
          "source": "src/NLP-GenI.html#GeniSuccess",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "GeniSuccess",
          "package": "GenI",
          "partial": "Geni Success",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:GeniSuccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "PartialResult",
          "package": "GenI",
          "signature": "PartialResult",
          "source": "src/NLP-GenI.html#ResultType",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "PartialResult",
          "package": "GenI",
          "partial": "Partial Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:PartialResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "ProgState",
          "package": "GenI",
          "signature": "ProgState",
          "source": "src/NLP-GenI.html#ProgState",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "ProgState",
          "package": "GenI",
          "partial": "Prog State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:ProgState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "customMorph",
          "package": "GenI",
          "signature": "Maybe MorphRealiser",
          "source": "src/NLP-GenI.html#ProgState",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "customMorph",
          "package": "GenI",
          "partial": "Morph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:customMorph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard GenI semantics and lexical selection algorithm\n   (with optional \u003ca\u003epreanchored\u003c/a\u003e mode)\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "defaultCustomSem",
          "package": "GenI",
          "signature": "ProgState -\u003e IO (CustomSem SemInput)",
          "source": "src/NLP-GenI.html#defaultCustomSem",
          "type": "function"
        },
        "index": {
          "description": "Standard GenI semantics and lexical selection algorithm with optional preanchored mode",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "defaultCustomSem",
          "normalized": "ProgState-\u003eIO(CustomSem SemInput)",
          "package": "GenI",
          "partial": "Custom Sem",
          "signature": "ProgState-\u003eIO(CustomSem SemInput)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:defaultCustomSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe program state when you start GenI for the very first time\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "emptyProgState",
          "package": "GenI",
          "signature": "Params -\u003e ProgState",
          "source": "src/NLP-GenI.html#emptyProgState",
          "type": "function"
        },
        "index": {
          "description": "The program state when you start GenI for the very first time",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "emptyProgState",
          "normalized": "Params-\u003eProgState",
          "package": "GenI",
          "partial": "Prog State",
          "signature": "Params-\u003eProgState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:emptyProgState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a helper to \u003ccode\u003erunGenI\u003c/code\u003e. It's mainly useful if you are building\n   interactive GenI debugging tools.\n\u003c/p\u003e\u003cp\u003eGiven a builder state,\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Unpacks the builder results\n\u003c/li\u003e\u003cli\u003e Finalises the results (morphological generation)\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "NLP.GenI",
          "name": "extractResults",
          "package": "GenI",
          "signature": "ProgState-\u003e Maybe Params-\u003e Builder st it-\u003e st-\u003e IO [GeniResult]",
          "type": "function"
        },
        "index": {
          "description": "This is helper to runGenI It mainly useful if you are building interactive GenI debugging tools Given builder state Unpacks the builder results Finalises the results morphological generation",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "extractResults",
          "normalized": "ProgState-\u003eMaybe Params-\u003eBuilder a b-\u003ea-\u003eIO[GeniResult]",
          "package": "GenI",
          "partial": "Results",
          "signature": "ProgState-\u003eMaybe Params-\u003eBuilder st it-\u003est-\u003eIO[GeniResult]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:extractResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003egetTraces\u003c/a\u003e\u003c/code\u003e is most likely useful for grammars produced by a\n   metagrammar system.  Given a tree name, we retrieve the `\u003ccode\u003etrace'\u003c/code\u003e\n   information from the grammar for all trees that have this name.  We\n   assume the tree name was constructed by GenI; see the source code for\n   details.\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "getTraces",
          "package": "GenI",
          "signature": "ProgState -\u003e Text -\u003e [Text]",
          "source": "src/NLP-GenI.html#getTraces",
          "type": "function"
        },
        "index": {
          "description": "getTraces is most likely useful for grammars produced by metagrammar system Given tree name we retrieve the trace information from the grammar for all trees that have this name We assume the tree name was constructed by GenI see the source code for details",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "getTraces",
          "normalized": "ProgState-\u003eText-\u003e[Text]",
          "package": "GenI",
          "partial": "Traces",
          "signature": "ProgState-\u003eText-\u003e[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:getTraces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etree schemata\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "gr",
          "package": "GenI",
          "signature": "Macros",
          "source": "src/NLP-GenI.html#ProgState",
          "type": "function"
        },
        "index": {
          "description": "tree schemata",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "gr",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:gr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ederivation tree behind the result\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "grDerivation",
          "package": "GenI",
          "signature": "TagDerivation",
          "source": "src/NLP-GenI.html#GeniSuccess",
          "type": "function"
        },
        "index": {
          "description": "derivation tree behind the result",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "grDerivation",
          "package": "GenI",
          "partial": "Derivation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:grDerivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eusually from lexical selection\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "grGlobalWarnings",
          "package": "GenI",
          "signature": "[Text]",
          "source": "src/NLP-GenI.html#GeniResults",
          "type": "function"
        },
        "index": {
          "description": "usually from lexical selection",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "grGlobalWarnings",
          "normalized": "[Text]",
          "package": "GenI",
          "partial": "Global Warnings",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:grGlobalWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e&#8220;original&#8221; uninflected result\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "grLemmaSentence",
          "package": "GenI",
          "signature": "LemmaPlusSentence",
          "source": "src/NLP-GenI.html#GeniSuccess",
          "type": "function"
        },
        "index": {
          "description": "original uninflected result",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "grLemmaSentence",
          "package": "GenI",
          "partial": "Lemma Sentence",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:grLemmaSentence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe lexical selection behind\n   this result (info only)\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "grLexSelection",
          "package": "GenI",
          "signature": "[GeniLexSel]",
          "source": "src/NLP-GenI.html#GeniSuccess",
          "type": "function"
        },
        "index": {
          "description": "the lexical selection behind this result info only",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "grLexSelection",
          "normalized": "[GeniLexSel]",
          "package": "GenI",
          "partial": "Lex Selection",
          "signature": "[GeniLexSel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:grLexSelection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enormally a chart item id\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "grOrigin",
          "package": "GenI",
          "signature": "Integer",
          "source": "src/NLP-GenI.html#GeniSuccess",
          "type": "function"
        },
        "index": {
          "description": "normally chart item id",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "grOrigin",
          "package": "GenI",
          "partial": "Origin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:grOrigin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esee \u003ccode\u003e\u003ca\u003eOptimalityTheory\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "grRanking",
          "package": "GenI",
          "signature": "Int",
          "source": "src/NLP-GenI.html#GeniSuccess",
          "type": "function"
        },
        "index": {
          "description": "see OptimalityTheory",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "grRanking",
          "package": "GenI",
          "partial": "Ranking",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:grRanking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eresults after morphology\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "grRealisations",
          "package": "GenI",
          "signature": "[Text]",
          "source": "src/NLP-GenI.html#GeniSuccess",
          "type": "function"
        },
        "index": {
          "description": "results after morphology",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "grRealisations",
          "normalized": "[Text]",
          "package": "GenI",
          "partial": "Realisations",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:grRealisations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "grResultType",
          "package": "GenI",
          "signature": "ResultType",
          "source": "src/NLP-GenI.html#GeniSuccess",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "grResultType",
          "package": "GenI",
          "partial": "Result Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:grResultType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eone per chart item\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "grResults",
          "package": "GenI",
          "signature": "[GeniResult]",
          "source": "src/NLP-GenI.html#GeniResults",
          "type": "function"
        },
        "index": {
          "description": "one per chart item",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "grResults",
          "normalized": "[GeniResult]",
          "package": "GenI",
          "partial": "Results",
          "signature": "[GeniResult]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:grResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethings like number of chart items\n   to help study efficiency\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "grStatistics",
          "package": "GenI",
          "signature": "Statistics",
          "source": "src/NLP-GenI.html#GeniResults",
          "type": "function"
        },
        "index": {
          "description": "things like number of chart items to help study efficiency",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "grStatistics",
          "package": "GenI",
          "partial": "Statistics",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:grStatistics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewhich OT constraints were violated\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "grViolations",
          "package": "GenI",
          "signature": "[OtViolation]",
          "source": "src/NLP-GenI.html#GeniSuccess",
          "type": "function"
        },
        "index": {
          "description": "which OT constraints were violated",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "grViolations",
          "normalized": "[OtViolation]",
          "package": "GenI",
          "partial": "Violations",
          "signature": "[OtViolation]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:grViolations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewarnings &#8220;local&#8221; to this particular\n   item, cf. \u003ccode\u003e\u003ca\u003egrGlobalWarnings\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "grWarnings",
          "package": "GenI",
          "signature": "[Text]",
          "source": "src/NLP-GenI.html#GeniSuccess",
          "type": "function"
        },
        "index": {
          "description": "warnings local to this particular item cf grGlobalWarnings",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "grWarnings",
          "normalized": "[Text]",
          "package": "GenI",
          "partial": "Warnings",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:grWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003einitGeni\u003c/a\u003e\u003c/code\u003e performs lexical selection and strips the input semantics of\n   any morpohological literals\n\u003c/p\u003e\u003cp\u003eSee \u003ccode\u003e\u003ca\u003edefaultCustomSem\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "initGeni",
          "package": "GenI",
          "signature": "ProgState -\u003e CustomSem sem -\u003e sem -\u003e ErrorIO (Input, GeniWarnings)",
          "source": "src/NLP-GenI.html#initGeni",
          "type": "function"
        },
        "index": {
          "description": "initGeni performs lexical selection and strips the input semantics of any morpohological literals See defaultCustomSem",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "initGeni",
          "normalized": "ProgState-\u003eCustomSem a-\u003ea-\u003eErrorIO(Input,GeniWarnings)",
          "package": "GenI",
          "partial": "Geni",
          "signature": "ProgState-\u003eCustomSem sem-\u003esem-\u003eErrorIO(Input,GeniWarnings)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:initGeni"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "isSuccess",
          "package": "GenI",
          "signature": "GeniResult -\u003e Bool",
          "source": "src/NLP-GenI.html#isSuccess",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "isSuccess",
          "normalized": "GeniResult-\u003eBool",
          "package": "GenI",
          "partial": "Success",
          "signature": "GeniResult-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:isSuccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "lParse",
          "package": "GenI",
          "signature": "lParse",
          "source": "src/NLP-GenI.html#lParse",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "lParse",
          "package": "GenI",
          "partial": "Parse",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:lParse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "lSet",
          "package": "GenI",
          "signature": "x -\u003e ProgState -\u003e ProgState",
          "source": "src/NLP-GenI.html#lSet",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "lSet",
          "normalized": "a-\u003eProgState-\u003eProgState",
          "package": "GenI",
          "partial": "Set",
          "signature": "x-\u003eProgState-\u003eProgState",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:lSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "lSummarise",
          "package": "GenI",
          "signature": "x -\u003e String",
          "source": "src/NLP-GenI.html#lSummarise",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "lSummarise",
          "normalized": "a-\u003eString",
          "package": "GenI",
          "partial": "Summarise",
          "signature": "x-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:lSummarise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elexical entries\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "le",
          "package": "GenI",
          "signature": "Lexicon",
          "source": "src/NLP-GenI.html#ProgState",
          "type": "function"
        },
        "index": {
          "description": "lexical entries",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "le",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:le"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo morphology! Pretend the lemma string is a sentence\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "lemmaSentenceString",
          "package": "GenI",
          "signature": "GeniSuccess -\u003e Text",
          "source": "src/NLP-GenI.html#lemmaSentenceString",
          "type": "function"
        },
        "index": {
          "description": "No morphology Pretend the lemma string is sentence",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "lemmaSentenceString",
          "normalized": "GeniSuccess-\u003eText",
          "package": "GenI",
          "partial": "Sentence String",
          "signature": "GeniSuccess-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:lemmaSentenceString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe have one master function that loads all the files GenI is expected to\n   use.  This just calls the sub-loaders below, some of which are exported\n   for use by the graphical interface.  The master function also makes sure\n   to complain intelligently if some of the required files are missing.\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "loadEverything",
          "package": "GenI",
          "signature": "ProgStateRef -\u003e CustomSem sem -\u003e IO ()",
          "source": "src/NLP-GenI.html#loadEverything",
          "type": "function"
        },
        "index": {
          "description": "We have one master function that loads all the files GenI is expected to use This just calls the sub-loaders below some of which are exported for use by the graphical interface The master function also makes sure to complain intelligently if some of the required files are missing",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "loadEverything",
          "normalized": "ProgStateRef-\u003eCustomSem a-\u003eIO()",
          "package": "GenI",
          "partial": "Everything",
          "signature": "ProgStateRef-\u003eCustomSem sem-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:loadEverything"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLoad something from a string rather than a file\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "loadFromString",
          "package": "GenI",
          "signature": "ProgStateRef-\u003e String-\u003e Text-\u003e IO a",
          "type": "function"
        },
        "index": {
          "description": "Load something from string rather than file",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "loadFromString",
          "normalized": "ProgStateRef-\u003eString-\u003eText-\u003eIO a",
          "package": "GenI",
          "partial": "From String",
          "signature": "ProgStateRef-\u003eString-\u003eText-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:loadFromString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe macros are stored as a hashing function in the monad.\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "loadGeniMacros",
          "package": "GenI",
          "signature": "ProgStateRef -\u003e IO Macros",
          "source": "src/NLP-GenI.html#loadGeniMacros",
          "type": "function"
        },
        "index": {
          "description": "The macros are stored as hashing function in the monad",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "loadGeniMacros",
          "normalized": "ProgStateRef-\u003eIO Macros",
          "package": "GenI",
          "partial": "Geni Macros",
          "signature": "ProgStateRef-\u003eIO Macros",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:loadGeniMacros"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "loadLexicon",
          "package": "GenI",
          "signature": "ProgStateRef -\u003e IO Lexicon",
          "source": "src/NLP-GenI.html#loadLexicon",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "loadLexicon",
          "normalized": "ProgStateRef-\u003eIO Lexicon",
          "package": "GenI",
          "partial": "Lexicon",
          "signature": "ProgStateRef-\u003eIO Lexicon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:loadLexicon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "loadRanking",
          "package": "GenI",
          "signature": "ProgStateRef -\u003e IO ()",
          "source": "src/NLP-GenI.html#loadRanking",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "loadRanking",
          "normalized": "ProgStateRef-\u003eIO()",
          "package": "GenI",
          "partial": "Ranking",
          "signature": "ProgStateRef-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:loadRanking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "loadTestSuite",
          "package": "GenI",
          "signature": "ProgState -\u003e CustomSem sem -\u003e IO [TestCase sem]",
          "source": "src/NLP-GenI.html#loadTestSuite",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "loadTestSuite",
          "normalized": "ProgState-\u003eCustomSem a-\u003eIO[TestCase a]",
          "package": "GenI",
          "partial": "Test Suite",
          "signature": "ProgState-\u003eCustomSem sem-\u003eIO[TestCase sem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:loadTestSuite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction to extract morphological\n information from the semantics (you may\n instead be looking for\n \u003ccode\u003e\u003ca\u003ecustomMorph\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "morphinf",
          "package": "GenI",
          "signature": "MorphInputFn",
          "source": "src/NLP-GenI.html#ProgState",
          "type": "function"
        },
        "index": {
          "description": "function to extract morphological information from the semantics you may instead be looking for customMorph",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "morphinf",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:morphinf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "nlTrace",
          "package": "GenI",
          "signature": "[Text]",
          "source": "src/NLP-GenI.html#GeniLexSel",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "nlTrace",
          "normalized": "[Text]",
          "package": "GenI",
          "partial": "Trace",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:nlTrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "nlTree",
          "package": "GenI",
          "signature": "Text",
          "source": "src/NLP-GenI.html#GeniLexSel",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "nlTree",
          "package": "GenI",
          "partial": "Tree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:nlTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe current configuration\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "pa",
          "package": "GenI",
          "signature": "Params",
          "source": "src/NLP-GenI.html#ProgState",
          "type": "function"
        },
        "index": {
          "description": "the current configuration",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "pa",
          "package": "GenI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:pa"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "parseSemInput",
          "package": "GenI",
          "signature": "Text -\u003e Either ParseError SemInput",
          "source": "src/NLP-GenI.html#parseSemInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "parseSemInput",
          "normalized": "Text-\u003eEither ParseError SemInput",
          "package": "GenI",
          "partial": "Sem Input",
          "signature": "Text-\u003eEither ParseError SemInput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:parseSemInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.GenI",
          "name": "prettyResult",
          "package": "GenI",
          "signature": "ProgState -\u003e GeniSuccess -\u003e Text",
          "source": "src/NLP-GenI.html#prettyResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "prettyResult",
          "normalized": "ProgState-\u003eGeniSuccess-\u003eText",
          "package": "GenI",
          "partial": "Result",
          "signature": "ProgState-\u003eGeniSuccess-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:prettyResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEntry point! (the most useful function to know here)\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Initialises the realiser (lexical selection, among other things),\n\u003c/li\u003e\u003cli\u003e Runs the builder (the surface realisation engine proper)\n\u003c/li\u003e\u003cli\u003e Unpacks the builder results\n\u003c/li\u003e\u003cli\u003e Finalises the results (morphological generation)\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIn addition to the results, this returns a generator state.  The latter is\n   is mostly useful for debugging via the graphical interface.\n   Note that we assumes that you have already loaded in your grammar and\n   parsed your input semantics.\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "runGeni",
          "package": "GenI",
          "signature": "ProgState -\u003e CustomSem sem -\u003e Builder st it -\u003e TestCase sem -\u003e ErrorIO (GeniResults, st)",
          "source": "src/NLP-GenI.html#runGeni",
          "type": "function"
        },
        "index": {
          "description": "Entry point the most useful function to know here Initialises the realiser lexical selection among other things Runs the builder the surface realisation engine proper Unpacks the builder results Finalises the results morphological generation In addition to the results this returns generator state The latter is is mostly useful for debugging via the graphical interface Note that we assumes that you have already loaded in your grammar and parsed your input semantics",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "runGeni",
          "normalized": "ProgState-\u003eCustomSem a-\u003eBuilder b c-\u003eTestCase a-\u003eErrorIO(GeniResults,b)",
          "package": "GenI",
          "partial": "Geni",
          "signature": "ProgState-\u003eCustomSem sem-\u003eBuilder st it-\u003eTestCase sem-\u003eErrorIO(GeniResults,st)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:runGeni"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow the sentences produced by the generator, in a relatively compact form\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "showRealisations",
          "package": "GenI",
          "signature": "[String] -\u003e String",
          "source": "src/NLP-GenI.html#showRealisations",
          "type": "function"
        },
        "index": {
          "description": "Show the sentences produced by the generator in relatively compact form",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "showRealisations",
          "normalized": "[String]-\u003eString",
          "package": "GenI",
          "partial": "Realisations",
          "signature": "[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:showRealisations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esimplifyResults \u003ca\u003e$\u003c/a\u003e runGenI...'\u003c/code\u003e for an easier time if you don't need the\n   surface realiser state\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "simplifyResults",
          "package": "GenI",
          "signature": "Either Text (GeniResults, st) -\u003e GeniResults",
          "source": "src/NLP-GenI.html#simplifyResults",
          "type": "function"
        },
        "index": {
          "description": "simplifyResults runGenI for an easier time if you don need the surface realiser state",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "simplifyResults",
          "normalized": "Either Text(GeniResults,a)-\u003eGeniResults",
          "package": "GenI",
          "partial": "Results",
          "signature": "Either Text(GeniResults,st)-\u003eGeniResults",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:simplifyResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esimplified traces (optional)\n\u003c/p\u003e",
          "module": "NLP.GenI",
          "name": "traces",
          "package": "GenI",
          "signature": "[Text]",
          "source": "src/NLP-GenI.html#ProgState",
          "type": "function"
        },
        "index": {
          "description": "simplified traces optional",
          "hierarchy": "NLP GenI",
          "module": "NLP.GenI",
          "name": "traces",
          "normalized": "[Text]",
          "package": "GenI",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GenI/docs/NLP-GenI.html#v:traces"
      }
    }
  ]
]