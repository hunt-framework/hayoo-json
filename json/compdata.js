[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "compdata"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the notion of algebras and catamorphisms, and their\n generalizations to e.g. monadic versions and other (co)recursion schemes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Algebra",
          "name": "Algebra",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the notion of algebras and catamorphisms and their generalizations to e.g monadic versions and other co recursion schemes",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "Algebra",
          "package": "compdata",
          "partial": "Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents an algebra over a functor \u003ccode\u003ef\u003c/code\u003e and carrier\n\u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "Alg",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#Alg",
          "type": "type"
        },
        "index": {
          "description": "This type represents an algebra over functor and carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "Alg",
          "package": "compdata",
          "partial": "Alg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:Alg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic algebra. It is similar to \u003ccode\u003e\u003ca\u003eAlg\u003c/a\u003e\u003c/code\u003e but\nthe return type is monadic.  \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "AlgM",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#AlgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic algebra It is similar to Alg but the return type is monadic",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "AlgM",
          "package": "compdata",
          "partial": "Alg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:AlgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a cv-algebra over a functor \u003ccode\u003ef\u003c/code\u003e and carrier \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "CVAlg",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#CVAlg",
          "type": "type"
        },
        "index": {
          "description": "This type represents cv-algebra over functor and carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "CVAlg",
          "package": "compdata",
          "partial": "CVAlg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:CVAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic cv-algebra over a functor \u003ccode\u003ef\u003c/code\u003e and carrier\n  \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "CVAlgM",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#CVAlgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic cv-algebra over functor and carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "CVAlgM",
          "package": "compdata",
          "partial": "CVAlg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:CVAlgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a cv-coalgebra over a functor \u003ccode\u003ef\u003c/code\u003e and carrier \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "CVCoalg",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#CVCoalg",
          "type": "type"
        },
        "index": {
          "description": "This type represents cv-coalgebra over functor and carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "CVCoalg",
          "package": "compdata",
          "partial": "CVCoalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:CVCoalg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a generalised cv-coalgebra over a functor \u003ccode\u003ef\u003c/code\u003e and\n  carrier \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "CVCoalg'",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#CVCoalg%27",
          "type": "type"
        },
        "index": {
          "description": "This type represents generalised cv-coalgebra over functor and carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "CVCoalg'",
          "package": "compdata",
          "partial": "CVCoalg'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:CVCoalg-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic cv-coalgebra over a functor \u003ccode\u003ef\u003c/code\u003e and carrier\n  \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "CVCoalgM",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#CVCoalgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic cv-coalgebra over functor and carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "CVCoalgM",
          "package": "compdata",
          "partial": "CVCoalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:CVCoalgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a coalgebra over a functor \u003ccode\u003ef\u003c/code\u003e and carrier \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "Coalg",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#Coalg",
          "type": "type"
        },
        "index": {
          "description": "This type represents coalgebra over functor and carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "Coalg",
          "package": "compdata",
          "partial": "Coalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:Coalg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic coalgebra over a functor \u003ccode\u003ef\u003c/code\u003e and carrier\n  \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "CoalgM",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#CoalgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic coalgebra over functor and carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "CoalgM",
          "package": "compdata",
          "partial": "Coalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:CoalgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a context function. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "CxtFun",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#CxtFun",
          "type": "type"
        },
        "index": {
          "description": "This type represents context function",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "CxtFun",
          "package": "compdata",
          "partial": "Cxt Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:CxtFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic context function.\n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "CxtFunM",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#CxtFunM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic context function",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "CxtFunM",
          "package": "compdata",
          "partial": "Cxt Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:CxtFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a term homomorphism. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "Hom",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#Hom",
          "type": "type"
        },
        "index": {
          "description": "This type represents term homomorphism",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "Hom",
          "package": "compdata",
          "partial": "Hom",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:Hom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic term homomorphism.  \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "HomM",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#HomM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic term homomorphism",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "HomM",
          "package": "compdata",
          "partial": "Hom",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:HomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic term homomorphism. It is similar to\n\u003ccode\u003e\u003ca\u003eHomM\u003c/a\u003e\u003c/code\u003e but has monadic values also in the domain. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "HomMD",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#HomMD",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic term homomorphism It is similar to HomM but has monadic values also in the domain",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "HomMD",
          "package": "compdata",
          "partial": "Hom MD",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:HomMD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents an r-algebra over a functor \u003ccode\u003ef\u003c/code\u003e and carrier \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "RAlg",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#RAlg",
          "type": "type"
        },
        "index": {
          "description": "This type represents an r-algebra over functor and carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "RAlg",
          "package": "compdata",
          "partial": "RAlg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:RAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic r-algebra over a functor \u003ccode\u003ef\u003c/code\u003e and carrier\n  \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "RAlgM",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#RAlgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic r-algebra over functor and carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "RAlgM",
          "package": "compdata",
          "partial": "RAlg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:RAlgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents an r-coalgebra over a functor \u003ccode\u003ef\u003c/code\u003e and carrier \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "RCoalg",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#RCoalg",
          "type": "type"
        },
        "index": {
          "description": "This type represents an r-coalgebra over functor and carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "RCoalg",
          "package": "compdata",
          "partial": "RCoalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:RCoalg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic r-coalgebra over a functor \u003ccode\u003ef\u003c/code\u003e and carrier\n  \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "RCoalgM",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#RCoalgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic r-coalgebra over functor and carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "RCoalgM",
          "package": "compdata",
          "partial": "RCoalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:RCoalgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a signature function.\n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "SigFun",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#SigFun",
          "type": "type"
        },
        "index": {
          "description": "This type represents signature function",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "SigFun",
          "package": "compdata",
          "partial": "Sig Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:SigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic signature function. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "SigFunM",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#SigFunM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic signature function",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "SigFunM",
          "package": "compdata",
          "partial": "Sig Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:SigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic signature function.  It is similar\nto \u003ccode\u003e\u003ca\u003eSigFunM\u003c/a\u003e\u003c/code\u003e but has monadic values also in the domain. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "SigFunMD",
          "package": "compdata",
          "source": "src/Data-Comp-Algebra.html#SigFunMD",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic signature function It is similar to SigFunM but has monadic values also in the domain",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "SigFunMD",
          "package": "compdata",
          "partial": "Sig Fun MD",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#t:SigFunMD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a monadic algebra into an ordinary algebra with a monadic\n  carrier. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "algM",
          "package": "compdata",
          "signature": "AlgM m f a -\u003e Alg f (m a)",
          "source": "src/Data-Comp-Algebra.html#algM",
          "type": "function"
        },
        "index": {
          "description": "Convert monadic algebra into an ordinary algebra with monadic carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "algM",
          "normalized": "AlgM a b c-\u003eAlg b(a c)",
          "package": "compdata",
          "signature": "AlgM m f a-\u003eAlg f(m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:algM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an anamorphism from the given coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "ana",
          "package": "compdata",
          "signature": "Coalg f a -\u003e a -\u003e Term f",
          "source": "src/Data-Comp-Algebra.html#ana",
          "type": "function"
        },
        "index": {
          "description": "Construct an anamorphism from the given coalgebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "ana",
          "normalized": "Coalg a b-\u003eb-\u003eTerm a",
          "package": "compdata",
          "signature": "Coalg f a-\u003ea-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:ana"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShortcut fusion variant of \u003ccode\u003e\u003ca\u003eana\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "ana'",
          "package": "compdata",
          "signature": "Coalg f a -\u003e a -\u003e Term f",
          "source": "src/Data-Comp-Algebra.html#ana%27",
          "type": "function"
        },
        "index": {
          "description": "Shortcut fusion variant of ana",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "ana'",
          "normalized": "Coalg a b-\u003eb-\u003eTerm a",
          "package": "compdata",
          "signature": "Coalg f a-\u003ea-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:ana-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic anamorphism from the given monadic coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "anaM",
          "package": "compdata",
          "signature": "CoalgM m f a -\u003e a -\u003e m (Term f)",
          "source": "src/Data-Comp-Algebra.html#anaM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic anamorphism from the given monadic coalgebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "anaM",
          "normalized": "CoalgM a b c-\u003ec-\u003ea(Term b)",
          "package": "compdata",
          "signature": "CoalgM m f a-\u003ea-\u003em(Term f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:anaM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an apomorphism from the given r-coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "apo",
          "package": "compdata",
          "signature": "RCoalg f a -\u003e a -\u003e Term f",
          "source": "src/Data-Comp-Algebra.html#apo",
          "type": "function"
        },
        "index": {
          "description": "Construct an apomorphism from the given r-coalgebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "apo",
          "normalized": "RCoalg a b-\u003eb-\u003eTerm a",
          "package": "compdata",
          "signature": "RCoalg f a-\u003ea-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:apo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic apomorphism from the given monadic r-coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "apoM",
          "package": "compdata",
          "signature": "RCoalgM m f a -\u003e a -\u003e m (Term f)",
          "source": "src/Data-Comp-Algebra.html#apoM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic apomorphism from the given monadic r-coalgebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "apoM",
          "normalized": "RCoalgM a b c-\u003ec-\u003ea(Term b)",
          "package": "compdata",
          "signature": "RCoalgM m f a-\u003ea-\u003em(Term f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:apoM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a whole context into another context. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "appCxt",
          "package": "compdata",
          "signature": "Context f (Cxt h f a) -\u003e Cxt h f a",
          "source": "src/Data-Comp-Algebra.html#appCxt",
          "type": "function"
        },
        "index": {
          "description": "This function applies whole context into another context",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "appCxt",
          "normalized": "Context a(Cxt b a c)-\u003eCxt b a c",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "Context f(Cxt h f a)-\u003eCxt h f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:appCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies the given term homomorphism to a\nterm/context. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "appHom",
          "package": "compdata",
          "signature": "Hom f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-Algebra.html#appHom",
          "type": "function"
        },
        "index": {
          "description": "This function applies the given term homomorphism to term context",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "appHom",
          "normalized": "Hom a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Hom",
          "signature": "Hom f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:appHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a term homomorphism recursively to a term/context. This is\n a top-down variant of \u003ccode\u003e\u003ca\u003eappHom\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "appHom'",
          "package": "compdata",
          "signature": "Hom f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-Algebra.html#appHom%27",
          "type": "function"
        },
        "index": {
          "description": "Apply term homomorphism recursively to term context This is top-down variant of appHom",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "appHom'",
          "normalized": "Hom a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Hom'",
          "signature": "Hom f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:appHom-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a monadic term homomorphism recursively to a term/context. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "appHomM",
          "package": "compdata",
          "signature": "HomM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Algebra.html#appHomM",
          "type": "function"
        },
        "index": {
          "description": "Apply monadic term homomorphism recursively to term context",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "appHomM",
          "normalized": "HomM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Hom",
          "signature": "HomM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:appHomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a monadic term homomorphism recursively to a\n term/context. This a top-down variant of \u003ccode\u003e\u003ca\u003eappHomM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "appHomM'",
          "package": "compdata",
          "signature": "HomM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Algebra.html#appHomM%27",
          "type": "function"
        },
        "index": {
          "description": "Apply monadic term homomorphism recursively to term context This top-down variant of appHomM",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "appHomM'",
          "normalized": "HomM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Hom M'",
          "signature": "HomM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:appHomM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a signature function to the given context. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "appSigFun",
          "package": "compdata",
          "signature": "SigFun f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-Algebra.html#appSigFun",
          "type": "function"
        },
        "index": {
          "description": "This function applies signature function to the given context",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "appSigFun",
          "normalized": "SigFun a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFun f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:appSigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a signature function to the given\n context. This is a top-down variant of \u003ccode\u003e\u003ca\u003eappSigFun\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "appSigFun'",
          "package": "compdata",
          "signature": "SigFun f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-Algebra.html#appSigFun%27",
          "type": "function"
        },
        "index": {
          "description": "This function applies signature function to the given context This is top-down variant of appSigFun",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "appSigFun'",
          "normalized": "SigFun a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Sig Fun'",
          "signature": "SigFun f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:appSigFun-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a monadic signature function to the given context. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "appSigFunM",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Algebra.html#appSigFunM",
          "type": "function"
        },
        "index": {
          "description": "This function applies monadic signature function to the given context",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "appSigFunM",
          "normalized": "SigFunM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFunM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:appSigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a monadic signature function to the given\n context. This is a top-down variant of \u003ccode\u003e\u003ca\u003eappSigFunM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "appSigFunM'",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Algebra.html#appSigFunM%27",
          "type": "function"
        },
        "index": {
          "description": "This function applies monadic signature function to the given context This is top-down variant of appSigFunM",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "appSigFunM'",
          "normalized": "SigFunM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Sig Fun M'",
          "signature": "SigFunM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:appSigFunM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a signature function to the given context. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "appSigFunMD",
          "package": "compdata",
          "signature": "SigFunMD m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Algebra.html#appSigFunMD",
          "type": "function"
        },
        "index": {
          "description": "This function applies signature function to the given context",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "appSigFunMD",
          "normalized": "SigFunMD a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Sig Fun MD",
          "signature": "SigFunMD m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:appSigFunMD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a catamorphism from the given algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "cata",
          "package": "compdata",
          "signature": "Alg f a -\u003e Term f -\u003e a",
          "source": "src/Data-Comp-Algebra.html#cata",
          "type": "function"
        },
        "index": {
          "description": "Construct catamorphism from the given algebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "cata",
          "normalized": "Alg a b-\u003eTerm a-\u003eb",
          "package": "compdata",
          "signature": "Alg f a-\u003eTerm f-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:cata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalisation of \u003ccode\u003e\u003ca\u003ecata\u003c/a\u003e\u003c/code\u003e from terms over \u003ccode\u003ef\u003c/code\u003e to contexts over \u003ccode\u003ef\u003c/code\u003e, where\n  the holes have the type of the algebra carrier. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "cata'",
          "package": "compdata",
          "signature": "Alg f a -\u003e Cxt h f a -\u003e a",
          "source": "src/Data-Comp-Algebra.html#cata%27",
          "type": "function"
        },
        "index": {
          "description": "generalisation of cata from terms over to contexts over where the holes have the type of the algebra carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "cata'",
          "normalized": "Alg a b-\u003eCxt c a b-\u003eb",
          "package": "compdata",
          "signature": "Alg f a-\u003eCxt h f a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:cata-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic catamorphism from the given monadic algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "cataM",
          "package": "compdata",
          "signature": "AlgM m f a -\u003e Term f -\u003e m a",
          "source": "src/Data-Comp-Algebra.html#cataM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic catamorphism from the given monadic algebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "cataM",
          "normalized": "AlgM a b c-\u003eTerm b-\u003ea c",
          "package": "compdata",
          "signature": "AlgM m f a-\u003eTerm f-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:cataM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalisation of \u003ccode\u003e\u003ca\u003ecataM\u003c/a\u003e\u003c/code\u003e from terms over \u003ccode\u003ef\u003c/code\u003e to contexts over \u003ccode\u003ef\u003c/code\u003e, where\n  the holes have the type of the monadic algebra carrier. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "cataM'",
          "package": "compdata",
          "signature": "AlgM m f a -\u003e Cxt h f a -\u003e m a",
          "source": "src/Data-Comp-Algebra.html#cataM%27",
          "type": "function"
        },
        "index": {
          "description": "generalisation of cataM from terms over to contexts over where the holes have the type of the monadic algebra carrier",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "cataM'",
          "normalized": "AlgM a b c-\u003eCxt d b c-\u003ea c",
          "package": "compdata",
          "partial": "M'",
          "signature": "AlgM m f a-\u003eCxt h f a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:cataM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose an algebra with a term homomorphism to get a new algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "compAlg",
          "package": "compdata",
          "signature": "Alg g a -\u003e Hom f g -\u003e Alg f a",
          "source": "src/Data-Comp-Algebra.html#compAlg",
          "type": "function"
        },
        "index": {
          "description": "Compose an algebra with term homomorphism to get new algebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compAlg",
          "normalized": "Alg a b-\u003eHom c a-\u003eAlg c b",
          "package": "compdata",
          "partial": "Alg",
          "signature": "Alg g a-\u003eHom f g-\u003eAlg f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose a monadic algebra with a monadic term homomorphism to get a new\n  monadic algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "compAlgM",
          "package": "compdata",
          "signature": "AlgM m g a -\u003e HomM m f g -\u003e AlgM m f a",
          "source": "src/Data-Comp-Algebra.html#compAlgM",
          "type": "function"
        },
        "index": {
          "description": "Compose monadic algebra with monadic term homomorphism to get new monadic algebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compAlgM",
          "normalized": "AlgM a b c-\u003eHomM a d b-\u003eAlgM a d c",
          "package": "compdata",
          "partial": "Alg",
          "signature": "AlgM m g a-\u003eHomM m f g-\u003eAlgM m f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compAlgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose a monadic algebra with a term homomorphism to get a new monadic\n  algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "compAlgM'",
          "package": "compdata",
          "signature": "AlgM m g a -\u003e Hom f g -\u003e AlgM m f a",
          "source": "src/Data-Comp-Algebra.html#compAlgM%27",
          "type": "function"
        },
        "index": {
          "description": "Compose monadic algebra with term homomorphism to get new monadic algebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compAlgM'",
          "normalized": "AlgM a b c-\u003eHom d b-\u003eAlgM a d c",
          "package": "compdata",
          "partial": "Alg M'",
          "signature": "AlgM m g a-\u003eHom f g-\u003eAlgM m f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compAlgM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes an algebra with a signature function.\n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "compAlgSigFun",
          "package": "compdata",
          "signature": "Alg g a -\u003e SigFun f g -\u003e Alg f a",
          "source": "src/Data-Comp-Algebra.html#compAlgSigFun",
          "type": "function"
        },
        "index": {
          "description": "This function composes an algebra with signature function",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compAlgSigFun",
          "normalized": "Alg a b-\u003eSigFun c a-\u003eAlg c b",
          "package": "compdata",
          "partial": "Alg Sig Fun",
          "signature": "Alg g a-\u003eSigFun f g-\u003eAlg f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compAlgSigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two monadic signature functions.  \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "compAlgSigFunM",
          "package": "compdata",
          "signature": "AlgM m g a -\u003e SigFunM m f g -\u003e AlgM m f a",
          "source": "src/Data-Comp-Algebra.html#compAlgSigFunM",
          "type": "function"
        },
        "index": {
          "description": "This function composes two monadic signature functions",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compAlgSigFunM",
          "normalized": "AlgM a b c-\u003eSigFunM a d b-\u003eAlgM a d c",
          "package": "compdata",
          "partial": "Alg Sig Fun",
          "signature": "AlgM m g a-\u003eSigFunM m f g-\u003eAlgM m f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compAlgSigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose a term homomorphism with a cv-coalgebra to get a new cv-coalgebra.\n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "compCVCoalg",
          "package": "compdata",
          "signature": "Hom f g -\u003e CVCoalg' f a -\u003e CVCoalg' g a",
          "source": "src/Data-Comp-Algebra.html#compCVCoalg",
          "type": "function"
        },
        "index": {
          "description": "Compose term homomorphism with cv-coalgebra to get new cv-coalgebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compCVCoalg",
          "normalized": "Hom a b-\u003eCVCoalg' a c-\u003eCVCoalg' b c",
          "package": "compdata",
          "partial": "CVCoalg",
          "signature": "Hom f g-\u003eCVCoalg' f a-\u003eCVCoalg' g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compCVCoalg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose a term homomorphism with a coalgebra to get a cv-coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "compCoalg",
          "package": "compdata",
          "signature": "Hom f g -\u003e Coalg f a -\u003e CVCoalg' g a",
          "source": "src/Data-Comp-Algebra.html#compCoalg",
          "type": "function"
        },
        "index": {
          "description": "Compose term homomorphism with coalgebra to get cv-coalgebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compCoalg",
          "normalized": "Hom a b-\u003eCoalg a c-\u003eCVCoalg' b c",
          "package": "compdata",
          "partial": "Coalg",
          "signature": "Hom f g-\u003eCoalg f a-\u003eCVCoalg' g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compCoalg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose two term homomorphisms. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "compHom",
          "package": "compdata",
          "signature": "Hom g h -\u003e Hom f g -\u003e Hom f h",
          "source": "src/Data-Comp-Algebra.html#compHom",
          "type": "function"
        },
        "index": {
          "description": "Compose two term homomorphisms",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compHom",
          "normalized": "Hom a b-\u003eHom c a-\u003eHom c b",
          "package": "compdata",
          "partial": "Hom",
          "signature": "Hom g h-\u003eHom f g-\u003eHom f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose two monadic term homomorphisms. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "compHomM",
          "package": "compdata",
          "signature": "HomM m g h -\u003e HomM m f g -\u003e HomM m f h",
          "source": "src/Data-Comp-Algebra.html#compHomM",
          "type": "function"
        },
        "index": {
          "description": "Compose two monadic term homomorphisms",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compHomM",
          "normalized": "HomM a b c-\u003eHomM a d b-\u003eHomM a d c",
          "package": "compdata",
          "partial": "Hom",
          "signature": "HomM m g h-\u003eHomM m f g-\u003eHomM m f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compHomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a term homomorphism with a signature function.\n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "compHomSigFun",
          "package": "compdata",
          "signature": "Hom g h -\u003e SigFun f g -\u003e Hom f h",
          "source": "src/Data-Comp-Algebra.html#compHomSigFun",
          "type": "function"
        },
        "index": {
          "description": "This function composes term homomorphism with signature function",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compHomSigFun",
          "normalized": "Hom a b-\u003eSigFun c a-\u003eHom c b",
          "package": "compdata",
          "partial": "Hom Sig Fun",
          "signature": "Hom g h-\u003eSigFun f g-\u003eHom f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compHomSigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two monadic signature functions.  \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "compHomSigFunM",
          "package": "compdata",
          "signature": "HomM m g h -\u003e SigFunM m f g -\u003e HomM m f h",
          "source": "src/Data-Comp-Algebra.html#compHomSigFunM",
          "type": "function"
        },
        "index": {
          "description": "This function composes two monadic signature functions",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compHomSigFunM",
          "normalized": "HomM a b c-\u003eSigFunM a d b-\u003eHomM a d c",
          "package": "compdata",
          "partial": "Hom Sig Fun",
          "signature": "HomM m g h-\u003eSigFunM m f g-\u003eHomM m f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compHomSigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two signature functions. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "compSigFun",
          "package": "compdata",
          "signature": "SigFun g h -\u003e SigFun f g -\u003e SigFun f h",
          "source": "src/Data-Comp-Algebra.html#compSigFun",
          "type": "function"
        },
        "index": {
          "description": "This function composes two signature functions",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compSigFun",
          "normalized": "SigFun a b-\u003eSigFun c a-\u003eSigFun c b",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFun g h-\u003eSigFun f g-\u003eSigFun f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compSigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a signature function with a term\n homomorphism.\n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "compSigFunHom",
          "package": "compdata",
          "signature": "SigFun g h -\u003e Hom f g -\u003e Hom f h",
          "source": "src/Data-Comp-Algebra.html#compSigFunHom",
          "type": "function"
        },
        "index": {
          "description": "This function composes signature function with term homomorphism",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compSigFunHom",
          "normalized": "SigFun a b-\u003eHom c a-\u003eHom c b",
          "package": "compdata",
          "partial": "Sig Fun Hom",
          "signature": "SigFun g h-\u003eHom f g-\u003eHom f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compSigFunHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Algebra",
          "name": "compSigFunHomM",
          "package": "compdata",
          "signature": "SigFunM m g h -\u003e HomM m f g -\u003e HomM m f h",
          "source": "src/Data-Comp-Algebra.html#compSigFunHomM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compSigFunHomM",
          "normalized": "SigFunM a b c-\u003eHomM a d b-\u003eHomM a d c",
          "package": "compdata",
          "partial": "Sig Fun Hom",
          "signature": "SigFunM m g h-\u003eHomM m f g-\u003eHomM m f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compSigFunHomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two monadic signature functions.  \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "compSigFunM",
          "package": "compdata",
          "signature": "SigFunM m g h -\u003e SigFunM m f g -\u003e SigFunM m f h",
          "source": "src/Data-Comp-Algebra.html#compSigFunM",
          "type": "function"
        },
        "index": {
          "description": "This function composes two monadic signature functions",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "compSigFunM",
          "normalized": "SigFunM a b c-\u003eSigFunM a d b-\u003eSigFunM a d c",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFunM m g h-\u003eSigFunM m f g-\u003eSigFunM m f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:compSigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a catamorphism for contexts over \u003ccode\u003ef\u003c/code\u003e with holes of type \u003ccode\u003ea\u003c/code\u003e, from\n  the given algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "free",
          "package": "compdata",
          "signature": "Alg f b -\u003e (a -\u003e b) -\u003e Cxt h f a -\u003e b",
          "source": "src/Data-Comp-Algebra.html#free",
          "type": "function"
        },
        "index": {
          "description": "Construct catamorphism for contexts over with holes of type from the given algebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "free",
          "normalized": "Alg a b-\u003e(c-\u003eb)-\u003eCxt d a c-\u003eb",
          "package": "compdata",
          "signature": "Alg f b-\u003e(a-\u003eb)-\u003eCxt h f a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:free"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic catamorphism for contexts over \u003ccode\u003ef\u003c/code\u003e with holes of type\n  \u003ccode\u003ea\u003c/code\u003e, from the given monadic algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "freeM",
          "package": "compdata",
          "signature": "AlgM m f b -\u003e (a -\u003e m b) -\u003e Cxt h f a -\u003e m b",
          "source": "src/Data-Comp-Algebra.html#freeM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic catamorphism for contexts over with holes of type from the given monadic algebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "freeM",
          "normalized": "AlgM a b c-\u003e(d-\u003ea c)-\u003eCxt e b d-\u003ea c",
          "package": "compdata",
          "signature": "AlgM m f b-\u003e(a-\u003em b)-\u003eCxt h f a-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:freeM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a futumorphism from the given cv-coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "futu",
          "package": "compdata",
          "signature": "CVCoalg f a -\u003e a -\u003e Term f",
          "source": "src/Data-Comp-Algebra.html#futu",
          "type": "function"
        },
        "index": {
          "description": "Construct futumorphism from the given cv-coalgebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "futu",
          "normalized": "CVCoalg a b-\u003eb-\u003eTerm a",
          "package": "compdata",
          "signature": "CVCoalg f a-\u003ea-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:futu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a futumorphism from the given generalised cv-coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "futu'",
          "package": "compdata",
          "signature": "CVCoalg' f a -\u003e a -\u003e Term f",
          "source": "src/Data-Comp-Algebra.html#futu%27",
          "type": "function"
        },
        "index": {
          "description": "Construct futumorphism from the given generalised cv-coalgebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "futu'",
          "normalized": "CVCoalg' a b-\u003eb-\u003eTerm a",
          "package": "compdata",
          "signature": "CVCoalg' f a-\u003ea-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:futu-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic futumorphism from the given monadic cv-coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "futuM",
          "package": "compdata",
          "signature": "CVCoalgM m f a -\u003e a -\u003e m (Term f)",
          "source": "src/Data-Comp-Algebra.html#futuM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic futumorphism from the given monadic cv-coalgebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "futuM",
          "normalized": "CVCoalgM a b c-\u003ec-\u003ea(Term b)",
          "package": "compdata",
          "signature": "CVCoalgM m f a-\u003ea-\u003em(Term f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:futuM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a histomorphism from the given cv-algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "histo",
          "package": "compdata",
          "signature": "CVAlg f a f' -\u003e Term f -\u003e a",
          "source": "src/Data-Comp-Algebra.html#histo",
          "type": "function"
        },
        "index": {
          "description": "Construct histomorphism from the given cv-algebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "histo",
          "normalized": "CVAlg a b c-\u003eTerm a-\u003eb",
          "package": "compdata",
          "signature": "CVAlg f a f'-\u003eTerm f-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:histo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic histomorphism from the given monadic cv-algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "histoM",
          "package": "compdata",
          "signature": "CVAlgM m f a f' -\u003e Term f -\u003e m a",
          "source": "src/Data-Comp-Algebra.html#histoM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic histomorphism from the given monadic cv-algebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "histoM",
          "normalized": "CVAlgM a b c d-\u003eTerm b-\u003ea c",
          "package": "compdata",
          "signature": "CVAlgM m f a f'-\u003eTerm f-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:histoM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLifts the given signature function to the canonical term\n homomorphism.\n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "hom",
          "package": "compdata",
          "signature": "SigFun f g -\u003e Hom f g",
          "source": "src/Data-Comp-Algebra.html#hom",
          "type": "function"
        },
        "index": {
          "description": "Lifts the given signature function to the canonical term homomorphism",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "hom",
          "normalized": "SigFun a b-\u003eHom a b",
          "package": "compdata",
          "signature": "SigFun f g-\u003eHom f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:hom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift the give monadic signature function to a monadic term homomorphism. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "hom'",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e HomM m f g",
          "source": "src/Data-Comp-Algebra.html#hom%27",
          "type": "function"
        },
        "index": {
          "description": "Lift the give monadic signature function to monadic term homomorphism",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "hom'",
          "normalized": "SigFunM a b c-\u003eHomM a b c",
          "package": "compdata",
          "signature": "SigFunM m f g-\u003eHomM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:hom-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift the given signature function to a monadic term homomorphism. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "homM",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e HomM m f g",
          "source": "src/Data-Comp-Algebra.html#homM",
          "type": "function"
        },
        "index": {
          "description": "Lift the given signature function to monadic term homomorphism",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "homM",
          "normalized": "SigFunM a b c-\u003eHomM a b c",
          "package": "compdata",
          "signature": "SigFunM m f g-\u003eHomM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:homM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function constructs the unique monadic homomorphism from the\ninitial term algebra to the given term algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "homMD",
          "package": "compdata",
          "signature": "HomMD m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Algebra.html#homMD",
          "type": "function"
        },
        "index": {
          "description": "This function constructs the unique monadic homomorphism from the initial term algebra to the given term algebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "homMD",
          "normalized": "HomMD a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "MD",
          "signature": "HomMD m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:homMD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a paramorphism from the given r-algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "para",
          "package": "compdata",
          "signature": "RAlg f a -\u003e Term f -\u003e a",
          "source": "src/Data-Comp-Algebra.html#para",
          "type": "function"
        },
        "index": {
          "description": "Construct paramorphism from the given r-algebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "para",
          "normalized": "RAlg a b-\u003eTerm a-\u003eb",
          "package": "compdata",
          "signature": "RAlg f a-\u003eTerm f-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:para"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic paramorphism from the given monadic r-algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "paraM",
          "package": "compdata",
          "signature": "RAlgM m f a -\u003e Term f -\u003e m a",
          "source": "src/Data-Comp-Algebra.html#paraM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic paramorphism from the given monadic r-algebra",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "paraM",
          "normalized": "RAlgM a b c-\u003eTerm b-\u003ea c",
          "package": "compdata",
          "signature": "RAlgM m f a-\u003eTerm f-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:paraM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift the given signature function to a monadic signature function. Note that\n  term homomorphisms are instances of signature functions. Hence this function\n  also applies to term homomorphisms. \n\u003c/p\u003e",
          "module": "Data.Comp.Algebra",
          "name": "sigFunM",
          "package": "compdata",
          "signature": "SigFun f g -\u003e SigFunM m f g",
          "source": "src/Data-Comp-Algebra.html#sigFunM",
          "type": "function"
        },
        "index": {
          "description": "Lift the given signature function to monadic signature function Note that term homomorphisms are instances of signature functions Hence this function also applies to term homomorphisms",
          "hierarchy": "Data Comp Algebra",
          "module": "Data.Comp.Algebra",
          "name": "sigFunM",
          "normalized": "SigFun a b-\u003eSigFunM c a b",
          "package": "compdata",
          "partial": "Fun",
          "signature": "SigFun f g-\u003eSigFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Algebra.html#v:sigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines annotations on signatures.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Annotation",
          "name": "Annotation",
          "package": "compdata",
          "source": "src/Data-Comp-Annotation.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines annotations on signatures",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "Annotation",
          "package": "compdata",
          "partial": "Annotation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type adds a constant product (annotation) to a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": ":&:",
          "package": "compdata",
          "source": "src/Data-Comp-Ops.html#%3A%26%3A",
          "type": "data"
        },
        "index": {
          "description": "This data type adds constant product annotation to signature",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": ":&:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#t::-38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal product of signatures (functors).\n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": ":*:",
          "package": "compdata",
          "source": "src/Data-Comp-Ops.html#%3A%2A%3A",
          "type": "data"
        },
        "index": {
          "description": "Formal product of signatures functors",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": ":*:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#t::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class defines how to distribute an annotation over a sum of\nsignatures. \n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "DistAnn",
          "package": "compdata",
          "source": "src/Data-Comp-Ops.html#DistAnn",
          "type": "class"
        },
        "index": {
          "description": "This class defines how to distribute an annotation over sum of signatures",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "DistAnn",
          "package": "compdata",
          "partial": "Dist Ann",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#t:DistAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Annotation",
          "name": "RemA",
          "package": "compdata",
          "source": "src/Data-Comp-Ops.html#RemA",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "RemA",
          "package": "compdata",
          "partial": "Rem",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#t:RemA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.Annotation\",\"Data.Comp.Ops\"]",
          "name": ":&:",
          "package": "compdata",
          "signature": "(f e) :&: a",
          "source": "src/Data-Comp-Ops.html#%3A%26%3A",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v::-38-:\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#v::-38-:\"]"
        },
        "index": {
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": ":&:",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v::-38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.Annotation\",\"Data.Comp.Ops\"]",
          "name": ":*:",
          "package": "compdata",
          "signature": "(f a) :*: (g a)",
          "source": "src/Data-Comp-Ops.html#%3A%2A%3A",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v::-42-:\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#v::-42-:\"]"
        },
        "index": {
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": ":*:",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnnotate each node of a term with a constant value. \n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "ann",
          "package": "compdata",
          "signature": "p -\u003e CxtFun f g",
          "source": "src/Data-Comp-Annotation.html#ann",
          "type": "function"
        },
        "index": {
          "description": "Annotate each node of term with constant value",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "ann",
          "normalized": "a-\u003eCxtFun b c",
          "package": "compdata",
          "signature": "p-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:ann"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject an annotation over a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "injectA",
          "package": "compdata",
          "signature": "p -\u003e s a -\u003e s' a",
          "source": "src/Data-Comp-Ops.html#injectA",
          "type": "method"
        },
        "index": {
          "description": "Inject an annotation over signature",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "injectA",
          "normalized": "a-\u003eb c-\u003ed c",
          "package": "compdata",
          "signature": "p-\u003es a-\u003es' a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:injectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform a function with a domain constructed from a functor to a function\n with a domain constructed with the same functor, but with an additional\n annotation. \n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "liftA",
          "package": "compdata",
          "signature": "(s' a -\u003e t) -\u003e s a -\u003e t",
          "source": "src/Data-Comp-Annotation.html#liftA",
          "type": "function"
        },
        "index": {
          "description": "Transform function with domain constructed from functor to function with domain constructed with the same functor but with an additional annotation",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "liftA",
          "normalized": "(a b-\u003ec)-\u003ed b-\u003ec",
          "package": "compdata",
          "signature": "(s' a-\u003et)-\u003es a-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:liftA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform a function with a domain constructed from a functor to a function\n  with a domain constructed with the same functor, but with an additional\n  annotation. \n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "liftA'",
          "package": "compdata",
          "signature": "(s' a -\u003e Cxt h s' a) -\u003e s a -\u003e Cxt h s a",
          "source": "src/Data-Comp-Annotation.html#liftA%27",
          "type": "function"
        },
        "index": {
          "description": "Transform function with domain constructed from functor to function with domain constructed with the same functor but with an additional annotation",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "liftA'",
          "normalized": "(a b-\u003eCxt c a b)-\u003ed b-\u003eCxt c d b",
          "package": "compdata",
          "partial": "A'",
          "signature": "(s' a-\u003eCxt h s' a)-\u003es a-\u003eCxt h s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:liftA-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function adds unique annotations to a term/context. Each\n node in the term/context is annotated with its path from the root,\n which is represented as an integer list. It is implemented as a\n DTT.\n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "pathAnn",
          "package": "compdata",
          "signature": "CxtFun g (g :&: [Int])",
          "source": "src/Data-Comp-Annotation.html#pathAnn",
          "type": "function"
        },
        "index": {
          "description": "This function adds unique annotations to term context Each node in the term context is annotated with its path from the root which is represented as an integer list It is implemented as DTT",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "pathAnn",
          "normalized": "CxtFun a(a[Int])",
          "package": "compdata",
          "partial": "Ann",
          "signature": "CxtFun g(g[Int])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:pathAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function is similar to \u003ccode\u003e\u003ca\u003eproject\u003c/a\u003e\u003c/code\u003e but applies to signatures\nwith an annotation which is then ignored. \n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "project'",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Maybe (s (Cxt h f a))",
          "source": "src/Data-Comp-Annotation.html#project%27",
          "type": "function"
        },
        "index": {
          "description": "This function is similar to project but applies to signatures with an annotation which is then ignored",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "project'",
          "normalized": "Cxt a b c-\u003eMaybe(d(Cxt a b c))",
          "package": "compdata",
          "signature": "Cxt h f a-\u003eMaybe(s(Cxt h f a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:project-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject an annotation from a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "projectA",
          "package": "compdata",
          "signature": "s' a -\u003e (s a, p)",
          "source": "src/Data-Comp-Ops.html#projectA",
          "type": "method"
        },
        "index": {
          "description": "Project an annotation from signature",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "projectA",
          "normalized": "a b-\u003e(c b,d)",
          "package": "compdata",
          "signature": "s' a-\u003e(s a,p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:projectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a term homomorphism over signatures \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e to a term homomorphism\n over the same signatures, but extended with annotations. \n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "propAnn",
          "package": "compdata",
          "signature": "Hom f g -\u003e Hom f' g'",
          "source": "src/Data-Comp-Annotation.html#propAnn",
          "type": "function"
        },
        "index": {
          "description": "Lift term homomorphism over signatures and to term homomorphism over the same signatures but extended with annotations",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "propAnn",
          "normalized": "Hom a b-\u003eHom c d",
          "package": "compdata",
          "partial": "Ann",
          "signature": "Hom f g-\u003eHom f' g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:propAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a top-down tree transducer over signatures \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e to a\n top-down tree transducer over the same signatures, but extended\n with annotations.\n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "propAnnDown",
          "package": "compdata",
          "signature": "DownTrans f q g -\u003e DownTrans f' q g'",
          "source": "src/Data-Comp-Annotation.html#propAnnDown",
          "type": "function"
        },
        "index": {
          "description": "Lift top-down tree transducer over signatures and to top-down tree transducer over the same signatures but extended with annotations",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "propAnnDown",
          "normalized": "DownTrans a b c-\u003eDownTrans d b e",
          "package": "compdata",
          "partial": "Ann Down",
          "signature": "DownTrans f q g-\u003eDownTrans f' q g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:propAnnDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a monadic term homomorphism over signatures \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e to a monadic\n  term homomorphism over the same signatures, but extended with annotations. \n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "propAnnM",
          "package": "compdata",
          "signature": "HomM m f g -\u003e HomM m f' g'",
          "source": "src/Data-Comp-Annotation.html#propAnnM",
          "type": "function"
        },
        "index": {
          "description": "Lift monadic term homomorphism over signatures and to monadic term homomorphism over the same signatures but extended with annotations",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "propAnnM",
          "normalized": "HomM a b c-\u003eHomM a d e",
          "package": "compdata",
          "partial": "Ann",
          "signature": "HomM m f g-\u003eHomM m f' g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:propAnnM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a macro tree transducer over signatures \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e to a\n macro tree transducer over the same signatures, but extended\n with annotations.\n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "propAnnMacro",
          "package": "compdata",
          "signature": "MacroTrans f q g -\u003e MacroTrans f' q g'",
          "source": "src/Data-Comp-Annotation.html#propAnnMacro",
          "type": "function"
        },
        "index": {
          "description": "Lift macro tree transducer over signatures and to macro tree transducer over the same signatures but extended with annotations",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "propAnnMacro",
          "normalized": "MacroTrans a b c-\u003eMacroTrans d b e",
          "package": "compdata",
          "partial": "Ann Macro",
          "signature": "MacroTrans f q g-\u003eMacroTrans f' q g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:propAnnMacro"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a macro tree transducer with regular look-ahead over\n signatures \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e to a macro tree transducer with regular\n look-ahead over the same signatures, but extended with annotations.\n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "propAnnMacroLA",
          "package": "compdata",
          "signature": "MacroTransLA f q p g -\u003e MacroTransLA f' q p g'",
          "source": "src/Data-Comp-Annotation.html#propAnnMacroLA",
          "type": "function"
        },
        "index": {
          "description": "Lift macro tree transducer with regular look-ahead over signatures and to macro tree transducer with regular look-ahead over the same signatures but extended with annotations",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "propAnnMacroLA",
          "normalized": "MacroTransLA a b c d-\u003eMacroTransLA e b c f",
          "package": "compdata",
          "partial": "Ann Macro LA",
          "signature": "MacroTransLA f q p g-\u003eMacroTransLA f' q p g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:propAnnMacroLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a stateful term homomorphism over signatures \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e to\n a stateful term homomorphism over the same signatures, but extended with\n annotations.\n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "propAnnQ",
          "package": "compdata",
          "signature": "QHom f q g -\u003e QHom f' q g'",
          "source": "src/Data-Comp-Annotation.html#propAnnQ",
          "type": "function"
        },
        "index": {
          "description": "Lift stateful term homomorphism over signatures and to stateful term homomorphism over the same signatures but extended with annotations",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "propAnnQ",
          "normalized": "QHom a b c-\u003eQHom d b e",
          "package": "compdata",
          "partial": "Ann",
          "signature": "QHom f q g-\u003eQHom f' q g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:propAnnQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a bottom-up tree transducer over signatures \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e to a\n bottom-up tree transducer over the same signatures, but extended\n with annotations.\n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "propAnnUp",
          "package": "compdata",
          "signature": "UpTrans f q g -\u003e UpTrans f' q g'",
          "source": "src/Data-Comp-Annotation.html#propAnnUp",
          "type": "function"
        },
        "index": {
          "description": "Lift bottom-up tree transducer over signatures and to bottom-up tree transducer over the same signatures but extended with annotations",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "propAnnUp",
          "normalized": "UpTrans a b c-\u003eUpTrans d b e",
          "package": "compdata",
          "partial": "Ann Up",
          "signature": "UpTrans f q g-\u003eUpTrans f' q g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:propAnnUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove annotations from a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "remA",
          "package": "compdata",
          "signature": "s a -\u003e s' a",
          "source": "src/Data-Comp-Ops.html#remA",
          "type": "method"
        },
        "index": {
          "description": "Remove annotations from signature",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "remA",
          "normalized": "a b-\u003ec b",
          "package": "compdata",
          "signature": "s a-\u003es' a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:remA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrip the annotations from a term over a functor with annotations. \n\u003c/p\u003e",
          "module": "Data.Comp.Annotation",
          "name": "stripA",
          "package": "compdata",
          "signature": "CxtFun g f",
          "source": "src/Data-Comp-Annotation.html#stripA",
          "type": "function"
        },
        "index": {
          "description": "Strip the annotations from term over functor with annotations",
          "hierarchy": "Data Comp Annotation",
          "module": "Data.Comp.Annotation",
          "name": "stripA",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Annotation.html#v:stripA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines generation of arbitrary values for signatures, which\n lifts to generating arbitrary terms.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Arbitrary",
          "name": "Arbitrary",
          "package": "compdata",
          "source": "src/Data-Comp-Arbitrary.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines generation of arbitrary values for signatures which lifts to generating arbitrary terms",
          "hierarchy": "Data Comp Arbitrary",
          "module": "Data.Comp.Arbitrary",
          "name": "Arbitrary",
          "package": "compdata",
          "partial": "Arbitrary",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Arbitrary.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature arbitration. An instance \u003ccode\u003eArbitraryF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eArbitrary (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Arbitrary",
          "name": "ArbitraryF",
          "package": "compdata",
          "source": "src/Data-Comp-Derive-Arbitrary.html#ArbitraryF",
          "type": "class"
        },
        "index": {
          "description": "Signature arbitration An instance ArbitraryF gives rise to an instance Arbitrary Term",
          "hierarchy": "Data Comp Arbitrary",
          "module": "Data.Comp.Arbitrary",
          "name": "ArbitraryF",
          "package": "compdata",
          "partial": "Arbitrary",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Arbitrary.html#t:ArbitraryF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Arbitrary",
          "name": "arbitraryF",
          "package": "compdata",
          "signature": "Gen (f v)",
          "source": "src/Data-Comp-Derive-Arbitrary.html#arbitraryF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Arbitrary",
          "module": "Data.Comp.Arbitrary",
          "name": "arbitraryF",
          "package": "compdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Arbitrary.html#v:arbitraryF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Arbitrary",
          "name": "arbitraryF'",
          "package": "compdata",
          "signature": "[(Int, Gen (f v))]",
          "source": "src/Data-Comp-Derive-Arbitrary.html#arbitraryF%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Arbitrary",
          "module": "Data.Comp.Arbitrary",
          "name": "arbitraryF'",
          "normalized": "[(Int,Gen(a b))]",
          "package": "compdata",
          "partial": "F'",
          "signature": "[(Int,Gen(f v))]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Arbitrary.html#v:arbitraryF-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Arbitrary",
          "name": "shrinkF",
          "package": "compdata",
          "signature": "f v -\u003e [f v]",
          "source": "src/Data-Comp-Derive-Arbitrary.html#shrinkF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Arbitrary",
          "module": "Data.Comp.Arbitrary",
          "name": "shrinkF",
          "normalized": "a b-\u003e[a b]",
          "package": "compdata",
          "signature": "f v-\u003e[f v]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Arbitrary.html#v:shrinkF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Automata.Product",
          "name": "Product",
          "package": "compdata",
          "source": "src/Data-Comp-Automata-Product.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Comp Automata Product",
          "module": "Data.Comp.Automata.Product",
          "name": "Product",
          "package": "compdata",
          "partial": "Product",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata-Product.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn instance \u003ccode\u003ea :\u003c b\u003c/code\u003e means that \u003ccode\u003ea\u003c/code\u003e is a component of \u003ccode\u003eb\u003c/code\u003e. \u003ccode\u003ea\u003c/code\u003e\n can be extracted from \u003ccode\u003eb\u003c/code\u003e via the method \u003ccode\u003e\u003ca\u003epr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata.Product",
          "name": ":\u003c",
          "package": "compdata",
          "source": "src/Data-Comp-Automata-Product-Derive.html#%3A%3C",
          "type": "class"
        },
        "index": {
          "description": "An instance means that is component of can be extracted from via the method pr",
          "hierarchy": "Data Comp Automata Product",
          "module": "Data.Comp.Automata.Product",
          "name": ":\u003c",
          "package": "compdata",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata-Product.html#t::-60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Automata.Product",
          "name": "pr",
          "package": "compdata",
          "signature": "b -\u003e a",
          "source": "src/Data-Comp-Automata-Product-Derive.html#pr",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Automata Product",
          "module": "Data.Comp.Automata.Product",
          "name": "pr",
          "normalized": "a-\u003eb",
          "package": "compdata",
          "signature": "b-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata-Product.html#v:pr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines stateful term homomorphisms. This (slightly\n oxymoronic) notion extends per se stateless term homomorphisms with\n a state that is maintained separately by a bottom-up or top-down\n state transformation. Additionally, this module also provides\n combinators to run state transformations themselves.\n\u003c/p\u003e\u003cp\u003eLike regular term homomorphisms also stateful homomorphisms (as\n well as transducers) can be lifted to annotated signatures\n (cf. \u003ca\u003eData.Comp.Annotation\u003c/a\u003e).\n\u003c/p\u003e\u003cp\u003eThe recursion schemes provided in this module are derived from tree\n automata. They allow for a higher degree of modularity and make it\n possible to apply fusion. The implementation is based on the paper\n \u003cem\u003eModular Tree Automata\u003c/em\u003e (Mathematics of Program Construction,\n 263-299, 2012, \u003ca\u003ehttp://dx.doi.org/10.1007/978-3-642-31113-0_14\u003c/a\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Automata",
          "name": "Automata",
          "package": "compdata",
          "source": "src/Data-Comp-Automata.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines stateful term homomorphisms This slightly oxymoronic notion extends per se stateless term homomorphisms with state that is maintained separately by bottom-up or top-down state transformation Additionally this module also provides combinators to run state transformations themselves Like regular term homomorphisms also stateful homomorphisms as well as transducers can be lifted to annotated signatures cf Data.Comp.Annotation The recursion schemes provided in this module are derived from tree automata They allow for higher degree of modularity and make it possible to apply fusion The implementation is based on the paper Modular Tree Automata Mathematics of Program Construction http dx.doi.org",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "Automata",
          "package": "compdata",
          "partial": "Automata",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents transition functions of generalised\n deterministic top-down tree acceptors (GDTAs) which have access\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "DDownState",
          "package": "compdata",
          "source": "src/Data-Comp-Automata.html#DDownState",
          "type": "type"
        },
        "index": {
          "description": "This type represents transition functions of generalised deterministic top-down tree acceptors GDTAs which have access",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "DDownState",
          "package": "compdata",
          "partial": "DDown State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#t:DDownState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents transition functions of generalised\n deterministic bottom-up tree acceptors (GUTAs) which have access\n to an extended state space.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "DUpState",
          "package": "compdata",
          "source": "src/Data-Comp-Automata.html#DUpState",
          "type": "type"
        },
        "index": {
          "description": "This type represents transition functions of generalised deterministic bottom-up tree acceptors GUTAs which have access to an extended state space",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "DUpState",
          "package": "compdata",
          "partial": "DUp State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#t:DUpState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents transition functions of total, deterministic\n top-down tree acceptors (DTAs).\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "DownState",
          "package": "compdata",
          "source": "src/Data-Comp-Automata.html#DownState",
          "type": "type"
        },
        "index": {
          "description": "This type represents transition functions of total deterministic top-down tree acceptors DTAs",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "DownState",
          "package": "compdata",
          "partial": "Down State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#t:DownState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents transition functions of total deterministic\n top-down tree transducers (DTTs).\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "DownTrans",
          "package": "compdata",
          "source": "src/Data-Comp-Automata.html#DownTrans",
          "type": "type"
        },
        "index": {
          "description": "This type represents transition functions of total deterministic top-down tree transducers DTTs",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "DownTrans",
          "package": "compdata",
          "partial": "Down Trans",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#t:DownTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a variant of the \u003ccode\u003e\u003ca\u003eDownTrans\u003c/a\u003e\u003c/code\u003e type that makes it easier to\n define DTTs as it avoids the explicit use of \u003ccode\u003e\u003ca\u003eHole\u003c/a\u003e\u003c/code\u003e to inject\n placeholders into the result.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "DownTrans'",
          "package": "compdata",
          "source": "src/Data-Comp-Automata.html#DownTrans%27",
          "type": "type"
        },
        "index": {
          "description": "This is variant of the DownTrans type that makes it easier to define DTTs as it avoids the explicit use of Hole to inject placeholders into the result",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "DownTrans'",
          "package": "compdata",
          "partial": "Down Trans'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#t:DownTrans-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents stateful term homomorphisms. Stateful term\n homomorphisms have access to a state that is provided (separately)\n by a bottom-up or top-down state transformation function (or both).\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "QHom",
          "package": "compdata",
          "source": "src/Data-Comp-Automata.html#QHom",
          "type": "type"
        },
        "index": {
          "description": "This type represents stateful term homomorphisms Stateful term homomorphisms have access to state that is provided separately by bottom-up or top-down state transformation function or both",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "QHom",
          "package": "compdata",
          "partial": "QHom",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#t:QHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents transition functions of total, deterministic\n bottom-up tree acceptors (UTAs).\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "UpState",
          "package": "compdata",
          "source": "src/Data-Comp-Automata.html#UpState",
          "type": "type"
        },
        "index": {
          "description": "This type represents transition functions of total deterministic bottom-up tree acceptors UTAs",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "UpState",
          "package": "compdata",
          "partial": "Up State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#t:UpState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents transition functions of total, deterministic\n bottom-up tree transducers (UTTs).\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "UpTrans",
          "package": "compdata",
          "source": "src/Data-Comp-Automata.html#UpTrans",
          "type": "type"
        },
        "index": {
          "description": "This type represents transition functions of total deterministic bottom-up tree transducers UTTs",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "UpTrans",
          "package": "compdata",
          "partial": "Up Trans",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#t:UpTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a variant of the \u003ccode\u003e\u003ca\u003eUpTrans\u003c/a\u003e\u003c/code\u003e type that makes it easier to\n define UTTs as it avoids the explicit use of \u003ccode\u003e\u003ca\u003eHole\u003c/a\u003e\u003c/code\u003e to inject\n placeholders into the result.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "UpTrans'",
          "package": "compdata",
          "source": "src/Data-Comp-Automata.html#UpTrans%27",
          "type": "type"
        },
        "index": {
          "description": "This is variant of the UpTrans type that makes it easier to define UTTs as it avoids the explicit use of Hole to inject placeholders into the result",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "UpTrans'",
          "package": "compdata",
          "partial": "Up Trans'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#t:UpTrans-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis operator constructs a singleton mapping.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "(|-\u003e)",
          "package": "compdata",
          "signature": "k -\u003e a -\u003e Map k a",
          "source": "src/Data-Comp-Automata.html#%7C-%3E",
          "type": "function"
        },
        "index": {
          "description": "This operator constructs singleton mapping",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "(|-\u003e) |-\u003e",
          "normalized": "a-\u003eb-\u003eMap a b",
          "package": "compdata",
          "signature": "k-\u003ea-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:-124--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleft-biased union of two mappings.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "(&)",
          "package": "compdata",
          "signature": "Map k v -\u003e Map k v -\u003e Map k v",
          "source": "src/Data-Comp-Automata.html#%26",
          "type": "function"
        },
        "index": {
          "description": "left-biased union of two mappings",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "(&) &",
          "normalized": "Map a b-\u003eMap a b-\u003eMap a b",
          "package": "compdata",
          "signature": "Map k v-\u003eMap k v-\u003eMap k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:-38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Automata",
          "name": "(\u003c*\u003e)",
          "package": "compdata",
          "signature": "DUpState f c p -\u003e DUpState f c q -\u003e DUpState f c (p, q)",
          "source": "src/Data-Comp-Automata.html#%3C%2A%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "(\u003c*\u003e) \u003c*\u003e",
          "normalized": "DUpState a b c-\u003eDUpState a b d-\u003eDUpState a b(c,d)",
          "package": "compdata",
          "signature": "DUpState f c p-\u003eDUpState f c q-\u003eDUpState f c(p,q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:-60--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a synonym for \u003ccode\u003e\u003ca\u003eprodDDownState\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "(\u003e*\u003c)",
          "package": "compdata",
          "signature": "DDownState f c p -\u003e DDownState f c q -\u003e DDownState f c (p, q)",
          "source": "src/Data-Comp-Automata.html#%3E%2A%3C",
          "type": "function"
        },
        "index": {
          "description": "This is synonym for prodDDownState",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "(\u003e*\u003c) \u003e*\u003c",
          "normalized": "DDownState a b c-\u003eDDownState a b d-\u003eDDownState a b(c,d)",
          "package": "compdata",
          "signature": "DDownState f c p-\u003eDDownState f c q-\u003eDDownState f c(p,q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:-62--42--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function provides access to components of the state from\n \u003ca\u003eabove\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "above",
          "package": "compdata",
          "signature": "p",
          "source": "src/Data-Comp-Automata.html#above",
          "type": "function"
        },
        "index": {
          "description": "This function provides access to components of the state from above",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "above",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:above"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function provides access to components of the states from\n \u003ca\u003ebelow\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "below",
          "package": "compdata",
          "signature": "a -\u003e p",
          "source": "src/Data-Comp-Automata.html#below",
          "type": "function"
        },
        "index": {
          "description": "This function provides access to components of the states from below",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "below",
          "normalized": "a-\u003eb",
          "package": "compdata",
          "signature": "a-\u003ep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:below"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a UTT with an algebra.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "compAlgUpTrans",
          "package": "compdata",
          "signature": "Alg g a -\u003e UpTrans f q g -\u003e Alg f (q, a)",
          "source": "src/Data-Comp-Automata.html#compAlgUpTrans",
          "type": "function"
        },
        "index": {
          "description": "This function composes UTT with an algebra",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "compAlgUpTrans",
          "normalized": "Alg a b-\u003eUpTrans c d a-\u003eAlg c(d,b)",
          "package": "compdata",
          "partial": "Alg Up Trans",
          "signature": "Alg g a-\u003eUpTrans f q g-\u003eAlg f(q,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:compAlgUpTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two DTTs. (see W.C. Rounds /Mappings and\n grammars on trees/, Theorem 2.)\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "compDownTrans",
          "package": "compdata",
          "signature": "DownTrans g p h -\u003e DownTrans f q g -\u003e DownTrans f (q, p) h",
          "source": "src/Data-Comp-Automata.html#compDownTrans",
          "type": "function"
        },
        "index": {
          "description": "This function composes two DTTs see W.C Rounds Mappings and grammars on trees Theorem",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "compDownTrans",
          "normalized": "DownTrans a b c-\u003eDownTrans d e a-\u003eDownTrans d(e,b)c",
          "package": "compdata",
          "partial": "Down Trans",
          "signature": "DownTrans g p h-\u003eDownTrans f q g-\u003eDownTrans f(q,p)h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:compDownTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a DTT after a homomorphism.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "compDownTransHom",
          "package": "compdata",
          "signature": "DownTrans g q h -\u003e Hom f g -\u003e DownTrans f q h",
          "source": "src/Data-Comp-Automata.html#compDownTransHom",
          "type": "function"
        },
        "index": {
          "description": "This function composes DTT after homomorphism",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "compDownTransHom",
          "normalized": "DownTrans a b c-\u003eHom d a-\u003eDownTrans d b c",
          "package": "compdata",
          "partial": "Down Trans Hom",
          "signature": "DownTrans g q h-\u003eHom f g-\u003eDownTrans f q h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:compDownTransHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a DTT after a function.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "compDownTransSig",
          "package": "compdata",
          "signature": "DownTrans g q h -\u003e SigFun f g -\u003e DownTrans f q h",
          "source": "src/Data-Comp-Automata.html#compDownTransSig",
          "type": "function"
        },
        "index": {
          "description": "This function composes DTT after function",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "compDownTransSig",
          "normalized": "DownTrans a b c-\u003eSigFun d a-\u003eDownTrans d b c",
          "package": "compdata",
          "partial": "Down Trans Sig",
          "signature": "DownTrans g q h-\u003eSigFun f g-\u003eDownTrans f q h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:compDownTransSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a homomorphism after a DTT.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "compHomDownTrans",
          "package": "compdata",
          "signature": "Hom g h -\u003e DownTrans f q g -\u003e DownTrans f q h",
          "source": "src/Data-Comp-Automata.html#compHomDownTrans",
          "type": "function"
        },
        "index": {
          "description": "This function composes homomorphism after DTT",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "compHomDownTrans",
          "normalized": "Hom a b-\u003eDownTrans c d a-\u003eDownTrans c d b",
          "package": "compdata",
          "partial": "Hom Down Trans",
          "signature": "Hom g h-\u003eDownTrans f q g-\u003eDownTrans f q h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:compHomDownTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator composes a UTT followed by a homomorphism.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "compHomUpTrans",
          "package": "compdata",
          "signature": "Hom g h -\u003e UpTrans f q g -\u003e UpTrans f q h",
          "source": "src/Data-Comp-Automata.html#compHomUpTrans",
          "type": "function"
        },
        "index": {
          "description": "This combinator composes UTT followed by homomorphism",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "compHomUpTrans",
          "normalized": "Hom a b-\u003eUpTrans c d a-\u003eUpTrans c d b",
          "package": "compdata",
          "partial": "Hom Up Trans",
          "signature": "Hom g h-\u003eUpTrans f q g-\u003eUpTrans f q h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:compHomUpTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a signature function after a DTT.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "compSigDownTrans",
          "package": "compdata",
          "signature": "SigFun g h -\u003e DownTrans f q g -\u003e DownTrans f q h",
          "source": "src/Data-Comp-Automata.html#compSigDownTrans",
          "type": "function"
        },
        "index": {
          "description": "This function composes signature function after DTT",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "compSigDownTrans",
          "normalized": "SigFun a b-\u003eDownTrans c d a-\u003eDownTrans c d b",
          "package": "compdata",
          "partial": "Sig Down Trans",
          "signature": "SigFun g h-\u003eDownTrans f q g-\u003eDownTrans f q h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:compSigDownTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator composes a UTT followed by a signature function.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "compSigUpTrans",
          "package": "compdata",
          "signature": "SigFun g h -\u003e UpTrans f q g -\u003e UpTrans f q h",
          "source": "src/Data-Comp-Automata.html#compSigUpTrans",
          "type": "function"
        },
        "index": {
          "description": "This combinator composes UTT followed by signature function",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "compSigUpTrans",
          "normalized": "SigFun a b-\u003eUpTrans c d a-\u003eUpTrans c d b",
          "package": "compdata",
          "partial": "Sig Up Trans",
          "signature": "SigFun g h-\u003eUpTrans f q g-\u003eUpTrans f q h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:compSigUpTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two UTTs. (see TATA, Theorem 6.4.5)\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "compUpTrans",
          "package": "compdata",
          "signature": "UpTrans g p h -\u003e UpTrans f q g -\u003e UpTrans f (q, p) h",
          "source": "src/Data-Comp-Automata.html#compUpTrans",
          "type": "function"
        },
        "index": {
          "description": "This function composes two UTTs see TATA Theorem",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "compUpTrans",
          "normalized": "UpTrans a b c-\u003eUpTrans d e a-\u003eUpTrans d(e,b)c",
          "package": "compdata",
          "partial": "Up Trans",
          "signature": "UpTrans g p h-\u003eUpTrans f q g-\u003eUpTrans f(q,p)h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:compUpTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator composes a homomorphism followed by a UTT.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "compUpTransHom",
          "package": "compdata",
          "signature": "UpTrans g q h -\u003e Hom f g -\u003e UpTrans f q h",
          "source": "src/Data-Comp-Automata.html#compUpTransHom",
          "type": "function"
        },
        "index": {
          "description": "This combinator composes homomorphism followed by UTT",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "compUpTransHom",
          "normalized": "UpTrans a b c-\u003eHom d a-\u003eUpTrans d b c",
          "package": "compdata",
          "partial": "Up Trans Hom",
          "signature": "UpTrans g q h-\u003eHom f g-\u003eUpTrans f q h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:compUpTransHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator composes a signature function followed by a UTT.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "compUpTransSig",
          "package": "compdata",
          "signature": "UpTrans g q h -\u003e SigFun f g -\u003e UpTrans f q h",
          "source": "src/Data-Comp-Automata.html#compUpTransSig",
          "type": "function"
        },
        "index": {
          "description": "This combinator composes signature function followed by UTT",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "compUpTransSig",
          "normalized": "UpTrans a b c-\u003eSigFun d a-\u003eUpTrans d b c",
          "package": "compdata",
          "partial": "Up Trans Sig",
          "signature": "UpTrans g q h-\u003eSigFun f g-\u003eUpTrans f q h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:compUpTransSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator turns an arbitrary DTA into a GDTA.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "dDownState",
          "package": "compdata",
          "signature": "DownState f q -\u003e DDownState f p q",
          "source": "src/Data-Comp-Automata.html#dDownState",
          "type": "function"
        },
        "index": {
          "description": "This combinator turns an arbitrary DTA into GDTA",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "dDownState",
          "normalized": "DownState a b-\u003eDDownState a c b",
          "package": "compdata",
          "partial": "Down State",
          "signature": "DownState f q-\u003eDDownState f p q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:dDownState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator turns an arbitrary UTA into a GUTA.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "dUpState",
          "package": "compdata",
          "signature": "UpState f q -\u003e DUpState f p q",
          "source": "src/Data-Comp-Automata.html#dUpState",
          "type": "function"
        },
        "index": {
          "description": "This combinator turns an arbitrary UTA into GUTA",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "dUpState",
          "normalized": "UpState a b-\u003eDUpState a c b",
          "package": "compdata",
          "partial": "Up State",
          "signature": "UpState f q-\u003eDUpState f p q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:dUpState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator turns a GDTA with the smallest possible state\n space into a DTA.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "downState",
          "package": "compdata",
          "signature": "DDownState f q q -\u003e DownState f q",
          "source": "src/Data-Comp-Automata.html#downState",
          "type": "function"
        },
        "index": {
          "description": "This combinator turns GDTA with the smallest possible state space into DTA",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "downState",
          "normalized": "DDownState a b b-\u003eDownState a b",
          "package": "compdata",
          "partial": "State",
          "signature": "DDownState f q q-\u003eDownState f q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:downState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function constructs a DTT from a given stateful term--\n homomorphism with the state propagated by the given DTA.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "downTrans",
          "package": "compdata",
          "signature": "DownState f q -\u003e QHom f q g -\u003e DownTrans f q g",
          "source": "src/Data-Comp-Automata.html#downTrans",
          "type": "function"
        },
        "index": {
          "description": "This function constructs DTT from given stateful term homomorphism with the state propagated by the given DTA",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "downTrans",
          "normalized": "DownState a b-\u003eQHom a b c-\u003eDownTrans a b c",
          "package": "compdata",
          "partial": "Trans",
          "signature": "DownState f q-\u003eQHom f q g-\u003eDownTrans f q g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:downTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function turns a DTT defined using the type \u003ccode\u003e\u003ca\u003eDownTrans'\u003c/a\u003e\u003c/code\u003e in\n to the canonical form of type \u003ccode\u003e\u003ca\u003eDownTrans\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "mkDownTrans",
          "package": "compdata",
          "signature": "DownTrans' f q g -\u003e DownTrans f q g",
          "source": "src/Data-Comp-Automata.html#mkDownTrans",
          "type": "function"
        },
        "index": {
          "description": "This function turns DTT defined using the type DownTrans in to the canonical form of type DownTrans",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "mkDownTrans",
          "normalized": "DownTrans' a b c-\u003eDownTrans a b c",
          "package": "compdata",
          "partial": "Down Trans",
          "signature": "DownTrans' f q g-\u003eDownTrans f q g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:mkDownTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function turns a UTT defined using the type \u003ccode\u003e\u003ca\u003eUpTrans'\u003c/a\u003e\u003c/code\u003e in\n to the canonical form of type \u003ccode\u003e\u003ca\u003eUpTrans\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "mkUpTrans",
          "package": "compdata",
          "signature": "UpTrans' f q g -\u003e UpTrans f q g",
          "source": "src/Data-Comp-Automata.html#mkUpTrans",
          "type": "function"
        },
        "index": {
          "description": "This function turns UTT defined using the type UpTrans in to the canonical form of type UpTrans",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "mkUpTrans",
          "normalized": "UpTrans' a b c-\u003eUpTrans a b c",
          "package": "compdata",
          "partial": "Up Trans",
          "signature": "UpTrans' f q g-\u003eUpTrans f q g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:mkUpTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the empty mapping.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "o",
          "package": "compdata",
          "signature": "Map k a",
          "source": "src/Data-Comp-Automata.html#o",
          "type": "function"
        },
        "index": {
          "description": "This is the empty mapping",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "o",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:o"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator constructs the product of two dependant top-down\n state transformations.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "prodDDownState",
          "package": "compdata",
          "signature": "DDownState f c p -\u003e DDownState f c q -\u003e DDownState f c (p, q)",
          "source": "src/Data-Comp-Automata.html#prodDDownState",
          "type": "function"
        },
        "index": {
          "description": "This combinator constructs the product of two dependant top-down state transformations",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "prodDDownState",
          "normalized": "DDownState a b c-\u003eDDownState a b d-\u003eDDownState a b(c,d)",
          "package": "compdata",
          "partial": "DDown State",
          "signature": "DDownState f c p-\u003eDDownState f c q-\u003eDDownState f c(p,q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:prodDDownState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator constructs the product of two GUTA.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "prodDUpState",
          "package": "compdata",
          "signature": "DUpState f c p -\u003e DUpState f c q -\u003e DUpState f c (p, q)",
          "source": "src/Data-Comp-Automata.html#prodDUpState",
          "type": "function"
        },
        "index": {
          "description": "This combinator constructs the product of two GUTA",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "prodDUpState",
          "normalized": "DUpState a b c-\u003eDUpState a b d-\u003eDUpState a b(c,d)",
          "package": "compdata",
          "partial": "DUp State",
          "signature": "DUpState f c p-\u003eDUpState f c q-\u003eDUpState f c(p,q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:prodDUpState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function constructs the product DTA of the given two DTAs.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "prodDownState",
          "package": "compdata",
          "signature": "DownState f p -\u003e DownState f q -\u003e DownState f (p, q)",
          "source": "src/Data-Comp-Automata.html#prodDownState",
          "type": "function"
        },
        "index": {
          "description": "This function constructs the product DTA of the given two DTAs",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "prodDownState",
          "normalized": "DownState a b-\u003eDownState a c-\u003eDownState a(b,c)",
          "package": "compdata",
          "partial": "Down State",
          "signature": "DownState f p-\u003eDownState f q-\u003eDownState f(p,q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:prodDownState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function combines the product UTA of the two given UTAs.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "prodUpState",
          "package": "compdata",
          "signature": "UpState f p -\u003e UpState f q -\u003e UpState f (p, q)",
          "source": "src/Data-Comp-Automata.html#prodUpState",
          "type": "function"
        },
        "index": {
          "description": "This function combines the product UTA of the two given UTAs",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "prodUpState",
          "normalized": "UpState a b-\u003eUpState a c-\u003eUpState a(b,c)",
          "package": "compdata",
          "partial": "Up State",
          "signature": "UpState f p-\u003eUpState f q-\u003eUpState f(p,q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:prodUpState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function turns a stateful homomorphism with a fully\n polymorphic state type into a (stateless) homomorphism.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "pureHom",
          "package": "compdata",
          "signature": "(forall q.  QHom f q g) -\u003e Hom f g",
          "source": "src/Data-Comp-Automata.html#pureHom",
          "type": "function"
        },
        "index": {
          "description": "This function turns stateful homomorphism with fully polymorphic state type into stateless homomorphism",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "pureHom",
          "normalized": "(a b QHom c d e)-\u003eHom c e",
          "package": "compdata",
          "partial": "Hom",
          "signature": "(forall q. QHom f q g)-\u003eHom f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:pureHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator combines a bottom-up and a top-down state\n transformations. Both state transformations can depend mutually\n recursive on each other.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "runDState",
          "package": "compdata",
          "signature": "DUpState f (u, d) u -\u003e DDownState f (u, d) d -\u003e d -\u003e Term f -\u003e u",
          "source": "src/Data-Comp-Automata.html#runDState",
          "type": "function"
        },
        "index": {
          "description": "This combinator combines bottom-up and top-down state transformations Both state transformations can depend mutually recursive on each other",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "runDState",
          "normalized": "DUpState a(b,c)b-\u003eDDownState a(b,c)c-\u003ec-\u003eTerm a-\u003eb",
          "package": "compdata",
          "partial": "DState",
          "signature": "DUpState f(u,d)u-\u003eDDownState f(u,d)d-\u003ed-\u003eTerm f-\u003eu",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:runDState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator runs a GUTA on a term.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "runDUpState",
          "package": "compdata",
          "signature": "DUpState f q q -\u003e Term f -\u003e q",
          "source": "src/Data-Comp-Automata.html#runDUpState",
          "type": "function"
        },
        "index": {
          "description": "This combinator runs GUTA on term",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "runDUpState",
          "normalized": "DUpState a b b-\u003eTerm a-\u003eb",
          "package": "compdata",
          "partial": "DUp State",
          "signature": "DUpState f q q-\u003eTerm f-\u003eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:runDUpState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a given stateful term homomorphism with a\n state space propagated by the given DTA to a term.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "runDownHom",
          "package": "compdata",
          "signature": "DownState f q -\u003e QHom f q g -\u003e q -\u003e Term f -\u003e Term g",
          "source": "src/Data-Comp-Automata.html#runDownHom",
          "type": "function"
        },
        "index": {
          "description": "This function applies given stateful term homomorphism with state space propagated by the given DTA to term",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "runDownHom",
          "normalized": "DownState a b-\u003eQHom a b c-\u003eb-\u003eTerm a-\u003eTerm c",
          "package": "compdata",
          "partial": "Down Hom",
          "signature": "DownState f q-\u003eQHom f q g-\u003eq-\u003eTerm f-\u003eTerm g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:runDownHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThsis function runs the given DTT on the given tree.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "runDownTrans",
          "package": "compdata",
          "signature": "DownTrans f q g -\u003e q -\u003e Cxt h f a -\u003e Cxt h g a",
          "source": "src/Data-Comp-Automata.html#runDownTrans",
          "type": "function"
        },
        "index": {
          "description": "Thsis function runs the given DTT on the given tree",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "runDownTrans",
          "normalized": "DownTrans a b c-\u003eb-\u003eCxt d a e-\u003eCxt d c e",
          "package": "compdata",
          "partial": "Down Trans",
          "signature": "DownTrans f q g-\u003eq-\u003eCxt h f a-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:runDownTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator runs a stateful term homomorphisms with a state\n space produced both on a bottom-up and a top-down state\n transformation.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "runQHom",
          "package": "compdata",
          "signature": "DUpState f (u, d) u -\u003e DDownState f (u, d) d -\u003e QHom f (u, d) g -\u003e d -\u003e Term f -\u003e (u, Term g)",
          "source": "src/Data-Comp-Automata.html#runQHom",
          "type": "function"
        },
        "index": {
          "description": "This combinator runs stateful term homomorphisms with state space produced both on bottom-up and top-down state transformation",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "runQHom",
          "normalized": "DUpState a(b,c)b-\u003eDDownState a(b,c)c-\u003eQHom a(b,c)d-\u003ec-\u003eTerm a-\u003e(b,Term d)",
          "package": "compdata",
          "partial": "QHom",
          "signature": "DUpState f(u,d)u-\u003eDDownState f(u,d)d-\u003eQHom f(u,d)g-\u003ed-\u003eTerm f-\u003e(u,Term g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:runQHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a given stateful term homomorphism with\n a state space propagated by the given UTA to a term.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "runUpHom",
          "package": "compdata",
          "signature": "UpState f q -\u003e QHom f q g -\u003e Term f -\u003e Term g",
          "source": "src/Data-Comp-Automata.html#runUpHom",
          "type": "function"
        },
        "index": {
          "description": "This function applies given stateful term homomorphism with state space propagated by the given UTA to term",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "runUpHom",
          "normalized": "UpState a b-\u003eQHom a b c-\u003eTerm a-\u003eTerm c",
          "package": "compdata",
          "partial": "Up Hom",
          "signature": "UpState f q-\u003eQHom f q g-\u003eTerm f-\u003eTerm g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:runUpHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a variant of \u003ccode\u003e\u003ca\u003erunUpHom\u003c/a\u003e\u003c/code\u003e that also returns the final state\n of the run.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "runUpHomSt",
          "package": "compdata",
          "signature": "UpState f q -\u003e QHom f q g -\u003e Term f -\u003e (q, Term g)",
          "source": "src/Data-Comp-Automata.html#runUpHomSt",
          "type": "function"
        },
        "index": {
          "description": "This is variant of runUpHom that also returns the final state of the run",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "runUpHomSt",
          "normalized": "UpState a b-\u003eQHom a b c-\u003eTerm a-\u003e(b,Term c)",
          "package": "compdata",
          "partial": "Up Hom St",
          "signature": "UpState f q-\u003eQHom f q g-\u003eTerm f-\u003e(q,Term g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:runUpHomSt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator runs the given UTA on a term returning the final\n state of the run.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "runUpState",
          "package": "compdata",
          "signature": "UpState f q -\u003e Term f -\u003e q",
          "source": "src/Data-Comp-Automata.html#runUpState",
          "type": "function"
        },
        "index": {
          "description": "This combinator runs the given UTA on term returning the final state of the run",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "runUpState",
          "normalized": "UpState a b-\u003eTerm a-\u003eb",
          "package": "compdata",
          "partial": "Up State",
          "signature": "UpState f q-\u003eTerm f-\u003eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:runUpState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function runs the given UTT on the given term.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "runUpTrans",
          "package": "compdata",
          "signature": "UpTrans f q g -\u003e Term f -\u003e Term g",
          "source": "src/Data-Comp-Automata.html#runUpTrans",
          "type": "function"
        },
        "index": {
          "description": "This function runs the given UTT on the given term",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "runUpTrans",
          "normalized": "UpTrans a b c-\u003eTerm a-\u003eTerm c",
          "package": "compdata",
          "partial": "Up Trans",
          "signature": "UpTrans f q g-\u003eTerm f-\u003eTerm g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:runUpTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChanges the state space of the DTA using the given isomorphism.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "tagDownState",
          "package": "compdata",
          "signature": "(q -\u003e p) -\u003e (p -\u003e q) -\u003e DownState f q -\u003e DownState f p",
          "source": "src/Data-Comp-Automata.html#tagDownState",
          "type": "function"
        },
        "index": {
          "description": "Changes the state space of the DTA using the given isomorphism",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "tagDownState",
          "normalized": "(a-\u003eb)-\u003e(b-\u003ea)-\u003eDownState c a-\u003eDownState c b",
          "package": "compdata",
          "partial": "Down State",
          "signature": "(q-\u003ep)-\u003e(p-\u003eq)-\u003eDownState f q-\u003eDownState f p",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:tagDownState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChanges the state space of the UTA using the given isomorphism.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "tagUpState",
          "package": "compdata",
          "signature": "(q -\u003e p) -\u003e (p -\u003e q) -\u003e UpState f q -\u003e UpState f p",
          "source": "src/Data-Comp-Automata.html#tagUpState",
          "type": "function"
        },
        "index": {
          "description": "Changes the state space of the UTA using the given isomorphism",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "tagUpState",
          "normalized": "(a-\u003eb)-\u003e(b-\u003ea)-\u003eUpState c a-\u003eUpState c b",
          "package": "compdata",
          "partial": "Up State",
          "signature": "(q-\u003ep)-\u003e(p-\u003eq)-\u003eUpState f q-\u003eUpState f p",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:tagUpState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator turns a GUTA with the smallest possible state\n space into a UTA.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "upState",
          "package": "compdata",
          "signature": "DUpState f q q -\u003e UpState f q",
          "source": "src/Data-Comp-Automata.html#upState",
          "type": "function"
        },
        "index": {
          "description": "This combinator turns GUTA with the smallest possible state space into UTA",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "upState",
          "normalized": "DUpState a b b-\u003eUpState a b",
          "package": "compdata",
          "partial": "State",
          "signature": "DUpState f q q-\u003eUpState f q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:upState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function constructs a UTT from a given stateful term\n homomorphism with the state propagated by the given UTA.\n\u003c/p\u003e",
          "module": "Data.Comp.Automata",
          "name": "upTrans",
          "package": "compdata",
          "signature": "UpState f q -\u003e QHom f q g -\u003e UpTrans f q g",
          "source": "src/Data-Comp-Automata.html#upTrans",
          "type": "function"
        },
        "index": {
          "description": "This function constructs UTT from given stateful term homomorphism with the state propagated by the given UTA",
          "hierarchy": "Data Comp Automata",
          "module": "Data.Comp.Automata",
          "name": "upTrans",
          "normalized": "UpState a b-\u003eQHom a b c-\u003eUpTrans a b c",
          "package": "compdata",
          "partial": "Trans",
          "signature": "UpState f q-\u003eQHom f q g-\u003eUpTrans f q g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Automata.html#v:upTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module implements the decomposition of terms into function\n symbols and arguments resp. variables.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Decompose",
          "name": "Decompose",
          "package": "compdata",
          "source": "src/Data-Comp-Decompose.html",
          "type": "module"
        },
        "index": {
          "description": "This module implements the decomposition of terms into function symbols and arguments resp variables",
          "hierarchy": "Data Comp Decompose",
          "module": "Data.Comp.Decompose",
          "name": "Decompose",
          "package": "compdata",
          "partial": "Decompose",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Decompose.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents decompositions of functorial values. \n\u003c/p\u003e",
          "module": "Data.Comp.Decompose",
          "name": "Decomp",
          "package": "compdata",
          "source": "src/Data-Comp-Decompose.html#Decomp",
          "type": "data"
        },
        "index": {
          "description": "This type represents decompositions of functorial values",
          "hierarchy": "Data Comp Decompose",
          "module": "Data.Comp.Decompose",
          "name": "Decomp",
          "package": "compdata",
          "partial": "Decomp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Decompose.html#t:Decomp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents decompositions of terms.  \n\u003c/p\u003e",
          "module": "Data.Comp.Decompose",
          "name": "DecompTerm",
          "package": "compdata",
          "source": "src/Data-Comp-Decompose.html#DecompTerm",
          "type": "type"
        },
        "index": {
          "description": "This type represents decompositions of terms",
          "hierarchy": "Data Comp Decompose",
          "module": "Data.Comp.Decompose",
          "name": "DecompTerm",
          "package": "compdata",
          "partial": "Decomp Term",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Decompose.html#t:DecompTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class specifies the decomposability of a functorial value. \n\u003c/p\u003e",
          "module": "Data.Comp.Decompose",
          "name": "Decompose",
          "package": "compdata",
          "source": "src/Data-Comp-Decompose.html#Decompose",
          "type": "class"
        },
        "index": {
          "description": "This class specifies the decomposability of functorial value",
          "hierarchy": "Data Comp Decompose",
          "module": "Data.Comp.Decompose",
          "name": "Decompose",
          "package": "compdata",
          "partial": "Decompose",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Decompose.html#t:Decompose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Decompose",
          "name": "Fun",
          "package": "compdata",
          "signature": "Fun (Const f) [a]",
          "source": "src/Data-Comp-Decompose.html#Decomp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Decompose",
          "module": "Data.Comp.Decompose",
          "name": "Fun",
          "normalized": "Fun(Const a)[b]",
          "package": "compdata",
          "partial": "Fun",
          "signature": "Fun(Const f)[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Decompose.html#v:Fun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Decompose",
          "name": "Var",
          "package": "compdata",
          "signature": "Var v",
          "source": "src/Data-Comp-Decompose.html#Decomp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Decompose",
          "module": "Data.Comp.Decompose",
          "name": "Var",
          "package": "compdata",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Decompose.html#v:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function computes the arguments of a functorial value.  \n\u003c/p\u003e",
          "module": "Data.Comp.Decompose",
          "name": "arguments",
          "package": "compdata",
          "signature": "f a -\u003e [a]",
          "source": "src/Data-Comp-Decompose.html#arguments",
          "type": "function"
        },
        "index": {
          "description": "This function computes the arguments of functorial value",
          "hierarchy": "Data Comp Decompose",
          "module": "Data.Comp.Decompose",
          "name": "arguments",
          "normalized": "a b-\u003e[b]",
          "package": "compdata",
          "signature": "f a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Decompose.html#v:arguments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function decomposes a functorial value. \n\u003c/p\u003e",
          "module": "Data.Comp.Decompose",
          "name": "decomp",
          "package": "compdata",
          "signature": "f a -\u003e Decomp f v a",
          "source": "src/Data-Comp-Decompose.html#decomp",
          "type": "method"
        },
        "index": {
          "description": "This function decomposes functorial value",
          "hierarchy": "Data Comp Decompose",
          "module": "Data.Comp.Decompose",
          "name": "decomp",
          "normalized": "a b-\u003eDecomp a c b",
          "package": "compdata",
          "signature": "f a-\u003eDecomp f v a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Decompose.html#v:decomp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function decomposes a term. \n\u003c/p\u003e",
          "module": "Data.Comp.Decompose",
          "name": "decompose",
          "package": "compdata",
          "signature": "Term f -\u003e DecompTerm f v",
          "source": "src/Data-Comp-Decompose.html#decompose",
          "type": "function"
        },
        "index": {
          "description": "This function decomposes term",
          "hierarchy": "Data Comp Decompose",
          "module": "Data.Comp.Decompose",
          "name": "decompose",
          "normalized": "Term a-\u003eDecompTerm a b",
          "package": "compdata",
          "signature": "Term f-\u003eDecompTerm f v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Decompose.html#v:decompose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function computes the structure of a functorial value. \n\u003c/p\u003e",
          "module": "Data.Comp.Decompose",
          "name": "structure",
          "package": "compdata",
          "signature": "f a -\u003e Const f",
          "source": "src/Data-Comp-Decompose.html#structure",
          "type": "function"
        },
        "index": {
          "description": "This function computes the structure of functorial value",
          "hierarchy": "Data Comp Decompose",
          "module": "Data.Comp.Decompose",
          "name": "structure",
          "normalized": "a b-\u003eConst a",
          "package": "compdata",
          "signature": "f a-\u003eConst f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Decompose.html#v:structure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines full evaluation of signatures, which lifts to full\n evaluation of terms and contexts.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.DeepSeq",
          "name": "DeepSeq",
          "package": "compdata",
          "source": "src/Data-Comp-DeepSeq.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines full evaluation of signatures which lifts to full evaluation of terms and contexts",
          "hierarchy": "Data Comp DeepSeq",
          "module": "Data.Comp.DeepSeq",
          "name": "DeepSeq",
          "package": "compdata",
          "partial": "Deep Seq",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-DeepSeq.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature normal form. An instance \u003ccode\u003eNFDataF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eNFData (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.DeepSeq",
          "name": "NFDataF",
          "package": "compdata",
          "source": "src/Data-Comp-Derive-DeepSeq.html#NFDataF",
          "type": "class"
        },
        "index": {
          "description": "Signature normal form An instance NFDataF gives rise to an instance NFData Term",
          "hierarchy": "Data Comp DeepSeq",
          "module": "Data.Comp.DeepSeq",
          "name": "NFDataF",
          "package": "compdata",
          "partial": "NFData",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-DeepSeq.html#t:NFDataF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.DeepSeq",
          "name": "rnfF",
          "package": "compdata",
          "signature": "f a -\u003e ()",
          "source": "src/Data-Comp-Derive-DeepSeq.html#rnfF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp DeepSeq",
          "module": "Data.Comp.DeepSeq",
          "name": "rnfF",
          "normalized": "a b-\u003e()",
          "package": "compdata",
          "signature": "f a-\u003e()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-DeepSeq.html#v:rnfF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains functionality for automatically deriving boilerplate\n code using Template Haskell. Examples include instances of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Derive",
          "name": "Derive",
          "package": "compdata",
          "source": "src/Data-Comp-Derive.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains functionality for automatically deriving boilerplate code using Template Haskell Examples include instances of Functor Foldable and Traversable",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "Derive",
          "package": "compdata",
          "partial": "Derive",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRandom generation and shrinking of values.\n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "Arbitrary",
          "package": "compdata",
          "type": "class"
        },
        "index": {
          "description": "Random generation and shrinking of values",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "Arbitrary",
          "package": "compdata",
          "partial": "Arbitrary",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#t:Arbitrary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature arbitration. An instance \u003ccode\u003eArbitraryF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eArbitrary (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "ArbitraryF",
          "package": "compdata",
          "source": "src/Data-Comp-Derive-Arbitrary.html#ArbitraryF",
          "type": "class"
        },
        "index": {
          "description": "Signature arbitration An instance ArbitraryF gives rise to an instance Arbitrary Term",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "ArbitraryF",
          "package": "compdata",
          "partial": "Arbitrary",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#t:ArbitraryF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature equality. An instance \u003ccode\u003eEqF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eEq (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "EqF",
          "package": "compdata",
          "source": "src/Data-Comp-Derive-Equality.html#EqF",
          "type": "class"
        },
        "index": {
          "description": "Signature equality An instance EqF gives rise to an instance Eq Term",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "EqF",
          "package": "compdata",
          "partial": "Eq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#t:EqF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData structures that can be folded.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003efoldMap\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example, given a data type\n\u003c/p\u003e\u003cpre\u003e data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)\n\u003c/pre\u003e\u003cp\u003ea suitable instance would be\n\u003c/p\u003e\u003cpre\u003e instance Foldable Tree where\n    foldMap f Empty = mempty\n    foldMap f (Leaf x) = f x\n    foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r\n\u003c/pre\u003e\u003cp\u003eThis is suitable even for abstract types, as the monoid is assumed\n to satisfy the monoid laws.  Alternatively, one could define \u003ccode\u003efoldr\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e instance Foldable Tree where\n    foldr f z Empty = z\n    foldr f z (Leaf x) = f x z\n    foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l\n\u003c/pre\u003e",
          "module": "Data.Comp.Derive",
          "name": "Foldable",
          "package": "compdata",
          "type": "class"
        },
        "index": {
          "description": "Data structures that can be folded Minimal complete definition foldMap or foldr For example given data type data Tree Empty Leaf Node Tree Tree suitable instance would be instance Foldable Tree where foldMap Empty mempty foldMap Leaf foldMap Node foldMap mappend mappend foldMap This is suitable even for abstract types as the monoid is assumed to satisfy the monoid laws Alternatively one could define foldr instance Foldable Tree where foldr Empty foldr Leaf foldr Node foldr foldr",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "Foldable",
          "package": "compdata",
          "partial": "Foldable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#t:Foldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e class is used for types that can be mapped over.\nInstances of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e should satisfy the following laws:\n\u003c/p\u003e\u003cpre\u003e fmap id  ==  id\n fmap (f . g)  ==  fmap f . fmap g\n\u003c/pre\u003e\u003cp\u003eThe instances of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e for lists, \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\nsatisfy these laws.\n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "Functor",
          "package": "compdata",
          "type": "class"
        },
        "index": {
          "description": "The Functor class is used for types that can be mapped over Instances of Functor should satisfy the following laws fmap id id fmap fmap fmap The instances of Functor for lists Maybe and IO satisfy these laws",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "Functor",
          "package": "compdata",
          "partial": "Functor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#t:Functor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class of types that can be fully evaluated.\n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "NFData",
          "package": "compdata",
          "type": "class"
        },
        "index": {
          "description": "class of types that can be fully evaluated",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "NFData",
          "package": "compdata",
          "partial": "NFData",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#t:NFData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature normal form. An instance \u003ccode\u003eNFDataF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eNFData (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "NFDataF",
          "package": "compdata",
          "source": "src/Data-Comp-Derive-DeepSeq.html#NFDataF",
          "type": "class"
        },
        "index": {
          "description": "Signature normal form An instance NFDataF gives rise to an instance NFData Term",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "NFDataF",
          "package": "compdata",
          "partial": "NFData",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#t:NFDataF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature ordering. An instance \u003ccode\u003eOrdF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eOrd (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "OrdF",
          "package": "compdata",
          "source": "src/Data-Comp-Derive-Ordering.html#OrdF",
          "type": "class"
        },
        "index": {
          "description": "Signature ordering An instance OrdF gives rise to an instance Ord Term",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "OrdF",
          "package": "compdata",
          "partial": "Ord",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#t:OrdF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature printing. An instance \u003ccode\u003eShowF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eShow (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "ShowF",
          "package": "compdata",
          "source": "src/Data-Comp-Derive-Show.html#ShowF",
          "type": "class"
        },
        "index": {
          "description": "Signature printing An instance ShowF gives rise to an instance Show Term",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "ShowF",
          "package": "compdata",
          "partial": "Show",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#t:ShowF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunctors representing data structures that can be traversed from\n left to right.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003esequenceA\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eInstances are similar to \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, e.g. given a data type\n\u003c/p\u003e\u003cpre\u003e data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)\n\u003c/pre\u003e\u003cp\u003ea suitable instance would be\n\u003c/p\u003e\u003cpre\u003e instance Traversable Tree where\n    traverse f Empty = pure Empty\n    traverse f (Leaf x) = Leaf \u003c$\u003e f x\n    traverse f (Node l k r) = Node \u003c$\u003e traverse f l \u003c*\u003e f k \u003c*\u003e traverse f r\n\u003c/pre\u003e\u003cp\u003eThis is suitable even for abstract types, as the laws for \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e\n imply a form of associativity.\n\u003c/p\u003e\u003cp\u003eThe superclass instances should satisfy the following:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e In the \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e instance, \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e should be equivalent to traversal\n    with the identity applicative functor (\u003ccode\u003e\u003ca\u003efmapDefault\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003cli\u003e In the \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e instance, \u003ccode\u003e\u003ca\u003efoldMap\u003c/a\u003e\u003c/code\u003e should be\n    equivalent to traversal with a constant applicative functor\n    (\u003ccode\u003e\u003ca\u003efoldMapDefault\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Data.Comp.Derive",
          "name": "Traversable",
          "package": "compdata",
          "type": "class"
        },
        "index": {
          "description": "Functors representing data structures that can be traversed from left to right Minimal complete definition traverse or sequenceA Instances are similar to Functor e.g given data type data Tree Empty Leaf Node Tree Tree suitable instance would be instance Traversable Tree where traverse Empty pure Empty traverse Leaf Leaf traverse Node Node traverse traverse This is suitable even for abstract types as the laws for imply form of associativity The superclass instances should satisfy the following In the Functor instance fmap should be equivalent to traversal with the identity applicative functor fmapDefault In the Foldable instance foldMap should be equivalent to traversal with constant applicative functor foldMapDefault",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "Traversable",
          "package": "compdata",
          "partial": "Traversable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#t:Traversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generator for values of the given type.\n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "arbitrary",
          "package": "compdata",
          "signature": "Gen a",
          "type": "method"
        },
        "index": {
          "description": "generator for values of the given type",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "arbitrary",
          "package": "compdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:arbitrary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Derive",
          "name": "arbitraryF",
          "package": "compdata",
          "signature": "Gen (f v)",
          "source": "src/Data-Comp-Derive-Arbitrary.html#arbitraryF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "arbitraryF",
          "package": "compdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:arbitraryF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Derive",
          "name": "arbitraryF'",
          "package": "compdata",
          "signature": "[(Int, Gen (f v))]",
          "source": "src/Data-Comp-Derive-Arbitrary.html#arbitraryF%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "arbitraryF'",
          "normalized": "[(Int,Gen(a b))]",
          "package": "compdata",
          "partial": "F'",
          "signature": "[(Int,Gen(f v))]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:arbitraryF-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Derive",
          "name": "compareF",
          "package": "compdata",
          "signature": "f a -\u003e f a -\u003e Ordering",
          "source": "src/Data-Comp-Derive-Ordering.html#compareF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "compareF",
          "normalized": "a b-\u003ea b-\u003eOrdering",
          "package": "compdata",
          "signature": "f a-\u003ef a-\u003eOrdering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:compareF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper function for generating a list of instances for a list of named\n signatures. For example, in order to derive instances \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003eShowF\u003c/code\u003e for a signature \u003ccode\u003eExp\u003c/code\u003e, use derive as follows (requires Template\n Haskell):\n\u003c/p\u003e\u003cpre\u003e $(derive [makeFunctor, makeShowF] [''Exp])\n\u003c/pre\u003e",
          "module": "[\"Data.Comp.Derive\",\"Data.Comp.Multi.Derive\",\"Data.Comp.MultiParam.Derive\",\"Data.Comp.Param.Derive\"]",
          "name": "derive",
          "package": "compdata",
          "signature": "[Name -\u003e Q [Dec]] -\u003e [Name] -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive-Utils.html#derive",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:derive\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:derive\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#v:derive\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#v:derive\"]"
        },
        "index": {
          "description": "Helper function for generating list of instances for list of named signatures For example in order to derive instances Functor and ShowF for signature Exp use derive as follows requires Template Haskell derive makeFunctor makeShowF Exp",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "derive",
          "normalized": "[Name-\u003eQ[Dec]]-\u003e[Name]-\u003eQ[Dec]",
          "package": "compdata",
          "signature": "[Name-\u003eQ[Dec]]-\u003e[Name]-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:derive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Derive",
          "name": "eqF",
          "package": "compdata",
          "signature": "f a -\u003e f a -\u003e Bool",
          "source": "src/Data-Comp-Derive-Equality.html#eqF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "eqF",
          "normalized": "a b-\u003ea b-\u003eBool",
          "package": "compdata",
          "signature": "f a-\u003ef a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:eqF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Derive",
          "name": "haskellStrict",
          "package": "compdata",
          "signature": "f (TermT m g) -\u003e TermT m g",
          "source": "src/Data-Comp-Derive-HaskellStrict.html#haskellStrict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "haskellStrict",
          "normalized": "a(TermT b c)-\u003eTermT b c",
          "package": "compdata",
          "partial": "Strict",
          "signature": "f(TermT m g)-\u003eTermT m g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:haskellStrict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Derive",
          "name": "haskellStrict'",
          "package": "compdata",
          "signature": "f (TermT m g) -\u003e TermT m g",
          "source": "src/Data-Comp-Derive-HaskellStrict.html#haskellStrict%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "haskellStrict'",
          "normalized": "a(TermT b c)-\u003eTermT b c",
          "package": "compdata",
          "partial": "Strict'",
          "signature": "f(TermT m g)-\u003eTermT m g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:haskellStrict-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven the name of a type class, where the first parameter is a functor,\n  lift it to sums of functors. Example: \u003ccode\u003eclass ShowF f where ...\u003c/code\u003e is lifted\n  as \u003ccode\u003einstance (ShowF f, ShowF g) =\u003e ShowF (f :+: g) where ... \u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "liftSum",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive.html#liftSum",
          "type": "function"
        },
        "index": {
          "description": "Given the name of type class where the first parameter is functor lift it to sums of functors Example class ShowF where is lifted as instance ShowF ShowF ShowF where",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "liftSum",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Sum",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:liftSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eArbitrary\u003c/a\u003e\u003c/code\u003e for a type constructor. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "makeArbitrary",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive-Arbitrary.html#makeArbitrary",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of Arbitrary for type constructor",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "makeArbitrary",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Arbitrary",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:makeArbitrary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eArbitraryF\u003c/a\u003e\u003c/code\u003e for a type constructor of any\n  first-order kind taking at least one argument. It is necessary that\n  all types that are used by the data type definition are themselves\n  instances of \u003ccode\u003e\u003ca\u003eArbitrary\u003c/a\u003e\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "makeArbitraryF",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive-Arbitrary.html#makeArbitraryF",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of ArbitraryF for type constructor of any first-order kind taking at least one argument It is necessary that all types that are used by the data type definition are themselves instances of Arbitrary",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "makeArbitraryF",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Arbitrary",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:makeArbitraryF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eEqF\u003c/a\u003e\u003c/code\u003e for a type constructor of any first-order kind\n  taking at least one argument. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "makeEqF",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive-Equality.html#makeEqF",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of EqF for type constructor of any first-order kind taking at least one argument",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "makeEqF",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Eq",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:makeEqF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e for a type constructor of any first-order\n  kind taking at least one argument. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "makeFoldable",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive-Foldable.html#makeFoldable",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of Foldable for type constructor of any first-order kind taking at least one argument",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "makeFoldable",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Foldable",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:makeFoldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e for a type constructor of any first-order\n  kind taking at least one argument. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "makeFunctor",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive.html#makeFunctor",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of Functor for type constructor of any first-order kind taking at least one argument",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "makeFunctor",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Functor",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:makeFunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003eHaskellStrict\u003c/code\u003e for a type constructor of any\n  first-order kind taking at least one argument. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "makeHaskellStrict",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive-HaskellStrict.html#makeHaskellStrict",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of HaskellStrict for type constructor of any first-order kind taking at least one argument",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "makeHaskellStrict",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Haskell Strict",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:makeHaskellStrict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eNFData\u003c/a\u003e\u003c/code\u003e for a type constructor. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "makeNFData",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive.html#makeNFData",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of NFData for type constructor",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "makeNFData",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "NFData",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:makeNFData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eNFDataF\u003c/a\u003e\u003c/code\u003e for a type constructor of any first-order\n  kind taking at least one argument. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "makeNFDataF",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive-DeepSeq.html#makeNFDataF",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of NFDataF for type constructor of any first-order kind taking at least one argument",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "makeNFDataF",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "NFData",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:makeNFDataF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eOrdF\u003c/a\u003e\u003c/code\u003e for a type constructor of any first-order kind\n  taking at least one argument. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "makeOrdF",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive-Ordering.html#makeOrdF",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of OrdF for type constructor of any first-order kind taking at least one argument",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "makeOrdF",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Ord",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:makeOrdF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eShowF\u003c/a\u003e\u003c/code\u003e for a type constructor of any first-order kind\n  taking at least one argument. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "makeShowF",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive-Show.html#makeShowF",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of ShowF for type constructor of any first-order kind taking at least one argument",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "makeShowF",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Show",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:makeShowF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e for a type constructor of any\n  first-order kind taking at least one argument. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "makeTraversable",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive-Traversable.html#makeTraversable",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of Traversable for type constructor of any first-order kind taking at least one argument",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "makeTraversable",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Traversable",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:makeTraversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ernf should reduce its argument to normal form (that is, fully\n evaluate all sub-components), and then return '()'.\n\u003c/p\u003e\u003cp\u003eThe default implementation of \u003ccode\u003e\u003ca\u003ernf\u003c/a\u003e\u003c/code\u003e is \n\u003c/p\u003e\u003cpre\u003e rnf a = a `seq` ()\n\u003c/pre\u003e\u003cp\u003ewhich may be convenient when defining instances for data types with\n no unevaluated fields (e.g. enumerations).\n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "rnf",
          "package": "compdata",
          "signature": "a -\u003e ()",
          "type": "method"
        },
        "index": {
          "description": "rnf should reduce its argument to normal form that is fully evaluate all sub-components and then return The default implementation of rnf is rnf seq which may be convenient when defining instances for data types with no unevaluated fields e.g enumerations",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "rnf",
          "normalized": "a-\u003e()",
          "package": "compdata",
          "signature": "a-\u003e()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:rnf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Derive",
          "name": "rnfF",
          "package": "compdata",
          "signature": "f a -\u003e ()",
          "source": "src/Data-Comp-Derive-DeepSeq.html#rnfF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "rnfF",
          "normalized": "a b-\u003e()",
          "package": "compdata",
          "signature": "f a-\u003e()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:rnfF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Derive",
          "name": "showF",
          "package": "compdata",
          "signature": "f String -\u003e String",
          "source": "src/Data-Comp-Derive-Show.html#showF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "showF",
          "normalized": "a String-\u003eString",
          "package": "compdata",
          "signature": "f String-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:showF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProduces a (possibly) empty list of all the possible\n immediate shrinks of the given value.\n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "shrink",
          "package": "compdata",
          "signature": "a -\u003e [a]",
          "type": "method"
        },
        "index": {
          "description": "Produces possibly empty list of all the possible immediate shrinks of the given value",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "shrink",
          "normalized": "a-\u003e[a]",
          "package": "compdata",
          "signature": "a-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:shrink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Derive",
          "name": "shrinkF",
          "package": "compdata",
          "signature": "f v -\u003e [f v]",
          "source": "src/Data-Comp-Derive-Arbitrary.html#shrinkF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "shrinkF",
          "normalized": "a b-\u003e[a b]",
          "package": "compdata",
          "signature": "f v-\u003e[f v]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:shrinkF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive smart constructors with products for a type constructor of any\n  parametric kind taking at least one argument. The smart constructors are\n  similar to the ordinary constructors, but an \u003ccode\u003e\u003ca\u003einjectA\u003c/a\u003e\u003c/code\u003e is automatically\n  inserted. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "smartAConstructors",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive-SmartAConstructors.html#smartAConstructors",
          "type": "function"
        },
        "index": {
          "description": "Derive smart constructors with products for type constructor of any parametric kind taking at least one argument The smart constructors are similar to the ordinary constructors but an injectA is automatically inserted",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "smartAConstructors",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "AConstructors",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:smartAConstructors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive smart constructors for a type constructor of any first-order kind\n taking at least one argument. The smart constructors are similar to the\n ordinary constructors, but an \u003ccode\u003e\u003ca\u003einject\u003c/a\u003e\u003c/code\u003e is automatically inserted. \n\u003c/p\u003e",
          "module": "Data.Comp.Derive",
          "name": "smartConstructors",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Derive-SmartConstructors.html#smartConstructors",
          "type": "function"
        },
        "index": {
          "description": "Derive smart constructors for type constructor of any first-order kind taking at least one argument The smart constructors are similar to the ordinary constructors but an inject is automatically inserted",
          "hierarchy": "Data Comp Derive",
          "module": "Data.Comp.Derive",
          "name": "smartConstructors",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Constructors",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Derive.html#v:smartConstructors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis modules defines the \u003ccode\u003e\u003ca\u003eDesugar\u003c/a\u003e\u003c/code\u003e type class for desugaring of terms.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "source": "src/Data-Comp-Desugar.html",
          "type": "module"
        },
        "index": {
          "description": "This modules defines the Desugar type class for desugaring of terms",
          "hierarchy": "Data Comp Desugar",
          "module": "Data.Comp.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "partial": "Desugar",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Desugar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe desugaring term homomorphism.\n\u003c/p\u003e",
          "module": "Data.Comp.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "source": "src/Data-Comp-Desugar.html#Desugar",
          "type": "class"
        },
        "index": {
          "description": "The desugaring term homomorphism",
          "hierarchy": "Data Comp Desugar",
          "module": "Data.Comp.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "partial": "Desugar",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Desugar.html#t:Desugar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Desugar",
          "name": "desugHom",
          "package": "compdata",
          "signature": "Hom f g",
          "source": "src/Data-Comp-Desugar.html#desugHom",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Desugar",
          "module": "Data.Comp.Desugar",
          "name": "desugHom",
          "package": "compdata",
          "partial": "Hom",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Desugar.html#v:desugHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Desugar",
          "name": "desugHom'",
          "package": "compdata",
          "signature": "Alg f (Context g a)",
          "source": "src/Data-Comp-Desugar.html#desugHom%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Desugar",
          "module": "Data.Comp.Desugar",
          "name": "desugHom'",
          "package": "compdata",
          "partial": "Hom'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Desugar.html#v:desugHom-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDesugar a term.\n\u003c/p\u003e",
          "module": "Data.Comp.Desugar",
          "name": "desugar",
          "package": "compdata",
          "signature": "Term f -\u003e Term g",
          "source": "src/Data-Comp-Desugar.html#desugar",
          "type": "function"
        },
        "index": {
          "description": "Desugar term",
          "hierarchy": "Data Comp Desugar",
          "module": "Data.Comp.Desugar",
          "name": "desugar",
          "normalized": "Term a-\u003eTerm b",
          "package": "compdata",
          "signature": "Term f-\u003eTerm g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Desugar.html#v:desugar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift desugaring to annotated terms.\n\u003c/p\u003e",
          "module": "Data.Comp.Desugar",
          "name": "desugarA",
          "package": "compdata",
          "signature": "Term f' -\u003e Term g'",
          "source": "src/Data-Comp-Desugar.html#desugarA",
          "type": "function"
        },
        "index": {
          "description": "Lift desugaring to annotated terms",
          "hierarchy": "Data Comp Desugar",
          "module": "Data.Comp.Desugar",
          "name": "desugarA",
          "normalized": "Term a-\u003eTerm b",
          "package": "compdata",
          "signature": "Term f'-\u003eTerm g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Desugar.html#v:desugarA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines equality for signatures, which lifts to equality for\n terms and contexts.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Equality",
          "name": "Equality",
          "package": "compdata",
          "source": "src/Data-Comp-Equality.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines equality for signatures which lifts to equality for terms and contexts",
          "hierarchy": "Data Comp Equality",
          "module": "Data.Comp.Equality",
          "name": "Equality",
          "package": "compdata",
          "partial": "Equality",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Equality.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature equality. An instance \u003ccode\u003eEqF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eEq (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Equality",
          "name": "EqF",
          "package": "compdata",
          "source": "src/Data-Comp-Derive-Equality.html#EqF",
          "type": "class"
        },
        "index": {
          "description": "Signature equality An instance EqF gives rise to an instance Eq Term",
          "hierarchy": "Data Comp Equality",
          "module": "Data.Comp.Equality",
          "name": "EqF",
          "package": "compdata",
          "partial": "Eq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Equality.html#t:EqF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Equality",
          "name": "eqF",
          "package": "compdata",
          "signature": "f a -\u003e f a -\u003e Bool",
          "source": "src/Data-Comp-Derive-Equality.html#eqF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Equality",
          "module": "Data.Comp.Equality",
          "name": "eqF",
          "normalized": "a b-\u003ea b-\u003eBool",
          "package": "compdata",
          "signature": "f a-\u003ef a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Equality.html#v:eqF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function implements equality of values of type \u003ccode\u003ef a\u003c/code\u003e modulo\nthe equality of \u003ccode\u003ea\u003c/code\u003e itself. If two functorial values are equal in this\nsense, \u003ccode\u003e\u003ca\u003eeqMod\u003c/a\u003e\u003c/code\u003e returns a \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e value containing a list of pairs\nconsisting of corresponding components of the two functorial\nvalues. \n\u003c/p\u003e",
          "module": "Data.Comp.Equality",
          "name": "eqMod",
          "package": "compdata",
          "signature": "f a -\u003e f b -\u003e Maybe [(a, b)]",
          "source": "src/Data-Comp-Equality.html#eqMod",
          "type": "function"
        },
        "index": {
          "description": "This function implements equality of values of type modulo the equality of itself If two functorial values are equal in this sense eqMod returns Just value containing list of pairs consisting of corresponding components of the two functorial values",
          "hierarchy": "Data Comp Equality",
          "module": "Data.Comp.Equality",
          "name": "eqMod",
          "normalized": "a b-\u003ea c-\u003eMaybe[(b,c)]",
          "package": "compdata",
          "partial": "Mod",
          "signature": "f a-\u003ef b-\u003eMaybe[(a,b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Equality.html#v:eqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines type generic functions and recursive schemes\n along the lines of the Uniplate library.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Generic",
          "name": "Generic",
          "package": "compdata",
          "source": "src/Data-Comp-Generic.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines type generic functions and recursive schemes along the lines of the Uniplate library",
          "hierarchy": "Data Comp Generic",
          "module": "Data.Comp.Generic",
          "name": "Generic",
          "package": "compdata",
          "partial": "Generic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Generic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function returns the subterm of a given term at the position\n specified by the given path or \u003ccode\u003eNothing\u003c/code\u003e if the input term has no\n such subterm\n\u003c/p\u003e",
          "module": "Data.Comp.Generic",
          "name": "getSubterm",
          "package": "compdata",
          "signature": "[Int] -\u003e Term g -\u003e Maybe (Term g)",
          "source": "src/Data-Comp-Generic.html#getSubterm",
          "type": "function"
        },
        "index": {
          "description": "This function returns the subterm of given term at the position specified by the given path or Nothing if the input term has no such subterm",
          "hierarchy": "Data Comp Generic",
          "module": "Data.Comp.Generic",
          "name": "getSubterm",
          "normalized": "[Int]-\u003eTerm a-\u003eMaybe(Term a)",
          "package": "compdata",
          "partial": "Subterm",
          "signature": "[Int]-\u003eTerm g-\u003eMaybe(Term g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Generic.html#v:getSubterm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function returns the subterm of a given term at the position\n specified by the given path. This function is a variant of\n \u003ccode\u003e\u003ca\u003egetSubterm\u003c/a\u003e\u003c/code\u003e which fails if there is no subterm at the given\n position.\n\u003c/p\u003e",
          "module": "Data.Comp.Generic",
          "name": "getSubterm'",
          "package": "compdata",
          "signature": "[Int] -\u003e Term g -\u003e Term g",
          "source": "src/Data-Comp-Generic.html#getSubterm%27",
          "type": "function"
        },
        "index": {
          "description": "This function returns the subterm of given term at the position specified by the given path This function is variant of getSubterm which fails if there is no subterm at the given position",
          "hierarchy": "Data Comp Generic",
          "module": "Data.Comp.Generic",
          "name": "getSubterm'",
          "normalized": "[Int]-\u003eTerm a-\u003eTerm a",
          "package": "compdata",
          "partial": "Subterm'",
          "signature": "[Int]-\u003eTerm g-\u003eTerm g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Generic.html#v:getSubterm-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Generic",
          "name": "gsize",
          "package": "compdata",
          "signature": "Term f -\u003e Int",
          "source": "src/Data-Comp-Generic.html#gsize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Generic",
          "module": "Data.Comp.Generic",
          "name": "gsize",
          "normalized": "Term a-\u003eInt",
          "package": "compdata",
          "signature": "Term f-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Generic.html#v:gsize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function computes the generic height of the given term.\n\u003c/p\u003e",
          "module": "Data.Comp.Generic",
          "name": "height",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Int",
          "source": "src/Data-Comp-Generic.html#height",
          "type": "function"
        },
        "index": {
          "description": "This function computes the generic height of the given term",
          "hierarchy": "Data Comp Generic",
          "module": "Data.Comp.Generic",
          "name": "height",
          "normalized": "Cxt a b c-\u003eInt",
          "package": "compdata",
          "signature": "Cxt h f a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Generic.html#v:height"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Generic",
          "name": "query",
          "package": "compdata",
          "signature": "(Term f -\u003e r) -\u003e (r -\u003e r -\u003e r) -\u003e Term f -\u003e r",
          "source": "src/Data-Comp-Generic.html#query",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Generic",
          "module": "Data.Comp.Generic",
          "name": "query",
          "normalized": "(Term a-\u003eb)-\u003e(b-\u003eb-\u003eb)-\u003eTerm a-\u003eb",
          "package": "compdata",
          "signature": "(Term f-\u003er)-\u003e(r-\u003er-\u003er)-\u003eTerm f-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Generic.html#v:query"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function computes the generic size of the given term,\n i.e. the its number of subterm occurrences.\n\u003c/p\u003e",
          "module": "Data.Comp.Generic",
          "name": "size",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Int",
          "source": "src/Data-Comp-Generic.html#size",
          "type": "function"
        },
        "index": {
          "description": "This function computes the generic size of the given term i.e the its number of subterm occurrences",
          "hierarchy": "Data Comp Generic",
          "module": "Data.Comp.Generic",
          "name": "size",
          "normalized": "Cxt a b c-\u003eInt",
          "package": "compdata",
          "signature": "Cxt h f a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Generic.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function returns a list of all subterms of the given\n term. This function is similar to Uniplate's \u003ccode\u003euniverse\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Data.Comp.Generic",
          "name": "subterms",
          "package": "compdata",
          "signature": "Term f -\u003e [Term f]",
          "source": "src/Data-Comp-Generic.html#subterms",
          "type": "function"
        },
        "index": {
          "description": "This function returns list of all subterms of the given term This function is similar to Uniplate universe function",
          "hierarchy": "Data Comp Generic",
          "module": "Data.Comp.Generic",
          "name": "subterms",
          "normalized": "Term a-\u003e[Term a]",
          "package": "compdata",
          "signature": "Term f-\u003e[Term f]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Generic.html#v:subterms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function returns a list of all subterms of the given term\n that are constructed from a particular functor.\n\u003c/p\u003e",
          "module": "Data.Comp.Generic",
          "name": "subterms'",
          "package": "compdata",
          "signature": "Term f -\u003e [g (Term f)]",
          "source": "src/Data-Comp-Generic.html#subterms%27",
          "type": "function"
        },
        "index": {
          "description": "This function returns list of all subterms of the given term that are constructed from particular functor",
          "hierarchy": "Data Comp Generic",
          "module": "Data.Comp.Generic",
          "name": "subterms'",
          "normalized": "Term a-\u003e[b(Term a)]",
          "package": "compdata",
          "signature": "Term f-\u003e[g(Term f)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Generic.html#v:subterms-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function transforms every subterm according to the given\n function in a bottom-up manner. This function is similar to\n Uniplate's \u003ccode\u003etransform\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Data.Comp.Generic",
          "name": "transform",
          "package": "compdata",
          "signature": "(Term f -\u003e Term f) -\u003e Term f -\u003e Term f",
          "source": "src/Data-Comp-Generic.html#transform",
          "type": "function"
        },
        "index": {
          "description": "This function transforms every subterm according to the given function in bottom-up manner This function is similar to Uniplate transform function",
          "hierarchy": "Data Comp Generic",
          "module": "Data.Comp.Generic",
          "name": "transform",
          "normalized": "(Term a-\u003eTerm a)-\u003eTerm a-\u003eTerm a",
          "package": "compdata",
          "signature": "(Term f-\u003eTerm f)-\u003eTerm f-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Generic.html#v:transform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Generic",
          "name": "transform'",
          "package": "compdata",
          "signature": "(Term f -\u003e Maybe (Term f)) -\u003e Term f -\u003e Term f",
          "source": "src/Data-Comp-Generic.html#transform%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Generic",
          "module": "Data.Comp.Generic",
          "name": "transform'",
          "normalized": "(Term a-\u003eMaybe(Term a))-\u003eTerm a-\u003eTerm a",
          "package": "compdata",
          "signature": "(Term f-\u003eMaybe(Term f))-\u003eTerm f-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Generic.html#v:transform-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic version of \u003ccode\u003e\u003ca\u003etransform\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Generic",
          "name": "transformM",
          "package": "compdata",
          "signature": "(Term f -\u003e m (Term f)) -\u003e Term f -\u003e m (Term f)",
          "source": "src/Data-Comp-Generic.html#transformM",
          "type": "function"
        },
        "index": {
          "description": "Monadic version of transform",
          "hierarchy": "Data Comp Generic",
          "module": "Data.Comp.Generic",
          "name": "transformM",
          "normalized": "(Term a-\u003eb(Term a))-\u003eTerm a-\u003eb(Term a)",
          "package": "compdata",
          "signature": "(Term f-\u003em(Term f))-\u003eTerm f-\u003em(Term f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Generic.html#v:transformM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines macro tree transducers (MTTs). It provides\n functions to run MTTs and to compose them with top down tree\n transducers. It also defines MTTs with regular look-ahead which\n combines MTTs with bottom-up tree acceptors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "MacroAutomata",
          "package": "compdata",
          "source": "src/Data-Comp-MacroAutomata.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines macro tree transducers MTTs It provides functions to run MTTs and to compose them with top down tree transducers It also defines MTTs with regular look-ahead which combines MTTs with bottom-up tree acceptors",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "MacroAutomata",
          "package": "compdata",
          "partial": "Macro Automata",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type constructor is used to define the state space of an MTT\n that is obtained by composing an MTT followed by a DTT.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": ":^:",
          "package": "compdata",
          "source": "src/Data-Comp-MacroAutomata.html#%3A%5E%3A",
          "type": "data"
        },
        "index": {
          "description": "This type constructor is used to define the state space of an MTT that is obtained by composing an MTT followed by DTT",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": ":^:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#t::-94-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity Functor.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "I",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#I",
          "type": "newtype"
        },
        "index": {
          "description": "The identity Functor",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "I",
          "package": "compdata",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#t:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents total deterministic macro tree transducers\n (MTTs).\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "MacroTrans",
          "package": "compdata",
          "source": "src/Data-Comp-MacroAutomata.html#MacroTrans",
          "type": "type"
        },
        "index": {
          "description": "This type represents total deterministic macro tree transducers MTTs",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "MacroTrans",
          "package": "compdata",
          "partial": "Macro Trans",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#t:MacroTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a variant of the type \u003ccode\u003e\u003ca\u003eMacroTrans\u003c/a\u003e\u003c/code\u003e that makes it easier\n to define MTTs as it avoids the explicit use of \u003ccode\u003e\u003ca\u003eHole\u003c/a\u003e\u003c/code\u003e when using\n placeholders in the result.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "MacroTrans'",
          "package": "compdata",
          "source": "src/Data-Comp-MacroAutomata.html#MacroTrans%27",
          "type": "type"
        },
        "index": {
          "description": "This is variant of the type MacroTrans that makes it easier to define MTTs as it avoids the explicit use of Hole when using placeholders in the result",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "MacroTrans'",
          "package": "compdata",
          "partial": "Macro Trans'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#t:MacroTrans-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type is an instantiation of the \u003ccode\u003e\u003ca\u003eMacroTrans\u003c/a\u003e\u003c/code\u003e type to a state\n space with only a single state with a single accumulation parameter\n (i.e. the state space is the identity functor).\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "MacroTransId",
          "package": "compdata",
          "source": "src/Data-Comp-MacroAutomata.html#MacroTransId",
          "type": "type"
        },
        "index": {
          "description": "This type is an instantiation of the MacroTrans type to state space with only single state with single accumulation parameter i.e the state space is the identity functor",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "MacroTransId",
          "package": "compdata",
          "partial": "Macro Trans Id",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#t:MacroTransId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type is a variant of the \u003ccode\u003e\u003ca\u003eMacroTransId\u003c/a\u003e\u003c/code\u003e which is more\n convenient to work with as it avoids the explicit use of \u003ccode\u003e\u003ca\u003eHole\u003c/a\u003e\u003c/code\u003e to\n embed placeholders into the result.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "MacroTransId'",
          "package": "compdata",
          "source": "src/Data-Comp-MacroAutomata.html#MacroTransId%27",
          "type": "type"
        },
        "index": {
          "description": "This type is variant of the MacroTransId which is more convenient to work with as it avoids the explicit use of Hole to embed placeholders into the result",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "MacroTransId'",
          "package": "compdata",
          "partial": "Macro Trans Id'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#t:MacroTransId-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents MTTs with regular look-ahead, i.e. MTTs that\n have access to information that is generated by a separate UTA.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "MacroTransLA",
          "package": "compdata",
          "source": "src/Data-Comp-MacroAutomata.html#MacroTransLA",
          "type": "type"
        },
        "index": {
          "description": "This type represents MTTs with regular look-ahead i.e MTTs that have access to information that is generated by separate UTA",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "MacroTransLA",
          "package": "compdata",
          "partial": "Macro Trans LA",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#t:MacroTransLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type is a more convenient variant of \u003ccode\u003e\u003ca\u003eMacroTransLA\u003c/a\u003e\u003c/code\u003e with\n which one can avoid using \u003ccode\u003e\u003ca\u003eHole\u003c/a\u003e\u003c/code\u003e explicitly when injecting\n placeholders in the result.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "MacroTransLA'",
          "package": "compdata",
          "source": "src/Data-Comp-MacroAutomata.html#MacroTransLA%27",
          "type": "type"
        },
        "index": {
          "description": "This type is more convenient variant of MacroTransLA with which one can avoid using Hole explicitly when injecting placeholders in the result",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "MacroTransLA'",
          "package": "compdata",
          "partial": "Macro Trans LA'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#t:MacroTransLA-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MacroAutomata",
          "name": ":^:",
          "package": "compdata",
          "signature": "(q (p -\u003e a)) :^: p",
          "source": "src/Data-Comp-MacroAutomata.html#%3A%5E%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": ":^:",
          "normalized": "(a(b-\u003ec))b",
          "package": "compdata",
          "signature": "(q(p-\u003ea))p",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#v::-94-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.MacroAutomata\",\"Data.Comp.Multi.HFunctor\",\"Data.Comp.MultiParam.HDifunctor\"]",
          "name": "I",
          "package": "compdata",
          "signature": "I",
          "source": "src/Data-Comp-Multi-HFunctor.html#I",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#v:I\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:I\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#v:I\"]"
        },
        "index": {
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "I",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#v:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes an MTT followed by a DTT. The resulting\n MTT's semantics is equivalent to first running the original MTT and\n then the DTT.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "compDownMacro",
          "package": "compdata",
          "signature": "DownTrans g p h -\u003e MacroTrans f q g -\u003e MacroTrans f (q :^: p) h",
          "source": "src/Data-Comp-MacroAutomata.html#compDownMacro",
          "type": "function"
        },
        "index": {
          "description": "This function composes an MTT followed by DTT The resulting MTT semantics is equivalent to first running the original MTT and then the DTT",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "compDownMacro",
          "normalized": "DownTrans a b c-\u003eMacroTrans d e a-\u003eMacroTrans d(e b)c",
          "package": "compdata",
          "partial": "Down Macro",
          "signature": "DownTrans g p h-\u003eMacroTrans f q g-\u003eMacroTrans f(q p)h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#v:compDownMacro"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes an MTT with regular look-ahead followed by\n a DTT.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "compDownMacroLA",
          "package": "compdata",
          "signature": "DownTrans g q2 h -\u003e MacroTransLA f q1 p g -\u003e MacroTransLA f (q1 :^: q2) p h",
          "source": "src/Data-Comp-MacroAutomata.html#compDownMacroLA",
          "type": "function"
        },
        "index": {
          "description": "This function composes an MTT with regular look-ahead followed by DTT",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "compDownMacroLA",
          "normalized": "DownTrans a b c-\u003eMacroTransLA d b e a-\u003eMacroTransLA d(b b)e c",
          "package": "compdata",
          "partial": "Down Macro LA",
          "signature": "DownTrans g q h-\u003eMacroTransLA f q p g-\u003eMacroTransLA f(q q)p h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#v:compDownMacroLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a DTT followed by an MTT. The resulting\n MTT's semantics is equivalent to the function composition of the\n semantics of the original MTT and DTT.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "compMacroDown",
          "package": "compdata",
          "signature": "MacroTrans g p h -\u003e DownTrans f q g -\u003e MacroTrans f (p :&: q) h",
          "source": "src/Data-Comp-MacroAutomata.html#compMacroDown",
          "type": "function"
        },
        "index": {
          "description": "This function composes DTT followed by an MTT The resulting MTT semantics is equivalent to the function composition of the semantics of the original MTT and DTT",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "compMacroDown",
          "normalized": "MacroTrans a b c-\u003eDownTrans d e a-\u003eMacroTrans d(b e)c",
          "package": "compdata",
          "partial": "Macro Down",
          "signature": "MacroTrans g p h-\u003eDownTrans f q g-\u003eMacroTrans f(p q)h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#v:compMacroDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function transforms an MTT of type |MacroTransId| into the\n canonical type such that it can be run.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "fromMacroTransId",
          "package": "compdata",
          "signature": "MacroTransId f g -\u003e MacroTrans f I g",
          "source": "src/Data-Comp-MacroAutomata.html#fromMacroTransId",
          "type": "function"
        },
        "index": {
          "description": "This function transforms an MTT of type MacroTransId into the canonical type such that it can be run",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "fromMacroTransId",
          "normalized": "MacroTransId a b-\u003eMacroTrans a I b",
          "package": "compdata",
          "partial": "Macro Trans Id",
          "signature": "MacroTransId f g-\u003eMacroTrans f I g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#v:fromMacroTransId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function transforms an MTT of type |MacroTransId'| into the\n canonical type such that it can be run.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "fromMacroTransId'",
          "package": "compdata",
          "signature": "MacroTransId' f g -\u003e MacroTrans f I g",
          "source": "src/Data-Comp-MacroAutomata.html#fromMacroTransId%27",
          "type": "function"
        },
        "index": {
          "description": "This function transforms an MTT of type MacroTransId into the canonical type such that it can be run",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "fromMacroTransId'",
          "normalized": "MacroTransId' a b-\u003eMacroTrans a I b",
          "package": "compdata",
          "partial": "Macro Trans Id'",
          "signature": "MacroTransId' f g-\u003eMacroTrans f I g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#v:fromMacroTransId-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function turns an MTT defined using the more convenient type\n \u003ccode\u003e\u003ca\u003eMacroTrans'\u003c/a\u003e\u003c/code\u003e into its canonical form of type \u003ccode\u003e\u003ca\u003eMacroTrans\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "mkMacroTrans",
          "package": "compdata",
          "signature": "MacroTrans' f q g -\u003e MacroTrans f q g",
          "source": "src/Data-Comp-MacroAutomata.html#mkMacroTrans",
          "type": "function"
        },
        "index": {
          "description": "This function turns an MTT defined using the more convenient type MacroTrans into its canonical form of type MacroTrans",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "mkMacroTrans",
          "normalized": "MacroTrans' a b c-\u003eMacroTrans a b c",
          "package": "compdata",
          "partial": "Macro Trans",
          "signature": "MacroTrans' f q g-\u003eMacroTrans f q g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#v:mkMacroTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function turns an MTT with regular look-ahead defined using\n the more convenient type |MacroTransLA'| into its canonical form of\n type |MacroTransLA|.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "mkMacroTransLA",
          "package": "compdata",
          "signature": "MacroTransLA' f q p g -\u003e MacroTransLA f q p g",
          "source": "src/Data-Comp-MacroAutomata.html#mkMacroTransLA",
          "type": "function"
        },
        "index": {
          "description": "This function turns an MTT with regular look-ahead defined using the more convenient type MacroTransLA into its canonical form of type MacroTransLA",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "mkMacroTransLA",
          "normalized": "MacroTransLA' a b c d-\u003eMacroTransLA a b c d",
          "package": "compdata",
          "partial": "Macro Trans LA",
          "signature": "MacroTransLA' f q p g-\u003eMacroTransLA f q p g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#v:mkMacroTransLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function defines the semantics of MTTs. It applies a given\n MTT to an input with and an initial state.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "runMacroTrans",
          "package": "compdata",
          "signature": "MacroTrans f q g -\u003e q (Cxt h g a) -\u003e Cxt h f a -\u003e Cxt h g a",
          "source": "src/Data-Comp-MacroAutomata.html#runMacroTrans",
          "type": "function"
        },
        "index": {
          "description": "This function defines the semantics of MTTs It applies given MTT to an input with and an initial state",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "runMacroTrans",
          "normalized": "MacroTrans a b c-\u003eb(Cxt d c e)-\u003eCxt d a e-\u003eCxt d c e",
          "package": "compdata",
          "partial": "Macro Trans",
          "signature": "MacroTrans f q g-\u003eq(Cxt h g a)-\u003eCxt h f a-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#v:runMacroTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function defines the semantics of MTTs with regular\n look-ahead. It applies a given MTT with regular look-ahead\n (including an accompanying bottom-up state transition function) to\n an input with and an initial state.\n\u003c/p\u003e",
          "module": "Data.Comp.MacroAutomata",
          "name": "runMacroTransLA",
          "package": "compdata",
          "signature": "UpState f p -\u003e MacroTransLA f q p g -\u003e q (Term g) -\u003e Term f -\u003e Term g",
          "source": "src/Data-Comp-MacroAutomata.html#runMacroTransLA",
          "type": "function"
        },
        "index": {
          "description": "This function defines the semantics of MTTs with regular look-ahead It applies given MTT with regular look-ahead including an accompanying bottom-up state transition function to an input with and an initial state",
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "runMacroTransLA",
          "normalized": "UpState a b-\u003eMacroTransLA a c b d-\u003ec(Term d)-\u003eTerm a-\u003eTerm d",
          "package": "compdata",
          "partial": "Macro Trans LA",
          "signature": "UpState f p-\u003eMacroTransLA f q p g-\u003eq(Term g)-\u003eTerm f-\u003eTerm g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#v:runMacroTransLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.MacroAutomata\",\"Data.Comp.Multi.HFunctor\",\"Data.Comp.MultiParam.HDifunctor\"]",
          "name": "unI",
          "package": "compdata",
          "signature": "a",
          "source": "src/Data-Comp-Multi-HFunctor.html#I",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#v:unI\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:unI\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#v:unI\"]"
        },
        "index": {
          "hierarchy": "Data Comp MacroAutomata",
          "module": "Data.Comp.MacroAutomata",
          "name": "unI",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MacroAutomata.html#v:unI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module implements matching of contexts or terms with variables againts terms\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Matching",
          "name": "Matching",
          "package": "compdata",
          "source": "src/Data-Comp-Matching.html",
          "type": "module"
        },
        "index": {
          "description": "This module implements matching of contexts or terms with variables againts terms",
          "hierarchy": "Data Comp Matching",
          "module": "Data.Comp.Matching",
          "name": "Matching",
          "package": "compdata",
          "partial": "Matching",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Matching.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function takes a context \u003ccode\u003ec\u003c/code\u003e as the first argument and tries\nto match it against the term \u003ccode\u003et\u003c/code\u003e (or in general a context with holes\nin \u003ccode\u003ea\u003c/code\u003e). The context \u003ccode\u003ec\u003c/code\u003e matches the term \u003ccode\u003et\u003c/code\u003e if there is a\n\u003cem\u003ematching substitution\u003c/em\u003e \u003ccode\u003es\u003c/code\u003e that maps holes to terms (resp. contexts in general)\nsuch that if the holes in the context \u003ccode\u003ec\u003c/code\u003e are replaced according to\nthe substitution \u003ccode\u003es\u003c/code\u003e, the term \u003ccode\u003et\u003c/code\u003e is obtained. Note that the context\n\u003ccode\u003ec\u003c/code\u003e might be non-linear, i.e. has multiple holes that are\nequal. According to the above definition this means that holes with\nequal holes have to be instantiated by equal terms! \n\u003c/p\u003e",
          "module": "Data.Comp.Matching",
          "name": "matchCxt",
          "package": "compdata",
          "signature": "Context f v -\u003e Cxt h f a -\u003e Maybe (CxtSubst h a f v)",
          "source": "src/Data-Comp-Matching.html#matchCxt",
          "type": "function"
        },
        "index": {
          "description": "This function takes context as the first argument and tries to match it against the term or in general context with holes in The context matches the term if there is matching substitution that maps holes to terms resp contexts in general such that if the holes in the context are replaced according to the substitution the term is obtained Note that the context might be non-linear i.e has multiple holes that are equal According to the above definition this means that holes with equal holes have to be instantiated by equal terms",
          "hierarchy": "Data Comp Matching",
          "module": "Data.Comp.Matching",
          "name": "matchCxt",
          "normalized": "Context a b-\u003eCxt c a d-\u003eMaybe(CxtSubst c d a b)",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "Context f v-\u003eCxt h f a-\u003eMaybe(CxtSubst h a f v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Matching.html#v:matchCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function is similar to \u003ccode\u003e\u003ca\u003ematchCxt\u003c/a\u003e\u003c/code\u003e but instead of a context it\nmatches a term with variables against a context.  \n\u003c/p\u003e",
          "module": "Data.Comp.Matching",
          "name": "matchTerm",
          "package": "compdata",
          "signature": "Term f -\u003e Cxt h f a -\u003e Maybe (CxtSubst h a f v)",
          "source": "src/Data-Comp-Matching.html#matchTerm",
          "type": "function"
        },
        "index": {
          "description": "This function is similar to matchCxt but instead of context it matches term with variables against context",
          "hierarchy": "Data Comp Matching",
          "module": "Data.Comp.Matching",
          "name": "matchTerm",
          "normalized": "Term a-\u003eCxt b a c-\u003eMaybe(CxtSubst b c a d)",
          "package": "compdata",
          "partial": "Term",
          "signature": "Term f-\u003eCxt h f a-\u003eMaybe(CxtSubst h a f v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Matching.html#v:matchTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the notion of algebras and catamorphisms, and their\n generalizations to e.g. monadic versions and other (co)recursion schemes.\n All definitions are generalised versions of those in \u003ca\u003eData.Comp.Algebra\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "Algebra",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the notion of algebras and catamorphisms and their generalizations to e.g monadic versions and other co recursion schemes All definitions are generalised versions of those in Data.Comp.Algebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "Algebra",
          "package": "compdata",
          "partial": "Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents multisorted \u003ccode\u003ef\u003c/code\u003e-algebras with a family \u003ccode\u003ee\u003c/code\u003e\n of carriers.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "Alg",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#Alg",
          "type": "type"
        },
        "index": {
          "description": "This type represents multisorted algebras with family of carriers",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "Alg",
          "package": "compdata",
          "partial": "Alg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:Alg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic algebra. It is similar to \u003ccode\u003e\u003ca\u003eAlg\u003c/a\u003e\u003c/code\u003e\n but the return type is monadic.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "AlgM",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#AlgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic algebra It is similar to Alg but the return type is monadic",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "AlgM",
          "package": "compdata",
          "partial": "Alg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:AlgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents cv-coalgebras over functor \u003ccode\u003ef\u003c/code\u003e and with domain\n \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "CVCoalg",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#CVCoalg",
          "type": "type"
        },
        "index": {
          "description": "This type represents cv-coalgebras over functor and with domain",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "CVCoalg",
          "package": "compdata",
          "partial": "CVCoalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:CVCoalg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents monadic cv-coalgebras over monad \u003ccode\u003em\u003c/code\u003e and\n functor \u003ccode\u003ef\u003c/code\u003e, and with domain \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "CVCoalgM",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#CVCoalgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic cv-coalgebras over monad and functor and with domain",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "CVCoalgM",
          "package": "compdata",
          "partial": "CVCoalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:CVCoalgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Algebra",
          "name": "Coalg",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#Coalg",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "Coalg",
          "package": "compdata",
          "partial": "Coalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:Coalg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Algebra",
          "name": "CoalgM",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#CoalgM",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "CoalgM",
          "package": "compdata",
          "partial": "Coalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:CoalgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents context function.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "CxtFun",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#CxtFun",
          "type": "type"
        },
        "index": {
          "description": "This type represents context function",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "CxtFun",
          "package": "compdata",
          "partial": "Cxt Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:CxtFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents monadic context function.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "CxtFunM",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#CxtFunM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic context function",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "CxtFunM",
          "package": "compdata",
          "partial": "Cxt Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:CxtFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents term homomorphisms.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "Hom",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#Hom",
          "type": "type"
        },
        "index": {
          "description": "This type represents term homomorphisms",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "Hom",
          "package": "compdata",
          "partial": "Hom",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:Hom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents monadic term algebras.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "HomM",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#HomM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic term algebras",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "HomM",
          "package": "compdata",
          "partial": "Hom",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:HomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents r-algebras over functor \u003ccode\u003ef\u003c/code\u003e and with domain\n \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "RAlg",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#RAlg",
          "type": "type"
        },
        "index": {
          "description": "This type represents r-algebras over functor and with domain",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "RAlg",
          "package": "compdata",
          "partial": "RAlg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:RAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents monadic r-algebras over monad \u003ccode\u003em\u003c/code\u003e and\n functor \u003ccode\u003ef\u003c/code\u003e and with domain \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "RAlgM",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#RAlgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic r-algebras over monad and functor and with domain",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "RAlgM",
          "package": "compdata",
          "partial": "RAlg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:RAlgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents r-coalgebras over functor \u003ccode\u003ef\u003c/code\u003e and with\n domain \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "RCoalg",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#RCoalg",
          "type": "type"
        },
        "index": {
          "description": "This type represents r-coalgebras over functor and with domain",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "RCoalg",
          "package": "compdata",
          "partial": "RCoalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:RCoalg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents monadic r-coalgebras over monad \u003ccode\u003em\u003c/code\u003e and\n functor \u003ccode\u003ef\u003c/code\u003e with domain \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "RCoalgM",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#RCoalgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic r-coalgebras over monad and functor with domain",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "RCoalgM",
          "package": "compdata",
          "partial": "RCoalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:RCoalgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents uniform signature function specification.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "SigFun",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#SigFun",
          "type": "type"
        },
        "index": {
          "description": "This type represents uniform signature function specification",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "SigFun",
          "package": "compdata",
          "partial": "Sig Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:SigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents monadic signature functions.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "SigFunM",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Algebra.html#SigFunM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic signature functions",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "SigFunM",
          "package": "compdata",
          "partial": "Sig Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#t:SigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function unfolds the given value to a term using the given\nunravelling function. This is the unique homomorphism \u003ccode\u003ea -\u003e Term f\u003c/code\u003e\nfrom the given coalgebra of type \u003ccode\u003ea -\u003e f a\u003c/code\u003e to the final coalgebra\n\u003ccode\u003eTerm f\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "ana",
          "package": "compdata",
          "signature": "Coalg f a -\u003e a :-\u003e Term f",
          "source": "src/Data-Comp-Multi-Algebra.html#ana",
          "type": "function"
        },
        "index": {
          "description": "This function unfolds the given value to term using the given unravelling function This is the unique homomorphism Term from the given coalgebra of type to the final coalgebra Term",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "ana",
          "normalized": "Coalg a b-\u003eb-\u003eTerm a",
          "package": "compdata",
          "signature": "Coalg f a-\u003ea-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:ana"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function unfolds the given value to a term using the given\n monadic unravelling function. This is the unique homomorphism \u003ccode\u003ea -\u003e\n Term f\u003c/code\u003e from the given coalgebra of type \u003ccode\u003ea -\u003e f a\u003c/code\u003e to the final\n coalgebra \u003ccode\u003eTerm f\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "anaM",
          "package": "compdata",
          "signature": "CoalgM m f a -\u003e NatM m a (Term f)",
          "source": "src/Data-Comp-Multi-Algebra.html#anaM",
          "type": "function"
        },
        "index": {
          "description": "This function unfolds the given value to term using the given monadic unravelling function This is the unique homomorphism Term from the given coalgebra of type to the final coalgebra Term",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "anaM",
          "normalized": "CoalgM a b c-\u003eNatM a c(Term b)",
          "package": "compdata",
          "signature": "CoalgM m f a-\u003eNatM m a(Term f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:anaM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function constructs an apomorphism from the given\n r-coalgebra.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "apo",
          "package": "compdata",
          "signature": "RCoalg f a -\u003e a :-\u003e Term f",
          "source": "src/Data-Comp-Multi-Algebra.html#apo",
          "type": "function"
        },
        "index": {
          "description": "This function constructs an apomorphism from the given r-coalgebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "apo",
          "normalized": "RCoalg a b-\u003eb-\u003eTerm a",
          "package": "compdata",
          "signature": "RCoalg f a-\u003ea-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:apo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function constructs a monadic apomorphism from the given\n monadic r-coalgebra.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "apoM",
          "package": "compdata",
          "signature": "RCoalgM m f a -\u003e NatM m a (Term f)",
          "source": "src/Data-Comp-Multi-Algebra.html#apoM",
          "type": "function"
        },
        "index": {
          "description": "This function constructs monadic apomorphism from the given monadic r-coalgebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "apoM",
          "normalized": "RCoalgM a b c-\u003eNatM a c(Term b)",
          "package": "compdata",
          "signature": "RCoalgM m f a-\u003eNatM m a(Term f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:apoM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a whole context into another context.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appCxt",
          "package": "compdata",
          "signature": "Context f (Cxt h f a) :-\u003e Cxt h f a",
          "source": "src/Data-Comp-Multi-Algebra.html#appCxt",
          "type": "function"
        },
        "index": {
          "description": "This function applies whole context into another context",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appCxt",
          "normalized": "Context a(Cxt b a c)-\u003eCxt b a c",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "Context f(Cxt h f a)-\u003eCxt h f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:appCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies the given term homomorphism to a\n term/context.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appHom",
          "package": "compdata",
          "signature": "Hom f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-Multi-Algebra.html#appHom",
          "type": "function"
        },
        "index": {
          "description": "This function applies the given term homomorphism to term context",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appHom",
          "normalized": "Hom a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Hom",
          "signature": "Hom f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:appHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies the given term homomorphism to a\n term/context. This is the top-down variant of \u003ccode\u003e\u003ca\u003eappHom\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appHom'",
          "package": "compdata",
          "signature": "Hom f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-Multi-Algebra.html#appHom%27",
          "type": "function"
        },
        "index": {
          "description": "This function applies the given term homomorphism to term context This is the top-down variant of appHom",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appHom'",
          "normalized": "Hom a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Hom'",
          "signature": "Hom f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:appHom-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies the given monadic term homomorphism to the\n given term/context.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appHomM",
          "package": "compdata",
          "signature": "HomM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Multi-Algebra.html#appHomM",
          "type": "function"
        },
        "index": {
          "description": "This function applies the given monadic term homomorphism to the given term context",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appHomM",
          "normalized": "HomM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Hom",
          "signature": "HomM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:appHomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies the given monadic term homomorphism to the\n given term/context. This is a top-down variant of \u003ccode\u003e\u003ca\u003eappHomM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appHomM'",
          "package": "compdata",
          "signature": "HomM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Multi-Algebra.html#appHomM%27",
          "type": "function"
        },
        "index": {
          "description": "This function applies the given monadic term homomorphism to the given term context This is top-down variant of appHomM",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appHomM'",
          "normalized": "HomM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Hom M'",
          "signature": "HomM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:appHomM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a signature function to the given context.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appSigFun",
          "package": "compdata",
          "signature": "SigFun f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-Multi-Algebra.html#appSigFun",
          "type": "function"
        },
        "index": {
          "description": "This function applies signature function to the given context",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appSigFun",
          "normalized": "SigFun a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFun f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:appSigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a signature function to the given\n context. This is the top-down variant of \u003ccode\u003e\u003ca\u003eappSigFun\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appSigFun'",
          "package": "compdata",
          "signature": "SigFun f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-Multi-Algebra.html#appSigFun%27",
          "type": "function"
        },
        "index": {
          "description": "This function applies signature function to the given context This is the top-down variant of appSigFun",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appSigFun'",
          "normalized": "SigFun a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Sig Fun'",
          "signature": "SigFun f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:appSigFun-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies the given monadic signature function to the\n given context.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appSigFunM",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Multi-Algebra.html#appSigFunM",
          "type": "function"
        },
        "index": {
          "description": "This function applies the given monadic signature function to the given context",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appSigFunM",
          "normalized": "SigFunM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFunM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:appSigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies the given monadic signature function to the\n given context. This is a top-down variant of \u003ccode\u003e\u003ca\u003eappSigFunM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appSigFunM'",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Multi-Algebra.html#appSigFunM%27",
          "type": "function"
        },
        "index": {
          "description": "This function applies the given monadic signature function to the given context This is top-down variant of appSigFunM",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "appSigFunM'",
          "normalized": "SigFunM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Sig Fun M'",
          "signature": "SigFunM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:appSigFunM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a catamorphism from the given algebra.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "cata",
          "package": "compdata",
          "signature": "Alg f a -\u003e Term f :-\u003e a",
          "source": "src/Data-Comp-Multi-Algebra.html#cata",
          "type": "function"
        },
        "index": {
          "description": "Construct catamorphism from the given algebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "cata",
          "normalized": "Alg a b-\u003eTerm a-\u003eb",
          "package": "compdata",
          "signature": "Alg f a-\u003eTerm f-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:cata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalisation of \u003ccode\u003e\u003ca\u003ecata\u003c/a\u003e\u003c/code\u003e from terms over \u003ccode\u003ef\u003c/code\u003e to contexts over\n \u003ccode\u003ef\u003c/code\u003e, where the holes have the type of the algebra carrier.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "cata'",
          "package": "compdata",
          "signature": "Alg f e -\u003e Cxt h f e :-\u003e e",
          "source": "src/Data-Comp-Multi-Algebra.html#cata%27",
          "type": "function"
        },
        "index": {
          "description": "generalisation of cata from terms over to contexts over where the holes have the type of the algebra carrier",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "cata'",
          "normalized": "Alg a b-\u003eCxt c a b-\u003eb",
          "package": "compdata",
          "signature": "Alg f e-\u003eCxt h f e-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:cata-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a monadic version of \u003ccode\u003e\u003ca\u003ecata\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "cataM",
          "package": "compdata",
          "signature": "AlgM m f a -\u003e NatM m (Term f) a",
          "source": "src/Data-Comp-Multi-Algebra.html#cataM",
          "type": "function"
        },
        "index": {
          "description": "This is monadic version of cata",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "cataM",
          "normalized": "AlgM a b c-\u003eNatM a(Term b)c",
          "package": "compdata",
          "signature": "AlgM m f a-\u003eNatM m(Term f)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:cataM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Algebra",
          "name": "cataM'",
          "package": "compdata",
          "signature": "AlgM m f a -\u003e NatM m (Cxt h f a) a",
          "source": "src/Data-Comp-Multi-Algebra.html#cataM%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "cataM'",
          "normalized": "AlgM a b c-\u003eNatM a(Cxt d b c)c",
          "package": "compdata",
          "partial": "M'",
          "signature": "AlgM m f a-\u003eNatM m(Cxt h f a)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:cataM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a term algebra with an algebra.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "compAlg",
          "package": "compdata",
          "signature": "Alg g a -\u003e Hom f g -\u003e Alg f a",
          "source": "src/Data-Comp-Multi-Algebra.html#compAlg",
          "type": "function"
        },
        "index": {
          "description": "This function composes term algebra with an algebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "compAlg",
          "normalized": "Alg a b-\u003eHom c a-\u003eAlg c b",
          "package": "compdata",
          "partial": "Alg",
          "signature": "Alg g a-\u003eHom f g-\u003eAlg f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:compAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a monadic term algebra with a monadic algebra \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "compAlgM",
          "package": "compdata",
          "signature": "AlgM m g a -\u003e HomM m f g -\u003e AlgM m f a",
          "source": "src/Data-Comp-Multi-Algebra.html#compAlgM",
          "type": "function"
        },
        "index": {
          "description": "This function composes monadic term algebra with monadic algebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "compAlgM",
          "normalized": "AlgM a b c-\u003eHomM a d b-\u003eAlgM a d c",
          "package": "compdata",
          "partial": "Alg",
          "signature": "AlgM m g a-\u003eHomM m f g-\u003eAlgM m f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:compAlgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a monadic term algebra with a monadic\n algebra.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "compAlgM'",
          "package": "compdata",
          "signature": "AlgM m g a -\u003e Hom f g -\u003e AlgM m f a",
          "source": "src/Data-Comp-Multi-Algebra.html#compAlgM%27",
          "type": "function"
        },
        "index": {
          "description": "This function composes monadic term algebra with monadic algebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "compAlgM'",
          "normalized": "AlgM a b c-\u003eHom d b-\u003eAlgM a d c",
          "package": "compdata",
          "partial": "Alg M'",
          "signature": "AlgM m g a-\u003eHom f g-\u003eAlgM m f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:compAlgM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two term algebras.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "compHom",
          "package": "compdata",
          "signature": "Hom g h -\u003e Hom f g -\u003e Hom f h",
          "source": "src/Data-Comp-Multi-Algebra.html#compHom",
          "type": "function"
        },
        "index": {
          "description": "This function composes two term algebras",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "compHom",
          "normalized": "Hom a b-\u003eHom c a-\u003eHom c b",
          "package": "compdata",
          "partial": "Hom",
          "signature": "Hom g h-\u003eHom f g-\u003eHom f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:compHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two monadic term algebras.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "compHomM",
          "package": "compdata",
          "signature": "HomM m g h -\u003e HomM m f g -\u003e HomM m f h",
          "source": "src/Data-Comp-Multi-Algebra.html#compHomM",
          "type": "function"
        },
        "index": {
          "description": "This function composes two monadic term algebras",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "compHomM",
          "normalized": "HomM a b c-\u003eHomM a d b-\u003eHomM a d c",
          "package": "compdata",
          "partial": "Hom",
          "signature": "HomM m g h-\u003eHomM m f g-\u003eHomM m f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:compHomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two signature functions.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "compSigFun",
          "package": "compdata",
          "signature": "SigFun g h -\u003e SigFun f g -\u003e SigFun f h",
          "source": "src/Data-Comp-Multi-Algebra.html#compSigFun",
          "type": "function"
        },
        "index": {
          "description": "This function composes two signature functions",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "compSigFun",
          "normalized": "SigFun a b-\u003eSigFun c a-\u003eSigFun c b",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFun g h-\u003eSigFun f g-\u003eSigFun f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:compSigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two monadic signature functions.  \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "compSigFunM",
          "package": "compdata",
          "signature": "SigFunM m g h -\u003e SigFunM m f g -\u003e SigFunM m f h",
          "source": "src/Data-Comp-Multi-Algebra.html#compSigFunM",
          "type": "function"
        },
        "index": {
          "description": "This function composes two monadic signature functions",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "compSigFunM",
          "normalized": "SigFunM a b c-\u003eSigFunM a d b-\u003eSigFunM a d c",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFunM m g h-\u003eSigFunM m f g-\u003eSigFunM m f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:compSigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a catamorphism for contexts over \u003ccode\u003ef\u003c/code\u003e with holes of type\n \u003ccode\u003eb\u003c/code\u003e, from the given algebra.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "free",
          "package": "compdata",
          "signature": "Alg f b -\u003e (a :-\u003e b) -\u003e Cxt h f a :-\u003e b",
          "source": "src/Data-Comp-Multi-Algebra.html#free",
          "type": "function"
        },
        "index": {
          "description": "Construct catamorphism for contexts over with holes of type from the given algebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "free",
          "normalized": "Alg a b-\u003e(c-\u003eb)-\u003eCxt d a c-\u003eb",
          "package": "compdata",
          "signature": "Alg f b-\u003e(a-\u003eb)-\u003eCxt h f a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:free"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic catamorphism for contexts over \u003ccode\u003ef\u003c/code\u003e with holes\n of type \u003ccode\u003eb\u003c/code\u003e, from the given monadic algebra.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "freeM",
          "package": "compdata",
          "signature": "AlgM m f b -\u003e NatM m a b -\u003e NatM m (Cxt h f a) b",
          "source": "src/Data-Comp-Multi-Algebra.html#freeM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic catamorphism for contexts over with holes of type from the given monadic algebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "freeM",
          "normalized": "AlgM a b c-\u003eNatM a d c-\u003eNatM a(Cxt e b d)c",
          "package": "compdata",
          "signature": "AlgM m f b-\u003eNatM m a b-\u003eNatM m(Cxt h f a)b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:freeM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function constructs the unique futumorphism from the given\n cv-coalgebra to the term algebra.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "futu",
          "package": "compdata",
          "signature": "CVCoalg f a -\u003e a :-\u003e Term f",
          "source": "src/Data-Comp-Multi-Algebra.html#futu",
          "type": "function"
        },
        "index": {
          "description": "This function constructs the unique futumorphism from the given cv-coalgebra to the term algebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "futu",
          "normalized": "CVCoalg a b-\u003eb-\u003eTerm a",
          "package": "compdata",
          "signature": "CVCoalg f a-\u003ea-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:futu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function constructs the unique monadic futumorphism from the\n given monadic cv-coalgebra to the term algebra.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "futuM",
          "package": "compdata",
          "signature": "CVCoalgM m f a -\u003e NatM m a (Term f)",
          "source": "src/Data-Comp-Multi-Algebra.html#futuM",
          "type": "function"
        },
        "index": {
          "description": "This function constructs the unique monadic futumorphism from the given monadic cv-coalgebra to the term algebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "futuM",
          "normalized": "CVCoalgM a b c-\u003eNatM a c(Term b)",
          "package": "compdata",
          "signature": "CVCoalgM m f a-\u003eNatM m a(Term f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:futuM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLifts the given signature function to the canonical term homomorphism.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "hom",
          "package": "compdata",
          "signature": "SigFun f g -\u003e Hom f g",
          "source": "src/Data-Comp-Multi-Algebra.html#hom",
          "type": "function"
        },
        "index": {
          "description": "Lifts the given signature function to the canonical term homomorphism",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "hom",
          "normalized": "SigFun a b-\u003eHom a b",
          "package": "compdata",
          "signature": "SigFun f g-\u003eHom f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:hom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function lifts the give monadic signature function to a\n monadic term algebra.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "hom'",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e HomM m f g",
          "source": "src/Data-Comp-Multi-Algebra.html#hom%27",
          "type": "function"
        },
        "index": {
          "description": "This function lifts the give monadic signature function to monadic term algebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "hom'",
          "normalized": "SigFunM a b c-\u003eHomM a b c",
          "package": "compdata",
          "signature": "SigFunM m f g-\u003eHomM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:hom-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function lifts the given signature function to a monadic\n term algebra.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "homM",
          "package": "compdata",
          "signature": "SigFun f g -\u003e HomM m f g",
          "source": "src/Data-Comp-Multi-Algebra.html#homM",
          "type": "function"
        },
        "index": {
          "description": "This function lifts the given signature function to monadic term algebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "homM",
          "normalized": "SigFun a b-\u003eHomM c a b",
          "package": "compdata",
          "signature": "SigFun f g-\u003eHomM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:homM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function lifts a many-sorted algebra to a monadic domain.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "liftMAlg",
          "package": "compdata",
          "signature": "Alg f I -\u003e Alg f m",
          "source": "src/Data-Comp-Multi-Algebra.html#liftMAlg",
          "type": "function"
        },
        "index": {
          "description": "This function lifts many-sorted algebra to monadic domain",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "liftMAlg",
          "normalized": "Alg a I-\u003eAlg a b",
          "package": "compdata",
          "partial": "MAlg",
          "signature": "Alg f I-\u003eAlg f m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:liftMAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function constructs a paramorphism from the given r-algebra\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "para",
          "package": "compdata",
          "signature": "RAlg f a -\u003e Term f :-\u003e a",
          "source": "src/Data-Comp-Multi-Algebra.html#para",
          "type": "function"
        },
        "index": {
          "description": "This function constructs paramorphism from the given r-algebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "para",
          "normalized": "RAlg a b-\u003eTerm a-\u003eb",
          "package": "compdata",
          "signature": "RAlg f a-\u003eTerm f-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:para"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function constructs a monadic paramorphism from the given\n monadic r-algebra\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "paraM",
          "package": "compdata",
          "signature": "RAlgM m f a -\u003e NatM m (Term f) a",
          "source": "src/Data-Comp-Multi-Algebra.html#paraM",
          "type": "function"
        },
        "index": {
          "description": "This function constructs monadic paramorphism from the given monadic r-algebra",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "paraM",
          "normalized": "RAlgM a b c-\u003eNatM a(Term b)c",
          "package": "compdata",
          "signature": "RAlgM m f a-\u003eNatM m(Term f)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:paraM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function lifts the given signature function to a monadic\n signature function. Note that term algebras are instances of\n signature functions. Hence this function also applies to term\n algebras.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Algebra",
          "name": "sigFunM",
          "package": "compdata",
          "signature": "SigFun f g -\u003e SigFunM m f g",
          "source": "src/Data-Comp-Multi-Algebra.html#sigFunM",
          "type": "function"
        },
        "index": {
          "description": "This function lifts the given signature function to monadic signature function Note that term algebras are instances of signature functions Hence this function also applies to term algebras",
          "hierarchy": "Data Comp Multi Algebra",
          "module": "Data.Comp.Multi.Algebra",
          "name": "sigFunM",
          "normalized": "SigFun a b-\u003eSigFunM c a b",
          "package": "compdata",
          "partial": "Fun",
          "signature": "SigFun f g-\u003eSigFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Algebra.html#v:sigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines annotations on signatures. All definitions are\n generalised versions of those in \u003ca\u003eData.Comp.Annotation\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.Annotation",
          "name": "Annotation",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Annotation.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines annotations on signatures All definitions are generalised versions of those in Data.Comp.Annotation",
          "hierarchy": "Data Comp Multi Annotation",
          "module": "Data.Comp.Multi.Annotation",
          "name": "Annotation",
          "package": "compdata",
          "partial": "Annotation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type adds a constant product to a\n signature. Alternatively, this could have also been defined as\n\u003c/p\u003e\u003cpre\u003edata (f :&: a) (g ::  * -\u003e *) e = f g e :&: a e\u003c/pre\u003e\u003cp\u003eThis is too general, however, for example for \u003ccode\u003eproductHHom\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Annotation",
          "name": ":&:",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ops.html#%3A%26%3A",
          "type": "data"
        },
        "index": {
          "description": "This data type adds constant product to signature Alternatively this could have also been defined as data This is too general however for example for productHHom",
          "hierarchy": "Data Comp Multi Annotation",
          "module": "Data.Comp.Multi.Annotation",
          "name": ":&:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#t::-38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class defines how to distribute an annotation over a sum of\n signatures.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Annotation",
          "name": "DistAnn",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ops.html#DistAnn",
          "type": "class"
        },
        "index": {
          "description": "This class defines how to distribute an annotation over sum of signatures",
          "hierarchy": "Data Comp Multi Annotation",
          "module": "Data.Comp.Multi.Annotation",
          "name": "DistAnn",
          "package": "compdata",
          "partial": "Dist Ann",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#t:DistAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Annotation",
          "name": "RemA",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ops.html#RemA",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp Multi Annotation",
          "module": "Data.Comp.Multi.Annotation",
          "name": "RemA",
          "package": "compdata",
          "partial": "Rem",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#t:RemA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.Multi.Annotation\",\"Data.Comp.Multi.Ops\"]",
          "name": ":&:",
          "package": "compdata",
          "signature": "(f g e) :&: a",
          "source": "src/Data-Comp-Multi-Ops.html#%3A%26%3A",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#v::-38-:\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#v::-38-:\"]"
        },
        "index": {
          "hierarchy": "Data Comp Multi Annotation",
          "module": "Data.Comp.Multi.Annotation",
          "name": ":&:",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#v::-38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function annotates each sub term of the given term with the\n given value (of type a).\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Annotation",
          "name": "ann",
          "package": "compdata",
          "signature": "p -\u003e CxtFun f g",
          "source": "src/Data-Comp-Multi-Annotation.html#ann",
          "type": "function"
        },
        "index": {
          "description": "This function annotates each sub term of the given term with the given value of type",
          "hierarchy": "Data Comp Multi Annotation",
          "module": "Data.Comp.Multi.Annotation",
          "name": "ann",
          "normalized": "a-\u003eCxtFun b c",
          "package": "compdata",
          "signature": "p-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#v:ann"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function injects an annotation over a signature.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Annotation",
          "name": "injectA",
          "package": "compdata",
          "signature": "p -\u003e s a :-\u003e s' a",
          "source": "src/Data-Comp-Multi-Ops.html#injectA",
          "type": "method"
        },
        "index": {
          "description": "This function injects an annotation over signature",
          "hierarchy": "Data Comp Multi Annotation",
          "module": "Data.Comp.Multi.Annotation",
          "name": "injectA",
          "normalized": "a-\u003eb c-\u003ed c",
          "package": "compdata",
          "signature": "p-\u003es a-\u003es' a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#v:injectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function transforms a function with a domain constructed\n from a functor to a function with a domain constructed with the\n same functor but with an additional annotation.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Annotation",
          "name": "liftA",
          "package": "compdata",
          "signature": "(s' a :-\u003e t) -\u003e s a :-\u003e t",
          "source": "src/Data-Comp-Multi-Annotation.html#liftA",
          "type": "function"
        },
        "index": {
          "description": "This function transforms function with domain constructed from functor to function with domain constructed with the same functor but with an additional annotation",
          "hierarchy": "Data Comp Multi Annotation",
          "module": "Data.Comp.Multi.Annotation",
          "name": "liftA",
          "normalized": "(a b-\u003ec)-\u003ed b-\u003ec",
          "package": "compdata",
          "signature": "(s' a-\u003et)-\u003es a-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#v:liftA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function transforms a function with a domain constructed\n from a functor to a function with a domain constructed with the\n same functor but with an additional annotation.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Annotation",
          "name": "liftA'",
          "package": "compdata",
          "signature": "(s' a :-\u003e Cxt h s' a) -\u003e s a :-\u003e Cxt h s a",
          "source": "src/Data-Comp-Multi-Annotation.html#liftA%27",
          "type": "function"
        },
        "index": {
          "description": "This function transforms function with domain constructed from functor to function with domain constructed with the same functor but with an additional annotation",
          "hierarchy": "Data Comp Multi Annotation",
          "module": "Data.Comp.Multi.Annotation",
          "name": "liftA'",
          "normalized": "(a b-\u003eCxt c a b)-\u003ed b-\u003eCxt c d b",
          "package": "compdata",
          "partial": "A'",
          "signature": "(s' a-\u003eCxt h s' a)-\u003es a-\u003eCxt h s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#v:liftA-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function is similar to \u003ccode\u003e\u003ca\u003eproject\u003c/a\u003e\u003c/code\u003e but applies to signatures\n with an annotation which is then ignored.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Annotation",
          "name": "project'",
          "package": "compdata",
          "signature": "Cxt h f a i -\u003e Maybe (s (Cxt h f a) i)",
          "source": "src/Data-Comp-Multi-Annotation.html#project%27",
          "type": "function"
        },
        "index": {
          "description": "This function is similar to project but applies to signatures with an annotation which is then ignored",
          "hierarchy": "Data Comp Multi Annotation",
          "module": "Data.Comp.Multi.Annotation",
          "name": "project'",
          "normalized": "Cxt a b c d-\u003eMaybe(e(Cxt a b c)d)",
          "package": "compdata",
          "signature": "Cxt h f a i-\u003eMaybe(s(Cxt h f a)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#v:project-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Annotation",
          "name": "projectA",
          "package": "compdata",
          "signature": "s' a :-\u003e (s a :&: p)",
          "source": "src/Data-Comp-Multi-Ops.html#projectA",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Annotation",
          "module": "Data.Comp.Multi.Annotation",
          "name": "projectA",
          "normalized": "a b-\u003e(c b d)",
          "package": "compdata",
          "signature": "s' a-\u003e(s a p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#v:projectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Annotation",
          "name": "propAnn",
          "package": "compdata",
          "signature": "Hom f g -\u003e Hom f' g'",
          "source": "src/Data-Comp-Multi-Annotation.html#propAnn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Annotation",
          "module": "Data.Comp.Multi.Annotation",
          "name": "propAnn",
          "normalized": "Hom a b-\u003eHom c d",
          "package": "compdata",
          "partial": "Ann",
          "signature": "Hom f g-\u003eHom f' g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#v:propAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Annotation",
          "name": "remA",
          "package": "compdata",
          "signature": "s a :-\u003e s' a",
          "source": "src/Data-Comp-Multi-Ops.html#remA",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Annotation",
          "module": "Data.Comp.Multi.Annotation",
          "name": "remA",
          "normalized": "a b-\u003ec b",
          "package": "compdata",
          "signature": "s a-\u003es' a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#v:remA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function strips the annotations from a term over a\nfunctor with annotations. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Annotation",
          "name": "stripA",
          "package": "compdata",
          "signature": "CxtFun g f",
          "source": "src/Data-Comp-Multi-Annotation.html#stripA",
          "type": "function"
        },
        "index": {
          "description": "This function strips the annotations from term over functor with annotations",
          "hierarchy": "Data Comp Multi Annotation",
          "module": "Data.Comp.Multi.Annotation",
          "name": "stripA",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Annotation.html#v:stripA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains functionality for automatically deriving boilerplate\n code using Template Haskell. Examples include instances of \u003ccode\u003e\u003ca\u003eHFunctor\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eHFoldable\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eHTraversable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "Derive",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Derive.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains functionality for automatically deriving boilerplate code using Template Haskell Examples include instances of HFunctor HFoldable and HTraversable",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "Derive",
          "package": "compdata",
          "partial": "Derive",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature equality. An instance \u003ccode\u003eEqHF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eKEq (HTerm f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "EqHF",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Equality.html#EqHF",
          "type": "class"
        },
        "index": {
          "description": "Signature equality An instance EqHF gives rise to an instance KEq HTerm",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "EqHF",
          "package": "compdata",
          "partial": "Eq HF",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#t:EqHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHigher-order functors that can be folded.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003ehfoldMap\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ehfoldr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "HFoldable",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFoldable.html#HFoldable",
          "type": "class"
        },
        "index": {
          "description": "Higher-order functors that can be folded Minimal complete definition hfoldMap or hfoldr",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "HFoldable",
          "package": "compdata",
          "partial": "HFoldable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#t:HFoldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class represents higher-order functors (Johann, Ghani, POPL\n '08) which are endofunctors on the category of endofunctors.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "HFunctor",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#HFunctor",
          "type": "class"
        },
        "index": {
          "description": "This class represents higher-order functors Johann Ghani POPL which are endofunctors on the category of endofunctors",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "HFunctor",
          "package": "compdata",
          "partial": "HFunctor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#t:HFunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Derive",
          "name": "HTraversable",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HTraversable.html#HTraversable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "HTraversable",
          "package": "compdata",
          "partial": "HTraversable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#t:HTraversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Derive",
          "name": "KEq",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Equality.html#KEq",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "KEq",
          "package": "compdata",
          "partial": "KEq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#t:KEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Derive",
          "name": "KShow",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Derive-Show.html#KShow",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "KShow",
          "package": "compdata",
          "partial": "KShow",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#t:KShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature ordering. An instance \u003ccode\u003eOrdHF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eOrd (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "OrdHF",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ordering.html#OrdHF",
          "type": "class"
        },
        "index": {
          "description": "Signature ordering An instance OrdHF gives rise to an instance Ord Term",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "OrdHF",
          "package": "compdata",
          "partial": "Ord HF",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#t:OrdHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature printing. An instance \u003ccode\u003eShowHF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eKShow (HTerm f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "ShowHF",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Derive-Show.html#ShowHF",
          "type": "class"
        },
        "index": {
          "description": "Signature printing An instance ShowHF gives rise to an instance KShow HTerm",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "ShowHF",
          "package": "compdata",
          "partial": "Show HF",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#t:ShowHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Derive",
          "name": "compareHF",
          "package": "compdata",
          "signature": "f a i -\u003e f a j -\u003e Ordering",
          "source": "src/Data-Comp-Multi-Ordering.html#compareHF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "compareHF",
          "normalized": "a b c-\u003ea b d-\u003eOrdering",
          "package": "compdata",
          "partial": "HF",
          "signature": "f a i-\u003ef a j-\u003eOrdering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:compareHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Derive",
          "name": "eqHF",
          "package": "compdata",
          "signature": "f g i -\u003e f g j -\u003e Bool",
          "source": "src/Data-Comp-Multi-Equality.html#eqHF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "eqHF",
          "normalized": "a b c-\u003ea b d-\u003eBool",
          "package": "compdata",
          "partial": "HF",
          "signature": "f g i-\u003ef g j-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:eqHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Derive",
          "name": "keq",
          "package": "compdata",
          "signature": "f i -\u003e f j -\u003e Bool",
          "source": "src/Data-Comp-Multi-Equality.html#keq",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "keq",
          "normalized": "a b-\u003ea c-\u003eBool",
          "package": "compdata",
          "signature": "f i-\u003ef j-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:keq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Derive",
          "name": "kshow",
          "package": "compdata",
          "signature": "a i -\u003e K String i",
          "source": "src/Data-Comp-Multi-Derive-Show.html#kshow",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "kshow",
          "normalized": "a b-\u003eK String b",
          "package": "compdata",
          "signature": "a i-\u003eK String i",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:kshow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven the name of a type class, where the first parameter is a higher-order\n  functor, lift it to sums of higher-order. Example: \u003ccode\u003eclass HShowF f where ...\u003c/code\u003e\n  is lifted as \u003ccode\u003einstance (HShowF f, HShowF g) =\u003e HShowF (f :+: g) where ... \u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "liftSum",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Multi-Derive.html#liftSum",
          "type": "function"
        },
        "index": {
          "description": "Given the name of type class where the first parameter is higher-order functor lift it to sums of higher-order Example class HShowF where is lifted as instance HShowF HShowF HShowF where",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "liftSum",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Sum",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:liftSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eEqHF\u003c/a\u003e\u003c/code\u003e for a type constructor of any higher-order\n  kind taking at least two arguments. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "makeEqHF",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Multi-Derive-Equality.html#makeEqHF",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of EqHF for type constructor of any higher-order kind taking at least two arguments",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "makeEqHF",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Eq HF",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:makeEqHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eHFoldable\u003c/a\u003e\u003c/code\u003e for a type constructor of any higher-order\n  kind taking at least two arguments. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "makeHFoldable",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Multi-Derive-HFoldable.html#makeHFoldable",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of HFoldable for type constructor of any higher-order kind taking at least two arguments",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "makeHFoldable",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "HFoldable",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:makeHFoldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eHFunctor\u003c/a\u003e\u003c/code\u003e for a type constructor of any higher-order\n  kind taking at least two arguments. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "makeHFunctor",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Multi-Derive-HFunctor.html#makeHFunctor",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of HFunctor for type constructor of any higher-order kind taking at least two arguments",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "makeHFunctor",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "HFunctor",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:makeHFunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eHTraversable\u003c/a\u003e\u003c/code\u003e for a type constructor of any\n  higher-order kind taking at least two arguments. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "makeHTraversable",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Multi-Derive-HTraversable.html#makeHTraversable",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of HTraversable for type constructor of any higher-order kind taking at least two arguments",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "makeHTraversable",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "HTraversable",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:makeHTraversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eOrdHF\u003c/a\u003e\u003c/code\u003e for a type constructor of any parametric\n  kind taking at least three arguments. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "makeOrdHF",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Multi-Derive-Ordering.html#makeOrdHF",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of OrdHF for type constructor of any parametric kind taking at least three arguments",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "makeOrdHF",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Ord HF",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:makeOrdHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eShowHF\u003c/a\u003e\u003c/code\u003e for a type constructor of any higher-order\n  kind taking at least two arguments. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "makeShowHF",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Multi-Derive-Show.html#makeShowHF",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of ShowHF for type constructor of any higher-order kind taking at least two arguments",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "makeShowHF",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Show HF",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:makeShowHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Derive",
          "name": "showHF",
          "package": "compdata",
          "signature": "Alg f (K String)",
          "source": "src/Data-Comp-Multi-Derive-Show.html#showHF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "showHF",
          "package": "compdata",
          "partial": "HF",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:showHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Derive",
          "name": "showHF'",
          "package": "compdata",
          "signature": "String",
          "source": "src/Data-Comp-Multi-Derive-Show.html#showHF%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "showHF'",
          "package": "compdata",
          "partial": "HF'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:showHF-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive smart constructors with products for a type constructor of any\n  parametric kind taking at least two arguments. The smart constructors are\n  similar to the ordinary constructors, but an \u003ccode\u003e\u003ca\u003einjectA\u003c/a\u003e\u003c/code\u003e is automatically\n  inserted. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "smartAConstructors",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Multi-Derive-SmartAConstructors.html#smartAConstructors",
          "type": "function"
        },
        "index": {
          "description": "Derive smart constructors with products for type constructor of any parametric kind taking at least two arguments The smart constructors are similar to the ordinary constructors but an injectA is automatically inserted",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "smartAConstructors",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "AConstructors",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:smartAConstructors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive smart constructors for a type constructor of any higher-order kind\n taking at least two arguments. The smart constructors are similar to the\n ordinary constructors, but an \u003ccode\u003e\u003ca\u003einject\u003c/a\u003e\u003c/code\u003e is automatically inserted. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Derive",
          "name": "smartConstructors",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Multi-Derive-SmartConstructors.html#smartConstructors",
          "type": "function"
        },
        "index": {
          "description": "Derive smart constructors for type constructor of any higher-order kind taking at least two arguments The smart constructors are similar to the ordinary constructors but an inject is automatically inserted",
          "hierarchy": "Data Comp Multi Derive",
          "module": "Data.Comp.Multi.Derive",
          "name": "smartConstructors",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Constructors",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Derive.html#v:smartConstructors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis modules defines the \u003ccode\u003e\u003ca\u003eDesugar\u003c/a\u003e\u003c/code\u003e type class for desugaring of terms.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Desugar.html",
          "type": "module"
        },
        "index": {
          "description": "This modules defines the Desugar type class for desugaring of terms",
          "hierarchy": "Data Comp Multi Desugar",
          "module": "Data.Comp.Multi.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "partial": "Desugar",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Desugar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe desugaring term homomorphism.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Desugar.html#Desugar",
          "type": "class"
        },
        "index": {
          "description": "The desugaring term homomorphism",
          "hierarchy": "Data Comp Multi Desugar",
          "module": "Data.Comp.Multi.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "partial": "Desugar",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Desugar.html#t:Desugar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Desugar",
          "name": "desugHom",
          "package": "compdata",
          "signature": "Hom f g",
          "source": "src/Data-Comp-Multi-Desugar.html#desugHom",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Desugar",
          "module": "Data.Comp.Multi.Desugar",
          "name": "desugHom",
          "package": "compdata",
          "partial": "Hom",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Desugar.html#v:desugHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Desugar",
          "name": "desugHom'",
          "package": "compdata",
          "signature": "Alg f (Context g a)",
          "source": "src/Data-Comp-Multi-Desugar.html#desugHom%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Desugar",
          "module": "Data.Comp.Multi.Desugar",
          "name": "desugHom'",
          "package": "compdata",
          "partial": "Hom'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Desugar.html#v:desugHom-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDesugar a term.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Desugar",
          "name": "desugar",
          "package": "compdata",
          "signature": "Term f :-\u003e Term g",
          "source": "src/Data-Comp-Multi-Desugar.html#desugar",
          "type": "function"
        },
        "index": {
          "description": "Desugar term",
          "hierarchy": "Data Comp Multi Desugar",
          "module": "Data.Comp.Multi.Desugar",
          "name": "desugar",
          "normalized": "Term a-\u003eTerm b",
          "package": "compdata",
          "signature": "Term f-\u003eTerm g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Desugar.html#v:desugar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift desugaring to annotated terms.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Desugar",
          "name": "desugarA",
          "package": "compdata",
          "signature": "Term f' :-\u003e Term g'",
          "source": "src/Data-Comp-Multi-Desugar.html#desugarA",
          "type": "function"
        },
        "index": {
          "description": "Lift desugaring to annotated terms",
          "hierarchy": "Data Comp Multi Desugar",
          "module": "Data.Comp.Multi.Desugar",
          "name": "desugarA",
          "normalized": "Term a-\u003eTerm b",
          "package": "compdata",
          "signature": "Term f'-\u003eTerm g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Desugar.html#v:desugarA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines equality for (higher-order) signatures, which lifts to\n equality for (higher-order) terms and contexts. All definitions are\n generalised versions of those in \u003ca\u003eData.Comp.Equality\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.Equality",
          "name": "Equality",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Equality.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines equality for higher-order signatures which lifts to equality for higher-order terms and contexts All definitions are generalised versions of those in Data.Comp.Equality",
          "hierarchy": "Data Comp Multi Equality",
          "module": "Data.Comp.Multi.Equality",
          "name": "Equality",
          "package": "compdata",
          "partial": "Equality",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Equality.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature equality. An instance \u003ccode\u003eEqHF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eKEq (HTerm f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Equality",
          "name": "EqHF",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Equality.html#EqHF",
          "type": "class"
        },
        "index": {
          "description": "Signature equality An instance EqHF gives rise to an instance KEq HTerm",
          "hierarchy": "Data Comp Multi Equality",
          "module": "Data.Comp.Multi.Equality",
          "name": "EqHF",
          "package": "compdata",
          "partial": "Eq HF",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Equality.html#t:EqHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Equality",
          "name": "KEq",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Equality.html#KEq",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp Multi Equality",
          "module": "Data.Comp.Multi.Equality",
          "name": "KEq",
          "package": "compdata",
          "partial": "KEq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Equality.html#t:KEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Equality",
          "name": "eqHF",
          "package": "compdata",
          "signature": "f g i -\u003e f g j -\u003e Bool",
          "source": "src/Data-Comp-Multi-Equality.html#eqHF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Equality",
          "module": "Data.Comp.Multi.Equality",
          "name": "eqHF",
          "normalized": "a b c-\u003ea b d-\u003eBool",
          "package": "compdata",
          "partial": "HF",
          "signature": "f g i-\u003ef g j-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Equality.html#v:eqHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function implements equality of values of type \u003ccode\u003ef a\u003c/code\u003e modulo\nthe equality of \u003ccode\u003ea\u003c/code\u003e itself. If two functorial values are equal in this\nsense, \u003ccode\u003eeqMod\u003c/code\u003e returns a \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e value containing a list of pairs\nconsisting of corresponding components of the two functorial\nvalues. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Equality",
          "name": "heqMod",
          "package": "compdata",
          "signature": "f a i -\u003e f b i -\u003e Maybe [(E a, E b)]",
          "source": "src/Data-Comp-Multi-Equality.html#heqMod",
          "type": "function"
        },
        "index": {
          "description": "This function implements equality of values of type modulo the equality of itself If two functorial values are equal in this sense eqMod returns Just value containing list of pairs consisting of corresponding components of the two functorial values",
          "hierarchy": "Data Comp Multi Equality",
          "module": "Data.Comp.Multi.Equality",
          "name": "heqMod",
          "normalized": "a b c-\u003ea d c-\u003eMaybe[(E b,E d)]",
          "package": "compdata",
          "partial": "Mod",
          "signature": "f a i-\u003ef b i-\u003eMaybe[(E a,E b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Equality.html#v:heqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Equality",
          "name": "keq",
          "package": "compdata",
          "signature": "f i -\u003e f j -\u003e Bool",
          "source": "src/Data-Comp-Multi-Equality.html#keq",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Equality",
          "module": "Data.Comp.Multi.Equality",
          "name": "keq",
          "normalized": "a b-\u003ea c-\u003eBool",
          "package": "compdata",
          "signature": "f i-\u003ef j-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Equality.html#v:keq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines type generic functions and recursive schemes\n along the lines of the Uniplate library. All definitions are\n generalised versions of those in \u003ca\u003eData.Comp.Generic\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.Generic",
          "name": "Generic",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Generic.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines type generic functions and recursive schemes along the lines of the Uniplate library All definitions are generalised versions of those in Data.Comp.Generic",
          "hierarchy": "Data Comp Multi Generic",
          "module": "Data.Comp.Multi.Generic",
          "name": "Generic",
          "package": "compdata",
          "partial": "Generic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Generic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function computes the generic depth of the given term.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Generic",
          "name": "depth",
          "package": "compdata",
          "signature": "Int",
          "source": "src/Data-Comp-Multi-Generic.html#depth",
          "type": "function"
        },
        "index": {
          "description": "This function computes the generic depth of the given term",
          "hierarchy": "Data Comp Multi Generic",
          "module": "Data.Comp.Multi.Generic",
          "name": "depth",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Generic.html#v:depth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Generic",
          "name": "query",
          "package": "compdata",
          "signature": "r",
          "source": "src/Data-Comp-Multi-Generic.html#query",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Generic",
          "module": "Data.Comp.Multi.Generic",
          "name": "query",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Generic.html#v:query"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function computes the generic size of the given term,\n i.e. the its number of subterm occurrences.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Generic",
          "name": "size",
          "package": "compdata",
          "signature": "Int",
          "source": "src/Data-Comp-Multi-Generic.html#size",
          "type": "function"
        },
        "index": {
          "description": "This function computes the generic size of the given term i.e the its number of subterm occurrences",
          "hierarchy": "Data Comp Multi Generic",
          "module": "Data.Comp.Multi.Generic",
          "name": "size",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Generic.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Generic",
          "name": "subs",
          "package": "compdata",
          "signature": "[E (Term f)]",
          "source": "src/Data-Comp-Multi-Generic.html#subs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Generic",
          "module": "Data.Comp.Multi.Generic",
          "name": "subs",
          "normalized": "[E(Term a)]",
          "package": "compdata",
          "signature": "[E(Term f)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Generic.html#v:subs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Generic",
          "name": "subs'",
          "package": "compdata",
          "signature": "[E (g (Term f))]",
          "source": "src/Data-Comp-Multi-Generic.html#subs%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Generic",
          "module": "Data.Comp.Multi.Generic",
          "name": "subs'",
          "normalized": "[E(a(Term b))]",
          "package": "compdata",
          "signature": "[E(g(Term f))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Generic.html#v:subs-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function returns a list of all subterms of the given\n term. This function is similar to Uniplate's \u003ccode\u003euniverse\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Generic",
          "name": "subterms",
          "package": "compdata",
          "signature": "[E (Term f)]",
          "source": "src/Data-Comp-Multi-Generic.html#subterms",
          "type": "function"
        },
        "index": {
          "description": "This function returns list of all subterms of the given term This function is similar to Uniplate universe function",
          "hierarchy": "Data Comp Multi Generic",
          "module": "Data.Comp.Multi.Generic",
          "name": "subterms",
          "normalized": "[E(Term a)]",
          "package": "compdata",
          "signature": "[E(Term f)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Generic.html#v:subterms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function returns a list of all subterms of the given term\n that are constructed from a particular functor.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Generic",
          "name": "subterms'",
          "package": "compdata",
          "signature": "[E (g (Term f))]",
          "source": "src/Data-Comp-Multi-Generic.html#subterms%27",
          "type": "function"
        },
        "index": {
          "description": "This function returns list of all subterms of the given term that are constructed from particular functor",
          "hierarchy": "Data Comp Multi Generic",
          "module": "Data.Comp.Multi.Generic",
          "name": "subterms'",
          "normalized": "[E(a(Term b))]",
          "package": "compdata",
          "signature": "[E(g(Term f))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Generic.html#v:subterms-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function transforms every subterm according to the given\n function in a bottom-up manner. This function is similar to\n Uniplate's \u003ccode\u003etransform\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Generic",
          "name": "transform",
          "package": "compdata",
          "signature": "(Term f :-\u003e Term f) -\u003e Term f :-\u003e Term f",
          "source": "src/Data-Comp-Multi-Generic.html#transform",
          "type": "function"
        },
        "index": {
          "description": "This function transforms every subterm according to the given function in bottom-up manner This function is similar to Uniplate transform function",
          "hierarchy": "Data Comp Multi Generic",
          "module": "Data.Comp.Multi.Generic",
          "name": "transform",
          "normalized": "(Term a-\u003eTerm a)-\u003eTerm a-\u003eTerm a",
          "package": "compdata",
          "signature": "(Term f-\u003eTerm f)-\u003eTerm f-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Generic.html#v:transform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic version of \u003ccode\u003e\u003ca\u003etransform\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Generic",
          "name": "transformM",
          "package": "compdata",
          "signature": "NatM m (Term f) (Term f) -\u003e NatM m (Term f) (Term f)",
          "source": "src/Data-Comp-Multi-Generic.html#transformM",
          "type": "function"
        },
        "index": {
          "description": "Monadic version of transform",
          "hierarchy": "Data Comp Multi Generic",
          "module": "Data.Comp.Multi.Generic",
          "name": "transformM",
          "normalized": "NatM a(Term b)(Term b)-\u003eNatM a(Term b)(Term b)",
          "package": "compdata",
          "signature": "NatM m(Term f)(Term f)-\u003eNatM m(Term f)(Term f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Generic.html#v:transformM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines higher-order foldable functors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.HFoldable",
          "name": "HFoldable",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFoldable.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines higher-order foldable functors",
          "hierarchy": "Data Comp Multi HFoldable",
          "module": "Data.Comp.Multi.HFoldable",
          "name": "HFoldable",
          "package": "compdata",
          "partial": "HFoldable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFoldable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHigher-order functors that can be folded.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003ehfoldMap\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ehfoldr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.HFoldable",
          "name": "HFoldable",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFoldable.html#HFoldable",
          "type": "class"
        },
        "index": {
          "description": "Higher-order functors that can be folded Minimal complete definition hfoldMap or hfoldr",
          "hierarchy": "Data Comp Multi HFoldable",
          "module": "Data.Comp.Multi.HFoldable",
          "name": "HFoldable",
          "package": "compdata",
          "partial": "HFoldable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFoldable.html#t:HFoldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HFoldable",
          "name": "hfold",
          "package": "compdata",
          "signature": "m",
          "source": "src/Data-Comp-Multi-HFoldable.html#hfold",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFoldable",
          "module": "Data.Comp.Multi.HFoldable",
          "name": "hfold",
          "package": "compdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFoldable.html#v:hfold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HFoldable",
          "name": "hfoldMap",
          "package": "compdata",
          "signature": "m",
          "source": "src/Data-Comp-Multi-HFoldable.html#hfoldMap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFoldable",
          "module": "Data.Comp.Multi.HFoldable",
          "name": "hfoldMap",
          "package": "compdata",
          "partial": "Map",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFoldable.html#v:hfoldMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HFoldable",
          "name": "hfoldl",
          "package": "compdata",
          "signature": "b",
          "source": "src/Data-Comp-Multi-HFoldable.html#hfoldl",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFoldable",
          "module": "Data.Comp.Multi.HFoldable",
          "name": "hfoldl",
          "package": "compdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFoldable.html#v:hfoldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HFoldable",
          "name": "hfoldl1",
          "package": "compdata",
          "signature": "a",
          "source": "src/Data-Comp-Multi-HFoldable.html#hfoldl1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFoldable",
          "module": "Data.Comp.Multi.HFoldable",
          "name": "hfoldl1",
          "package": "compdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFoldable.html#v:hfoldl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HFoldable",
          "name": "hfoldr",
          "package": "compdata",
          "signature": "b",
          "source": "src/Data-Comp-Multi-HFoldable.html#hfoldr",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFoldable",
          "module": "Data.Comp.Multi.HFoldable",
          "name": "hfoldr",
          "package": "compdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFoldable.html#v:hfoldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HFoldable",
          "name": "hfoldr1",
          "package": "compdata",
          "signature": "a",
          "source": "src/Data-Comp-Multi-HFoldable.html#hfoldr1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFoldable",
          "module": "Data.Comp.Multi.HFoldable",
          "name": "hfoldr1",
          "package": "compdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFoldable.html#v:hfoldr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HFoldable",
          "name": "htoList",
          "package": "compdata",
          "signature": "[E a]",
          "source": "src/Data-Comp-Multi-HFoldable.html#htoList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFoldable",
          "module": "Data.Comp.Multi.HFoldable",
          "name": "htoList",
          "normalized": "[E a]",
          "package": "compdata",
          "partial": "List",
          "signature": "[E a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFoldable.html#v:htoList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HFoldable",
          "name": "kfoldl",
          "package": "compdata",
          "signature": "b",
          "source": "src/Data-Comp-Multi-HFoldable.html#kfoldl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFoldable",
          "module": "Data.Comp.Multi.HFoldable",
          "name": "kfoldl",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFoldable.html#v:kfoldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HFoldable",
          "name": "kfoldr",
          "package": "compdata",
          "signature": "b",
          "source": "src/Data-Comp-Multi-HFoldable.html#kfoldr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFoldable",
          "module": "Data.Comp.Multi.HFoldable",
          "name": "kfoldr",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFoldable.html#v:kfoldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines higher-order functors (Johann, Ghani, POPL\n '08), i.e. endofunctors on the category of endofunctors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "HFunctor",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines higher-order functors Johann Ghani POPL i.e endofunctors on the category of endofunctors",
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "HFunctor",
          "package": "compdata",
          "partial": "HFunctor",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents natural transformations.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.HFunctor",
          "name": ":-\u003e",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#%3A-%3E",
          "type": "type"
        },
        "index": {
          "description": "This type represents natural transformations",
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": ":-\u003e",
          "package": "compdata",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#t::-45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents co-cones from \u003ccode\u003ef\u003c/code\u003e to \u003ccode\u003ea\u003c/code\u003e. \u003ccode\u003ef :=\u003e a\u003c/code\u003e is\n isomorphic to f :-\u003e K a\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.HFunctor",
          "name": ":=\u003e",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#%3A%3D%3E",
          "type": "type"
        },
        "index": {
          "description": "This type represents co-cones from to is isomorphic to",
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": ":=\u003e",
          "package": "compdata",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#t::-61--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type denotes the composition of two functor families.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.HFunctor",
          "name": ":.:",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#%3A.%3A",
          "type": "data"
        },
        "index": {
          "description": "This data type denotes the composition of two functor families",
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": ":.:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#t::.:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HFunctor",
          "name": "A",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#A",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "A",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#t:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HFunctor",
          "name": "E",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#E",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "E",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#t:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class represents higher-order functors (Johann, Ghani, POPL\n '08) which are endofunctors on the category of endofunctors.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "HFunctor",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#HFunctor",
          "type": "class"
        },
        "index": {
          "description": "This class represents higher-order functors Johann Ghani POPL which are endofunctors on the category of endofunctors",
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "HFunctor",
          "package": "compdata",
          "partial": "HFunctor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#t:HFunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity Functor.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "I",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#I",
          "type": "newtype"
        },
        "index": {
          "description": "The identity Functor",
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "I",
          "package": "compdata",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#t:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe parametrised constant functor.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "K",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#K",
          "type": "newtype"
        },
        "index": {
          "description": "The parametrised constant functor",
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "K",
          "package": "compdata",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#t:K"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HFunctor",
          "name": "NatM",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#NatM",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "NatM",
          "package": "compdata",
          "partial": "Nat",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#t:NatM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.Multi.HFunctor\",\"Data.Comp.MultiParam.HDifunctor\"]",
          "name": "A",
          "package": "compdata",
          "signature": "A",
          "source": "src/Data-Comp-Multi-HFunctor.html#A",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:A\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#v:A\"]"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "A",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HFunctor",
          "name": "Comp",
          "package": "compdata",
          "signature": "Comp f (g e) t",
          "source": "src/Data-Comp-Multi-HFunctor.html#%3A.%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "Comp",
          "package": "compdata",
          "partial": "Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:Comp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.Multi.HFunctor\",\"Data.Comp.MultiParam.HDifunctor\"]",
          "name": "E",
          "package": "compdata",
          "signature": "forall i . E",
          "source": "src/Data-Comp-Multi-HFunctor.html#E",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:E\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#v:E\"]"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "E",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.Multi.HFunctor\",\"Data.Comp.MultiParam.HDifunctor\"]",
          "name": "K",
          "package": "compdata",
          "signature": "K",
          "source": "src/Data-Comp-Multi-HFunctor.html#K",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:K\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#v:K\"]"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "K",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:K"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA higher-order functor \u003ccode\u003ef\u003c/code\u003e also maps a natural transformation\n \u003ccode\u003eg :-\u003e h\u003c/code\u003e to a natural transformation \u003ccode\u003ef g :-\u003e f h\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "hfmap",
          "package": "compdata",
          "signature": "(f :-\u003e g) -\u003e h f :-\u003e h g",
          "source": "src/Data-Comp-Multi-HFunctor.html#hfmap",
          "type": "method"
        },
        "index": {
          "description": "higher-order functor also maps natural transformation to natural transformation",
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "hfmap",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "compdata",
          "signature": "(f-\u003eg)-\u003eh f-\u003eh g",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:hfmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HFunctor",
          "name": "runE",
          "package": "compdata",
          "signature": "b) -\u003e E f -\u003e b",
          "source": "src/Data-Comp-Multi-HFunctor.html#runE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "runE",
          "normalized": "a)-\u003eE b-\u003ea",
          "package": "compdata",
          "signature": "b)-\u003eE f-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:runE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.Multi.HFunctor\",\"Data.Comp.MultiParam.HDifunctor\"]",
          "name": "unA",
          "package": "compdata",
          "signature": "forall i.  f i",
          "source": "src/Data-Comp-Multi-HFunctor.html#A",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:unA\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#v:unA\"]"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "unA",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:unA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.Multi.HFunctor\",\"Data.Comp.MultiParam.HDifunctor\"]",
          "name": "unE",
          "package": "compdata",
          "signature": "f i",
          "source": "src/Data-Comp-Multi-HFunctor.html#E",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:unE\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#v:unE\"]"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "unE",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:unE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.Multi.HFunctor\",\"Data.Comp.MultiParam.HDifunctor\"]",
          "name": "unK",
          "package": "compdata",
          "signature": "a",
          "source": "src/Data-Comp-Multi-HFunctor.html#K",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:unK\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#v:unK\"]"
        },
        "index": {
          "hierarchy": "Data Comp Multi HFunctor",
          "module": "Data.Comp.Multi.HFunctor",
          "name": "unK",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HFunctor.html#v:unK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines higher-order traversable functors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.HTraversable",
          "name": "HTraversable",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HTraversable.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines higher-order traversable functors",
          "hierarchy": "Data Comp Multi HTraversable",
          "module": "Data.Comp.Multi.HTraversable",
          "name": "HTraversable",
          "package": "compdata",
          "partial": "HTraversable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HTraversable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HTraversable",
          "name": "HTraversable",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HTraversable.html#HTraversable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp Multi HTraversable",
          "module": "Data.Comp.Multi.HTraversable",
          "name": "HTraversable",
          "package": "compdata",
          "partial": "HTraversable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HTraversable.html#t:HTraversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure to a monadic action, evaluate\n these actions from left to right, and collect the results.\n\u003c/p\u003e\u003cp\u003eAlternative type in terms of natural transformations using\n functor composition \u003ccode\u003e:.:\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003ehmapM :: Monad m =\u003e (a :-\u003e m :.: b) -\u003e t a :-\u003e m :.: (t b)\u003c/pre\u003e",
          "module": "Data.Comp.Multi.HTraversable",
          "name": "hmapM",
          "package": "compdata",
          "signature": "NatM m a b -\u003e NatM m (t a) (t b)",
          "source": "src/Data-Comp-Multi-HTraversable.html#hmapM",
          "type": "method"
        },
        "index": {
          "description": "Map each element of structure to monadic action evaluate these actions from left to right and collect the results Alternative type in terms of natural transformations using functor composition hmapM Monad",
          "hierarchy": "Data Comp Multi HTraversable",
          "module": "Data.Comp.Multi.HTraversable",
          "name": "hmapM",
          "normalized": "NatM a b c-\u003eNatM a(d b)(d c)",
          "package": "compdata",
          "signature": "NatM m a b-\u003eNatM m(t a)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HTraversable.html#v:hmapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.HTraversable",
          "name": "htraverse",
          "package": "compdata",
          "signature": "NatM f a b -\u003e NatM f (t a) (t b)",
          "source": "src/Data-Comp-Multi-HTraversable.html#htraverse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi HTraversable",
          "module": "Data.Comp.Multi.HTraversable",
          "name": "htraverse",
          "normalized": "NatM a b c-\u003eNatM a(d b)(d c)",
          "package": "compdata",
          "signature": "NatM f a b-\u003eNatM f(t a)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-HTraversable.html#v:htraverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides functionality to number the components of a\n functorial value with consecutive integers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.Number",
          "name": "Number",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Number.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides functionality to number the components of functorial value with consecutive integers",
          "hierarchy": "Data Comp Multi Number",
          "module": "Data.Comp.Multi.Number",
          "name": "Number",
          "package": "compdata",
          "partial": "Number",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Number.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Number",
          "name": "HTraversable",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HTraversable.html#HTraversable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp Multi Number",
          "module": "Data.Comp.Multi.Number",
          "name": "HTraversable",
          "package": "compdata",
          "partial": "HTraversable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Number.html#t:HTraversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type is used for numbering components of a functorial value.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Number",
          "name": "Numbered",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Number.html#Numbered",
          "type": "newtype"
        },
        "index": {
          "description": "This type is used for numbering components of functorial value",
          "hierarchy": "Data Comp Multi Number",
          "module": "Data.Comp.Multi.Number",
          "name": "Numbered",
          "package": "compdata",
          "partial": "Numbered",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Number.html#t:Numbered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Number",
          "name": "Numbered",
          "package": "compdata",
          "signature": "Numbered (Int, a i)",
          "source": "src/Data-Comp-Multi-Number.html#Numbered",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Number",
          "module": "Data.Comp.Multi.Number",
          "name": "Numbered",
          "normalized": "Numbered(Int,a b)",
          "package": "compdata",
          "partial": "Numbered",
          "signature": "Numbered(Int,a i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Number.html#v:Numbered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function numbers the components of the given functorial\n value with consecutive integers starting at 0.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Number",
          "name": "number",
          "package": "compdata",
          "signature": "f a :-\u003e f (Numbered a)",
          "source": "src/Data-Comp-Multi-Number.html#number",
          "type": "function"
        },
        "index": {
          "description": "This function numbers the components of the given functorial value with consecutive integers starting at",
          "hierarchy": "Data Comp Multi Number",
          "module": "Data.Comp.Multi.Number",
          "name": "number",
          "normalized": "a b-\u003ea(Numbered b)",
          "package": "compdata",
          "signature": "f a-\u003ef(Numbered a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Number.html#v:number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Number",
          "name": "unNumbered",
          "package": "compdata",
          "signature": "Numbered a :-\u003e a",
          "source": "src/Data-Comp-Multi-Number.html#unNumbered",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Number",
          "module": "Data.Comp.Multi.Number",
          "name": "unNumbered",
          "normalized": "Numbered a-\u003ea",
          "package": "compdata",
          "partial": "Numbered",
          "signature": "Numbered a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Number.html#v:unNumbered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides operators on higher-order functors. All definitions are\n generalised versions of those in \u003ca\u003eData.Comp.Ops\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.Ops",
          "name": "Ops",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ops.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides operators on higher-order functors All definitions are generalised versions of those in Data.Comp.Ops",
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": "Ops",
          "package": "compdata",
          "partial": "Ops",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type adds a constant product to a\n signature. Alternatively, this could have also been defined as\n\u003c/p\u003e\u003cpre\u003edata (f :&: a) (g ::  * -\u003e *) e = f g e :&: a e\u003c/pre\u003e\u003cp\u003eThis is too general, however, for example for \u003ccode\u003eproductHHom\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Ops",
          "name": ":&:",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ops.html#%3A%26%3A",
          "type": "data"
        },
        "index": {
          "description": "This data type adds constant product to signature Alternatively this could have also been defined as data This is too general however for example for productHHom",
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": ":&:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#t::-38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Ops",
          "name": ":*:",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ops.html#%3A%2A%3A",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": ":*:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#t::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData type defining coproducts.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Ops",
          "name": ":+:",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ops.html#%3A%2B%3A",
          "type": "data"
        },
        "index": {
          "description": "Data type defining coproducts",
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": ":+:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#t::-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe subsumption relation.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Ops",
          "name": ":\u003c:",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ops.html#%3A%3C%3A",
          "type": "class"
        },
        "index": {
          "description": "The subsumption relation",
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": ":\u003c:",
          "package": "compdata",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#t::-60-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class defines how to distribute an annotation over a sum of\n signatures.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Ops",
          "name": "DistAnn",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ops.html#DistAnn",
          "type": "class"
        },
        "index": {
          "description": "This class defines how to distribute an annotation over sum of signatures",
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": "DistAnn",
          "package": "compdata",
          "partial": "Dist Ann",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#t:DistAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Ops",
          "name": "RemA",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ops.html#RemA",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": "RemA",
          "package": "compdata",
          "partial": "Rem",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#t:RemA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Ops",
          "name": ":*:",
          "package": "compdata",
          "signature": "(f a) :*: (g a)",
          "source": "src/Data-Comp-Multi-Ops.html#%3A%2A%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": ":*:",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#v::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Ops",
          "name": "Inl",
          "package": "compdata",
          "signature": "Inl (f h e)",
          "source": "src/Data-Comp-Multi-Ops.html#%3A%2B%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": "Inl",
          "package": "compdata",
          "partial": "Inl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#v:Inl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Ops",
          "name": "Inr",
          "package": "compdata",
          "signature": "Inr (g h e)",
          "source": "src/Data-Comp-Multi-Ops.html#%3A%2B%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": "Inr",
          "package": "compdata",
          "partial": "Inr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#v:Inr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUtility function to case on a higher-order functor sum, without exposing the\n  internal representation of sums. \n\u003c/p\u003e",
          "module": "[\"Data.Comp.Multi.Ops\",\"Data.Comp.Multi.Sum\"]",
          "name": "caseH",
          "package": "compdata",
          "signature": "(f a b -\u003e c) -\u003e (g a b -\u003e c) -\u003e (f :+: g) a b -\u003e c",
          "source": "src/Data-Comp-Multi-Ops.html#caseH",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#v:caseH\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:caseH\"]"
        },
        "index": {
          "description": "Utility function to case on higher-order functor sum without exposing the internal representation of sums",
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": "caseH",
          "normalized": "(a b c-\u003ed)-\u003e(e b c-\u003ed)-\u003e(a e)b c-\u003ed",
          "package": "compdata",
          "signature": "(f a b-\u003ec)-\u003e(g a b-\u003ec)-\u003e(f g)a b-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#v:caseH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Ops",
          "name": "fst",
          "package": "compdata",
          "signature": "(f :*: g) a -\u003e f a",
          "source": "src/Data-Comp-Multi-Ops.html#fst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": "fst",
          "normalized": "(a*b)c-\u003ea c",
          "package": "compdata",
          "signature": "(f*g)a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#v:fst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Ops",
          "name": "inj",
          "package": "compdata",
          "signature": "sub a :-\u003e sup a",
          "source": "src/Data-Comp-Multi-Ops.html#inj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": "inj",
          "normalized": "a b-\u003ec b",
          "package": "compdata",
          "signature": "sub a-\u003esup a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#v:inj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function injects an annotation over a signature.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Ops",
          "name": "injectA",
          "package": "compdata",
          "signature": "p -\u003e s a :-\u003e s' a",
          "source": "src/Data-Comp-Multi-Ops.html#injectA",
          "type": "method"
        },
        "index": {
          "description": "This function injects an annotation over signature",
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": "injectA",
          "normalized": "a-\u003eb c-\u003ed c",
          "package": "compdata",
          "signature": "p-\u003es a-\u003es' a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#v:injectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Ops",
          "name": "proj",
          "package": "compdata",
          "signature": "NatM Maybe (sup a) (sub a)",
          "source": "src/Data-Comp-Multi-Ops.html#proj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": "proj",
          "package": "compdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#v:proj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Ops",
          "name": "projectA",
          "package": "compdata",
          "signature": "s' a :-\u003e (s a :&: p)",
          "source": "src/Data-Comp-Multi-Ops.html#projectA",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": "projectA",
          "normalized": "a b-\u003e(c b d)",
          "package": "compdata",
          "signature": "s' a-\u003e(s a p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#v:projectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Ops",
          "name": "remA",
          "package": "compdata",
          "signature": "s a :-\u003e s' a",
          "source": "src/Data-Comp-Multi-Ops.html#remA",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": "remA",
          "normalized": "a b-\u003ec b",
          "package": "compdata",
          "signature": "s a-\u003es' a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#v:remA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Ops",
          "name": "snd",
          "package": "compdata",
          "signature": "(f :*: g) a -\u003e g a",
          "source": "src/Data-Comp-Multi-Ops.html#snd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Ops",
          "module": "Data.Comp.Multi.Ops",
          "name": "snd",
          "normalized": "(a*b)c-\u003eb c",
          "package": "compdata",
          "signature": "(f*g)a-\u003eg a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ops.html#v:snd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines ordering of signatures, which lifts to ordering of\n terms and contexts.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.Ordering",
          "name": "Ordering",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ordering.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines ordering of signatures which lifts to ordering of terms and contexts",
          "hierarchy": "Data Comp Multi Ordering",
          "module": "Data.Comp.Multi.Ordering",
          "name": "Ordering",
          "package": "compdata",
          "partial": "Ordering",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ordering.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Ordering",
          "name": "KOrd",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ordering.html#KOrd",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp Multi Ordering",
          "module": "Data.Comp.Multi.Ordering",
          "name": "KOrd",
          "package": "compdata",
          "partial": "KOrd",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ordering.html#t:KOrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature ordering. An instance \u003ccode\u003eOrdHF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eOrd (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Ordering",
          "name": "OrdHF",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ordering.html#OrdHF",
          "type": "class"
        },
        "index": {
          "description": "Signature ordering An instance OrdHF gives rise to an instance Ord Term",
          "hierarchy": "Data Comp Multi Ordering",
          "module": "Data.Comp.Multi.Ordering",
          "name": "OrdHF",
          "package": "compdata",
          "partial": "Ord HF",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ordering.html#t:OrdHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Ordering",
          "name": "compareHF",
          "package": "compdata",
          "signature": "f a i -\u003e f a j -\u003e Ordering",
          "source": "src/Data-Comp-Multi-Ordering.html#compareHF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Ordering",
          "module": "Data.Comp.Multi.Ordering",
          "name": "compareHF",
          "normalized": "a b c-\u003ea b d-\u003eOrdering",
          "package": "compdata",
          "partial": "HF",
          "signature": "f a i-\u003ef a j-\u003eOrdering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ordering.html#v:compareHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Ordering",
          "name": "kcompare",
          "package": "compdata",
          "signature": "f i -\u003e f j -\u003e Ordering",
          "source": "src/Data-Comp-Multi-Ordering.html#kcompare",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Ordering",
          "module": "Data.Comp.Multi.Ordering",
          "name": "kcompare",
          "normalized": "a b-\u003ea c-\u003eOrdering",
          "package": "compdata",
          "signature": "f i-\u003ef j-\u003eOrdering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Ordering.html#v:kcompare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines showing of (higher-order) signatures, which lifts to\n showing of (higher-order) terms and contexts. All definitions are\n generalised versions of those in \u003ca\u003eData.Comp.Show\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.Show",
          "name": "Show",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Show.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines showing of higher-order signatures which lifts to showing of higher-order terms and contexts All definitions are generalised versions of those in Data.Comp.Show",
          "hierarchy": "Data Comp Multi Show",
          "module": "Data.Comp.Multi.Show",
          "name": "Show",
          "package": "compdata",
          "partial": "Show",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Show.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature printing. An instance \u003ccode\u003eShowHF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eKShow (HTerm f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Show",
          "name": "ShowHF",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Derive-Show.html#ShowHF",
          "type": "class"
        },
        "index": {
          "description": "Signature printing An instance ShowHF gives rise to an instance KShow HTerm",
          "hierarchy": "Data Comp Multi Show",
          "module": "Data.Comp.Multi.Show",
          "name": "ShowHF",
          "package": "compdata",
          "partial": "Show HF",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Show.html#t:ShowHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Show",
          "name": "showHF",
          "package": "compdata",
          "signature": "Alg f (K String)",
          "source": "src/Data-Comp-Multi-Derive-Show.html#showHF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Show",
          "module": "Data.Comp.Multi.Show",
          "name": "showHF",
          "package": "compdata",
          "partial": "HF",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Show.html#v:showHF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Show",
          "name": "showHF'",
          "package": "compdata",
          "signature": "String",
          "source": "src/Data-Comp-Multi-Derive-Show.html#showHF%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Show",
          "module": "Data.Comp.Multi.Show",
          "name": "showHF'",
          "package": "compdata",
          "partial": "HF'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Show.html#v:showHF-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines sums on signatures. All definitions are\n generalised versions of those in \u003ca\u003eData.Comp.Sum\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.Sum",
          "name": "Sum",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Sum.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines sums on signatures All definitions are generalised versions of those in Data.Comp.Sum",
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "Sum",
          "package": "compdata",
          "partial": "Sum",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData type defining coproducts.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Sum",
          "name": ":+:",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ops.html#%3A%2B%3A",
          "type": "data"
        },
        "index": {
          "description": "Data type defining coproducts",
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": ":+:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#t::-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe subsumption relation.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Sum",
          "name": ":\u003c:",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Ops.html#%3A%3C%3A",
          "type": "class"
        },
        "index": {
          "description": "The subsumption relation",
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": ":\u003c:",
          "package": "compdata",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#t::-60-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject a term over a sub signature to a term over larger signature. If the\n signature \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use \u003ccode\u003edeepInject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e\n instead.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject",
          "package": "compdata",
          "signature": "CxtFun g f",
          "source": "src/Data-Comp-Multi-Sum.html#deepInject",
          "type": "function"
        },
        "index": {
          "description": "Inject term over sub signature to term over larger signature If the signature is compound of atomic signatures use deepInject instead",
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepInject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject10",
          "package": "compdata",
          "signature": "CxtFun (:+: f10 (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))))) g",
          "source": "src/Data-Comp-Multi-Sum.html#deepInject10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject10",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepInject10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject2",
          "package": "compdata",
          "signature": "CxtFun (:+: f2 f1) g",
          "source": "src/Data-Comp-Multi-Sum.html#deepInject2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject2",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepInject2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject3",
          "package": "compdata",
          "signature": "CxtFun (:+: f3 (:+: f2 f1)) g",
          "source": "src/Data-Comp-Multi-Sum.html#deepInject3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject3",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepInject3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject4",
          "package": "compdata",
          "signature": "CxtFun (:+: f4 (:+: f3 (:+: f2 f1))) g",
          "source": "src/Data-Comp-Multi-Sum.html#deepInject4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject4",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepInject4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject5",
          "package": "compdata",
          "signature": "CxtFun (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))) g",
          "source": "src/Data-Comp-Multi-Sum.html#deepInject5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject5",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepInject5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject6",
          "package": "compdata",
          "signature": "CxtFun (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))) g",
          "source": "src/Data-Comp-Multi-Sum.html#deepInject6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject6",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepInject6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject7",
          "package": "compdata",
          "signature": "CxtFun (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))) g",
          "source": "src/Data-Comp-Multi-Sum.html#deepInject7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject7",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepInject7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject8",
          "package": "compdata",
          "signature": "CxtFun (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))) g",
          "source": "src/Data-Comp-Multi-Sum.html#deepInject8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject8",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepInject8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject9",
          "package": "compdata",
          "signature": "CxtFun (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))))) g",
          "source": "src/Data-Comp-Multi-Sum.html#deepInject9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepInject9",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepInject9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTries to coerce a term\u003cem\u003econtext to a term\u003c/em\u003econtext over a sub-signature. If\n the signature \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use\n \u003ccode\u003edeepProject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject",
          "package": "compdata",
          "signature": "CxtFunM Maybe f g",
          "source": "src/Data-Comp-Multi-Sum.html#deepProject",
          "type": "function"
        },
        "index": {
          "description": "Tries to coerce term context to term context over sub-signature If the signature is compound of atomic signatures use deepProject instead",
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepProject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject10",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g10 (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))))",
          "source": "src/Data-Comp-Multi-Sum.html#deepProject10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject10",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepProject10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject2",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g2 g1)",
          "source": "src/Data-Comp-Multi-Sum.html#deepProject2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject2",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepProject2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject3",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g3 (:+: g2 g1))",
          "source": "src/Data-Comp-Multi-Sum.html#deepProject3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject3",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepProject3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject4",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g4 (:+: g3 (:+: g2 g1)))",
          "source": "src/Data-Comp-Multi-Sum.html#deepProject4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject4",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepProject4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject5",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))",
          "source": "src/Data-Comp-Multi-Sum.html#deepProject5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject5",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepProject5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject6",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))",
          "source": "src/Data-Comp-Multi-Sum.html#deepProject6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject6",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepProject6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject7",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))",
          "source": "src/Data-Comp-Multi-Sum.html#deepProject7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject7",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepProject7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject8",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))",
          "source": "src/Data-Comp-Multi-Sum.html#deepProject8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject8",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepProject8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject9",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))))",
          "source": "src/Data-Comp-Multi-Sum.html#deepProject9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "deepProject9",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:deepProject9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inj",
          "package": "compdata",
          "signature": "sub a :-\u003e sup a",
          "source": "src/Data-Comp-Multi-Ops.html#inj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inj",
          "normalized": "a b-\u003ec b",
          "package": "compdata",
          "signature": "sub a-\u003esup a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inj10",
          "package": "compdata",
          "signature": ":+: f10 (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))))) a i -\u003e g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inj10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inj10",
          "normalized": "a(a(a(a(a(a(a(a(a a))))))))b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f(f f))))))))a i-\u003eg a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inj10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inj2",
          "package": "compdata",
          "signature": ":+: f2 f1 a i -\u003e g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inj2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inj2",
          "normalized": "a a b c-\u003ed b c",
          "package": "compdata",
          "signature": "f f a i-\u003eg a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inj2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inj3",
          "package": "compdata",
          "signature": ":+: f3 (:+: f2 f1) a i -\u003e g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inj3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inj3",
          "normalized": "a(a a)b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f f)a i-\u003eg a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inj3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inj4",
          "package": "compdata",
          "signature": ":+: f4 (:+: f3 (:+: f2 f1)) a i -\u003e g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inj4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inj4",
          "normalized": "a(a(a a))b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f(f f))a i-\u003eg a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inj5",
          "package": "compdata",
          "signature": ":+: f5 (:+: f4 (:+: f3 (:+: f2 f1))) a i -\u003e g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inj5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inj5",
          "normalized": "a(a(a(a a)))b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f(f(f f)))a i-\u003eg a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inj5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inj6",
          "package": "compdata",
          "signature": ":+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))) a i -\u003e g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inj6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inj6",
          "normalized": "a(a(a(a(a a))))b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f(f(f(f f))))a i-\u003eg a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inj6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inj7",
          "package": "compdata",
          "signature": ":+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))) a i -\u003e g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inj7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inj7",
          "normalized": "a(a(a(a(a(a a)))))b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f(f(f(f(f f)))))a i-\u003eg a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inj7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inj8",
          "package": "compdata",
          "signature": ":+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))) a i -\u003e g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inj8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inj8",
          "normalized": "a(a(a(a(a(a(a a))))))b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f f))))))a i-\u003eg a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inj8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inj9",
          "package": "compdata",
          "signature": ":+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))) a i -\u003e g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inj9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inj9",
          "normalized": "a(a(a(a(a(a(a(a a)))))))b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f f)))))))a i-\u003eg a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inj9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject a term where the outermost layer is a sub signature. If the signature\n \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use \u003ccode\u003einject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Sum",
          "name": "inject",
          "package": "compdata",
          "signature": "g (Cxt h f a) :-\u003e Cxt h f a",
          "source": "src/Data-Comp-Multi-Sum.html#inject",
          "type": "function"
        },
        "index": {
          "description": "Inject term where the outermost layer is sub signature If the signature is compound of atomic signatures use inject instead",
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inject",
          "normalized": "a(Cxt b c d)-\u003eCxt b c d",
          "package": "compdata",
          "signature": "g(Cxt h f a)-\u003eCxt h f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inject10",
          "package": "compdata",
          "signature": ":+: f10 (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))))) (Cxt h g a) i -\u003e Cxt h g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inject10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inject10",
          "normalized": "a(a(a(a(a(a(a(a(a a))))))))(Cxt b c d)e-\u003eCxt b c d e",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f(f f))))))))(Cxt h g a)i-\u003eCxt h g a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inject10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inject2",
          "package": "compdata",
          "signature": ":+: f2 f1 (Cxt h g a) i -\u003e Cxt h g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inject2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inject2",
          "normalized": "a a(Cxt b c d)e-\u003eCxt b c d e",
          "package": "compdata",
          "signature": "f f(Cxt h g a)i-\u003eCxt h g a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inject2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inject3",
          "package": "compdata",
          "signature": ":+: f3 (:+: f2 f1) (Cxt h g a) i -\u003e Cxt h g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inject3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inject3",
          "normalized": "a(a a)(Cxt b c d)e-\u003eCxt b c d e",
          "package": "compdata",
          "signature": "f(f f)(Cxt h g a)i-\u003eCxt h g a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inject3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inject4",
          "package": "compdata",
          "signature": ":+: f4 (:+: f3 (:+: f2 f1)) (Cxt h g a) i -\u003e Cxt h g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inject4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inject4",
          "normalized": "a(a(a a))(Cxt b c d)e-\u003eCxt b c d e",
          "package": "compdata",
          "signature": "f(f(f f))(Cxt h g a)i-\u003eCxt h g a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inject4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inject5",
          "package": "compdata",
          "signature": ":+: f5 (:+: f4 (:+: f3 (:+: f2 f1))) (Cxt h g a) i -\u003e Cxt h g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inject5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inject5",
          "normalized": "a(a(a(a a)))(Cxt b c d)e-\u003eCxt b c d e",
          "package": "compdata",
          "signature": "f(f(f(f f)))(Cxt h g a)i-\u003eCxt h g a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inject5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inject6",
          "package": "compdata",
          "signature": ":+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))) (Cxt h g a) i -\u003e Cxt h g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inject6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inject6",
          "normalized": "a(a(a(a(a a))))(Cxt b c d)e-\u003eCxt b c d e",
          "package": "compdata",
          "signature": "f(f(f(f(f f))))(Cxt h g a)i-\u003eCxt h g a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inject6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inject7",
          "package": "compdata",
          "signature": ":+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))) (Cxt h g a) i -\u003e Cxt h g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inject7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inject7",
          "normalized": "a(a(a(a(a(a a)))))(Cxt b c d)e-\u003eCxt b c d e",
          "package": "compdata",
          "signature": "f(f(f(f(f(f f)))))(Cxt h g a)i-\u003eCxt h g a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inject7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inject8",
          "package": "compdata",
          "signature": ":+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))) (Cxt h g a) i -\u003e Cxt h g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inject8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inject8",
          "normalized": "a(a(a(a(a(a(a a))))))(Cxt b c d)e-\u003eCxt b c d e",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f f))))))(Cxt h g a)i-\u003eCxt h g a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inject8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "inject9",
          "package": "compdata",
          "signature": ":+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))) (Cxt h g a) i -\u003e Cxt h g a i",
          "source": "src/Data-Comp-Multi-Sum.html#inject9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "inject9",
          "normalized": "a(a(a(a(a(a(a(a a)))))))(Cxt b c d)e-\u003eCxt b c d e",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f f)))))))(Cxt h g a)i-\u003eCxt h g a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:inject9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "injectConst",
          "package": "compdata",
          "signature": "Const g :-\u003e Cxt h f a",
          "source": "src/Data-Comp-Multi-Sum.html#injectConst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "injectConst",
          "normalized": "Const a-\u003eCxt b c d",
          "package": "compdata",
          "partial": "Const",
          "signature": "Const g-\u003eCxt h f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:injectConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "injectConst2",
          "package": "compdata",
          "signature": "Const (f1 :+: f2) :-\u003e Cxt h g a",
          "source": "src/Data-Comp-Multi-Sum.html#injectConst2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "injectConst2",
          "normalized": "Const(a a)-\u003eCxt b c d",
          "package": "compdata",
          "partial": "Const",
          "signature": "Const(f f)-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:injectConst2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "injectConst3",
          "package": "compdata",
          "signature": "Const (f1 :+: (f2 :+: f3)) :-\u003e Cxt h g a",
          "source": "src/Data-Comp-Multi-Sum.html#injectConst3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "injectConst3",
          "normalized": "Const(a(a a))-\u003eCxt b c d",
          "package": "compdata",
          "partial": "Const",
          "signature": "Const(f(f f))-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:injectConst3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function injects a whole context into another context.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Sum",
          "name": "injectCxt",
          "package": "compdata",
          "signature": "Cxt h' g (Cxt h f a) :-\u003e Cxt h f a",
          "source": "src/Data-Comp-Multi-Sum.html#injectCxt",
          "type": "function"
        },
        "index": {
          "description": "This function injects whole context into another context",
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "injectCxt",
          "normalized": "Cxt a b(Cxt c d e)-\u003eCxt c d e",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "Cxt h' g(Cxt h f a)-\u003eCxt h f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:injectCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function lifts the given functor to a context.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Sum",
          "name": "liftCxt",
          "package": "compdata",
          "signature": "g a :-\u003e Context f a",
          "source": "src/Data-Comp-Multi-Sum.html#liftCxt",
          "type": "function"
        },
        "index": {
          "description": "This function lifts the given functor to context",
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "liftCxt",
          "normalized": "a b-\u003eContext c b",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "g a-\u003eContext f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:liftCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "proj",
          "package": "compdata",
          "signature": "NatM Maybe (sup a) (sub a)",
          "source": "src/Data-Comp-Multi-Ops.html#proj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "proj",
          "package": "compdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:proj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "proj10",
          "package": "compdata",
          "signature": "f a i -\u003e Maybe (:+: g10 (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))) a i)",
          "source": "src/Data-Comp-Multi-Sum.html#proj10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "proj10",
          "normalized": "a b c-\u003eMaybe(d(d(d(d(d(d(d(d(d d))))))))b c)",
          "package": "compdata",
          "signature": "f a i-\u003eMaybe(g(g(g(g(g(g(g(g(g g))))))))a i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:proj10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "proj2",
          "package": "compdata",
          "signature": "f a i -\u003e Maybe (:+: g2 g1 a i)",
          "source": "src/Data-Comp-Multi-Sum.html#proj2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "proj2",
          "normalized": "a b c-\u003eMaybe(d d b c)",
          "package": "compdata",
          "signature": "f a i-\u003eMaybe(g g a i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:proj2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "proj3",
          "package": "compdata",
          "signature": "f a i -\u003e Maybe (:+: g3 (:+: g2 g1) a i)",
          "source": "src/Data-Comp-Multi-Sum.html#proj3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "proj3",
          "normalized": "a b c-\u003eMaybe(d(d d)b c)",
          "package": "compdata",
          "signature": "f a i-\u003eMaybe(g(g g)a i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:proj3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "proj4",
          "package": "compdata",
          "signature": "f a i -\u003e Maybe (:+: g4 (:+: g3 (:+: g2 g1)) a i)",
          "source": "src/Data-Comp-Multi-Sum.html#proj4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "proj4",
          "normalized": "a b c-\u003eMaybe(d(d(d d))b c)",
          "package": "compdata",
          "signature": "f a i-\u003eMaybe(g(g(g g))a i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:proj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "proj5",
          "package": "compdata",
          "signature": "f a i -\u003e Maybe (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))) a i)",
          "source": "src/Data-Comp-Multi-Sum.html#proj5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "proj5",
          "normalized": "a b c-\u003eMaybe(d(d(d(d d)))b c)",
          "package": "compdata",
          "signature": "f a i-\u003eMaybe(g(g(g(g g)))a i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:proj5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "proj6",
          "package": "compdata",
          "signature": "f a i -\u003e Maybe (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))) a i)",
          "source": "src/Data-Comp-Multi-Sum.html#proj6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "proj6",
          "normalized": "a b c-\u003eMaybe(d(d(d(d(d d))))b c)",
          "package": "compdata",
          "signature": "f a i-\u003eMaybe(g(g(g(g(g g))))a i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:proj6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "proj7",
          "package": "compdata",
          "signature": "f a i -\u003e Maybe (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))) a i)",
          "source": "src/Data-Comp-Multi-Sum.html#proj7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "proj7",
          "normalized": "a b c-\u003eMaybe(d(d(d(d(d(d d)))))b c)",
          "package": "compdata",
          "signature": "f a i-\u003eMaybe(g(g(g(g(g(g g)))))a i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:proj7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "proj8",
          "package": "compdata",
          "signature": "f a i -\u003e Maybe (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))) a i)",
          "source": "src/Data-Comp-Multi-Sum.html#proj8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "proj8",
          "normalized": "a b c-\u003eMaybe(d(d(d(d(d(d(d d))))))b c)",
          "package": "compdata",
          "signature": "f a i-\u003eMaybe(g(g(g(g(g(g(g g))))))a i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:proj8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "proj9",
          "package": "compdata",
          "signature": "f a i -\u003e Maybe (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))) a i)",
          "source": "src/Data-Comp-Multi-Sum.html#proj9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "proj9",
          "normalized": "a b c-\u003eMaybe(d(d(d(d(d(d(d(d d)))))))b c)",
          "package": "compdata",
          "signature": "f a i-\u003eMaybe(g(g(g(g(g(g(g(g g)))))))a i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:proj9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject the outermost layer of a term to a sub signature. If the signature\n \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use \u003ccode\u003eproject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Sum",
          "name": "project",
          "package": "compdata",
          "signature": "NatM Maybe (Cxt h f a) (g (Cxt h f a))",
          "source": "src/Data-Comp-Multi-Sum.html#project",
          "type": "function"
        },
        "index": {
          "description": "Project the outermost layer of term to sub signature If the signature is compound of atomic signatures use project instead",
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "project",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:project"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "project10",
          "package": "compdata",
          "signature": "Cxt h f a i -\u003e Maybe (:+: g10 (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))) (Cxt h f a) i)",
          "source": "src/Data-Comp-Multi-Sum.html#project10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "project10",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e(e(e(e(e(e(e(e e))))))))(Cxt a b c)d)",
          "package": "compdata",
          "signature": "Cxt h f a i-\u003eMaybe(g(g(g(g(g(g(g(g(g g))))))))(Cxt h f a)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:project10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "project2",
          "package": "compdata",
          "signature": "Cxt h f a i -\u003e Maybe (:+: g2 g1 (Cxt h f a) i)",
          "source": "src/Data-Comp-Multi-Sum.html#project2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "project2",
          "normalized": "Cxt a b c d-\u003eMaybe(e e(Cxt a b c)d)",
          "package": "compdata",
          "signature": "Cxt h f a i-\u003eMaybe(g g(Cxt h f a)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:project2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "project3",
          "package": "compdata",
          "signature": "Cxt h f a i -\u003e Maybe (:+: g3 (:+: g2 g1) (Cxt h f a) i)",
          "source": "src/Data-Comp-Multi-Sum.html#project3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "project3",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e e)(Cxt a b c)d)",
          "package": "compdata",
          "signature": "Cxt h f a i-\u003eMaybe(g(g g)(Cxt h f a)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:project3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "project4",
          "package": "compdata",
          "signature": "Cxt h f a i -\u003e Maybe (:+: g4 (:+: g3 (:+: g2 g1)) (Cxt h f a) i)",
          "source": "src/Data-Comp-Multi-Sum.html#project4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "project4",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e(e e))(Cxt a b c)d)",
          "package": "compdata",
          "signature": "Cxt h f a i-\u003eMaybe(g(g(g g))(Cxt h f a)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:project4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "project5",
          "package": "compdata",
          "signature": "Cxt h f a i -\u003e Maybe (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))) (Cxt h f a) i)",
          "source": "src/Data-Comp-Multi-Sum.html#project5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "project5",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e(e(e e)))(Cxt a b c)d)",
          "package": "compdata",
          "signature": "Cxt h f a i-\u003eMaybe(g(g(g(g g)))(Cxt h f a)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:project5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "project6",
          "package": "compdata",
          "signature": "Cxt h f a i -\u003e Maybe (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))) (Cxt h f a) i)",
          "source": "src/Data-Comp-Multi-Sum.html#project6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "project6",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e(e(e(e e))))(Cxt a b c)d)",
          "package": "compdata",
          "signature": "Cxt h f a i-\u003eMaybe(g(g(g(g(g g))))(Cxt h f a)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:project6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "project7",
          "package": "compdata",
          "signature": "Cxt h f a i -\u003e Maybe (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))) (Cxt h f a) i)",
          "source": "src/Data-Comp-Multi-Sum.html#project7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "project7",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e(e(e(e(e e)))))(Cxt a b c)d)",
          "package": "compdata",
          "signature": "Cxt h f a i-\u003eMaybe(g(g(g(g(g(g g)))))(Cxt h f a)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:project7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "project8",
          "package": "compdata",
          "signature": "Cxt h f a i -\u003e Maybe (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))) (Cxt h f a) i)",
          "source": "src/Data-Comp-Multi-Sum.html#project8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "project8",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e(e(e(e(e(e e))))))(Cxt a b c)d)",
          "package": "compdata",
          "signature": "Cxt h f a i-\u003eMaybe(g(g(g(g(g(g(g g))))))(Cxt h f a)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:project8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "project9",
          "package": "compdata",
          "signature": "Cxt h f a i -\u003e Maybe (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))) (Cxt h f a) i)",
          "source": "src/Data-Comp-Multi-Sum.html#project9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "project9",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e(e(e(e(e(e(e e)))))))(Cxt a b c)d)",
          "package": "compdata",
          "signature": "Cxt h f a i-\u003eMaybe(g(g(g(g(g(g(g(g g)))))))(Cxt h f a)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:project9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Sum",
          "name": "projectConst",
          "package": "compdata",
          "signature": "NatM Maybe (Cxt h f a) (Const g)",
          "source": "src/Data-Comp-Multi-Sum.html#projectConst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "projectConst",
          "package": "compdata",
          "partial": "Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:projectConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies the given context with hole type \u003ccode\u003ea\u003c/code\u003e to a\n family \u003ccode\u003ef\u003c/code\u003e of contexts (possibly terms) indexed by \u003ccode\u003ea\u003c/code\u003e. That is,\n each hole \u003ccode\u003eh\u003c/code\u003e is replaced by the context \u003ccode\u003ef h\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Sum",
          "name": "substHoles",
          "package": "compdata",
          "signature": "(v :-\u003e Cxt h g a) -\u003e Cxt h' f v :-\u003e Cxt h g a",
          "source": "src/Data-Comp-Multi-Sum.html#substHoles",
          "type": "function"
        },
        "index": {
          "description": "This function applies the given context with hole type to family of contexts possibly terms indexed by That is each hole is replaced by the context",
          "hierarchy": "Data Comp Multi Sum",
          "module": "Data.Comp.Multi.Sum",
          "name": "substHoles",
          "normalized": "(a-\u003eCxt b c d)-\u003eCxt e f a-\u003eCxt b c d",
          "package": "compdata",
          "partial": "Holes",
          "signature": "(v-\u003eCxt h g a)-\u003eCxt h' f v-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Sum.html#v:substHoles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the central notion of mutual recursive (or, higher-order)\n \u003cem\u003eterms\u003c/em\u003e and its generalisation to (higher-order) contexts. All definitions\n are generalised versions of those in \u003ca\u003eData.Comp.Term\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.Term",
          "name": "Term",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Term.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the central notion of mutual recursive or higher-order terms and its generalisation to higher-order contexts All definitions are generalised versions of those in Data.Comp.Term",
          "hierarchy": "Data Comp Multi Term",
          "module": "Data.Comp.Multi.Term",
          "name": "Term",
          "package": "compdata",
          "partial": "Term",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Term.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Term",
          "name": "Const",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Term.html#Const",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Comp Multi Term",
          "module": "Data.Comp.Multi.Term",
          "name": "Const",
          "package": "compdata",
          "partial": "Const",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Term.html#t:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA context might contain holes.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Term",
          "name": "Context",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Term.html#Context",
          "type": "type"
        },
        "index": {
          "description": "context might contain holes",
          "hierarchy": "Data Comp Multi Term",
          "module": "Data.Comp.Multi.Term",
          "name": "Context",
          "package": "compdata",
          "partial": "Context",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Term.html#t:Context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type represents contexts over a signature. Contexts are\n terms containing zero or more holes. The first type parameter is\n supposed to be one of the phantom types \u003ccode\u003e\u003ca\u003eHole\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eNoHole\u003c/a\u003e\u003c/code\u003e. The\n second parameter is the signature of the context. The third\n parameter is the type family of the holes. The last parameter is\n the index/label.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Term",
          "name": "Cxt",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Term.html#Cxt",
          "type": "data"
        },
        "index": {
          "description": "This data type represents contexts over signature Contexts are terms containing zero or more holes The first type parameter is supposed to be one of the phantom types Hole and NoHole The second parameter is the signature of the context The third parameter is the type family of the holes The last parameter is the index label",
          "hierarchy": "Data Comp Multi Term",
          "module": "Data.Comp.Multi.Term",
          "name": "Cxt",
          "package": "compdata",
          "partial": "Cxt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Term.html#t:Cxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhantom type that signals that a \u003ccode\u003e\u003ca\u003eCxt\u003c/a\u003e\u003c/code\u003e might contain holes.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Term",
          "name": "Hole",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Term.html#Hole",
          "type": "data"
        },
        "index": {
          "description": "Phantom type that signals that Cxt might contain holes",
          "hierarchy": "Data Comp Multi Term",
          "module": "Data.Comp.Multi.Term",
          "name": "Hole",
          "package": "compdata",
          "partial": "Hole",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Term.html#t:Hole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhantom type that signals that a \u003ccode\u003e\u003ca\u003eCxt\u003c/a\u003e\u003c/code\u003e does not contain holes.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Term",
          "name": "NoHole",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Term.html#NoHole",
          "type": "data"
        },
        "index": {
          "description": "Phantom type that signals that Cxt does not contain holes",
          "hierarchy": "Data Comp Multi Term",
          "module": "Data.Comp.Multi.Term",
          "name": "NoHole",
          "package": "compdata",
          "partial": "No Hole",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Term.html#t:NoHole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA (higher-order) term is a context with no holes.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Term",
          "name": "Term",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Term.html#Term",
          "type": "type"
        },
        "index": {
          "description": "higher-order term is context with no holes",
          "hierarchy": "Data Comp Multi Term",
          "module": "Data.Comp.Multi.Term",
          "name": "Term",
          "package": "compdata",
          "partial": "Term",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Term.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Term",
          "name": "Hole",
          "package": "compdata",
          "signature": "a i -\u003e Cxt Hole f a i",
          "source": "src/Data-Comp-Multi-Term.html#Cxt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Term",
          "module": "Data.Comp.Multi.Term",
          "name": "Hole",
          "normalized": "a b-\u003eCxt Hole c a b",
          "package": "compdata",
          "partial": "Hole",
          "signature": "a i-\u003eCxt Hole f a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Term.html#v:Hole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Term",
          "name": "Term",
          "package": "compdata",
          "signature": "f (Cxt h f a) i -\u003e Cxt h f a i",
          "source": "src/Data-Comp-Multi-Term.html#Cxt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Term",
          "module": "Data.Comp.Multi.Term",
          "name": "Term",
          "normalized": "a(Cxt b a c)d-\u003eCxt b a c d",
          "package": "compdata",
          "partial": "Term",
          "signature": "f(Cxt h f a)i-\u003eCxt h f a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Term.html#v:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function converts a constant to a term. This assumes that\n the argument is indeed a constant, i.e. does not have a value for\n the argument type of the functor f.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Term",
          "name": "constTerm",
          "package": "compdata",
          "signature": "Const f :-\u003e Term f",
          "source": "src/Data-Comp-Multi-Term.html#constTerm",
          "type": "function"
        },
        "index": {
          "description": "This function converts constant to term This assumes that the argument is indeed constant i.e does not have value for the argument type of the functor",
          "hierarchy": "Data Comp Multi Term",
          "module": "Data.Comp.Multi.Term",
          "name": "constTerm",
          "normalized": "Const a-\u003eTerm a",
          "package": "compdata",
          "partial": "Term",
          "signature": "Const f-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Term.html#v:constTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Term",
          "name": "simpCxt",
          "package": "compdata",
          "signature": "f a i -\u003e Context f a i",
          "source": "src/Data-Comp-Multi-Term.html#simpCxt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Term",
          "module": "Data.Comp.Multi.Term",
          "name": "simpCxt",
          "normalized": "a b c-\u003eContext a b c",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "f a i-\u003eContext f a i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Term.html#v:simpCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast a term over a signature to a context over the same signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Term",
          "name": "toCxt",
          "package": "compdata",
          "signature": "Term f :-\u003e Context f a",
          "source": "src/Data-Comp-Multi-Term.html#toCxt",
          "type": "function"
        },
        "index": {
          "description": "Cast term over signature to context over the same signature",
          "hierarchy": "Data Comp Multi Term",
          "module": "Data.Comp.Multi.Term",
          "name": "toCxt",
          "normalized": "Term a-\u003eContext a b",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "Term f-\u003eContext f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Term.html#v:toCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function unravels the given term at the topmost layer.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Term",
          "name": "unTerm",
          "package": "compdata",
          "signature": "Term f t -\u003e f (Term f) t",
          "source": "src/Data-Comp-Multi-Term.html#unTerm",
          "type": "function"
        },
        "index": {
          "description": "This function unravels the given term at the topmost layer",
          "hierarchy": "Data Comp Multi Term",
          "module": "Data.Comp.Multi.Term",
          "name": "unTerm",
          "normalized": "Term a b-\u003ea(Term a)b",
          "package": "compdata",
          "partial": "Term",
          "signature": "Term f t-\u003ef(Term f)t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Term.html#v:unTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines an abstract notion of (bound) variables in compositional\n data types, and scoped substitution. Capture-avoidance is \u003cem\u003enot\u003c/em\u003e taken into\n account. All definitions are generalised versions of those in\n \u003ca\u003eData.Comp.Variables\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi.Variables",
          "name": "Variables",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Variables.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines an abstract notion of bound variables in compositional data types and scoped substitution Capture-avoidance is not taken into account All definitions are generalised versions of those in Data.Comp.Variables",
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "Variables",
          "package": "compdata",
          "partial": "Variables",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Variables",
          "name": "CxtSubst",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Variables.html#CxtSubst",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "CxtSubst",
          "package": "compdata",
          "partial": "Cxt Subst",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#t:CxtSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Variables",
          "name": "GSubst",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Variables.html#GSubst",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "GSubst",
          "package": "compdata",
          "partial": "GSubst",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#t:GSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis multiparameter class defines functors with variables. An instance\n  \u003ccode\u003eHasVar f v\u003c/code\u003e denotes that values over \u003ccode\u003ef\u003c/code\u003e might contain and bind variables of\n  type \u003ccode\u003ev\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Variables",
          "name": "HasVars",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Variables.html#HasVars",
          "type": "class"
        },
        "index": {
          "description": "This multiparameter class defines functors with variables An instance HasVar denotes that values over might contain and bind variables of type",
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "HasVars",
          "package": "compdata",
          "partial": "Has Vars",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#t:HasVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Variables",
          "name": "Subst",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-Variables.html#Subst",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "Subst",
          "package": "compdata",
          "partial": "Subst",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#t:Subst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Variables",
          "name": "appSubst",
          "package": "compdata",
          "signature": "GSubst v t -\u003e a :-\u003e a",
          "source": "src/Data-Comp-Multi-Variables.html#appSubst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "appSubst",
          "normalized": "GSubst a b-\u003ec-\u003ec",
          "package": "compdata",
          "partial": "Subst",
          "signature": "GSubst v t-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#v:appSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndicates the set of variables bound by the \u003ccode\u003ef\u003c/code\u003e constructor\n for each argument of the constructor. For example for a\n non-recursive let binding:\n \u003ccode\u003e\n data Let i e = Let Var (e i) (e i)\n instance HasVars Let Var where\n   bindsVars (Let v x y) = Map.fromList [(y, (Set.singleton v))]\n \u003c/code\u003e\n If, instead, the let binding is recursive, the methods has to\n be implemented like this:\n \u003ccode\u003e\n   bindsVars (Let v x y) = Map.fromList [(x, (Set.singleton v)),\n                                         (y, (Set.singleton v))]\n \u003c/code\u003e\n This indicates that the scope of the bound variable also\n extends to the right-hand side of the variable binding.\n\u003c/p\u003e\u003cp\u003eThe default implementation returns the empty map.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Variables",
          "name": "bindsVars",
          "package": "compdata",
          "signature": "Map (E a) (Set v)",
          "source": "src/Data-Comp-Multi-Variables.html#bindsVars",
          "type": "method"
        },
        "index": {
          "description": "Indicates the set of variables bound by the constructor for each argument of the constructor For example for non-recursive let binding data Let Let Var instance HasVars Let Var where bindsVars Let Map.fromList Set.singleton If instead the let binding is recursive the methods has to be implemented like this bindsVars Let Map.fromList Set.singleton Set.singleton This indicates that the scope of the bound variable also extends to the right-hand side of the variable binding The default implementation returns the empty map",
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "bindsVars",
          "package": "compdata",
          "partial": "Vars",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#v:bindsVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two substitutions \u003ccode\u003es1\u003c/code\u003e and \u003ccode\u003es2\u003c/code\u003e. That is,\napplying the resulting substitution is equivalent to first applying\n\u003ccode\u003es2\u003c/code\u003e and then \u003ccode\u003es1\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Variables",
          "name": "compSubst",
          "package": "compdata",
          "signature": "CxtSubst h a f v -\u003e CxtSubst h a f v -\u003e CxtSubst h a f v",
          "source": "src/Data-Comp-Multi-Variables.html#compSubst",
          "type": "function"
        },
        "index": {
          "description": "This function composes two substitutions s1 and s2 That is applying the resulting substitution is equivalent to first applying s2 and then s1",
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "compSubst",
          "normalized": "CxtSubst a b c d-\u003eCxtSubst a b c d-\u003eCxtSubst a b c d",
          "package": "compdata",
          "partial": "Subst",
          "signature": "CxtSubst h a f v-\u003eCxtSubst h a f v-\u003eCxtSubst h a f v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#v:compSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function checks whether a variable is contained in a context. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Variables",
          "name": "containsVar",
          "package": "compdata",
          "signature": "Bool",
          "source": "src/Data-Comp-Multi-Variables.html#containsVar",
          "type": "function"
        },
        "index": {
          "description": "This function checks whether variable is contained in context",
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "containsVar",
          "package": "compdata",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#v:containsVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator pairs every argument of a given constructor with\n the set of (newly) bound variables according to the corresponding\n \u003ccode\u003e\u003ca\u003eHasVars\u003c/a\u003e\u003c/code\u003e type class instance.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Variables",
          "name": "getBoundVars",
          "package": "compdata",
          "signature": "f a i -\u003e f (a :*: K (Set v)) i",
          "source": "src/Data-Comp-Multi-Variables.html#getBoundVars",
          "type": "function"
        },
        "index": {
          "description": "This combinator pairs every argument of given constructor with the set of newly bound variables according to the corresponding HasVars type class instance",
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "getBoundVars",
          "normalized": "a b c-\u003ea(b*K(Set d))c",
          "package": "compdata",
          "partial": "Bound Vars",
          "signature": "f a i-\u003ef(a*K(Set v))i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#v:getBoundVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndicates whether the \u003ccode\u003ef\u003c/code\u003e constructor is a variable. The\n default implementation returns \u003ccode\u003eNothing\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Variables",
          "name": "isVar",
          "package": "compdata",
          "signature": "Maybe v",
          "source": "src/Data-Comp-Multi-Variables.html#isVar",
          "type": "method"
        },
        "index": {
          "description": "Indicates whether the constructor is variable The default implementation returns Nothing",
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "isVar",
          "package": "compdata",
          "partial": "Var",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#v:isVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function computes the list of variables occurring in a context. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Variables",
          "name": "variableList",
          "package": "compdata",
          "signature": "[v]",
          "source": "src/Data-Comp-Multi-Variables.html#variableList",
          "type": "function"
        },
        "index": {
          "description": "This function computes the list of variables occurring in context",
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "variableList",
          "normalized": "[a]",
          "package": "compdata",
          "partial": "List",
          "signature": "[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#v:variableList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function computes the set of variables occurring in a context. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Variables",
          "name": "variables",
          "package": "compdata",
          "signature": "Set v",
          "source": "src/Data-Comp-Multi-Variables.html#variables",
          "type": "function"
        },
        "index": {
          "description": "This function computes the set of variables occurring in context",
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "variables",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#v:variables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function computes the set of variables occurring in a context. \n\u003c/p\u003e",
          "module": "Data.Comp.Multi.Variables",
          "name": "variables'",
          "package": "compdata",
          "signature": "Set v",
          "source": "src/Data-Comp-Multi-Variables.html#variables%27",
          "type": "function"
        },
        "index": {
          "description": "This function computes the set of variables occurring in context",
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "variables'",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#v:variables-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Multi.Variables",
          "name": "varsToHoles",
          "package": "compdata",
          "signature": "Term f :-\u003e Context f (K v)",
          "source": "src/Data-Comp-Multi-Variables.html#varsToHoles",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Multi Variables",
          "module": "Data.Comp.Multi.Variables",
          "name": "varsToHoles",
          "normalized": "Term a-\u003eContext a(K b)",
          "package": "compdata",
          "partial": "To Holes",
          "signature": "Term f-\u003eContext f(K v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi-Variables.html#v:varsToHoles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the infrastructure necessary to use\n \u003cem\u003eGeneralised Compositional Data Types\u003c/em\u003e. Generalised Compositional Data Types \n is an extension of Compositional Data Types with mutually recursive\n data types, and more generally GADTs. Examples of usage are bundled with the\n package in the library \u003ccode\u003eexamples/Examples/Multi\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Multi",
          "name": "Multi",
          "package": "compdata",
          "source": "src/Data-Comp-Multi.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the infrastructure necessary to use Generalised Compositional Data Types Generalised Compositional Data Types is an extension of Compositional Data Types with mutually recursive data types and more generally GADTs Examples of usage are bundled with the package in the library examples Examples Multi",
          "hierarchy": "Data Comp Multi",
          "module": "Data.Comp.Multi",
          "name": "Multi",
          "package": "compdata",
          "partial": "Multi",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Multi.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the notion of algebras and catamorphisms, and their\n generalizations to e.g. monadic versions and other (co)recursion schemes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "Algebra",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Algebra.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the notion of algebras and catamorphisms and their generalizations to e.g monadic versions and other co recursion schemes",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "Algebra",
          "package": "compdata",
          "partial": "Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents an algebra over a difunctor \u003ccode\u003ef\u003c/code\u003e and carrier \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "Alg",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Algebra.html#Alg",
          "type": "type"
        },
        "index": {
          "description": "This type represents an algebra over difunctor and carrier",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "Alg",
          "package": "compdata",
          "partial": "Alg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#t:Alg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic algebra. It is similar to \u003ccode\u003e\u003ca\u003eAlg\u003c/a\u003e\u003c/code\u003e but\n  the return type is monadic. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "AlgM",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Algebra.html#AlgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic algebra It is similar to Alg but the return type is monadic",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "AlgM",
          "package": "compdata",
          "partial": "Alg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#t:AlgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic algebra, but where the covariant argument is\n  also a monadic computation. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "AlgM'",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Algebra.html#AlgM%27",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic algebra but where the covariant argument is also monadic computation",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "AlgM'",
          "package": "compdata",
          "partial": "Alg M'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#t:AlgM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "Compose",
          "package": "compdata",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "Compose",
          "package": "compdata",
          "partial": "Compose",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#t:Compose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a context function. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "CxtFun",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Algebra.html#CxtFun",
          "type": "type"
        },
        "index": {
          "description": "This type represents context function",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "CxtFun",
          "package": "compdata",
          "partial": "Cxt Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#t:CxtFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic context function. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "CxtFunM",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Algebra.html#CxtFunM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic context function",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "CxtFunM",
          "package": "compdata",
          "partial": "Cxt Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#t:CxtFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a term homomorphism. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "Hom",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Algebra.html#Hom",
          "type": "type"
        },
        "index": {
          "description": "This type represents term homomorphism",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "Hom",
          "package": "compdata",
          "partial": "Hom",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#t:Hom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic term homomorphism. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "HomM",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Algebra.html#HomM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic term homomorphism",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "HomM",
          "package": "compdata",
          "partial": "Hom",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#t:HomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a signature function. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "SigFun",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Algebra.html#SigFun",
          "type": "type"
        },
        "index": {
          "description": "This type represents signature function",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "SigFun",
          "package": "compdata",
          "partial": "Sig Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#t:SigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic signature function. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "SigFunM",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Algebra.html#SigFunM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic signature function",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "SigFunM",
          "package": "compdata",
          "partial": "Sig Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#t:SigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "Compose",
          "package": "compdata",
          "signature": "Compose",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "Compose",
          "package": "compdata",
          "partial": "Compose",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:Compose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a whole context into another context. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appCxt",
          "package": "compdata",
          "signature": "Cxt Hole f a (Cxt h f a b) :-\u003e Cxt h f a b",
          "source": "src/Data-Comp-MultiParam-Algebra.html#appCxt",
          "type": "function"
        },
        "index": {
          "description": "This function applies whole context into another context",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appCxt",
          "normalized": "Cxt Hole a b(Cxt c a b d)-\u003eCxt c a b d",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "Cxt Hole f a(Cxt h f a b)-\u003eCxt h f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:appCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a term homomorphism recursively to a term/context. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appHom",
          "package": "compdata",
          "signature": "Hom f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-MultiParam-Algebra.html#appHom",
          "type": "function"
        },
        "index": {
          "description": "Apply term homomorphism recursively to term context",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appHom",
          "normalized": "Hom a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Hom",
          "signature": "Hom f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:appHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a term homomorphism recursively to a term/context. This is\n a top-down variant of \u003ccode\u003e\u003ca\u003eappHom\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appHom'",
          "package": "compdata",
          "signature": "Hom f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-MultiParam-Algebra.html#appHom%27",
          "type": "function"
        },
        "index": {
          "description": "Apply term homomorphism recursively to term context This is top-down variant of appHom",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appHom'",
          "normalized": "Hom a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Hom'",
          "signature": "Hom f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:appHom-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a monadic term homomorphism recursively to a term/context. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appHomM",
          "package": "compdata",
          "signature": "HomM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-MultiParam-Algebra.html#appHomM",
          "type": "function"
        },
        "index": {
          "description": "Apply monadic term homomorphism recursively to term context",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appHomM",
          "normalized": "HomM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Hom",
          "signature": "HomM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:appHomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a monadic term homomorphism recursively to a\n term/context. This is a top-down variant of \u003ccode\u003e\u003ca\u003eappHomM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appHomM'",
          "package": "compdata",
          "signature": "HomM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-MultiParam-Algebra.html#appHomM%27",
          "type": "function"
        },
        "index": {
          "description": "Apply monadic term homomorphism recursively to term context This is top-down variant of appHomM",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appHomM'",
          "normalized": "HomM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Hom M'",
          "signature": "HomM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:appHomM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a signature function to the given context. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appSigFun",
          "package": "compdata",
          "signature": "SigFun f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-MultiParam-Algebra.html#appSigFun",
          "type": "function"
        },
        "index": {
          "description": "This function applies signature function to the given context",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appSigFun",
          "normalized": "SigFun a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFun f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:appSigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a signature function to the given context. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appSigFun'",
          "package": "compdata",
          "signature": "SigFun f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-MultiParam-Algebra.html#appSigFun%27",
          "type": "function"
        },
        "index": {
          "description": "This function applies signature function to the given context",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appSigFun'",
          "normalized": "SigFun a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Sig Fun'",
          "signature": "SigFun f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:appSigFun-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a monadic signature function to the given context. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appSigFunM",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-MultiParam-Algebra.html#appSigFunM",
          "type": "function"
        },
        "index": {
          "description": "This function applies monadic signature function to the given context",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appSigFunM",
          "normalized": "SigFunM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFunM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:appSigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a monadic signature function to the given\n context. This is a top-down variant of \u003ccode\u003e\u003ca\u003eappSigFunM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appSigFunM'",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-MultiParam-Algebra.html#appSigFunM%27",
          "type": "function"
        },
        "index": {
          "description": "This function applies monadic signature function to the given context This is top-down variant of appSigFunM",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appSigFunM'",
          "normalized": "SigFunM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Sig Fun M'",
          "signature": "SigFunM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:appSigFunM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA restricted form of |appHomM| which only works for terms. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appTHomM",
          "package": "compdata",
          "signature": "HomM m f g -\u003e Term f i -\u003e m (Term g i)",
          "source": "src/Data-Comp-MultiParam-Algebra.html#appTHomM",
          "type": "function"
        },
        "index": {
          "description": "restricted form of appHomM which only works for terms",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appTHomM",
          "normalized": "HomM a b c-\u003eTerm b d-\u003ea(Term c d)",
          "package": "compdata",
          "partial": "THom",
          "signature": "HomM m f g-\u003eTerm f i-\u003em(Term g i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:appTHomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA restricted form of |appHomM'| which only works for terms. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appTHomM'",
          "package": "compdata",
          "signature": "HomM m f g -\u003e Term f i -\u003e m (Term g i)",
          "source": "src/Data-Comp-MultiParam-Algebra.html#appTHomM%27",
          "type": "function"
        },
        "index": {
          "description": "restricted form of appHomM which only works for terms",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appTHomM'",
          "normalized": "HomM a b c-\u003eTerm b d-\u003ea(Term c d)",
          "package": "compdata",
          "partial": "THom M'",
          "signature": "HomM m f g-\u003eTerm f i-\u003em(Term g i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:appTHomM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA restricted form of |appSigFunM| which only works for terms. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appTSigFunM",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e Term f i -\u003e m (Term g i)",
          "source": "src/Data-Comp-MultiParam-Algebra.html#appTSigFunM",
          "type": "function"
        },
        "index": {
          "description": "restricted form of appSigFunM which only works for terms",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appTSigFunM",
          "normalized": "SigFunM a b c-\u003eTerm b d-\u003ea(Term c d)",
          "package": "compdata",
          "partial": "TSig Fun",
          "signature": "SigFunM m f g-\u003eTerm f i-\u003em(Term g i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:appTSigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA restricted form of |appSigFunM'| which only works for terms. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appTSigFunM'",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e Term f i -\u003e m (Term g i)",
          "source": "src/Data-Comp-MultiParam-Algebra.html#appTSigFunM%27",
          "type": "function"
        },
        "index": {
          "description": "restricted form of appSigFunM which only works for terms",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "appTSigFunM'",
          "normalized": "SigFunM a b c-\u003eTerm b d-\u003ea(Term c d)",
          "package": "compdata",
          "partial": "TSig Fun M'",
          "signature": "SigFunM m f g-\u003eTerm f i-\u003em(Term g i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:appTSigFunM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a catamorphism from the given algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "cata",
          "package": "compdata",
          "signature": "Alg f a -\u003e Term f :-\u003e a",
          "source": "src/Data-Comp-MultiParam-Algebra.html#cata",
          "type": "function"
        },
        "index": {
          "description": "Construct catamorphism from the given algebra",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "cata",
          "normalized": "Alg a b-\u003eTerm a-\u003eb",
          "package": "compdata",
          "signature": "Alg f a-\u003eTerm f-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:cata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalisation of \u003ccode\u003e\u003ca\u003ecata\u003c/a\u003e\u003c/code\u003e from terms over \u003ccode\u003ef\u003c/code\u003e to contexts over \u003ccode\u003ef\u003c/code\u003e, where\n  the holes have the type of the algebra carrier. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "cata'",
          "package": "compdata",
          "signature": "Alg f a -\u003e Cxt h f a a :-\u003e a",
          "source": "src/Data-Comp-MultiParam-Algebra.html#cata%27",
          "type": "function"
        },
        "index": {
          "description": "generalisation of cata from terms over to contexts over where the holes have the type of the algebra carrier",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "cata'",
          "normalized": "Alg a b-\u003eCxt c a b b-\u003eb",
          "package": "compdata",
          "signature": "Alg f a-\u003eCxt h f a a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:cata-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic catamorphism from the given monadic algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "cataM",
          "package": "compdata",
          "signature": "AlgM m f a -\u003e NatM m (Term f) a",
          "source": "src/Data-Comp-MultiParam-Algebra.html#cataM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic catamorphism from the given monadic algebra",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "cataM",
          "normalized": "AlgM a b c-\u003eNatM a(Term b)c",
          "package": "compdata",
          "signature": "AlgM m f a-\u003eNatM m(Term f)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:cataM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic catamorphism from the given monadic algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "cataM'",
          "package": "compdata",
          "signature": "AlgM' m f a -\u003e NatM m (Term f) a",
          "source": "src/Data-Comp-MultiParam-Algebra.html#cataM%27",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic catamorphism from the given monadic algebra",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "cataM'",
          "normalized": "AlgM' a b c-\u003eNatM a(Term b)c",
          "package": "compdata",
          "partial": "M'",
          "signature": "AlgM' m f a-\u003eNatM m(Term f)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:cataM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose an algebra with a term homomorphism to get a new algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "compAlg",
          "package": "compdata",
          "signature": "Alg g a -\u003e Hom f g -\u003e Alg f a",
          "source": "src/Data-Comp-MultiParam-Algebra.html#compAlg",
          "type": "function"
        },
        "index": {
          "description": "Compose an algebra with term homomorphism to get new algebra",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "compAlg",
          "normalized": "Alg a b-\u003eHom c a-\u003eAlg c b",
          "package": "compdata",
          "partial": "Alg",
          "signature": "Alg g a-\u003eHom f g-\u003eAlg f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:compAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose a monadic algebra with a monadic term homomorphism to get a new\n  monadic algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "compAlgM",
          "package": "compdata",
          "signature": "AlgM m g a -\u003e HomM m f g -\u003e AlgM m f a",
          "source": "src/Data-Comp-MultiParam-Algebra.html#compAlgM",
          "type": "function"
        },
        "index": {
          "description": "Compose monadic algebra with monadic term homomorphism to get new monadic algebra",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "compAlgM",
          "normalized": "AlgM a b c-\u003eHomM a d b-\u003eAlgM a d c",
          "package": "compdata",
          "partial": "Alg",
          "signature": "AlgM m g a-\u003eHomM m f g-\u003eAlgM m f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:compAlgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose a monadic algebra with a term homomorphism to get a new monadic\n  algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "compAlgM'",
          "package": "compdata",
          "signature": "AlgM m g a -\u003e Hom f g -\u003e AlgM m f a",
          "source": "src/Data-Comp-MultiParam-Algebra.html#compAlgM%27",
          "type": "function"
        },
        "index": {
          "description": "Compose monadic algebra with term homomorphism to get new monadic algebra",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "compAlgM'",
          "normalized": "AlgM a b c-\u003eHom d b-\u003eAlgM a d c",
          "package": "compdata",
          "partial": "Alg M'",
          "signature": "AlgM m g a-\u003eHom f g-\u003eAlgM m f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:compAlgM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose two term homomorphisms. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "compHom",
          "package": "compdata",
          "signature": "Hom g h -\u003e Hom f g -\u003e Hom f h",
          "source": "src/Data-Comp-MultiParam-Algebra.html#compHom",
          "type": "function"
        },
        "index": {
          "description": "Compose two term homomorphisms",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "compHom",
          "normalized": "Hom a b-\u003eHom c a-\u003eHom c b",
          "package": "compdata",
          "partial": "Hom",
          "signature": "Hom g h-\u003eHom f g-\u003eHom f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:compHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose two monadic term homomorphisms. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "compHomM",
          "package": "compdata",
          "signature": "HomM m g h -\u003e HomM m f g -\u003e HomM m f h",
          "source": "src/Data-Comp-MultiParam-Algebra.html#compHomM",
          "type": "function"
        },
        "index": {
          "description": "Compose two monadic term homomorphisms",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "compHomM",
          "normalized": "HomM a b c-\u003eHomM a d b-\u003eHomM a d c",
          "package": "compdata",
          "partial": "Hom",
          "signature": "HomM m g h-\u003eHomM m f g-\u003eHomM m f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:compHomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two signature functions. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "compSigFun",
          "package": "compdata",
          "signature": "SigFun g h -\u003e SigFun f g -\u003e SigFun f h",
          "source": "src/Data-Comp-MultiParam-Algebra.html#compSigFun",
          "type": "function"
        },
        "index": {
          "description": "This function composes two signature functions",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "compSigFun",
          "normalized": "SigFun a b-\u003eSigFun c a-\u003eSigFun c b",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFun g h-\u003eSigFun f g-\u003eSigFun f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:compSigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two monadic signature functions. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "compSigFunM",
          "package": "compdata",
          "signature": "SigFunM m g h -\u003e SigFunM m f g -\u003e SigFunM m f h",
          "source": "src/Data-Comp-MultiParam-Algebra.html#compSigFunM",
          "type": "function"
        },
        "index": {
          "description": "This function composes two monadic signature functions",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "compSigFunM",
          "normalized": "SigFunM a b c-\u003eSigFunM a d b-\u003eSigFunM a d c",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFunM m g h-\u003eSigFunM m f g-\u003eSigFunM m f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:compSigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a catamorphism for contexts over \u003ccode\u003ef\u003c/code\u003e with holes of type \u003ccode\u003eb\u003c/code\u003e, from\n  the given algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "free",
          "package": "compdata",
          "signature": "Alg f a -\u003e (b :-\u003e a) -\u003e Cxt h f a b :-\u003e a",
          "source": "src/Data-Comp-MultiParam-Algebra.html#free",
          "type": "function"
        },
        "index": {
          "description": "Construct catamorphism for contexts over with holes of type from the given algebra",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "free",
          "normalized": "Alg a b-\u003e(c-\u003eb)-\u003eCxt d a b c-\u003eb",
          "package": "compdata",
          "signature": "Alg f a-\u003e(b-\u003ea)-\u003eCxt h f a b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:free"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic catamorphism for contexts over \u003ccode\u003ef\u003c/code\u003e with holes of type\n  \u003ccode\u003eb\u003c/code\u003e, from the given monadic algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "freeM",
          "package": "compdata",
          "signature": "AlgM m f a -\u003e NatM m b a -\u003e NatM m (Cxt h f a b) a",
          "source": "src/Data-Comp-MultiParam-Algebra.html#freeM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic catamorphism for contexts over with holes of type from the given monadic algebra",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "freeM",
          "normalized": "AlgM a b c-\u003eNatM a d c-\u003eNatM a(Cxt e b c d)c",
          "package": "compdata",
          "signature": "AlgM m f a-\u003eNatM m b a-\u003eNatM m(Cxt h f a b)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:freeM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic catamorphism for contexts over \u003ccode\u003ef\u003c/code\u003e with holes of type\n  \u003ccode\u003eb\u003c/code\u003e, from the given monadic algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "freeM'",
          "package": "compdata",
          "signature": "AlgM' m f a -\u003e NatM m b a -\u003e NatM m (Cxt h f a b) a",
          "source": "src/Data-Comp-MultiParam-Algebra.html#freeM%27",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic catamorphism for contexts over with holes of type from the given monadic algebra",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "freeM'",
          "normalized": "AlgM' a b c-\u003eNatM a d c-\u003eNatM a(Cxt e b c d)c",
          "package": "compdata",
          "partial": "M'",
          "signature": "AlgM' m f a-\u003eNatM m b a-\u003eNatM m(Cxt h f a b)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:freeM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "getCompose",
          "package": "compdata",
          "signature": "f (g a)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "getCompose",
          "package": "compdata",
          "partial": "Compose",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:getCompose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLifts the given signature function to the canonical term homomorphism. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "hom",
          "package": "compdata",
          "signature": "SigFun f g -\u003e Hom f g",
          "source": "src/Data-Comp-MultiParam-Algebra.html#hom",
          "type": "function"
        },
        "index": {
          "description": "Lifts the given signature function to the canonical term homomorphism",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "hom",
          "normalized": "SigFun a b-\u003eHom a b",
          "package": "compdata",
          "signature": "SigFun f g-\u003eHom f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:hom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift the give monadic signature function to a monadic term homomorphism. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "hom'",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e HomM m f g",
          "source": "src/Data-Comp-MultiParam-Algebra.html#hom%27",
          "type": "function"
        },
        "index": {
          "description": "Lift the give monadic signature function to monadic term homomorphism",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "hom'",
          "normalized": "SigFunM a b c-\u003eHomM a b c",
          "package": "compdata",
          "signature": "SigFunM m f g-\u003eHomM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:hom-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift the given signature function to a monadic term homomorphism. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "homM",
          "package": "compdata",
          "signature": "SigFun f g -\u003e HomM m f g",
          "source": "src/Data-Comp-MultiParam-Algebra.html#homM",
          "type": "function"
        },
        "index": {
          "description": "Lift the given signature function to monadic term homomorphism",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "homM",
          "normalized": "SigFun a b-\u003eHomM c a b",
          "package": "compdata",
          "signature": "SigFun f g-\u003eHomM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:homM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift the given signature function to a monadic signature function. Note that\n  term homomorphisms are instances of signature functions. Hence this function\n  also applies to term homomorphisms. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "sigFunM",
          "package": "compdata",
          "signature": "SigFun f g -\u003e SigFunM m f g",
          "source": "src/Data-Comp-MultiParam-Algebra.html#sigFunM",
          "type": "function"
        },
        "index": {
          "description": "Lift the given signature function to monadic signature function Note that term homomorphisms are instances of signature functions Hence this function also applies to term homomorphisms",
          "hierarchy": "Data Comp MultiParam Algebra",
          "module": "Data.Comp.MultiParam.Algebra",
          "name": "sigFunM",
          "normalized": "SigFun a b-\u003eSigFunM c a b",
          "package": "compdata",
          "partial": "Fun",
          "signature": "SigFun f g-\u003eSigFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Algebra.html#v:sigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines annotations on signatures.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "Annotation",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Annotation.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines annotations on signatures",
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "Annotation",
          "package": "compdata",
          "partial": "Annotation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type adds a constant product to a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": ":&:",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ops.html#%3A%26%3A",
          "type": "data"
        },
        "index": {
          "description": "This data type adds constant product to signature",
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": ":&:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#t::-38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal product of signatures (higher-order difunctors).\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": ":*:",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ops.html#%3A%2A%3A",
          "type": "data"
        },
        "index": {
          "description": "Formal product of signatures higher-order difunctors",
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": ":*:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#t::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class defines how to distribute an annotation over a sum of\n  signatures. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "DistAnn",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ops.html#DistAnn",
          "type": "class"
        },
        "index": {
          "description": "This class defines how to distribute an annotation over sum of signatures",
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "DistAnn",
          "package": "compdata",
          "partial": "Dist Ann",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#t:DistAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "RemA",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ops.html#RemA",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "RemA",
          "package": "compdata",
          "partial": "Rem",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#t:RemA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.MultiParam.Annotation\",\"Data.Comp.MultiParam.Ops\"]",
          "name": ":&:",
          "package": "compdata",
          "signature": "(f a b i) :&: p",
          "source": "src/Data-Comp-MultiParam-Ops.html#%3A%26%3A",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#v::-38-:\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#v::-38-:\"]"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": ":&:",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#v::-38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.MultiParam.Annotation\",\"Data.Comp.MultiParam.Ops\"]",
          "name": ":*:",
          "package": "compdata",
          "signature": "(f a b) :*: (g a b)",
          "source": "src/Data-Comp-MultiParam-Ops.html#%3A%2A%3A",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#v::-42-:\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#v::-42-:\"]"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": ":*:",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#v::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnnotate each node of a term with a constant value. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "ann",
          "package": "compdata",
          "signature": "p -\u003e CxtFun f g",
          "source": "src/Data-Comp-MultiParam-Annotation.html#ann",
          "type": "function"
        },
        "index": {
          "description": "Annotate each node of term with constant value",
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "ann",
          "normalized": "a-\u003eCxtFun b c",
          "package": "compdata",
          "signature": "p-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#v:ann"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject an annotation over a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "injectA",
          "package": "compdata",
          "signature": "p -\u003e s a b :-\u003e s' a b",
          "source": "src/Data-Comp-MultiParam-Ops.html#injectA",
          "type": "method"
        },
        "index": {
          "description": "Inject an annotation over signature",
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "injectA",
          "normalized": "a-\u003eb c d-\u003ee c d",
          "package": "compdata",
          "signature": "p-\u003es a b-\u003es' a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#v:injectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform a function with a domain constructed from a higher-order difunctor\n  to a function with a domain constructed with the same higher-order difunctor,\n  but with an additional annotation. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "liftA",
          "package": "compdata",
          "signature": "(s' a b :-\u003e t) -\u003e s a b :-\u003e t",
          "source": "src/Data-Comp-MultiParam-Annotation.html#liftA",
          "type": "function"
        },
        "index": {
          "description": "Transform function with domain constructed from higher-order difunctor to function with domain constructed with the same higher-order difunctor but with an additional annotation",
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "liftA",
          "normalized": "(a b c-\u003ed)-\u003ee b c-\u003ed",
          "package": "compdata",
          "signature": "(s' a b-\u003et)-\u003es a b-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#v:liftA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform a function with a domain constructed from a higher-order difunctor\n  to a function with a domain constructed with the same higher-order difunctor,\n  but with an additional annotation. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "liftA'",
          "package": "compdata",
          "signature": "(s' a b :-\u003e Cxt h s' c d) -\u003e s a b :-\u003e Cxt h s c d",
          "source": "src/Data-Comp-MultiParam-Annotation.html#liftA%27",
          "type": "function"
        },
        "index": {
          "description": "Transform function with domain constructed from higher-order difunctor to function with domain constructed with the same higher-order difunctor but with an additional annotation",
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "liftA'",
          "normalized": "(a b c-\u003eCxt d a e f)-\u003eg b c-\u003eCxt d g e f",
          "package": "compdata",
          "partial": "A'",
          "signature": "(s' a b-\u003eCxt h s' c d)-\u003es a b-\u003eCxt h s c d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#v:liftA-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function is similar to \u003ccode\u003e\u003ca\u003eproject\u003c/a\u003e\u003c/code\u003e but applies to signatures\n  with an annotation which is then ignored. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "project'",
          "package": "compdata",
          "signature": "Cxt h f a b i -\u003e Maybe (s a (Cxt h f a b) i)",
          "source": "src/Data-Comp-MultiParam-Annotation.html#project%27",
          "type": "function"
        },
        "index": {
          "description": "This function is similar to project but applies to signatures with an annotation which is then ignored",
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "project'",
          "normalized": "Cxt a b c d e-\u003eMaybe(f c(Cxt a b c d)e)",
          "package": "compdata",
          "signature": "Cxt h f a b i-\u003eMaybe(s a(Cxt h f a b)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#v:project-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject an annotation from a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "projectA",
          "package": "compdata",
          "signature": "s' a b :-\u003e (s a b :&: p)",
          "source": "src/Data-Comp-MultiParam-Ops.html#projectA",
          "type": "method"
        },
        "index": {
          "description": "Project an annotation from signature",
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "projectA",
          "normalized": "a b c-\u003e(d b c e)",
          "package": "compdata",
          "signature": "s' a b-\u003e(s a b p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#v:projectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a term homomorphism over signatures \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e to a term homomorphism\n over the same signatures, but extended with annotations. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "propAnn",
          "package": "compdata",
          "signature": "Hom f g -\u003e Hom f' g'",
          "source": "src/Data-Comp-MultiParam-Annotation.html#propAnn",
          "type": "function"
        },
        "index": {
          "description": "Lift term homomorphism over signatures and to term homomorphism over the same signatures but extended with annotations",
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "propAnn",
          "normalized": "Hom a b-\u003eHom c d",
          "package": "compdata",
          "partial": "Ann",
          "signature": "Hom f g-\u003eHom f' g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#v:propAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a monadic term homomorphism over signatures \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e to a monadic\n  term homomorphism over the same signatures, but extended with annotations. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "propAnnM",
          "package": "compdata",
          "signature": "HomM m f g -\u003e HomM m f' g'",
          "source": "src/Data-Comp-MultiParam-Annotation.html#propAnnM",
          "type": "function"
        },
        "index": {
          "description": "Lift monadic term homomorphism over signatures and to monadic term homomorphism over the same signatures but extended with annotations",
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "propAnnM",
          "normalized": "HomM a b c-\u003eHomM a d e",
          "package": "compdata",
          "partial": "Ann",
          "signature": "HomM m f g-\u003eHomM m f' g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#v:propAnnM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove annotations from a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "remA",
          "package": "compdata",
          "signature": "s a b :-\u003e s' a b",
          "source": "src/Data-Comp-MultiParam-Ops.html#remA",
          "type": "method"
        },
        "index": {
          "description": "Remove annotations from signature",
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "remA",
          "normalized": "a b c-\u003ed b c",
          "package": "compdata",
          "signature": "s a b-\u003es' a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#v:remA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrip the annotations from a term over a higher-order difunctor with\n  annotations. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "stripA",
          "package": "compdata",
          "signature": "CxtFun g f",
          "source": "src/Data-Comp-MultiParam-Annotation.html#stripA",
          "type": "function"
        },
        "index": {
          "description": "Strip the annotations from term over higher-order difunctor with annotations",
          "hierarchy": "Data Comp MultiParam Annotation",
          "module": "Data.Comp.MultiParam.Annotation",
          "name": "stripA",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Annotation.html#v:stripA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains functionality for automatically deriving boilerplate\n code using Template Haskell. Examples include instances of \u003ccode\u003e\u003ca\u003eHDifunctor\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eShowHD\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eEqHD\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "Derive",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Derive.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains functionality for automatically deriving boilerplate code using Template Haskell Examples include instances of HDifunctor ShowHD and EqHD",
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "Derive",
          "package": "compdata",
          "partial": "Derive",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature equality. An instance \u003ccode\u003eEqHD f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eEq (Term f i)\u003c/code\u003e. The equality test is performed inside the \u003ccode\u003e\u003ca\u003eFreshM\u003c/a\u003e\u003c/code\u003e monad for\n  generating fresh identifiers. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "EqHD",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Equality.html#EqHD",
          "type": "class"
        },
        "index": {
          "description": "Signature equality An instance EqHD gives rise to an instance Eq Term The equality test is performed inside the FreshM monad for generating fresh identifiers",
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "EqHD",
          "package": "compdata",
          "partial": "Eq HD",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#t:EqHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class represents higher-order difunctors.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "HDifunctor",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-HDifunctor.html#HDifunctor",
          "type": "class"
        },
        "index": {
          "description": "This class represents higher-order difunctors",
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "HDifunctor",
          "package": "compdata",
          "partial": "HDifunctor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#t:HDifunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature ordering. An instance \u003ccode\u003eOrdHD f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eOrd (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "OrdHD",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ordering.html#OrdHD",
          "type": "class"
        },
        "index": {
          "description": "Signature ordering An instance OrdHD gives rise to an instance Ord Term",
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "OrdHD",
          "package": "compdata",
          "partial": "Ord HD",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#t:OrdHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature printing. An instance \u003ccode\u003eShowHD f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eShow (Term f i)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "ShowHD",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Derive-Show.html#ShowHD",
          "type": "class"
        },
        "index": {
          "description": "Signature printing An instance ShowHD gives rise to an instance Show Term",
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "ShowHD",
          "package": "compdata",
          "partial": "Show HD",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#t:ShowHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Derive",
          "name": "compareHD",
          "package": "compdata",
          "signature": "f Name a i -\u003e f Name a j -\u003e FreshM Ordering",
          "source": "src/Data-Comp-MultiParam-Ordering.html#compareHD",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "compareHD",
          "normalized": "a Name b c-\u003ea Name b d-\u003eFreshM Ordering",
          "package": "compdata",
          "partial": "HD",
          "signature": "f Name a i-\u003ef Name a j-\u003eFreshM Ordering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#v:compareHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Derive",
          "name": "eqHD",
          "package": "compdata",
          "signature": "f Name a i -\u003e f Name a j -\u003e FreshM Bool",
          "source": "src/Data-Comp-MultiParam-Equality.html#eqHD",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "eqHD",
          "normalized": "a Name b c-\u003ea Name b d-\u003eFreshM Bool",
          "package": "compdata",
          "partial": "HD",
          "signature": "f Name a i-\u003ef Name a j-\u003eFreshM Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#v:eqHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven the name of a type class, where the first parameter is a higher-order\n  difunctor, lift it to sums of higher-order difunctors. Example:\n  \u003ccode\u003eclass ShowHD f where ...\u003c/code\u003e is lifted as\n  \u003ccode\u003einstance (ShowHD f, ShowHD g) =\u003e ShowHD (f :+: g) where ... \u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "liftSum",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-MultiParam-Derive.html#liftSum",
          "type": "function"
        },
        "index": {
          "description": "Given the name of type class where the first parameter is higher-order difunctor lift it to sums of higher-order difunctors Example class ShowHD where is lifted as instance ShowHD ShowHD ShowHD where",
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "liftSum",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Sum",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#v:liftSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eEqHD\u003c/a\u003e\u003c/code\u003e for a type constructor of any parametric\n  kind taking at least three arguments. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "makeEqHD",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-MultiParam-Derive-Equality.html#makeEqHD",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of EqHD for type constructor of any parametric kind taking at least three arguments",
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "makeEqHD",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Eq HD",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#v:makeEqHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eHDifunctor\u003c/a\u003e\u003c/code\u003e for a type constructor of any parametric\n  kind taking at least three arguments. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "makeHDifunctor",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-MultiParam-Derive-HDifunctor.html#makeHDifunctor",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of HDifunctor for type constructor of any parametric kind taking at least three arguments",
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "makeHDifunctor",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "HDifunctor",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#v:makeHDifunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eOrdHD\u003c/a\u003e\u003c/code\u003e for a type constructor of any parametric\n  kind taking at least three arguments. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "makeOrdHD",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-MultiParam-Derive-Ordering.html#makeOrdHD",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of OrdHD for type constructor of any parametric kind taking at least three arguments",
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "makeOrdHD",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Ord HD",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#v:makeOrdHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eShowHD\u003c/a\u003e\u003c/code\u003e for a type constructor of any parametric\n  kind taking at least three arguments. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "makeShowHD",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-MultiParam-Derive-Show.html#makeShowHD",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of ShowHD for type constructor of any parametric kind taking at least three arguments",
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "makeShowHD",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Show HD",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#v:makeShowHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Derive",
          "name": "showHD",
          "package": "compdata",
          "signature": "f Name (K (FreshM String)) i -\u003e FreshM String",
          "source": "src/Data-Comp-MultiParam-Derive-Show.html#showHD",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "showHD",
          "normalized": "a Name(K(FreshM String))b-\u003eFreshM String",
          "package": "compdata",
          "partial": "HD",
          "signature": "f Name(K(FreshM String))i-\u003eFreshM String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#v:showHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive smart constructors with annotations for a higher-order difunctor. The\n smart constructors are similar to the ordinary constructors, but a\n 'injectA . hdimap Var id' is automatically inserted. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "smartAConstructors",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-MultiParam-Derive-SmartAConstructors.html#smartAConstructors",
          "type": "function"
        },
        "index": {
          "description": "Derive smart constructors with annotations for higher-order difunctor The smart constructors are similar to the ordinary constructors but injectA hdimap Var id is automatically inserted",
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "smartAConstructors",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "AConstructors",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#v:smartAConstructors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive smart constructors for a higher-order difunctor. The smart\n constructors are similar to the ordinary constructors, but a\n 'inject . hdimap Var id' is automatically inserted. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "smartConstructors",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-MultiParam-Derive-SmartConstructors.html#smartConstructors",
          "type": "function"
        },
        "index": {
          "description": "Derive smart constructors for higher-order difunctor The smart constructors are similar to the ordinary constructors but inject hdimap Var id is automatically inserted",
          "hierarchy": "Data Comp MultiParam Derive",
          "module": "Data.Comp.MultiParam.Derive",
          "name": "smartConstructors",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Constructors",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Derive.html#v:smartConstructors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis modules defines the \u003ccode\u003e\u003ca\u003eDesugar\u003c/a\u003e\u003c/code\u003e type class for desugaring of terms.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MultiParam.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Desugar.html",
          "type": "module"
        },
        "index": {
          "description": "This modules defines the Desugar type class for desugaring of terms",
          "hierarchy": "Data Comp MultiParam Desugar",
          "module": "Data.Comp.MultiParam.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "partial": "Desugar",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Desugar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe desugaring term homomorphism.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Desugar.html#Desugar",
          "type": "class"
        },
        "index": {
          "description": "The desugaring term homomorphism",
          "hierarchy": "Data Comp MultiParam Desugar",
          "module": "Data.Comp.MultiParam.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "partial": "Desugar",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Desugar.html#t:Desugar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Desugar",
          "name": "desugHom",
          "package": "compdata",
          "signature": "Hom f g",
          "source": "src/Data-Comp-MultiParam-Desugar.html#desugHom",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Desugar",
          "module": "Data.Comp.MultiParam.Desugar",
          "name": "desugHom",
          "package": "compdata",
          "partial": "Hom",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Desugar.html#v:desugHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Desugar",
          "name": "desugHom'",
          "package": "compdata",
          "signature": "f a (Cxt h g a b) :-\u003e Cxt h g a b",
          "source": "src/Data-Comp-MultiParam-Desugar.html#desugHom%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Desugar",
          "module": "Data.Comp.MultiParam.Desugar",
          "name": "desugHom'",
          "normalized": "a b(Cxt c d b e)-\u003eCxt c d b e",
          "package": "compdata",
          "partial": "Hom'",
          "signature": "f a(Cxt h g a b)-\u003eCxt h g a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Desugar.html#v:desugHom-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDesugar a term.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Desugar",
          "name": "desugar",
          "package": "compdata",
          "signature": "Term f :-\u003e Term g",
          "source": "src/Data-Comp-MultiParam-Desugar.html#desugar",
          "type": "function"
        },
        "index": {
          "description": "Desugar term",
          "hierarchy": "Data Comp MultiParam Desugar",
          "module": "Data.Comp.MultiParam.Desugar",
          "name": "desugar",
          "normalized": "Term a-\u003eTerm b",
          "package": "compdata",
          "signature": "Term f-\u003eTerm g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Desugar.html#v:desugar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift desugaring to annotated terms.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Desugar",
          "name": "desugarA",
          "package": "compdata",
          "signature": "Term f' :-\u003e Term g'",
          "source": "src/Data-Comp-MultiParam-Desugar.html#desugarA",
          "type": "function"
        },
        "index": {
          "description": "Lift desugaring to annotated terms",
          "hierarchy": "Data Comp MultiParam Desugar",
          "module": "Data.Comp.MultiParam.Desugar",
          "name": "desugarA",
          "normalized": "Term a-\u003eTerm b",
          "package": "compdata",
          "signature": "Term f'-\u003eTerm g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Desugar.html#v:desugarA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines equality for signatures, which lifts to equality for\n terms.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MultiParam.Equality",
          "name": "Equality",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Equality.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines equality for signatures which lifts to equality for terms",
          "hierarchy": "Data Comp MultiParam Equality",
          "module": "Data.Comp.MultiParam.Equality",
          "name": "Equality",
          "package": "compdata",
          "partial": "Equality",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Equality.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature equality. An instance \u003ccode\u003eEqHD f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eEq (Term f i)\u003c/code\u003e. The equality test is performed inside the \u003ccode\u003e\u003ca\u003eFreshM\u003c/a\u003e\u003c/code\u003e monad for\n  generating fresh identifiers. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Equality",
          "name": "EqHD",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Equality.html#EqHD",
          "type": "class"
        },
        "index": {
          "description": "Signature equality An instance EqHD gives rise to an instance Eq Term The equality test is performed inside the FreshM monad for generating fresh identifiers",
          "hierarchy": "Data Comp MultiParam Equality",
          "module": "Data.Comp.MultiParam.Equality",
          "name": "EqHD",
          "package": "compdata",
          "partial": "Eq HD",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Equality.html#t:EqHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquality on parametric values. The equality test is performed inside the\n \u003ccode\u003e\u003ca\u003eFreshM\u003c/a\u003e\u003c/code\u003e monad for generating fresh identifiers.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Equality",
          "name": "PEq",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Equality.html#PEq",
          "type": "class"
        },
        "index": {
          "description": "Equality on parametric values The equality test is performed inside the FreshM monad for generating fresh identifiers",
          "hierarchy": "Data Comp MultiParam Equality",
          "module": "Data.Comp.MultiParam.Equality",
          "name": "PEq",
          "package": "compdata",
          "partial": "PEq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Equality.html#t:PEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Equality",
          "name": "eqHD",
          "package": "compdata",
          "signature": "f Name a i -\u003e f Name a j -\u003e FreshM Bool",
          "source": "src/Data-Comp-MultiParam-Equality.html#eqHD",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Equality",
          "module": "Data.Comp.MultiParam.Equality",
          "name": "eqHD",
          "normalized": "a Name b c-\u003ea Name b d-\u003eFreshM Bool",
          "package": "compdata",
          "partial": "HD",
          "signature": "f Name a i-\u003ef Name a j-\u003eFreshM Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Equality.html#v:eqHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Equality",
          "name": "peq",
          "package": "compdata",
          "signature": "a i -\u003e a j -\u003e FreshM Bool",
          "source": "src/Data-Comp-MultiParam-Equality.html#peq",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Equality",
          "module": "Data.Comp.MultiParam.Equality",
          "name": "peq",
          "normalized": "a b-\u003ea c-\u003eFreshM Bool",
          "package": "compdata",
          "signature": "a i-\u003ea j-\u003eFreshM Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Equality.html#v:peq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines a monad for generating fresh, abstract names, useful\n e.g. for defining equality on terms.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MultiParam.FreshM",
          "name": "FreshM",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-FreshM.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines monad for generating fresh abstract names useful e.g for defining equality on terms",
          "hierarchy": "Data Comp MultiParam FreshM",
          "module": "Data.Comp.MultiParam.FreshM",
          "name": "FreshM",
          "package": "compdata",
          "partial": "Fresh",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-FreshM.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonad for generating fresh (abstract) names.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.FreshM",
          "name": "FreshM",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-FreshM.html#FreshM",
          "type": "data"
        },
        "index": {
          "description": "Monad for generating fresh abstract names",
          "hierarchy": "Data Comp MultiParam FreshM",
          "module": "Data.Comp.MultiParam.FreshM",
          "name": "FreshM",
          "package": "compdata",
          "partial": "Fresh",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-FreshM.html#t:FreshM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract notion of a name (the constructor is hidden).\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.FreshM",
          "name": "Name",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-FreshM.html#Name",
          "type": "data"
        },
        "index": {
          "description": "Abstract notion of name the constructor is hidden",
          "hierarchy": "Data Comp MultiParam FreshM",
          "module": "Data.Comp.MultiParam.FreshM",
          "name": "Name",
          "package": "compdata",
          "partial": "Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-FreshM.html#t:Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate a computation that uses fresh names.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.FreshM",
          "name": "evalFreshM",
          "package": "compdata",
          "signature": "FreshM a -\u003e a",
          "source": "src/Data-Comp-MultiParam-FreshM.html#evalFreshM",
          "type": "function"
        },
        "index": {
          "description": "Evaluate computation that uses fresh names",
          "hierarchy": "Data Comp MultiParam FreshM",
          "module": "Data.Comp.MultiParam.FreshM",
          "name": "evalFreshM",
          "normalized": "FreshM a-\u003ea",
          "package": "compdata",
          "partial": "Fresh",
          "signature": "FreshM a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-FreshM.html#v:evalFreshM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange the type tag of a name.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.FreshM",
          "name": "nameCoerce",
          "package": "compdata",
          "signature": "Name i -\u003e Name j",
          "source": "src/Data-Comp-MultiParam-FreshM.html#nameCoerce",
          "type": "function"
        },
        "index": {
          "description": "Change the type tag of name",
          "hierarchy": "Data Comp MultiParam FreshM",
          "module": "Data.Comp.MultiParam.FreshM",
          "name": "nameCoerce",
          "normalized": "Name a-\u003eName b",
          "package": "compdata",
          "partial": "Coerce",
          "signature": "Name i-\u003eName j",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-FreshM.html#v:nameCoerce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun the given computation with the next available name.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.FreshM",
          "name": "withName",
          "package": "compdata",
          "signature": "(Name i -\u003e FreshM a) -\u003e FreshM a",
          "source": "src/Data-Comp-MultiParam-FreshM.html#withName",
          "type": "function"
        },
        "index": {
          "description": "Run the given computation with the next available name",
          "hierarchy": "Data Comp MultiParam FreshM",
          "module": "Data.Comp.MultiParam.FreshM",
          "name": "withName",
          "normalized": "(Name a-\u003eFreshM b)-\u003eFreshM b",
          "package": "compdata",
          "partial": "Name",
          "signature": "(Name i-\u003eFreshM a)-\u003eFreshM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-FreshM.html#v:withName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines higher-order difunctors, a hybrid between higher-order\n functors (Johann, Ghani, POPL '08), and difunctors (Meijer, Hutton, FPCA\n '95). Higher-order difunctors are used to define signatures for\n compositional parametric generalised data types.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "HDifunctor",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-HDifunctor.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines higher-order difunctors hybrid between higher-order functors Johann Ghani POPL and difunctors Meijer Hutton FPCA Higher-order difunctors are used to define signatures for compositional parametric generalised data types",
          "hierarchy": "Data Comp MultiParam HDifunctor",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "HDifunctor",
          "package": "compdata",
          "partial": "HDifunctor",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents natural transformations.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": ":-\u003e",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#%3A-%3E",
          "type": "type"
        },
        "index": {
          "description": "This type represents natural transformations",
          "hierarchy": "Data Comp MultiParam HDifunctor",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": ":-\u003e",
          "package": "compdata",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#t::-45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "A",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#A",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam HDifunctor",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "A",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#t:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "E",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#E",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam HDifunctor",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "E",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#t:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class represents higher-order difunctors.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "HDifunctor",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-HDifunctor.html#HDifunctor",
          "type": "class"
        },
        "index": {
          "description": "This class represents higher-order difunctors",
          "hierarchy": "Data Comp MultiParam HDifunctor",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "HDifunctor",
          "package": "compdata",
          "partial": "HDifunctor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#t:HDifunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class represents higher-order functors (Johann, Ghani, POPL\n '08) which are endofunctors on the category of endofunctors.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "HFunctor",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#HFunctor",
          "type": "class"
        },
        "index": {
          "description": "This class represents higher-order functors Johann Ghani POPL which are endofunctors on the category of endofunctors",
          "hierarchy": "Data Comp MultiParam HDifunctor",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "HFunctor",
          "package": "compdata",
          "partial": "HFunctor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#t:HFunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity Functor.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "I",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#I",
          "type": "newtype"
        },
        "index": {
          "description": "The identity Functor",
          "hierarchy": "Data Comp MultiParam HDifunctor",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "I",
          "package": "compdata",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#t:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe parametrised constant functor.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "K",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#K",
          "type": "newtype"
        },
        "index": {
          "description": "The parametrised constant functor",
          "hierarchy": "Data Comp MultiParam HDifunctor",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "K",
          "package": "compdata",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#t:K"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "NatM",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HFunctor.html#NatM",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam HDifunctor",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "NatM",
          "package": "compdata",
          "partial": "Nat",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#t:NatM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "hdimap",
          "package": "compdata",
          "signature": "(a :-\u003e b) -\u003e (c :-\u003e d) -\u003e f b c :-\u003e f a d",
          "source": "src/Data-Comp-MultiParam-HDifunctor.html#hdimap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam HDifunctor",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "hdimap",
          "normalized": "(a-\u003eb)-\u003e(c-\u003ed)-\u003ee b c-\u003ee a d",
          "package": "compdata",
          "signature": "(a-\u003eb)-\u003e(c-\u003ed)-\u003ef b c-\u003ef a d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#v:hdimap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA higher-order functor \u003ccode\u003ef\u003c/code\u003e also maps a natural transformation\n \u003ccode\u003eg :-\u003e h\u003c/code\u003e to a natural transformation \u003ccode\u003ef g :-\u003e f h\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "hfmap",
          "package": "compdata",
          "signature": "(f :-\u003e g) -\u003e h f :-\u003e h g",
          "source": "src/Data-Comp-Multi-HFunctor.html#hfmap",
          "type": "method"
        },
        "index": {
          "description": "higher-order functor also maps natural transformation to natural transformation",
          "hierarchy": "Data Comp MultiParam HDifunctor",
          "module": "Data.Comp.MultiParam.HDifunctor",
          "name": "hfmap",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "compdata",
          "signature": "(f-\u003eg)-\u003eh f-\u003eh g",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDifunctor.html#v:hfmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines traversable higher-order difunctors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MultiParam.HDitraversable",
          "name": "HDitraversable",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-HDitraversable.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines traversable higher-order difunctors",
          "hierarchy": "Data Comp MultiParam HDitraversable",
          "module": "Data.Comp.MultiParam.HDitraversable",
          "name": "HDitraversable",
          "package": "compdata",
          "partial": "HDitraversable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDitraversable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHDifunctors representing data structures that can be traversed from left to\n  right. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.HDitraversable",
          "name": "HDitraversable",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-HDitraversable.html#HDitraversable",
          "type": "class"
        },
        "index": {
          "description": "HDifunctors representing data structures that can be traversed from left to right",
          "hierarchy": "Data Comp MultiParam HDitraversable",
          "module": "Data.Comp.MultiParam.HDitraversable",
          "name": "HDitraversable",
          "package": "compdata",
          "partial": "HDitraversable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDitraversable.html#t:HDitraversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.HDitraversable",
          "name": "HTraversable",
          "package": "compdata",
          "source": "src/Data-Comp-Multi-HTraversable.html#HTraversable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam HDitraversable",
          "module": "Data.Comp.MultiParam.HDitraversable",
          "name": "HTraversable",
          "package": "compdata",
          "partial": "HTraversable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDitraversable.html#t:HTraversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.HDitraversable",
          "name": "hdimapM",
          "package": "compdata",
          "signature": "NatM m b c -\u003e NatM m (f a b) (f a c)",
          "source": "src/Data-Comp-MultiParam-HDitraversable.html#hdimapM",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam HDitraversable",
          "module": "Data.Comp.MultiParam.HDitraversable",
          "name": "hdimapM",
          "normalized": "NatM a b c-\u003eNatM a(d e b)(d e c)",
          "package": "compdata",
          "signature": "NatM m b c-\u003eNatM m(f a b)(f a c)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDitraversable.html#v:hdimapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure to a monadic action, evaluate\n these actions from left to right, and collect the results.\n\u003c/p\u003e\u003cp\u003eAlternative type in terms of natural transformations using\n functor composition \u003ccode\u003e:.:\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003ehmapM :: Monad m =\u003e (a :-\u003e m :.: b) -\u003e t a :-\u003e m :.: (t b)\u003c/pre\u003e",
          "module": "Data.Comp.MultiParam.HDitraversable",
          "name": "hmapM",
          "package": "compdata",
          "signature": "NatM m a b -\u003e NatM m (t a) (t b)",
          "source": "src/Data-Comp-Multi-HTraversable.html#hmapM",
          "type": "method"
        },
        "index": {
          "description": "Map each element of structure to monadic action evaluate these actions from left to right and collect the results Alternative type in terms of natural transformations using functor composition hmapM Monad",
          "hierarchy": "Data Comp MultiParam HDitraversable",
          "module": "Data.Comp.MultiParam.HDitraversable",
          "name": "hmapM",
          "normalized": "NatM a b c-\u003eNatM a(d b)(d c)",
          "package": "compdata",
          "signature": "NatM m a b-\u003eNatM m(t a)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDitraversable.html#v:hmapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.HDitraversable",
          "name": "htraverse",
          "package": "compdata",
          "signature": "NatM f a b -\u003e NatM f (t a) (t b)",
          "source": "src/Data-Comp-Multi-HTraversable.html#htraverse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam HDitraversable",
          "module": "Data.Comp.MultiParam.HDitraversable",
          "name": "htraverse",
          "normalized": "NatM a b c-\u003eNatM a(d b)(d c)",
          "package": "compdata",
          "signature": "NatM f a b-\u003eNatM f(t a)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-HDitraversable.html#v:htraverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides operators on higher-order difunctors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "Ops",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ops.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides operators on higher-order difunctors",
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "Ops",
          "package": "compdata",
          "partial": "Ops",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type adds a constant product to a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Ops",
          "name": ":&:",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ops.html#%3A%26%3A",
          "type": "data"
        },
        "index": {
          "description": "This data type adds constant product to signature",
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": ":&:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#t::-38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal product of signatures (higher-order difunctors).\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Ops",
          "name": ":*:",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ops.html#%3A%2A%3A",
          "type": "data"
        },
        "index": {
          "description": "Formal product of signatures higher-order difunctors",
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": ":*:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#t::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal sum of signatures (difunctors).\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Ops",
          "name": ":+:",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ops.html#%3A%2B%3A",
          "type": "data"
        },
        "index": {
          "description": "Formal sum of signatures difunctors",
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": ":+:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#t::-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature containment relation for automatic injections. The left-hand must\n be an atomic signature, where as the right-hand side must have a list-like\n structure. Examples include \u003ccode\u003ef :\u003c: f :+: g\u003c/code\u003e and \u003ccode\u003eg :\u003c: f :+: (g :+: h)\u003c/code\u003e,\n non-examples include \u003ccode\u003ef :+: g :\u003c: f :+: (g :+: h)\u003c/code\u003e and\n \u003ccode\u003ef :\u003c: (f :+: g) :+: h\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Ops",
          "name": ":\u003c:",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ops.html#%3A%3C%3A",
          "type": "class"
        },
        "index": {
          "description": "Signature containment relation for automatic injections The left-hand must be an atomic signature where as the right-hand side must have list-like structure Examples include and non-examples include and",
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": ":\u003c:",
          "package": "compdata",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#t::-60-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class defines how to distribute an annotation over a sum of\n  signatures. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "DistAnn",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ops.html#DistAnn",
          "type": "class"
        },
        "index": {
          "description": "This class defines how to distribute an annotation over sum of signatures",
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "DistAnn",
          "package": "compdata",
          "partial": "Dist Ann",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#t:DistAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Ops",
          "name": "RemA",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ops.html#RemA",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "RemA",
          "package": "compdata",
          "partial": "Rem",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#t:RemA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Ops",
          "name": "Inl",
          "package": "compdata",
          "signature": "Inl (f a b i)",
          "source": "src/Data-Comp-MultiParam-Ops.html#%3A%2B%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "Inl",
          "package": "compdata",
          "partial": "Inl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#v:Inl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Ops",
          "name": "Inr",
          "package": "compdata",
          "signature": "Inr (g a b i)",
          "source": "src/Data-Comp-MultiParam-Ops.html#%3A%2B%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "Inr",
          "package": "compdata",
          "partial": "Inr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#v:Inr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUtility function to case on a higher-order difunctor sum, without exposing\n  the internal representation of sums. \n\u003c/p\u003e",
          "module": "[\"Data.Comp.MultiParam.Ops\",\"Data.Comp.MultiParam.Sum\"]",
          "name": "caseHD",
          "package": "compdata",
          "signature": "(f a b i -\u003e c) -\u003e (g a b i -\u003e c) -\u003e (f :+: g) a b i -\u003e c",
          "source": "src/Data-Comp-MultiParam-Ops.html#caseHD",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#v:caseHD\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:caseHD\"]"
        },
        "index": {
          "description": "Utility function to case on higher-order difunctor sum without exposing the internal representation of sums",
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "caseHD",
          "normalized": "(a b c d-\u003ee)-\u003e(f b c d-\u003ee)-\u003e(a f)b c d-\u003ee",
          "package": "compdata",
          "partial": "HD",
          "signature": "(f a b i-\u003ec)-\u003e(g a b i-\u003ec)-\u003e(f g)a b i-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#v:caseHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Ops",
          "name": "ffst",
          "package": "compdata",
          "signature": "(f :*: g) a b -\u003e f a b",
          "source": "src/Data-Comp-MultiParam-Ops.html#ffst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "ffst",
          "normalized": "(a*b)c d-\u003ea c d",
          "package": "compdata",
          "signature": "(f*g)a b-\u003ef a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#v:ffst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Ops",
          "name": "fsnd",
          "package": "compdata",
          "signature": "(f :*: g) a b -\u003e g a b",
          "source": "src/Data-Comp-MultiParam-Ops.html#fsnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "fsnd",
          "normalized": "(a*b)c d-\u003eb c d",
          "package": "compdata",
          "signature": "(f*g)a b-\u003eg a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#v:fsnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Ops",
          "name": "inj",
          "package": "compdata",
          "signature": "sub a b :-\u003e sup a b",
          "source": "src/Data-Comp-MultiParam-Ops.html#inj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "inj",
          "normalized": "a b c-\u003ed b c",
          "package": "compdata",
          "signature": "sub a b-\u003esup a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#v:inj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject an annotation over a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "injectA",
          "package": "compdata",
          "signature": "p -\u003e s a b :-\u003e s' a b",
          "source": "src/Data-Comp-MultiParam-Ops.html#injectA",
          "type": "method"
        },
        "index": {
          "description": "Inject an annotation over signature",
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "injectA",
          "normalized": "a-\u003eb c d-\u003ee c d",
          "package": "compdata",
          "signature": "p-\u003es a b-\u003es' a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#v:injectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Ops",
          "name": "proj",
          "package": "compdata",
          "signature": "NatM Maybe (sup a b) (sub a b)",
          "source": "src/Data-Comp-MultiParam-Ops.html#proj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "proj",
          "package": "compdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#v:proj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject an annotation from a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "projectA",
          "package": "compdata",
          "signature": "s' a b :-\u003e (s a b :&: p)",
          "source": "src/Data-Comp-MultiParam-Ops.html#projectA",
          "type": "method"
        },
        "index": {
          "description": "Project an annotation from signature",
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "projectA",
          "normalized": "a b c-\u003e(d b c e)",
          "package": "compdata",
          "signature": "s' a b-\u003e(s a b p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#v:projectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove annotations from a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "remA",
          "package": "compdata",
          "signature": "s a b :-\u003e s' a b",
          "source": "src/Data-Comp-MultiParam-Ops.html#remA",
          "type": "method"
        },
        "index": {
          "description": "Remove annotations from signature",
          "hierarchy": "Data Comp MultiParam Ops",
          "module": "Data.Comp.MultiParam.Ops",
          "name": "remA",
          "normalized": "a b c-\u003ed b c",
          "package": "compdata",
          "signature": "s a b-\u003es' a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ops.html#v:remA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines ordering of signatures, which lifts to ordering of\n terms and contexts.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MultiParam.Ordering",
          "name": "Ordering",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ordering.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines ordering of signatures which lifts to ordering of terms and contexts",
          "hierarchy": "Data Comp MultiParam Ordering",
          "module": "Data.Comp.MultiParam.Ordering",
          "name": "Ordering",
          "package": "compdata",
          "partial": "Ordering",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ordering.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature ordering. An instance \u003ccode\u003eOrdHD f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eOrd (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Ordering",
          "name": "OrdHD",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ordering.html#OrdHD",
          "type": "class"
        },
        "index": {
          "description": "Signature ordering An instance OrdHD gives rise to an instance Ord Term",
          "hierarchy": "Data Comp MultiParam Ordering",
          "module": "Data.Comp.MultiParam.Ordering",
          "name": "OrdHD",
          "package": "compdata",
          "partial": "Ord HD",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ordering.html#t:OrdHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdering of parametric values.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Ordering",
          "name": "POrd",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ordering.html#POrd",
          "type": "class"
        },
        "index": {
          "description": "Ordering of parametric values",
          "hierarchy": "Data Comp MultiParam Ordering",
          "module": "Data.Comp.MultiParam.Ordering",
          "name": "POrd",
          "package": "compdata",
          "partial": "POrd",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ordering.html#t:POrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Ordering",
          "name": "compareHD",
          "package": "compdata",
          "signature": "f Name a i -\u003e f Name a j -\u003e FreshM Ordering",
          "source": "src/Data-Comp-MultiParam-Ordering.html#compareHD",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Ordering",
          "module": "Data.Comp.MultiParam.Ordering",
          "name": "compareHD",
          "normalized": "a Name b c-\u003ea Name b d-\u003eFreshM Ordering",
          "package": "compdata",
          "partial": "HD",
          "signature": "f Name a i-\u003ef Name a j-\u003eFreshM Ordering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ordering.html#v:compareHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Ordering",
          "name": "pcompare",
          "package": "compdata",
          "signature": "a i -\u003e a j -\u003e FreshM Ordering",
          "source": "src/Data-Comp-MultiParam-Ordering.html#pcompare",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Ordering",
          "module": "Data.Comp.MultiParam.Ordering",
          "name": "pcompare",
          "normalized": "a b-\u003ea c-\u003eFreshM Ordering",
          "package": "compdata",
          "signature": "a i-\u003ea j-\u003eFreshM Ordering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Ordering.html#v:pcompare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines showing of signatures, which lifts to showing of terms.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MultiParam.Show",
          "name": "Show",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Show.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines showing of signatures which lifts to showing of terms",
          "hierarchy": "Data Comp MultiParam Show",
          "module": "Data.Comp.MultiParam.Show",
          "name": "Show",
          "package": "compdata",
          "partial": "Show",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Show.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature printing. An instance \u003ccode\u003eShowHD f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eShow (Term f i)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Show",
          "name": "ShowHD",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Derive-Show.html#ShowHD",
          "type": "class"
        },
        "index": {
          "description": "Signature printing An instance ShowHD gives rise to an instance Show Term",
          "hierarchy": "Data Comp MultiParam Show",
          "module": "Data.Comp.MultiParam.Show",
          "name": "ShowHD",
          "package": "compdata",
          "partial": "Show HD",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Show.html#t:ShowHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Show",
          "name": "showHD",
          "package": "compdata",
          "signature": "f Name (K (FreshM String)) i -\u003e FreshM String",
          "source": "src/Data-Comp-MultiParam-Derive-Show.html#showHD",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Show",
          "module": "Data.Comp.MultiParam.Show",
          "name": "showHD",
          "normalized": "a Name(K(FreshM String))b-\u003eFreshM String",
          "package": "compdata",
          "partial": "HD",
          "signature": "f Name(K(FreshM String))i-\u003eFreshM String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Show.html#v:showHD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides the infrastructure to extend signatures.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "Sum",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Sum.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides the infrastructure to extend signatures",
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "Sum",
          "package": "compdata",
          "partial": "Sum",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal sum of signatures (difunctors).\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Sum",
          "name": ":+:",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ops.html#%3A%2B%3A",
          "type": "data"
        },
        "index": {
          "description": "Formal sum of signatures difunctors",
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": ":+:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#t::-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature containment relation for automatic injections. The left-hand must\n be an atomic signature, where as the right-hand side must have a list-like\n structure. Examples include \u003ccode\u003ef :\u003c: f :+: g\u003c/code\u003e and \u003ccode\u003eg :\u003c: f :+: (g :+: h)\u003c/code\u003e,\n non-examples include \u003ccode\u003ef :+: g :\u003c: f :+: (g :+: h)\u003c/code\u003e and\n \u003ccode\u003ef :\u003c: (f :+: g) :+: h\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Sum",
          "name": ":\u003c:",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Ops.html#%3A%3C%3A",
          "type": "class"
        },
        "index": {
          "description": "Signature containment relation for automatic injections The left-hand must be an atomic signature where as the right-hand side must have list-like structure Examples include and non-examples include and",
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": ":\u003c:",
          "package": "compdata",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#t::-60-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject a term over a sub signature to a term over larger signature. If the\n signature \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use \u003ccode\u003edeepInject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e\n instead.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject",
          "package": "compdata",
          "signature": "CxtFun g f",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepInject",
          "type": "function"
        },
        "index": {
          "description": "Inject term over sub signature to term over larger signature If the signature is compound of atomic signatures use deepInject instead",
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepInject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject10",
          "package": "compdata",
          "signature": "CxtFun (:+: f10 (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))))) g",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepInject10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject10",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepInject10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject2",
          "package": "compdata",
          "signature": "CxtFun (:+: f2 f1) g",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepInject2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject2",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepInject2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject3",
          "package": "compdata",
          "signature": "CxtFun (:+: f3 (:+: f2 f1)) g",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepInject3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject3",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepInject3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject4",
          "package": "compdata",
          "signature": "CxtFun (:+: f4 (:+: f3 (:+: f2 f1))) g",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepInject4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject4",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepInject4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject5",
          "package": "compdata",
          "signature": "CxtFun (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))) g",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepInject5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject5",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepInject5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject6",
          "package": "compdata",
          "signature": "CxtFun (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))) g",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepInject6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject6",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepInject6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject7",
          "package": "compdata",
          "signature": "CxtFun (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))) g",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepInject7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject7",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepInject7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject8",
          "package": "compdata",
          "signature": "CxtFun (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))) g",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepInject8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject8",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepInject8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject9",
          "package": "compdata",
          "signature": "CxtFun (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))))) g",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepInject9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepInject9",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepInject9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTries to coerce a term\u003cem\u003econtext to a term\u003c/em\u003econtext over a sub-signature. If\n the signature \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use\n \u003ccode\u003edeepProject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject",
          "package": "compdata",
          "signature": "Term f i -\u003e Maybe (Term g i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepProject",
          "type": "function"
        },
        "index": {
          "description": "Tries to coerce term context to term context over sub-signature If the signature is compound of atomic signatures use deepProject instead",
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject",
          "normalized": "Term a b-\u003eMaybe(Term c b)",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f i-\u003eMaybe(Term g i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepProject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject10",
          "package": "compdata",
          "signature": "Term f i -\u003e Maybe (Term (:+: g10 (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))))) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepProject10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject10",
          "normalized": "Term a b-\u003eMaybe(Term(c(c(c(c(c(c(c(c(c c)))))))))b)",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f i-\u003eMaybe(Term(g(g(g(g(g(g(g(g(g g)))))))))i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepProject10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject2",
          "package": "compdata",
          "signature": "Term f i -\u003e Maybe (Term (:+: g2 g1) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepProject2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject2",
          "normalized": "Term a b-\u003eMaybe(Term(c c)b)",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f i-\u003eMaybe(Term(g g)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepProject2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject3",
          "package": "compdata",
          "signature": "Term f i -\u003e Maybe (Term (:+: g3 (:+: g2 g1)) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepProject3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject3",
          "normalized": "Term a b-\u003eMaybe(Term(c(c c))b)",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f i-\u003eMaybe(Term(g(g g))i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepProject3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject4",
          "package": "compdata",
          "signature": "Term f i -\u003e Maybe (Term (:+: g4 (:+: g3 (:+: g2 g1))) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepProject4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject4",
          "normalized": "Term a b-\u003eMaybe(Term(c(c(c c)))b)",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f i-\u003eMaybe(Term(g(g(g g)))i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepProject4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject5",
          "package": "compdata",
          "signature": "Term f i -\u003e Maybe (Term (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepProject5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject5",
          "normalized": "Term a b-\u003eMaybe(Term(c(c(c(c c))))b)",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f i-\u003eMaybe(Term(g(g(g(g g))))i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepProject5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject6",
          "package": "compdata",
          "signature": "Term f i -\u003e Maybe (Term (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepProject6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject6",
          "normalized": "Term a b-\u003eMaybe(Term(c(c(c(c(c c)))))b)",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f i-\u003eMaybe(Term(g(g(g(g(g g)))))i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepProject6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject7",
          "package": "compdata",
          "signature": "Term f i -\u003e Maybe (Term (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepProject7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject7",
          "normalized": "Term a b-\u003eMaybe(Term(c(c(c(c(c(c c))))))b)",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f i-\u003eMaybe(Term(g(g(g(g(g(g g))))))i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepProject7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject8",
          "package": "compdata",
          "signature": "Term f i -\u003e Maybe (Term (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepProject8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject8",
          "normalized": "Term a b-\u003eMaybe(Term(c(c(c(c(c(c(c c)))))))b)",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f i-\u003eMaybe(Term(g(g(g(g(g(g(g g)))))))i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepProject8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject9",
          "package": "compdata",
          "signature": "Term f i -\u003e Maybe (Term (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#deepProject9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "deepProject9",
          "normalized": "Term a b-\u003eMaybe(Term(c(c(c(c(c(c(c(c c))))))))b)",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f i-\u003eMaybe(Term(g(g(g(g(g(g(g(g g))))))))i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:deepProject9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj",
          "package": "compdata",
          "signature": "sub a b :-\u003e sup a b",
          "source": "src/Data-Comp-MultiParam-Ops.html#inj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj",
          "normalized": "a b c-\u003ed b c",
          "package": "compdata",
          "signature": "sub a b-\u003esup a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj10",
          "package": "compdata",
          "signature": ":+: f10 (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))))) a b i -\u003e g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inj10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj10",
          "normalized": "a(a(a(a(a(a(a(a(a a))))))))b c d-\u003ee b c d",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f(f f))))))))a b i-\u003eg a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inj10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj2",
          "package": "compdata",
          "signature": ":+: f2 f1 a b i -\u003e g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inj2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj2",
          "normalized": "a a b c d-\u003ee b c d",
          "package": "compdata",
          "signature": "f f a b i-\u003eg a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inj2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj3",
          "package": "compdata",
          "signature": ":+: f3 (:+: f2 f1) a b i -\u003e g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inj3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj3",
          "normalized": "a(a a)b c d-\u003ee b c d",
          "package": "compdata",
          "signature": "f(f f)a b i-\u003eg a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inj3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj4",
          "package": "compdata",
          "signature": ":+: f4 (:+: f3 (:+: f2 f1)) a b i -\u003e g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inj4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj4",
          "normalized": "a(a(a a))b c d-\u003ee b c d",
          "package": "compdata",
          "signature": "f(f(f f))a b i-\u003eg a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj5",
          "package": "compdata",
          "signature": ":+: f5 (:+: f4 (:+: f3 (:+: f2 f1))) a b i -\u003e g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inj5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj5",
          "normalized": "a(a(a(a a)))b c d-\u003ee b c d",
          "package": "compdata",
          "signature": "f(f(f(f f)))a b i-\u003eg a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inj5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj6",
          "package": "compdata",
          "signature": ":+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))) a b i -\u003e g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inj6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj6",
          "normalized": "a(a(a(a(a a))))b c d-\u003ee b c d",
          "package": "compdata",
          "signature": "f(f(f(f(f f))))a b i-\u003eg a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inj6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj7",
          "package": "compdata",
          "signature": ":+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))) a b i -\u003e g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inj7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj7",
          "normalized": "a(a(a(a(a(a a)))))b c d-\u003ee b c d",
          "package": "compdata",
          "signature": "f(f(f(f(f(f f)))))a b i-\u003eg a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inj7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj8",
          "package": "compdata",
          "signature": ":+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))) a b i -\u003e g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inj8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj8",
          "normalized": "a(a(a(a(a(a(a a))))))b c d-\u003ee b c d",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f f))))))a b i-\u003eg a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inj8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj9",
          "package": "compdata",
          "signature": ":+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))) a b i -\u003e g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inj9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inj9",
          "normalized": "a(a(a(a(a(a(a(a a)))))))b c d-\u003ee b c d",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f f)))))))a b i-\u003eg a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inj9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject a term where the outermost layer is a sub signature. If the signature\n \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use \u003ccode\u003einject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject",
          "package": "compdata",
          "signature": "g a (Cxt h f a b) :-\u003e Cxt h f a b",
          "source": "src/Data-Comp-MultiParam-Sum.html#inject",
          "type": "function"
        },
        "index": {
          "description": "Inject term where the outermost layer is sub signature If the signature is compound of atomic signatures use inject instead",
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject",
          "normalized": "a b(Cxt c d b e)-\u003eCxt c d b e",
          "package": "compdata",
          "signature": "g a(Cxt h f a b)-\u003eCxt h f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject10",
          "package": "compdata",
          "signature": ":+: f10 (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))))) a (Cxt h g a b) i -\u003e Cxt h g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inject10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject10",
          "normalized": "a(a(a(a(a(a(a(a(a a))))))))b(Cxt c d b e)f-\u003eCxt c d b e f",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f(f f))))))))a(Cxt h g a b)i-\u003eCxt h g a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inject10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject2",
          "package": "compdata",
          "signature": ":+: f2 f1 a (Cxt h g a b) i -\u003e Cxt h g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inject2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject2",
          "normalized": "a a b(Cxt c d b e)f-\u003eCxt c d b e f",
          "package": "compdata",
          "signature": "f f a(Cxt h g a b)i-\u003eCxt h g a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inject2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject3",
          "package": "compdata",
          "signature": ":+: f3 (:+: f2 f1) a (Cxt h g a b) i -\u003e Cxt h g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inject3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject3",
          "normalized": "a(a a)b(Cxt c d b e)f-\u003eCxt c d b e f",
          "package": "compdata",
          "signature": "f(f f)a(Cxt h g a b)i-\u003eCxt h g a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inject3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject4",
          "package": "compdata",
          "signature": ":+: f4 (:+: f3 (:+: f2 f1)) a (Cxt h g a b) i -\u003e Cxt h g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inject4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject4",
          "normalized": "a(a(a a))b(Cxt c d b e)f-\u003eCxt c d b e f",
          "package": "compdata",
          "signature": "f(f(f f))a(Cxt h g a b)i-\u003eCxt h g a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inject4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject5",
          "package": "compdata",
          "signature": ":+: f5 (:+: f4 (:+: f3 (:+: f2 f1))) a (Cxt h g a b) i -\u003e Cxt h g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inject5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject5",
          "normalized": "a(a(a(a a)))b(Cxt c d b e)f-\u003eCxt c d b e f",
          "package": "compdata",
          "signature": "f(f(f(f f)))a(Cxt h g a b)i-\u003eCxt h g a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inject5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject6",
          "package": "compdata",
          "signature": ":+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))) a (Cxt h g a b) i -\u003e Cxt h g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inject6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject6",
          "normalized": "a(a(a(a(a a))))b(Cxt c d b e)f-\u003eCxt c d b e f",
          "package": "compdata",
          "signature": "f(f(f(f(f f))))a(Cxt h g a b)i-\u003eCxt h g a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inject6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject7",
          "package": "compdata",
          "signature": ":+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))) a (Cxt h g a b) i -\u003e Cxt h g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inject7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject7",
          "normalized": "a(a(a(a(a(a a)))))b(Cxt c d b e)f-\u003eCxt c d b e f",
          "package": "compdata",
          "signature": "f(f(f(f(f(f f)))))a(Cxt h g a b)i-\u003eCxt h g a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inject7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject8",
          "package": "compdata",
          "signature": ":+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))) a (Cxt h g a b) i -\u003e Cxt h g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inject8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject8",
          "normalized": "a(a(a(a(a(a(a a))))))b(Cxt c d b e)f-\u003eCxt c d b e f",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f f))))))a(Cxt h g a b)i-\u003eCxt h g a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inject8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject9",
          "package": "compdata",
          "signature": ":+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))) a (Cxt h g a b) i -\u003e Cxt h g a b i",
          "source": "src/Data-Comp-MultiParam-Sum.html#inject9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "inject9",
          "normalized": "a(a(a(a(a(a(a(a a)))))))b(Cxt c d b e)f-\u003eCxt c d b e f",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f f)))))))a(Cxt h g a b)i-\u003eCxt h g a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:inject9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function injects a whole context into another context. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "injectCxt",
          "package": "compdata",
          "signature": "Cxt h g a (Cxt h f a b) :-\u003e Cxt h f a b",
          "source": "src/Data-Comp-MultiParam-Sum.html#injectCxt",
          "type": "function"
        },
        "index": {
          "description": "This function injects whole context into another context",
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "injectCxt",
          "normalized": "Cxt a b c(Cxt a d c e)-\u003eCxt a d c e",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "Cxt h g a(Cxt h f a b)-\u003eCxt h f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:injectCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function lifts the given functor to a context. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "liftCxt",
          "package": "compdata",
          "signature": "g a b :-\u003e Cxt Hole f a b",
          "source": "src/Data-Comp-MultiParam-Sum.html#liftCxt",
          "type": "function"
        },
        "index": {
          "description": "This function lifts the given functor to context",
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "liftCxt",
          "normalized": "a b c-\u003eCxt Hole d b c",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "g a b-\u003eCxt Hole f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:liftCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj",
          "package": "compdata",
          "signature": "NatM Maybe (sup a b) (sub a b)",
          "source": "src/Data-Comp-MultiParam-Ops.html#proj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj",
          "package": "compdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:proj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj10",
          "package": "compdata",
          "signature": "f a b i -\u003e Maybe (:+: g10 (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))) a b i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#proj10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj10",
          "normalized": "a b c d-\u003eMaybe(e(e(e(e(e(e(e(e(e e))))))))b c d)",
          "package": "compdata",
          "signature": "f a b i-\u003eMaybe(g(g(g(g(g(g(g(g(g g))))))))a b i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:proj10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj2",
          "package": "compdata",
          "signature": "f a b i -\u003e Maybe (:+: g2 g1 a b i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#proj2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj2",
          "normalized": "a b c d-\u003eMaybe(e e b c d)",
          "package": "compdata",
          "signature": "f a b i-\u003eMaybe(g g a b i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:proj2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj3",
          "package": "compdata",
          "signature": "f a b i -\u003e Maybe (:+: g3 (:+: g2 g1) a b i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#proj3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj3",
          "normalized": "a b c d-\u003eMaybe(e(e e)b c d)",
          "package": "compdata",
          "signature": "f a b i-\u003eMaybe(g(g g)a b i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:proj3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj4",
          "package": "compdata",
          "signature": "f a b i -\u003e Maybe (:+: g4 (:+: g3 (:+: g2 g1)) a b i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#proj4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj4",
          "normalized": "a b c d-\u003eMaybe(e(e(e e))b c d)",
          "package": "compdata",
          "signature": "f a b i-\u003eMaybe(g(g(g g))a b i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:proj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj5",
          "package": "compdata",
          "signature": "f a b i -\u003e Maybe (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))) a b i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#proj5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj5",
          "normalized": "a b c d-\u003eMaybe(e(e(e(e e)))b c d)",
          "package": "compdata",
          "signature": "f a b i-\u003eMaybe(g(g(g(g g)))a b i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:proj5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj6",
          "package": "compdata",
          "signature": "f a b i -\u003e Maybe (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))) a b i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#proj6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj6",
          "normalized": "a b c d-\u003eMaybe(e(e(e(e(e e))))b c d)",
          "package": "compdata",
          "signature": "f a b i-\u003eMaybe(g(g(g(g(g g))))a b i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:proj6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj7",
          "package": "compdata",
          "signature": "f a b i -\u003e Maybe (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))) a b i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#proj7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj7",
          "normalized": "a b c d-\u003eMaybe(e(e(e(e(e(e e)))))b c d)",
          "package": "compdata",
          "signature": "f a b i-\u003eMaybe(g(g(g(g(g(g g)))))a b i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:proj7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj8",
          "package": "compdata",
          "signature": "f a b i -\u003e Maybe (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))) a b i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#proj8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj8",
          "normalized": "a b c d-\u003eMaybe(e(e(e(e(e(e(e e))))))b c d)",
          "package": "compdata",
          "signature": "f a b i-\u003eMaybe(g(g(g(g(g(g(g g))))))a b i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:proj8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj9",
          "package": "compdata",
          "signature": "f a b i -\u003e Maybe (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))) a b i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#proj9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "proj9",
          "normalized": "a b c d-\u003eMaybe(e(e(e(e(e(e(e(e e)))))))b c d)",
          "package": "compdata",
          "signature": "f a b i-\u003eMaybe(g(g(g(g(g(g(g(g g)))))))a b i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:proj9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject the outermost layer of a term to a sub signature. If the signature\n \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use \u003ccode\u003eproject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project",
          "package": "compdata",
          "signature": "NatM Maybe (Cxt h f a b) (g a (Cxt h f a b))",
          "source": "src/Data-Comp-MultiParam-Sum.html#project",
          "type": "function"
        },
        "index": {
          "description": "Project the outermost layer of term to sub signature If the signature is compound of atomic signatures use project instead",
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:project"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project10",
          "package": "compdata",
          "signature": "Cxt h f a b i -\u003e Maybe (:+: g10 (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))) a (Cxt h f a b) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#project10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project10",
          "normalized": "Cxt a b c d e-\u003eMaybe(f(f(f(f(f(f(f(f(f f))))))))c(Cxt a b c d)e)",
          "package": "compdata",
          "signature": "Cxt h f a b i-\u003eMaybe(g(g(g(g(g(g(g(g(g g))))))))a(Cxt h f a b)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:project10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project2",
          "package": "compdata",
          "signature": "Cxt h f a b i -\u003e Maybe (:+: g2 g1 a (Cxt h f a b) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#project2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project2",
          "normalized": "Cxt a b c d e-\u003eMaybe(f f c(Cxt a b c d)e)",
          "package": "compdata",
          "signature": "Cxt h f a b i-\u003eMaybe(g g a(Cxt h f a b)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:project2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project3",
          "package": "compdata",
          "signature": "Cxt h f a b i -\u003e Maybe (:+: g3 (:+: g2 g1) a (Cxt h f a b) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#project3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project3",
          "normalized": "Cxt a b c d e-\u003eMaybe(f(f f)c(Cxt a b c d)e)",
          "package": "compdata",
          "signature": "Cxt h f a b i-\u003eMaybe(g(g g)a(Cxt h f a b)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:project3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project4",
          "package": "compdata",
          "signature": "Cxt h f a b i -\u003e Maybe (:+: g4 (:+: g3 (:+: g2 g1)) a (Cxt h f a b) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#project4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project4",
          "normalized": "Cxt a b c d e-\u003eMaybe(f(f(f f))c(Cxt a b c d)e)",
          "package": "compdata",
          "signature": "Cxt h f a b i-\u003eMaybe(g(g(g g))a(Cxt h f a b)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:project4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project5",
          "package": "compdata",
          "signature": "Cxt h f a b i -\u003e Maybe (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))) a (Cxt h f a b) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#project5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project5",
          "normalized": "Cxt a b c d e-\u003eMaybe(f(f(f(f f)))c(Cxt a b c d)e)",
          "package": "compdata",
          "signature": "Cxt h f a b i-\u003eMaybe(g(g(g(g g)))a(Cxt h f a b)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:project5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project6",
          "package": "compdata",
          "signature": "Cxt h f a b i -\u003e Maybe (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))) a (Cxt h f a b) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#project6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project6",
          "normalized": "Cxt a b c d e-\u003eMaybe(f(f(f(f(f f))))c(Cxt a b c d)e)",
          "package": "compdata",
          "signature": "Cxt h f a b i-\u003eMaybe(g(g(g(g(g g))))a(Cxt h f a b)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:project6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project7",
          "package": "compdata",
          "signature": "Cxt h f a b i -\u003e Maybe (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))) a (Cxt h f a b) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#project7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project7",
          "normalized": "Cxt a b c d e-\u003eMaybe(f(f(f(f(f(f f)))))c(Cxt a b c d)e)",
          "package": "compdata",
          "signature": "Cxt h f a b i-\u003eMaybe(g(g(g(g(g(g g)))))a(Cxt h f a b)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:project7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project8",
          "package": "compdata",
          "signature": "Cxt h f a b i -\u003e Maybe (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))) a (Cxt h f a b) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#project8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project8",
          "normalized": "Cxt a b c d e-\u003eMaybe(f(f(f(f(f(f(f f))))))c(Cxt a b c d)e)",
          "package": "compdata",
          "signature": "Cxt h f a b i-\u003eMaybe(g(g(g(g(g(g(g g))))))a(Cxt h f a b)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:project8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project9",
          "package": "compdata",
          "signature": "Cxt h f a b i -\u003e Maybe (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))) a (Cxt h f a b) i)",
          "source": "src/Data-Comp-MultiParam-Sum.html#project9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Sum",
          "module": "Data.Comp.MultiParam.Sum",
          "name": "project9",
          "normalized": "Cxt a b c d e-\u003eMaybe(f(f(f(f(f(f(f(f f)))))))c(Cxt a b c d)e)",
          "package": "compdata",
          "signature": "Cxt h f a b i-\u003eMaybe(g(g(g(g(g(g(g(g g)))))))a(Cxt h f a b)i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Sum.html#v:project9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the central notion of \u003cem\u003egeneralised parametrised terms\u003c/em\u003e\n and their generalisation to generalised parametrised contexts.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Term",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Term.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the central notion of generalised parametrised terms and their generalisation to generalised parametrised contexts",
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Term",
          "package": "compdata",
          "partial": "Term",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA context may contain holes. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Context",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Term.html#Context",
          "type": "type"
        },
        "index": {
          "description": "context may contain holes",
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Context",
          "package": "compdata",
          "partial": "Context",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#t:Context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type represents contexts over a signature. Contexts are terms\n  containing zero or more holes, and zero or more parameters. The first\n  parameter is a phantom type indicating whether the context has holes. The\n  second paramater is the signature of the context, in the form of a\n  \u003ca\u003eData.Comp.MultiParam.HDifunctor\u003c/a\u003e. The third parameter is the type of\n  parameters, the fourth parameter is the type of holes, and the fifth\n  parameter is the GADT type. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Cxt",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Term.html#Cxt",
          "type": "data"
        },
        "index": {
          "description": "This data type represents contexts over signature Contexts are terms containing zero or more holes and zero or more parameters The first parameter is phantom type indicating whether the context has holes The second paramater is the signature of the context in the form of Data.Comp.MultiParam.HDifunctor The third parameter is the type of parameters the fourth parameter is the type of holes and the fifth parameter is the GADT type",
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Cxt",
          "package": "compdata",
          "partial": "Cxt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#t:Cxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhantom type used to define \u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Hole",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Term.html#Hole",
          "type": "data"
        },
        "index": {
          "description": "Phantom type used to define Context",
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Hole",
          "package": "compdata",
          "partial": "Hole",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#t:Hole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhantom type used to define \u003ccode\u003e\u003ca\u003eTerm\u003c/a\u003e\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Term",
          "name": "NoHole",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Term.html#NoHole",
          "type": "data"
        },
        "index": {
          "description": "Phantom type used to define Term",
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "NoHole",
          "package": "compdata",
          "partial": "No Hole",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#t:NoHole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonads for which embedded \u003ccode\u003eTrm\u003c/code\u003e values, which are parametric at top level,\n  can be made into monadic \u003ccode\u003eTerm\u003c/code\u003e values, i.e. \"pushing the parametricity\n  inwards\". \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Term",
          "name": "ParamFunctor",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Term.html#ParamFunctor",
          "type": "class"
        },
        "index": {
          "description": "Monads for which embedded Trm values which are parametric at top level can be made into monadic Term values i.e pushing the parametricity inwards",
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "ParamFunctor",
          "package": "compdata",
          "partial": "Param Functor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#t:ParamFunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA term is a context with no holes, where all occurrences of the\n  contravariant parameter is fully parametric. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Term",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Term.html#Term",
          "type": "newtype"
        },
        "index": {
          "description": "term is context with no holes where all occurrences of the contravariant parameter is fully parametric",
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Term",
          "package": "compdata",
          "partial": "Term",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Preterms\" |\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Trm",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam-Term.html#Trm",
          "type": "type"
        },
        "index": {
          "description": "Preterms",
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Trm",
          "package": "compdata",
          "partial": "Trm",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#t:Trm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Term",
          "name": "Hole",
          "package": "compdata",
          "signature": "b i -\u003e Cxt Hole f a b i",
          "source": "src/Data-Comp-MultiParam-Term.html#Cxt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Hole",
          "normalized": "a b-\u003eCxt Hole c d a b",
          "package": "compdata",
          "partial": "Hole",
          "signature": "b i-\u003eCxt Hole f a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#v:Hole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Term",
          "name": "In",
          "package": "compdata",
          "signature": "f a (Cxt h f a b) i -\u003e Cxt h f a b i",
          "source": "src/Data-Comp-MultiParam-Term.html#Cxt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "In",
          "normalized": "a b(Cxt c a b d)e-\u003eCxt c a b d e",
          "package": "compdata",
          "partial": "In",
          "signature": "f a(Cxt h f a b)i-\u003eCxt h f a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#v:In"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Term",
          "name": "Term",
          "package": "compdata",
          "signature": "Term",
          "source": "src/Data-Comp-MultiParam-Term.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Term",
          "package": "compdata",
          "partial": "Term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#v:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Term",
          "name": "Var",
          "package": "compdata",
          "signature": "a i -\u003e Cxt h f a b i",
          "source": "src/Data-Comp-MultiParam-Term.html#Cxt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "Var",
          "normalized": "a b-\u003eCxt c d a e b",
          "package": "compdata",
          "partial": "Var",
          "signature": "a i-\u003eCxt h f a b i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#v:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an instance of \u003ccode\u003e\u003ca\u003ehdimapM\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eCxt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Term",
          "name": "hdimapMCxt",
          "package": "compdata",
          "signature": "NatM m b b' -\u003e NatM m (Cxt h f a b) (Cxt h f a b')",
          "source": "src/Data-Comp-MultiParam-Term.html#hdimapMCxt",
          "type": "function"
        },
        "index": {
          "description": "This is an instance of hdimapM for Cxt",
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "hdimapMCxt",
          "normalized": "NatM a b c-\u003eNatM a(Cxt d e f b)(Cxt d e f c)",
          "package": "compdata",
          "partial": "MCxt",
          "signature": "NatM m b b'-\u003eNatM m(Cxt h f a b)(Cxt h f a b')",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#v:hdimapMCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an instance of \u003ccode\u003e\u003ca\u003ehfmap\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eCxt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Term",
          "name": "hfmapCxt",
          "package": "compdata",
          "signature": "(b :-\u003e b') -\u003e Cxt h f a b :-\u003e Cxt h f a b'",
          "source": "src/Data-Comp-MultiParam-Term.html#hfmapCxt",
          "type": "function"
        },
        "index": {
          "description": "This is an instance of hfmap for Cxt",
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "hfmapCxt",
          "normalized": "(a-\u003eb)-\u003eCxt c d e a-\u003eCxt c d e b",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "(b-\u003eb')-\u003eCxt h f a b-\u003eCxt h f a b'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#v:hfmapCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a difunctorial value into a context. \n\u003c/p\u003e",
          "module": "Data.Comp.MultiParam.Term",
          "name": "simpCxt",
          "package": "compdata",
          "signature": "f a b :-\u003e Cxt Hole f a b",
          "source": "src/Data-Comp-MultiParam-Term.html#simpCxt",
          "type": "function"
        },
        "index": {
          "description": "Convert difunctorial value into context",
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "simpCxt",
          "normalized": "a b c-\u003eCxt Hole a b c",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "f a b-\u003eCxt Hole f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#v:simpCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Term",
          "name": "termM",
          "package": "compdata",
          "signature": "(forall a.  m (Trm f a i)) -\u003e m (Term f i)",
          "source": "src/Data-Comp-MultiParam-Term.html#termM",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "termM",
          "normalized": "(a b c(Trm d e f))-\u003ec(Term d f)",
          "package": "compdata",
          "signature": "(forall a. m(Trm f a i))-\u003em(Term f i)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#v:termM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Term",
          "name": "toCxt",
          "package": "compdata",
          "signature": "Trm f a :-\u003e Cxt h f a b",
          "source": "src/Data-Comp-MultiParam-Term.html#toCxt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "toCxt",
          "normalized": "Trm a b-\u003eCxt c a b d",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "Trm f a-\u003eCxt h f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#v:toCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.MultiParam.Term",
          "name": "unTerm",
          "package": "compdata",
          "signature": "forall a.  Trm f a i",
          "source": "src/Data-Comp-MultiParam-Term.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp MultiParam Term",
          "module": "Data.Comp.MultiParam.Term",
          "name": "unTerm",
          "package": "compdata",
          "partial": "Term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam-Term.html#v:unTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the infrastructure necessary to use\n \u003cem\u003eGeneralised Parametric Compositional Data Types\u003c/em\u003e. Generalised Parametric\n Compositional Data Types is an extension of Compositional Data Types with\n parametric higher-order abstract syntax (PHOAS) for usage with binders, and\n GADTs. Generalised Parametric Compositional Data Types combines Generalised\n Compositional Data Types (\u003ca\u003eData.Comp.Multi\u003c/a\u003e) and Parametric Compositional\n Data Types (\u003ca\u003eData.Comp.Param\u003c/a\u003e). Examples of usage are bundled with the\n package in the library \u003ccode\u003eexamples/Examples/MultiParam\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.MultiParam",
          "name": "MultiParam",
          "package": "compdata",
          "source": "src/Data-Comp-MultiParam.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the infrastructure necessary to use Generalised Parametric Compositional Data Types Generalised Parametric Compositional Data Types is an extension of Compositional Data Types with parametric higher-order abstract syntax PHOAS for usage with binders and GADTs Generalised Parametric Compositional Data Types combines Generalised Compositional Data Types Data.Comp.Multi and Parametric Compositional Data Types Data.Comp.Param Examples of usage are bundled with the package in the library examples Examples MultiParam",
          "hierarchy": "Data Comp MultiParam",
          "module": "Data.Comp.MultiParam",
          "name": "MultiParam",
          "package": "compdata",
          "partial": "Multi Param",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-MultiParam.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides functionality to number the components of a\n functorial value with consecutive integers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Number",
          "name": "Number",
          "package": "compdata",
          "source": "src/Data-Comp-Number.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides functionality to number the components of functorial value with consecutive integers",
          "hierarchy": "Data Comp Number",
          "module": "Data.Comp.Number",
          "name": "Number",
          "package": "compdata",
          "partial": "Number",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Number.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type is used for numbering components of a functorial value.\n\u003c/p\u003e",
          "module": "Data.Comp.Number",
          "name": "Numbered",
          "package": "compdata",
          "source": "src/Data-Comp-Number.html#Numbered",
          "type": "newtype"
        },
        "index": {
          "description": "This type is used for numbering components of functorial value",
          "hierarchy": "Data Comp Number",
          "module": "Data.Comp.Number",
          "name": "Numbered",
          "package": "compdata",
          "partial": "Numbered",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Number.html#t:Numbered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunctors representing data structures that can be traversed from\n left to right.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003esequenceA\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eInstances are similar to \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, e.g. given a data type\n\u003c/p\u003e\u003cpre\u003e data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)\n\u003c/pre\u003e\u003cp\u003ea suitable instance would be\n\u003c/p\u003e\u003cpre\u003e instance Traversable Tree where\n    traverse f Empty = pure Empty\n    traverse f (Leaf x) = Leaf \u003c$\u003e f x\n    traverse f (Node l k r) = Node \u003c$\u003e traverse f l \u003c*\u003e f k \u003c*\u003e traverse f r\n\u003c/pre\u003e\u003cp\u003eThis is suitable even for abstract types, as the laws for \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e\n imply a form of associativity.\n\u003c/p\u003e\u003cp\u003eThe superclass instances should satisfy the following:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e In the \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e instance, \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e should be equivalent to traversal\n    with the identity applicative functor (\u003ccode\u003e\u003ca\u003efmapDefault\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003cli\u003e In the \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e instance, \u003ccode\u003e\u003ca\u003efoldMap\u003c/a\u003e\u003c/code\u003e should be\n    equivalent to traversal with a constant applicative functor\n    (\u003ccode\u003e\u003ca\u003efoldMapDefault\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Data.Comp.Number",
          "name": "Traversable",
          "package": "compdata",
          "type": "class"
        },
        "index": {
          "description": "Functors representing data structures that can be traversed from left to right Minimal complete definition traverse or sequenceA Instances are similar to Functor e.g given data type data Tree Empty Leaf Node Tree Tree suitable instance would be instance Traversable Tree where traverse Empty pure Empty traverse Leaf Leaf traverse Node Node traverse traverse This is suitable even for abstract types as the laws for imply form of associativity The superclass instances should satisfy the following In the Functor instance fmap should be equivalent to traversal with the identity applicative functor fmapDefault In the Foldable instance foldMap should be equivalent to traversal with constant applicative functor foldMapDefault",
          "hierarchy": "Data Comp Number",
          "module": "Data.Comp.Number",
          "name": "Traversable",
          "package": "compdata",
          "partial": "Traversable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Number.html#t:Traversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Number",
          "name": "Numbered",
          "package": "compdata",
          "signature": "Numbered (Int, a)",
          "source": "src/Data-Comp-Number.html#Numbered",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Number",
          "module": "Data.Comp.Number",
          "name": "Numbered",
          "normalized": "Numbered(Int,a)",
          "package": "compdata",
          "partial": "Numbered",
          "signature": "Numbered(Int,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Number.html#v:Numbered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function numbers the components of the given functorial\n value with consecutive integers starting at 0.\n\u003c/p\u003e",
          "module": "Data.Comp.Number",
          "name": "number",
          "package": "compdata",
          "signature": "f a -\u003e f (Numbered a)",
          "source": "src/Data-Comp-Number.html#number",
          "type": "function"
        },
        "index": {
          "description": "This function numbers the components of the given functorial value with consecutive integers starting at",
          "hierarchy": "Data Comp Number",
          "module": "Data.Comp.Number",
          "name": "number",
          "normalized": "a b-\u003ea(Numbered b)",
          "package": "compdata",
          "signature": "f a-\u003ef(Numbered a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Number.html#v:number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Number",
          "name": "unNumbered",
          "package": "compdata",
          "signature": "Numbered a -\u003e a",
          "source": "src/Data-Comp-Number.html#unNumbered",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Number",
          "module": "Data.Comp.Number",
          "name": "unNumbered",
          "normalized": "Numbered a-\u003ea",
          "package": "compdata",
          "partial": "Numbered",
          "signature": "Numbered a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Number.html#v:unNumbered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides operators on functors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Ops",
          "name": "Ops",
          "package": "compdata",
          "source": "src/Data-Comp-Ops.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides operators on functors",
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": "Ops",
          "package": "compdata",
          "partial": "Ops",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type adds a constant product (annotation) to a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Ops",
          "name": ":&:",
          "package": "compdata",
          "source": "src/Data-Comp-Ops.html#%3A%26%3A",
          "type": "data"
        },
        "index": {
          "description": "This data type adds constant product annotation to signature",
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": ":&:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#t::-38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal product of signatures (functors).\n\u003c/p\u003e",
          "module": "Data.Comp.Ops",
          "name": ":*:",
          "package": "compdata",
          "source": "src/Data-Comp-Ops.html#%3A%2A%3A",
          "type": "data"
        },
        "index": {
          "description": "Formal product of signatures functors",
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": ":*:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#t::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal sum of signatures (functors).\n\u003c/p\u003e",
          "module": "Data.Comp.Ops",
          "name": ":+:",
          "package": "compdata",
          "source": "src/Data-Comp-Ops.html#%3A%2B%3A",
          "type": "data"
        },
        "index": {
          "description": "Formal sum of signatures functors",
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": ":+:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#t::-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature containment relation for automatic injections. The left-hand must\n be an atomic signature, where as the right-hand side must have a list-like\n structure. Examples include \u003ccode\u003ef :\u003c: f :+: g\u003c/code\u003e and \u003ccode\u003eg :\u003c: f :+: (g :+: h)\u003c/code\u003e,\n non-examples include \u003ccode\u003ef :+: g :\u003c: f :+: (g :+: h)\u003c/code\u003e and\n \u003ccode\u003ef :\u003c: (f :+: g) :+: h\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Ops",
          "name": ":\u003c:",
          "package": "compdata",
          "source": "src/Data-Comp-Ops.html#%3A%3C%3A",
          "type": "class"
        },
        "index": {
          "description": "Signature containment relation for automatic injections The left-hand must be an atomic signature where as the right-hand side must have list-like structure Examples include and non-examples include and",
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": ":\u003c:",
          "package": "compdata",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#t::-60-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class defines how to distribute an annotation over a sum of\nsignatures. \n\u003c/p\u003e",
          "module": "Data.Comp.Ops",
          "name": "DistAnn",
          "package": "compdata",
          "source": "src/Data-Comp-Ops.html#DistAnn",
          "type": "class"
        },
        "index": {
          "description": "This class defines how to distribute an annotation over sum of signatures",
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": "DistAnn",
          "package": "compdata",
          "partial": "Dist Ann",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#t:DistAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Ops",
          "name": "RemA",
          "package": "compdata",
          "source": "src/Data-Comp-Ops.html#RemA",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": "RemA",
          "package": "compdata",
          "partial": "Rem",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#t:RemA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Ops",
          "name": "Inl",
          "package": "compdata",
          "signature": "Inl (f e)",
          "source": "src/Data-Comp-Ops.html#%3A%2B%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": "Inl",
          "package": "compdata",
          "partial": "Inl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#v:Inl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Ops",
          "name": "Inr",
          "package": "compdata",
          "signature": "Inr (g e)",
          "source": "src/Data-Comp-Ops.html#%3A%2B%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": "Inr",
          "package": "compdata",
          "partial": "Inr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#v:Inr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUtility function to case on a functor sum, without exposing the internal\n  representation of sums. \n\u003c/p\u003e",
          "module": "[\"Data.Comp.Ops\",\"Data.Comp.Sum\"]",
          "name": "caseF",
          "package": "compdata",
          "signature": "(f a -\u003e b) -\u003e (g a -\u003e b) -\u003e (f :+: g) a -\u003e b",
          "source": "src/Data-Comp-Ops.html#caseF",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#v:caseF\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:caseF\"]"
        },
        "index": {
          "description": "Utility function to case on functor sum without exposing the internal representation of sums",
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": "caseF",
          "normalized": "(a b-\u003ec)-\u003e(d b-\u003ec)-\u003e(a d)b-\u003ec",
          "package": "compdata",
          "signature": "(f a-\u003eb)-\u003e(g a-\u003eb)-\u003e(f g)a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#v:caseF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Ops",
          "name": "ffst",
          "package": "compdata",
          "signature": "(f :*: g) a -\u003e f a",
          "source": "src/Data-Comp-Ops.html#ffst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": "ffst",
          "normalized": "(a*b)c-\u003ea c",
          "package": "compdata",
          "signature": "(f*g)a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#v:ffst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Ops",
          "name": "fsnd",
          "package": "compdata",
          "signature": "(f :*: g) a -\u003e g a",
          "source": "src/Data-Comp-Ops.html#fsnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": "fsnd",
          "normalized": "(a*b)c-\u003eb c",
          "package": "compdata",
          "signature": "(f*g)a-\u003eg a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#v:fsnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Ops",
          "name": "inj",
          "package": "compdata",
          "signature": "sub a -\u003e sup a",
          "source": "src/Data-Comp-Ops.html#inj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": "inj",
          "normalized": "a b-\u003ec b",
          "package": "compdata",
          "signature": "sub a-\u003esup a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#v:inj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject an annotation over a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Ops",
          "name": "injectA",
          "package": "compdata",
          "signature": "p -\u003e s a -\u003e s' a",
          "source": "src/Data-Comp-Ops.html#injectA",
          "type": "method"
        },
        "index": {
          "description": "Inject an annotation over signature",
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": "injectA",
          "normalized": "a-\u003eb c-\u003ed c",
          "package": "compdata",
          "signature": "p-\u003es a-\u003es' a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#v:injectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Ops",
          "name": "proj",
          "package": "compdata",
          "signature": "sup a -\u003e Maybe (sub a)",
          "source": "src/Data-Comp-Ops.html#proj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": "proj",
          "normalized": "a b-\u003eMaybe(c b)",
          "package": "compdata",
          "signature": "sup a-\u003eMaybe(sub a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#v:proj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject an annotation from a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Ops",
          "name": "projectA",
          "package": "compdata",
          "signature": "s' a -\u003e (s a, p)",
          "source": "src/Data-Comp-Ops.html#projectA",
          "type": "method"
        },
        "index": {
          "description": "Project an annotation from signature",
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": "projectA",
          "normalized": "a b-\u003e(c b,d)",
          "package": "compdata",
          "signature": "s' a-\u003e(s a,p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#v:projectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove annotations from a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Ops",
          "name": "remA",
          "package": "compdata",
          "signature": "s a -\u003e s' a",
          "source": "src/Data-Comp-Ops.html#remA",
          "type": "method"
        },
        "index": {
          "description": "Remove annotations from signature",
          "hierarchy": "Data Comp Ops",
          "module": "Data.Comp.Ops",
          "name": "remA",
          "normalized": "a b-\u003ec b",
          "package": "compdata",
          "signature": "s a-\u003es' a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ops.html#v:remA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines ordering of signatures, which lifts to ordering of\n terms and contexts.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Ordering",
          "name": "Ordering",
          "package": "compdata",
          "source": "src/Data-Comp-Ordering.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines ordering of signatures which lifts to ordering of terms and contexts",
          "hierarchy": "Data Comp Ordering",
          "module": "Data.Comp.Ordering",
          "name": "Ordering",
          "package": "compdata",
          "partial": "Ordering",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ordering.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature ordering. An instance \u003ccode\u003eOrdF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eOrd (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Ordering",
          "name": "OrdF",
          "package": "compdata",
          "source": "src/Data-Comp-Derive-Ordering.html#OrdF",
          "type": "class"
        },
        "index": {
          "description": "Signature ordering An instance OrdF gives rise to an instance Ord Term",
          "hierarchy": "Data Comp Ordering",
          "module": "Data.Comp.Ordering",
          "name": "OrdF",
          "package": "compdata",
          "partial": "Ord",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ordering.html#t:OrdF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Ordering",
          "name": "compareF",
          "package": "compdata",
          "signature": "f a -\u003e f a -\u003e Ordering",
          "source": "src/Data-Comp-Derive-Ordering.html#compareF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Ordering",
          "module": "Data.Comp.Ordering",
          "name": "compareF",
          "normalized": "a b-\u003ea b-\u003eOrdering",
          "package": "compdata",
          "signature": "f a-\u003ef a-\u003eOrdering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Ordering.html#v:compareF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the notion of algebras and catamorphisms, and their\n generalizations to e.g. monadic versions and other (co)recursion schemes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "Algebra",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the notion of algebras and catamorphisms and their generalizations to e.g monadic versions and other co recursion schemes",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "Algebra",
          "package": "compdata",
          "partial": "Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents an algebra over a difunctor \u003ccode\u003ef\u003c/code\u003e and carrier \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "Alg",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#Alg",
          "type": "type"
        },
        "index": {
          "description": "This type represents an algebra over difunctor and carrier",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "Alg",
          "package": "compdata",
          "partial": "Alg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:Alg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic algebra. It is similar to \u003ccode\u003e\u003ca\u003eAlg\u003c/a\u003e\u003c/code\u003e but\n  the return type is monadic. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "AlgM",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#AlgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic algebra It is similar to Alg but the return type is monadic",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "AlgM",
          "package": "compdata",
          "partial": "Alg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:AlgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a cv-algebra over a difunctor \u003ccode\u003ef\u003c/code\u003e and carrier \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "CVAlg",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#CVAlg",
          "type": "type"
        },
        "index": {
          "description": "This type represents cv-algebra over difunctor and carrier",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "CVAlg",
          "package": "compdata",
          "partial": "CVAlg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:CVAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic cv-algebra over a functor \u003ccode\u003ef\u003c/code\u003e and carrier\n  \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "CVAlgM",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#CVAlgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic cv-algebra over functor and carrier",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "CVAlgM",
          "package": "compdata",
          "partial": "CVAlg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:CVAlgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a cv-coalgebra over a difunctor \u003ccode\u003ef\u003c/code\u003e and carrier \u003ccode\u003ea\u003c/code\u003e.\n  The list of \u003ccode\u003e(a,b)\u003c/code\u003es represent the parameters that may occur in the\n  constructed value. The first component represents the seed of the parameter,\n  and the second component is the (polymorphic) parameter itself. If \u003ccode\u003ef\u003c/code\u003e is\n  itself a binder, then the parameters bound by \u003ccode\u003ef\u003c/code\u003e can be passed to the\n  covariant argument, thereby making them available to sub terms. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "CVCoalg",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#CVCoalg",
          "type": "type"
        },
        "index": {
          "description": "This type represents cv-coalgebra over difunctor and carrier The list of represent the parameters that may occur in the constructed value The first component represents the seed of the parameter and the second component is the polymorphic parameter itself If is itself binder then the parameters bound by can be passed to the covariant argument thereby making them available to sub terms",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "CVCoalg",
          "package": "compdata",
          "partial": "CVCoalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:CVCoalg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a generalised cv-coalgebra over a difunctor \u003ccode\u003ef\u003c/code\u003e and\n  carrier \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "CVCoalg'",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#CVCoalg%27",
          "type": "type"
        },
        "index": {
          "description": "This type represents generalised cv-coalgebra over difunctor and carrier",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "CVCoalg'",
          "package": "compdata",
          "partial": "CVCoalg'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:CVCoalg-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic cv-coalgebra over a difunctor \u003ccode\u003ef\u003c/code\u003e and carrier\n  \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "CVCoalgM",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#CVCoalgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic cv-coalgebra over difunctor and carrier",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "CVCoalgM",
          "package": "compdata",
          "partial": "CVCoalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:CVCoalgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a coalgebra over a difunctor \u003ccode\u003ef\u003c/code\u003e and carrier \u003ccode\u003ea\u003c/code\u003e. The\n  list of \u003ccode\u003e(a,b)\u003c/code\u003es represent the parameters that may occur in the constructed\n  value. The first component represents the seed of the parameter,\n  and the second component is the (polymorphic) parameter itself. If \u003ccode\u003ef\u003c/code\u003e is\n  itself a binder, then the parameters bound by \u003ccode\u003ef\u003c/code\u003e can be passed to the\n  covariant argument, thereby making them available to sub terms. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "Coalg",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#Coalg",
          "type": "type"
        },
        "index": {
          "description": "This type represents coalgebra over difunctor and carrier The list of represent the parameters that may occur in the constructed value The first component represents the seed of the parameter and the second component is the polymorphic parameter itself If is itself binder then the parameters bound by can be passed to the covariant argument thereby making them available to sub terms",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "Coalg",
          "package": "compdata",
          "partial": "Coalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:Coalg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic coalgebra over a difunctor \u003ccode\u003ef\u003c/code\u003e and carrier\n  \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "CoalgM",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#CoalgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic coalgebra over difunctor and carrier",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "CoalgM",
          "package": "compdata",
          "partial": "Coalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:CoalgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a context function. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "CxtFun",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#CxtFun",
          "type": "type"
        },
        "index": {
          "description": "This type represents context function",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "CxtFun",
          "package": "compdata",
          "partial": "Cxt Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:CxtFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic context function. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "CxtFunM",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#CxtFunM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic context function",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "CxtFunM",
          "package": "compdata",
          "partial": "Cxt Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:CxtFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a term homomorphism. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "Hom",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#Hom",
          "type": "type"
        },
        "index": {
          "description": "This type represents term homomorphism",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "Hom",
          "package": "compdata",
          "partial": "Hom",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:Hom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic term homomorphism. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "HomM",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#HomM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic term homomorphism",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "HomM",
          "package": "compdata",
          "partial": "Hom",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:HomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic term homomorphism. It is similar to\n  \u003ccode\u003e\u003ca\u003eHomM\u003c/a\u003e\u003c/code\u003e but has monadic values also in the domain. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "HomMD",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#HomMD",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic term homomorphism It is similar to HomM but has monadic values also in the domain",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "HomMD",
          "package": "compdata",
          "partial": "Hom MD",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:HomMD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents an r-algebra over a difunctor \u003ccode\u003ef\u003c/code\u003e and carrier \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "RAlg",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#RAlg",
          "type": "type"
        },
        "index": {
          "description": "This type represents an r-algebra over difunctor and carrier",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "RAlg",
          "package": "compdata",
          "partial": "RAlg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:RAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic r-algebra over a difunctor \u003ccode\u003ef\u003c/code\u003e and carrier\n  \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "RAlgM",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#RAlgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic r-algebra over difunctor and carrier",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "RAlgM",
          "package": "compdata",
          "partial": "RAlg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:RAlgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents an r-coalgebra over a difunctor \u003ccode\u003ef\u003c/code\u003e and carrier \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "RCoalg",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#RCoalg",
          "type": "type"
        },
        "index": {
          "description": "This type represents an r-coalgebra over difunctor and carrier",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "RCoalg",
          "package": "compdata",
          "partial": "RCoalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:RCoalg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic r-coalgebra over a functor \u003ccode\u003ef\u003c/code\u003e and carrier\n  \u003ccode\u003ea\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "RCoalgM",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#RCoalgM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic r-coalgebra over functor and carrier",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "RCoalgM",
          "package": "compdata",
          "partial": "RCoalg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:RCoalgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a signature function. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "SigFun",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#SigFun",
          "type": "type"
        },
        "index": {
          "description": "This type represents signature function",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "SigFun",
          "package": "compdata",
          "partial": "Sig Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:SigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic signature function. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "SigFunM",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#SigFunM",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic signature function",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "SigFunM",
          "package": "compdata",
          "partial": "Sig Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:SigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a monadic signature function. It is similar to\n  \u003ccode\u003e\u003ca\u003eSigFunM\u003c/a\u003e\u003c/code\u003e but has monadic values also in the domain. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "SigFunMD",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Algebra.html#SigFunMD",
          "type": "type"
        },
        "index": {
          "description": "This type represents monadic signature function It is similar to SigFunM but has monadic values also in the domain",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "SigFunMD",
          "package": "compdata",
          "partial": "Sig Fun MD",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#t:SigFunMD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a monadic algebra into an ordinary algebra with a monadic\n  carrier. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "algM",
          "package": "compdata",
          "signature": "AlgM m f a -\u003e Alg f (m a)",
          "source": "src/Data-Comp-Param-Algebra.html#algM",
          "type": "function"
        },
        "index": {
          "description": "Convert monadic algebra into an ordinary algebra with monadic carrier",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "algM",
          "normalized": "AlgM a b c-\u003eAlg b(a c)",
          "package": "compdata",
          "signature": "AlgM m f a-\u003eAlg f(m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:algM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an anamorphism from the given coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "ana",
          "package": "compdata",
          "signature": "Coalg f a -\u003e a -\u003e Term f",
          "source": "src/Data-Comp-Param-Algebra.html#ana",
          "type": "function"
        },
        "index": {
          "description": "Construct an anamorphism from the given coalgebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "ana",
          "normalized": "Coalg a b-\u003eb-\u003eTerm a",
          "package": "compdata",
          "signature": "Coalg f a-\u003ea-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:ana"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic anamorphism from the given monadic coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "anaM",
          "package": "compdata",
          "signature": "CoalgM m f a -\u003e a -\u003e forall a.  m (Trm f a)",
          "source": "src/Data-Comp-Param-Algebra.html#anaM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic anamorphism from the given monadic coalgebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "anaM",
          "normalized": "CoalgM a b c-\u003ec-\u003ed e a(Trm b c)",
          "package": "compdata",
          "signature": "CoalgM m f a-\u003ea-\u003eforall a. m(Trm f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:anaM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an apomorphism from the given r-coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "apo",
          "package": "compdata",
          "signature": "RCoalg f a -\u003e a -\u003e Term f",
          "source": "src/Data-Comp-Param-Algebra.html#apo",
          "type": "function"
        },
        "index": {
          "description": "Construct an apomorphism from the given r-coalgebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "apo",
          "normalized": "RCoalg a b-\u003eb-\u003eTerm a",
          "package": "compdata",
          "signature": "RCoalg f a-\u003ea-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:apo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic apomorphism from the given monadic r-coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "apoM",
          "package": "compdata",
          "signature": "RCoalgM m f a -\u003e a -\u003e forall a.  m (Trm f a)",
          "source": "src/Data-Comp-Param-Algebra.html#apoM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic apomorphism from the given monadic r-coalgebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "apoM",
          "normalized": "RCoalgM a b c-\u003ec-\u003ed e a(Trm b c)",
          "package": "compdata",
          "signature": "RCoalgM m f a-\u003ea-\u003eforall a. m(Trm f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:apoM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a whole context into another context. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appCxt",
          "package": "compdata",
          "signature": "Context f a (Cxt h f a b) -\u003e Cxt h f a b",
          "source": "src/Data-Comp-Param-Algebra.html#appCxt",
          "type": "function"
        },
        "index": {
          "description": "This function applies whole context into another context",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appCxt",
          "normalized": "Context a b(Cxt c a b d)-\u003eCxt c a b d",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "Context f a(Cxt h f a b)-\u003eCxt h f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a term homomorphism recursively to a term/context. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appHom",
          "package": "compdata",
          "signature": "Hom f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-Param-Algebra.html#appHom",
          "type": "function"
        },
        "index": {
          "description": "Apply term homomorphism recursively to term context",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appHom",
          "normalized": "Hom a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Hom",
          "signature": "Hom f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a term homomorphism recursively to a term/context. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appHom'",
          "package": "compdata",
          "signature": "Hom f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-Param-Algebra.html#appHom%27",
          "type": "function"
        },
        "index": {
          "description": "Apply term homomorphism recursively to term context",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appHom'",
          "normalized": "Hom a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Hom'",
          "signature": "Hom f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appHom-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a monadic term homomorphism recursively to a\n term/context. The monad is sequenced bottom-up.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appHomM",
          "package": "compdata",
          "signature": "HomM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Param-Algebra.html#appHomM",
          "type": "function"
        },
        "index": {
          "description": "Apply monadic term homomorphism recursively to term context The monad is sequenced bottom-up",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appHomM",
          "normalized": "HomM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Hom",
          "signature": "HomM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appHomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a monadic term homomorphism recursively to a\n term/context. The monad is sequence top-down.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appHomM'",
          "package": "compdata",
          "signature": "HomM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Param-Algebra.html#appHomM%27",
          "type": "function"
        },
        "index": {
          "description": "Apply monadic term homomorphism recursively to term context The monad is sequence top-down",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appHomM'",
          "normalized": "HomM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Hom M'",
          "signature": "HomM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appHomM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a signature function to the given context. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appSigFun",
          "package": "compdata",
          "signature": "SigFun f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-Param-Algebra.html#appSigFun",
          "type": "function"
        },
        "index": {
          "description": "This function applies signature function to the given context",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appSigFun",
          "normalized": "SigFun a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFun f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appSigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a signature function to the given\n context. This is a top-bottom variant of \u003ccode\u003e\u003ca\u003eappSigFun\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appSigFun'",
          "package": "compdata",
          "signature": "SigFun f g -\u003e CxtFun f g",
          "source": "src/Data-Comp-Param-Algebra.html#appSigFun%27",
          "type": "function"
        },
        "index": {
          "description": "This function applies signature function to the given context This is top-bottom variant of appSigFun",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appSigFun'",
          "normalized": "SigFun a b-\u003eCxtFun a b",
          "package": "compdata",
          "partial": "Sig Fun'",
          "signature": "SigFun f g-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appSigFun-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a monadic signature function to the given context. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appSigFunM",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Param-Algebra.html#appSigFunM",
          "type": "function"
        },
        "index": {
          "description": "This function applies monadic signature function to the given context",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appSigFunM",
          "normalized": "SigFunM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFunM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appSigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a monadic signature function to the given\n context. This is a 'top-down variant of \u003ccode\u003e\u003ca\u003eappSigFunM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appSigFunM'",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Param-Algebra.html#appSigFunM%27",
          "type": "function"
        },
        "index": {
          "description": "This function applies monadic signature function to the given context This is top-down variant of appSigFunM",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appSigFunM'",
          "normalized": "SigFunM a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Sig Fun M'",
          "signature": "SigFunM m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appSigFunM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a signature function to the given context. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appSigFunMD",
          "package": "compdata",
          "signature": "SigFunMD m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Param-Algebra.html#appSigFunMD",
          "type": "function"
        },
        "index": {
          "description": "This function applies signature function to the given context",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appSigFunMD",
          "normalized": "SigFunMD a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "Sig Fun MD",
          "signature": "SigFunMD m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appSigFunMD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA restricted form of |appHomM| which only works for terms. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appTHomM",
          "package": "compdata",
          "signature": "HomM m f g -\u003e Term f -\u003e m (Term g)",
          "source": "src/Data-Comp-Param-Algebra.html#appTHomM",
          "type": "function"
        },
        "index": {
          "description": "restricted form of appHomM which only works for terms",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appTHomM",
          "normalized": "HomM a b c-\u003eTerm b-\u003ea(Term c)",
          "package": "compdata",
          "partial": "THom",
          "signature": "HomM m f g-\u003eTerm f-\u003em(Term g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appTHomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA restricted form of |appHomM'| which only works for terms. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appTHomM'",
          "package": "compdata",
          "signature": "HomM m f g -\u003e Term f -\u003e m (Term g)",
          "source": "src/Data-Comp-Param-Algebra.html#appTHomM%27",
          "type": "function"
        },
        "index": {
          "description": "restricted form of appHomM which only works for terms",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appTHomM'",
          "normalized": "HomM a b c-\u003eTerm b-\u003ea(Term c)",
          "package": "compdata",
          "partial": "THom M'",
          "signature": "HomM m f g-\u003eTerm f-\u003em(Term g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appTHomM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA restricted form of |appSigFunM| which only works for terms. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appTSigFunM",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e Term f -\u003e m (Term g)",
          "source": "src/Data-Comp-Param-Algebra.html#appTSigFunM",
          "type": "function"
        },
        "index": {
          "description": "restricted form of appSigFunM which only works for terms",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appTSigFunM",
          "normalized": "SigFunM a b c-\u003eTerm b-\u003ea(Term c)",
          "package": "compdata",
          "partial": "TSig Fun",
          "signature": "SigFunM m f g-\u003eTerm f-\u003em(Term g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appTSigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA restricted form of |appSigFunM'| which only works for terms. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appTSigFunM'",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e Term f -\u003e m (Term g)",
          "source": "src/Data-Comp-Param-Algebra.html#appTSigFunM%27",
          "type": "function"
        },
        "index": {
          "description": "restricted form of appSigFunM which only works for terms",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appTSigFunM'",
          "normalized": "SigFunM a b c-\u003eTerm b-\u003ea(Term c)",
          "package": "compdata",
          "partial": "TSig Fun M'",
          "signature": "SigFunM m f g-\u003eTerm f-\u003em(Term g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appTSigFunM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA restricted form of |appSigFunMD| which only works for terms. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "appTSigFunMD",
          "package": "compdata",
          "signature": "SigFunMD m f g -\u003e Term f -\u003e m (Term g)",
          "source": "src/Data-Comp-Param-Algebra.html#appTSigFunMD",
          "type": "function"
        },
        "index": {
          "description": "restricted form of appSigFunMD which only works for terms",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "appTSigFunMD",
          "normalized": "SigFunMD a b c-\u003eTerm b-\u003ea(Term c)",
          "package": "compdata",
          "partial": "TSig Fun MD",
          "signature": "SigFunMD m f g-\u003eTerm f-\u003em(Term g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:appTSigFunMD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a catamorphism from the given algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "cata",
          "package": "compdata",
          "signature": "Alg f a -\u003e Term f -\u003e a",
          "source": "src/Data-Comp-Param-Algebra.html#cata",
          "type": "function"
        },
        "index": {
          "description": "Construct catamorphism from the given algebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "cata",
          "normalized": "Alg a b-\u003eTerm a-\u003eb",
          "package": "compdata",
          "signature": "Alg f a-\u003eTerm f-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:cata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalisation of \u003ccode\u003e\u003ca\u003ecata\u003c/a\u003e\u003c/code\u003e from terms over \u003ccode\u003ef\u003c/code\u003e to contexts over \u003ccode\u003ef\u003c/code\u003e, where\n  the holes have the type of the algebra carrier. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "cata'",
          "package": "compdata",
          "signature": "Alg f a -\u003e Cxt h f a a -\u003e a",
          "source": "src/Data-Comp-Param-Algebra.html#cata%27",
          "type": "function"
        },
        "index": {
          "description": "generalisation of cata from terms over to contexts over where the holes have the type of the algebra carrier",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "cata'",
          "normalized": "Alg a b-\u003eCxt c a b b-\u003eb",
          "package": "compdata",
          "signature": "Alg f a-\u003eCxt h f a a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:cata-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic catamorphism from the given monadic algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "cataM",
          "package": "compdata",
          "signature": "AlgM m f a -\u003e Term f -\u003e m a",
          "source": "src/Data-Comp-Param-Algebra.html#cataM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic catamorphism from the given monadic algebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "cataM",
          "normalized": "AlgM a b c-\u003eTerm b-\u003ea c",
          "package": "compdata",
          "signature": "AlgM m f a-\u003eTerm f-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:cataM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalisation of \u003ccode\u003e\u003ca\u003ecataM\u003c/a\u003e\u003c/code\u003e from terms over \u003ccode\u003ef\u003c/code\u003e to contexts over \u003ccode\u003ef\u003c/code\u003e, where\n  the holes have the type of the monadic algebra carrier. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "cataM'",
          "package": "compdata",
          "signature": "AlgM m f a -\u003e Cxt h f a (m a) -\u003e m a",
          "source": "src/Data-Comp-Param-Algebra.html#cataM%27",
          "type": "function"
        },
        "index": {
          "description": "generalisation of cataM from terms over to contexts over where the holes have the type of the monadic algebra carrier",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "cataM'",
          "normalized": "AlgM a b c-\u003eCxt d b c(a c)-\u003ea c",
          "package": "compdata",
          "partial": "M'",
          "signature": "AlgM m f a-\u003eCxt h f a(m a)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:cataM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose an algebra with a term homomorphism to get a new algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "compAlg",
          "package": "compdata",
          "signature": "Alg g a -\u003e Hom f g -\u003e Alg f a",
          "source": "src/Data-Comp-Param-Algebra.html#compAlg",
          "type": "function"
        },
        "index": {
          "description": "Compose an algebra with term homomorphism to get new algebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compAlg",
          "normalized": "Alg a b-\u003eHom c a-\u003eAlg c b",
          "package": "compdata",
          "partial": "Alg",
          "signature": "Alg g a-\u003eHom f g-\u003eAlg f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose a monadic algebra with a monadic term homomorphism to get a new\n  monadic algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "compAlgM",
          "package": "compdata",
          "signature": "AlgM m g a -\u003e HomM m f g -\u003e AlgM m f a",
          "source": "src/Data-Comp-Param-Algebra.html#compAlgM",
          "type": "function"
        },
        "index": {
          "description": "Compose monadic algebra with monadic term homomorphism to get new monadic algebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compAlgM",
          "normalized": "AlgM a b c-\u003eHomM a d b-\u003eAlgM a d c",
          "package": "compdata",
          "partial": "Alg",
          "signature": "AlgM m g a-\u003eHomM m f g-\u003eAlgM m f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compAlgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose a monadic algebra with a term homomorphism to get a new monadic\n  algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "compAlgM'",
          "package": "compdata",
          "signature": "AlgM m g a -\u003e Hom f g -\u003e AlgM m f a",
          "source": "src/Data-Comp-Param-Algebra.html#compAlgM%27",
          "type": "function"
        },
        "index": {
          "description": "Compose monadic algebra with term homomorphism to get new monadic algebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compAlgM'",
          "normalized": "AlgM a b c-\u003eHom d b-\u003eAlgM a d c",
          "package": "compdata",
          "partial": "Alg M'",
          "signature": "AlgM m g a-\u003eHom f g-\u003eAlgM m f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compAlgM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Algebra",
          "name": "compAlgSigFun",
          "package": "compdata",
          "signature": "Alg g a -\u003e SigFun f g -\u003e Alg f a",
          "source": "src/Data-Comp-Param-Algebra.html#compAlgSigFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compAlgSigFun",
          "normalized": "Alg a b-\u003eSigFun c a-\u003eAlg c b",
          "package": "compdata",
          "partial": "Alg Sig Fun",
          "signature": "Alg g a-\u003eSigFun f g-\u003eAlg f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compAlgSigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose a monadic algebra with a monadic signature function to get a new\n  monadic algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "compAlgSigFunM",
          "package": "compdata",
          "signature": "AlgM m g a -\u003e SigFunM m f g -\u003e AlgM m f a",
          "source": "src/Data-Comp-Param-Algebra.html#compAlgSigFunM",
          "type": "function"
        },
        "index": {
          "description": "Compose monadic algebra with monadic signature function to get new monadic algebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compAlgSigFunM",
          "normalized": "AlgM a b c-\u003eSigFunM a d b-\u003eAlgM a d c",
          "package": "compdata",
          "partial": "Alg Sig Fun",
          "signature": "AlgM m g a-\u003eSigFunM m f g-\u003eAlgM m f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compAlgSigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose a monadic algebra with a signature function to get a new monadic\n  algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "compAlgSigFunM'",
          "package": "compdata",
          "signature": "AlgM m g a -\u003e SigFun f g -\u003e AlgM m f a",
          "source": "src/Data-Comp-Param-Algebra.html#compAlgSigFunM%27",
          "type": "function"
        },
        "index": {
          "description": "Compose monadic algebra with signature function to get new monadic algebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compAlgSigFunM'",
          "normalized": "AlgM a b c-\u003eSigFun d b-\u003eAlgM a d c",
          "package": "compdata",
          "partial": "Alg Sig Fun M'",
          "signature": "AlgM m g a-\u003eSigFun f g-\u003eAlgM m f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compAlgSigFunM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose two term homomorphisms. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "compHom",
          "package": "compdata",
          "signature": "Hom g h -\u003e Hom f g -\u003e Hom f h",
          "source": "src/Data-Comp-Param-Algebra.html#compHom",
          "type": "function"
        },
        "index": {
          "description": "Compose two term homomorphisms",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compHom",
          "normalized": "Hom a b-\u003eHom c a-\u003eHom c b",
          "package": "compdata",
          "partial": "Hom",
          "signature": "Hom g h-\u003eHom f g-\u003eHom f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose two monadic term homomorphisms. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "compHomM",
          "package": "compdata",
          "signature": "HomM m g h -\u003e HomM m f g -\u003e HomM m f h",
          "source": "src/Data-Comp-Param-Algebra.html#compHomM",
          "type": "function"
        },
        "index": {
          "description": "Compose two monadic term homomorphisms",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compHomM",
          "normalized": "HomM a b c-\u003eHomM a d b-\u003eHomM a d c",
          "package": "compdata",
          "partial": "Hom",
          "signature": "HomM m g h-\u003eHomM m f g-\u003eHomM m f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compHomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose two monadic term homomorphisms. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "compHomM'",
          "package": "compdata",
          "signature": "HomM m g h -\u003e HomM m f g -\u003e HomM m f h",
          "source": "src/Data-Comp-Param-Algebra.html#compHomM%27",
          "type": "function"
        },
        "index": {
          "description": "Compose two monadic term homomorphisms",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compHomM'",
          "normalized": "HomM a b c-\u003eHomM a d b-\u003eHomM a d c",
          "package": "compdata",
          "partial": "Hom M'",
          "signature": "HomM m g h-\u003eHomM m f g-\u003eHomM m f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compHomM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a term homomorphism and a signature function. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "compHomSigFun",
          "package": "compdata",
          "signature": "Hom g h -\u003e SigFun f g -\u003e Hom f h",
          "source": "src/Data-Comp-Param-Algebra.html#compHomSigFun",
          "type": "function"
        },
        "index": {
          "description": "This function composes term homomorphism and signature function",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compHomSigFun",
          "normalized": "Hom a b-\u003eSigFun c a-\u003eHom c b",
          "package": "compdata",
          "partial": "Hom Sig Fun",
          "signature": "Hom g h-\u003eSigFun f g-\u003eHom f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compHomSigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two signature functions. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "compSigFun",
          "package": "compdata",
          "signature": "SigFun g h -\u003e SigFun f g -\u003e SigFun f h",
          "source": "src/Data-Comp-Param-Algebra.html#compSigFun",
          "type": "function"
        },
        "index": {
          "description": "This function composes two signature functions",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compSigFun",
          "normalized": "SigFun a b-\u003eSigFun c a-\u003eSigFun c b",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFun g h-\u003eSigFun f g-\u003eSigFun f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compSigFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a term homomorphism and a signature function. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "compSigFunHom",
          "package": "compdata",
          "signature": "SigFun g h -\u003e Hom f g -\u003e Hom f h",
          "source": "src/Data-Comp-Param-Algebra.html#compSigFunHom",
          "type": "function"
        },
        "index": {
          "description": "This function composes term homomorphism and signature function",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compSigFunHom",
          "normalized": "SigFun a b-\u003eHom c a-\u003eHom c b",
          "package": "compdata",
          "partial": "Sig Fun Hom",
          "signature": "SigFun g h-\u003eHom f g-\u003eHom f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compSigFunHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose two monadic term homomorphisms. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "compSigFunHomM",
          "package": "compdata",
          "signature": "SigFunM m g h -\u003e HomM m f g -\u003e HomM m f h",
          "source": "src/Data-Comp-Param-Algebra.html#compSigFunHomM",
          "type": "function"
        },
        "index": {
          "description": "Compose two monadic term homomorphisms",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compSigFunHomM",
          "normalized": "SigFunM a b c-\u003eHomM a d b-\u003eHomM a d c",
          "package": "compdata",
          "partial": "Sig Fun Hom",
          "signature": "SigFunM m g h-\u003eHomM m f g-\u003eHomM m f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compSigFunHomM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose two monadic term homomorphisms. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "compSigFunHomM'",
          "package": "compdata",
          "signature": "SigFunM m g h -\u003e HomM m f g -\u003e HomM m f h",
          "source": "src/Data-Comp-Param-Algebra.html#compSigFunHomM%27",
          "type": "function"
        },
        "index": {
          "description": "Compose two monadic term homomorphisms",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compSigFunHomM'",
          "normalized": "SigFunM a b c-\u003eHomM a d b-\u003eHomM a d c",
          "package": "compdata",
          "partial": "Sig Fun Hom M'",
          "signature": "SigFunM m g h-\u003eHomM m f g-\u003eHomM m f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compSigFunHomM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two monadic signature functions. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "compSigFunM",
          "package": "compdata",
          "signature": "SigFunM m g h -\u003e SigFunM m f g -\u003e SigFunM m f h",
          "source": "src/Data-Comp-Param-Algebra.html#compSigFunM",
          "type": "function"
        },
        "index": {
          "description": "This function composes two monadic signature functions",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "compSigFunM",
          "normalized": "SigFunM a b c-\u003eSigFunM a d b-\u003eSigFunM a d c",
          "package": "compdata",
          "partial": "Sig Fun",
          "signature": "SigFunM m g h-\u003eSigFunM m f g-\u003eSigFunM m f h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:compSigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a catamorphism for contexts over \u003ccode\u003ef\u003c/code\u003e with holes of type \u003ccode\u003eb\u003c/code\u003e, from\n  the given algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "free",
          "package": "compdata",
          "signature": "Alg f a -\u003e (b -\u003e a) -\u003e Cxt h f a b -\u003e a",
          "source": "src/Data-Comp-Param-Algebra.html#free",
          "type": "function"
        },
        "index": {
          "description": "Construct catamorphism for contexts over with holes of type from the given algebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "free",
          "normalized": "Alg a b-\u003e(c-\u003eb)-\u003eCxt d a b c-\u003eb",
          "package": "compdata",
          "signature": "Alg f a-\u003e(b-\u003ea)-\u003eCxt h f a b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:free"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic catamorphism for contexts over \u003ccode\u003ef\u003c/code\u003e with holes of type\n  \u003ccode\u003eb\u003c/code\u003e, from the given monadic algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "freeM",
          "package": "compdata",
          "signature": "AlgM m f a -\u003e (b -\u003e m a) -\u003e Cxt h f a b -\u003e m a",
          "source": "src/Data-Comp-Param-Algebra.html#freeM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic catamorphism for contexts over with holes of type from the given monadic algebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "freeM",
          "normalized": "AlgM a b c-\u003e(d-\u003ea c)-\u003eCxt e b c d-\u003ea c",
          "package": "compdata",
          "signature": "AlgM m f a-\u003e(b-\u003em a)-\u003eCxt h f a b-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:freeM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a futumorphism from the given cv-coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "futu",
          "package": "compdata",
          "signature": "CVCoalg f a -\u003e a -\u003e Term f",
          "source": "src/Data-Comp-Param-Algebra.html#futu",
          "type": "function"
        },
        "index": {
          "description": "Construct futumorphism from the given cv-coalgebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "futu",
          "normalized": "CVCoalg a b-\u003eb-\u003eTerm a",
          "package": "compdata",
          "signature": "CVCoalg f a-\u003ea-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:futu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a futumorphism from the given generalised cv-coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "futu'",
          "package": "compdata",
          "signature": "CVCoalg' f a -\u003e a -\u003e Term f",
          "source": "src/Data-Comp-Param-Algebra.html#futu%27",
          "type": "function"
        },
        "index": {
          "description": "Construct futumorphism from the given generalised cv-coalgebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "futu'",
          "normalized": "CVCoalg' a b-\u003eb-\u003eTerm a",
          "package": "compdata",
          "signature": "CVCoalg' f a-\u003ea-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:futu-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic futumorphism from the given monadic cv-coalgebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "futuM",
          "package": "compdata",
          "signature": "CVCoalgM m f a -\u003e a -\u003e forall a.  m (Trm f a)",
          "source": "src/Data-Comp-Param-Algebra.html#futuM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic futumorphism from the given monadic cv-coalgebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "futuM",
          "normalized": "CVCoalgM a b c-\u003ec-\u003ed e a(Trm b c)",
          "package": "compdata",
          "signature": "CVCoalgM m f a-\u003ea-\u003eforall a. m(Trm f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:futuM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a histomorphism from the given cv-algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "histo",
          "package": "compdata",
          "signature": "CVAlg f a f' -\u003e Term f -\u003e a",
          "source": "src/Data-Comp-Param-Algebra.html#histo",
          "type": "function"
        },
        "index": {
          "description": "Construct histomorphism from the given cv-algebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "histo",
          "normalized": "CVAlg a b c-\u003eTerm a-\u003eb",
          "package": "compdata",
          "signature": "CVAlg f a f'-\u003eTerm f-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:histo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic histomorphism from the given monadic cv-algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "histoM",
          "package": "compdata",
          "signature": "CVAlgM m f a f' -\u003e Term f -\u003e m a",
          "source": "src/Data-Comp-Param-Algebra.html#histoM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic histomorphism from the given monadic cv-algebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "histoM",
          "normalized": "CVAlgM a b c d-\u003eTerm b-\u003ea c",
          "package": "compdata",
          "signature": "CVAlgM m f a f'-\u003eTerm f-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:histoM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLifts the given signature function to the canonical term homomorphism. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "hom",
          "package": "compdata",
          "signature": "SigFun f g -\u003e Hom f g",
          "source": "src/Data-Comp-Param-Algebra.html#hom",
          "type": "function"
        },
        "index": {
          "description": "Lifts the given signature function to the canonical term homomorphism",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "hom",
          "normalized": "SigFun a b-\u003eHom a b",
          "package": "compdata",
          "signature": "SigFun f g-\u003eHom f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:hom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift the given signature function to a monadic term homomorphism. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "homM",
          "package": "compdata",
          "signature": "SigFunM m f g -\u003e HomM m f g",
          "source": "src/Data-Comp-Param-Algebra.html#homM",
          "type": "function"
        },
        "index": {
          "description": "Lift the given signature function to monadic term homomorphism",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "homM",
          "normalized": "SigFunM a b c-\u003eHomM a b c",
          "package": "compdata",
          "signature": "SigFunM m f g-\u003eHomM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:homM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function constructs the unique monadic homomorphism from the\n  initial term algebra to the given term algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "homMD",
          "package": "compdata",
          "signature": "HomMD m f g -\u003e CxtFunM m f g",
          "source": "src/Data-Comp-Param-Algebra.html#homMD",
          "type": "function"
        },
        "index": {
          "description": "This function constructs the unique monadic homomorphism from the initial term algebra to the given term algebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "homMD",
          "normalized": "HomMD a b c-\u003eCxtFunM a b c",
          "package": "compdata",
          "partial": "MD",
          "signature": "HomMD m f g-\u003eCxtFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:homMD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a paramorphism from the given r-algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "para",
          "package": "compdata",
          "signature": "RAlg f a -\u003e Term f -\u003e a",
          "source": "src/Data-Comp-Param-Algebra.html#para",
          "type": "function"
        },
        "index": {
          "description": "Construct paramorphism from the given r-algebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "para",
          "normalized": "RAlg a b-\u003eTerm a-\u003eb",
          "package": "compdata",
          "signature": "RAlg f a-\u003eTerm f-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:para"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a monadic paramorphism from the given monadic r-algebra. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "paraM",
          "package": "compdata",
          "signature": "RAlgM m f a -\u003e Term f -\u003e m a",
          "source": "src/Data-Comp-Param-Algebra.html#paraM",
          "type": "function"
        },
        "index": {
          "description": "Construct monadic paramorphism from the given monadic r-algebra",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "paraM",
          "normalized": "RAlgM a b c-\u003eTerm b-\u003ea c",
          "package": "compdata",
          "signature": "RAlgM m f a-\u003eTerm f-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:paraM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift the given signature function to a monadic signature function. Note that\n  term homomorphisms are instances of signature functions. Hence this function\n  also applies to term homomorphisms. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Algebra",
          "name": "sigFunM",
          "package": "compdata",
          "signature": "SigFun f g -\u003e SigFunM m f g",
          "source": "src/Data-Comp-Param-Algebra.html#sigFunM",
          "type": "function"
        },
        "index": {
          "description": "Lift the given signature function to monadic signature function Note that term homomorphisms are instances of signature functions Hence this function also applies to term homomorphisms",
          "hierarchy": "Data Comp Param Algebra",
          "module": "Data.Comp.Param.Algebra",
          "name": "sigFunM",
          "normalized": "SigFun a b-\u003eSigFunM c a b",
          "package": "compdata",
          "partial": "Fun",
          "signature": "SigFun f g-\u003eSigFunM m f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Algebra.html#v:sigFunM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines annotations on signatures.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param.Annotation",
          "name": "Annotation",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Annotation.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines annotations on signatures",
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": "Annotation",
          "package": "compdata",
          "partial": "Annotation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type adds a constant product to a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Annotation",
          "name": ":&:",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ops.html#%3A%26%3A",
          "type": "data"
        },
        "index": {
          "description": "This data type adds constant product to signature",
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": ":&:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#t::-38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal product of signatures (difunctors).\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Annotation",
          "name": ":*:",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ops.html#%3A%2A%3A",
          "type": "data"
        },
        "index": {
          "description": "Formal product of signatures difunctors",
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": ":*:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#t::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class defines how to distribute an annotation over a sum of\n  signatures. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Annotation",
          "name": "DistAnn",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ops.html#DistAnn",
          "type": "class"
        },
        "index": {
          "description": "This class defines how to distribute an annotation over sum of signatures",
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": "DistAnn",
          "package": "compdata",
          "partial": "Dist Ann",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#t:DistAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Annotation",
          "name": "RemA",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ops.html#RemA",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": "RemA",
          "package": "compdata",
          "partial": "Rem",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#t:RemA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.Param.Annotation\",\"Data.Comp.Param.Ops\"]",
          "name": ":&:",
          "package": "compdata",
          "signature": "(f a b) :&: p",
          "source": "src/Data-Comp-Param-Ops.html#%3A%26%3A",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#v::-38-:\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#v::-38-:\"]"
        },
        "index": {
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": ":&:",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#v::-38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Comp.Param.Annotation\",\"Data.Comp.Param.Ops\"]",
          "name": ":*:",
          "package": "compdata",
          "signature": "(f a b) :*: (g a b)",
          "source": "src/Data-Comp-Param-Ops.html#%3A%2A%3A",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#v::-42-:\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#v::-42-:\"]"
        },
        "index": {
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": ":*:",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#v::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnnotate each node of a term with a constant value. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Annotation",
          "name": "ann",
          "package": "compdata",
          "signature": "p -\u003e CxtFun f g",
          "source": "src/Data-Comp-Param-Annotation.html#ann",
          "type": "function"
        },
        "index": {
          "description": "Annotate each node of term with constant value",
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": "ann",
          "normalized": "a-\u003eCxtFun b c",
          "package": "compdata",
          "signature": "p-\u003eCxtFun f g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#v:ann"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject an annotation over a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Annotation",
          "name": "injectA",
          "package": "compdata",
          "signature": "p -\u003e s a b -\u003e s' a b",
          "source": "src/Data-Comp-Param-Ops.html#injectA",
          "type": "method"
        },
        "index": {
          "description": "Inject an annotation over signature",
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": "injectA",
          "normalized": "a-\u003eb c d-\u003ee c d",
          "package": "compdata",
          "signature": "p-\u003es a b-\u003es' a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#v:injectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform a function with a domain constructed from a functor to a function\n with a domain constructed with the same functor, but with an additional\n annotation. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Annotation",
          "name": "liftA",
          "package": "compdata",
          "signature": "(s' a b -\u003e t) -\u003e s a b -\u003e t",
          "source": "src/Data-Comp-Param-Annotation.html#liftA",
          "type": "function"
        },
        "index": {
          "description": "Transform function with domain constructed from functor to function with domain constructed with the same functor but with an additional annotation",
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": "liftA",
          "normalized": "(a b c-\u003ed)-\u003ee b c-\u003ed",
          "package": "compdata",
          "signature": "(s' a b-\u003et)-\u003es a b-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#v:liftA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform a function with a domain constructed from a functor to a function\n  with a domain constructed with the same functor, but with an additional\n  annotation. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Annotation",
          "name": "liftA'",
          "package": "compdata",
          "signature": "(s' a b -\u003e Cxt h s' c d) -\u003e s a b -\u003e Cxt h s c d",
          "source": "src/Data-Comp-Param-Annotation.html#liftA%27",
          "type": "function"
        },
        "index": {
          "description": "Transform function with domain constructed from functor to function with domain constructed with the same functor but with an additional annotation",
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": "liftA'",
          "normalized": "(a b c-\u003eCxt d a e f)-\u003eg b c-\u003eCxt d g e f",
          "package": "compdata",
          "partial": "A'",
          "signature": "(s' a b-\u003eCxt h s' c d)-\u003es a b-\u003eCxt h s c d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#v:liftA-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function is similar to \u003ccode\u003e\u003ca\u003eproject\u003c/a\u003e\u003c/code\u003e but applies to signatures\nwith an annotation which is then ignored. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Annotation",
          "name": "project'",
          "package": "compdata",
          "signature": "Cxt h f a b -\u003e Maybe (s a (Cxt h f a b))",
          "source": "src/Data-Comp-Param-Annotation.html#project%27",
          "type": "function"
        },
        "index": {
          "description": "This function is similar to project but applies to signatures with an annotation which is then ignored",
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": "project'",
          "normalized": "Cxt a b c d-\u003eMaybe(e c(Cxt a b c d))",
          "package": "compdata",
          "signature": "Cxt h f a b-\u003eMaybe(s a(Cxt h f a b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#v:project-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject an annotation from a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Annotation",
          "name": "projectA",
          "package": "compdata",
          "signature": "s' a b -\u003e (s a b, p)",
          "source": "src/Data-Comp-Param-Ops.html#projectA",
          "type": "method"
        },
        "index": {
          "description": "Project an annotation from signature",
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": "projectA",
          "normalized": "a b c-\u003e(d b c,e)",
          "package": "compdata",
          "signature": "s' a b-\u003e(s a b,p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#v:projectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a term homomorphism over signatures \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e to a term homomorphism\n over the same signatures, but extended with annotations. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Annotation",
          "name": "propAnn",
          "package": "compdata",
          "signature": "Hom f g -\u003e Hom f' g'",
          "source": "src/Data-Comp-Param-Annotation.html#propAnn",
          "type": "function"
        },
        "index": {
          "description": "Lift term homomorphism over signatures and to term homomorphism over the same signatures but extended with annotations",
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": "propAnn",
          "normalized": "Hom a b-\u003eHom c d",
          "package": "compdata",
          "partial": "Ann",
          "signature": "Hom f g-\u003eHom f' g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#v:propAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a monadic term homomorphism over signatures \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e to a monadic\n  term homomorphism over the same signatures, but extended with annotations. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Annotation",
          "name": "propAnnM",
          "package": "compdata",
          "signature": "HomM m f g -\u003e HomM m f' g'",
          "source": "src/Data-Comp-Param-Annotation.html#propAnnM",
          "type": "function"
        },
        "index": {
          "description": "Lift monadic term homomorphism over signatures and to monadic term homomorphism over the same signatures but extended with annotations",
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": "propAnnM",
          "normalized": "HomM a b c-\u003eHomM a d e",
          "package": "compdata",
          "partial": "Ann",
          "signature": "HomM m f g-\u003eHomM m f' g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#v:propAnnM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove annotations from a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Annotation",
          "name": "remA",
          "package": "compdata",
          "signature": "s a b -\u003e s' a b",
          "source": "src/Data-Comp-Param-Ops.html#remA",
          "type": "method"
        },
        "index": {
          "description": "Remove annotations from signature",
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": "remA",
          "normalized": "a b c-\u003ed b c",
          "package": "compdata",
          "signature": "s a b-\u003es' a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#v:remA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrip the annotations from a term over a functor with annotations. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Annotation",
          "name": "stripA",
          "package": "compdata",
          "signature": "CxtFun g f",
          "source": "src/Data-Comp-Param-Annotation.html#stripA",
          "type": "function"
        },
        "index": {
          "description": "Strip the annotations from term over functor with annotations",
          "hierarchy": "Data Comp Param Annotation",
          "module": "Data.Comp.Param.Annotation",
          "name": "stripA",
          "package": "compdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Annotation.html#v:stripA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains functionality for automatically deriving boilerplate\n code using Template Haskell. Examples include instances of \u003ccode\u003e\u003ca\u003eDifunctor\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003eDifoldable\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eDitraversable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param.Derive",
          "name": "Derive",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Derive.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains functionality for automatically deriving boilerplate code using Template Haskell Examples include instances of Difunctor Difoldable and Ditraversable",
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "Derive",
          "package": "compdata",
          "partial": "Derive",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class represents difunctors, i.e. binary type constructors that are\n contravariant in the first argument and covariant in the second argument.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Derive",
          "name": "Difunctor",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Difunctor.html#Difunctor",
          "type": "class"
        },
        "index": {
          "description": "This class represents difunctors i.e binary type constructors that are contravariant in the first argument and covariant in the second argument",
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "Difunctor",
          "package": "compdata",
          "partial": "Difunctor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#t:Difunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDifunctors representing data structures that can be traversed from left to\n  right. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Derive",
          "name": "Ditraversable",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ditraversable.html#Ditraversable",
          "type": "class"
        },
        "index": {
          "description": "Difunctors representing data structures that can be traversed from left to right",
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "Ditraversable",
          "package": "compdata",
          "partial": "Ditraversable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#t:Ditraversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature equality. An instance \u003ccode\u003eEqD f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eEq (Term f)\u003c/code\u003e. The equality test is performed inside the \u003ccode\u003e\u003ca\u003eFreshM\u003c/a\u003e\u003c/code\u003e monad for\n  generating fresh identifiers. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Derive",
          "name": "EqD",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Equality.html#EqD",
          "type": "class"
        },
        "index": {
          "description": "Signature equality An instance EqD gives rise to an instance Eq Term The equality test is performed inside the FreshM monad for generating fresh identifiers",
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "EqD",
          "package": "compdata",
          "partial": "Eq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#t:EqD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature ordering. An instance \u003ccode\u003eOrdD f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eOrd (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Derive",
          "name": "OrdD",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ordering.html#OrdD",
          "type": "class"
        },
        "index": {
          "description": "Signature ordering An instance OrdD gives rise to an instance Ord Term",
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "OrdD",
          "package": "compdata",
          "partial": "Ord",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#t:OrdD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature printing. An instance \u003ccode\u003eShowD f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eShow (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Derive",
          "name": "ShowD",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Derive-Show.html#ShowD",
          "type": "class"
        },
        "index": {
          "description": "Signature printing An instance ShowD gives rise to an instance Show Term",
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "ShowD",
          "package": "compdata",
          "partial": "Show",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#t:ShowD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Derive",
          "name": "compareD",
          "package": "compdata",
          "signature": "f Name a -\u003e f Name a -\u003e FreshM Ordering",
          "source": "src/Data-Comp-Param-Ordering.html#compareD",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "compareD",
          "normalized": "a Name b-\u003ea Name b-\u003eFreshM Ordering",
          "package": "compdata",
          "signature": "f Name a-\u003ef Name a-\u003eFreshM Ordering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#v:compareD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Derive",
          "name": "eqD",
          "package": "compdata",
          "signature": "f Name a -\u003e f Name a -\u003e FreshM Bool",
          "source": "src/Data-Comp-Param-Equality.html#eqD",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "eqD",
          "normalized": "a Name b-\u003ea Name b-\u003eFreshM Bool",
          "package": "compdata",
          "signature": "f Name a-\u003ef Name a-\u003eFreshM Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#v:eqD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven the name of a type class, where the first parameter is a difunctor,\n  lift it to sums of difunctors. Example: \u003ccode\u003eclass ShowD f where ...\u003c/code\u003e is lifted\n  as \u003ccode\u003einstance (ShowD f, ShowD g) =\u003e ShowD (f :+: g) where ... \u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Derive",
          "name": "liftSum",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Param-Derive.html#liftSum",
          "type": "function"
        },
        "index": {
          "description": "Given the name of type class where the first parameter is difunctor lift it to sums of difunctors Example class ShowD where is lifted as instance ShowD ShowD ShowD where",
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "liftSum",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Sum",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#v:liftSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eDifunctor\u003c/a\u003e\u003c/code\u003e for a type constructor of any parametric\n  kind taking at least two arguments. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Derive",
          "name": "makeDifunctor",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Param-Derive-Difunctor.html#makeDifunctor",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of Difunctor for type constructor of any parametric kind taking at least two arguments",
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "makeDifunctor",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Difunctor",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#v:makeDifunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003eTraversable\u003c/code\u003e for a type constructor of any\n  first-order kind taking at least one argument. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Derive",
          "name": "makeDitraversable",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Param-Derive-Ditraversable.html#makeDitraversable",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of Traversable for type constructor of any first-order kind taking at least one argument",
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "makeDitraversable",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Ditraversable",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#v:makeDitraversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eEqD\u003c/a\u003e\u003c/code\u003e for a type constructor of any parametric\n  kind taking at least two arguments. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Derive",
          "name": "makeEqD",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Param-Derive-Equality.html#makeEqD",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of EqD for type constructor of any parametric kind taking at least two arguments",
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "makeEqD",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Eq",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#v:makeEqD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eOrdD\u003c/a\u003e\u003c/code\u003e for a type constructor of any parametric\n  kind taking at least two arguments. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Derive",
          "name": "makeOrdD",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Param-Derive-Ordering.html#makeOrdD",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of OrdD for type constructor of any parametric kind taking at least two arguments",
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "makeOrdD",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Ord",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#v:makeOrdD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of \u003ccode\u003e\u003ca\u003eShowD\u003c/a\u003e\u003c/code\u003e for a type constructor of any parametric\n  kind taking at least two arguments. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Derive",
          "name": "makeShowD",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Param-Derive-Show.html#makeShowD",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of ShowD for type constructor of any parametric kind taking at least two arguments",
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "makeShowD",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Show",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#v:makeShowD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Derive",
          "name": "showD",
          "package": "compdata",
          "signature": "f Name (FreshM String) -\u003e FreshM String",
          "source": "src/Data-Comp-Param-Derive-Show.html#showD",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "showD",
          "normalized": "a Name(FreshM String)-\u003eFreshM String",
          "package": "compdata",
          "signature": "f Name(FreshM String)-\u003eFreshM String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#v:showD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive smart constructors with annotations for a difunctor. The smart\n constructors are similar to the ordinary constructors, but a\n 'injectA . dimap Var id' is automatically inserted. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Derive",
          "name": "smartAConstructors",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Param-Derive-SmartAConstructors.html#smartAConstructors",
          "type": "function"
        },
        "index": {
          "description": "Derive smart constructors with annotations for difunctor The smart constructors are similar to the ordinary constructors but injectA dimap Var id is automatically inserted",
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "smartAConstructors",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "AConstructors",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#v:smartAConstructors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive smart constructors for a difunctor. The smart constructors are\n similar to the ordinary constructors, but a 'inject . dimap Var id' is\n automatically inserted. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Derive",
          "name": "smartConstructors",
          "package": "compdata",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Data-Comp-Param-Derive-SmartConstructors.html#smartConstructors",
          "type": "function"
        },
        "index": {
          "description": "Derive smart constructors for difunctor The smart constructors are similar to the ordinary constructors but inject dimap Var id is automatically inserted",
          "hierarchy": "Data Comp Param Derive",
          "module": "Data.Comp.Param.Derive",
          "name": "smartConstructors",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "compdata",
          "partial": "Constructors",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Derive.html#v:smartConstructors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis modules defines the \u003ccode\u003e\u003ca\u003eDesugar\u003c/a\u003e\u003c/code\u003e type class for desugaring of terms.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Desugar.html",
          "type": "module"
        },
        "index": {
          "description": "This modules defines the Desugar type class for desugaring of terms",
          "hierarchy": "Data Comp Param Desugar",
          "module": "Data.Comp.Param.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "partial": "Desugar",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Desugar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe desugaring term homomorphism.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Desugar.html#Desugar",
          "type": "class"
        },
        "index": {
          "description": "The desugaring term homomorphism",
          "hierarchy": "Data Comp Param Desugar",
          "module": "Data.Comp.Param.Desugar",
          "name": "Desugar",
          "package": "compdata",
          "partial": "Desugar",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Desugar.html#t:Desugar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Desugar",
          "name": "desugHom",
          "package": "compdata",
          "signature": "Hom f g",
          "source": "src/Data-Comp-Param-Desugar.html#desugHom",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Desugar",
          "module": "Data.Comp.Param.Desugar",
          "name": "desugHom",
          "package": "compdata",
          "partial": "Hom",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Desugar.html#v:desugHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Desugar",
          "name": "desugHom'",
          "package": "compdata",
          "signature": "f a (Cxt h g a b) -\u003e Cxt h g a b",
          "source": "src/Data-Comp-Param-Desugar.html#desugHom%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Desugar",
          "module": "Data.Comp.Param.Desugar",
          "name": "desugHom'",
          "normalized": "a b(Cxt c d b e)-\u003eCxt c d b e",
          "package": "compdata",
          "partial": "Hom'",
          "signature": "f a(Cxt h g a b)-\u003eCxt h g a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Desugar.html#v:desugHom-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDesugar a term.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Desugar",
          "name": "desugar",
          "package": "compdata",
          "signature": "Term f -\u003e Term g",
          "source": "src/Data-Comp-Param-Desugar.html#desugar",
          "type": "function"
        },
        "index": {
          "description": "Desugar term",
          "hierarchy": "Data Comp Param Desugar",
          "module": "Data.Comp.Param.Desugar",
          "name": "desugar",
          "normalized": "Term a-\u003eTerm b",
          "package": "compdata",
          "signature": "Term f-\u003eTerm g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Desugar.html#v:desugar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift desugaring to annotated terms.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Desugar",
          "name": "desugarA",
          "package": "compdata",
          "signature": "Term f' -\u003e Term g'",
          "source": "src/Data-Comp-Param-Desugar.html#desugarA",
          "type": "function"
        },
        "index": {
          "description": "Lift desugaring to annotated terms",
          "hierarchy": "Data Comp Param Desugar",
          "module": "Data.Comp.Param.Desugar",
          "name": "desugarA",
          "normalized": "Term a-\u003eTerm b",
          "package": "compdata",
          "signature": "Term f'-\u003eTerm g'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Desugar.html#v:desugarA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines difunctors (Meijer, Hutton, FPCA '95), i.e. binary type\n constructors that are contravariant in the first argument and covariant in\n the second argument.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param.Difunctor",
          "name": "Difunctor",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Difunctor.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines difunctors Meijer Hutton FPCA i.e binary type constructors that are contravariant in the first argument and covariant in the second argument",
          "hierarchy": "Data Comp Param Difunctor",
          "module": "Data.Comp.Param.Difunctor",
          "name": "Difunctor",
          "package": "compdata",
          "partial": "Difunctor",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Difunctor.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class represents difunctors, i.e. binary type constructors that are\n contravariant in the first argument and covariant in the second argument.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Difunctor",
          "name": "Difunctor",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Difunctor.html#Difunctor",
          "type": "class"
        },
        "index": {
          "description": "This class represents difunctors i.e binary type constructors that are contravariant in the first argument and covariant in the second argument",
          "hierarchy": "Data Comp Param Difunctor",
          "module": "Data.Comp.Param.Difunctor",
          "name": "Difunctor",
          "package": "compdata",
          "partial": "Difunctor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Difunctor.html#t:Difunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Difunctor",
          "name": "difmap",
          "package": "compdata",
          "signature": "(a -\u003e b) -\u003e f c a -\u003e f c b",
          "source": "src/Data-Comp-Param-Difunctor.html#difmap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Difunctor",
          "module": "Data.Comp.Param.Difunctor",
          "name": "difmap",
          "normalized": "(a-\u003eb)-\u003ec d a-\u003ec d b",
          "package": "compdata",
          "signature": "(a-\u003eb)-\u003ef c a-\u003ef c b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Difunctor.html#v:difmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Difunctor",
          "name": "dimap",
          "package": "compdata",
          "signature": "(a -\u003e b) -\u003e (c -\u003e d) -\u003e f b c -\u003e f a d",
          "source": "src/Data-Comp-Param-Difunctor.html#dimap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Difunctor",
          "module": "Data.Comp.Param.Difunctor",
          "name": "dimap",
          "normalized": "(a-\u003eb)-\u003e(c-\u003ed)-\u003ee b c-\u003ee a d",
          "package": "compdata",
          "signature": "(a-\u003eb)-\u003e(c-\u003ed)-\u003ef b c-\u003ef a d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Difunctor.html#v:dimap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines traversable difunctors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param.Ditraversable",
          "name": "Ditraversable",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ditraversable.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines traversable difunctors",
          "hierarchy": "Data Comp Param Ditraversable",
          "module": "Data.Comp.Param.Ditraversable",
          "name": "Ditraversable",
          "package": "compdata",
          "partial": "Ditraversable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ditraversable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDifunctors representing data structures that can be traversed from left to\n  right. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Ditraversable",
          "name": "Ditraversable",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ditraversable.html#Ditraversable",
          "type": "class"
        },
        "index": {
          "description": "Difunctors representing data structures that can be traversed from left to right",
          "hierarchy": "Data Comp Param Ditraversable",
          "module": "Data.Comp.Param.Ditraversable",
          "name": "Ditraversable",
          "package": "compdata",
          "partial": "Ditraversable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ditraversable.html#t:Ditraversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Ditraversable",
          "name": "dimapM",
          "package": "compdata",
          "signature": "(b -\u003e m c) -\u003e f a b -\u003e m (f a c)",
          "source": "src/Data-Comp-Param-Ditraversable.html#dimapM",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Ditraversable",
          "module": "Data.Comp.Param.Ditraversable",
          "name": "dimapM",
          "normalized": "(a-\u003eb c)-\u003ed e a-\u003eb(d e c)",
          "package": "compdata",
          "signature": "(b-\u003em c)-\u003ef a b-\u003em(f a c)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ditraversable.html#v:dimapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Ditraversable",
          "name": "disequence",
          "package": "compdata",
          "signature": "f a (m b) -\u003e m (f a b)",
          "source": "src/Data-Comp-Param-Ditraversable.html#disequence",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Ditraversable",
          "module": "Data.Comp.Param.Ditraversable",
          "name": "disequence",
          "normalized": "a b(c d)-\u003ec(a b d)",
          "package": "compdata",
          "signature": "f a(m b)-\u003em(f a b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ditraversable.html#v:disequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines equality for signatures, which lifts to equality for\n terms.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param.Equality",
          "name": "Equality",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Equality.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines equality for signatures which lifts to equality for terms",
          "hierarchy": "Data Comp Param Equality",
          "module": "Data.Comp.Param.Equality",
          "name": "Equality",
          "package": "compdata",
          "partial": "Equality",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Equality.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature equality. An instance \u003ccode\u003eEqD f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eEq (Term f)\u003c/code\u003e. The equality test is performed inside the \u003ccode\u003e\u003ca\u003eFreshM\u003c/a\u003e\u003c/code\u003e monad for\n  generating fresh identifiers. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Equality",
          "name": "EqD",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Equality.html#EqD",
          "type": "class"
        },
        "index": {
          "description": "Signature equality An instance EqD gives rise to an instance Eq Term The equality test is performed inside the FreshM monad for generating fresh identifiers",
          "hierarchy": "Data Comp Param Equality",
          "module": "Data.Comp.Param.Equality",
          "name": "EqD",
          "package": "compdata",
          "partial": "Eq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Equality.html#t:EqD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquality on parametric values. The equality test is performed inside the\n \u003ccode\u003e\u003ca\u003eFreshM\u003c/a\u003e\u003c/code\u003e monad for generating fresh identifiers.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Equality",
          "name": "PEq",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Equality.html#PEq",
          "type": "class"
        },
        "index": {
          "description": "Equality on parametric values The equality test is performed inside the FreshM monad for generating fresh identifiers",
          "hierarchy": "Data Comp Param Equality",
          "module": "Data.Comp.Param.Equality",
          "name": "PEq",
          "package": "compdata",
          "partial": "PEq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Equality.html#t:PEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Equality",
          "name": "eqD",
          "package": "compdata",
          "signature": "f Name a -\u003e f Name a -\u003e FreshM Bool",
          "source": "src/Data-Comp-Param-Equality.html#eqD",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Equality",
          "module": "Data.Comp.Param.Equality",
          "name": "eqD",
          "normalized": "a Name b-\u003ea Name b-\u003eFreshM Bool",
          "package": "compdata",
          "signature": "f Name a-\u003ef Name a-\u003eFreshM Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Equality.html#v:eqD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Equality",
          "name": "peq",
          "package": "compdata",
          "signature": "a -\u003e a -\u003e FreshM Bool",
          "source": "src/Data-Comp-Param-Equality.html#peq",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Equality",
          "module": "Data.Comp.Param.Equality",
          "name": "peq",
          "normalized": "a-\u003ea-\u003eFreshM Bool",
          "package": "compdata",
          "signature": "a-\u003ea-\u003eFreshM Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Equality.html#v:peq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines a monad for generating fresh, abstract names, useful\n e.g. for defining equality on terms.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param.FreshM",
          "name": "FreshM",
          "package": "compdata",
          "source": "src/Data-Comp-Param-FreshM.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines monad for generating fresh abstract names useful e.g for defining equality on terms",
          "hierarchy": "Data Comp Param FreshM",
          "module": "Data.Comp.Param.FreshM",
          "name": "FreshM",
          "package": "compdata",
          "partial": "Fresh",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-FreshM.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonad for generating fresh (abstract) names.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.FreshM",
          "name": "FreshM",
          "package": "compdata",
          "source": "src/Data-Comp-Param-FreshM.html#FreshM",
          "type": "data"
        },
        "index": {
          "description": "Monad for generating fresh abstract names",
          "hierarchy": "Data Comp Param FreshM",
          "module": "Data.Comp.Param.FreshM",
          "name": "FreshM",
          "package": "compdata",
          "partial": "Fresh",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-FreshM.html#t:FreshM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract notion of a name (the constructor is hidden).\n\u003c/p\u003e",
          "module": "Data.Comp.Param.FreshM",
          "name": "Name",
          "package": "compdata",
          "source": "src/Data-Comp-Param-FreshM.html#Name",
          "type": "data"
        },
        "index": {
          "description": "Abstract notion of name the constructor is hidden",
          "hierarchy": "Data Comp Param FreshM",
          "module": "Data.Comp.Param.FreshM",
          "name": "Name",
          "package": "compdata",
          "partial": "Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-FreshM.html#t:Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate a computation that uses fresh names.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.FreshM",
          "name": "evalFreshM",
          "package": "compdata",
          "signature": "FreshM a -\u003e a",
          "source": "src/Data-Comp-Param-FreshM.html#evalFreshM",
          "type": "function"
        },
        "index": {
          "description": "Evaluate computation that uses fresh names",
          "hierarchy": "Data Comp Param FreshM",
          "module": "Data.Comp.Param.FreshM",
          "name": "evalFreshM",
          "normalized": "FreshM a-\u003ea",
          "package": "compdata",
          "partial": "Fresh",
          "signature": "FreshM a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-FreshM.html#v:evalFreshM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun the given computation with the next available name.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.FreshM",
          "name": "withName",
          "package": "compdata",
          "signature": "(Name -\u003e FreshM a) -\u003e FreshM a",
          "source": "src/Data-Comp-Param-FreshM.html#withName",
          "type": "function"
        },
        "index": {
          "description": "Run the given computation with the next available name",
          "hierarchy": "Data Comp Param FreshM",
          "module": "Data.Comp.Param.FreshM",
          "name": "withName",
          "normalized": "(Name-\u003eFreshM a)-\u003eFreshM a",
          "package": "compdata",
          "partial": "Name",
          "signature": "(Name-\u003eFreshM a)-\u003eFreshM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-FreshM.html#v:withName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides operators on difunctors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param.Ops",
          "name": "Ops",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ops.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides operators on difunctors",
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": "Ops",
          "package": "compdata",
          "partial": "Ops",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type adds a constant product to a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Ops",
          "name": ":&:",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ops.html#%3A%26%3A",
          "type": "data"
        },
        "index": {
          "description": "This data type adds constant product to signature",
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": ":&:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#t::-38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal product of signatures (difunctors).\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Ops",
          "name": ":*:",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ops.html#%3A%2A%3A",
          "type": "data"
        },
        "index": {
          "description": "Formal product of signatures difunctors",
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": ":*:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#t::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal sum of signatures (difunctors).\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Ops",
          "name": ":+:",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ops.html#%3A%2B%3A",
          "type": "data"
        },
        "index": {
          "description": "Formal sum of signatures difunctors",
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": ":+:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#t::-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature containment relation for automatic injections. The left-hand must\n be an atomic signature, where as the right-hand side must have a list-like\n structure. Examples include \u003ccode\u003ef :\u003c: f :+: g\u003c/code\u003e and \u003ccode\u003eg :\u003c: f :+: (g :+: h)\u003c/code\u003e,\n non-examples include \u003ccode\u003ef :+: g :\u003c: f :+: (g :+: h)\u003c/code\u003e and\n \u003ccode\u003ef :\u003c: (f :+: g) :+: h\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Ops",
          "name": ":\u003c:",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ops.html#%3A%3C%3A",
          "type": "class"
        },
        "index": {
          "description": "Signature containment relation for automatic injections The left-hand must be an atomic signature where as the right-hand side must have list-like structure Examples include and non-examples include and",
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": ":\u003c:",
          "package": "compdata",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#t::-60-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class defines how to distribute an annotation over a sum of\n  signatures. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Ops",
          "name": "DistAnn",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ops.html#DistAnn",
          "type": "class"
        },
        "index": {
          "description": "This class defines how to distribute an annotation over sum of signatures",
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": "DistAnn",
          "package": "compdata",
          "partial": "Dist Ann",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#t:DistAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Ops",
          "name": "RemA",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ops.html#RemA",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": "RemA",
          "package": "compdata",
          "partial": "Rem",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#t:RemA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Ops",
          "name": "Inl",
          "package": "compdata",
          "signature": "Inl (f a b)",
          "source": "src/Data-Comp-Param-Ops.html#%3A%2B%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": "Inl",
          "package": "compdata",
          "partial": "Inl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#v:Inl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Ops",
          "name": "Inr",
          "package": "compdata",
          "signature": "Inr (g a b)",
          "source": "src/Data-Comp-Param-Ops.html#%3A%2B%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": "Inr",
          "package": "compdata",
          "partial": "Inr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#v:Inr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUtility function to case on a difunctor sum, without exposing the internal\n  representation of sums. \n\u003c/p\u003e",
          "module": "[\"Data.Comp.Param.Ops\",\"Data.Comp.Param.Sum\"]",
          "name": "caseD",
          "package": "compdata",
          "signature": "(f a b -\u003e c) -\u003e (g a b -\u003e c) -\u003e (f :+: g) a b -\u003e c",
          "source": "src/Data-Comp-Param-Ops.html#caseD",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#v:caseD\",\"http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:caseD\"]"
        },
        "index": {
          "description": "Utility function to case on difunctor sum without exposing the internal representation of sums",
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": "caseD",
          "normalized": "(a b c-\u003ed)-\u003e(e b c-\u003ed)-\u003e(a e)b c-\u003ed",
          "package": "compdata",
          "signature": "(f a b-\u003ec)-\u003e(g a b-\u003ec)-\u003e(f g)a b-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#v:caseD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Ops",
          "name": "ffst",
          "package": "compdata",
          "signature": "(f :*: g) a b -\u003e f a b",
          "source": "src/Data-Comp-Param-Ops.html#ffst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": "ffst",
          "normalized": "(a*b)c d-\u003ea c d",
          "package": "compdata",
          "signature": "(f*g)a b-\u003ef a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#v:ffst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Ops",
          "name": "fsnd",
          "package": "compdata",
          "signature": "(f :*: g) a b -\u003e g a b",
          "source": "src/Data-Comp-Param-Ops.html#fsnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": "fsnd",
          "normalized": "(a*b)c d-\u003eb c d",
          "package": "compdata",
          "signature": "(f*g)a b-\u003eg a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#v:fsnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Ops",
          "name": "inj",
          "package": "compdata",
          "signature": "sub a b -\u003e sup a b",
          "source": "src/Data-Comp-Param-Ops.html#inj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": "inj",
          "normalized": "a b c-\u003ed b c",
          "package": "compdata",
          "signature": "sub a b-\u003esup a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#v:inj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject an annotation over a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Ops",
          "name": "injectA",
          "package": "compdata",
          "signature": "p -\u003e s a b -\u003e s' a b",
          "source": "src/Data-Comp-Param-Ops.html#injectA",
          "type": "method"
        },
        "index": {
          "description": "Inject an annotation over signature",
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": "injectA",
          "normalized": "a-\u003eb c d-\u003ee c d",
          "package": "compdata",
          "signature": "p-\u003es a b-\u003es' a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#v:injectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Ops",
          "name": "proj",
          "package": "compdata",
          "signature": "sup a b -\u003e Maybe (sub a b)",
          "source": "src/Data-Comp-Param-Ops.html#proj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": "proj",
          "normalized": "a b c-\u003eMaybe(d b c)",
          "package": "compdata",
          "signature": "sup a b-\u003eMaybe(sub a b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#v:proj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject an annotation from a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Ops",
          "name": "projectA",
          "package": "compdata",
          "signature": "s' a b -\u003e (s a b, p)",
          "source": "src/Data-Comp-Param-Ops.html#projectA",
          "type": "method"
        },
        "index": {
          "description": "Project an annotation from signature",
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": "projectA",
          "normalized": "a b c-\u003e(d b c,e)",
          "package": "compdata",
          "signature": "s' a b-\u003e(s a b,p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#v:projectA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove annotations from a signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Ops",
          "name": "remA",
          "package": "compdata",
          "signature": "s a b -\u003e s' a b",
          "source": "src/Data-Comp-Param-Ops.html#remA",
          "type": "method"
        },
        "index": {
          "description": "Remove annotations from signature",
          "hierarchy": "Data Comp Param Ops",
          "module": "Data.Comp.Param.Ops",
          "name": "remA",
          "normalized": "a b c-\u003ed b c",
          "package": "compdata",
          "signature": "s a b-\u003es' a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ops.html#v:remA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines ordering of signatures, which lifts to ordering of\n terms and contexts.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param.Ordering",
          "name": "Ordering",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ordering.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines ordering of signatures which lifts to ordering of terms and contexts",
          "hierarchy": "Data Comp Param Ordering",
          "module": "Data.Comp.Param.Ordering",
          "name": "Ordering",
          "package": "compdata",
          "partial": "Ordering",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ordering.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature ordering. An instance \u003ccode\u003eOrdD f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eOrd (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Ordering",
          "name": "OrdD",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ordering.html#OrdD",
          "type": "class"
        },
        "index": {
          "description": "Signature ordering An instance OrdD gives rise to an instance Ord Term",
          "hierarchy": "Data Comp Param Ordering",
          "module": "Data.Comp.Param.Ordering",
          "name": "OrdD",
          "package": "compdata",
          "partial": "Ord",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ordering.html#t:OrdD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdering of parametric values.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Ordering",
          "name": "POrd",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ordering.html#POrd",
          "type": "class"
        },
        "index": {
          "description": "Ordering of parametric values",
          "hierarchy": "Data Comp Param Ordering",
          "module": "Data.Comp.Param.Ordering",
          "name": "POrd",
          "package": "compdata",
          "partial": "POrd",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ordering.html#t:POrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Ordering",
          "name": "compList",
          "package": "compdata",
          "signature": "[Ordering] -\u003e Ordering",
          "source": "src/Data-Comp-Param-Ordering.html#compList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Ordering",
          "module": "Data.Comp.Param.Ordering",
          "name": "compList",
          "normalized": "[Ordering]-\u003eOrdering",
          "package": "compdata",
          "partial": "List",
          "signature": "[Ordering]-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ordering.html#v:compList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Ordering",
          "name": "compareD",
          "package": "compdata",
          "signature": "f Name a -\u003e f Name a -\u003e FreshM Ordering",
          "source": "src/Data-Comp-Param-Ordering.html#compareD",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Ordering",
          "module": "Data.Comp.Param.Ordering",
          "name": "compareD",
          "normalized": "a Name b-\u003ea Name b-\u003eFreshM Ordering",
          "package": "compdata",
          "signature": "f Name a-\u003ef Name a-\u003eFreshM Ordering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ordering.html#v:compareD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Ordering",
          "name": "pcompare",
          "package": "compdata",
          "signature": "a -\u003e a -\u003e FreshM Ordering",
          "source": "src/Data-Comp-Param-Ordering.html#pcompare",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Ordering",
          "module": "Data.Comp.Param.Ordering",
          "name": "pcompare",
          "normalized": "a-\u003ea-\u003eFreshM Ordering",
          "package": "compdata",
          "signature": "a-\u003ea-\u003eFreshM Ordering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Ordering.html#v:pcompare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines showing of signatures, which lifts to showing of terms.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param.Show",
          "name": "Show",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Show.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines showing of signatures which lifts to showing of terms",
          "hierarchy": "Data Comp Param Show",
          "module": "Data.Comp.Param.Show",
          "name": "Show",
          "package": "compdata",
          "partial": "Show",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Show.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature printing. An instance \u003ccode\u003eShowD f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eShow (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Show",
          "name": "ShowD",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Derive-Show.html#ShowD",
          "type": "class"
        },
        "index": {
          "description": "Signature printing An instance ShowD gives rise to an instance Show Term",
          "hierarchy": "Data Comp Param Show",
          "module": "Data.Comp.Param.Show",
          "name": "ShowD",
          "package": "compdata",
          "partial": "Show",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Show.html#t:ShowD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Show",
          "name": "showD",
          "package": "compdata",
          "signature": "f Name (FreshM String) -\u003e FreshM String",
          "source": "src/Data-Comp-Param-Derive-Show.html#showD",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Show",
          "module": "Data.Comp.Param.Show",
          "name": "showD",
          "normalized": "a Name(FreshM String)-\u003eFreshM String",
          "package": "compdata",
          "signature": "f Name(FreshM String)-\u003eFreshM String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Show.html#v:showD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides the infrastructure to extend signatures.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param.Sum",
          "name": "Sum",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Sum.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides the infrastructure to extend signatures",
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "Sum",
          "package": "compdata",
          "partial": "Sum",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal sum of signatures (difunctors).\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Sum",
          "name": ":+:",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ops.html#%3A%2B%3A",
          "type": "data"
        },
        "index": {
          "description": "Formal sum of signatures difunctors",
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": ":+:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#t::-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature containment relation for automatic injections. The left-hand must\n be an atomic signature, where as the right-hand side must have a list-like\n structure. Examples include \u003ccode\u003ef :\u003c: f :+: g\u003c/code\u003e and \u003ccode\u003eg :\u003c: f :+: (g :+: h)\u003c/code\u003e,\n non-examples include \u003ccode\u003ef :+: g :\u003c: f :+: (g :+: h)\u003c/code\u003e and\n \u003ccode\u003ef :\u003c: (f :+: g) :+: h\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Sum",
          "name": ":\u003c:",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Ops.html#%3A%3C%3A",
          "type": "class"
        },
        "index": {
          "description": "Signature containment relation for automatic injections The left-hand must be an atomic signature where as the right-hand side must have list-like structure Examples include and non-examples include and",
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": ":\u003c:",
          "package": "compdata",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#t::-60-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject a term over a sub signature to a term over larger signature. If the\n signature \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use \u003ccode\u003edeepInject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e\n instead.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject",
          "package": "compdata",
          "signature": "Term g -\u003e Term f",
          "source": "src/Data-Comp-Param-Sum.html#deepInject",
          "type": "function"
        },
        "index": {
          "description": "Inject term over sub signature to term over larger signature If the signature is compound of atomic signatures use deepInject instead",
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject",
          "normalized": "Term a-\u003eTerm b",
          "package": "compdata",
          "partial": "Inject",
          "signature": "Term g-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepInject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject10",
          "package": "compdata",
          "signature": "CxtFun (:+: f10 (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))))) g",
          "source": "src/Data-Comp-Param-Sum.html#deepInject10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject10",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepInject10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject2",
          "package": "compdata",
          "signature": "CxtFun (:+: f2 f1) g",
          "source": "src/Data-Comp-Param-Sum.html#deepInject2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject2",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepInject2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject3",
          "package": "compdata",
          "signature": "CxtFun (:+: f3 (:+: f2 f1)) g",
          "source": "src/Data-Comp-Param-Sum.html#deepInject3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject3",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepInject3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject4",
          "package": "compdata",
          "signature": "CxtFun (:+: f4 (:+: f3 (:+: f2 f1))) g",
          "source": "src/Data-Comp-Param-Sum.html#deepInject4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject4",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepInject4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject5",
          "package": "compdata",
          "signature": "CxtFun (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))) g",
          "source": "src/Data-Comp-Param-Sum.html#deepInject5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject5",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepInject5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject6",
          "package": "compdata",
          "signature": "CxtFun (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))) g",
          "source": "src/Data-Comp-Param-Sum.html#deepInject6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject6",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepInject6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject7",
          "package": "compdata",
          "signature": "CxtFun (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))) g",
          "source": "src/Data-Comp-Param-Sum.html#deepInject7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject7",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepInject7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject8",
          "package": "compdata",
          "signature": "CxtFun (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))) g",
          "source": "src/Data-Comp-Param-Sum.html#deepInject8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject8",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepInject8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject9",
          "package": "compdata",
          "signature": "CxtFun (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))))) g",
          "source": "src/Data-Comp-Param-Sum.html#deepInject9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepInject9",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepInject9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTries to coerce a term\u003cem\u003econtext to a term\u003c/em\u003econtext over a sub-signature. If\n the signature \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use\n \u003ccode\u003edeepProject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject",
          "package": "compdata",
          "signature": "Term f -\u003e Maybe (Term g)",
          "source": "src/Data-Comp-Param-Sum.html#deepProject",
          "type": "function"
        },
        "index": {
          "description": "Tries to coerce term context to term context over sub-signature If the signature is compound of atomic signatures use deepProject instead",
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject",
          "normalized": "Term a-\u003eMaybe(Term b)",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f-\u003eMaybe(Term g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepProject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject10",
          "package": "compdata",
          "signature": "Term f -\u003e Maybe (Term (:+: g10 (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))))))",
          "source": "src/Data-Comp-Param-Sum.html#deepProject10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject10",
          "normalized": "Term a-\u003eMaybe(Term(b(b(b(b(b(b(b(b(b b))))))))))",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f-\u003eMaybe(Term(g(g(g(g(g(g(g(g(g g))))))))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepProject10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject2",
          "package": "compdata",
          "signature": "Term f -\u003e Maybe (Term (:+: g2 g1))",
          "source": "src/Data-Comp-Param-Sum.html#deepProject2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject2",
          "normalized": "Term a-\u003eMaybe(Term(b b))",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f-\u003eMaybe(Term(g g))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepProject2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject3",
          "package": "compdata",
          "signature": "Term f -\u003e Maybe (Term (:+: g3 (:+: g2 g1)))",
          "source": "src/Data-Comp-Param-Sum.html#deepProject3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject3",
          "normalized": "Term a-\u003eMaybe(Term(b(b b)))",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f-\u003eMaybe(Term(g(g g)))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepProject3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject4",
          "package": "compdata",
          "signature": "Term f -\u003e Maybe (Term (:+: g4 (:+: g3 (:+: g2 g1))))",
          "source": "src/Data-Comp-Param-Sum.html#deepProject4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject4",
          "normalized": "Term a-\u003eMaybe(Term(b(b(b b))))",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f-\u003eMaybe(Term(g(g(g g))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepProject4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject5",
          "package": "compdata",
          "signature": "Term f -\u003e Maybe (Term (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))",
          "source": "src/Data-Comp-Param-Sum.html#deepProject5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject5",
          "normalized": "Term a-\u003eMaybe(Term(b(b(b(b b)))))",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f-\u003eMaybe(Term(g(g(g(g g)))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepProject5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject6",
          "package": "compdata",
          "signature": "Term f -\u003e Maybe (Term (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))",
          "source": "src/Data-Comp-Param-Sum.html#deepProject6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject6",
          "normalized": "Term a-\u003eMaybe(Term(b(b(b(b(b b))))))",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f-\u003eMaybe(Term(g(g(g(g(g g))))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepProject6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject7",
          "package": "compdata",
          "signature": "Term f -\u003e Maybe (Term (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))",
          "source": "src/Data-Comp-Param-Sum.html#deepProject7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject7",
          "normalized": "Term a-\u003eMaybe(Term(b(b(b(b(b(b b)))))))",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f-\u003eMaybe(Term(g(g(g(g(g(g g)))))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepProject7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject8",
          "package": "compdata",
          "signature": "Term f -\u003e Maybe (Term (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))))",
          "source": "src/Data-Comp-Param-Sum.html#deepProject8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject8",
          "normalized": "Term a-\u003eMaybe(Term(b(b(b(b(b(b(b b))))))))",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f-\u003eMaybe(Term(g(g(g(g(g(g(g g))))))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepProject8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject9",
          "package": "compdata",
          "signature": "Term f -\u003e Maybe (Term (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))))",
          "source": "src/Data-Comp-Param-Sum.html#deepProject9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "deepProject9",
          "normalized": "Term a-\u003eMaybe(Term(b(b(b(b(b(b(b(b b)))))))))",
          "package": "compdata",
          "partial": "Project",
          "signature": "Term f-\u003eMaybe(Term(g(g(g(g(g(g(g(g g)))))))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:deepProject9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inj",
          "package": "compdata",
          "signature": "sub a b -\u003e sup a b",
          "source": "src/Data-Comp-Param-Ops.html#inj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inj",
          "normalized": "a b c-\u003ed b c",
          "package": "compdata",
          "signature": "sub a b-\u003esup a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inj10",
          "package": "compdata",
          "signature": ":+: f10 (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))))) a b -\u003e g a b",
          "source": "src/Data-Comp-Param-Sum.html#inj10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inj10",
          "normalized": "a(a(a(a(a(a(a(a(a a))))))))b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f(f f))))))))a b-\u003eg a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inj10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inj2",
          "package": "compdata",
          "signature": ":+: f2 f1 a b -\u003e g a b",
          "source": "src/Data-Comp-Param-Sum.html#inj2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inj2",
          "normalized": "a a b c-\u003ed b c",
          "package": "compdata",
          "signature": "f f a b-\u003eg a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inj2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inj3",
          "package": "compdata",
          "signature": ":+: f3 (:+: f2 f1) a b -\u003e g a b",
          "source": "src/Data-Comp-Param-Sum.html#inj3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inj3",
          "normalized": "a(a a)b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f f)a b-\u003eg a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inj3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inj4",
          "package": "compdata",
          "signature": ":+: f4 (:+: f3 (:+: f2 f1)) a b -\u003e g a b",
          "source": "src/Data-Comp-Param-Sum.html#inj4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inj4",
          "normalized": "a(a(a a))b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f(f f))a b-\u003eg a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inj5",
          "package": "compdata",
          "signature": ":+: f5 (:+: f4 (:+: f3 (:+: f2 f1))) a b -\u003e g a b",
          "source": "src/Data-Comp-Param-Sum.html#inj5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inj5",
          "normalized": "a(a(a(a a)))b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f(f(f f)))a b-\u003eg a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inj5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inj6",
          "package": "compdata",
          "signature": ":+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))) a b -\u003e g a b",
          "source": "src/Data-Comp-Param-Sum.html#inj6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inj6",
          "normalized": "a(a(a(a(a a))))b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f(f(f(f f))))a b-\u003eg a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inj6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inj7",
          "package": "compdata",
          "signature": ":+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))) a b -\u003e g a b",
          "source": "src/Data-Comp-Param-Sum.html#inj7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inj7",
          "normalized": "a(a(a(a(a(a a)))))b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f(f(f(f(f f)))))a b-\u003eg a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inj7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inj8",
          "package": "compdata",
          "signature": ":+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))) a b -\u003e g a b",
          "source": "src/Data-Comp-Param-Sum.html#inj8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inj8",
          "normalized": "a(a(a(a(a(a(a a))))))b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f f))))))a b-\u003eg a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inj8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inj9",
          "package": "compdata",
          "signature": ":+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))) a b -\u003e g a b",
          "source": "src/Data-Comp-Param-Sum.html#inj9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inj9",
          "normalized": "a(a(a(a(a(a(a(a a)))))))b c-\u003ed b c",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f f)))))))a b-\u003eg a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inj9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject a term where the outermost layer is a sub signature. If the signature\n \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use \u003ccode\u003einject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Sum",
          "name": "inject",
          "package": "compdata",
          "signature": "g a (Cxt h f a b) -\u003e Cxt h f a b",
          "source": "src/Data-Comp-Param-Sum.html#inject",
          "type": "function"
        },
        "index": {
          "description": "Inject term where the outermost layer is sub signature If the signature is compound of atomic signatures use inject instead",
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inject",
          "normalized": "a b(Cxt c d b e)-\u003eCxt c d b e",
          "package": "compdata",
          "signature": "g a(Cxt h f a b)-\u003eCxt h f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject a term where the outermost layer is a sub signature. If the signature\n \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use \u003ccode\u003einject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Sum",
          "name": "inject'",
          "package": "compdata",
          "signature": "g (Cxt h f a b) (Cxt h f a b) -\u003e Cxt h f a b",
          "source": "src/Data-Comp-Param-Sum.html#inject%27",
          "type": "function"
        },
        "index": {
          "description": "Inject term where the outermost layer is sub signature If the signature is compound of atomic signatures use inject instead",
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inject'",
          "normalized": "a(Cxt b c d e)(Cxt b c d e)-\u003eCxt b c d e",
          "package": "compdata",
          "signature": "g(Cxt h f a b)(Cxt h f a b)-\u003eCxt h f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inject-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inject10",
          "package": "compdata",
          "signature": ":+: f10 (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))))) a (Cxt h g a b) -\u003e Cxt h g a b",
          "source": "src/Data-Comp-Param-Sum.html#inject10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inject10",
          "normalized": "a(a(a(a(a(a(a(a(a a))))))))b(Cxt c d b e)-\u003eCxt c d b e",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f(f f))))))))a(Cxt h g a b)-\u003eCxt h g a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inject10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inject2",
          "package": "compdata",
          "signature": ":+: f2 f1 a (Cxt h g a b) -\u003e Cxt h g a b",
          "source": "src/Data-Comp-Param-Sum.html#inject2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inject2",
          "normalized": "a a b(Cxt c d b e)-\u003eCxt c d b e",
          "package": "compdata",
          "signature": "f f a(Cxt h g a b)-\u003eCxt h g a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inject2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inject3",
          "package": "compdata",
          "signature": ":+: f3 (:+: f2 f1) a (Cxt h g a b) -\u003e Cxt h g a b",
          "source": "src/Data-Comp-Param-Sum.html#inject3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inject3",
          "normalized": "a(a a)b(Cxt c d b e)-\u003eCxt c d b e",
          "package": "compdata",
          "signature": "f(f f)a(Cxt h g a b)-\u003eCxt h g a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inject3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inject4",
          "package": "compdata",
          "signature": ":+: f4 (:+: f3 (:+: f2 f1)) a (Cxt h g a b) -\u003e Cxt h g a b",
          "source": "src/Data-Comp-Param-Sum.html#inject4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inject4",
          "normalized": "a(a(a a))b(Cxt c d b e)-\u003eCxt c d b e",
          "package": "compdata",
          "signature": "f(f(f f))a(Cxt h g a b)-\u003eCxt h g a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inject4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inject5",
          "package": "compdata",
          "signature": ":+: f5 (:+: f4 (:+: f3 (:+: f2 f1))) a (Cxt h g a b) -\u003e Cxt h g a b",
          "source": "src/Data-Comp-Param-Sum.html#inject5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inject5",
          "normalized": "a(a(a(a a)))b(Cxt c d b e)-\u003eCxt c d b e",
          "package": "compdata",
          "signature": "f(f(f(f f)))a(Cxt h g a b)-\u003eCxt h g a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inject5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inject6",
          "package": "compdata",
          "signature": ":+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))) a (Cxt h g a b) -\u003e Cxt h g a b",
          "source": "src/Data-Comp-Param-Sum.html#inject6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inject6",
          "normalized": "a(a(a(a(a a))))b(Cxt c d b e)-\u003eCxt c d b e",
          "package": "compdata",
          "signature": "f(f(f(f(f f))))a(Cxt h g a b)-\u003eCxt h g a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inject6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inject7",
          "package": "compdata",
          "signature": ":+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))) a (Cxt h g a b) -\u003e Cxt h g a b",
          "source": "src/Data-Comp-Param-Sum.html#inject7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inject7",
          "normalized": "a(a(a(a(a(a a)))))b(Cxt c d b e)-\u003eCxt c d b e",
          "package": "compdata",
          "signature": "f(f(f(f(f(f f)))))a(Cxt h g a b)-\u003eCxt h g a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inject7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inject8",
          "package": "compdata",
          "signature": ":+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))) a (Cxt h g a b) -\u003e Cxt h g a b",
          "source": "src/Data-Comp-Param-Sum.html#inject8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inject8",
          "normalized": "a(a(a(a(a(a(a a))))))b(Cxt c d b e)-\u003eCxt c d b e",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f f))))))a(Cxt h g a b)-\u003eCxt h g a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inject8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "inject9",
          "package": "compdata",
          "signature": ":+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))) a (Cxt h g a b) -\u003e Cxt h g a b",
          "source": "src/Data-Comp-Param-Sum.html#inject9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "inject9",
          "normalized": "a(a(a(a(a(a(a(a a)))))))b(Cxt c d b e)-\u003eCxt c d b e",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f f)))))))a(Cxt h g a b)-\u003eCxt h g a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:inject9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function injects a whole context into another context. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Sum",
          "name": "injectCxt",
          "package": "compdata",
          "signature": "Cxt h g a (Cxt h f a b) -\u003e Cxt h f a b",
          "source": "src/Data-Comp-Param-Sum.html#injectCxt",
          "type": "function"
        },
        "index": {
          "description": "This function injects whole context into another context",
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "injectCxt",
          "normalized": "Cxt a b c(Cxt a d c e)-\u003eCxt a d c e",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "Cxt h g a(Cxt h f a b)-\u003eCxt h f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:injectCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function lifts the given functor to a context. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Sum",
          "name": "liftCxt",
          "package": "compdata",
          "signature": "g a b -\u003e Cxt Hole f a b",
          "source": "src/Data-Comp-Param-Sum.html#liftCxt",
          "type": "function"
        },
        "index": {
          "description": "This function lifts the given functor to context",
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "liftCxt",
          "normalized": "a b c-\u003eCxt Hole d b c",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "g a b-\u003eCxt Hole f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:liftCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "proj",
          "package": "compdata",
          "signature": "sup a b -\u003e Maybe (sub a b)",
          "source": "src/Data-Comp-Param-Ops.html#proj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "proj",
          "normalized": "a b c-\u003eMaybe(d b c)",
          "package": "compdata",
          "signature": "sup a b-\u003eMaybe(sub a b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:proj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "proj10",
          "package": "compdata",
          "signature": "f a b -\u003e Maybe (:+: g10 (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))) a b)",
          "source": "src/Data-Comp-Param-Sum.html#proj10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "proj10",
          "normalized": "a b c-\u003eMaybe(d(d(d(d(d(d(d(d(d d))))))))b c)",
          "package": "compdata",
          "signature": "f a b-\u003eMaybe(g(g(g(g(g(g(g(g(g g))))))))a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:proj10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "proj2",
          "package": "compdata",
          "signature": "f a b -\u003e Maybe (:+: g2 g1 a b)",
          "source": "src/Data-Comp-Param-Sum.html#proj2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "proj2",
          "normalized": "a b c-\u003eMaybe(d d b c)",
          "package": "compdata",
          "signature": "f a b-\u003eMaybe(g g a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:proj2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "proj3",
          "package": "compdata",
          "signature": "f a b -\u003e Maybe (:+: g3 (:+: g2 g1) a b)",
          "source": "src/Data-Comp-Param-Sum.html#proj3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "proj3",
          "normalized": "a b c-\u003eMaybe(d(d d)b c)",
          "package": "compdata",
          "signature": "f a b-\u003eMaybe(g(g g)a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:proj3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "proj4",
          "package": "compdata",
          "signature": "f a b -\u003e Maybe (:+: g4 (:+: g3 (:+: g2 g1)) a b)",
          "source": "src/Data-Comp-Param-Sum.html#proj4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "proj4",
          "normalized": "a b c-\u003eMaybe(d(d(d d))b c)",
          "package": "compdata",
          "signature": "f a b-\u003eMaybe(g(g(g g))a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:proj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "proj5",
          "package": "compdata",
          "signature": "f a b -\u003e Maybe (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))) a b)",
          "source": "src/Data-Comp-Param-Sum.html#proj5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "proj5",
          "normalized": "a b c-\u003eMaybe(d(d(d(d d)))b c)",
          "package": "compdata",
          "signature": "f a b-\u003eMaybe(g(g(g(g g)))a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:proj5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "proj6",
          "package": "compdata",
          "signature": "f a b -\u003e Maybe (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))) a b)",
          "source": "src/Data-Comp-Param-Sum.html#proj6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "proj6",
          "normalized": "a b c-\u003eMaybe(d(d(d(d(d d))))b c)",
          "package": "compdata",
          "signature": "f a b-\u003eMaybe(g(g(g(g(g g))))a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:proj6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "proj7",
          "package": "compdata",
          "signature": "f a b -\u003e Maybe (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))) a b)",
          "source": "src/Data-Comp-Param-Sum.html#proj7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "proj7",
          "normalized": "a b c-\u003eMaybe(d(d(d(d(d(d d)))))b c)",
          "package": "compdata",
          "signature": "f a b-\u003eMaybe(g(g(g(g(g(g g)))))a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:proj7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "proj8",
          "package": "compdata",
          "signature": "f a b -\u003e Maybe (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))) a b)",
          "source": "src/Data-Comp-Param-Sum.html#proj8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "proj8",
          "normalized": "a b c-\u003eMaybe(d(d(d(d(d(d(d d))))))b c)",
          "package": "compdata",
          "signature": "f a b-\u003eMaybe(g(g(g(g(g(g(g g))))))a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:proj8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "proj9",
          "package": "compdata",
          "signature": "f a b -\u003e Maybe (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))) a b)",
          "source": "src/Data-Comp-Param-Sum.html#proj9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "proj9",
          "normalized": "a b c-\u003eMaybe(d(d(d(d(d(d(d(d d)))))))b c)",
          "package": "compdata",
          "signature": "f a b-\u003eMaybe(g(g(g(g(g(g(g(g g)))))))a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:proj9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject the outermost layer of a term to a sub signature. If the signature\n \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use \u003ccode\u003eproject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Sum",
          "name": "project",
          "package": "compdata",
          "signature": "Cxt h f a b -\u003e Maybe (g a (Cxt h f a b))",
          "source": "src/Data-Comp-Param-Sum.html#project",
          "type": "function"
        },
        "index": {
          "description": "Project the outermost layer of term to sub signature If the signature is compound of atomic signatures use project instead",
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "project",
          "normalized": "Cxt a b c d-\u003eMaybe(e c(Cxt a b c d))",
          "package": "compdata",
          "signature": "Cxt h f a b-\u003eMaybe(g a(Cxt h f a b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:project"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "project10",
          "package": "compdata",
          "signature": "Cxt h f a b -\u003e Maybe (:+: g10 (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))) a (Cxt h f a b))",
          "source": "src/Data-Comp-Param-Sum.html#project10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "project10",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e(e(e(e(e(e(e(e e))))))))c(Cxt a b c d))",
          "package": "compdata",
          "signature": "Cxt h f a b-\u003eMaybe(g(g(g(g(g(g(g(g(g g))))))))a(Cxt h f a b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:project10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "project2",
          "package": "compdata",
          "signature": "Cxt h f a b -\u003e Maybe (:+: g2 g1 a (Cxt h f a b))",
          "source": "src/Data-Comp-Param-Sum.html#project2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "project2",
          "normalized": "Cxt a b c d-\u003eMaybe(e e c(Cxt a b c d))",
          "package": "compdata",
          "signature": "Cxt h f a b-\u003eMaybe(g g a(Cxt h f a b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:project2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "project3",
          "package": "compdata",
          "signature": "Cxt h f a b -\u003e Maybe (:+: g3 (:+: g2 g1) a (Cxt h f a b))",
          "source": "src/Data-Comp-Param-Sum.html#project3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "project3",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e e)c(Cxt a b c d))",
          "package": "compdata",
          "signature": "Cxt h f a b-\u003eMaybe(g(g g)a(Cxt h f a b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:project3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "project4",
          "package": "compdata",
          "signature": "Cxt h f a b -\u003e Maybe (:+: g4 (:+: g3 (:+: g2 g1)) a (Cxt h f a b))",
          "source": "src/Data-Comp-Param-Sum.html#project4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "project4",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e(e e))c(Cxt a b c d))",
          "package": "compdata",
          "signature": "Cxt h f a b-\u003eMaybe(g(g(g g))a(Cxt h f a b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:project4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "project5",
          "package": "compdata",
          "signature": "Cxt h f a b -\u003e Maybe (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))) a (Cxt h f a b))",
          "source": "src/Data-Comp-Param-Sum.html#project5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "project5",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e(e(e e)))c(Cxt a b c d))",
          "package": "compdata",
          "signature": "Cxt h f a b-\u003eMaybe(g(g(g(g g)))a(Cxt h f a b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:project5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "project6",
          "package": "compdata",
          "signature": "Cxt h f a b -\u003e Maybe (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))) a (Cxt h f a b))",
          "source": "src/Data-Comp-Param-Sum.html#project6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "project6",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e(e(e(e e))))c(Cxt a b c d))",
          "package": "compdata",
          "signature": "Cxt h f a b-\u003eMaybe(g(g(g(g(g g))))a(Cxt h f a b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:project6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "project7",
          "package": "compdata",
          "signature": "Cxt h f a b -\u003e Maybe (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))) a (Cxt h f a b))",
          "source": "src/Data-Comp-Param-Sum.html#project7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "project7",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e(e(e(e(e e)))))c(Cxt a b c d))",
          "package": "compdata",
          "signature": "Cxt h f a b-\u003eMaybe(g(g(g(g(g(g g)))))a(Cxt h f a b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:project7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "project8",
          "package": "compdata",
          "signature": "Cxt h f a b -\u003e Maybe (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))) a (Cxt h f a b))",
          "source": "src/Data-Comp-Param-Sum.html#project8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "project8",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e(e(e(e(e(e e))))))c(Cxt a b c d))",
          "package": "compdata",
          "signature": "Cxt h f a b-\u003eMaybe(g(g(g(g(g(g(g g))))))a(Cxt h f a b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:project8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Sum",
          "name": "project9",
          "package": "compdata",
          "signature": "Cxt h f a b -\u003e Maybe (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))) a (Cxt h f a b))",
          "source": "src/Data-Comp-Param-Sum.html#project9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Sum",
          "module": "Data.Comp.Param.Sum",
          "name": "project9",
          "normalized": "Cxt a b c d-\u003eMaybe(e(e(e(e(e(e(e(e e)))))))c(Cxt a b c d))",
          "package": "compdata",
          "signature": "Cxt h f a b-\u003eMaybe(g(g(g(g(g(g(g(g g)))))))a(Cxt h f a b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Sum.html#v:project9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the central notion of \u003cem\u003eparametrised terms\u003c/em\u003e and their\n generalisation to parametrised contexts.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param.Term",
          "name": "Term",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Term.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the central notion of parametrised terms and their generalisation to parametrised contexts",
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "Term",
          "package": "compdata",
          "partial": "Term",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA context may contain holes. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Term",
          "name": "Context",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Term.html#Context",
          "type": "type"
        },
        "index": {
          "description": "context may contain holes",
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "Context",
          "package": "compdata",
          "partial": "Context",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#t:Context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type represents contexts over a signature. Contexts are terms\n  containing zero or more holes, and zero or more parameters. The first\n  parameter is a phantom type indicating whether the context has holes. The\n  second paramater is the signature of the context, in the form of a\n  \u003ca\u003eData.Comp.Param.Difunctor\u003c/a\u003e. The third parameter is the type of parameters,\n  and the fourth parameter is the type of holes. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Term",
          "name": "Cxt",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Term.html#Cxt",
          "type": "data"
        },
        "index": {
          "description": "This data type represents contexts over signature Contexts are terms containing zero or more holes and zero or more parameters The first parameter is phantom type indicating whether the context has holes The second paramater is the signature of the context in the form of Data.Comp.Param.Difunctor The third parameter is the type of parameters and the fourth parameter is the type of holes",
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "Cxt",
          "package": "compdata",
          "partial": "Cxt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#t:Cxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhantom type used to define \u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Term",
          "name": "Hole",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Term.html#Hole",
          "type": "data"
        },
        "index": {
          "description": "Phantom type used to define Context",
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "Hole",
          "package": "compdata",
          "partial": "Hole",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#t:Hole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhantom type used to define \u003ccode\u003e\u003ca\u003eTerm\u003c/a\u003e\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Term",
          "name": "NoHole",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Term.html#NoHole",
          "type": "data"
        },
        "index": {
          "description": "Phantom type used to define Term",
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "NoHole",
          "package": "compdata",
          "partial": "No Hole",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#t:NoHole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonads for which embedded \u003ccode\u003eTrm\u003c/code\u003e values, which are parametric at top level,\n  can be made into monadic \u003ccode\u003eTerm\u003c/code\u003e values, i.e. \"pushing the parametricity\n  inwards\". \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Term",
          "name": "ParamFunctor",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Term.html#ParamFunctor",
          "type": "class"
        },
        "index": {
          "description": "Monads for which embedded Trm values which are parametric at top level can be made into monadic Term values i.e pushing the parametricity inwards",
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "ParamFunctor",
          "package": "compdata",
          "partial": "Param Functor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#t:ParamFunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA term is a context with no holes, where all occurrences of the\n  contravariant parameter is fully parametric. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Term",
          "name": "Term",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Term.html#Term",
          "type": "newtype"
        },
        "index": {
          "description": "term is context with no holes where all occurrences of the contravariant parameter is fully parametric",
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "Term",
          "package": "compdata",
          "partial": "Term",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Preterms\" \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Term",
          "name": "Trm",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Term.html#Trm",
          "type": "type"
        },
        "index": {
          "description": "Preterms",
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "Trm",
          "package": "compdata",
          "partial": "Trm",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#t:Trm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Term",
          "name": "Hole",
          "package": "compdata",
          "signature": "b -\u003e Cxt Hole f a b",
          "source": "src/Data-Comp-Param-Term.html#Cxt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "Hole",
          "normalized": "a-\u003eCxt Hole b c a",
          "package": "compdata",
          "partial": "Hole",
          "signature": "b-\u003eCxt Hole f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#v:Hole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Term",
          "name": "In",
          "package": "compdata",
          "signature": "f a (Cxt h f a b) -\u003e Cxt h f a b",
          "source": "src/Data-Comp-Param-Term.html#Cxt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "In",
          "normalized": "a b(Cxt c a b d)-\u003eCxt c a b d",
          "package": "compdata",
          "partial": "In",
          "signature": "f a(Cxt h f a b)-\u003eCxt h f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#v:In"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Term",
          "name": "Term",
          "package": "compdata",
          "signature": "Term",
          "source": "src/Data-Comp-Param-Term.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "Term",
          "package": "compdata",
          "partial": "Term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#v:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Term",
          "name": "Var",
          "package": "compdata",
          "signature": "a -\u003e Cxt h f a b",
          "source": "src/Data-Comp-Param-Term.html#Cxt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "Var",
          "normalized": "a-\u003eCxt b c a d",
          "package": "compdata",
          "partial": "Var",
          "signature": "a-\u003eCxt h f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#v:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator maps a function over a context by applying the\n function to each hole.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Term",
          "name": "cxtMap",
          "package": "compdata",
          "signature": "(b -\u003e c) -\u003e Context f a b -\u003e Context f a c",
          "source": "src/Data-Comp-Param-Term.html#cxtMap",
          "type": "function"
        },
        "index": {
          "description": "This combinator maps function over context by applying the function to each hole",
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "cxtMap",
          "normalized": "(a-\u003eb)-\u003eContext c d a-\u003eContext c d b",
          "package": "compdata",
          "partial": "Map",
          "signature": "(b-\u003ec)-\u003eContext f a b-\u003eContext f a c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#v:cxtMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a difunctorial value into a context. \n\u003c/p\u003e",
          "module": "Data.Comp.Param.Term",
          "name": "simpCxt",
          "package": "compdata",
          "signature": "f a b -\u003e Cxt Hole f a b",
          "source": "src/Data-Comp-Param-Term.html#simpCxt",
          "type": "function"
        },
        "index": {
          "description": "Convert difunctorial value into context",
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "simpCxt",
          "normalized": "a b c-\u003eCxt Hole a b c",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "f a b-\u003eCxt Hole f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#v:simpCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Term",
          "name": "termM",
          "package": "compdata",
          "signature": "(forall a.  m (Trm f a)) -\u003e m (Term f)",
          "source": "src/Data-Comp-Param-Term.html#termM",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "termM",
          "normalized": "(a b c(Trm d e))-\u003ec(Term d)",
          "package": "compdata",
          "signature": "(forall a. m(Trm f a))-\u003em(Term f)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#v:termM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Term",
          "name": "toCxt",
          "package": "compdata",
          "signature": "Trm f a -\u003e Cxt h f a b",
          "source": "src/Data-Comp-Param-Term.html#toCxt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "toCxt",
          "normalized": "Trm a b-\u003eCxt c a b d",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "Trm f a-\u003eCxt h f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#v:toCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Term",
          "name": "unTerm",
          "package": "compdata",
          "signature": "forall a.  Trm f a",
          "source": "src/Data-Comp-Param-Term.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Term",
          "module": "Data.Comp.Param.Term",
          "name": "unTerm",
          "package": "compdata",
          "partial": "Term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Term.html#v:unTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis modules defines terms & contexts with thunks, with deferred\n monadic computations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param.Thunk",
          "name": "Thunk",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Thunk.html",
          "type": "module"
        },
        "index": {
          "description": "This modules defines terms contexts with thunks with deferred monadic computations",
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "Thunk",
          "package": "compdata",
          "partial": "Thunk",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents algebras which have terms with thunks as\n carrier.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Thunk",
          "name": "AlgT",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Thunk.html#AlgT",
          "type": "type"
        },
        "index": {
          "description": "This type represents algebras which have terms with thunks as carrier",
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "AlgT",
          "package": "compdata",
          "partial": "Alg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#t:AlgT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents contexts with thunks.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Thunk",
          "name": "CxtT",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Thunk.html#CxtT",
          "type": "type"
        },
        "index": {
          "description": "This type represents contexts with thunks",
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "CxtT",
          "package": "compdata",
          "partial": "Cxt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#t:CxtT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents terms with thunks.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Thunk",
          "name": "TermT",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Thunk.html#TermT",
          "type": "type"
        },
        "index": {
          "description": "This type represents terms with thunks",
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "TermT",
          "package": "compdata",
          "partial": "Term",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#t:TermT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Thunk",
          "name": "Thunk",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Thunk.html#Thunk",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "Thunk",
          "package": "compdata",
          "partial": "Thunk",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#t:Thunk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents terms with thunks.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Thunk",
          "name": "TrmT",
          "package": "compdata",
          "source": "src/Data-Comp-Param-Thunk.html#TrmT",
          "type": "type"
        },
        "index": {
          "description": "This type represents terms with thunks",
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "TrmT",
          "package": "compdata",
          "partial": "Trm",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#t:TrmT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Thunk",
          "name": "evalStrict",
          "package": "compdata",
          "signature": "(g (TrmT m f a) (f a (TrmT m f a)) -\u003e TrmT m f a) -\u003e g (TrmT m f a) (TrmT m f a) -\u003e TrmT m f a",
          "source": "src/Data-Comp-Param-Thunk.html#evalStrict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "evalStrict",
          "normalized": "(a(TrmT b c d)(c d(TrmT b c d))-\u003eTrmT b c d)-\u003ea(TrmT b c d)(TrmT b c d)-\u003eTrmT b c d",
          "package": "compdata",
          "partial": "Strict",
          "signature": "(g(TrmT m f a)(f a(TrmT m f a))-\u003eTrmT m f a)-\u003eg(TrmT m f a)(TrmT m f a)-\u003eTrmT m f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#v:evalStrict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function evaluates all thunks.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Thunk",
          "name": "nf",
          "package": "compdata",
          "signature": "TrmT m f a -\u003e m (Trm f a)",
          "source": "src/Data-Comp-Param-Thunk.html#nf",
          "type": "function"
        },
        "index": {
          "description": "This function evaluates all thunks",
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "nf",
          "normalized": "TrmT a b c-\u003ea(Trm b c)",
          "package": "compdata",
          "signature": "TrmT m f a-\u003em(Trm f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#v:nf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function evaluates all thunks while simultaneously\n projecting the term to a smaller signature. Failure to do the\n projection is signalled as a failure in the monad as in \u003ccode\u003e\u003ca\u003ewhnfPr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Thunk",
          "name": "nfPr",
          "package": "compdata",
          "signature": "TrmT m f a -\u003e m (Trm g a)",
          "source": "src/Data-Comp-Param-Thunk.html#nfPr",
          "type": "function"
        },
        "index": {
          "description": "This function evaluates all thunks while simultaneously projecting the term to smaller signature Failure to do the projection is signalled as failure in the monad as in whnfPr",
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "nfPr",
          "normalized": "TrmT a b c-\u003ea(Trm d c)",
          "package": "compdata",
          "partial": "Pr",
          "signature": "TrmT m f a-\u003em(Trm g a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#v:nfPr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function evaluates all thunks.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Thunk",
          "name": "nfT",
          "package": "compdata",
          "signature": "TermT m f -\u003e m (Term f)",
          "source": "src/Data-Comp-Param-Thunk.html#nfT",
          "type": "function"
        },
        "index": {
          "description": "This function evaluates all thunks",
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "nfT",
          "normalized": "TermT a b-\u003ea(Term b)",
          "package": "compdata",
          "signature": "TermT m f-\u003em(Term f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#v:nfT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function evaluates all thunks while simultaneously\n projecting the term to a smaller signature. Failure to do the\n projection is signalled as a failure in the monad as in \u003ccode\u003e\u003ca\u003ewhnfPr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Thunk",
          "name": "nfTPr",
          "package": "compdata",
          "signature": "TermT m f -\u003e m (Term g)",
          "source": "src/Data-Comp-Param-Thunk.html#nfTPr",
          "type": "function"
        },
        "index": {
          "description": "This function evaluates all thunks while simultaneously projecting the term to smaller signature Failure to do the projection is signalled as failure in the monad as in whnfPr",
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "nfTPr",
          "normalized": "TermT a b-\u003ea(Term c)",
          "package": "compdata",
          "partial": "TPr",
          "signature": "TermT m f-\u003em(Term g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#v:nfTPr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator makes the evaluation of the given functor\n application strict by evaluating all thunks of immediate subterms.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Thunk",
          "name": "strict",
          "package": "compdata",
          "signature": "f a (TrmT m g a) -\u003e TrmT m g a",
          "source": "src/Data-Comp-Param-Thunk.html#strict",
          "type": "function"
        },
        "index": {
          "description": "This combinator makes the evaluation of the given functor application strict by evaluating all thunks of immediate subterms",
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "strict",
          "normalized": "a b(TrmT c d b)-\u003eTrmT c d b",
          "package": "compdata",
          "signature": "f a(TrmT m g a)-\u003eTrmT m g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#v:strict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator makes the evaluation of the given functor\n application strict by evaluating all thunks of immediate subterms.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Thunk",
          "name": "strict'",
          "package": "compdata",
          "signature": "f (TrmT m g a) (TrmT m g a) -\u003e TrmT m g a",
          "source": "src/Data-Comp-Param-Thunk.html#strict%27",
          "type": "function"
        },
        "index": {
          "description": "This combinator makes the evaluation of the given functor application strict by evaluating all thunks of immediate subterms",
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "strict'",
          "normalized": "a(TrmT b c d)(TrmT b c d)-\u003eTrmT b c d",
          "package": "compdata",
          "signature": "f(TrmT m g a)(TrmT m g a)-\u003eTrmT m g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#v:strict-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function turns a monadic computation into a thunk.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Thunk",
          "name": "thunk",
          "package": "compdata",
          "signature": "m (Cxt h f a b) -\u003e Cxt h f a b",
          "source": "src/Data-Comp-Param-Thunk.html#thunk",
          "type": "function"
        },
        "index": {
          "description": "This function turns monadic computation into thunk",
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "thunk",
          "normalized": "a(Cxt b c d e)-\u003eCxt b c d e",
          "package": "compdata",
          "signature": "m(Cxt h f a b)-\u003eCxt h f a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#v:thunk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function evaluates all thunks until a non-thunk node is\n found.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Thunk",
          "name": "whnf",
          "package": "compdata",
          "signature": "TrmT m f a -\u003e m (Either a (f a (TrmT m f a)))",
          "source": "src/Data-Comp-Param-Thunk.html#whnf",
          "type": "function"
        },
        "index": {
          "description": "This function evaluates all thunks until non-thunk node is found",
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "whnf",
          "normalized": "TrmT a b c-\u003ea(Either c(b c(TrmT a b c)))",
          "package": "compdata",
          "signature": "TrmT m f a-\u003em(Either a(f a(TrmT m f a)))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#v:whnf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Param.Thunk",
          "name": "whnf'",
          "package": "compdata",
          "signature": "TrmT m f a -\u003e m (TrmT m f a)",
          "source": "src/Data-Comp-Param-Thunk.html#whnf%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "whnf'",
          "normalized": "TrmT a b c-\u003ea(TrmT a b c)",
          "package": "compdata",
          "signature": "TrmT m f a-\u003em(TrmT m f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#v:whnf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function first evaluates the argument term into whnf via\n \u003ccode\u003e\u003ca\u003ewhnf\u003c/a\u003e\u003c/code\u003e and then projects the top-level signature to the desired\n subsignature. Failure to do the projection is signalled as a\n failure in the monad.\n\u003c/p\u003e",
          "module": "Data.Comp.Param.Thunk",
          "name": "whnfPr",
          "package": "compdata",
          "signature": "TrmT m f a -\u003e m (g a (TrmT m f a))",
          "source": "src/Data-Comp-Param-Thunk.html#whnfPr",
          "type": "function"
        },
        "index": {
          "description": "This function first evaluates the argument term into whnf via whnf and then projects the top-level signature to the desired subsignature Failure to do the projection is signalled as failure in the monad",
          "hierarchy": "Data Comp Param Thunk",
          "module": "Data.Comp.Param.Thunk",
          "name": "whnfPr",
          "normalized": "TrmT a b c-\u003ea(d c(TrmT a b c))",
          "package": "compdata",
          "partial": "Pr",
          "signature": "TrmT m f a-\u003em(g a(TrmT m f a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param-Thunk.html#v:whnfPr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the infrastructure necessary to use\n \u003cem\u003eParametric Compositional Data Types\u003c/em\u003e. Parametric Compositional Data Types \n is an extension of Compositional Data Types with parametric\n higher-order abstract syntax (PHOAS) for usage with binders. Examples of\n usage are bundled with the package in the library\n \u003ccode\u003eexamples/Examples/Param\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Param",
          "name": "Param",
          "package": "compdata",
          "source": "src/Data-Comp-Param.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the infrastructure necessary to use Parametric Compositional Data Types Parametric Compositional Data Types is an extension of Compositional Data Types with parametric higher-order abstract syntax PHOAS for usage with binders Examples of usage are bundled with the package in the library examples Examples Param",
          "hierarchy": "Data Comp Param",
          "module": "Data.Comp.Param",
          "name": "Param",
          "package": "compdata",
          "partial": "Param",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Param.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines showing of signatures, which lifts to showing of\n terms and contexts.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Show",
          "name": "Show",
          "package": "compdata",
          "source": "src/Data-Comp-Show.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines showing of signatures which lifts to showing of terms and contexts",
          "hierarchy": "Data Comp Show",
          "module": "Data.Comp.Show",
          "name": "Show",
          "package": "compdata",
          "partial": "Show",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Show.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature printing. An instance \u003ccode\u003eShowF f\u003c/code\u003e gives rise to an instance\n  \u003ccode\u003eShow (Term f)\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Show",
          "name": "ShowF",
          "package": "compdata",
          "source": "src/Data-Comp-Derive-Show.html#ShowF",
          "type": "class"
        },
        "index": {
          "description": "Signature printing An instance ShowF gives rise to an instance Show Term",
          "hierarchy": "Data Comp Show",
          "module": "Data.Comp.Show",
          "name": "ShowF",
          "package": "compdata",
          "partial": "Show",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Show.html#t:ShowF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Show",
          "name": "showF",
          "package": "compdata",
          "signature": "f String -\u003e String",
          "source": "src/Data-Comp-Derive-Show.html#showF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Show",
          "module": "Data.Comp.Show",
          "name": "showF",
          "normalized": "a String-\u003eString",
          "package": "compdata",
          "signature": "f String-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Show.html#v:showF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides the infrastructure to extend signatures.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Sum",
          "name": "Sum",
          "package": "compdata",
          "source": "src/Data-Comp-Sum.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides the infrastructure to extend signatures",
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "Sum",
          "package": "compdata",
          "partial": "Sum",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal sum of signatures (functors).\n\u003c/p\u003e",
          "module": "Data.Comp.Sum",
          "name": ":+:",
          "package": "compdata",
          "source": "src/Data-Comp-Ops.html#%3A%2B%3A",
          "type": "data"
        },
        "index": {
          "description": "Formal sum of signatures functors",
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": ":+:",
          "package": "compdata",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#t::-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature containment relation for automatic injections. The left-hand must\n be an atomic signature, where as the right-hand side must have a list-like\n structure. Examples include \u003ccode\u003ef :\u003c: f :+: g\u003c/code\u003e and \u003ccode\u003eg :\u003c: f :+: (g :+: h)\u003c/code\u003e,\n non-examples include \u003ccode\u003ef :+: g :\u003c: f :+: (g :+: h)\u003c/code\u003e and\n \u003ccode\u003ef :\u003c: (f :+: g) :+: h\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Sum",
          "name": ":\u003c:",
          "package": "compdata",
          "source": "src/Data-Comp-Ops.html#%3A%3C%3A",
          "type": "class"
        },
        "index": {
          "description": "Signature containment relation for automatic injections The left-hand must be an atomic signature where as the right-hand side must have list-like structure Examples include and non-examples include and",
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": ":\u003c:",
          "package": "compdata",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#t::-60-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject a term over a sub signature to a term over larger signature. If the\n signature \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use \u003ccode\u003edeepInject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e\n instead.\n\u003c/p\u003e",
          "module": "Data.Comp.Sum",
          "name": "deepInject",
          "package": "compdata",
          "signature": "CxtFun g f",
          "source": "src/Data-Comp-Sum.html#deepInject",
          "type": "function"
        },
        "index": {
          "description": "Inject term over sub signature to term over larger signature If the signature is compound of atomic signatures use deepInject instead",
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepInject",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepInject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepInject10",
          "package": "compdata",
          "signature": "CxtFun (:+: f10 (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))))) g",
          "source": "src/Data-Comp-Sum.html#deepInject10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepInject10",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepInject10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepInject2",
          "package": "compdata",
          "signature": "CxtFun (:+: f2 f1) g",
          "source": "src/Data-Comp-Sum.html#deepInject2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepInject2",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepInject2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepInject3",
          "package": "compdata",
          "signature": "CxtFun (:+: f3 (:+: f2 f1)) g",
          "source": "src/Data-Comp-Sum.html#deepInject3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepInject3",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepInject3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepInject4",
          "package": "compdata",
          "signature": "CxtFun (:+: f4 (:+: f3 (:+: f2 f1))) g",
          "source": "src/Data-Comp-Sum.html#deepInject4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepInject4",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepInject4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepInject5",
          "package": "compdata",
          "signature": "CxtFun (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))) g",
          "source": "src/Data-Comp-Sum.html#deepInject5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepInject5",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepInject5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepInject6",
          "package": "compdata",
          "signature": "CxtFun (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))) g",
          "source": "src/Data-Comp-Sum.html#deepInject6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepInject6",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepInject6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepInject7",
          "package": "compdata",
          "signature": "CxtFun (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))) g",
          "source": "src/Data-Comp-Sum.html#deepInject7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepInject7",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepInject7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepInject8",
          "package": "compdata",
          "signature": "CxtFun (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))) g",
          "source": "src/Data-Comp-Sum.html#deepInject8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepInject8",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepInject8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepInject9",
          "package": "compdata",
          "signature": "CxtFun (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))))) g",
          "source": "src/Data-Comp-Sum.html#deepInject9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepInject9",
          "package": "compdata",
          "partial": "Inject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepInject9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTries to coerce a term\u003cem\u003econtext to a term\u003c/em\u003econtext over a sub-signature. If\n the signature \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use\n \u003ccode\u003edeepProject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Comp.Sum",
          "name": "deepProject",
          "package": "compdata",
          "signature": "CxtFunM Maybe f g",
          "source": "src/Data-Comp-Sum.html#deepProject",
          "type": "function"
        },
        "index": {
          "description": "Tries to coerce term context to term context over sub-signature If the signature is compound of atomic signatures use deepProject instead",
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepProject",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepProject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepProject10",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g10 (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))))",
          "source": "src/Data-Comp-Sum.html#deepProject10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepProject10",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepProject10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepProject2",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g2 g1)",
          "source": "src/Data-Comp-Sum.html#deepProject2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepProject2",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepProject2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepProject3",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g3 (:+: g2 g1))",
          "source": "src/Data-Comp-Sum.html#deepProject3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepProject3",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepProject3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepProject4",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g4 (:+: g3 (:+: g2 g1)))",
          "source": "src/Data-Comp-Sum.html#deepProject4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepProject4",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepProject4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepProject5",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))",
          "source": "src/Data-Comp-Sum.html#deepProject5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepProject5",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepProject5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepProject6",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))",
          "source": "src/Data-Comp-Sum.html#deepProject6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepProject6",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepProject6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepProject7",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))",
          "source": "src/Data-Comp-Sum.html#deepProject7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepProject7",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepProject7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepProject8",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))",
          "source": "src/Data-Comp-Sum.html#deepProject8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepProject8",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepProject8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "deepProject9",
          "package": "compdata",
          "signature": "CxtFunM Maybe f (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))))",
          "source": "src/Data-Comp-Sum.html#deepProject9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "deepProject9",
          "package": "compdata",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:deepProject9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inj",
          "package": "compdata",
          "signature": "sub a -\u003e sup a",
          "source": "src/Data-Comp-Ops.html#inj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inj",
          "normalized": "a b-\u003ec b",
          "package": "compdata",
          "signature": "sub a-\u003esup a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inj10",
          "package": "compdata",
          "signature": ":+: f10 (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))))) a -\u003e g a",
          "source": "src/Data-Comp-Sum.html#inj10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inj10",
          "normalized": "a(a(a(a(a(a(a(a(a a))))))))b-\u003ec b",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f(f f))))))))a-\u003eg a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inj10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inj2",
          "package": "compdata",
          "signature": ":+: f2 f1 a -\u003e g a",
          "source": "src/Data-Comp-Sum.html#inj2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inj2",
          "normalized": "a a b-\u003ec b",
          "package": "compdata",
          "signature": "f f a-\u003eg a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inj2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inj3",
          "package": "compdata",
          "signature": ":+: f3 (:+: f2 f1) a -\u003e g a",
          "source": "src/Data-Comp-Sum.html#inj3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inj3",
          "normalized": "a(a a)b-\u003ec b",
          "package": "compdata",
          "signature": "f(f f)a-\u003eg a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inj3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inj4",
          "package": "compdata",
          "signature": ":+: f4 (:+: f3 (:+: f2 f1)) a -\u003e g a",
          "source": "src/Data-Comp-Sum.html#inj4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inj4",
          "normalized": "a(a(a a))b-\u003ec b",
          "package": "compdata",
          "signature": "f(f(f f))a-\u003eg a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inj5",
          "package": "compdata",
          "signature": ":+: f5 (:+: f4 (:+: f3 (:+: f2 f1))) a -\u003e g a",
          "source": "src/Data-Comp-Sum.html#inj5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inj5",
          "normalized": "a(a(a(a a)))b-\u003ec b",
          "package": "compdata",
          "signature": "f(f(f(f f)))a-\u003eg a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inj5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inj6",
          "package": "compdata",
          "signature": ":+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))) a -\u003e g a",
          "source": "src/Data-Comp-Sum.html#inj6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inj6",
          "normalized": "a(a(a(a(a a))))b-\u003ec b",
          "package": "compdata",
          "signature": "f(f(f(f(f f))))a-\u003eg a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inj6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inj7",
          "package": "compdata",
          "signature": ":+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))) a -\u003e g a",
          "source": "src/Data-Comp-Sum.html#inj7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inj7",
          "normalized": "a(a(a(a(a(a a)))))b-\u003ec b",
          "package": "compdata",
          "signature": "f(f(f(f(f(f f)))))a-\u003eg a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inj7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inj8",
          "package": "compdata",
          "signature": ":+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))) a -\u003e g a",
          "source": "src/Data-Comp-Sum.html#inj8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inj8",
          "normalized": "a(a(a(a(a(a(a a))))))b-\u003ec b",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f f))))))a-\u003eg a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inj8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inj9",
          "package": "compdata",
          "signature": ":+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))) a -\u003e g a",
          "source": "src/Data-Comp-Sum.html#inj9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inj9",
          "normalized": "a(a(a(a(a(a(a(a a)))))))b-\u003ec b",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f f)))))))a-\u003eg a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inj9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject a term where the outermost layer is a sub signature. If the signature\n \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use \u003ccode\u003einject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Comp.Sum",
          "name": "inject",
          "package": "compdata",
          "signature": "g (Cxt h f a) -\u003e Cxt h f a",
          "source": "src/Data-Comp-Sum.html#inject",
          "type": "function"
        },
        "index": {
          "description": "Inject term where the outermost layer is sub signature If the signature is compound of atomic signatures use inject instead",
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inject",
          "normalized": "a(Cxt b c d)-\u003eCxt b c d",
          "package": "compdata",
          "signature": "g(Cxt h f a)-\u003eCxt h f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inject10",
          "package": "compdata",
          "signature": ":+: f10 (:+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))))) (Cxt h g a) -\u003e Cxt h g a",
          "source": "src/Data-Comp-Sum.html#inject10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inject10",
          "normalized": "a(a(a(a(a(a(a(a(a a))))))))(Cxt b c d)-\u003eCxt b c d",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f(f f))))))))(Cxt h g a)-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inject10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inject2",
          "package": "compdata",
          "signature": ":+: f2 f1 (Cxt h g a) -\u003e Cxt h g a",
          "source": "src/Data-Comp-Sum.html#inject2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inject2",
          "normalized": "a a(Cxt b c d)-\u003eCxt b c d",
          "package": "compdata",
          "signature": "f f(Cxt h g a)-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inject2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inject3",
          "package": "compdata",
          "signature": ":+: f3 (:+: f2 f1) (Cxt h g a) -\u003e Cxt h g a",
          "source": "src/Data-Comp-Sum.html#inject3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inject3",
          "normalized": "a(a a)(Cxt b c d)-\u003eCxt b c d",
          "package": "compdata",
          "signature": "f(f f)(Cxt h g a)-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inject3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inject4",
          "package": "compdata",
          "signature": ":+: f4 (:+: f3 (:+: f2 f1)) (Cxt h g a) -\u003e Cxt h g a",
          "source": "src/Data-Comp-Sum.html#inject4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inject4",
          "normalized": "a(a(a a))(Cxt b c d)-\u003eCxt b c d",
          "package": "compdata",
          "signature": "f(f(f f))(Cxt h g a)-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inject4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inject5",
          "package": "compdata",
          "signature": ":+: f5 (:+: f4 (:+: f3 (:+: f2 f1))) (Cxt h g a) -\u003e Cxt h g a",
          "source": "src/Data-Comp-Sum.html#inject5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inject5",
          "normalized": "a(a(a(a a)))(Cxt b c d)-\u003eCxt b c d",
          "package": "compdata",
          "signature": "f(f(f(f f)))(Cxt h g a)-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inject5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inject6",
          "package": "compdata",
          "signature": ":+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))) (Cxt h g a) -\u003e Cxt h g a",
          "source": "src/Data-Comp-Sum.html#inject6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inject6",
          "normalized": "a(a(a(a(a a))))(Cxt b c d)-\u003eCxt b c d",
          "package": "compdata",
          "signature": "f(f(f(f(f f))))(Cxt h g a)-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inject6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inject7",
          "package": "compdata",
          "signature": ":+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))) (Cxt h g a) -\u003e Cxt h g a",
          "source": "src/Data-Comp-Sum.html#inject7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inject7",
          "normalized": "a(a(a(a(a(a a)))))(Cxt b c d)-\u003eCxt b c d",
          "package": "compdata",
          "signature": "f(f(f(f(f(f f)))))(Cxt h g a)-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inject7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inject8",
          "package": "compdata",
          "signature": ":+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1)))))) (Cxt h g a) -\u003e Cxt h g a",
          "source": "src/Data-Comp-Sum.html#inject8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inject8",
          "normalized": "a(a(a(a(a(a(a a))))))(Cxt b c d)-\u003eCxt b c d",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f f))))))(Cxt h g a)-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inject8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "inject9",
          "package": "compdata",
          "signature": ":+: f9 (:+: f8 (:+: f7 (:+: f6 (:+: f5 (:+: f4 (:+: f3 (:+: f2 f1))))))) (Cxt h g a) -\u003e Cxt h g a",
          "source": "src/Data-Comp-Sum.html#inject9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "inject9",
          "normalized": "a(a(a(a(a(a(a(a a)))))))(Cxt b c d)-\u003eCxt b c d",
          "package": "compdata",
          "signature": "f(f(f(f(f(f(f(f f)))))))(Cxt h g a)-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:inject9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "injectConst",
          "package": "compdata",
          "signature": "Const g -\u003e Cxt h f a",
          "source": "src/Data-Comp-Sum.html#injectConst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "injectConst",
          "normalized": "Const a-\u003eCxt b c d",
          "package": "compdata",
          "partial": "Const",
          "signature": "Const g-\u003eCxt h f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:injectConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "injectConst2",
          "package": "compdata",
          "signature": "Const (f1 :+: f2) -\u003e Cxt h g a",
          "source": "src/Data-Comp-Sum.html#injectConst2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "injectConst2",
          "normalized": "Const(a a)-\u003eCxt b c d",
          "package": "compdata",
          "partial": "Const",
          "signature": "Const(f f)-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:injectConst2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "injectConst3",
          "package": "compdata",
          "signature": "Const (f1 :+: (f2 :+: f3)) -\u003e Cxt h g a",
          "source": "src/Data-Comp-Sum.html#injectConst3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "injectConst3",
          "normalized": "Const(a(a a))-\u003eCxt b c d",
          "package": "compdata",
          "partial": "Const",
          "signature": "Const(f(f f))-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:injectConst3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function injects a whole context into another context. \n\u003c/p\u003e",
          "module": "Data.Comp.Sum",
          "name": "injectCxt",
          "package": "compdata",
          "signature": "Cxt h' g (Cxt h f a) -\u003e Cxt h f a",
          "source": "src/Data-Comp-Sum.html#injectCxt",
          "type": "function"
        },
        "index": {
          "description": "This function injects whole context into another context",
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "injectCxt",
          "normalized": "Cxt a b(Cxt c d e)-\u003eCxt c d e",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "Cxt h' g(Cxt h f a)-\u003eCxt h f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:injectCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function lifts the given functor to a context. \n\u003c/p\u003e",
          "module": "Data.Comp.Sum",
          "name": "liftCxt",
          "package": "compdata",
          "signature": "g a -\u003e Context f a",
          "source": "src/Data-Comp-Sum.html#liftCxt",
          "type": "function"
        },
        "index": {
          "description": "This function lifts the given functor to context",
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "liftCxt",
          "normalized": "a b-\u003eContext c b",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "g a-\u003eContext f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:liftCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "proj",
          "package": "compdata",
          "signature": "sup a -\u003e Maybe (sub a)",
          "source": "src/Data-Comp-Ops.html#proj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "proj",
          "normalized": "a b-\u003eMaybe(c b)",
          "package": "compdata",
          "signature": "sup a-\u003eMaybe(sub a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:proj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "proj10",
          "package": "compdata",
          "signature": "f a -\u003e Maybe (:+: g10 (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))) a)",
          "source": "src/Data-Comp-Sum.html#proj10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "proj10",
          "normalized": "a b-\u003eMaybe(c(c(c(c(c(c(c(c(c c))))))))b)",
          "package": "compdata",
          "signature": "f a-\u003eMaybe(g(g(g(g(g(g(g(g(g g))))))))a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:proj10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "proj2",
          "package": "compdata",
          "signature": "f a -\u003e Maybe (:+: g2 g1 a)",
          "source": "src/Data-Comp-Sum.html#proj2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "proj2",
          "normalized": "a b-\u003eMaybe(c c b)",
          "package": "compdata",
          "signature": "f a-\u003eMaybe(g g a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:proj2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "proj3",
          "package": "compdata",
          "signature": "f a -\u003e Maybe (:+: g3 (:+: g2 g1) a)",
          "source": "src/Data-Comp-Sum.html#proj3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "proj3",
          "normalized": "a b-\u003eMaybe(c(c c)b)",
          "package": "compdata",
          "signature": "f a-\u003eMaybe(g(g g)a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:proj3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "proj4",
          "package": "compdata",
          "signature": "f a -\u003e Maybe (:+: g4 (:+: g3 (:+: g2 g1)) a)",
          "source": "src/Data-Comp-Sum.html#proj4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "proj4",
          "normalized": "a b-\u003eMaybe(c(c(c c))b)",
          "package": "compdata",
          "signature": "f a-\u003eMaybe(g(g(g g))a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:proj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "proj5",
          "package": "compdata",
          "signature": "f a -\u003e Maybe (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))) a)",
          "source": "src/Data-Comp-Sum.html#proj5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "proj5",
          "normalized": "a b-\u003eMaybe(c(c(c(c c)))b)",
          "package": "compdata",
          "signature": "f a-\u003eMaybe(g(g(g(g g)))a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:proj5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "proj6",
          "package": "compdata",
          "signature": "f a -\u003e Maybe (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))) a)",
          "source": "src/Data-Comp-Sum.html#proj6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "proj6",
          "normalized": "a b-\u003eMaybe(c(c(c(c(c c))))b)",
          "package": "compdata",
          "signature": "f a-\u003eMaybe(g(g(g(g(g g))))a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:proj6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "proj7",
          "package": "compdata",
          "signature": "f a -\u003e Maybe (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))) a)",
          "source": "src/Data-Comp-Sum.html#proj7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "proj7",
          "normalized": "a b-\u003eMaybe(c(c(c(c(c(c c)))))b)",
          "package": "compdata",
          "signature": "f a-\u003eMaybe(g(g(g(g(g(g g)))))a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:proj7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "proj8",
          "package": "compdata",
          "signature": "f a -\u003e Maybe (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))) a)",
          "source": "src/Data-Comp-Sum.html#proj8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "proj8",
          "normalized": "a b-\u003eMaybe(c(c(c(c(c(c(c c))))))b)",
          "package": "compdata",
          "signature": "f a-\u003eMaybe(g(g(g(g(g(g(g g))))))a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:proj8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "proj9",
          "package": "compdata",
          "signature": "f a -\u003e Maybe (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))) a)",
          "source": "src/Data-Comp-Sum.html#proj9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "proj9",
          "normalized": "a b-\u003eMaybe(c(c(c(c(c(c(c(c c)))))))b)",
          "package": "compdata",
          "signature": "f a-\u003eMaybe(g(g(g(g(g(g(g(g g)))))))a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:proj9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject the outermost layer of a term to a sub signature. If the signature\n \u003ccode\u003eg\u003c/code\u003e is compound of \u003cem\u003en\u003c/em\u003e atomic signatures, use \u003ccode\u003eproject\u003c/code\u003e\u003cem\u003en\u003c/em\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Comp.Sum",
          "name": "project",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Maybe (g (Cxt h f a))",
          "source": "src/Data-Comp-Sum.html#project",
          "type": "function"
        },
        "index": {
          "description": "Project the outermost layer of term to sub signature If the signature is compound of atomic signatures use project instead",
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "project",
          "normalized": "Cxt a b c-\u003eMaybe(d(Cxt a b c))",
          "package": "compdata",
          "signature": "Cxt h f a-\u003eMaybe(g(Cxt h f a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:project"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "project10",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Maybe (:+: g10 (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))))) (Cxt h f a))",
          "source": "src/Data-Comp-Sum.html#project10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "project10",
          "normalized": "Cxt a b c-\u003eMaybe(d(d(d(d(d(d(d(d(d d))))))))(Cxt a b c))",
          "package": "compdata",
          "signature": "Cxt h f a-\u003eMaybe(g(g(g(g(g(g(g(g(g g))))))))(Cxt h f a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:project10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "project2",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Maybe (:+: g2 g1 (Cxt h f a))",
          "source": "src/Data-Comp-Sum.html#project2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "project2",
          "normalized": "Cxt a b c-\u003eMaybe(d d(Cxt a b c))",
          "package": "compdata",
          "signature": "Cxt h f a-\u003eMaybe(g g(Cxt h f a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:project2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "project3",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Maybe (:+: g3 (:+: g2 g1) (Cxt h f a))",
          "source": "src/Data-Comp-Sum.html#project3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "project3",
          "normalized": "Cxt a b c-\u003eMaybe(d(d d)(Cxt a b c))",
          "package": "compdata",
          "signature": "Cxt h f a-\u003eMaybe(g(g g)(Cxt h f a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:project3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "project4",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Maybe (:+: g4 (:+: g3 (:+: g2 g1)) (Cxt h f a))",
          "source": "src/Data-Comp-Sum.html#project4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "project4",
          "normalized": "Cxt a b c-\u003eMaybe(d(d(d d))(Cxt a b c))",
          "package": "compdata",
          "signature": "Cxt h f a-\u003eMaybe(g(g(g g))(Cxt h f a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:project4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "project5",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Maybe (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))) (Cxt h f a))",
          "source": "src/Data-Comp-Sum.html#project5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "project5",
          "normalized": "Cxt a b c-\u003eMaybe(d(d(d(d d)))(Cxt a b c))",
          "package": "compdata",
          "signature": "Cxt h f a-\u003eMaybe(g(g(g(g g)))(Cxt h f a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:project5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "project6",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Maybe (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))) (Cxt h f a))",
          "source": "src/Data-Comp-Sum.html#project6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "project6",
          "normalized": "Cxt a b c-\u003eMaybe(d(d(d(d(d d))))(Cxt a b c))",
          "package": "compdata",
          "signature": "Cxt h f a-\u003eMaybe(g(g(g(g(g g))))(Cxt h f a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:project6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "project7",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Maybe (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))) (Cxt h f a))",
          "source": "src/Data-Comp-Sum.html#project7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "project7",
          "normalized": "Cxt a b c-\u003eMaybe(d(d(d(d(d(d d)))))(Cxt a b c))",
          "package": "compdata",
          "signature": "Cxt h f a-\u003eMaybe(g(g(g(g(g(g g)))))(Cxt h f a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:project7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "project8",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Maybe (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1)))))) (Cxt h f a))",
          "source": "src/Data-Comp-Sum.html#project8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "project8",
          "normalized": "Cxt a b c-\u003eMaybe(d(d(d(d(d(d(d d))))))(Cxt a b c))",
          "package": "compdata",
          "signature": "Cxt h f a-\u003eMaybe(g(g(g(g(g(g(g g))))))(Cxt h f a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:project8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "project9",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Maybe (:+: g9 (:+: g8 (:+: g7 (:+: g6 (:+: g5 (:+: g4 (:+: g3 (:+: g2 g1))))))) (Cxt h f a))",
          "source": "src/Data-Comp-Sum.html#project9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "project9",
          "normalized": "Cxt a b c-\u003eMaybe(d(d(d(d(d(d(d(d d)))))))(Cxt a b c))",
          "package": "compdata",
          "signature": "Cxt h f a-\u003eMaybe(g(g(g(g(g(g(g(g g)))))))(Cxt h f a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:project9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "projectConst",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Maybe (Const g)",
          "source": "src/Data-Comp-Sum.html#projectConst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "projectConst",
          "normalized": "Cxt a b c-\u003eMaybe(Const d)",
          "package": "compdata",
          "partial": "Const",
          "signature": "Cxt h f a-\u003eMaybe(Const g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:projectConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies the given context with hole type \u003ccode\u003ea\u003c/code\u003e to a\nfamily \u003ccode\u003ef\u003c/code\u003e of contexts (possibly terms) indexed by \u003ccode\u003ea\u003c/code\u003e. That is, each\nhole \u003ccode\u003eh\u003c/code\u003e is replaced by the context \u003ccode\u003ef h\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Sum",
          "name": "substHoles",
          "package": "compdata",
          "signature": "Cxt h' f v -\u003e (v -\u003e Cxt h g a) -\u003e Cxt h g a",
          "source": "src/Data-Comp-Sum.html#substHoles",
          "type": "function"
        },
        "index": {
          "description": "This function applies the given context with hole type to family of contexts possibly terms indexed by That is each hole is replaced by the context",
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "substHoles",
          "normalized": "Cxt a b c-\u003e(c-\u003eCxt d e f)-\u003eCxt d e f",
          "package": "compdata",
          "partial": "Holes",
          "signature": "Cxt h' f v-\u003e(v-\u003eCxt h g a)-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:substHoles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Sum",
          "name": "substHoles'",
          "package": "compdata",
          "signature": "Cxt h' f v -\u003e Map v (Cxt h g a) -\u003e Cxt h g a",
          "source": "src/Data-Comp-Sum.html#substHoles%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Sum",
          "module": "Data.Comp.Sum",
          "name": "substHoles'",
          "normalized": "Cxt a b c-\u003eMap c(Cxt d e f)-\u003eCxt d e f",
          "package": "compdata",
          "partial": "Holes'",
          "signature": "Cxt h' f v-\u003eMap v(Cxt h g a)-\u003eCxt h g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Sum.html#v:substHoles-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the central notion of \u003cem\u003eterms\u003c/em\u003e and its\n generalisation to contexts.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Term",
          "name": "Term",
          "package": "compdata",
          "source": "src/Data-Comp-Term.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the central notion of terms and its generalisation to contexts",
          "hierarchy": "Data Comp Term",
          "module": "Data.Comp.Term",
          "name": "Term",
          "package": "compdata",
          "partial": "Term",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Term.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Term",
          "name": "Const",
          "package": "compdata",
          "source": "src/Data-Comp-Term.html#Const",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Comp Term",
          "module": "Data.Comp.Term",
          "name": "Const",
          "package": "compdata",
          "partial": "Const",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Term.html#t:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Term",
          "name": "Context",
          "package": "compdata",
          "source": "src/Data-Comp-Term.html#Context",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Comp Term",
          "module": "Data.Comp.Term",
          "name": "Context",
          "package": "compdata",
          "partial": "Context",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Term.html#t:Context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type represents contexts over a signature. Contexts are\nterms containing zero or more holes. The first type parameter is\nsupposed to be one of the phantom types \u003ccode\u003e\u003ca\u003eHole\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eNoHole\u003c/a\u003e\u003c/code\u003e. The\nsecond parameter is the signature of the context. The third parameter\nis the type of the holes. \n\u003c/p\u003e",
          "module": "Data.Comp.Term",
          "name": "Cxt",
          "package": "compdata",
          "source": "src/Data-Comp-Term.html#Cxt",
          "type": "data"
        },
        "index": {
          "description": "This data type represents contexts over signature Contexts are terms containing zero or more holes The first type parameter is supposed to be one of the phantom types Hole and NoHole The second parameter is the signature of the context The third parameter is the type of the holes",
          "hierarchy": "Data Comp Term",
          "module": "Data.Comp.Term",
          "name": "Cxt",
          "package": "compdata",
          "partial": "Cxt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Term.html#t:Cxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhantom type that signals that a \u003ccode\u003e\u003ca\u003eCxt\u003c/a\u003e\u003c/code\u003e might contain holes.  \n\u003c/p\u003e",
          "module": "Data.Comp.Term",
          "name": "Hole",
          "package": "compdata",
          "source": "src/Data-Comp-Term.html#Hole",
          "type": "data"
        },
        "index": {
          "description": "Phantom type that signals that Cxt might contain holes",
          "hierarchy": "Data Comp Term",
          "module": "Data.Comp.Term",
          "name": "Hole",
          "package": "compdata",
          "partial": "Hole",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Term.html#t:Hole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhantom type that signals that a \u003ccode\u003e\u003ca\u003eCxt\u003c/a\u003e\u003c/code\u003e does not contain holes.\n\u003c/p\u003e",
          "module": "Data.Comp.Term",
          "name": "NoHole",
          "package": "compdata",
          "source": "src/Data-Comp-Term.html#NoHole",
          "type": "data"
        },
        "index": {
          "description": "Phantom type that signals that Cxt does not contain holes",
          "hierarchy": "Data Comp Term",
          "module": "Data.Comp.Term",
          "name": "NoHole",
          "package": "compdata",
          "partial": "No Hole",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Term.html#t:NoHole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePolymorphic definition of a term. This formulation is more\n natural than \u003ccode\u003e\u003ca\u003eTerm\u003c/a\u003e\u003c/code\u003e, it leads to impredicative types in some cases,\n though.\n\u003c/p\u003e",
          "module": "Data.Comp.Term",
          "name": "PTerm",
          "package": "compdata",
          "source": "src/Data-Comp-Term.html#PTerm",
          "type": "type"
        },
        "index": {
          "description": "Polymorphic definition of term This formulation is more natural than Term it leads to impredicative types in some cases though",
          "hierarchy": "Data Comp Term",
          "module": "Data.Comp.Term",
          "name": "PTerm",
          "package": "compdata",
          "partial": "PTerm",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Term.html#t:PTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA term is a context with no holes.  \n\u003c/p\u003e",
          "module": "Data.Comp.Term",
          "name": "Term",
          "package": "compdata",
          "source": "src/Data-Comp-Term.html#Term",
          "type": "type"
        },
        "index": {
          "description": "term is context with no holes",
          "hierarchy": "Data Comp Term",
          "module": "Data.Comp.Term",
          "name": "Term",
          "package": "compdata",
          "partial": "Term",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Term.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Term",
          "name": "Hole",
          "package": "compdata",
          "signature": "a -\u003e Cxt Hole f a",
          "source": "src/Data-Comp-Term.html#Cxt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Term",
          "module": "Data.Comp.Term",
          "name": "Hole",
          "normalized": "a-\u003eCxt Hole b a",
          "package": "compdata",
          "partial": "Hole",
          "signature": "a-\u003eCxt Hole f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Term.html#v:Hole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Term",
          "name": "Term",
          "package": "compdata",
          "signature": "f (Cxt h f a) -\u003e Cxt h f a",
          "source": "src/Data-Comp-Term.html#Cxt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Term",
          "module": "Data.Comp.Term",
          "name": "Term",
          "normalized": "a(Cxt b a c)-\u003eCxt b a c",
          "package": "compdata",
          "partial": "Term",
          "signature": "f(Cxt h f a)-\u003eCxt h f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Term.html#v:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function converts a constant to a term. This assumes that the\nargument is indeed a constant, i.e. does not have a value for the\nargument type of the functor \u003ccode\u003ef\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Term",
          "name": "constTerm",
          "package": "compdata",
          "signature": "Const f -\u003e Term f",
          "source": "src/Data-Comp-Term.html#constTerm",
          "type": "function"
        },
        "index": {
          "description": "This function converts constant to term This assumes that the argument is indeed constant i.e does not have value for the argument type of the functor",
          "hierarchy": "Data Comp Term",
          "module": "Data.Comp.Term",
          "name": "constTerm",
          "normalized": "Const a-\u003eTerm a",
          "package": "compdata",
          "partial": "Term",
          "signature": "Const f-\u003eTerm f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Term.html#v:constTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a functorial value into a context.  \n\u003c/p\u003e",
          "module": "Data.Comp.Term",
          "name": "simpCxt",
          "package": "compdata",
          "signature": "f a -\u003e Context f a",
          "source": "src/Data-Comp-Term.html#simpCxt",
          "type": "function"
        },
        "index": {
          "description": "Convert functorial value into context",
          "hierarchy": "Data Comp Term",
          "module": "Data.Comp.Term",
          "name": "simpCxt",
          "normalized": "a b-\u003eContext a b",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "f a-\u003eContext f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Term.html#v:simpCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast a term over a signature to a context over the same signature. \n\u003c/p\u003e",
          "module": "Data.Comp.Term",
          "name": "toCxt",
          "package": "compdata",
          "signature": "Term f -\u003e Cxt h f a",
          "source": "src/Data-Comp-Term.html#toCxt",
          "type": "function"
        },
        "index": {
          "description": "Cast term over signature to context over the same signature",
          "hierarchy": "Data Comp Term",
          "module": "Data.Comp.Term",
          "name": "toCxt",
          "normalized": "Term a-\u003eCxt b a c",
          "package": "compdata",
          "partial": "Cxt",
          "signature": "Term f-\u003eCxt h f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Term.html#v:toCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function unravels the given term at the topmost layer.  \n\u003c/p\u003e",
          "module": "Data.Comp.Term",
          "name": "unTerm",
          "package": "compdata",
          "signature": "Cxt NoHole f a -\u003e f (Cxt NoHole f a)",
          "source": "src/Data-Comp-Term.html#unTerm",
          "type": "function"
        },
        "index": {
          "description": "This function unravels the given term at the topmost layer",
          "hierarchy": "Data Comp Term",
          "module": "Data.Comp.Term",
          "name": "unTerm",
          "normalized": "Cxt NoHole a b-\u003ea(Cxt NoHole a b)",
          "package": "compdata",
          "partial": "Term",
          "signature": "Cxt NoHole f a-\u003ef(Cxt NoHole f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Term.html#v:unTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines term rewriting systems (TRSs) using compositional data\n types.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "TermRewriting",
          "package": "compdata",
          "source": "src/Data-Comp-TermRewriting.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines term rewriting systems TRSs using compositional data types",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "TermRewriting",
          "package": "compdata",
          "partial": "Term Rewriting",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a potential single step reduction from any\n input. If there is no single step then the return value is the\n input together with \u003ccode\u003eFalse\u003c/code\u003e. Otherwise, the successor is returned\n together with \u003ccode\u003eTrue\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "BStep",
          "package": "compdata",
          "source": "src/Data-Comp-TermRewriting.html#BStep",
          "type": "type"
        },
        "index": {
          "description": "This type represents potential single step reduction from any input If there is no single step then the return value is the input together with False Otherwise the successor is returned together with True",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "BStep",
          "package": "compdata",
          "partial": "BStep",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#t:BStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents \u003cem\u003erecursive program schemes\u003c/em\u003e.  \n\u003c/p\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "RPS",
          "package": "compdata",
          "source": "src/Data-Comp-TermRewriting.html#RPS",
          "type": "type"
        },
        "index": {
          "description": "This type represents recursive program schemes",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "RPS",
          "package": "compdata",
          "partial": "RPS",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#t:RPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents term rewrite rules from signature \u003ccode\u003ef\u003c/code\u003e to\nsignature \u003ccode\u003eg\u003c/code\u003e over variables of type \u003ccode\u003ev\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "Rule",
          "package": "compdata",
          "source": "src/Data-Comp-TermRewriting.html#Rule",
          "type": "type"
        },
        "index": {
          "description": "This type represents term rewrite rules from signature to signature over variables of type",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "Rule",
          "package": "compdata",
          "partial": "Rule",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#t:Rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents a potential single step reduction from any\n input.\n\u003c/p\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "Step",
          "package": "compdata",
          "source": "src/Data-Comp-TermRewriting.html#Step",
          "type": "type"
        },
        "index": {
          "description": "This type represents potential single step reduction from any input",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "Step",
          "package": "compdata",
          "partial": "Step",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#t:Step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents term rewriting systems (TRSs) from signature\n\u003ccode\u003ef\u003c/code\u003e to signature \u003ccode\u003eg\u003c/code\u003e over variables of type \u003ccode\u003ev\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "TRS",
          "package": "compdata",
          "source": "src/Data-Comp-TermRewriting.html#TRS",
          "type": "type"
        },
        "index": {
          "description": "This type represents term rewriting systems TRSs from signature to signature over variables of type",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "TRS",
          "package": "compdata",
          "partial": "TRS",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#t:TRS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents variables.\n\u003c/p\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "Var",
          "package": "compdata",
          "source": "src/Data-Comp-TermRewriting.html#Var",
          "type": "type"
        },
        "index": {
          "description": "This type represents variables",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "Var",
          "package": "compdata",
          "partial": "Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function tries to apply the given rule at the root of the\ngiven term (resp. context in general). If successful, the function\nreturns the result term of the rewrite step; otherwise \u003ccode\u003eNothing\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "appRule",
          "package": "compdata",
          "signature": "Rule f f v -\u003e Step (Cxt h f a)",
          "source": "src/Data-Comp-TermRewriting.html#appRule",
          "type": "function"
        },
        "index": {
          "description": "This function tries to apply the given rule at the root of the given term resp context in general If successful the function returns the result term of the rewrite step otherwise Nothing",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "appRule",
          "normalized": "Rule a a b-\u003eStep(Cxt c a d)",
          "package": "compdata",
          "partial": "Rule",
          "signature": "Rule f f v-\u003eStep(Cxt h f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#v:appRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function tries to apply one of the rules in the given TRS at\nthe root of the given term (resp. context in general) by trying each\nrule one by one using \u003ccode\u003e\u003ca\u003eappRule\u003c/a\u003e\u003c/code\u003e until one rule is applicable. If no\nrule is applicable \u003ccode\u003eNothing\u003c/code\u003e is returned. \n\u003c/p\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "appTRS",
          "package": "compdata",
          "signature": "TRS f f v -\u003e Step (Cxt h f a)",
          "source": "src/Data-Comp-TermRewriting.html#appTRS",
          "type": "function"
        },
        "index": {
          "description": "This function tries to apply one of the rules in the given TRS at the root of the given term resp context in general by trying each rule one by one using appRule until one rule is applicable If no rule is applicable Nothing is returned",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "appTRS",
          "normalized": "TRS a a b-\u003eStep(Cxt c a d)",
          "package": "compdata",
          "partial": "TRS",
          "signature": "TRS f f v-\u003eStep(Cxt h f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#v:appTRS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an auxiliary function that turns function \u003ccode\u003ef\u003c/code\u003e of type\n  \u003ccode\u003e(t -\u003e Maybe t)\u003c/code\u003e into functions \u003ccode\u003ef'\u003c/code\u003e of type \u003ccode\u003et -\u003e (t,Bool)\u003c/code\u003e. \u003ccode\u003ef' x\u003c/code\u003e\n  evaluates to \u003ccode\u003e(y,True)\u003c/code\u003e if \u003ccode\u003ef x\u003c/code\u003e evaluates to \u003ccode\u003eJust y\u003c/code\u003e, and to\n  \u003ccode\u003e(x,False)\u003c/code\u003e if \u003ccode\u003ef x\u003c/code\u003e evaluates to \u003ccode\u003eNothing\u003c/code\u003e. This function is useful\n  to change the output of functions that apply rules such as \u003ccode\u003e\u003ca\u003eappTRS\u003c/a\u003e\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "bStep",
          "package": "compdata",
          "signature": "Step t -\u003e BStep t",
          "source": "src/Data-Comp-TermRewriting.html#bStep",
          "type": "function"
        },
        "index": {
          "description": "This is an auxiliary function that turns function of type Maybe into functions of type Bool evaluates to True if evaluates to Just and to False if evaluates to Nothing This function is useful to change the output of functions that apply rules such as appTRS",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "bStep",
          "normalized": "Step a-\u003eBStep a",
          "package": "compdata",
          "partial": "Step",
          "signature": "Step t-\u003eBStep t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#v:bStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function tries to match the given rule against the given term\n(resp. context in general) at the root. If successful, the function\nreturns the right hand side of the rule and the matching\nsubstitution. \n\u003c/p\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "matchRule",
          "package": "compdata",
          "signature": "Rule f g v -\u003e Cxt h f a -\u003e Maybe (Context g v, Map v (Cxt h f a))",
          "source": "src/Data-Comp-TermRewriting.html#matchRule",
          "type": "function"
        },
        "index": {
          "description": "This function tries to match the given rule against the given term resp context in general at the root If successful the function returns the right hand side of the rule and the matching substitution",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "matchRule",
          "normalized": "Rule a b c-\u003eCxt d a e-\u003eMaybe(Context b c,Map c(Cxt d a e))",
          "package": "compdata",
          "partial": "Rule",
          "signature": "Rule f g v-\u003eCxt h f a-\u003eMaybe(Context g v,Map v(Cxt h f a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#v:matchRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function tries to match the rules of the given TRS against\n the given term (resp. context in general) at the root. The first\n rule in the TRS that matches is then used and the corresponding\n right-hand side as well the matching substitution is returned.\n\u003c/p\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "matchRules",
          "package": "compdata",
          "signature": "TRS f g v -\u003e Cxt h f a -\u003e Maybe (Context g v, Map v (Cxt h f a))",
          "source": "src/Data-Comp-TermRewriting.html#matchRules",
          "type": "function"
        },
        "index": {
          "description": "This function tries to match the rules of the given TRS against the given term resp context in general at the root The first rule in the TRS that matches is then used and the corresponding right-hand side as well the matching substitution is returned",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "matchRules",
          "normalized": "TRS a b c-\u003eCxt d a e-\u003eMaybe(Context b c,Map c(Cxt d a e))",
          "package": "compdata",
          "partial": "Rules",
          "signature": "TRS f g v-\u003eCxt h f a-\u003eMaybe(Context g v,Map v(Cxt h f a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#v:matchRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function performs a parallel reduction step by trying to\napply rules of the given system to all outermost redexes. If the given\nterm contains no redexes, \u003ccode\u003eNothing\u003c/code\u003e is returned. \n\u003c/p\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "parTopStep",
          "package": "compdata",
          "signature": "TRS f f v -\u003e Step (Cxt h f a)",
          "source": "src/Data-Comp-TermRewriting.html#parTopStep",
          "type": "function"
        },
        "index": {
          "description": "This function performs parallel reduction step by trying to apply rules of the given system to all outermost redexes If the given term contains no redexes Nothing is returned",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "parTopStep",
          "normalized": "TRS a a b-\u003eStep(Cxt c a d)",
          "package": "compdata",
          "partial": "Top Step",
          "signature": "TRS f f v-\u003eStep(Cxt h f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#v:parTopStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function performs a parallel reduction step by trying to\napply rules of the given system to all outermost redexes and then\nrecursively in the variable positions of the redexes. If the given\nterm does not contain any redexes, \u003ccode\u003eNothing\u003c/code\u003e is returned. \n\u003c/p\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "parallelStep",
          "package": "compdata",
          "signature": "TRS f f v -\u003e Step (Cxt h f a)",
          "source": "src/Data-Comp-TermRewriting.html#parallelStep",
          "type": "function"
        },
        "index": {
          "description": "This function performs parallel reduction step by trying to apply rules of the given system to all outermost redexes and then recursively in the variable positions of the redexes If the given term does not contain any redexes Nothing is returned",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "parallelStep",
          "normalized": "TRS a a b-\u003eStep(Cxt c a d)",
          "package": "compdata",
          "partial": "Step",
          "signature": "TRS f f v-\u003eStep(Cxt h f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#v:parallelStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies the given reduction step repeatedly until a\nnormal form is reached. \n\u003c/p\u003e",
          "module": "Data.Comp.TermRewriting",
          "name": "reduce",
          "package": "compdata",
          "signature": "Step t -\u003e t -\u003e t",
          "source": "src/Data-Comp-TermRewriting.html#reduce",
          "type": "function"
        },
        "index": {
          "description": "This function applies the given reduction step repeatedly until normal form is reached",
          "hierarchy": "Data Comp TermRewriting",
          "module": "Data.Comp.TermRewriting",
          "name": "reduce",
          "normalized": "Step a-\u003ea-\u003ea",
          "package": "compdata",
          "signature": "Step t-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-TermRewriting.html#v:reduce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis modules defines terms & contexts with thunks, with deferred\n monadic computations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Thunk",
          "name": "Thunk",
          "package": "compdata",
          "source": "src/Data-Comp-Thunk.html",
          "type": "module"
        },
        "index": {
          "description": "This modules defines terms contexts with thunks with deferred monadic computations",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "Thunk",
          "package": "compdata",
          "partial": "Thunk",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents algebras which have terms with thunks as\n carrier.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "AlgT",
          "package": "compdata",
          "source": "src/Data-Comp-Thunk.html#AlgT",
          "type": "type"
        },
        "index": {
          "description": "This type represents algebras which have terms with thunks as carrier",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "AlgT",
          "package": "compdata",
          "partial": "Alg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#t:AlgT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents contexts with thunks.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "CxtT",
          "package": "compdata",
          "source": "src/Data-Comp-Thunk.html#CxtT",
          "type": "type"
        },
        "index": {
          "description": "This type represents contexts with thunks",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "CxtT",
          "package": "compdata",
          "partial": "Cxt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#t:CxtT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents terms with thunks.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "TermT",
          "package": "compdata",
          "source": "src/Data-Comp-Thunk.html#TermT",
          "type": "type"
        },
        "index": {
          "description": "This type represents terms with thunks",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "TermT",
          "package": "compdata",
          "partial": "Term",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#t:TermT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eeval\u003c/a\u003e\u003c/code\u003e with flipped argument positions\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "(#\u003e)",
          "package": "compdata",
          "signature": "TermT m f -\u003e (f (TermT m f) -\u003e TermT m f) -\u003e TermT m f",
          "source": "src/Data-Comp-Thunk.html#%23%3E",
          "type": "function"
        },
        "index": {
          "description": "Variant of eval with flipped argument positions",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "(#\u003e) #\u003e",
          "normalized": "TermT a b-\u003e(b(TermT a b)-\u003eTermT a b)-\u003eTermT a b",
          "package": "compdata",
          "signature": "TermT m f-\u003e(f(TermT m f)-\u003eTermT m f)-\u003eTermT m f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:-35--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003edeepEval\u003c/a\u003e\u003c/code\u003e with flipped argument positions\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "(#\u003e\u003e)",
          "package": "compdata",
          "signature": "TermT m f -\u003e (Term f -\u003e TermT m f) -\u003e TermT m f",
          "source": "src/Data-Comp-Thunk.html#%23%3E%3E",
          "type": "function"
        },
        "index": {
          "description": "Variant of deepEval with flipped argument positions",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "(#\u003e\u003e) #\u003e\u003e",
          "normalized": "TermT a b-\u003e(Term b-\u003eTermT a b)-\u003eTermT a b",
          "package": "compdata",
          "signature": "TermT m f-\u003e(Term f-\u003eTermT m f)-\u003eTermT m f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:-35--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator runs a catamorphism on a term with thunks.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "cataT",
          "package": "compdata",
          "signature": "Alg f a -\u003e TermT m f -\u003e m a",
          "source": "src/Data-Comp-Thunk.html#cataT",
          "type": "function"
        },
        "index": {
          "description": "This combinator runs catamorphism on term with thunks",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "cataT",
          "normalized": "Alg a b-\u003eTermT c a-\u003ec b",
          "package": "compdata",
          "signature": "Alg f a-\u003eTermT m f-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:cataT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator runs a monadic catamorphism on a term with thunks\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "cataTM",
          "package": "compdata",
          "signature": "AlgM m f a -\u003e TermT m f -\u003e m a",
          "source": "src/Data-Comp-Thunk.html#cataTM",
          "type": "function"
        },
        "index": {
          "description": "This combinator runs monadic catamorphism on term with thunks",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "cataTM",
          "normalized": "AlgM a b c-\u003eTermT a b-\u003ea c",
          "package": "compdata",
          "partial": "TM",
          "signature": "AlgM m f a-\u003eTermT m f-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:cataTM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function inspects a term (using \u003ccode\u003e\u003ca\u003enf\u003c/a\u003e\u003c/code\u003e) according to the\n given function.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "deepEval",
          "package": "compdata",
          "signature": "(Term f -\u003e TermT m f) -\u003e TermT m f -\u003e TermT m f",
          "source": "src/Data-Comp-Thunk.html#deepEval",
          "type": "function"
        },
        "index": {
          "description": "This function inspects term using nf according to the given function",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "deepEval",
          "normalized": "(Term a-\u003eTermT b a)-\u003eTermT b a-\u003eTermT b a",
          "package": "compdata",
          "partial": "Eval",
          "signature": "(Term f-\u003eTermT m f)-\u003eTermT m f-\u003eTermT m f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:deepEval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function inspects two terms (using \u003ccode\u003e\u003ca\u003enf\u003c/a\u003e\u003c/code\u003e) according\n to the given function.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "deepEval2",
          "package": "compdata",
          "signature": "(Term f -\u003e Term f -\u003e TermT m f) -\u003e TermT m f -\u003e TermT m f -\u003e TermT m f",
          "source": "src/Data-Comp-Thunk.html#deepEval2",
          "type": "function"
        },
        "index": {
          "description": "This function inspects two terms using nf according to the given function",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "deepEval2",
          "normalized": "(Term a-\u003eTerm a-\u003eTermT b a)-\u003eTermT b a-\u003eTermT b a-\u003eTermT b a",
          "package": "compdata",
          "partial": "Eval",
          "signature": "(Term f-\u003eTerm f-\u003eTermT m f)-\u003eTermT m f-\u003eTermT m f-\u003eTermT m f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:deepEval2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function decides equality of terms with thunks.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "eqT",
          "package": "compdata",
          "signature": "TermT m f -\u003e TermT m f -\u003e m Bool",
          "source": "src/Data-Comp-Thunk.html#eqT",
          "type": "function"
        },
        "index": {
          "description": "This function decides equality of terms with thunks",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "eqT",
          "normalized": "TermT a b-\u003eTermT a b-\u003ea Bool",
          "package": "compdata",
          "signature": "TermT m f-\u003eTermT m f-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:eqT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function inspects the topmost non-thunk node (using\n \u003ccode\u003e\u003ca\u003ewhnf\u003c/a\u003e\u003c/code\u003e) according to the given function.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "eval",
          "package": "compdata",
          "signature": "(f (TermT m f) -\u003e TermT m f) -\u003e TermT m f -\u003e TermT m f",
          "source": "src/Data-Comp-Thunk.html#eval",
          "type": "function"
        },
        "index": {
          "description": "This function inspects the topmost non-thunk node using whnf according to the given function",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "eval",
          "normalized": "(a(TermT b a)-\u003eTermT b a)-\u003eTermT b a-\u003eTermT b a",
          "package": "compdata",
          "signature": "(f(TermT m f)-\u003eTermT m f)-\u003eTermT m f-\u003eTermT m f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:eval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function inspects the topmost non-thunk nodes of two terms\n (using \u003ccode\u003e\u003ca\u003ewhnf\u003c/a\u003e\u003c/code\u003e) according to the given function.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "eval2",
          "package": "compdata",
          "signature": "(f (TermT m f) -\u003e f (TermT m f) -\u003e TermT m f) -\u003e TermT m f -\u003e TermT m f -\u003e TermT m f",
          "source": "src/Data-Comp-Thunk.html#eval2",
          "type": "function"
        },
        "index": {
          "description": "This function inspects the topmost non-thunk nodes of two terms using whnf according to the given function",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "eval2",
          "normalized": "(a(TermT b a)-\u003ea(TermT b a)-\u003eTermT b a)-\u003eTermT b a-\u003eTermT b a-\u003eTermT b a",
          "package": "compdata",
          "signature": "(f(TermT m f)-\u003ef(TermT m f)-\u003eTermT m f)-\u003eTermT m f-\u003eTermT m f-\u003eTermT m f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:eval2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function evaluates all thunks.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "nf",
          "package": "compdata",
          "signature": "TermT m f -\u003e m (Term f)",
          "source": "src/Data-Comp-Thunk.html#nf",
          "type": "function"
        },
        "index": {
          "description": "This function evaluates all thunks",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "nf",
          "normalized": "TermT a b-\u003ea(Term b)",
          "package": "compdata",
          "signature": "TermT m f-\u003em(Term f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:nf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function evaluates all thunks while simultaneously\n projecting the term to a smaller signature. Failure to do the\n projection is signalled as a failure in the monad as in \u003ccode\u003e\u003ca\u003ewhnfPr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "nfPr",
          "package": "compdata",
          "signature": "TermT m f -\u003e m (Term g)",
          "source": "src/Data-Comp-Thunk.html#nfPr",
          "type": "function"
        },
        "index": {
          "description": "This function evaluates all thunks while simultaneously projecting the term to smaller signature Failure to do the projection is signalled as failure in the monad as in whnfPr",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "nfPr",
          "normalized": "TermT a b-\u003ea(Term c)",
          "package": "compdata",
          "partial": "Pr",
          "signature": "TermT m f-\u003em(Term g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:nfPr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator makes the evaluation of the given functor\n application strict by evaluating all thunks of immediate subterms.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "strict",
          "package": "compdata",
          "signature": "f (TermT m g) -\u003e TermT m g",
          "source": "src/Data-Comp-Thunk.html#strict",
          "type": "function"
        },
        "index": {
          "description": "This combinator makes the evaluation of the given functor application strict by evaluating all thunks of immediate subterms",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "strict",
          "normalized": "a(TermT b c)-\u003eTermT b c",
          "package": "compdata",
          "signature": "f(TermT m g)-\u003eTermT m g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:strict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator is a variant of \u003ccode\u003e\u003ca\u003estrict\u003c/a\u003e\u003c/code\u003e that only makes a subset\n of the arguments of a functor application strict. The first\n argument of this combinator specifies which positions are supposed\n to be strict.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "strictAt",
          "package": "compdata",
          "signature": "Pos f -\u003e f (TermT m g) -\u003e TermT m g",
          "source": "src/Data-Comp-Thunk.html#strictAt",
          "type": "function"
        },
        "index": {
          "description": "This combinator is variant of strict that only makes subset of the arguments of functor application strict The first argument of this combinator specifies which positions are supposed to be strict",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "strictAt",
          "normalized": "Pos a-\u003ea(TermT b c)-\u003eTermT b c",
          "package": "compdata",
          "partial": "At",
          "signature": "Pos f-\u003ef(TermT m g)-\u003eTermT m g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:strictAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function turns a monadic computation into a thunk.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "thunk",
          "package": "compdata",
          "signature": "m (Cxt h f a) -\u003e Cxt h f a",
          "source": "src/Data-Comp-Thunk.html#thunk",
          "type": "function"
        },
        "index": {
          "description": "This function turns monadic computation into thunk",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "thunk",
          "normalized": "a(Cxt b c d)-\u003eCxt b c d",
          "package": "compdata",
          "signature": "m(Cxt h f a)-\u003eCxt h f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:thunk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function evaluates all thunks until a non-thunk node is\n found.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "whnf",
          "package": "compdata",
          "signature": "TermT m f -\u003e m (f (TermT m f))",
          "source": "src/Data-Comp-Thunk.html#whnf",
          "type": "function"
        },
        "index": {
          "description": "This function evaluates all thunks until non-thunk node is found",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "whnf",
          "normalized": "TermT a b-\u003ea(b(TermT a b))",
          "package": "compdata",
          "signature": "TermT m f-\u003em(f(TermT m f))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:whnf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Thunk",
          "name": "whnf'",
          "package": "compdata",
          "signature": "TermT m f -\u003e m (TermT m f)",
          "source": "src/Data-Comp-Thunk.html#whnf%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "whnf'",
          "normalized": "TermT a b-\u003ea(TermT a b)",
          "package": "compdata",
          "signature": "TermT m f-\u003em(TermT m f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:whnf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function first evaluates the argument term into whnf via\n \u003ccode\u003e\u003ca\u003ewhnf\u003c/a\u003e\u003c/code\u003e and then projects the top-level signature to the desired\n subsignature. Failure to do the projection is signalled as a\n failure in the monad.\n\u003c/p\u003e",
          "module": "Data.Comp.Thunk",
          "name": "whnfPr",
          "package": "compdata",
          "signature": "TermT m f -\u003e m (g (TermT m f))",
          "source": "src/Data-Comp-Thunk.html#whnfPr",
          "type": "function"
        },
        "index": {
          "description": "This function first evaluates the argument term into whnf via whnf and then projects the top-level signature to the desired subsignature Failure to do the projection is signalled as failure in the monad",
          "hierarchy": "Data Comp Thunk",
          "module": "Data.Comp.Thunk",
          "name": "whnfPr",
          "normalized": "TermT a b-\u003ea(c(TermT a b))",
          "package": "compdata",
          "partial": "Pr",
          "signature": "TermT m f-\u003em(g(TermT m f))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Thunk.html#v:whnfPr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module implements a simple unification algorithm using compositional\n data types.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Unification",
          "name": "Unification",
          "package": "compdata",
          "source": "src/Data-Comp-Unification.html",
          "type": "module"
        },
        "index": {
          "description": "This module implements simple unification algorithm using compositional data types",
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "Unification",
          "package": "compdata",
          "partial": "Unification",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents equations between terms over a specific\nsignature. \n\u003c/p\u003e",
          "module": "Data.Comp.Unification",
          "name": "Equation",
          "package": "compdata",
          "source": "src/Data-Comp-Unification.html#Equation",
          "type": "type"
        },
        "index": {
          "description": "This type represents equations between terms over specific signature",
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "Equation",
          "package": "compdata",
          "partial": "Equation",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#t:Equation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents list of equations. \n\u003c/p\u003e",
          "module": "Data.Comp.Unification",
          "name": "Equations",
          "package": "compdata",
          "source": "src/Data-Comp-Unification.html#Equations",
          "type": "type"
        },
        "index": {
          "description": "This type represents list of equations",
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "Equations",
          "package": "compdata",
          "partial": "Equations",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#t:Equations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents errors that might occur during the\nunification.  \n\u003c/p\u003e",
          "module": "Data.Comp.Unification",
          "name": "UnifError",
          "package": "compdata",
          "source": "src/Data-Comp-Unification.html#UnifError",
          "type": "data"
        },
        "index": {
          "description": "This type represents errors that might occur during the unification",
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "UnifError",
          "package": "compdata",
          "partial": "Unif Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#t:UnifError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the unification monad that is used to run the unification\n algorithm.\n\u003c/p\u003e",
          "module": "Data.Comp.Unification",
          "name": "UnifyM",
          "package": "compdata",
          "source": "src/Data-Comp-Unification.html#UnifyM",
          "type": "type"
        },
        "index": {
          "description": "This is the unification monad that is used to run the unification algorithm",
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "UnifyM",
          "package": "compdata",
          "partial": "Unify",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#t:UnifyM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents the state for the unification algorithm.\n\u003c/p\u003e",
          "module": "Data.Comp.Unification",
          "name": "UnifyState",
          "package": "compdata",
          "source": "src/Data-Comp-Unification.html#UnifyState",
          "type": "data"
        },
        "index": {
          "description": "This type represents the state for the unification algorithm",
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "UnifyState",
          "package": "compdata",
          "partial": "Unify State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#t:UnifyState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Unification",
          "name": "FailedOccursCheck",
          "package": "compdata",
          "signature": "FailedOccursCheck v (Term f)",
          "source": "src/Data-Comp-Unification.html#UnifError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "FailedOccursCheck",
          "package": "compdata",
          "partial": "Failed Occurs Check",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:FailedOccursCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Unification",
          "name": "HeadSymbolMismatch",
          "package": "compdata",
          "signature": "HeadSymbolMismatch (Term f) (Term f)",
          "source": "src/Data-Comp-Unification.html#UnifError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "HeadSymbolMismatch",
          "package": "compdata",
          "partial": "Head Symbol Mismatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:HeadSymbolMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Unification",
          "name": "UnifError",
          "package": "compdata",
          "signature": "UnifError String",
          "source": "src/Data-Comp-Unification.html#UnifError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "UnifError",
          "package": "compdata",
          "partial": "Unif Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:UnifError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Unification",
          "name": "UnifyState",
          "package": "compdata",
          "signature": "UnifyState",
          "source": "src/Data-Comp-Unification.html#UnifyState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "UnifyState",
          "package": "compdata",
          "partial": "Unify State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:UnifyState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a substitution to each term in a list of\n equations.\n\u003c/p\u003e",
          "module": "Data.Comp.Unification",
          "name": "appSubstEq",
          "package": "compdata",
          "signature": "Subst f v -\u003e Equation f -\u003e Equation f",
          "source": "src/Data-Comp-Unification.html#appSubstEq",
          "type": "function"
        },
        "index": {
          "description": "This function applies substitution to each term in list of equations",
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "appSubstEq",
          "normalized": "Subst a b-\u003eEquation a-\u003eEquation a",
          "package": "compdata",
          "partial": "Subst Eq",
          "signature": "Subst f v-\u003eEquation f-\u003eEquation f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:appSubstEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is used in order to signal a failed occurs check during\n unification.\n\u003c/p\u003e",
          "module": "Data.Comp.Unification",
          "name": "failedOccursCheck",
          "package": "compdata",
          "signature": "v -\u003e Term f -\u003e m a",
          "source": "src/Data-Comp-Unification.html#failedOccursCheck",
          "type": "function"
        },
        "index": {
          "description": "This is used in order to signal failed occurs check during unification",
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "failedOccursCheck",
          "normalized": "a-\u003eTerm b-\u003ec d",
          "package": "compdata",
          "partial": "Occurs Check",
          "signature": "v-\u003eTerm f-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:failedOccursCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is used in order to signal a head symbol mismatch during\n unification.\n\u003c/p\u003e",
          "module": "Data.Comp.Unification",
          "name": "headSymbolMismatch",
          "package": "compdata",
          "signature": "Term f -\u003e Term f -\u003e m a",
          "source": "src/Data-Comp-Unification.html#headSymbolMismatch",
          "type": "function"
        },
        "index": {
          "description": "This is used in order to signal head symbol mismatch during unification",
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "headSymbolMismatch",
          "normalized": "Term a-\u003eTerm a-\u003eb c",
          "package": "compdata",
          "partial": "Symbol Mismatch",
          "signature": "Term f-\u003eTerm f-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:headSymbolMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Unification",
          "name": "putBinding",
          "package": "compdata",
          "signature": "(v, Term f) -\u003e UnifyM f v m ()",
          "source": "src/Data-Comp-Unification.html#putBinding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "putBinding",
          "normalized": "(a,Term b)-\u003eUnifyM b a c()",
          "package": "compdata",
          "partial": "Binding",
          "signature": "(v,Term f)-\u003eUnifyM f v m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:putBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Unification",
          "name": "putEqs",
          "package": "compdata",
          "signature": "Equations f -\u003e UnifyM f v m ()",
          "source": "src/Data-Comp-Unification.html#putEqs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "putEqs",
          "normalized": "Equations a-\u003eUnifyM a b c()",
          "package": "compdata",
          "partial": "Eqs",
          "signature": "Equations f-\u003eUnifyM f v m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:putEqs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Unification",
          "name": "runUnify",
          "package": "compdata",
          "signature": "UnifyM f v m ()",
          "source": "src/Data-Comp-Unification.html#runUnify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "runUnify",
          "normalized": "UnifyM a b c()",
          "package": "compdata",
          "partial": "Unify",
          "signature": "UnifyM f v m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:runUnify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function runs a unification monad with the given initial\n list of equations.\n\u003c/p\u003e",
          "module": "Data.Comp.Unification",
          "name": "runUnifyM",
          "package": "compdata",
          "signature": "UnifyM f v m a -\u003e Equations f -\u003e m (Subst f v)",
          "source": "src/Data-Comp-Unification.html#runUnifyM",
          "type": "function"
        },
        "index": {
          "description": "This function runs unification monad with the given initial list of equations",
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "runUnifyM",
          "normalized": "UnifyM a b c d-\u003eEquations a-\u003ec(Subst a b)",
          "package": "compdata",
          "partial": "Unify",
          "signature": "UnifyM f v m a-\u003eEquations f-\u003em(Subst f v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:runUnifyM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function returns the most general unifier of the given\nequations using the algorithm of Martelli and Montanari. \n\u003c/p\u003e",
          "module": "Data.Comp.Unification",
          "name": "unify",
          "package": "compdata",
          "signature": "Equations f -\u003e m (Subst f v)",
          "source": "src/Data-Comp-Unification.html#unify",
          "type": "function"
        },
        "index": {
          "description": "This function returns the most general unifier of the given equations using the algorithm of Martelli and Montanari",
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "unify",
          "normalized": "Equations a-\u003eb(Subst a c)",
          "package": "compdata",
          "signature": "Equations f-\u003em(Subst f v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:unify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Unification",
          "name": "unifyStep",
          "package": "compdata",
          "signature": "Equation f -\u003e UnifyM f v m ()",
          "source": "src/Data-Comp-Unification.html#unifyStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "unifyStep",
          "normalized": "Equation a-\u003eUnifyM a b c()",
          "package": "compdata",
          "partial": "Step",
          "signature": "Equation f-\u003eUnifyM f v m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:unifyStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Unification",
          "name": "usEqs",
          "package": "compdata",
          "signature": "Equations f",
          "source": "src/Data-Comp-Unification.html#UnifyState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "usEqs",
          "package": "compdata",
          "partial": "Eqs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:usEqs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Unification",
          "name": "usSubst",
          "package": "compdata",
          "signature": "Subst f v",
          "source": "src/Data-Comp-Unification.html#UnifyState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "usSubst",
          "package": "compdata",
          "partial": "Subst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:usSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Unification",
          "name": "withNextEq",
          "package": "compdata",
          "signature": "(Equation f -\u003e UnifyM f v m ()) -\u003e UnifyM f v m ()",
          "source": "src/Data-Comp-Unification.html#withNextEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Unification",
          "module": "Data.Comp.Unification",
          "name": "withNextEq",
          "normalized": "(Equation a-\u003eUnifyM a b c())-\u003eUnifyM a b c()",
          "package": "compdata",
          "partial": "Next Eq",
          "signature": "(Equation f-\u003eUnifyM f v m())-\u003eUnifyM f v m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Unification.html#v:withNextEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines an abstract notion of (bound) variables in compositional\n data types, and scoped substitution. Capture-avoidance is \u003cem\u003enot\u003c/em\u003e taken into\n account.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp.Variables",
          "name": "Variables",
          "package": "compdata",
          "source": "src/Data-Comp-Variables.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines an abstract notion of bound variables in compositional data types and scoped substitution Capture-avoidance is not taken into account",
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "Variables",
          "package": "compdata",
          "partial": "Variables",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents substitutions of contexts, i.e. finite\n mappings from variables to contexts.\n\u003c/p\u003e",
          "module": "Data.Comp.Variables",
          "name": "CxtSubst",
          "package": "compdata",
          "source": "src/Data-Comp-Variables.html#CxtSubst",
          "type": "type"
        },
        "index": {
          "description": "This type represents substitutions of contexts i.e finite mappings from variables to contexts",
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "CxtSubst",
          "package": "compdata",
          "partial": "Cxt Subst",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#t:CxtSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis multiparameter class defines functors with variables. An instance\n  \u003ccode\u003eHasVar f v\u003c/code\u003e denotes that values over \u003ccode\u003ef\u003c/code\u003e might contain and bind variables of\n  type \u003ccode\u003ev\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Variables",
          "name": "HasVars",
          "package": "compdata",
          "source": "src/Data-Comp-Variables.html#HasVars",
          "type": "class"
        },
        "index": {
          "description": "This multiparameter class defines functors with variables An instance HasVar denotes that values over might contain and bind variables of type",
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "HasVars",
          "package": "compdata",
          "partial": "Has Vars",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#t:HasVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents substitutions of terms, i.e. finite mappings\n from variables to terms.\n\u003c/p\u003e",
          "module": "Data.Comp.Variables",
          "name": "Subst",
          "package": "compdata",
          "source": "src/Data-Comp-Variables.html#Subst",
          "type": "type"
        },
        "index": {
          "description": "This type represents substitutions of terms i.e finite mappings from variables to terms",
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "Subst",
          "package": "compdata",
          "partial": "Subst",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#t:Subst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the given substitution.\n\u003c/p\u003e",
          "module": "Data.Comp.Variables",
          "name": "appSubst",
          "package": "compdata",
          "signature": "Map v t -\u003e a -\u003e a",
          "source": "src/Data-Comp-Variables.html#appSubst",
          "type": "function"
        },
        "index": {
          "description": "Apply the given substitution",
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "appSubst",
          "normalized": "Map a b-\u003ec-\u003ec",
          "package": "compdata",
          "partial": "Subst",
          "signature": "Map v t-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#v:appSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndicates the set of variables bound by the \u003ccode\u003ef\u003c/code\u003e constructor\n for each argument of the constructor. For example for a\n non-recursive let binding:\n \u003ccode\u003e\n data Let e = Let Var e e\n instance HasVars Let Var where\n   bindsVars (Let v x y) = Map.fromList [(y, (Set.singleton v))]\n \u003c/code\u003e\n If, instead, the let binding is recursive, the methods has to\n be implemented like this:\n \u003ccode\u003e\n   bindsVars (Let v x y) = Map.fromList [(x, (Set.singleton v)),\n                                         (y, (Set.singleton v))]\n \u003c/code\u003e\n This indicates that the scope of the bound variable also\n extends to the right-hand side of the variable binding.\n\u003c/p\u003e\u003cp\u003eThe default implementation returns the empty map.\n\u003c/p\u003e",
          "module": "Data.Comp.Variables",
          "name": "bindsVars",
          "package": "compdata",
          "signature": "f a -\u003e Map a (Set v)",
          "source": "src/Data-Comp-Variables.html#bindsVars",
          "type": "method"
        },
        "index": {
          "description": "Indicates the set of variables bound by the constructor for each argument of the constructor For example for non-recursive let binding data Let Let Var instance HasVars Let Var where bindsVars Let Map.fromList Set.singleton If instead the let binding is recursive the methods has to be implemented like this bindsVars Let Map.fromList Set.singleton Set.singleton This indicates that the scope of the bound variable also extends to the right-hand side of the variable binding The default implementation returns the empty map",
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "bindsVars",
          "normalized": "a b-\u003eMap b(Set c)",
          "package": "compdata",
          "partial": "Vars",
          "signature": "f a-\u003eMap a(Set v)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#v:bindsVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes two substitutions \u003ccode\u003es1\u003c/code\u003e and \u003ccode\u003es2\u003c/code\u003e. That is,\napplying the resulting substitution is equivalent to first applying\n\u003ccode\u003es2\u003c/code\u003e and then \u003ccode\u003es1\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Data.Comp.Variables",
          "name": "compSubst",
          "package": "compdata",
          "signature": "CxtSubst h a f v -\u003e CxtSubst h a f v -\u003e CxtSubst h a f v",
          "source": "src/Data-Comp-Variables.html#compSubst",
          "type": "function"
        },
        "index": {
          "description": "This function composes two substitutions s1 and s2 That is applying the resulting substitution is equivalent to first applying s2 and then s1",
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "compSubst",
          "normalized": "CxtSubst a b c d-\u003eCxtSubst a b c d-\u003eCxtSubst a b c d",
          "package": "compdata",
          "partial": "Subst",
          "signature": "CxtSubst h a f v-\u003eCxtSubst h a f v-\u003eCxtSubst h a f v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#v:compSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function checks whether a variable is contained in a context. \n\u003c/p\u003e",
          "module": "Data.Comp.Variables",
          "name": "containsVar",
          "package": "compdata",
          "signature": "v -\u003e Cxt h f a -\u003e Bool",
          "source": "src/Data-Comp-Variables.html#containsVar",
          "type": "function"
        },
        "index": {
          "description": "This function checks whether variable is contained in context",
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "containsVar",
          "normalized": "a-\u003eCxt b c d-\u003eBool",
          "package": "compdata",
          "partial": "Var",
          "signature": "v-\u003eCxt h f a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#v:containsVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator pairs every argument of a given constructor with\n the set of (newly) bound variables according to the corresponding\n \u003ccode\u003e\u003ca\u003eHasVars\u003c/a\u003e\u003c/code\u003e type class instance.\n\u003c/p\u003e",
          "module": "Data.Comp.Variables",
          "name": "getBoundVars",
          "package": "compdata",
          "signature": "f a -\u003e f (Set v, a)",
          "source": "src/Data-Comp-Variables.html#getBoundVars",
          "type": "function"
        },
        "index": {
          "description": "This combinator pairs every argument of given constructor with the set of newly bound variables according to the corresponding HasVars type class instance",
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "getBoundVars",
          "normalized": "a b-\u003ea(Set c,b)",
          "package": "compdata",
          "partial": "Bound Vars",
          "signature": "f a-\u003ef(Set v,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#v:getBoundVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndicates whether the \u003ccode\u003ef\u003c/code\u003e constructor is a variable. The\n default implementation returns \u003ccode\u003eNothing\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Comp.Variables",
          "name": "isVar",
          "package": "compdata",
          "signature": "f a -\u003e Maybe v",
          "source": "src/Data-Comp-Variables.html#isVar",
          "type": "method"
        },
        "index": {
          "description": "Indicates whether the constructor is variable The default implementation returns Nothing",
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "isVar",
          "normalized": "a b-\u003eMaybe c",
          "package": "compdata",
          "partial": "Var",
          "signature": "f a-\u003eMaybe v",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#v:isVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Comp.Variables",
          "name": "substVars",
          "package": "compdata",
          "signature": "(v -\u003e Maybe t) -\u003e a -\u003e a",
          "source": "src/Data-Comp-Variables.html#substVars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "substVars",
          "normalized": "(a-\u003eMaybe b)-\u003ec-\u003ec",
          "package": "compdata",
          "partial": "Vars",
          "signature": "(v-\u003eMaybe t)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#v:substVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function computes the list of variables occurring in a context. \n\u003c/p\u003e",
          "module": "Data.Comp.Variables",
          "name": "variableList",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e [v]",
          "source": "src/Data-Comp-Variables.html#variableList",
          "type": "function"
        },
        "index": {
          "description": "This function computes the list of variables occurring in context",
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "variableList",
          "normalized": "Cxt a b c-\u003e[d]",
          "package": "compdata",
          "partial": "List",
          "signature": "Cxt h f a-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#v:variableList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function computes the set of variables occurring in a context. \n\u003c/p\u003e",
          "module": "Data.Comp.Variables",
          "name": "variables",
          "package": "compdata",
          "signature": "Cxt h f a -\u003e Set v",
          "source": "src/Data-Comp-Variables.html#variables",
          "type": "function"
        },
        "index": {
          "description": "This function computes the set of variables occurring in context",
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "variables",
          "normalized": "Cxt a b c-\u003eSet d",
          "package": "compdata",
          "signature": "Cxt h f a-\u003eSet v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#v:variables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function computes the set of variables occurring in a constant. \n\u003c/p\u003e",
          "module": "Data.Comp.Variables",
          "name": "variables'",
          "package": "compdata",
          "signature": "Const f -\u003e Set v",
          "source": "src/Data-Comp-Variables.html#variables%27",
          "type": "function"
        },
        "index": {
          "description": "This function computes the set of variables occurring in constant",
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "variables'",
          "normalized": "Const a-\u003eSet b",
          "package": "compdata",
          "signature": "Const f-\u003eSet v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#v:variables-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert variables to holes, except those that are bound.\n\u003c/p\u003e",
          "module": "Data.Comp.Variables",
          "name": "varsToHoles",
          "package": "compdata",
          "signature": "Term f -\u003e Context f v",
          "source": "src/Data-Comp-Variables.html#varsToHoles",
          "type": "function"
        },
        "index": {
          "description": "Convert variables to holes except those that are bound",
          "hierarchy": "Data Comp Variables",
          "module": "Data.Comp.Variables",
          "name": "varsToHoles",
          "normalized": "Term a-\u003eContext a b",
          "package": "compdata",
          "partial": "To Holes",
          "signature": "Term f-\u003eContext f v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp-Variables.html#v:varsToHoles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the infrastructure necessary to use\n \u003cem\u003eCompositional Data Types\u003c/em\u003e. Compositional Data Types is an extension of\n Wouter Swierstra's Functional Pearl: \u003cem\u003eData types a la carte\u003c/em\u003e. Examples of\n usage are bundled with the package in the library \u003ccode\u003eexamples/Examples\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Comp",
          "name": "Comp",
          "package": "compdata",
          "source": "src/Data-Comp.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the infrastructure necessary to use Compositional Data Types Compositional Data Types is an extension of Wouter Swierstra Functional Pearl Data types la carte Examples of usage are bundled with the package in the library examples Examples",
          "hierarchy": "Data Comp",
          "module": "Data.Comp",
          "name": "Comp",
          "package": "compdata",
          "partial": "Comp",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/compdata/docs/Data-Comp.html#"
      }
    }
  ]
]