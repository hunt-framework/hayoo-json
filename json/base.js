[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "base"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module describes a structure intermediate between a functor and\n a monad (technically, a strong lax monoidal functor).  Compared with\n monads, this interface lacks the full power of the binding operation\n \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e, but\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e it has more instances.\n\u003c/li\u003e\u003cli\u003e it is sufficient for many uses, e.g. context-free parsing, or the\n   \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e class.\n\u003c/li\u003e\u003cli\u003e instances can perform analysis of computations before they are\n   executed, and thus produce shared optimizations.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThis interface was introduced for parsers by Niklas R&#246;jemo, because\n it admits more sharing than the monadic interface.  The names here are\n mostly based on parsing work by Doaitse Swierstra.\n\u003c/p\u003e\u003cp\u003eFor more details, see \u003cem\u003eApplicative Programming with Effects\u003c/em\u003e,\n by Conor McBride and Ross Paterson, online at\n \u003ca\u003ehttp://www.soi.city.ac.uk/~ross/papers/Applicative.html\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Applicative",
          "name": "Applicative",
          "package": "base",
          "source": "src/Control-Applicative.html",
          "type": "module"
        },
        "index": {
          "description": "This module describes structure intermediate between functor and monad technically strong lax monoidal functor Compared with monads this interface lacks the full power of the binding operation but it has more instances it is sufficient for many uses e.g context-free parsing or the Traversable class instances can perform analysis of computations before they are executed and thus produce shared optimizations This interface was introduced for parsers by Niklas jemo because it admits more sharing than the monadic interface The names here are mostly based on parsing work by Doaitse Swierstra For more details see Applicative Programming with Effects by Conor McBride and Ross Paterson online at http www.soi.city.ac.uk ross papers Applicative.html",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "Applicative",
          "package": "base",
          "partial": "Applicative",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA monoid on applicative functors.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e\u003c|\u003e\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf defined, \u003ccode\u003e\u003ca\u003esome\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emany\u003c/a\u003e\u003c/code\u003e should be the least solutions\n of the equations:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003esome v = (:) \u003ccode\u003e\u003ca\u003e\u003c$\u003e\u003c/a\u003e\u003c/code\u003e v \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e many v\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003emany v = some v \u003ccode\u003e\u003ca\u003e\u003c|\u003e\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e []\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Applicative",
          "name": "Alternative",
          "package": "base",
          "source": "src/Control-Applicative.html#Alternative",
          "type": "class"
        },
        "index": {
          "description": "monoid on applicative functors Minimal complete definition empty and If defined some and many should be the least solutions of the equations some many many some pure",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "Alternative",
          "package": "base",
          "partial": "Alternative",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#t:Alternative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA functor with application, providing operations to\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e embed pure expressions (\u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e), and\n\u003c/li\u003e\u003cli\u003e sequence computations and combine their results (\u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eA minimal complete definition must include implementations of these\n functions satisfying the following laws:\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003cem\u003eidentity\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e v = v\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003ecomposition\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e (.) \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e u \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e v \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e w = u \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e (v \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e w)\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003ehomomorphism\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e x = \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e (f x)\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003einterchange\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003eu \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e y = \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e y) \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e u\u003c/code\u003e\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eThe other methods have the following default definitions, which may\n be overridden with equivalent specialized implementations:\n\u003c/p\u003e\u003cpre\u003e\n      u \u003ccode\u003e\u003ca\u003e*\u003e\u003c/a\u003e\u003c/code\u003e v = \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e) \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e u \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e v\n      u \u003ccode\u003e\u003ca\u003e\u003c*\u003c/a\u003e\u003c/code\u003e v = \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e u \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e v\n\u003c/pre\u003e\u003cp\u003eAs a consequence of these laws, the \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e instance for \u003ccode\u003ef\u003c/code\u003e will satisfy\n\u003c/p\u003e\u003cpre\u003e\n      \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e f x = \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e x\n\u003c/pre\u003e\u003cp\u003eIf \u003ccode\u003ef\u003c/code\u003e is also a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e, it should satisfy \u003ccode\u003e\u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and\n \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e) = \u003ccode\u003e\u003ca\u003eap\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e (which implies that \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e satisfy the\n applicative functor laws).\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "Applicative",
          "package": "base",
          "source": "src/Control-Applicative.html#Applicative",
          "type": "class"
        },
        "index": {
          "description": "functor with application providing operations to embed pure expressions pure and sequence computations and combine their results minimal complete definition must include implementations of these functions satisfying the following laws identity pure id composition pure homomorphism pure pure pure interchange pure pure The other methods have the following default definitions which may be overridden with equivalent specialized implementations pure const id pure const As consequence of these laws the Functor instance for will satisfy fmap pure If is also Monad it should satisfy pure return and ap which implies that pure and satisfy the applicative functor laws",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "Applicative",
          "package": "base",
          "partial": "Applicative",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#t:Applicative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative",
          "name": "Const",
          "package": "base",
          "source": "src/Control-Applicative.html#Const",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "Const",
          "package": "base",
          "partial": "Const",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#t:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative",
          "name": "WrappedArrow",
          "package": "base",
          "source": "src/Control-Applicative.html#WrappedArrow",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "WrappedArrow",
          "package": "base",
          "partial": "Wrapped Arrow",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#t:WrappedArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative",
          "name": "WrappedMonad",
          "package": "base",
          "source": "src/Control-Applicative.html#WrappedMonad",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "WrappedMonad",
          "package": "base",
          "partial": "Wrapped Monad",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#t:WrappedMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLists, but with an \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e functor based on zipping, so that\n\u003c/p\u003e\u003cpre\u003ef \u003ccode\u003e\u003ca\u003e\u003c$\u003e\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eZipList\u003c/a\u003e\u003c/code\u003e xs1 \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e ... \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eZipList\u003c/a\u003e\u003c/code\u003e xsn = \u003ccode\u003e\u003ca\u003eZipList\u003c/a\u003e\u003c/code\u003e (zipWithn f xs1 ... xsn)\u003c/pre\u003e",
          "module": "Control.Applicative",
          "name": "ZipList",
          "package": "base",
          "source": "src/Control-Applicative.html#ZipList",
          "type": "newtype"
        },
        "index": {
          "description": "Lists but with an Applicative functor based on zipping so that ZipList xs1 ZipList xsn ZipList zipWithn xs1 xsn",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "ZipList",
          "package": "base",
          "partial": "Zip List",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#t:ZipList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequence actions, discarding the value of the first argument.\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "(*\u003e)",
          "package": "base",
          "signature": "f a -\u003e f b -\u003e f b",
          "source": "src/Control-Applicative.html#%2A%3E",
          "type": "method"
        },
        "index": {
          "description": "Sequence actions discarding the value of the first argument",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "(*\u003e) *\u003e",
          "normalized": "a b-\u003ea c-\u003ea c",
          "package": "base",
          "signature": "f a-\u003ef b-\u003ef b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:-42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn associative binary operation\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "(\u003c|\u003e)",
          "package": "base",
          "signature": "f a -\u003e f a -\u003e f a",
          "source": "src/Control-Applicative.html#%3C%7C%3E",
          "type": "method"
        },
        "index": {
          "description": "An associative binary operation",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "(\u003c|\u003e) \u003c|\u003e",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "base",
          "signature": "f a-\u003ef a-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:-60--124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace all locations in the input with the same value.\n The default definition is \u003ccode\u003e\u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, but this may be\n overridden with a more efficient version.\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "(\u003c$)",
          "package": "base",
          "signature": "a -\u003e f b -\u003e f a",
          "source": "src/GHC-Base.html#%3C%24",
          "type": "function"
        },
        "index": {
          "description": "Replace all locations in the input with the same value The default definition is fmap const but this may be overridden with more efficient version",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "(\u003c$) \u003c$",
          "normalized": "a-\u003eb c-\u003eb a",
          "package": "base",
          "signature": "a-\u003ef b-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:-60--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn infix synonym for \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Applicative\",\"Data.Functor\"]",
          "name": "(\u003c$\u003e)",
          "package": "base",
          "signature": "(a -\u003e b) -\u003e f a -\u003e f b",
          "source": "src/Data-Functor.html#%3C%24%3E",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:-60--36--62-\",\"http://hackage.haskell.org/package/base/docs/Data-Functor.html#v:-60--36--62-\"]"
        },
        "index": {
          "description": "An infix synonym for fmap",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "(\u003c$\u003e) \u003c$\u003e",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "base",
          "signature": "(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:-60--36--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequence actions, discarding the value of the second argument.\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "(\u003c*)",
          "package": "base",
          "signature": "f a -\u003e f b -\u003e f a",
          "source": "src/Control-Applicative.html#%3C%2A",
          "type": "method"
        },
        "index": {
          "description": "Sequence actions discarding the value of the second argument",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "(\u003c*) \u003c*",
          "normalized": "a b-\u003ea c-\u003ea b",
          "package": "base",
          "signature": "f a-\u003ef b-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:-60--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e with the arguments reversed.\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "(\u003c**\u003e)",
          "package": "base",
          "signature": "f a -\u003e f (a -\u003e b) -\u003e f b",
          "source": "src/Control-Applicative.html#%3C%2A%2A%3E",
          "type": "function"
        },
        "index": {
          "description": "variant of with the arguments reversed",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "(\u003c**\u003e) \u003c**\u003e",
          "normalized": "a b-\u003ea(b-\u003ec)-\u003ea c",
          "package": "base",
          "signature": "f a-\u003ef(a-\u003eb)-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:-60--42--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequential application.\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "(\u003c*\u003e)",
          "package": "base",
          "signature": "f (a -\u003e b) -\u003e f a -\u003e f b",
          "source": "src/Control-Applicative.html#%3C%2A%3E",
          "type": "method"
        },
        "index": {
          "description": "Sequential application",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "(\u003c*\u003e) \u003c*\u003e",
          "normalized": "a(b-\u003ec)-\u003ea b-\u003ea c",
          "package": "base",
          "signature": "f(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:-60--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative",
          "name": "Const",
          "package": "base",
          "signature": "Const",
          "source": "src/Control-Applicative.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "Const",
          "package": "base",
          "partial": "Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative",
          "name": "WrapArrow",
          "package": "base",
          "signature": "WrapArrow",
          "source": "src/Control-Applicative.html#WrappedArrow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "WrapArrow",
          "package": "base",
          "partial": "Wrap Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:WrapArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative",
          "name": "WrapMonad",
          "package": "base",
          "signature": "WrapMonad",
          "source": "src/Control-Applicative.html#WrappedMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "WrapMonad",
          "package": "base",
          "partial": "Wrap Monad",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:WrapMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative",
          "name": "ZipList",
          "package": "base",
          "signature": "ZipList",
          "source": "src/Control-Applicative.html#ZipList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "ZipList",
          "package": "base",
          "partial": "Zip List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:ZipList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity of \u003ccode\u003e\u003ca\u003e\u003c|\u003e\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "empty",
          "package": "base",
          "signature": "f a",
          "source": "src/Control-Applicative.html#empty",
          "type": "method"
        },
        "index": {
          "description": "The identity of",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "empty",
          "package": "base",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative",
          "name": "getConst",
          "package": "base",
          "signature": "a",
          "source": "src/Control-Applicative.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "getConst",
          "package": "base",
          "partial": "Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:getConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative",
          "name": "getZipList",
          "package": "base",
          "signature": "[a]",
          "source": "src/Control-Applicative.html#ZipList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "getZipList",
          "normalized": "[a]",
          "package": "base",
          "partial": "Zip List",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:getZipList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a function to actions.\n This function may be used as a value for \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e in a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "liftA",
          "package": "base",
          "signature": "(a -\u003e b) -\u003e f a -\u003e f b",
          "source": "src/Control-Applicative.html#liftA",
          "type": "function"
        },
        "index": {
          "description": "Lift function to actions This function may be used as value for fmap in Functor instance",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "liftA",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "base",
          "signature": "(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:liftA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a binary function to actions.\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "liftA2",
          "package": "base",
          "signature": "(a -\u003e b -\u003e c) -\u003e f a -\u003e f b -\u003e f c",
          "source": "src/Control-Applicative.html#liftA2",
          "type": "function"
        },
        "index": {
          "description": "Lift binary function to actions",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "liftA2",
          "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
          "package": "base",
          "signature": "(a-\u003eb-\u003ec)-\u003ef a-\u003ef b-\u003ef c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:liftA2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a ternary function to actions.\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "liftA3",
          "package": "base",
          "signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e f a -\u003e f b -\u003e f c -\u003e f d",
          "source": "src/Control-Applicative.html#liftA3",
          "type": "function"
        },
        "index": {
          "description": "Lift ternary function to actions",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "liftA3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003ee a-\u003ee b-\u003ee c-\u003ee d",
          "package": "base",
          "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003ef a-\u003ef b-\u003ef c-\u003ef d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:liftA3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZero or more.\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "many",
          "package": "base",
          "signature": "f a -\u003e f [a]",
          "source": "src/Control-Applicative.html#many",
          "type": "method"
        },
        "index": {
          "description": "Zero or more",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "many",
          "normalized": "a b-\u003ea[b]",
          "package": "base",
          "signature": "f a-\u003ef[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:many"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne or none.\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "optional",
          "package": "base",
          "signature": "f a -\u003e f (Maybe a)",
          "source": "src/Control-Applicative.html#optional",
          "type": "function"
        },
        "index": {
          "description": "One or none",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "optional",
          "normalized": "a b-\u003ea(Maybe b)",
          "package": "base",
          "signature": "f a-\u003ef(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:optional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a value.\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "pure",
          "package": "base",
          "signature": "a -\u003e f a",
          "source": "src/Control-Applicative.html#pure",
          "type": "method"
        },
        "index": {
          "description": "Lift value",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "pure",
          "normalized": "a-\u003eb a",
          "package": "base",
          "signature": "a-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:pure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne or more.\n\u003c/p\u003e",
          "module": "Control.Applicative",
          "name": "some",
          "package": "base",
          "signature": "f a -\u003e f [a]",
          "source": "src/Control-Applicative.html#some",
          "type": "method"
        },
        "index": {
          "description": "One or more",
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "some",
          "normalized": "a b-\u003ea[b]",
          "package": "base",
          "signature": "f a-\u003ef[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:some"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative",
          "name": "unwrapArrow",
          "package": "base",
          "signature": "a b c",
          "source": "src/Control-Applicative.html#WrappedArrow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "unwrapArrow",
          "package": "base",
          "partial": "Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:unwrapArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Applicative",
          "name": "unwrapMonad",
          "package": "base",
          "signature": "m a",
          "source": "src/Control-Applicative.html#WrappedMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Applicative",
          "module": "Control.Applicative",
          "name": "unwrapMonad",
          "package": "base",
          "partial": "Monad",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:unwrapMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic arrow definitions, based on\n  * \u003cem\u003eGeneralising Monads to Arrows\u003c/em\u003e, by John Hughes,\n    \u003cem\u003eScience of Computer Programming\u003c/em\u003e 37, pp67-111, May 2000.\n plus a couple of definitions (\u003ccode\u003e\u003ca\u003ereturnA\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e) from\n  * \u003cem\u003eA New Notation for Arrows\u003c/em\u003e, by Ross Paterson, in \u003cem\u003eICFP 2001\u003c/em\u003e,\n    Firenze, Italy, pp229-240.\n These papers and more information on arrows can be found at\n \u003ca\u003ehttp://www.haskell.org/arrows/\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow",
          "name": "Arrow",
          "package": "base",
          "source": "src/Control-Arrow.html",
          "type": "module"
        },
        "index": {
          "description": "Basic arrow definitions based on Generalising Monads to Arrows by John Hughes Science of Computer Programming pp67-111 May plus couple of definitions returnA and loop from New Notation for Arrows by Ross Paterson in ICFP Firenze Italy pp229-240 These papers and more information on arrows can be found at http www.haskell.org arrows",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "Arrow",
          "package": "base",
          "partial": "Arrow",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe basic arrow class.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e, satisfying the laws\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e id = \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (f \u003e\u003e\u003e g) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e g\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e f) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f)\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e (f \u003e\u003e\u003e g) = \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e g\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e \u003e\u003e\u003e f\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e *** g) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e *** g) \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f) \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eassoc\u003c/code\u003e = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eassoc\u003c/code\u003e \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003ewhere\n\u003c/p\u003e\u003cpre\u003e assoc ((a,b),c) = (a,(b,c))\n\u003c/pre\u003e\u003cp\u003eThe other combinators have sensible default definitions,\n which may be overridden for efficiency.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "Arrow",
          "package": "base",
          "source": "src/Control-Arrow.html#Arrow",
          "type": "class"
        },
        "index": {
          "description": "The basic arrow class Minimal complete definition arr and first satisfying the laws arr id id arr arr arr first arr arr first first first first first arr fst arr fst first arr id arr id first first first arr assoc arr assoc first where assoc The other combinators have sensible default definitions which may be overridden for efficiency",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "Arrow",
          "package": "base",
          "partial": "Arrow",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:Arrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome arrows allow application of arrow inputs to other inputs.\n Instances should satisfy the following laws:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\\x -\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\\y -\u003e (x,y)))) \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003eapp\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (g \u003e\u003e\u003e)) \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003eapp\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e g \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003eapp\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003e\u003e\u003e h)) \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003eapp\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eapp\u003c/a\u003e\u003c/code\u003e \u003e\u003e\u003e h\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSuch arrows are equivalent to monads (see \u003ccode\u003e\u003ca\u003eArrowMonad\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "ArrowApply",
          "package": "base",
          "source": "src/Control-Arrow.html#ArrowApply",
          "type": "class"
        },
        "index": {
          "description": "Some arrows allow application of arrow inputs to other inputs Instances should satisfy the following laws first arr arr app id first arr app second app first arr app app Such arrows are equivalent to monads see ArrowMonad",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "ArrowApply",
          "package": "base",
          "partial": "Arrow Apply",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:ArrowApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChoice, for arrows that support it.  This class underlies the\n \u003ccode\u003eif\u003c/code\u003e and \u003ccode\u003ecase\u003c/code\u003e constructs in arrow notation.\n Minimal complete definition: \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e, satisfying the laws\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e f) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e f)\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e (f \u003e\u003e\u003e g) = \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e g\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003ef \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e +++ g) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e +++ g) \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e f) \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eassocsum\u003c/code\u003e = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eassocsum\u003c/code\u003e \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003ewhere\n\u003c/p\u003e\u003cpre\u003e assocsum (Left (Left x)) = Left x\n assocsum (Left (Right y)) = Right (Left y)\n assocsum (Right z) = Right (Right z)\n\u003c/pre\u003e\u003cp\u003eThe other combinators have sensible default definitions, which may\n be overridden for efficiency.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "ArrowChoice",
          "package": "base",
          "source": "src/Control-Arrow.html#ArrowChoice",
          "type": "class"
        },
        "index": {
          "description": "Choice for arrows that support it This class underlies the if and case constructs in arrow notation Minimal complete definition left satisfying the laws left arr arr left left left left arr Left arr Left left left arr id arr id left left left arr assocsum arr assocsum left where assocsum Left Left Left assocsum Left Right Right Left assocsum Right Right Right The other combinators have sensible default definitions which may be overridden for efficiency",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "ArrowChoice",
          "package": "base",
          "partial": "Arrow Choice",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:ArrowChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e operator expresses computations in which an output value\n is fed back as input, although the computation occurs only once.\n It underlies the \u003ccode\u003erec\u003c/code\u003e value recursion construct in arrow notation.\n \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e should satisfy the following laws:\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003cem\u003eextension\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e f) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\\ b -\u003e \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efix\u003c/a\u003e\u003c/code\u003e (\\ (c,d) -\u003e f (b,d))))\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003eleft tightening\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e h \u003e\u003e\u003e f) = h \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003eright tightening\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e h) = \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e h\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003esliding\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e *** k)) = \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e *** k) \u003e\u003e\u003e f)\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003evanishing\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e f) = \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e unassoc \u003e\u003e\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e assoc)\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003esuperposing\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e f) = \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e assoc \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e unassoc)\u003c/code\u003e\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003ewhere\n\u003c/p\u003e\u003cpre\u003e assoc ((a,b),c) = (a,(b,c))\n unassoc (a,(b,c)) = ((a,b),c)\n\u003c/pre\u003e",
          "module": "Control.Arrow",
          "name": "ArrowLoop",
          "package": "base",
          "source": "src/Control-Arrow.html#ArrowLoop",
          "type": "class"
        },
        "index": {
          "description": "The loop operator expresses computations in which an output value is fed back as input although the computation occurs only once It underlies the rec value recursion construct in arrow notation loop should satisfy the following laws extension loop arr arr fst fix left tightening loop first loop right tightening loop first loop sliding loop arr id loop arr id vanishing loop loop loop arr unassoc arr assoc superposing second loop loop arr assoc second arr unassoc where assoc unassoc",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "ArrowLoop",
          "package": "base",
          "partial": "Arrow Loop",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:ArrowLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eArrowApply\u003c/a\u003e\u003c/code\u003e class is equivalent to \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e: any monad gives rise\n   to a \u003ccode\u003e\u003ca\u003eKleisli\u003c/a\u003e\u003c/code\u003e arrow, and any instance of \u003ccode\u003e\u003ca\u003eArrowApply\u003c/a\u003e\u003c/code\u003e defines a monad.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "ArrowMonad",
          "package": "base",
          "source": "src/Control-Arrow.html#ArrowMonad",
          "type": "newtype"
        },
        "index": {
          "description": "The ArrowApply class is equivalent to Monad any monad gives rise to Kleisli arrow and any instance of ArrowApply defines monad",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "ArrowMonad",
          "package": "base",
          "partial": "Arrow Monad",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:ArrowMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA monoid on arrows.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "ArrowPlus",
          "package": "base",
          "source": "src/Control-Arrow.html#ArrowPlus",
          "type": "class"
        },
        "index": {
          "description": "monoid on arrows",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "ArrowPlus",
          "package": "base",
          "partial": "Arrow Plus",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:ArrowPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow",
          "name": "ArrowZero",
          "package": "base",
          "source": "src/Control-Arrow.html#ArrowZero",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "ArrowZero",
          "package": "base",
          "partial": "Arrow Zero",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:ArrowZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKleisli arrows of a monad.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "Kleisli",
          "package": "base",
          "source": "src/Control-Arrow.html#Kleisli",
          "type": "newtype"
        },
        "index": {
          "description": "Kleisli arrows of monad",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "Kleisli",
          "package": "base",
          "partial": "Kleisli",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:Kleisli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFanin: Split the input between the two argument arrows and\n   merge their outputs.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "(|||)",
          "package": "base",
          "signature": "a b d -\u003e a c d -\u003e a (Either b c) d",
          "source": "src/Control-Arrow.html#%7C%7C%7C",
          "type": "method"
        },
        "index": {
          "description": "Fanin Split the input between the two argument arrows and merge their outputs The default definition may be overridden with more efficient version if desired",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "(|||) |||",
          "normalized": "a b c-\u003ea d c-\u003ea(Either b d)c",
          "package": "base",
          "signature": "a b d-\u003ea c d-\u003ea(Either b c)d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-124--124--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFanout: send the input to both argument arrows and combine\n   their output.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "(&&&)",
          "package": "base",
          "signature": "a b c -\u003e a b c' -\u003e a b (c, c')",
          "source": "src/Control-Arrow.html#%26%26%26",
          "type": "method"
        },
        "index": {
          "description": "Fanout send the input to both argument arrows and combine their output The default definition may be overridden with more efficient version if desired",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "(&&&) &&&",
          "normalized": "a b c-\u003ea b d-\u003ea b(c,d)",
          "package": "base",
          "signature": "a b c-\u003ea b c'-\u003ea b(c,c')",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-38--38--38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit the input between the two argument arrows and combine\n   their output.  Note that this is in general not a functor.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "(***)",
          "package": "base",
          "signature": "a b c -\u003e a b' c' -\u003e a (b, b') (c, c')",
          "source": "src/Control-Arrow.html#%2A%2A%2A",
          "type": "method"
        },
        "index": {
          "description": "Split the input between the two argument arrows and combine their output Note that this is in general not functor The default definition may be overridden with more efficient version if desired",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "(***) ***",
          "normalized": "a b c-\u003ea d e-\u003ea(b,d)(c,e)",
          "package": "base",
          "signature": "a b c-\u003ea b' c'-\u003ea(b,b')(c,c')",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-42--42--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit the input between the two argument arrows, retagging\n   and merging their outputs.\n   Note that this is in general not a functor.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "(+++)",
          "package": "base",
          "signature": "a b c -\u003e a b' c' -\u003e a (Either b b') (Either c c')",
          "source": "src/Control-Arrow.html#%2B%2B%2B",
          "type": "method"
        },
        "index": {
          "description": "Split the input between the two argument arrows retagging and merging their outputs Note that this is in general not functor The default definition may be overridden with more efficient version if desired",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "(+++) +++",
          "normalized": "a b c-\u003ea d e-\u003ea(Either b d)(Either c e)",
          "package": "base",
          "signature": "a b c-\u003ea b' c'-\u003ea(Either b b')(Either c c')",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-43--43--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn associative operation with identity \u003ccode\u003e\u003ca\u003ezeroArrow\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "(\u003c+\u003e)",
          "package": "base",
          "signature": "a b c -\u003e a b c -\u003e a b c",
          "source": "src/Control-Arrow.html#%3C%2B%3E",
          "type": "method"
        },
        "index": {
          "description": "An associative operation with identity zeroArrow",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "a b c-\u003ea b c-\u003ea b c",
          "package": "base",
          "signature": "a b c-\u003ea b c-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight-to-left composition\n\u003c/p\u003e",
          "module": "[\"Control.Arrow\",\"Control.Category\"]",
          "name": "(\u003c\u003c\u003c)",
          "package": "base",
          "signature": "cat b c -\u003e cat a b -\u003e cat a c",
          "source": "src/Control-Category.html#%3C%3C%3C",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-60--60--60-\",\"http://hackage.haskell.org/package/base/docs/Control-Category.html#v:-60--60--60-\"]"
        },
        "index": {
          "description": "Right-to-left composition",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "(\u003c\u003c\u003c) \u003c\u003c\u003c",
          "normalized": "a b c-\u003ea d b-\u003ea d c",
          "package": "base",
          "signature": "cat b c-\u003ecat a b-\u003ecat a c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-60--60--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrecomposition with a pure function (right-to-left variant).\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "(\u003c\u003c^)",
          "package": "base",
          "signature": "a c d -\u003e (b -\u003e c) -\u003e a b d",
          "source": "src/Control-Arrow.html#%3C%3C%5E",
          "type": "function"
        },
        "index": {
          "description": "Precomposition with pure function right-to-left variant",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "(\u003c\u003c^) \u003c\u003c^",
          "normalized": "a b c-\u003e(d-\u003eb)-\u003ea d c",
          "package": "base",
          "signature": "a c d-\u003e(b-\u003ec)-\u003ea b d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-60--60--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft-to-right composition\n\u003c/p\u003e",
          "module": "[\"Control.Arrow\",\"Control.Category\"]",
          "name": "(\u003e\u003e\u003e)",
          "package": "base",
          "signature": "cat a b -\u003e cat b c -\u003e cat a c",
          "source": "src/Control-Category.html#%3E%3E%3E",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-62--62--62-\",\"http://hackage.haskell.org/package/base/docs/Control-Category.html#v:-62--62--62-\"]"
        },
        "index": {
          "description": "Left-to-right composition",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "(\u003e\u003e\u003e) \u003e\u003e\u003e",
          "normalized": "a b c-\u003ea c d-\u003ea b d",
          "package": "base",
          "signature": "cat a b-\u003ecat b c-\u003ecat a c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-62--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePostcomposition with a pure function.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "(\u003e\u003e^)",
          "package": "base",
          "signature": "a b c -\u003e (c -\u003e d) -\u003e a b d",
          "source": "src/Control-Arrow.html#%3E%3E%5E",
          "type": "function"
        },
        "index": {
          "description": "Postcomposition with pure function",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "(\u003e\u003e^) \u003e\u003e^",
          "normalized": "a b c-\u003e(c-\u003ed)-\u003ea b d",
          "package": "base",
          "signature": "a b c-\u003e(c-\u003ed)-\u003ea b d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-62--62--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePostcomposition with a pure function (right-to-left variant).\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "(^\u003c\u003c)",
          "package": "base",
          "signature": "(c -\u003e d) -\u003e a b c -\u003e a b d",
          "source": "src/Control-Arrow.html#%5E%3C%3C",
          "type": "function"
        },
        "index": {
          "description": "Postcomposition with pure function right-to-left variant",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "(^\u003c\u003c) ^\u003c\u003c",
          "normalized": "(a-\u003eb)-\u003ec d a-\u003ec d b",
          "package": "base",
          "signature": "(c-\u003ed)-\u003ea b c-\u003ea b d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-94--60--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrecomposition with a pure function.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "(^\u003e\u003e)",
          "package": "base",
          "signature": "(b -\u003e c) -\u003e a c d -\u003e a b d",
          "source": "src/Control-Arrow.html#%5E%3E%3E",
          "type": "function"
        },
        "index": {
          "description": "Precomposition with pure function",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "(^\u003e\u003e) ^\u003e\u003e",
          "normalized": "(a-\u003eb)-\u003ec b d-\u003ec a d",
          "package": "base",
          "signature": "(b-\u003ec)-\u003ea c d-\u003ea b d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-94--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow",
          "name": "ArrowMonad",
          "package": "base",
          "signature": "ArrowMonad (a () b)",
          "source": "src/Control-Arrow.html#ArrowMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "ArrowMonad",
          "normalized": "ArrowMonad(a()b)",
          "package": "base",
          "partial": "Arrow Monad",
          "signature": "ArrowMonad(a()b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:ArrowMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow",
          "name": "Kleisli",
          "package": "base",
          "signature": "Kleisli",
          "source": "src/Control-Arrow.html#Kleisli",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "Kleisli",
          "package": "base",
          "partial": "Kleisli",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:Kleisli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow",
          "name": "app",
          "package": "base",
          "signature": "a (a b c, b) c",
          "source": "src/Control-Arrow.html#app",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "app",
          "normalized": "a(a b c,b)c",
          "package": "base",
          "signature": "a(a b c,b)c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a function to an arrow.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "arr",
          "package": "base",
          "signature": "(b -\u003e c) -\u003e a b c",
          "source": "src/Control-Arrow.html#arr",
          "type": "method"
        },
        "index": {
          "description": "Lift function to an arrow",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "arr",
          "normalized": "(a-\u003eb)-\u003ec a b",
          "package": "base",
          "signature": "(b-\u003ec)-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:arr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend the first component of the input through the argument\n   arrow, and copy the rest unchanged to the output.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "first",
          "package": "base",
          "signature": "a b c -\u003e a (b, d) (c, d)",
          "source": "src/Control-Arrow.html#first",
          "type": "method"
        },
        "index": {
          "description": "Send the first component of the input through the argument arrow and copy the rest unchanged to the output",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "first",
          "normalized": "a b c-\u003ea(b,d)(c,d)",
          "package": "base",
          "signature": "a b c-\u003ea(b,d)(c,d)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:first"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFeed marked inputs through the argument arrow, passing the\n   rest through unchanged to the output.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "left",
          "package": "base",
          "signature": "a b c -\u003e a (Either b d) (Either c d)",
          "source": "src/Control-Arrow.html#left",
          "type": "method"
        },
        "index": {
          "description": "Feed marked inputs through the argument arrow passing the rest through unchanged to the output",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "left",
          "normalized": "a b c-\u003ea(Either b d)(Either c d)",
          "package": "base",
          "signature": "a b c-\u003ea(Either b d)(Either c d)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAny instance of \u003ccode\u003e\u003ca\u003eArrowApply\u003c/a\u003e\u003c/code\u003e can be made into an instance of\n   \u003ccode\u003e\u003ca\u003eArrowChoice\u003c/a\u003e\u003c/code\u003e by defining \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eleftApp\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "leftApp",
          "package": "base",
          "signature": "a b c -\u003e a (Either b d) (Either c d)",
          "source": "src/Control-Arrow.html#leftApp",
          "type": "function"
        },
        "index": {
          "description": "Any instance of ArrowApply can be made into an instance of ArrowChoice by defining left leftApp",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "leftApp",
          "normalized": "a b c-\u003ea(Either b d)(Either c d)",
          "package": "base",
          "partial": "App",
          "signature": "a b c-\u003ea(Either b d)(Either c d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:leftApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow",
          "name": "loop",
          "package": "base",
          "signature": "a (b, d) (c, d) -\u003e a b c",
          "source": "src/Control-Arrow.html#loop",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "loop",
          "normalized": "a(b,c)(d,c)-\u003ea b d",
          "package": "base",
          "signature": "a(b,d)(c,d)-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:loop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity arrow, which plays the role of \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e in arrow notation.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "returnA",
          "package": "base",
          "signature": "a b b",
          "source": "src/Control-Arrow.html#returnA",
          "type": "function"
        },
        "index": {
          "description": "The identity arrow which plays the role of return in arrow notation",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "returnA",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:returnA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA mirror image of \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "right",
          "package": "base",
          "signature": "a b c -\u003e a (Either d b) (Either d c)",
          "source": "src/Control-Arrow.html#right",
          "type": "method"
        },
        "index": {
          "description": "mirror image of left The default definition may be overridden with more efficient version if desired",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "right",
          "normalized": "a b c-\u003ea(Either d b)(Either d c)",
          "package": "base",
          "signature": "a b c-\u003ea(Either d b)(Either d c)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow",
          "name": "runKleisli",
          "package": "base",
          "signature": "a -\u003e m b",
          "source": "src/Control-Arrow.html#Kleisli",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "runKleisli",
          "normalized": "a-\u003eb c",
          "package": "base",
          "partial": "Kleisli",
          "signature": "a-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:runKleisli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA mirror image of \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
          "module": "Control.Arrow",
          "name": "second",
          "package": "base",
          "signature": "a b c -\u003e a (d, b) (d, c)",
          "source": "src/Control-Arrow.html#second",
          "type": "method"
        },
        "index": {
          "description": "mirror image of first The default definition may be overridden with more efficient version if desired",
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "second",
          "normalized": "a b c-\u003ea(d,b)(d,c)",
          "package": "base",
          "signature": "a b c-\u003ea(d,b)(d,c)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:second"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow",
          "name": "zeroArrow",
          "package": "base",
          "signature": "a b c",
          "source": "src/Control-Arrow.html#zeroArrow",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow",
          "module": "Control.Arrow",
          "name": "zeroArrow",
          "package": "base",
          "partial": "Arrow",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:zeroArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Category",
          "name": "Category",
          "package": "base",
          "source": "src/Control-Category.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Category",
          "module": "Control.Category",
          "name": "Category",
          "package": "base",
          "partial": "Category",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Category.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class for categories.\n   id and (.) must form a monoid.\n\u003c/p\u003e",
          "module": "Control.Category",
          "name": "Category",
          "package": "base",
          "source": "src/Control-Category.html#Category",
          "type": "class"
        },
        "index": {
          "description": "class for categories id and must form monoid",
          "hierarchy": "Control Category",
          "module": "Control.Category",
          "name": "Category",
          "package": "base",
          "partial": "Category",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Category.html#t:Category"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emorphism composition\n\u003c/p\u003e",
          "module": "Control.Category",
          "name": "(.)",
          "package": "base",
          "signature": "cat b c -\u003e cat a b -\u003e cat a c",
          "source": "src/Control-Category.html#.",
          "type": "method"
        },
        "index": {
          "description": "morphism composition",
          "hierarchy": "Control Category",
          "module": "Control.Category",
          "name": "(.) .",
          "normalized": "a b c-\u003ea d b-\u003ea d c",
          "package": "base",
          "signature": "cat b c-\u003ecat a b-\u003ecat a c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Category.html#v:."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe identity morphism\n\u003c/p\u003e",
          "module": "Control.Category",
          "name": "id",
          "package": "base",
          "signature": "cat a a",
          "source": "src/Control-Category.html#id",
          "type": "method"
        },
        "index": {
          "description": "the identity morphism",
          "hierarchy": "Control Category",
          "module": "Control.Category",
          "name": "id",
          "package": "base",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Category.html#v:id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnbounded channels.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Concurrent.Chan",
          "name": "Chan",
          "package": "base",
          "source": "src/Control-Concurrent-Chan.html",
          "type": "module"
        },
        "index": {
          "description": "Unbounded channels",
          "hierarchy": "Control Concurrent Chan",
          "module": "Control.Concurrent.Chan",
          "name": "Chan",
          "package": "base",
          "partial": "Chan",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-Chan.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e is an abstract type representing an unbounded FIFO channel.\n\u003c/p\u003e",
          "module": "Control.Concurrent.Chan",
          "name": "Chan",
          "package": "base",
          "source": "src/Control-Concurrent-Chan.html#Chan",
          "type": "data"
        },
        "index": {
          "description": "Chan is an abstract type representing an unbounded FIFO channel",
          "hierarchy": "Control Concurrent Chan",
          "module": "Control.Concurrent.Chan",
          "name": "Chan",
          "package": "base",
          "partial": "Chan",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-Chan.html#t:Chan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDuplicate a \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e: the duplicate channel begins empty, but data written to\n either channel from then on will be available from both.  Hence this creates\n a kind of broadcast channel, where data written by anyone is seen by\n everyone else.\n\u003c/p\u003e\u003cp\u003e(Note that a duplicated channel is not equal to its original.\n So: \u003ccode\u003efmap (c /=) $ dupChan c\u003c/code\u003e returns \u003ccode\u003eTrue\u003c/code\u003e for all \u003ccode\u003ec\u003c/code\u003e.)\n\u003c/p\u003e",
          "module": "Control.Concurrent.Chan",
          "name": "dupChan",
          "package": "base",
          "signature": "Chan a -\u003e IO (Chan a)",
          "source": "src/Control-Concurrent-Chan.html#dupChan",
          "type": "function"
        },
        "index": {
          "description": "Duplicate Chan the duplicate channel begins empty but data written to either channel from then on will be available from both Hence this creates kind of broadcast channel where data written by anyone is seen by everyone else Note that duplicated channel is not equal to its original So fmap dupChan returns True for all",
          "hierarchy": "Control Concurrent Chan",
          "module": "Control.Concurrent.Chan",
          "name": "dupChan",
          "normalized": "Chan a-\u003eIO(Chan a)",
          "package": "base",
          "partial": "Chan",
          "signature": "Chan a-\u003eIO(Chan a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-Chan.html#v:dupChan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a lazy list representing the contents of the supplied\n \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e, much like \u003ccode\u003e\u003ca\u003ehGetContents\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent.Chan",
          "name": "getChanContents",
          "package": "base",
          "signature": "Chan a -\u003e IO [a]",
          "source": "src/Control-Concurrent-Chan.html#getChanContents",
          "type": "function"
        },
        "index": {
          "description": "Return lazy list representing the contents of the supplied Chan much like hGetContents",
          "hierarchy": "Control Concurrent Chan",
          "module": "Control.Concurrent.Chan",
          "name": "getChanContents",
          "normalized": "Chan a-\u003eIO[a]",
          "package": "base",
          "partial": "Chan Contents",
          "signature": "Chan a-\u003eIO[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-Chan.html#v:getChanContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: if you need this operation, use Control.Concurrent.STM.TChan instead.  See http:\u003cem/\u003ehackage.haskell.org\u003cem\u003etrac\u003c/em\u003eghc\u003cem\u003eticket\u003c/em\u003e4154 for details\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the supplied \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e is empty.\n\u003c/p\u003e",
          "module": "Control.Concurrent.Chan",
          "name": "isEmptyChan",
          "package": "base",
          "signature": "Chan a -\u003e IO Bool",
          "source": "src/Control-Concurrent-Chan.html#isEmptyChan",
          "type": "function"
        },
        "index": {
          "description": "Deprecated if you need this operation use Control.Concurrent.STM.TChan instead See http hackage.haskell.org trac ghc ticket for details Returns True if the supplied Chan is empty",
          "hierarchy": "Control Concurrent Chan",
          "module": "Control.Concurrent.Chan",
          "name": "isEmptyChan",
          "normalized": "Chan a-\u003eIO Bool",
          "package": "base",
          "partial": "Empty Chan",
          "signature": "Chan a-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-Chan.html#v:isEmptyChan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild and returns a new instance of \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent.Chan",
          "name": "newChan",
          "package": "base",
          "signature": "IO (Chan a)",
          "source": "src/Control-Concurrent-Chan.html#newChan",
          "type": "function"
        },
        "index": {
          "description": "Build and returns new instance of Chan",
          "hierarchy": "Control Concurrent Chan",
          "module": "Control.Concurrent.Chan",
          "name": "newChan",
          "package": "base",
          "partial": "Chan",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-Chan.html#v:newChan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the next value from the \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent.Chan",
          "name": "readChan",
          "package": "base",
          "signature": "Chan a -\u003e IO a",
          "source": "src/Control-Concurrent-Chan.html#readChan",
          "type": "function"
        },
        "index": {
          "description": "Read the next value from the Chan",
          "hierarchy": "Control Concurrent Chan",
          "module": "Control.Concurrent.Chan",
          "name": "readChan",
          "normalized": "Chan a-\u003eIO a",
          "package": "base",
          "partial": "Chan",
          "signature": "Chan a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-Chan.html#v:readChan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: if you need this operation, use Control.Concurrent.STM.TChan instead.  See http:\u003cem/\u003ehackage.haskell.org\u003cem\u003etrac\u003c/em\u003eghc\u003cem\u003eticket\u003c/em\u003e4154 for details\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003ePut a data item back onto a channel, where it will be the next item read.\n\u003c/p\u003e",
          "module": "Control.Concurrent.Chan",
          "name": "unGetChan",
          "package": "base",
          "signature": "Chan a -\u003e a -\u003e IO ()",
          "source": "src/Control-Concurrent-Chan.html#unGetChan",
          "type": "function"
        },
        "index": {
          "description": "Deprecated if you need this operation use Control.Concurrent.STM.TChan instead See http hackage.haskell.org trac ghc ticket for details Put data item back onto channel where it will be the next item read",
          "hierarchy": "Control Concurrent Chan",
          "module": "Control.Concurrent.Chan",
          "name": "unGetChan",
          "normalized": "Chan a-\u003ea-\u003eIO()",
          "package": "base",
          "partial": "Get Chan",
          "signature": "Chan a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-Chan.html#v:unGetChan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a value to a \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent.Chan",
          "name": "writeChan",
          "package": "base",
          "signature": "Chan a -\u003e a -\u003e IO ()",
          "source": "src/Control-Concurrent-Chan.html#writeChan",
          "type": "function"
        },
        "index": {
          "description": "Write value to Chan",
          "hierarchy": "Control Concurrent Chan",
          "module": "Control.Concurrent.Chan",
          "name": "writeChan",
          "normalized": "Chan a-\u003ea-\u003eIO()",
          "package": "base",
          "partial": "Chan",
          "signature": "Chan a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-Chan.html#v:writeChan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite an entire list of items to a \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent.Chan",
          "name": "writeList2Chan",
          "package": "base",
          "signature": "Chan a -\u003e [a] -\u003e IO ()",
          "source": "src/Control-Concurrent-Chan.html#writeList2Chan",
          "type": "function"
        },
        "index": {
          "description": "Write an entire list of items to Chan",
          "hierarchy": "Control Concurrent Chan",
          "module": "Control.Concurrent.Chan",
          "name": "writeList2Chan",
          "normalized": "Chan a-\u003e[a]-\u003eIO()",
          "package": "base",
          "partial": "List Chan",
          "signature": "Chan a-\u003e[a]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-Chan.html#v:writeList2Chan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e t\u003c/code\u003e is mutable location that is either empty or contains a\n value of type \u003ccode\u003et\u003c/code\u003e.  It has two fundamental operations: \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e\n which fills an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e if it is empty and blocks otherwise, and\n \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e which empties an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e if it is full and blocks\n otherwise.  They can be used in multiple different ways:\n\u003c/p\u003e\u003col\u003e\u003cli\u003e As synchronized mutable variables,\n  2. As channels, with \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e as receive and send, and\n  3. As a binary semaphore \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e ()\u003c/code\u003e, with \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e as\n     wait and signal.\n\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eThey were introduced in the paper \u003ca\u003eConcurrent Haskell\u003c/a\u003e by Simon\n Peyton Jones, Andrew Gordon and Sigbjorn Finne, though some details\n of their implementation have since then changed (in particular, a\n put on a full MVar used to error, but now merely blocks.)\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Applicability\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003es offer more flexibility than \u003ccode\u003eIORef\u003c/code\u003es, but less flexibility\n than \u003ccode\u003eSTM\u003c/code\u003e.  They are appropriate for building synchronization\n primitives and performing simple interthread communication; however\n they are very simple and susceptible to race conditions, deadlocks or\n uncaught exceptions.  Do not use them if you need perform larger\n atomic operations such as reading from multiple variables: use \u003ccode\u003eSTM\u003c/code\u003e\n instead.\n\u003c/p\u003e\u003cp\u003eIn particular, the \u003ca\u003ebigger\u003c/a\u003e functions in this module (\u003ccode\u003e\u003ca\u003ereadMVar\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eswapMVar\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ewithMVar\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003emodifyMVar_\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emodifyMVar\u003c/a\u003e\u003c/code\u003e) are simply\n the composition of a \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e followed by a \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e with\n exception safety.\n These only have atomicity guarantees if all other threads\n perform a \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e before a \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e as well;  otherwise, they may\n block.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Fairness\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNo thread can be blocked indefinitely on an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e unless another\n thread holds that \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e indefinitely.  One usual implementation of\n this fairness guarantee is that threads blocked on an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e are\n served in a first-in-first-out fashion, but this is not guaranteed\n in the semantics.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Gotchas\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eLike many other Haskell data structures, \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003es are lazy.  This\n means that if you place an expensive unevaluated thunk inside an\n \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e, it will be evaluated by the thread that consumes it, not the\n thread that produced it.  Be sure to \u003ccode\u003e\u003ca\u003eevaluate\u003c/a\u003e\u003c/code\u003e values to be placed\n in an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e to the appropriate normal form, or utilize a strict\n MVar provided by the strict-concurrency package.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Ordering\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e operations are always observed to take place in the order\n they are written in the program, regardless of the memory model of\n the underlying machine.  This is in contrast to \u003ccode\u003eIORef\u003c/code\u003e operations\n which may appear out-of-order to another thread in some cases.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Example\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eConsider the following concurrent data structure, a skip channel.\n This is a channel for an intermittent source of high bandwidth\n information (for example, mouse movement events.)  Writing to the\n channel never blocks, and reading from the channel only returns the\n most recent value, or blocks if there are no new values.  Multiple\n readers are supported with a \u003ccode\u003edupSkipChan\u003c/code\u003e operation.\n\u003c/p\u003e\u003cp\u003eA skip channel is a pair of \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003es. The first \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e contains the\n current value, and a list of semaphores that need to be notified\n when it changes. The second \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e is a semaphore for this particular\n reader: it is full if there is a value in the channel that this\n reader has not read yet, and empty otherwise.\n\u003c/p\u003e\u003cpre\u003e\n     data SkipChan a = SkipChan (MVar (a, [MVar ()])) (MVar ())\n\nnewSkipChan :: IO (SkipChan a)\n     newSkipChan = do\n         sem \u003c- newEmptyMVar\n         main \u003c- newMVar (undefined, [sem])\n         return (SkipChan main sem)\n\nputSkipChan :: SkipChan a -\u003e a -\u003e IO ()\n     putSkipChan (SkipChan main _) v = do\n         (_, sems) \u003c- takeMVar main\n         putMVar main (v, [])\n         mapM_ (sem -\u003e putMVar sem ()) sems\n\ngetSkipChan :: SkipChan a -\u003e IO a\n     getSkipChan (SkipChan main sem) = do\n         takeMVar sem\n         (v, sems) \u003c- takeMVar main\n         putMVar main (v, sem:sems)\n         return v\n\ndupSkipChan :: SkipChan a -\u003e IO (SkipChan a)\n     dupSkipChan (SkipChan main _) = do\n         sem \u003c- newEmptyMVar\n         (v, sems) \u003c- takeMVar main\n         putMVar main (v, sem:sems)\n         return (SkipChan main sem)\n\u003c/pre\u003e\u003cp\u003eThis example was adapted from the original Concurrent Haskell paper.\n For more examples of \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003es being used to build higher-level\n synchronization primitives, see \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eQSem\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "MVar",
          "package": "base",
          "source": "src/Control-Concurrent-MVar.html",
          "type": "module"
        },
        "index": {
          "description": "An MVar is mutable location that is either empty or contains value of type It has two fundamental operations putMVar which fills an MVar if it is empty and blocks otherwise and takeMVar which empties an MVar if it is full and blocks otherwise They can be used in multiple different ways As synchronized mutable variables As channels with takeMVar and putMVar as receive and send and As binary semaphore MVar with takeMVar and putMVar as wait and signal They were introduced in the paper Concurrent Haskell by Simon Peyton Jones Andrew Gordon and Sigbjorn Finne though some details of their implementation have since then changed in particular put on full MVar used to error but now merely blocks Applicability MVar offer more flexibility than IORef but less flexibility than STM They are appropriate for building synchronization primitives and performing simple interthread communication however they are very simple and susceptible to race conditions deadlocks or uncaught exceptions Do not use them if you need perform larger atomic operations such as reading from multiple variables use STM instead In particular the bigger functions in this module readMVar swapMVar withMVar modifyMVar and modifyMVar are simply the composition of takeMVar followed by putMVar with exception safety These only have atomicity guarantees if all other threads perform takeMVar before putMVar as well otherwise they may block Fairness No thread can be blocked indefinitely on an MVar unless another thread holds that MVar indefinitely One usual implementation of this fairness guarantee is that threads blocked on an MVar are served in first-in-first-out fashion but this is not guaranteed in the semantics Gotchas Like many other Haskell data structures MVar are lazy This means that if you place an expensive unevaluated thunk inside an MVar it will be evaluated by the thread that consumes it not the thread that produced it Be sure to evaluate values to be placed in an MVar to the appropriate normal form or utilize strict MVar provided by the strict-concurrency package Ordering MVar operations are always observed to take place in the order they are written in the program regardless of the memory model of the underlying machine This is in contrast to IORef operations which may appear out-of-order to another thread in some cases Example Consider the following concurrent data structure skip channel This is channel for an intermittent source of high bandwidth information for example mouse movement events Writing to the channel never blocks and reading from the channel only returns the most recent value or blocks if there are no new values Multiple readers are supported with dupSkipChan operation skip channel is pair of MVar The first MVar contains the current value and list of semaphores that need to be notified when it changes The second MVar is semaphore for this particular reader it is full if there is value in the channel that this reader has not read yet and empty otherwise data SkipChan SkipChan MVar MVar MVar newSkipChan IO SkipChan newSkipChan do sem newEmptyMVar main newMVar undefined sem return SkipChan main sem putSkipChan SkipChan IO putSkipChan SkipChan main do sems takeMVar main putMVar main mapM sem putMVar sem sems getSkipChan SkipChan IO getSkipChan SkipChan main sem do takeMVar sem sems takeMVar main putMVar main sem sems return dupSkipChan SkipChan IO SkipChan dupSkipChan SkipChan main do sem newEmptyMVar sems takeMVar main putMVar main sem sems return SkipChan main sem This example was adapted from the original Concurrent Haskell paper For more examples of MVar being used to build higher-level synchronization primitives see Chan and QSem",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "MVar",
          "package": "base",
          "partial": "MVar",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e (pronounced \"em-var\") is a synchronising variable, used\nfor communication between concurrent threads.  It can be thought of\nas a a box, which may be empty or full.\n\u003c/p\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "MVar",
          "package": "base",
          "source": "src/GHC-MVar.html#MVar",
          "type": "data"
        },
        "index": {
          "description": "An MVar pronounced em-var is synchronising variable used for communication between concurrent threads It can be thought of as box which may be empty or full",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "MVar",
          "package": "base",
          "partial": "MVar",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#t:MVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use mkWeakMVar instead\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "addMVarFinalizer",
          "package": "base",
          "signature": "MVar a -\u003e IO () -\u003e IO ()",
          "source": "src/Control-Concurrent-MVar.html#addMVarFinalizer",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use mkWeakMVar instead",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "addMVarFinalizer",
          "normalized": "MVar a-\u003eIO()-\u003eIO()",
          "package": "base",
          "partial": "MVar Finalizer",
          "signature": "MVar a-\u003eIO()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:addMVarFinalizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a given \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e is empty.\n\u003c/p\u003e\u003cp\u003eNotice that the boolean value returned  is just a snapshot of\n the state of the MVar. By the time you get to react on its result,\n the MVar may have been filled (or emptied) - so be extremely\n careful when using this operation.   Use \u003ccode\u003e\u003ca\u003etryTakeMVar\u003c/a\u003e\u003c/code\u003e instead if possible.\n\u003c/p\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "isEmptyMVar",
          "package": "base",
          "signature": "MVar a -\u003e IO Bool",
          "source": "src/GHC-MVar.html#isEmptyMVar",
          "type": "function"
        },
        "index": {
          "description": "Check whether given MVar is empty Notice that the boolean value returned is just snapshot of the state of the MVar By the time you get to react on its result the MVar may have been filled or emptied so be extremely careful when using this operation Use tryTakeMVar instead if possible",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "isEmptyMVar",
          "normalized": "MVar a-\u003eIO Bool",
          "package": "base",
          "partial": "Empty MVar",
          "signature": "MVar a-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:isEmptyMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a \u003ccode\u003e\u003ca\u003eWeak\u003c/a\u003e\u003c/code\u003e pointer to an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e, using the second argument as\n a finalizer to run when \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e is garbage-collected\n\u003c/p\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "mkWeakMVar",
          "package": "base",
          "signature": "MVar a -\u003e IO () -\u003e IO (Weak (MVar a))",
          "source": "src/Control-Concurrent-MVar.html#mkWeakMVar",
          "type": "function"
        },
        "index": {
          "description": "Make Weak pointer to an MVar using the second argument as finalizer to run when MVar is garbage-collected",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "mkWeakMVar",
          "normalized": "MVar a-\u003eIO()-\u003eIO(Weak(MVar a))",
          "package": "base",
          "partial": "Weak MVar",
          "signature": "MVar a-\u003eIO()-\u003eIO(Weak(MVar a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:mkWeakMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA slight variation on \u003ccode\u003e\u003ca\u003emodifyMVar_\u003c/a\u003e\u003c/code\u003e that allows a value to be\n  returned (\u003ccode\u003eb\u003c/code\u003e) in addition to the modified value of the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "modifyMVar",
          "package": "base",
          "signature": "MVar a -\u003e (a -\u003e IO (a, b)) -\u003e IO b",
          "source": "src/Control-Concurrent-MVar.html#modifyMVar",
          "type": "function"
        },
        "index": {
          "description": "slight variation on modifyMVar that allows value to be returned in addition to the modified value of the MVar",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "modifyMVar",
          "normalized": "MVar a-\u003e(a-\u003eIO(a,b))-\u003eIO b",
          "package": "base",
          "partial": "MVar",
          "signature": "MVar a-\u003e(a-\u003eIO(a,b))-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:modifyMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003emodifyMVar\u003c/a\u003e\u003c/code\u003e, but the \u003ccode\u003eIO\u003c/code\u003e action in the second argument is executed with\n  asynchronous exceptions masked.\n\u003c/p\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "modifyMVarMasked",
          "package": "base",
          "signature": "MVar a -\u003e (a -\u003e IO (a, b)) -\u003e IO b",
          "source": "src/Control-Concurrent-MVar.html#modifyMVarMasked",
          "type": "function"
        },
        "index": {
          "description": "Like modifyMVar but the IO action in the second argument is executed with asynchronous exceptions masked",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "modifyMVarMasked",
          "normalized": "MVar a-\u003e(a-\u003eIO(a,b))-\u003eIO b",
          "package": "base",
          "partial": "MVar Masked",
          "signature": "MVar a-\u003e(a-\u003eIO(a,b))-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:modifyMVarMasked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003emodifyMVar_\u003c/a\u003e\u003c/code\u003e, but the \u003ccode\u003eIO\u003c/code\u003e action in the second argument is executed with\n  asynchronous exceptions masked.\n\u003c/p\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "modifyMVarMasked_",
          "package": "base",
          "signature": "MVar a -\u003e (a -\u003e IO a) -\u003e IO ()",
          "source": "src/Control-Concurrent-MVar.html#modifyMVarMasked_",
          "type": "function"
        },
        "index": {
          "description": "Like modifyMVar but the IO action in the second argument is executed with asynchronous exceptions masked",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "modifyMVarMasked_",
          "normalized": "MVar a-\u003e(a-\u003eIO a)-\u003eIO()",
          "package": "base",
          "partial": "MVar Masked",
          "signature": "MVar a-\u003e(a-\u003eIO a)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:modifyMVarMasked_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn exception-safe wrapper for modifying the contents of an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e.\n  Like \u003ccode\u003e\u003ca\u003ewithMVar\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003emodifyMVar\u003c/a\u003e\u003c/code\u003e will replace the original contents of\n  the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e if an exception is raised during the operation.  This\n  function is only atomic if there are no other producers for this\n  \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "modifyMVar_",
          "package": "base",
          "signature": "MVar a -\u003e (a -\u003e IO a) -\u003e IO ()",
          "source": "src/Control-Concurrent-MVar.html#modifyMVar_",
          "type": "function"
        },
        "index": {
          "description": "An exception-safe wrapper for modifying the contents of an MVar Like withMVar modifyMVar will replace the original contents of the MVar if an exception is raised during the operation This function is only atomic if there are no other producers for this MVar",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "modifyMVar_",
          "normalized": "MVar a-\u003e(a-\u003eIO a)-\u003eIO()",
          "package": "base",
          "partial": "MVar",
          "signature": "MVar a-\u003e(a-\u003eIO a)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:modifyMVar_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e which is initially empty.\n\u003c/p\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "newEmptyMVar",
          "package": "base",
          "signature": "IO (MVar a)",
          "source": "src/GHC-MVar.html#newEmptyMVar",
          "type": "function"
        },
        "index": {
          "description": "Create an MVar which is initially empty",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "newEmptyMVar",
          "package": "base",
          "partial": "Empty MVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:newEmptyMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e which contains the supplied value.\n\u003c/p\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "newMVar",
          "package": "base",
          "signature": "a -\u003e IO (MVar a)",
          "source": "src/GHC-MVar.html#newMVar",
          "type": "function"
        },
        "index": {
          "description": "Create an MVar which contains the supplied value",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "newMVar",
          "normalized": "a-\u003eIO(MVar a)",
          "package": "base",
          "partial": "MVar",
          "signature": "a-\u003eIO(MVar a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:newMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePut a value into an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e.  If the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e is currently full,\n \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e will wait until it becomes empty.\n\u003c/p\u003e\u003cp\u003eThere are two further important properties of \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e is single-wakeup.  That is, if there are multiple\n     threads blocked in \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e, and the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e becomes empty,\n     only one thread will be woken up.  The runtime guarantees that\n     the woken thread completes its \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e operation.\n\u003c/li\u003e\u003cli\u003e When multiple threads are blocked on an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e, they are\n     woken up in FIFO order.  This is useful for providing\n     fairness properties of abstractions built using \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003es.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "putMVar",
          "package": "base",
          "signature": "MVar a -\u003e a -\u003e IO ()",
          "source": "src/GHC-MVar.html#putMVar",
          "type": "function"
        },
        "index": {
          "description": "Put value into an MVar If the MVar is currently full putMVar will wait until it becomes empty There are two further important properties of putMVar putMVar is single-wakeup That is if there are multiple threads blocked in putMVar and the MVar becomes empty only one thread will be woken up The runtime guarantees that the woken thread completes its putMVar operation When multiple threads are blocked on an MVar they are woken up in FIFO order This is useful for providing fairness properties of abstractions built using MVar",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "putMVar",
          "normalized": "MVar a-\u003ea-\u003eIO()",
          "package": "base",
          "partial": "MVar",
          "signature": "MVar a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:putMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a combination of \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e; ie. it takes the value\n  from the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e, puts it back, and also returns it.  This function\n  is atomic only if there are no other producers (i.e. threads calling\n  \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e) for this \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "readMVar",
          "package": "base",
          "signature": "MVar a -\u003e IO a",
          "source": "src/Control-Concurrent-MVar.html#readMVar",
          "type": "function"
        },
        "index": {
          "description": "This is combination of takeMVar and putMVar ie it takes the value from the MVar puts it back and also returns it This function is atomic only if there are no other producers i.e threads calling putMVar for this MVar",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "readMVar",
          "normalized": "MVar a-\u003eIO a",
          "package": "base",
          "partial": "MVar",
          "signature": "MVar a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:readMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake a value from an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e, put a new value into the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e and\n  return the value taken. This function is atomic only if there are\n  no other producers for this \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "swapMVar",
          "package": "base",
          "signature": "MVar a -\u003e a -\u003e IO a",
          "source": "src/Control-Concurrent-MVar.html#swapMVar",
          "type": "function"
        },
        "index": {
          "description": "Take value from an MVar put new value into the MVar and return the value taken This function is atomic only if there are no other producers for this MVar",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "swapMVar",
          "normalized": "MVar a-\u003ea-\u003eIO a",
          "package": "base",
          "partial": "MVar",
          "signature": "MVar a-\u003ea-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:swapMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the contents of the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e.  If the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e is currently\n empty, \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e will wait until it is full.  After a \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e,\n the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e is left empty.\n\u003c/p\u003e\u003cp\u003eThere are two further important properties of \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e is single-wakeup.  That is, if there are multiple\n     threads blocked in \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e, and the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e becomes full,\n     only one thread will be woken up.  The runtime guarantees that\n     the woken thread completes its \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e operation.\n\u003c/li\u003e\u003cli\u003e When multiple threads are blocked on an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e, they are\n     woken up in FIFO order.  This is useful for providing\n     fairness properties of abstractions built using \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003es.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "takeMVar",
          "package": "base",
          "signature": "MVar a -\u003e IO a",
          "source": "src/GHC-MVar.html#takeMVar",
          "type": "function"
        },
        "index": {
          "description": "Return the contents of the MVar If the MVar is currently empty takeMVar will wait until it is full After takeMVar the MVar is left empty There are two further important properties of takeMVar takeMVar is single-wakeup That is if there are multiple threads blocked in takeMVar and the MVar becomes full only one thread will be woken up The runtime guarantees that the woken thread completes its takeMVar operation When multiple threads are blocked on an MVar they are woken up in FIFO order This is useful for providing fairness properties of abstractions built using MVar",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "takeMVar",
          "normalized": "MVar a-\u003eIO a",
          "package": "base",
          "partial": "MVar",
          "signature": "MVar a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:takeMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA non-blocking version of \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e.  The \u003ccode\u003e\u003ca\u003etryPutMVar\u003c/a\u003e\u003c/code\u003e function\n attempts to put the value \u003ccode\u003ea\u003c/code\u003e into the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e, returning \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if\n it was successful, or \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise.\n\u003c/p\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "tryPutMVar",
          "package": "base",
          "signature": "MVar a -\u003e a -\u003e IO Bool",
          "source": "src/GHC-MVar.html#tryPutMVar",
          "type": "function"
        },
        "index": {
          "description": "non-blocking version of putMVar The tryPutMVar function attempts to put the value into the MVar returning True if it was successful or False otherwise",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "tryPutMVar",
          "normalized": "MVar a-\u003ea-\u003eIO Bool",
          "package": "base",
          "partial": "Put MVar",
          "signature": "MVar a-\u003ea-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:tryPutMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA non-blocking version of \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e.  The \u003ccode\u003e\u003ca\u003etryTakeMVar\u003c/a\u003e\u003c/code\u003e function\n returns immediately, with \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e was empty, or\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e if the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e was full with contents \u003ccode\u003ea\u003c/code\u003e.  After \u003ccode\u003e\u003ca\u003etryTakeMVar\u003c/a\u003e\u003c/code\u003e,\n the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e is left empty.\n\u003c/p\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "tryTakeMVar",
          "package": "base",
          "signature": "MVar a -\u003e IO (Maybe a)",
          "source": "src/GHC-MVar.html#tryTakeMVar",
          "type": "function"
        },
        "index": {
          "description": "non-blocking version of takeMVar The tryTakeMVar function returns immediately with Nothing if the MVar was empty or Just if the MVar was full with contents After tryTakeMVar the MVar is left empty",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "tryTakeMVar",
          "normalized": "MVar a-\u003eIO(Maybe a)",
          "package": "base",
          "partial": "Take MVar",
          "signature": "MVar a-\u003eIO(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:tryTakeMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ewithMVar\u003c/a\u003e\u003c/code\u003e is an exception-safe wrapper for operating on the contents\n  of an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e.  This operation is exception-safe: it will replace the\n  original contents of the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e if an exception is raised (see\n  \u003ca\u003eControl.Exception\u003c/a\u003e).  However, it is only atomic if there are no\n  other producers for this \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent.MVar",
          "name": "withMVar",
          "package": "base",
          "signature": "MVar a -\u003e (a -\u003e IO b) -\u003e IO b",
          "source": "src/Control-Concurrent-MVar.html#withMVar",
          "type": "function"
        },
        "index": {
          "description": "withMVar is an exception-safe wrapper for operating on the contents of an MVar This operation is exception-safe it will replace the original contents of the MVar if an exception is raised see Control.Exception However it is only atomic if there are no other producers for this MVar",
          "hierarchy": "Control Concurrent MVar",
          "module": "Control.Concurrent.MVar",
          "name": "withMVar",
          "normalized": "MVar a-\u003e(a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "partial": "MVar",
          "signature": "MVar a-\u003e(a-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html#v:withMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Control.Concurrent.QSem will be removed in GHC 7.8. Please use an alternative, e.g. the SafeSemaphore package, instead.\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eSimple quantity semaphores.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Concurrent.QSem",
          "name": "QSem",
          "package": "base",
          "source": "src/Control-Concurrent-QSem.html",
          "type": "module"
        },
        "index": {
          "description": "Deprecated Control.Concurrent.QSem will be removed in GHC Please use an alternative e.g the SafeSemaphore package instead Simple quantity semaphores",
          "hierarchy": "Control Concurrent QSem",
          "module": "Control.Concurrent.QSem",
          "name": "QSem",
          "package": "base",
          "partial": "QSem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-QSem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eQSem\u003c/a\u003e\u003c/code\u003e is a simple quantity semaphore, in which the available\n \"quantity\" is always dealt with in units of one.\n\u003c/p\u003e",
          "module": "Control.Concurrent.QSem",
          "name": "QSem",
          "package": "base",
          "source": "src/Control-Concurrent-QSem.html#QSem",
          "type": "data"
        },
        "index": {
          "description": "QSem is simple quantity semaphore in which the available quantity is always dealt with in units of one",
          "hierarchy": "Control Concurrent QSem",
          "module": "Control.Concurrent.QSem",
          "name": "QSem",
          "package": "base",
          "partial": "QSem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-QSem.html#t:QSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a new \u003ccode\u003e\u003ca\u003eQSem\u003c/a\u003e\u003c/code\u003e with a supplied initial quantity.\n  The initial quantity must be at least 0.\n\u003c/p\u003e",
          "module": "Control.Concurrent.QSem",
          "name": "newQSem",
          "package": "base",
          "signature": "Int -\u003e IO QSem",
          "source": "src/Control-Concurrent-QSem.html#newQSem",
          "type": "function"
        },
        "index": {
          "description": "Build new QSem with supplied initial quantity The initial quantity must be at least",
          "hierarchy": "Control Concurrent QSem",
          "module": "Control.Concurrent.QSem",
          "name": "newQSem",
          "normalized": "Int-\u003eIO QSem",
          "package": "base",
          "partial": "QSem",
          "signature": "Int-\u003eIO QSem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-QSem.html#v:newQSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignal that a unit of the \u003ccode\u003e\u003ca\u003eQSem\u003c/a\u003e\u003c/code\u003e is available\n\u003c/p\u003e",
          "module": "Control.Concurrent.QSem",
          "name": "signalQSem",
          "package": "base",
          "signature": "QSem -\u003e IO ()",
          "source": "src/Control-Concurrent-QSem.html#signalQSem",
          "type": "function"
        },
        "index": {
          "description": "Signal that unit of the QSem is available",
          "hierarchy": "Control Concurrent QSem",
          "module": "Control.Concurrent.QSem",
          "name": "signalQSem",
          "normalized": "QSem-\u003eIO()",
          "package": "base",
          "partial": "QSem",
          "signature": "QSem-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-QSem.html#v:signalQSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWait for a unit to become available\n\u003c/p\u003e",
          "module": "Control.Concurrent.QSem",
          "name": "waitQSem",
          "package": "base",
          "signature": "QSem -\u003e IO ()",
          "source": "src/Control-Concurrent-QSem.html#waitQSem",
          "type": "function"
        },
        "index": {
          "description": "Wait for unit to become available",
          "hierarchy": "Control Concurrent QSem",
          "module": "Control.Concurrent.QSem",
          "name": "waitQSem",
          "normalized": "QSem-\u003eIO()",
          "package": "base",
          "partial": "QSem",
          "signature": "QSem-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-QSem.html#v:waitQSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Control.Concurrent.QSemN will be removed in GHC 7.8. Please use an alternative, e.g. the SafeSemaphore package, instead.\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eQuantity semaphores in which each thread may wait for an arbitrary\n \"amount\".\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Concurrent.QSemN",
          "name": "QSemN",
          "package": "base",
          "source": "src/Control-Concurrent-QSemN.html",
          "type": "module"
        },
        "index": {
          "description": "Deprecated Control.Concurrent.QSemN will be removed in GHC Please use an alternative e.g the SafeSemaphore package instead Quantity semaphores in which each thread may wait for an arbitrary amount",
          "hierarchy": "Control Concurrent QSemN",
          "module": "Control.Concurrent.QSemN",
          "name": "QSemN",
          "package": "base",
          "partial": "QSem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-QSemN.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eQSemN\u003c/a\u003e\u003c/code\u003e is a quantity semaphore, in which the available\n \"quantity\" may be signalled or waited for in arbitrary amounts.\n\u003c/p\u003e",
          "module": "Control.Concurrent.QSemN",
          "name": "QSemN",
          "package": "base",
          "source": "src/Control-Concurrent-QSemN.html#QSemN",
          "type": "data"
        },
        "index": {
          "description": "QSemN is quantity semaphore in which the available quantity may be signalled or waited for in arbitrary amounts",
          "hierarchy": "Control Concurrent QSemN",
          "module": "Control.Concurrent.QSemN",
          "name": "QSemN",
          "package": "base",
          "partial": "QSem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-QSemN.html#t:QSemN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a new \u003ccode\u003e\u003ca\u003eQSemN\u003c/a\u003e\u003c/code\u003e with a supplied initial quantity.\n  The initial quantity must be at least 0.\n\u003c/p\u003e",
          "module": "Control.Concurrent.QSemN",
          "name": "newQSemN",
          "package": "base",
          "signature": "Int -\u003e IO QSemN",
          "source": "src/Control-Concurrent-QSemN.html#newQSemN",
          "type": "function"
        },
        "index": {
          "description": "Build new QSemN with supplied initial quantity The initial quantity must be at least",
          "hierarchy": "Control Concurrent QSemN",
          "module": "Control.Concurrent.QSemN",
          "name": "newQSemN",
          "normalized": "Int-\u003eIO QSemN",
          "package": "base",
          "partial": "QSem",
          "signature": "Int-\u003eIO QSemN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-QSemN.html#v:newQSemN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignal that a given quantity is now available from the \u003ccode\u003e\u003ca\u003eQSemN\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent.QSemN",
          "name": "signalQSemN",
          "package": "base",
          "signature": "QSemN -\u003e Int -\u003e IO ()",
          "source": "src/Control-Concurrent-QSemN.html#signalQSemN",
          "type": "function"
        },
        "index": {
          "description": "Signal that given quantity is now available from the QSemN",
          "hierarchy": "Control Concurrent QSemN",
          "module": "Control.Concurrent.QSemN",
          "name": "signalQSemN",
          "normalized": "QSemN-\u003eInt-\u003eIO()",
          "package": "base",
          "partial": "QSem",
          "signature": "QSemN-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-QSemN.html#v:signalQSemN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWait for the specified quantity to become available\n\u003c/p\u003e",
          "module": "Control.Concurrent.QSemN",
          "name": "waitQSemN",
          "package": "base",
          "signature": "QSemN -\u003e Int -\u003e IO ()",
          "source": "src/Control-Concurrent-QSemN.html#waitQSemN",
          "type": "function"
        },
        "index": {
          "description": "Wait for the specified quantity to become available",
          "hierarchy": "Control Concurrent QSemN",
          "module": "Control.Concurrent.QSemN",
          "name": "waitQSemN",
          "normalized": "QSemN-\u003eInt-\u003eIO()",
          "package": "base",
          "partial": "QSem",
          "signature": "QSemN-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-QSemN.html#v:waitQSemN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Control.Concurrent.SampleVar will be removed in GHC 7.8. Please use an alternative, e.g. the SafeSemaphore package, instead.\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eSample variables\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Concurrent.SampleVar",
          "name": "SampleVar",
          "package": "base",
          "source": "src/Control-Concurrent-SampleVar.html",
          "type": "module"
        },
        "index": {
          "description": "Deprecated Control.Concurrent.SampleVar will be removed in GHC Please use an alternative e.g the SafeSemaphore package instead Sample variables",
          "hierarchy": "Control Concurrent SampleVar",
          "module": "Control.Concurrent.SampleVar",
          "name": "SampleVar",
          "package": "base",
          "partial": "Sample Var",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-SampleVar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSample variables are slightly different from a normal \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Reading an empty \u003ccode\u003e\u003ca\u003eSampleVar\u003c/a\u003e\u003c/code\u003e causes the reader to block.\n    (same as \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e on empty \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e)\n\u003c/li\u003e\u003cli\u003e Reading a filled \u003ccode\u003e\u003ca\u003eSampleVar\u003c/a\u003e\u003c/code\u003e empties it and returns value.\n    (same as \u003ccode\u003e\u003ca\u003etakeMVar\u003c/a\u003e\u003c/code\u003e)\n\u003c/li\u003e\u003cli\u003e Writing to an empty \u003ccode\u003e\u003ca\u003eSampleVar\u003c/a\u003e\u003c/code\u003e fills it with a value, and\n    potentially, wakes up a blocked reader (same as for \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e on\n    empty \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003cli\u003e Writing to a filled \u003ccode\u003e\u003ca\u003eSampleVar\u003c/a\u003e\u003c/code\u003e overwrites the current value.\n    (different from \u003ccode\u003e\u003ca\u003eputMVar\u003c/a\u003e\u003c/code\u003e on full \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e.)\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Concurrent.SampleVar",
          "name": "SampleVar",
          "package": "base",
          "source": "src/Control-Concurrent-SampleVar.html#SampleVar",
          "type": "data"
        },
        "index": {
          "description": "Sample variables are slightly different from normal MVar Reading an empty SampleVar causes the reader to block same as takeMVar on empty MVar Reading filled SampleVar empties it and returns value same as takeMVar Writing to an empty SampleVar fills it with value and potentially wakes up blocked reader same as for putMVar on empty MVar Writing to filled SampleVar overwrites the current value different from putMVar on full MVar",
          "hierarchy": "Control Concurrent SampleVar",
          "module": "Control.Concurrent.SampleVar",
          "name": "SampleVar",
          "package": "base",
          "partial": "Sample Var",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-SampleVar.html#t:SampleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the SampleVar is full, leave it empty.  Otherwise, do nothing.\n\u003c/p\u003e",
          "module": "Control.Concurrent.SampleVar",
          "name": "emptySampleVar",
          "package": "base",
          "signature": "SampleVar a -\u003e IO ()",
          "source": "src/Control-Concurrent-SampleVar.html#emptySampleVar",
          "type": "function"
        },
        "index": {
          "description": "If the SampleVar is full leave it empty Otherwise do nothing",
          "hierarchy": "Control Concurrent SampleVar",
          "module": "Control.Concurrent.SampleVar",
          "name": "emptySampleVar",
          "normalized": "SampleVar a-\u003eIO()",
          "package": "base",
          "partial": "Sample Var",
          "signature": "SampleVar a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-SampleVar.html#v:emptySampleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the \u003ccode\u003e\u003ca\u003eSampleVar\u003c/a\u003e\u003c/code\u003e is currently empty.\n\u003c/p\u003e\u003cp\u003eNote that this function is only useful if you know that no other\n threads can be modifying the state of the \u003ccode\u003e\u003ca\u003eSampleVar\u003c/a\u003e\u003c/code\u003e, because\n otherwise the state of the \u003ccode\u003e\u003ca\u003eSampleVar\u003c/a\u003e\u003c/code\u003e may have changed by the time\n you see the result of \u003ccode\u003e\u003ca\u003eisEmptySampleVar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent.SampleVar",
          "name": "isEmptySampleVar",
          "package": "base",
          "signature": "SampleVar a -\u003e IO Bool",
          "source": "src/Control-Concurrent-SampleVar.html#isEmptySampleVar",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the SampleVar is currently empty Note that this function is only useful if you know that no other threads can be modifying the state of the SampleVar because otherwise the state of the SampleVar may have changed by the time you see the result of isEmptySampleVar",
          "hierarchy": "Control Concurrent SampleVar",
          "module": "Control.Concurrent.SampleVar",
          "name": "isEmptySampleVar",
          "normalized": "SampleVar a-\u003eIO Bool",
          "package": "base",
          "partial": "Empty Sample Var",
          "signature": "SampleVar a-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-SampleVar.html#v:isEmptySampleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a new, empty, \u003ccode\u003e\u003ca\u003eSampleVar\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Concurrent.SampleVar",
          "name": "newEmptySampleVar",
          "package": "base",
          "signature": "IO (SampleVar a)",
          "source": "src/Control-Concurrent-SampleVar.html#newEmptySampleVar",
          "type": "function"
        },
        "index": {
          "description": "Build new empty SampleVar",
          "hierarchy": "Control Concurrent SampleVar",
          "module": "Control.Concurrent.SampleVar",
          "name": "newEmptySampleVar",
          "package": "base",
          "partial": "Empty Sample Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-SampleVar.html#v:newEmptySampleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a \u003ccode\u003e\u003ca\u003eSampleVar\u003c/a\u003e\u003c/code\u003e with an initial value.\n\u003c/p\u003e",
          "module": "Control.Concurrent.SampleVar",
          "name": "newSampleVar",
          "package": "base",
          "signature": "a -\u003e IO (SampleVar a)",
          "source": "src/Control-Concurrent-SampleVar.html#newSampleVar",
          "type": "function"
        },
        "index": {
          "description": "Build SampleVar with an initial value",
          "hierarchy": "Control Concurrent SampleVar",
          "module": "Control.Concurrent.SampleVar",
          "name": "newSampleVar",
          "normalized": "a-\u003eIO(SampleVar a)",
          "package": "base",
          "partial": "Sample Var",
          "signature": "a-\u003eIO(SampleVar a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-SampleVar.html#v:newSampleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWait for a value to become available, then take it and return.\n\u003c/p\u003e",
          "module": "Control.Concurrent.SampleVar",
          "name": "readSampleVar",
          "package": "base",
          "signature": "SampleVar a -\u003e IO a",
          "source": "src/Control-Concurrent-SampleVar.html#readSampleVar",
          "type": "function"
        },
        "index": {
          "description": "Wait for value to become available then take it and return",
          "hierarchy": "Control Concurrent SampleVar",
          "module": "Control.Concurrent.SampleVar",
          "name": "readSampleVar",
          "normalized": "SampleVar a-\u003eIO a",
          "package": "base",
          "partial": "Sample Var",
          "signature": "SampleVar a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-SampleVar.html#v:readSampleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a value into the \u003ccode\u003e\u003ca\u003eSampleVar\u003c/a\u003e\u003c/code\u003e, overwriting any previous value that\n was there.\n\u003c/p\u003e",
          "module": "Control.Concurrent.SampleVar",
          "name": "writeSampleVar",
          "package": "base",
          "signature": "SampleVar a -\u003e a -\u003e IO ()",
          "source": "src/Control-Concurrent-SampleVar.html#writeSampleVar",
          "type": "function"
        },
        "index": {
          "description": "Write value into the SampleVar overwriting any previous value that was there",
          "hierarchy": "Control Concurrent SampleVar",
          "module": "Control.Concurrent.SampleVar",
          "name": "writeSampleVar",
          "normalized": "SampleVar a-\u003ea-\u003eIO()",
          "package": "base",
          "partial": "Sample Var",
          "signature": "SampleVar a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent-SampleVar.html#v:writeSampleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA common interface to a collection of useful concurrency\n abstractions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Concurrent",
          "name": "Concurrent",
          "package": "base",
          "source": "src/Control-Concurrent.html",
          "type": "module"
        },
        "index": {
          "description": "common interface to collection of useful concurrency abstractions",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "Concurrent",
          "package": "base",
          "partial": "Concurrent",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e is an abstract type representing a handle to a thread.\n\u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e is an instance of \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e, where\nthe \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e instance implements an arbitrary total ordering over\n\u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003es. The \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instance lets you convert an arbitrary-valued\n\u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e to string form; showing a \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e value is occasionally\nuseful when debugging or diagnosing the behaviour of a concurrent\nprogram.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote\u003c/em\u003e: in GHC, if you have a \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e, you essentially have\na pointer to the thread itself.  This means the thread itself can't be\ngarbage collected until you drop the \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e.\nThis misfeature will hopefully be corrected at a later date.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote\u003c/em\u003e: Hugs does not provide any operations on other threads;\nit defines \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e as a synonym for ().\n\u003c/p\u003e",
          "module": "Control.Concurrent",
          "name": "ThreadId",
          "package": "base",
          "source": "src/GHC-Conc-Sync.html#ThreadId",
          "type": "data"
        },
        "index": {
          "description": "ThreadId is an abstract type representing handle to thread ThreadId is an instance of Eq Ord and Show where the Ord instance implements an arbitrary total ordering over ThreadId The Show instance lets you convert an arbitrary-valued ThreadId to string form showing ThreadId value is occasionally useful when debugging or diagnosing the behaviour of concurrent program Note in GHC if you have ThreadId you essentially have pointer to the thread itself This means the thread itself can be garbage collected until you drop the ThreadId This misfeature will hopefully be corrected at later date Note Hugs does not provide any operations on other threads it defines ThreadId as synonym for",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "ThreadId",
          "package": "base",
          "partial": "Thread Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#t:ThreadId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efork a thread and call the supplied function when the thread is about\n to terminate, with an exception or a returned value.  The function is\n called with asynchronous exceptions masked.\n\u003c/p\u003e\u003cpre\u003e forkFinally action and_then =\n   mask $ \\restore -\u003e\n     forkIO $ try (restore action) \u003e\u003e= and_then\n\u003c/pre\u003e\u003cp\u003eThis function is useful for informing the parent when a child\n terminates, for example.\n\u003c/p\u003e",
          "module": "Control.Concurrent",
          "name": "forkFinally",
          "package": "base",
          "signature": "IO a -\u003e (Either SomeException a -\u003e IO ()) -\u003e IO ThreadId",
          "source": "src/Control-Concurrent.html#forkFinally",
          "type": "function"
        },
        "index": {
          "description": "fork thread and call the supplied function when the thread is about to terminate with an exception or returned value The function is called with asynchronous exceptions masked forkFinally action and then mask restore forkIO try restore action and then This function is useful for informing the parent when child terminates for example",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "forkFinally",
          "normalized": "IO a-\u003e(Either SomeException a-\u003eIO())-\u003eIO ThreadId",
          "package": "base",
          "partial": "Finally",
          "signature": "IO a-\u003e(Either SomeException a-\u003eIO())-\u003eIO ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkFinally"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSparks off a new thread to run the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e computation passed as the\nfirst argument, and returns the \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e of the newly created\nthread.\n\u003c/p\u003e\u003cp\u003eThe new thread will be a lightweight thread; if you want to use a foreign\nlibrary that uses thread-local storage, use \u003ccode\u003e\u003ca\u003eforkOS\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e\u003cp\u003eGHC note: the new thread inherits the \u003cem\u003emasked\u003c/em\u003e state of the parent\n(see \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eThe newly created thread has an exception handler that discards the\nexceptions \u003ccode\u003e\u003ca\u003eBlockedIndefinitelyOnMVar\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eBlockedIndefinitelyOnSTM\u003c/a\u003e\u003c/code\u003e, and\n\u003ccode\u003e\u003ca\u003eThreadKilled\u003c/a\u003e\u003c/code\u003e, and passes all other exceptions to the uncaught\nexception handler.\n\u003c/p\u003e",
          "module": "[\"Control.Concurrent\",\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "forkIO",
          "package": "base",
          "signature": "IO () -\u003e IO ThreadId",
          "source": "src/GHC-Conc-Sync.html#forkIO",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkIO\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:forkIO\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:forkIO\"]"
        },
        "index": {
          "description": "Sparks off new thread to run the IO computation passed as the first argument and returns the ThreadId of the newly created thread The new thread will be lightweight thread if you want to use foreign library that uses thread-local storage use forkOS instead GHC note the new thread inherits the masked state of the parent see mask The newly created thread has an exception handler that discards the exceptions BlockedIndefinitelyOnMVar BlockedIndefinitelyOnSTM and ThreadKilled and passes all other exceptions to the uncaught exception handler",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "forkIO",
          "normalized": "IO()-\u003eIO ThreadId",
          "package": "base",
          "partial": "IO",
          "signature": "IO()-\u003eIO ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use forkIOWithUnmask instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis function is deprecated; use \u003ccode\u003e\u003ca\u003eforkIOWithUnmask\u003c/a\u003e\u003c/code\u003e instead\n\u003c/p\u003e",
          "module": "[\"Control.Concurrent\",\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "forkIOUnmasked",
          "package": "base",
          "signature": "IO () -\u003e IO ThreadId",
          "source": "src/GHC-Conc-Sync.html#forkIOUnmasked",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkIOUnmasked\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:forkIOUnmasked\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:forkIOUnmasked\"]"
        },
        "index": {
          "description": "Deprecated use forkIOWithUnmask instead This function is deprecated use forkIOWithUnmask instead",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "forkIOUnmasked",
          "normalized": "IO()-\u003eIO ThreadId",
          "package": "base",
          "partial": "IOUnmasked",
          "signature": "IO()-\u003eIO ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkIOUnmasked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eforkIO\u003c/a\u003e\u003c/code\u003e, but the child thread is passed a function that can\n be used to unmask asynchronous exceptions.  This function is\n typically used in the following way\n\u003c/p\u003e\u003cpre\u003e  ... mask_ $ forkIOWithUnmask $ \\unmask -\u003e\n                 catch (unmask ...) handler\n\u003c/pre\u003e\u003cp\u003eso that the exception handler in the child thread is established\n with asynchronous exceptions masked, meanwhile the main body of\n the child thread is executed in the unmasked state.\n\u003c/p\u003e\u003cp\u003eNote that the unmask function passed to the child thread should\n only be used in that thread; the behaviour is undefined if it is\n invoked in a different thread.\n\u003c/p\u003e",
          "module": "[\"Control.Concurrent\",\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "forkIOWithUnmask",
          "package": "base",
          "signature": "((forall a.  IO a -\u003e IO a) -\u003e IO ()) -\u003e IO ThreadId",
          "source": "src/GHC-Conc-Sync.html#forkIOWithUnmask",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkIOWithUnmask\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:forkIOWithUnmask\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:forkIOWithUnmask\"]"
        },
        "index": {
          "description": "Like forkIO but the child thread is passed function that can be used to unmask asynchronous exceptions This function is typically used in the following way mask forkIOWithUnmask unmask catch unmask handler so that the exception handler in the child thread is established with asynchronous exceptions masked meanwhile the main body of the child thread is executed in the unmasked state Note that the unmask function passed to the child thread should only be used in that thread the behaviour is undefined if it is invoked in different thread",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "forkIOWithUnmask",
          "normalized": "((a b IO c-\u003eIO c)-\u003eIO())-\u003eIO ThreadId",
          "package": "base",
          "partial": "IOWith Unmask",
          "signature": "((forall a. IO a-\u003eIO a)-\u003eIO())-\u003eIO ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkIOWithUnmask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eforkIO\u003c/a\u003e\u003c/code\u003e, this sparks off a new thread to run the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\ncomputation passed as the first argument, and returns the \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e\nof the newly created thread.\n\u003c/p\u003e\u003cp\u003eHowever, \u003ccode\u003e\u003ca\u003eforkOS\u003c/a\u003e\u003c/code\u003e creates a \u003cem\u003ebound\u003c/em\u003e thread, which is necessary if you\nneed to call foreign (non-Haskell) libraries that make use of\nthread-local state, such as OpenGL (see \u003ca\u003eControl.Concurrent\u003c/a\u003e).\n\u003c/p\u003e\u003cp\u003eUsing \u003ccode\u003e\u003ca\u003eforkOS\u003c/a\u003e\u003c/code\u003e instead of \u003ccode\u003e\u003ca\u003eforkIO\u003c/a\u003e\u003c/code\u003e makes no difference at all to the\nscheduling behaviour of the Haskell runtime system.  It is a common\nmisconception that you need to use \u003ccode\u003e\u003ca\u003eforkOS\u003c/a\u003e\u003c/code\u003e instead of \u003ccode\u003e\u003ca\u003eforkIO\u003c/a\u003e\u003c/code\u003e to\navoid blocking all the Haskell threads when making a foreign call;\nthis isn't the case.  To allow foreign calls to be made without\nblocking all the Haskell threads (with GHC), it is only necessary to\nuse the \u003ccode\u003e-threaded\u003c/code\u003e option when linking your program, and to make sure\nthe foreign import is not marked \u003ccode\u003eunsafe\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent",
          "name": "forkOS",
          "package": "base",
          "signature": "IO () -\u003e IO ThreadId",
          "source": "src/Control-Concurrent.html#forkOS",
          "type": "function"
        },
        "index": {
          "description": "Like forkIO this sparks off new thread to run the IO computation passed as the first argument and returns the ThreadId of the newly created thread However forkOS creates bound thread which is necessary if you need to call foreign non-Haskell libraries that make use of thread-local state such as OpenGL see Control.Concurrent Using forkOS instead of forkIO makes no difference at all to the scheduling behaviour of the Haskell runtime system It is common misconception that you need to use forkOS instead of forkIO to avoid blocking all the Haskell threads when making foreign call this isn the case To allow foreign calls to be made without blocking all the Haskell threads with GHC it is only necessary to use the threaded option when linking your program and to make sure the foreign import is not marked unsafe",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "forkOS",
          "normalized": "IO()-\u003eIO ThreadId",
          "package": "base",
          "partial": "OS",
          "signature": "IO()-\u003eIO ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkOS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eforkIO\u003c/a\u003e\u003c/code\u003e, but lets you specify on which processor the thread\nshould run.  Unlike a \u003ccode\u003e\u003ca\u003eforkIO\u003c/a\u003e\u003c/code\u003e thread, a thread created by \u003ccode\u003e\u003ca\u003eforkOn\u003c/a\u003e\u003c/code\u003e\nwill stay on the same processor for its entire lifetime (\u003ccode\u003e\u003ca\u003eforkIO\u003c/a\u003e\u003c/code\u003e\nthreads can migrate between processors according to the scheduling\npolicy).  \u003ccode\u003e\u003ca\u003eforkOn\u003c/a\u003e\u003c/code\u003e is useful for overriding the scheduling policy when\nyou know in advance how best to distribute the threads.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e argument specifies a \u003cem\u003ecapability number\u003c/em\u003e (see\n\u003ccode\u003e\u003ca\u003egetNumCapabilities\u003c/a\u003e\u003c/code\u003e).  Typically capabilities correspond to physical\nprocessors, but the exact behaviour is implementation-dependent.  The\nvalue passed to \u003ccode\u003e\u003ca\u003eforkOn\u003c/a\u003e\u003c/code\u003e is interpreted modulo the total number of\ncapabilities as returned by \u003ccode\u003e\u003ca\u003egetNumCapabilities\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eGHC note: the number of capabilities is specified by the \u003ccode\u003e+RTS -N\u003c/code\u003e\noption when the program is started.  Capabilities can be fixed to\nactual processor cores with \u003ccode\u003e+RTS -qa\u003c/code\u003e if the underlying operating\nsystem supports that, although in practice this is usually unnecessary\n(and may actually degrade perforamnce in some cases - experimentation\nis recommended).\n\u003c/p\u003e",
          "module": "[\"Control.Concurrent\",\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "forkOn",
          "package": "base",
          "signature": "Int -\u003e IO () -\u003e IO ThreadId",
          "source": "src/GHC-Conc-Sync.html#forkOn",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkOn\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:forkOn\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:forkOn\"]"
        },
        "index": {
          "description": "Like forkIO but lets you specify on which processor the thread should run Unlike forkIO thread thread created by forkOn will stay on the same processor for its entire lifetime forkIO threads can migrate between processors according to the scheduling policy forkOn is useful for overriding the scheduling policy when you know in advance how best to distribute the threads The Int argument specifies capability number see getNumCapabilities Typically capabilities correspond to physical processors but the exact behaviour is implementation-dependent The value passed to forkOn is interpreted modulo the total number of capabilities as returned by getNumCapabilities GHC note the number of capabilities is specified by the RTS option when the program is started Capabilities can be fixed to actual processor cores with RTS qa if the underlying operating system supports that although in practice this is usually unnecessary and may actually degrade perforamnce in some cases experimentation is recommended",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "forkOn",
          "normalized": "Int-\u003eIO()-\u003eIO ThreadId",
          "package": "base",
          "partial": "On",
          "signature": "Int-\u003eIO()-\u003eIO ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eforkIOWithUnmask\u003c/a\u003e\u003c/code\u003e, but the child thread is pinned to the\n given CPU, as with \u003ccode\u003e\u003ca\u003eforkOn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Concurrent\",\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "forkOnWithUnmask",
          "package": "base",
          "signature": "Int -\u003e ((forall a.  IO a -\u003e IO a) -\u003e IO ()) -\u003e IO ThreadId",
          "source": "src/GHC-Conc-Sync.html#forkOnWithUnmask",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkOnWithUnmask\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:forkOnWithUnmask\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:forkOnWithUnmask\"]"
        },
        "index": {
          "description": "Like forkIOWithUnmask but the child thread is pinned to the given CPU as with forkOn",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "forkOnWithUnmask",
          "normalized": "Int-\u003e((a b IO c-\u003eIO c)-\u003eIO())-\u003eIO ThreadId",
          "package": "base",
          "partial": "On With Unmask",
          "signature": "Int-\u003e((forall a. IO a-\u003eIO a)-\u003eIO())-\u003eIO ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkOnWithUnmask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the number of Haskell threads that can run truly\nsimultaneously (on separate physical processors) at any given time.  To change\nthis value, use \u003ccode\u003e\u003ca\u003esetNumCapabilities\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Concurrent\",\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "getNumCapabilities",
          "package": "base",
          "signature": "IO Int",
          "source": "src/GHC-Conc-Sync.html#getNumCapabilities",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:getNumCapabilities\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:getNumCapabilities\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:getNumCapabilities\"]"
        },
        "index": {
          "description": "Returns the number of Haskell threads that can run truly simultaneously on separate physical processors at any given time To change this value use setNumCapabilities",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "getNumCapabilities",
          "package": "base",
          "partial": "Num Capabilities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:getNumCapabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the calling thread is \u003cem\u003ebound\u003c/em\u003e, that is, if it is\n safe to use foreign libraries that rely on thread-local state from the\n calling thread.\n\u003c/p\u003e",
          "module": "Control.Concurrent",
          "name": "isCurrentThreadBound",
          "package": "base",
          "signature": "IO Bool",
          "source": "src/Control-Concurrent.html#isCurrentThreadBound",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the calling thread is bound that is if it is safe to use foreign libraries that rely on thread-local state from the calling thread",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "isCurrentThreadBound",
          "package": "base",
          "partial": "Current Thread Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:isCurrentThreadBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ekillThread\u003c/a\u003e\u003c/code\u003e raises the \u003ccode\u003e\u003ca\u003eThreadKilled\u003c/a\u003e\u003c/code\u003e exception in the given\nthread (GHC only).\n\u003c/p\u003e\u003cpre\u003e killThread tid = throwTo tid ThreadKilled\n\u003c/pre\u003e",
          "module": "[\"Control.Concurrent\",\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "killThread",
          "package": "base",
          "signature": "ThreadId -\u003e IO ()",
          "source": "src/GHC-Conc-Sync.html#killThread",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:killThread\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:killThread\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:killThread\"]"
        },
        "index": {
          "description": "killThread raises the ThreadKilled exception in the given thread GHC only killThread tid throwTo tid ThreadKilled",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "killThread",
          "normalized": "ThreadId-\u003eIO()",
          "package": "base",
          "partial": "Thread",
          "signature": "ThreadId-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:killThread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Control.Concurrent.mergeIO will be removed in GHC 7.8. Please use an alternative, e.g. the SafeSemaphore package, instead.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Concurrent",
          "name": "mergeIO",
          "package": "base",
          "signature": "[a] -\u003e [a] -\u003e IO [a]",
          "source": "src/Control-Concurrent.html#mergeIO",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Control.Concurrent.mergeIO will be removed in GHC Please use an alternative e.g the SafeSemaphore package instead",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "mergeIO",
          "normalized": "[a]-\u003e[a]-\u003eIO[a]",
          "package": "base",
          "partial": "IO",
          "signature": "[a]-\u003e[a]-\u003eIO[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:mergeIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emake a weak pointer to a \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e.  It can be important to do\n this if you want to hold a reference to a \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e while still\n allowing the thread to receive the \u003ccode\u003eBlockedIndefinitely\u003c/code\u003e family of\n exceptions (e.g. \u003ccode\u003e\u003ca\u003eBlockedIndefinitelyOnMVar\u003c/a\u003e\u003c/code\u003e).  Holding a normal\n \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e reference will prevent the delivery of\n \u003ccode\u003eBlockedIndefinitely\u003c/code\u003e exceptions because the reference could be\n used as the target of \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e at any time, which would unblock\n the thread.\n\u003c/p\u003e\u003cp\u003eHolding a \u003ccode\u003eWeak ThreadId\u003c/code\u003e, on the other hand, will not prevent the\n thread from receiving \u003ccode\u003eBlockedIndefinitely\u003c/code\u003e exceptions.  It is\n still possible to throw an exception to a \u003ccode\u003eWeak ThreadId\u003c/code\u003e, but the\n caller must use \u003ccode\u003edeRefWeak\u003c/code\u003e first to determine whether the thread\n still exists.\n\u003c/p\u003e",
          "module": "[\"Control.Concurrent\",\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "mkWeakThreadId",
          "package": "base",
          "signature": "ThreadId -\u003e IO (Weak ThreadId)",
          "source": "src/GHC-Conc-Sync.html#mkWeakThreadId",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:mkWeakThreadId\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:mkWeakThreadId\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:mkWeakThreadId\"]"
        },
        "index": {
          "description": "make weak pointer to ThreadId It can be important to do this if you want to hold reference to ThreadId while still allowing the thread to receive the BlockedIndefinitely family of exceptions e.g BlockedIndefinitelyOnMVar Holding normal ThreadId reference will prevent the delivery of BlockedIndefinitely exceptions because the reference could be used as the target of throwTo at any time which would unblock the thread Holding Weak ThreadId on the other hand will not prevent the thread from receiving BlockedIndefinitely exceptions It is still possible to throw an exception to Weak ThreadId but the caller must use deRefWeak first to determine whether the thread still exists",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "mkWeakThreadId",
          "normalized": "ThreadId-\u003eIO(Weak ThreadId)",
          "package": "base",
          "partial": "Weak Thread Id",
          "signature": "ThreadId-\u003eIO(Weak ThreadId)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:mkWeakThreadId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e of the calling thread (GHC only).\n\u003c/p\u003e",
          "module": "[\"Control.Concurrent\",\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "myThreadId",
          "package": "base",
          "signature": "IO ThreadId",
          "source": "src/GHC-Conc-Sync.html#myThreadId",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:myThreadId\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:myThreadId\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:myThreadId\"]"
        },
        "index": {
          "description": "Returns the ThreadId of the calling thread GHC only",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "myThreadId",
          "package": "base",
          "partial": "Thread Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:myThreadId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Control.Concurrent.nmergeIO will be removed in GHC 7.8. Please use an alternative, e.g. the SafeSemaphore package, instead.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Concurrent",
          "name": "nmergeIO",
          "package": "base",
          "signature": "[[a]] -\u003e IO [a]",
          "source": "src/Control-Concurrent.html#nmergeIO",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Control.Concurrent.nmergeIO will be removed in GHC Please use an alternative e.g the SafeSemaphore package instead",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "nmergeIO",
          "normalized": "[[a]]-\u003eIO[a]",
          "package": "base",
          "partial": "IO",
          "signature": "[[a]]-\u003eIO[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:nmergeIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if bound threads are supported.\n If \u003ccode\u003ertsSupportsBoundThreads\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eisCurrentThreadBound\u003c/a\u003e\u003c/code\u003e\n will always return \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e and both \u003ccode\u003e\u003ca\u003eforkOS\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003erunInBoundThread\u003c/a\u003e\u003c/code\u003e will\n fail.\n\u003c/p\u003e",
          "module": "Control.Concurrent",
          "name": "rtsSupportsBoundThreads",
          "package": "base",
          "signature": "Bool",
          "source": "src/Control-Concurrent.html#rtsSupportsBoundThreads",
          "type": "function"
        },
        "index": {
          "description": "True if bound threads are supported If rtsSupportsBoundThreads is False isCurrentThreadBound will always return False and both forkOS and runInBoundThread will fail",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "rtsSupportsBoundThreads",
          "package": "base",
          "partial": "Supports Bound Threads",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:rtsSupportsBoundThreads"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e computation passed as the first argument. If the calling thread\nis not \u003cem\u003ebound\u003c/em\u003e, a bound thread is created temporarily. \u003ccode\u003erunInBoundThread\u003c/code\u003e\ndoesn't finish until the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e computation finishes.\n\u003c/p\u003e\u003cp\u003eYou can wrap a series of foreign function calls that rely on thread-local state\nwith \u003ccode\u003erunInBoundThread\u003c/code\u003e so that you can use them without knowing whether the\ncurrent thread is \u003cem\u003ebound\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent",
          "name": "runInBoundThread",
          "package": "base",
          "signature": "IO a -\u003e IO a",
          "source": "src/Control-Concurrent.html#runInBoundThread",
          "type": "function"
        },
        "index": {
          "description": "Run the IO computation passed as the first argument If the calling thread is not bound bound thread is created temporarily runInBoundThread doesn finish until the IO computation finishes You can wrap series of foreign function calls that rely on thread-local state with runInBoundThread so that you can use them without knowing whether the current thread is bound",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "runInBoundThread",
          "normalized": "IO a-\u003eIO a",
          "package": "base",
          "partial": "In Bound Thread",
          "signature": "IO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:runInBoundThread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e computation passed as the first argument. If the calling thread\nis \u003cem\u003ebound\u003c/em\u003e, an unbound thread is created temporarily using \u003ccode\u003e\u003ca\u003eforkIO\u003c/a\u003e\u003c/code\u003e.\n\u003ccode\u003erunInBoundThread\u003c/code\u003e doesn't finish until the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e computation finishes.\n\u003c/p\u003e\u003cp\u003eUse this function \u003cem\u003eonly\u003c/em\u003e in the rare case that you have actually observed a\nperformance loss due to the use of bound threads. A program that\ndoesn't need it's main thread to be bound and makes \u003cem\u003eheavy\u003c/em\u003e use of concurrency\n(e.g. a web server), might want to wrap it's \u003ccode\u003emain\u003c/code\u003e action in\n\u003ccode\u003erunInUnboundThread\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that exceptions which are thrown to the current thread are thrown in turn\nto the thread that is executing the given computation. This ensures there's\nalways a way of killing the forked thread.\n\u003c/p\u003e",
          "module": "Control.Concurrent",
          "name": "runInUnboundThread",
          "package": "base",
          "signature": "IO a -\u003e IO a",
          "source": "src/Control-Concurrent.html#runInUnboundThread",
          "type": "function"
        },
        "index": {
          "description": "Run the IO computation passed as the first argument If the calling thread is bound an unbound thread is created temporarily using forkIO runInBoundThread doesn finish until the IO computation finishes Use this function only in the rare case that you have actually observed performance loss due to the use of bound threads program that doesn need it main thread to be bound and makes heavy use of concurrency e.g web server might want to wrap it main action in runInUnboundThread Note that exceptions which are thrown to the current thread are thrown in turn to the thread that is executing the given computation This ensures there always way of killing the forked thread",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "runInUnboundThread",
          "normalized": "IO a-\u003eIO a",
          "package": "base",
          "partial": "In Unbound Thread",
          "signature": "IO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:runInUnboundThread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the number of Haskell threads that can run truly simultaneously\n(on separate physical processors) at any given time.  The number\npassed to \u003ccode\u003e\u003ca\u003eforkOn\u003c/a\u003e\u003c/code\u003e is interpreted modulo this value.  The initial\nvalue is given by the \u003ccode\u003e+RTS -N\u003c/code\u003e runtime flag.\n\u003c/p\u003e\u003cp\u003eThis is also the number of threads that will participate in parallel\ngarbage collection.  It is strongly recommended that the number of\ncapabilities is not set larger than the number of physical processor\ncores, and it may often be beneficial to leave one or more cores free\nto avoid contention with other processes in the machine.\n\u003c/p\u003e",
          "module": "[\"Control.Concurrent\",\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "setNumCapabilities",
          "package": "base",
          "signature": "Int -\u003e IO ()",
          "source": "src/GHC-Conc-Sync.html#setNumCapabilities",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:setNumCapabilities\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:setNumCapabilities\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:setNumCapabilities\"]"
        },
        "index": {
          "description": "Set the number of Haskell threads that can run truly simultaneously on separate physical processors at any given time The number passed to forkOn is interpreted modulo this value The initial value is given by the RTS runtime flag This is also the number of threads that will participate in parallel garbage collection It is strongly recommended that the number of capabilities is not set larger than the number of physical processor cores and it may often be beneficial to leave one or more cores free to avoid contention with other processes in the machine",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "setNumCapabilities",
          "normalized": "Int-\u003eIO()",
          "package": "base",
          "partial": "Num Capabilities",
          "signature": "Int-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:setNumCapabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturns the number of the capability on which the thread is currently\n running, and a boolean indicating whether the thread is locked to\n that capability or not.  A thread is locked to a capability if it\n was created with \u003ccode\u003eforkOn\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Concurrent\",\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "threadCapability",
          "package": "base",
          "signature": "ThreadId -\u003e IO (Int, Bool)",
          "source": "src/GHC-Conc-Sync.html#threadCapability",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:threadCapability\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:threadCapability\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:threadCapability\"]"
        },
        "index": {
          "description": "returns the number of the capability on which the thread is currently running and boolean indicating whether the thread is locked to that capability or not thread is locked to capability if it was created with forkOn",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "threadCapability",
          "normalized": "ThreadId-\u003eIO(Int,Bool)",
          "package": "base",
          "partial": "Capability",
          "signature": "ThreadId-\u003eIO(Int,Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:threadCapability"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSuspends the current thread for a given number of microseconds\n (GHC only).\n\u003c/p\u003e\u003cp\u003eThere is no guarantee that the thread will be rescheduled promptly\n when the delay has expired, but the thread will never continue to\n run \u003cem\u003eearlier\u003c/em\u003e than specified.\n\u003c/p\u003e",
          "module": "[\"Control.Concurrent\",\"GHC.Conc.IO\",\"GHC.Conc\"]",
          "name": "threadDelay",
          "package": "base",
          "signature": "Int -\u003e IO ()",
          "source": "src/GHC-Conc-IO.html#threadDelay",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:threadDelay\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc-IO.html#v:threadDelay\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:threadDelay\"]"
        },
        "index": {
          "description": "Suspends the current thread for given number of microseconds GHC only There is no guarantee that the thread will be rescheduled promptly when the delay has expired but the thread will never continue to run earlier than specified",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "threadDelay",
          "normalized": "Int-\u003eIO()",
          "package": "base",
          "partial": "Delay",
          "signature": "Int-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:threadDelay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBlock the current thread until data is available to read on the\n given file descriptor (GHC only).\n\u003c/p\u003e\u003cp\u003eThis will throw an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e if the file descriptor was closed\n while this thread was blocked.  To safely close a file descriptor\n that has been used with \u003ccode\u003e\u003ca\u003ethreadWaitRead\u003c/a\u003e\u003c/code\u003e, use\n \u003ccode\u003e\u003ca\u003ecloseFdWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent",
          "name": "threadWaitRead",
          "package": "base",
          "signature": "Fd -\u003e IO ()",
          "source": "src/Control-Concurrent.html#threadWaitRead",
          "type": "function"
        },
        "index": {
          "description": "Block the current thread until data is available to read on the given file descriptor GHC only This will throw an IOError if the file descriptor was closed while this thread was blocked To safely close file descriptor that has been used with threadWaitRead use closeFdWith",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "threadWaitRead",
          "normalized": "Fd-\u003eIO()",
          "package": "base",
          "partial": "Wait Read",
          "signature": "Fd-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:threadWaitRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBlock the current thread until data can be written to the\n given file descriptor (GHC only).\n\u003c/p\u003e\u003cp\u003eThis will throw an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e if the file descriptor was closed\n while this thread was blocked.  To safely close a file descriptor\n that has been used with \u003ccode\u003e\u003ca\u003ethreadWaitWrite\u003c/a\u003e\u003c/code\u003e, use\n \u003ccode\u003e\u003ca\u003ecloseFdWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Concurrent",
          "name": "threadWaitWrite",
          "package": "base",
          "signature": "Fd -\u003e IO ()",
          "source": "src/Control-Concurrent.html#threadWaitWrite",
          "type": "function"
        },
        "index": {
          "description": "Block the current thread until data can be written to the given file descriptor GHC only This will throw an IOError if the file descriptor was closed while this thread was blocked To safely close file descriptor that has been used with threadWaitWrite use closeFdWith",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "threadWaitWrite",
          "normalized": "Fd-\u003eIO()",
          "package": "base",
          "partial": "Wait Write",
          "signature": "Fd-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:threadWaitWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e raises an arbitrary exception in the target thread (GHC only).\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e does not return until the exception has been raised in the\ntarget thread.\nThe calling thread can thus be certain that the target\nthread has received the exception.  This is a useful property to know\nwhen dealing with race conditions: eg. if there are two threads that\ncan kill each other, it is guaranteed that only one of the threads\nwill get to kill the other.\n\u003c/p\u003e\u003cp\u003eWhatever work the target thread was doing when the exception was\nraised is not lost: the computation is suspended until required by\nanother thread.\n\u003c/p\u003e\u003cp\u003eIf the target thread is currently making a foreign call, then the\nexception will not be raised (and hence \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e will not return)\nuntil the call has completed.  This is the case regardless of whether\nthe call is inside a \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e or not.  However, in GHC a foreign call\ncan be annotated as \u003ccode\u003einterruptible\u003c/code\u003e, in which case a \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e will\ncause the RTS to attempt to cause the call to return; see the GHC\ndocumentation for more details.\n\u003c/p\u003e\u003cp\u003eImportant note: the behaviour of \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e differs from that described in\nthe paper \"Asynchronous exceptions in Haskell\"\n(\u003ca\u003ehttp://research.microsoft.com/~simonpj/Papers/asynch-exns.htm\u003c/a\u003e).\nIn the paper, \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e is non-blocking; but the library implementation adopts\na more synchronous design in which \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e does not return until the exception\nis received by the target thread.  The trade-off is discussed in Section 9 of the paper.\nLike any blocking operation, \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e is therefore interruptible (see Section 5.3 of\nthe paper).  Unlike other interruptible operations, however, \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e\nis \u003cem\u003ealways\u003c/em\u003e interruptible, even if it does not actually block.\n\u003c/p\u003e\u003cp\u003eThere is no guarantee that the exception will be delivered promptly,\nalthough the runtime will endeavour to ensure that arbitrary\ndelays don't occur.  In GHC, an exception can only be raised when a\nthread reaches a \u003cem\u003esafe point\u003c/em\u003e, where a safe point is where memory\nallocation occurs.  Some loops do not perform any memory allocation\ninside the loop and therefore cannot be interrupted by a \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the target of \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e is the calling thread, then the behaviour\nis the same as \u003ccode\u003e\u003ca\u003ethrowIO\u003c/a\u003e\u003c/code\u003e, except that the exception\nis thrown as an asynchronous exception.  This means that if there is\nan enclosing pure computation, which would be the case if the current\nIO operation is inside \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eunsafeInterleaveIO\u003c/a\u003e\u003c/code\u003e, that\ncomputation is not permanently replaced by the exception, but is\nsuspended as if it had received an asynchronous exception.\n\u003c/p\u003e\u003cp\u003eNote that if \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e is called with the current thread as the\ntarget, the exception will be thrown even if the thread is currently\ninside \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003euninterruptibleMask\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Concurrent\",\"Control.Exception.Base\",\"Control.Exception\",\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "throwTo",
          "package": "base",
          "signature": "ThreadId -\u003e e -\u003e IO ()",
          "source": "src/GHC-Conc-Sync.html#throwTo",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:throwTo\",\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:throwTo\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:throwTo\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:throwTo\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:throwTo\"]"
        },
        "index": {
          "description": "throwTo raises an arbitrary exception in the target thread GHC only throwTo does not return until the exception has been raised in the target thread The calling thread can thus be certain that the target thread has received the exception This is useful property to know when dealing with race conditions eg if there are two threads that can kill each other it is guaranteed that only one of the threads will get to kill the other Whatever work the target thread was doing when the exception was raised is not lost the computation is suspended until required by another thread If the target thread is currently making foreign call then the exception will not be raised and hence throwTo will not return until the call has completed This is the case regardless of whether the call is inside mask or not However in GHC foreign call can be annotated as interruptible in which case throwTo will cause the RTS to attempt to cause the call to return see the GHC documentation for more details Important note the behaviour of throwTo differs from that described in the paper Asynchronous exceptions in Haskell http research.microsoft.com simonpj Papers asynch-exns.htm In the paper throwTo is non-blocking but the library implementation adopts more synchronous design in which throwTo does not return until the exception is received by the target thread The trade-off is discussed in Section of the paper Like any blocking operation throwTo is therefore interruptible see Section of the paper Unlike other interruptible operations however throwTo is always interruptible even if it does not actually block There is no guarantee that the exception will be delivered promptly although the runtime will endeavour to ensure that arbitrary delays don occur In GHC an exception can only be raised when thread reaches safe point where safe point is where memory allocation occurs Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by throwTo If the target of throwTo is the calling thread then the behaviour is the same as throwIO except that the exception is thrown as an asynchronous exception This means that if there is an enclosing pure computation which would be the case if the current IO operation is inside unsafePerformIO or unsafeInterleaveIO that computation is not permanently replaced by the exception but is suspended as if it had received an asynchronous exception Note that if throwTo is called with the current thread as the target the exception will be thrown even if the thread is currently inside mask or uninterruptibleMask",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "throwTo",
          "normalized": "ThreadId-\u003ea-\u003eIO()",
          "package": "base",
          "partial": "To",
          "signature": "ThreadId-\u003ee-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:throwTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eyield\u003c/a\u003e\u003c/code\u003e action allows (forces, in a co-operative multitasking\n implementation) a context-switch to any other currently runnable\n threads (if any), and is occasionally useful when implementing\n concurrency abstractions.\n\u003c/p\u003e",
          "module": "[\"Control.Concurrent\",\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "yield",
          "package": "base",
          "signature": "IO ()",
          "source": "src/GHC-Conc-Sync.html#yield",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:yield\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:yield\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:yield\"]"
        },
        "index": {
          "description": "The yield action allows forces in co-operative multitasking implementation context-switch to any other currently runnable threads if any and is occasionally useful when implementing concurrency abstractions",
          "hierarchy": "Control Concurrent",
          "module": "Control.Concurrent",
          "name": "yield",
          "normalized": "IO()",
          "package": "base",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:yield"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExtensible exceptions, except for multiple handlers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Exception.Base",
          "name": "Base",
          "package": "base",
          "source": "src/Control-Exception-Base.html",
          "type": "module"
        },
        "index": {
          "description": "Extensible exceptions except for multiple handlers",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "Base",
          "package": "base",
          "partial": "Base",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArithmetic exceptions.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "ArithException",
          "package": "base",
          "source": "src/GHC-Exception.html#ArithException",
          "type": "data"
        },
        "index": {
          "description": "Arithmetic exceptions",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "ArithException",
          "package": "base",
          "partial": "Arith Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:ArithException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExceptions generated by array operations\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "ArrayException",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#ArrayException",
          "type": "data"
        },
        "index": {
          "description": "Exceptions generated by array operations",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "ArrayException",
          "package": "base",
          "partial": "Array Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:ArrayException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eassert\u003c/a\u003e\u003c/code\u003e was applied to \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "AssertionFailed",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#AssertionFailed",
          "type": "data"
        },
        "index": {
          "description": "assert was applied to False",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "AssertionFailed",
          "package": "base",
          "partial": "Assertion Failed",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:AssertionFailed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAsynchronous exceptions.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "AsyncException",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#AsyncException",
          "type": "data"
        },
        "index": {
          "description": "Asynchronous exceptions",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "AsyncException",
          "package": "base",
          "partial": "Async Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:AsyncException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe thread is blocked on an \u003ccode\u003eMVar\u003c/code\u003e, but there are no other references\n to the \u003ccode\u003eMVar\u003c/code\u003e so it can't ever continue.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "BlockedIndefinitelyOnMVar",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#BlockedIndefinitelyOnMVar",
          "type": "data"
        },
        "index": {
          "description": "The thread is blocked on an MVar but there are no other references to the MVar so it can ever continue",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "BlockedIndefinitelyOnMVar",
          "package": "base",
          "partial": "Blocked Indefinitely On MVar",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe thread is waiting to retry an STM transaction, but there are no\n other references to any \u003ccode\u003eTVar\u003c/code\u003es involved, so it can't ever continue.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "BlockedIndefinitelyOnSTM",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#BlockedIndefinitelyOnSTM",
          "type": "data"
        },
        "index": {
          "description": "The thread is waiting to retry an STM transaction but there are no other references to any TVar involved so it can ever continue",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "BlockedIndefinitelyOnSTM",
          "package": "base",
          "partial": "Blocked Indefinitely On STM",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere are no runnable threads, so the program is deadlocked.\n The \u003ccode\u003eDeadlock\u003c/code\u003e exception is raised in the main thread only.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "Deadlock",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#Deadlock",
          "type": "data"
        },
        "index": {
          "description": "There are no runnable threads so the program is deadlocked The Deadlock exception is raised in the main thread only",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "Deadlock",
          "package": "base",
          "partial": "Deadlock",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:Deadlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is thrown when the user calls \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e. The \u003ccode\u003eString\u003c/code\u003e is the\n argument given to \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "ErrorCall",
          "package": "base",
          "source": "src/GHC-Exception.html#ErrorCall",
          "type": "data"
        },
        "index": {
          "description": "This is thrown when the user calls error The String is the argument given to error",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "ErrorCall",
          "package": "base",
          "partial": "Error Call",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:ErrorCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAny type that you wish to throw or catch as an exception must be an\ninstance of the \u003ccode\u003eException\u003c/code\u003e class. The simplest case is a new exception\ntype directly below the root:\n\u003c/p\u003e\u003cpre\u003e data MyException = ThisException | ThatException\n     deriving (Show, Typeable)\n\n instance Exception MyException\n\u003c/pre\u003e\u003cp\u003eThe default method definitions in the \u003ccode\u003eException\u003c/code\u003e class do what we need\nin this case. You can now throw and catch \u003ccode\u003eThisException\u003c/code\u003e and\n\u003ccode\u003eThatException\u003c/code\u003e as exceptions:\n\u003c/p\u003e\u003cpre\u003e\n*Main\u003e throw ThisException `catch` \\e -\u003e putStrLn (\"Caught \" ++ show (e :: MyException))\nCaught ThisException\n\u003c/pre\u003e\u003cp\u003eIn more complicated examples, you may wish to define a whole hierarchy\nof exceptions:\n\u003c/p\u003e\u003cpre\u003e ---------------------------------------------------------------------\n -- Make the root exception type for all the exceptions in a compiler\n\n data SomeCompilerException = forall e . Exception e =\u003e SomeCompilerException e\n     deriving Typeable\n\n instance Show SomeCompilerException where\n     show (SomeCompilerException e) = show e\n\n instance Exception SomeCompilerException\n\n compilerExceptionToException :: Exception e =\u003e e -\u003e SomeException\n compilerExceptionToException = toException . SomeCompilerException\n\n compilerExceptionFromException :: Exception e =\u003e SomeException -\u003e Maybe e\n compilerExceptionFromException x = do\n     SomeCompilerException a \u003c- fromException x\n     cast a\n\n ---------------------------------------------------------------------\n -- Make a subhierarchy for exceptions in the frontend of the compiler\n\n data SomeFrontendException = forall e . Exception e =\u003e SomeFrontendException e\n     deriving Typeable\n\n instance Show SomeFrontendException where\n     show (SomeFrontendException e) = show e\n\n instance Exception SomeFrontendException where\n     toException = compilerExceptionToException\n     fromException = compilerExceptionFromException\n\n frontendExceptionToException :: Exception e =\u003e e -\u003e SomeException\n frontendExceptionToException = toException . SomeFrontendException\n\n frontendExceptionFromException :: Exception e =\u003e SomeException -\u003e Maybe e\n frontendExceptionFromException x = do\n     SomeFrontendException a \u003c- fromException x\n     cast a\n\n ---------------------------------------------------------------------\n -- Make an exception type for a particular frontend compiler exception\n\n data MismatchedParentheses = MismatchedParentheses\n     deriving (Typeable, Show)\n\n instance Exception MismatchedParentheses where\n     toException   = frontendExceptionToException\n     fromException = frontendExceptionFromException\n\u003c/pre\u003e\u003cp\u003eWe can now catch a \u003ccode\u003eMismatchedParentheses\u003c/code\u003e exception as\n\u003ccode\u003eMismatchedParentheses\u003c/code\u003e, \u003ccode\u003eSomeFrontendException\u003c/code\u003e or\n\u003ccode\u003eSomeCompilerException\u003c/code\u003e, but not other types, e.g. \u003ccode\u003eIOException\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: MismatchedParentheses))\nCaught MismatchedParentheses\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: SomeFrontendException))\nCaught MismatchedParentheses\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: SomeCompilerException))\nCaught MismatchedParentheses\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: IOException))\n*** Exception: MismatchedParentheses\n\u003c/pre\u003e",
          "module": "Control.Exception.Base",
          "name": "Exception",
          "package": "base",
          "source": "src/GHC-Exception.html#Exception",
          "type": "class"
        },
        "index": {
          "description": "Any type that you wish to throw or catch as an exception must be an instance of the Exception class The simplest case is new exception type directly below the root data MyException ThisException ThatException deriving Show Typeable instance Exception MyException The default method definitions in the Exception class do what we need in this case You can now throw and catch ThisException and ThatException as exceptions Main throw ThisException catch putStrLn Caught show MyException Caught ThisException In more complicated examples you may wish to define whole hierarchy of exceptions Make the root exception type for all the exceptions in compiler data SomeCompilerException forall Exception SomeCompilerException deriving Typeable instance Show SomeCompilerException where show SomeCompilerException show instance Exception SomeCompilerException compilerExceptionToException Exception SomeException compilerExceptionToException toException SomeCompilerException compilerExceptionFromException Exception SomeException Maybe compilerExceptionFromException do SomeCompilerException fromException cast Make subhierarchy for exceptions in the frontend of the compiler data SomeFrontendException forall Exception SomeFrontendException deriving Typeable instance Show SomeFrontendException where show SomeFrontendException show instance Exception SomeFrontendException where toException compilerExceptionToException fromException compilerExceptionFromException frontendExceptionToException Exception SomeException frontendExceptionToException toException SomeFrontendException frontendExceptionFromException Exception SomeException Maybe frontendExceptionFromException do SomeFrontendException fromException cast Make an exception type for particular frontend compiler exception data MismatchedParentheses MismatchedParentheses deriving Typeable Show instance Exception MismatchedParentheses where toException frontendExceptionToException fromException frontendExceptionFromException We can now catch MismatchedParentheses exception as MismatchedParentheses SomeFrontendException or SomeCompilerException but not other types e.g IOException Main throw MismatchedParentheses catch putStrLn Caught show MismatchedParentheses Caught MismatchedParentheses Main throw MismatchedParentheses catch putStrLn Caught show SomeFrontendException Caught MismatchedParentheses Main throw MismatchedParentheses catch putStrLn Caught show SomeCompilerException Caught MismatchedParentheses Main throw MismatchedParentheses catch putStrLn Caught show IOException Exception MismatchedParentheses",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "Exception",
          "package": "base",
          "partial": "Exception",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:Exception"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExceptions that occur in the \u003ccode\u003eIO\u003c/code\u003e monad.\n An \u003ccode\u003eIOException\u003c/code\u003e records a more specific error type, a descriptive\n string and maybe the handle that was used when the error was\n flagged.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "IOException",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#IOException",
          "type": "data"
        },
        "index": {
          "description": "Exceptions that occur in the IO monad An IOException records more specific error type descriptive string and maybe the handle that was used when the error was flagged",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "IOException",
          "package": "base",
          "partial": "IOException",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:IOException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes the behaviour of a thread when an asynchronous\n exception is received.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "MaskingState",
          "package": "base",
          "source": "src/GHC-IO.html#MaskingState",
          "type": "data"
        },
        "index": {
          "description": "Describes the behaviour of thread when an asynchronous exception is received",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "MaskingState",
          "package": "base",
          "partial": "Masking State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:MaskingState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown when the program attempts to call \u003ccode\u003eatomically\u003c/code\u003e, from the \u003ccode\u003estm\u003c/code\u003e\n package, inside another call to \u003ccode\u003eatomically\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "NestedAtomically",
          "package": "base",
          "source": "src/Control-Exception-Base.html#NestedAtomically",
          "type": "data"
        },
        "index": {
          "description": "Thrown when the program attempts to call atomically from the stm package inside another call to atomically",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "NestedAtomically",
          "package": "base",
          "partial": "Nested Atomically",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:NestedAtomically"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class method without a definition (neither a default definition,\n nor a definition in the appropriate instance) was called. The\n \u003ccode\u003eString\u003c/code\u003e gives information about which method it was.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "NoMethodError",
          "package": "base",
          "source": "src/Control-Exception-Base.html#NoMethodError",
          "type": "data"
        },
        "index": {
          "description": "class method without definition neither default definition nor definition in the appropriate instance was called The String gives information about which method it was",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "NoMethodError",
          "package": "base",
          "partial": "No Method Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:NoMethodError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown when the runtime system detects that the computation is\n guaranteed not to terminate. Note that there is no guarantee that\n the runtime system will notice whether any given computation is\n guaranteed to terminate or not.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "NonTermination",
          "package": "base",
          "source": "src/Control-Exception-Base.html#NonTermination",
          "type": "data"
        },
        "index": {
          "description": "Thrown when the runtime system detects that the computation is guaranteed not to terminate Note that there is no guarantee that the runtime system will notice whether any given computation is guaranteed to terminate or not",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "NonTermination",
          "package": "base",
          "partial": "Non Termination",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:NonTermination"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern match failed. The \u003ccode\u003eString\u003c/code\u003e gives information about the\n source location of the pattern.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "PatternMatchFail",
          "package": "base",
          "source": "src/Control-Exception-Base.html#PatternMatchFail",
          "type": "data"
        },
        "index": {
          "description": "pattern match failed The String gives information about the source location of the pattern",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "PatternMatchFail",
          "package": "base",
          "partial": "Pattern Match Fail",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:PatternMatchFail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn uninitialised record field was used. The \u003ccode\u003eString\u003c/code\u003e gives\n information about the source location where the record was\n constructed.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "RecConError",
          "package": "base",
          "source": "src/Control-Exception-Base.html#RecConError",
          "type": "data"
        },
        "index": {
          "description": "An uninitialised record field was used The String gives information about the source location where the record was constructed",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "RecConError",
          "package": "base",
          "partial": "Rec Con Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:RecConError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA record selector was applied to a constructor without the\n appropriate field. This can only happen with a datatype with\n multiple constructors, where some fields are in one constructor\n but not another. The \u003ccode\u003eString\u003c/code\u003e gives information about the source\n location of the record selector.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "RecSelError",
          "package": "base",
          "source": "src/Control-Exception-Base.html#RecSelError",
          "type": "data"
        },
        "index": {
          "description": "record selector was applied to constructor without the appropriate field This can only happen with datatype with multiple constructors where some fields are in one constructor but not another The String gives information about the source location of the record selector",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "RecSelError",
          "package": "base",
          "partial": "Rec Sel Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:RecSelError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA record update was performed on a constructor without the\n appropriate field. This can only happen with a datatype with\n multiple constructors, where some fields are in one constructor\n but not another. The \u003ccode\u003eString\u003c/code\u003e gives information about the source\n location of the record update.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "RecUpdError",
          "package": "base",
          "source": "src/Control-Exception-Base.html#RecUpdError",
          "type": "data"
        },
        "index": {
          "description": "record update was performed on constructor without the appropriate field This can only happen with datatype with multiple constructors where some fields are in one constructor but not another The String gives information about the source location of the record update",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "RecUpdError",
          "package": "base",
          "partial": "Rec Upd Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:RecUpdError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003eSomeException\u003c/code\u003e type is the root of the exception type hierarchy.\nWhen an exception of type \u003ccode\u003ee\u003c/code\u003e is thrown, behind the scenes it is\nencapsulated in a \u003ccode\u003eSomeException\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Base",
          "name": "SomeException",
          "package": "base",
          "source": "src/GHC-Exception.html#SomeException",
          "type": "data"
        },
        "index": {
          "description": "The SomeException type is the root of the exception type hierarchy When an exception of type is thrown behind the scenes it is encapsulated in SomeException",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "SomeException",
          "package": "base",
          "partial": "Some Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#t:SomeException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "AssertionFailed",
          "package": "base",
          "signature": "AssertionFailed String",
          "source": "src/GHC-IO-Exception.html#AssertionFailed",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:AssertionFailed\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:AssertionFailed\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "AssertionFailed",
          "package": "base",
          "partial": "Assertion Failed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:AssertionFailed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "BlockedIndefinitelyOnMVar",
          "package": "base",
          "signature": "BlockedIndefinitelyOnMVar",
          "source": "src/GHC-IO-Exception.html#BlockedIndefinitelyOnMVar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:BlockedIndefinitelyOnMVar\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:BlockedIndefinitelyOnMVar\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "BlockedIndefinitelyOnMVar",
          "package": "base",
          "partial": "Blocked Indefinitely On MVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:BlockedIndefinitelyOnMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "BlockedIndefinitelyOnSTM",
          "package": "base",
          "signature": "BlockedIndefinitelyOnSTM",
          "source": "src/GHC-IO-Exception.html#BlockedIndefinitelyOnSTM",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:BlockedIndefinitelyOnSTM\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:BlockedIndefinitelyOnSTM\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "BlockedIndefinitelyOnSTM",
          "package": "base",
          "partial": "Blocked Indefinitely On STM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:BlockedIndefinitelyOnSTM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "Deadlock",
          "package": "base",
          "signature": "Deadlock",
          "source": "src/GHC-IO-Exception.html#Deadlock",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:Deadlock\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:Deadlock\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "Deadlock",
          "package": "base",
          "partial": "Deadlock",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:Deadlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "Denormal",
          "package": "base",
          "signature": "Denormal",
          "source": "src/GHC-Exception.html#ArithException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:Denormal\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:Denormal\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "Denormal",
          "package": "base",
          "partial": "Denormal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:Denormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "DivideByZero",
          "package": "base",
          "signature": "DivideByZero",
          "source": "src/GHC-Exception.html#ArithException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:DivideByZero\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:DivideByZero\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "DivideByZero",
          "package": "base",
          "partial": "Divide By Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:DivideByZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "ErrorCall",
          "package": "base",
          "signature": "ErrorCall String",
          "source": "src/GHC-Exception.html#ErrorCall",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:ErrorCall\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:ErrorCall\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "ErrorCall",
          "package": "base",
          "partial": "Error Call",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:ErrorCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe program's heap is reaching its limit, and\n the program should take action to reduce the amount of\n live data it has. Notes:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e It is undefined which thread receives this exception.\n\u003c/li\u003e\u003cli\u003e GHC currently does not throw \u003ccode\u003e\u003ca\u003eHeapOverflow\u003c/a\u003e\u003c/code\u003e exceptions.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "HeapOverflow",
          "package": "base",
          "signature": "HeapOverflow",
          "source": "src/GHC-IO-Exception.html#AsyncException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:HeapOverflow\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:HeapOverflow\"]"
        },
        "index": {
          "description": "The program heap is reaching its limit and the program should take action to reduce the amount of live data it has Notes It is undefined which thread receives this exception GHC currently does not throw HeapOverflow exceptions",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "HeapOverflow",
          "package": "base",
          "partial": "Heap Overflow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:HeapOverflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn attempt was made to index an array outside\n its declared bounds.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "IndexOutOfBounds",
          "package": "base",
          "signature": "IndexOutOfBounds String",
          "source": "src/GHC-IO-Exception.html#ArrayException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:IndexOutOfBounds\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:IndexOutOfBounds\"]"
        },
        "index": {
          "description": "An attempt was made to index an array outside its declared bounds",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "IndexOutOfBounds",
          "package": "base",
          "partial": "Index Out Of Bounds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:IndexOutOfBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "LossOfPrecision",
          "package": "base",
          "signature": "LossOfPrecision",
          "source": "src/GHC-Exception.html#ArithException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:LossOfPrecision\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:LossOfPrecision\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "LossOfPrecision",
          "package": "base",
          "partial": "Loss Of Precision",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:LossOfPrecision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe state during \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e: asynchronous exceptions are masked, but blocking operations may still be interrupted\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "MaskedInterruptible",
          "package": "base",
          "signature": "MaskedInterruptible",
          "source": "src/GHC-IO.html#MaskingState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:MaskedInterruptible\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:MaskedInterruptible\"]"
        },
        "index": {
          "description": "the state during mask asynchronous exceptions are masked but blocking operations may still be interrupted",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "MaskedInterruptible",
          "package": "base",
          "partial": "Masked Interruptible",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:MaskedInterruptible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe state during \u003ccode\u003e\u003ca\u003euninterruptibleMask\u003c/a\u003e\u003c/code\u003e: asynchronous exceptions are masked, and blocking operations may not be interrupted\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "MaskedUninterruptible",
          "package": "base",
          "signature": "MaskedUninterruptible",
          "source": "src/GHC-IO.html#MaskingState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:MaskedUninterruptible\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:MaskedUninterruptible\"]"
        },
        "index": {
          "description": "the state during uninterruptibleMask asynchronous exceptions are masked and blocking operations may not be interrupted",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "MaskedUninterruptible",
          "package": "base",
          "partial": "Masked Uninterruptible",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:MaskedUninterruptible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "NestedAtomically",
          "package": "base",
          "signature": "NestedAtomically",
          "source": "src/Control-Exception-Base.html#NestedAtomically",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:NestedAtomically\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:NestedAtomically\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "NestedAtomically",
          "package": "base",
          "partial": "Nested Atomically",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:NestedAtomically"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "NoMethodError",
          "package": "base",
          "signature": "NoMethodError String",
          "source": "src/Control-Exception-Base.html#NoMethodError",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:NoMethodError\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:NoMethodError\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "NoMethodError",
          "package": "base",
          "partial": "No Method Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:NoMethodError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "NonTermination",
          "package": "base",
          "signature": "NonTermination",
          "source": "src/Control-Exception-Base.html#NonTermination",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:NonTermination\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:NonTermination\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "NonTermination",
          "package": "base",
          "partial": "Non Termination",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:NonTermination"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "Overflow",
          "package": "base",
          "signature": "Overflow",
          "source": "src/GHC-Exception.html#ArithException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:Overflow\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:Overflow\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "Overflow",
          "package": "base",
          "partial": "Overflow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:Overflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "PatternMatchFail",
          "package": "base",
          "signature": "PatternMatchFail String",
          "source": "src/Control-Exception-Base.html#PatternMatchFail",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:PatternMatchFail\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:PatternMatchFail\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "PatternMatchFail",
          "package": "base",
          "partial": "Pattern Match Fail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:PatternMatchFail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "RatioZeroDenominator",
          "package": "base",
          "signature": "RatioZeroDenominator",
          "source": "src/GHC-Exception.html#ArithException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:RatioZeroDenominator\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:RatioZeroDenominator\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "RatioZeroDenominator",
          "package": "base",
          "partial": "Ratio Zero Denominator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:RatioZeroDenominator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "RecConError",
          "package": "base",
          "signature": "RecConError String",
          "source": "src/Control-Exception-Base.html#RecConError",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:RecConError\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:RecConError\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "RecConError",
          "package": "base",
          "partial": "Rec Con Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:RecConError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "RecSelError",
          "package": "base",
          "signature": "RecSelError String",
          "source": "src/Control-Exception-Base.html#RecSelError",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:RecSelError\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:RecSelError\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "RecSelError",
          "package": "base",
          "partial": "Rec Sel Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:RecSelError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "RecUpdError",
          "package": "base",
          "signature": "RecUpdError String",
          "source": "src/Control-Exception-Base.html#RecUpdError",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:RecUpdError\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:RecUpdError\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "RecUpdError",
          "package": "base",
          "partial": "Rec Upd Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:RecUpdError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "SomeException",
          "package": "base",
          "signature": "SomeException e",
          "source": "src/GHC-Exception.html#SomeException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:SomeException\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:SomeException\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "SomeException",
          "package": "base",
          "partial": "Some Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:SomeException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current thread's stack exceeded its limit.\n Since an exception has been raised, the thread's stack\n will certainly be below its limit again, but the\n programmer should take remedial action\n immediately.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "StackOverflow",
          "package": "base",
          "signature": "StackOverflow",
          "source": "src/GHC-IO-Exception.html#AsyncException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:StackOverflow\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:StackOverflow\"]"
        },
        "index": {
          "description": "The current thread stack exceeded its limit Since an exception has been raised the thread stack will certainly be below its limit again but the programmer should take remedial action immediately",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "StackOverflow",
          "package": "base",
          "partial": "Stack Overflow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:StackOverflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis exception is raised by another thread\n calling \u003ccode\u003e\u003ca\u003ekillThread\u003c/a\u003e\u003c/code\u003e, or by the system\n if it needs to terminate the thread for some\n reason.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "ThreadKilled",
          "package": "base",
          "signature": "ThreadKilled",
          "source": "src/GHC-IO-Exception.html#AsyncException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:ThreadKilled\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:ThreadKilled\"]"
        },
        "index": {
          "description": "This exception is raised by another thread calling killThread or by the system if it needs to terminate the thread for some reason",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "ThreadKilled",
          "package": "base",
          "partial": "Thread Killed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:ThreadKilled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn attempt was made to evaluate an element of an\n array that had not been initialized.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "UndefinedElement",
          "package": "base",
          "signature": "UndefinedElement String",
          "source": "src/GHC-IO-Exception.html#ArrayException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:UndefinedElement\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:UndefinedElement\"]"
        },
        "index": {
          "description": "An attempt was made to evaluate an element of an array that had not been initialized",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "UndefinedElement",
          "package": "base",
          "partial": "Undefined Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:UndefinedElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "Underflow",
          "package": "base",
          "signature": "Underflow",
          "source": "src/GHC-Exception.html#ArithException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:Underflow\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:Underflow\"]"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "Underflow",
          "package": "base",
          "partial": "Underflow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:Underflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003easynchronous exceptions are unmasked (the normal state)\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "Unmasked",
          "package": "base",
          "signature": "Unmasked",
          "source": "src/GHC-IO.html#MaskingState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:Unmasked\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:Unmasked\"]"
        },
        "index": {
          "description": "asynchronous exceptions are unmasked the normal state",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "Unmasked",
          "package": "base",
          "partial": "Unmasked",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:Unmasked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis exception is raised by default in the main thread of\n the program when the user requests to terminate the program\n via the usual mechanism(s) (e.g. Control-C in the console).\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "UserInterrupt",
          "package": "base",
          "signature": "UserInterrupt",
          "source": "src/GHC-IO-Exception.html#AsyncException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:UserInterrupt\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:UserInterrupt\"]"
        },
        "index": {
          "description": "This exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism e.g Control-C in the console",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "UserInterrupt",
          "package": "base",
          "partial": "User Interrupt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:UserInterrupt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Base",
          "name": "absentError",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Addr-35-\"\u003eAddr# -\u003e a",
          "source": "src/Control-Exception-Base.html#absentError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "absentError",
          "normalized": "a b c d GHC Prim.html #t Addr Addr #-\u003ee",
          "package": "base",
          "partial": "Error",
          "signature": "packages archive doc html GHC Prim.html #t Addr Addr #-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:absentError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the first argument evaluates to \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, then the result is the\n second argument.  Otherwise an \u003ccode\u003eAssertionFailed\u003c/code\u003e exception is raised,\n containing a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e with the source file and line number of the\n call to \u003ccode\u003e\u003ca\u003eassert\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eAssertions can normally be turned on or off with a compiler flag\n (for GHC, assertions are normally on unless optimisation is turned on \n with \u003ccode\u003e-O\u003c/code\u003e or the \u003ccode\u003e-fignore-asserts\u003c/code\u003e\n option is given).  When assertions are turned off, the first\n argument to \u003ccode\u003e\u003ca\u003eassert\u003c/a\u003e\u003c/code\u003e is ignored, and the second argument is\n returned as the result.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "assert",
          "package": "base",
          "signature": "Bool -\u003e a -\u003e a",
          "source": "src/GHC-Base.html#assert",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:assert\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:assert\"]"
        },
        "index": {
          "description": "If the first argument evaluates to True then the result is the second argument Otherwise an AssertionFailed exception is raised containing String with the source file and line number of the call to assert Assertions can normally be turned on or off with compiler flag for GHC assertions are normally on unless optimisation is turned on with or the fignore-asserts option is given When assertions are turned off the first argument to assert is ignored and the second argument is returned as the result",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "assert",
          "normalized": "Bool-\u003ea-\u003ea",
          "package": "base",
          "signature": "Bool-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:assert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use Control.Exception.mask instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eNote: this function is deprecated, please use \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e\u003cp\u003eApplying \u003ccode\u003e\u003ca\u003eblock\u003c/a\u003e\u003c/code\u003e to a computation will\n execute that computation with asynchronous exceptions\n \u003cem\u003eblocked\u003c/em\u003e.  That is, any thread which\n attempts to raise an exception in the current thread with \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e will be\n blocked until asynchronous exceptions are unblocked again.  There's\n no need to worry about re-enabling asynchronous exceptions; that is\n done automatically on exiting the scope of\n \u003ccode\u003e\u003ca\u003eblock\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThreads created by \u003ccode\u003e\u003ca\u003eforkIO\u003c/a\u003e\u003c/code\u003e inherit the blocked\n state from the parent; that is, to start a thread in blocked mode,\n use \u003ccode\u003eblock $ forkIO ...\u003c/code\u003e.  This is particularly useful if you need to\n establish an exception handler in the forked thread before any\n asynchronous exceptions are received.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "block",
          "package": "base",
          "signature": "IO a -\u003e IO a",
          "source": "src/GHC-IO.html#block",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:block\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:block\"]"
        },
        "index": {
          "description": "Deprecated use Control.Exception.mask instead Note this function is deprecated please use mask instead Applying block to computation will execute that computation with asynchronous exceptions blocked That is any thread which attempts to raise an exception in the current thread with throwTo will be blocked until asynchronous exceptions are unblocked again There no need to worry about re-enabling asynchronous exceptions that is done automatically on exiting the scope of block Threads created by forkIO inherit the blocked state from the parent that is to start thread in blocked mode use block forkIO This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "block",
          "normalized": "IO a-\u003eIO a",
          "package": "base",
          "signature": "IO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:block"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use Control.Exception.getMaskingState instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003ereturns True if asynchronous exceptions are blocked in the\n current thread.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "blocked",
          "package": "base",
          "signature": "IO Bool",
          "source": "src/GHC-IO.html#blocked",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:blocked\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:blocked\"]"
        },
        "index": {
          "description": "Deprecated use Control.Exception.getMaskingState instead returns True if asynchronous exceptions are blocked in the current thread",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "blocked",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:blocked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen you want to acquire a resource, do some work with it, and\n then release the resource, it is a good idea to use \u003ccode\u003e\u003ca\u003ebracket\u003c/a\u003e\u003c/code\u003e,\n because \u003ccode\u003e\u003ca\u003ebracket\u003c/a\u003e\u003c/code\u003e will install the necessary exception handler to\n release the resource in the event that an exception is raised\n during the computation.  If an exception is raised, then \u003ccode\u003e\u003ca\u003ebracket\u003c/a\u003e\u003c/code\u003e will\n re-raise the exception (after performing the release).\n\u003c/p\u003e\u003cp\u003eA common example is opening a file:\n\u003c/p\u003e\u003cpre\u003e bracket\n   (openFile \"filename\" ReadMode)\n   (hClose)\n   (\\fileHandle -\u003e do { ... })\n\u003c/pre\u003e\u003cp\u003eThe arguments to \u003ccode\u003e\u003ca\u003ebracket\u003c/a\u003e\u003c/code\u003e are in this order so that we can partially apply\n it, e.g.:\n\u003c/p\u003e\u003cpre\u003e withFile name mode = bracket (openFile name mode) hClose\n\u003c/pre\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "bracket",
          "package": "base",
          "signature": "IO a-\u003e (a -\u003e IO b)-\u003e (a -\u003e IO c)-\u003e IO c",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:bracket\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:bracket\"]"
        },
        "index": {
          "description": "When you want to acquire resource do some work with it and then release the resource it is good idea to use bracket because bracket will install the necessary exception handler to release the resource in the event that an exception is raised during the computation If an exception is raised then bracket will re-raise the exception after performing the release common example is opening file bracket openFile filename ReadMode hClose fileHandle do The arguments to bracket are in this order so that we can partially apply it e.g withFile name mode bracket openFile name mode hClose",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "bracket",
          "normalized": "IO a-\u003e(a-\u003eIO b)-\u003e(a-\u003eIO c)-\u003eIO c",
          "package": "base",
          "signature": "IO a-\u003e(a-\u003eIO b)-\u003e(a-\u003eIO c)-\u003eIO c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:bracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ebracket\u003c/a\u003e\u003c/code\u003e, but only performs the final action if there was an\n exception raised by the in-between computation.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "bracketOnError",
          "package": "base",
          "signature": "IO a-\u003e (a -\u003e IO b)-\u003e (a -\u003e IO c)-\u003e IO c",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:bracketOnError\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:bracketOnError\"]"
        },
        "index": {
          "description": "Like bracket but only performs the final action if there was an exception raised by the in-between computation",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "bracketOnError",
          "normalized": "IO a-\u003e(a-\u003eIO b)-\u003e(a-\u003eIO c)-\u003eIO c",
          "package": "base",
          "partial": "On Error",
          "signature": "IO a-\u003e(a-\u003eIO b)-\u003e(a-\u003eIO c)-\u003eIO c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:bracketOnError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003ebracket\u003c/a\u003e\u003c/code\u003e where the return value from the first computation\n is not required.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "bracket_",
          "package": "base",
          "signature": "IO a -\u003e IO b -\u003e IO c -\u003e IO c",
          "source": "src/Control-Exception-Base.html#bracket_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:bracket_\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:bracket_\"]"
        },
        "index": {
          "description": "variant of bracket where the return value from the first computation is not required",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "bracket_",
          "normalized": "IO a-\u003eIO b-\u003eIO c-\u003eIO c",
          "package": "base",
          "signature": "IO a-\u003eIO b-\u003eIO c-\u003eIO c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:bracket_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the simplest of the exception-catching functions.  It\n takes a single argument, runs it, and if an exception is raised\n the \"handler\" is executed, with the value of the exception passed as an\n argument.  Otherwise, the result is returned as normal.  For example:\n\u003c/p\u003e\u003cpre\u003e   catch (readFile f)\n         (\\e -\u003e do let err = show (e :: IOException)\n                   hPutStr stderr (\"Warning: Couldn't open \" ++ f ++ \": \" ++ err)\n                   return \"\")\n\u003c/pre\u003e\u003cp\u003eNote that we have to give a type signature to \u003ccode\u003ee\u003c/code\u003e, or the program\n will not typecheck as the type is ambiguous. While it is possible\n to catch exceptions of any type, see the section \"Catching all\n exceptions\" (in \u003ca\u003eControl.Exception\u003c/a\u003e) for an explanation of the problems with doing so.\n\u003c/p\u003e\u003cp\u003eFor catching exceptions in pure (non-\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e) expressions, see the\n function \u003ccode\u003e\u003ca\u003eevaluate\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that due to Haskell's unspecified evaluation order, an\n expression may throw one of several possible exceptions: consider\n the expression \u003ccode\u003e(error \"urk\") + (1 `div` 0)\u003c/code\u003e.  Does\n the expression throw\n \u003ccode\u003eErrorCall \"urk\"\u003c/code\u003e, or \u003ccode\u003eDivideByZero\u003c/code\u003e?\n\u003c/p\u003e\u003cp\u003eThe answer is \"it might throw either\"; the choice is\n non-deterministic. If you are catching any type of exception then you\n might catch either. If you are calling \u003ccode\u003ecatch\u003c/code\u003e with type\n \u003ccode\u003eIO Int -\u003e (ArithException -\u003e IO Int) -\u003e IO Int\u003c/code\u003e then the handler may\n get run with \u003ccode\u003eDivideByZero\u003c/code\u003e as an argument, or an \u003ccode\u003eErrorCall \"urk\"\u003c/code\u003e\n exception may be propogated further up. If you call it again, you\n might get a the opposite behaviour. This is ok, because \u003ccode\u003e\u003ca\u003ecatch\u003c/a\u003e\u003c/code\u003e is an\n \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e computation.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "catch",
          "package": "base",
          "signature": "IO a-\u003e (e -\u003e IO a)-\u003e IO a",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:catch\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:catch\"]"
        },
        "index": {
          "description": "This is the simplest of the exception-catching functions It takes single argument runs it and if an exception is raised the handler is executed with the value of the exception passed as an argument Otherwise the result is returned as normal For example catch readFile do let err show IOException hPutStr stderr Warning Couldn open err return Note that we have to give type signature to or the program will not typecheck as the type is ambiguous While it is possible to catch exceptions of any type see the section Catching all exceptions in Control.Exception for an explanation of the problems with doing so For catching exceptions in pure non IO expressions see the function evaluate Note that due to Haskell unspecified evaluation order an expression may throw one of several possible exceptions consider the expression error urk div Does the expression throw ErrorCall urk or DivideByZero The answer is it might throw either the choice is non-deterministic If you are catching any type of exception then you might catch either If you are calling catch with type IO Int ArithException IO Int IO Int then the handler may get run with DivideByZero as an argument or an ErrorCall urk exception may be propogated further up If you call it again you might get the opposite behaviour This is ok because catch is an IO computation",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "catch",
          "normalized": "IO a-\u003e(b-\u003eIO a)-\u003eIO a",
          "package": "base",
          "signature": "IO a-\u003e(e-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:catch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003ecatchJust\u003c/a\u003e\u003c/code\u003e is like \u003ccode\u003e\u003ca\u003ecatch\u003c/a\u003e\u003c/code\u003e, but it takes an extra\n argument which is an \u003cem\u003eexception predicate\u003c/em\u003e, a function which\n selects which type of exceptions we're interested in.\n\u003c/p\u003e\u003cpre\u003e catchJust (\\e -\u003e if isDoesNotExistErrorType (ioeGetErrorType e) then Just () else Nothing)\n           (readFile f)\n           (\\_ -\u003e do hPutStrLn stderr (\"No such file: \" ++ show f)\n                     return \"\")\n\u003c/pre\u003e\u003cp\u003eAny other exceptions which are not matched by the predicate\n are re-raised, and may be caught by an enclosing\n \u003ccode\u003e\u003ca\u003ecatch\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ecatchJust\u003c/a\u003e\u003c/code\u003e, etc.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "catchJust",
          "package": "base",
          "signature": "(e -\u003e Maybe b)-\u003e IO a-\u003e (b -\u003e IO a)-\u003e IO a",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:catchJust\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:catchJust\"]"
        },
        "index": {
          "description": "The function catchJust is like catch but it takes an extra argument which is an exception predicate function which selects which type of exceptions we re interested in catchJust if isDoesNotExistErrorType ioeGetErrorType then Just else Nothing readFile do hPutStrLn stderr No such file show return Any other exceptions which are not matched by the predicate are re-raised and may be caught by an enclosing catch catchJust etc",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "catchJust",
          "normalized": "(a-\u003eMaybe b)-\u003eIO c-\u003e(b-\u003eIO c)-\u003eIO c",
          "package": "base",
          "partial": "Just",
          "signature": "(e-\u003eMaybe b)-\u003eIO a-\u003e(b-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:catchJust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForces its argument to be evaluated to weak head normal form when\n the resultant \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e action is executed. It can be used to order\n evaluation with respect to other \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e operations; its semantics are\n given by\n\u003c/p\u003e\u003cpre\u003e   evaluate x `seq` y    ==\u003e  y\n   evaluate x `catch` f  ==\u003e  (return $! x) `catch` f\n   evaluate x \u003e\u003e= f      ==\u003e  (return $! x) \u003e\u003e= f\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e the first equation implies that \u003ccode\u003e(evaluate x)\u003c/code\u003e is \u003cem\u003enot\u003c/em\u003e the\n same as \u003ccode\u003e(return $! x)\u003c/code\u003e.  A correct definition is\n\u003c/p\u003e\u003cpre\u003e   evaluate x = (return $! x) \u003e\u003e= return\n\u003c/pre\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "evaluate",
          "package": "base",
          "signature": "a -\u003e IO a",
          "source": "src/GHC-IO.html#evaluate",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:evaluate\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:evaluate\"]"
        },
        "index": {
          "description": "Forces its argument to be evaluated to weak head normal form when the resultant IO action is executed It can be used to order evaluation with respect to other IO operations its semantics are given by evaluate seq evaluate catch return catch evaluate return Note the first equation implies that evaluate is not the same as return correct definition is evaluate return return",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "evaluate",
          "normalized": "a-\u003eIO a",
          "package": "base",
          "signature": "a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:evaluate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA specialised variant of \u003ccode\u003e\u003ca\u003ebracket\u003c/a\u003e\u003c/code\u003e with just a computation to run\n afterward.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "finally",
          "package": "base",
          "signature": "IO a-\u003e IO b-\u003e IO a",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:finally\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:finally\"]"
        },
        "index": {
          "description": "specialised variant of bracket with just computation to run afterward",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "finally",
          "normalized": "IO a-\u003eIO b-\u003eIO a",
          "package": "base",
          "signature": "IO a-\u003eIO b-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:finally"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Base",
          "name": "fromException",
          "package": "base",
          "signature": "SomeException -\u003e Maybe e",
          "source": "src/GHC-Exception.html#fromException",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "fromException",
          "normalized": "SomeException-\u003eMaybe a",
          "package": "base",
          "partial": "Exception",
          "signature": "SomeException-\u003eMaybe e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:fromException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the \u003ccode\u003e\u003ca\u003eMaskingState\u003c/a\u003e\u003c/code\u003e for the current thread.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "getMaskingState",
          "package": "base",
          "signature": "IO MaskingState",
          "source": "src/GHC-IO.html#getMaskingState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:getMaskingState\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:getMaskingState\"]"
        },
        "index": {
          "description": "Returns the MaskingState for the current thread",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "getMaskingState",
          "package": "base",
          "partial": "Masking State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:getMaskingState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003ecatch\u003c/a\u003e\u003c/code\u003e with the arguments swapped around; useful in\n situations where the code for the handler is shorter.  For example:\n\u003c/p\u003e\u003cpre\u003e   do handle (\\NonTermination -\u003e exitWith (ExitFailure 1)) $\n      ...\n\u003c/pre\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "handle",
          "package": "base",
          "signature": "(e -\u003e IO a) -\u003e IO a -\u003e IO a",
          "source": "src/Control-Exception-Base.html#handle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:handle\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:handle\"]"
        },
        "index": {
          "description": "version of catch with the arguments swapped around useful in situations where the code for the handler is shorter For example do handle NonTermination exitWith ExitFailure",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "handle",
          "normalized": "(a-\u003eIO b)-\u003eIO b-\u003eIO b",
          "package": "base",
          "signature": "(e-\u003eIO a)-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:handle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003ecatchJust\u003c/a\u003e\u003c/code\u003e with the arguments swapped around (see\n \u003ccode\u003e\u003ca\u003ehandle\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "handleJust",
          "package": "base",
          "signature": "(e -\u003e Maybe b) -\u003e (b -\u003e IO a) -\u003e IO a -\u003e IO a",
          "source": "src/Control-Exception-Base.html#handleJust",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:handleJust\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:handleJust\"]"
        },
        "index": {
          "description": "version of catchJust with the arguments swapped around see handle",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "handleJust",
          "normalized": "(a-\u003eMaybe b)-\u003e(b-\u003eIO c)-\u003eIO c-\u003eIO c",
          "package": "base",
          "partial": "Just",
          "signature": "(e-\u003eMaybe b)-\u003e(b-\u003eIO a)-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:handleJust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e in the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\",\"Prelude\",\"System.IO.Error\"]",
          "name": "ioError",
          "package": "base",
          "signature": "IOError -\u003e IO a",
          "source": "src/GHC-IO-Exception.html#ioError",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:ioError\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:ioError\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:ioError\",\"http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:ioError\"]"
        },
        "index": {
          "description": "Raise an IOError in the IO monad",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "ioError",
          "normalized": "IOError-\u003eIO a",
          "package": "base",
          "partial": "Error",
          "signature": "IOError-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:ioError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Base",
          "name": "irrefutPatError",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Addr-35-\"\u003eAddr# -\u003e a",
          "source": "src/Control-Exception-Base.html#irrefutPatError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "irrefutPatError",
          "normalized": "a b c d GHC Prim.html #t Addr Addr #-\u003ee",
          "package": "base",
          "partial": "Pat Error",
          "signature": "packages archive doc html GHC Prim.html #t Addr Addr #-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:irrefutPatError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function maps one exception into another as proposed in the\n paper \"A semantics for imprecise exceptions\".\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "mapException",
          "package": "base",
          "signature": "(e1 -\u003e e2) -\u003e a -\u003e a",
          "source": "src/Control-Exception-Base.html#mapException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:mapException\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:mapException\"]"
        },
        "index": {
          "description": "This function maps one exception into another as proposed in the paper semantics for imprecise exceptions",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "mapException",
          "normalized": "(a-\u003ea)-\u003eb-\u003eb",
          "package": "base",
          "partial": "Exception",
          "signature": "(e-\u003ee)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:mapException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExecutes an IO computation with asynchronous\n exceptions \u003cem\u003emasked\u003c/em\u003e.  That is, any thread which attempts to raise\n an exception in the current thread with \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e\n will be blocked until asynchronous exceptions are unmasked again.\n\u003c/p\u003e\u003cp\u003eThe argument passed to \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e is a function that takes as its\n argument another function, which can be used to restore the\n prevailing masking state within the context of the masked\n computation.  For example, a common way to use \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e is to protect\n the acquisition of a resource:\n\u003c/p\u003e\u003cpre\u003e mask $ \\restore -\u003e do\n     x \u003c- acquire\n     restore (do_something_with x) `onException` release\n     release\n\u003c/pre\u003e\u003cp\u003eThis code guarantees that \u003ccode\u003eacquire\u003c/code\u003e is paired with \u003ccode\u003erelease\u003c/code\u003e, by masking\n asynchronous exceptions for the critical parts. (Rather than write\n this code yourself, it would be better to use\n \u003ccode\u003e\u003ca\u003ebracket\u003c/a\u003e\u003c/code\u003e which abstracts the general pattern).\n\u003c/p\u003e\u003cp\u003eNote that the \u003ccode\u003erestore\u003c/code\u003e action passed to the argument to \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e\n does not necessarily unmask asynchronous exceptions, it just\n restores the masking state to that of the enclosing context.  Thus\n if asynchronous exceptions are already masked, \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e cannot be used\n to unmask exceptions again.  This is so that if you call a library function\n with exceptions masked, you can be sure that the library call will not be\n able to unmask exceptions again.  If you are writing library code and need\n to use asynchronous exceptions, the only way is to create a new thread;\n see \u003ccode\u003e\u003ca\u003eforkIOWithUnmask\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eAsynchronous exceptions may still be received while in the masked\n state if the masked thread \u003cem\u003eblocks\u003c/em\u003e in certain ways; see\n \u003ca\u003eControl.Exception\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eThreads created by \u003ccode\u003e\u003ca\u003eforkIO\u003c/a\u003e\u003c/code\u003e inherit the masked\n state from the parent; that is, to start a thread in blocked mode,\n use \u003ccode\u003emask_ $ forkIO ...\u003c/code\u003e.  This is particularly useful if you need\n to establish an exception handler in the forked thread before any\n asynchronous exceptions are received.  To create a a new thread in\n an unmasked state use \u003ccode\u003e\u003ca\u003eforkIOUnmasked\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "mask",
          "package": "base",
          "signature": "((forall a.  IO a -\u003e IO a) -\u003e IO b) -\u003e IO b",
          "source": "src/GHC-IO.html#mask",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:mask\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:mask\"]"
        },
        "index": {
          "description": "Executes an IO computation with asynchronous exceptions masked That is any thread which attempts to raise an exception in the current thread with throwTo will be blocked until asynchronous exceptions are unmasked again The argument passed to mask is function that takes as its argument another function which can be used to restore the prevailing masking state within the context of the masked computation For example common way to use mask is to protect the acquisition of resource mask restore do acquire restore do something with onException release release This code guarantees that acquire is paired with release by masking asynchronous exceptions for the critical parts Rather than write this code yourself it would be better to use bracket which abstracts the general pattern Note that the restore action passed to the argument to mask does not necessarily unmask asynchronous exceptions it just restores the masking state to that of the enclosing context Thus if asynchronous exceptions are already masked mask cannot be used to unmask exceptions again This is so that if you call library function with exceptions masked you can be sure that the library call will not be able to unmask exceptions again If you are writing library code and need to use asynchronous exceptions the only way is to create new thread see forkIOWithUnmask Asynchronous exceptions may still be received while in the masked state if the masked thread blocks in certain ways see Control.Exception Threads created by forkIO inherit the masked state from the parent that is to start thread in blocked mode use mask forkIO This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received To create new thread in an unmasked state use forkIOUnmasked",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "mask",
          "normalized": "((a b IO c-\u003eIO c)-\u003eIO d)-\u003eIO d",
          "package": "base",
          "signature": "((forall a. IO a-\u003eIO a)-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:mask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e, but does not pass a \u003ccode\u003erestore\u003c/code\u003e action to the argument.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "mask_",
          "package": "base",
          "signature": "IO a -\u003e IO a",
          "source": "src/GHC-IO.html#mask_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:mask_\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:mask_\"]"
        },
        "index": {
          "description": "Like mask but does not pass restore action to the argument",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "mask_",
          "normalized": "IO a-\u003eIO a",
          "package": "base",
          "signature": "IO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:mask_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Base",
          "name": "nestedAtomically",
          "package": "base",
          "signature": "SomeException",
          "source": "src/Control-Exception-Base.html#nestedAtomically",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "nestedAtomically",
          "package": "base",
          "partial": "Atomically",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:nestedAtomically"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Base",
          "name": "noMethodBindingError",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Addr-35-\"\u003eAddr# -\u003e a",
          "source": "src/Control-Exception-Base.html#noMethodBindingError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "noMethodBindingError",
          "normalized": "a b c d GHC Prim.html #t Addr Addr #-\u003ee",
          "package": "base",
          "partial": "Method Binding Error",
          "signature": "packages archive doc html GHC Prim.html #t Addr Addr #-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:noMethodBindingError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Base",
          "name": "nonExhaustiveGuardsError",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Addr-35-\"\u003eAddr# -\u003e a",
          "source": "src/Control-Exception-Base.html#nonExhaustiveGuardsError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "nonExhaustiveGuardsError",
          "normalized": "a b c d GHC Prim.html #t Addr Addr #-\u003ee",
          "package": "base",
          "partial": "Exhaustive Guards Error",
          "signature": "packages archive doc html GHC Prim.html #t Addr Addr #-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:nonExhaustiveGuardsError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Base",
          "name": "nonTermination",
          "package": "base",
          "signature": "SomeException",
          "source": "src/Control-Exception-Base.html#nonTermination",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "nonTermination",
          "package": "base",
          "partial": "Termination",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:nonTermination"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003efinally\u003c/a\u003e\u003c/code\u003e, but only performs the final action if there was an\n exception raised by the computation.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "onException",
          "package": "base",
          "signature": "IO a -\u003e IO b -\u003e IO a",
          "source": "src/Control-Exception-Base.html#onException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:onException\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:onException\"]"
        },
        "index": {
          "description": "Like finally but only performs the final action if there was an exception raised by the computation",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "onException",
          "normalized": "IO a-\u003eIO b-\u003eIO a",
          "package": "base",
          "partial": "Exception",
          "signature": "IO a-\u003eIO b-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:onException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Base",
          "name": "patError",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Addr-35-\"\u003eAddr# -\u003e a",
          "source": "src/Control-Exception-Base.html#patError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "patError",
          "normalized": "a b c d GHC Prim.html #t Addr Addr #-\u003ee",
          "package": "base",
          "partial": "Error",
          "signature": "packages archive doc html GHC Prim.html #t Addr Addr #-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:patError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Base",
          "name": "recConError",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Addr-35-\"\u003eAddr# -\u003e a",
          "source": "src/Control-Exception-Base.html#recConError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "recConError",
          "normalized": "a b c d GHC Prim.html #t Addr Addr #-\u003ee",
          "package": "base",
          "partial": "Con Error",
          "signature": "packages archive doc html GHC Prim.html #t Addr Addr #-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:recConError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Base",
          "name": "recSelError",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Addr-35-\"\u003eAddr# -\u003e a",
          "source": "src/Control-Exception-Base.html#recSelError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "recSelError",
          "normalized": "a b c d GHC Prim.html #t Addr Addr #-\u003ee",
          "package": "base",
          "partial": "Sel Error",
          "signature": "packages archive doc html GHC Prim.html #t Addr Addr #-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:recSelError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Base",
          "name": "runtimeError",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Addr-35-\"\u003eAddr# -\u003e a",
          "source": "src/Control-Exception-Base.html#runtimeError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "runtimeError",
          "normalized": "a b c d GHC Prim.html #t Addr Addr #-\u003ee",
          "package": "base",
          "partial": "Error",
          "signature": "packages archive doc html GHC Prim.html #t Addr Addr #-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:runtimeError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an exception.  Exceptions may be thrown from purely\n functional code, but may only be caught within the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "throw",
          "package": "base",
          "signature": "e -\u003e a",
          "source": "src/GHC-Exception.html#throw",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:throw\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:throw\"]"
        },
        "index": {
          "description": "Throw an exception Exceptions may be thrown from purely functional code but may only be caught within the IO monad",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "throw",
          "normalized": "a-\u003eb",
          "package": "base",
          "signature": "e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:throw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003ethrow\u003c/a\u003e\u003c/code\u003e that can only be used within the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad.\n\u003c/p\u003e\u003cp\u003eAlthough \u003ccode\u003e\u003ca\u003ethrowIO\u003c/a\u003e\u003c/code\u003e has a type that is an instance of the type of \u003ccode\u003e\u003ca\u003ethrow\u003c/a\u003e\u003c/code\u003e, the\n two functions are subtly different:\n\u003c/p\u003e\u003cpre\u003e throw e   `seq` x  ===\u003e throw e\n throwIO e `seq` x  ===\u003e x\n\u003c/pre\u003e\u003cp\u003eThe first example will cause the exception \u003ccode\u003ee\u003c/code\u003e to be raised,\n whereas the second one won't.  In fact, \u003ccode\u003e\u003ca\u003ethrowIO\u003c/a\u003e\u003c/code\u003e will only cause\n an exception to be raised when it is used within the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad.\n The \u003ccode\u003e\u003ca\u003ethrowIO\u003c/a\u003e\u003c/code\u003e variant should be used in preference to \u003ccode\u003e\u003ca\u003ethrow\u003c/a\u003e\u003c/code\u003e to\n raise an exception within the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad because it guarantees\n ordering with respect to other \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e operations, whereas \u003ccode\u003e\u003ca\u003ethrow\u003c/a\u003e\u003c/code\u003e\n does not.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "throwIO",
          "package": "base",
          "signature": "e -\u003e IO a",
          "source": "src/GHC-IO.html#throwIO",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:throwIO\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:throwIO\"]"
        },
        "index": {
          "description": "variant of throw that can only be used within the IO monad Although throwIO has type that is an instance of the type of throw the two functions are subtly different throw seq throw throwIO seq The first example will cause the exception to be raised whereas the second one won In fact throwIO will only cause an exception to be raised when it is used within the IO monad The throwIO variant should be used in preference to throw to raise an exception within the IO monad because it guarantees ordering with respect to other IO operations whereas throw does not",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "throwIO",
          "normalized": "a-\u003eIO b",
          "package": "base",
          "partial": "IO",
          "signature": "e-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:throwIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Base",
          "name": "toException",
          "package": "base",
          "signature": "e -\u003e SomeException",
          "source": "src/GHC-Exception.html#toException",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "toException",
          "normalized": "a-\u003eSomeException",
          "package": "base",
          "partial": "Exception",
          "signature": "e-\u003eSomeException",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:toException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003ecatch\u003c/a\u003e\u003c/code\u003e, but returns an \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e result which is\n \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e a)\u003c/code\u003e if no exception of type \u003ccode\u003ee\u003c/code\u003e was raised, or \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e ex)\u003c/code\u003e\n if an exception of type \u003ccode\u003ee\u003c/code\u003e was raised and its value is \u003ccode\u003eex\u003c/code\u003e.\n If any other type of exception is raised than it will be propogated\n up to the next enclosing exception handler.\n\u003c/p\u003e\u003cpre\u003e  try a = catch (Right `liftM` a) (return . Left)\n\u003c/pre\u003e\u003cp\u003eNote that \u003ca\u003eSystem.IO.Error\u003c/a\u003e also exports a function called\n \u003ccode\u003e\u003ca\u003etry\u003c/a\u003e\u003c/code\u003e with a similar type to \u003ccode\u003e\u003ca\u003etry\u003c/a\u003e\u003c/code\u003e,\n except that it catches only the IO and user families of exceptions\n (as required by the Haskell 98 \u003ccode\u003eIO\u003c/code\u003e module).\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "try",
          "package": "base",
          "signature": "IO a -\u003e IO (Either e a)",
          "source": "src/Control-Exception-Base.html#try",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:try\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:try\"]"
        },
        "index": {
          "description": "Similar to catch but returns an Either result which is Right if no exception of type was raised or Left ex if an exception of type was raised and its value is ex If any other type of exception is raised than it will be propogated up to the next enclosing exception handler try catch Right liftM return Left Note that System.IO.Error also exports function called try with similar type to try except that it catches only the IO and user families of exceptions as required by the Haskell IO module",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "try",
          "normalized": "IO a-\u003eIO(Either b a)",
          "package": "base",
          "signature": "IO a-\u003eIO(Either e a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:try"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003etry\u003c/a\u003e\u003c/code\u003e that takes an exception predicate to select\n which exceptions are caught (c.f. \u003ccode\u003e\u003ca\u003ecatchJust\u003c/a\u003e\u003c/code\u003e).  If the exception\n does not match the predicate, it is re-thrown.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "tryJust",
          "package": "base",
          "signature": "(e -\u003e Maybe b) -\u003e IO a -\u003e IO (Either b a)",
          "source": "src/Control-Exception-Base.html#tryJust",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:tryJust\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:tryJust\"]"
        },
        "index": {
          "description": "variant of try that takes an exception predicate to select which exceptions are caught c.f catchJust If the exception does not match the predicate it is re-thrown",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "tryJust",
          "normalized": "(a-\u003eMaybe b)-\u003eIO c-\u003eIO(Either b c)",
          "package": "base",
          "partial": "Just",
          "signature": "(e-\u003eMaybe b)-\u003eIO a-\u003eIO(Either b a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:tryJust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use Control.Exception.mask instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eNote: this function is deprecated, please use \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e\u003cp\u003eTo re-enable asynchronous exceptions inside the scope of\n \u003ccode\u003e\u003ca\u003eblock\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eunblock\u003c/a\u003e\u003c/code\u003e can be\n used.  It scopes in exactly the same way, so on exit from\n \u003ccode\u003e\u003ca\u003eunblock\u003c/a\u003e\u003c/code\u003e asynchronous exception delivery will\n be disabled again.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "unblock",
          "package": "base",
          "signature": "IO a -\u003e IO a",
          "source": "src/GHC-IO.html#unblock",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:unblock\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:unblock\"]"
        },
        "index": {
          "description": "Deprecated use Control.Exception.mask instead Note this function is deprecated please use mask instead To re-enable asynchronous exceptions inside the scope of block unblock can be used It scopes in exactly the same way so on exit from unblock asynchronous exception delivery will be disabled again",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "unblock",
          "normalized": "IO a-\u003eIO a",
          "package": "base",
          "signature": "IO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:unblock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e, but the masked computation is not interruptible (see\n \u003ca\u003eControl.Exception\u003c/a\u003e).  THIS SHOULD BE USED WITH\n GREAT CARE, because if a thread executing in \u003ccode\u003e\u003ca\u003euninterruptibleMask\u003c/a\u003e\u003c/code\u003e\n blocks for any reason, then the thread (and possibly the program,\n if this is the main thread) will be unresponsive and unkillable.\n This function should only be necessary if you need to mask\n exceptions around an interruptible operation, and you can guarantee\n that the interruptible operation will only block for a short period\n of time.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "uninterruptibleMask",
          "package": "base",
          "signature": "((forall a.  IO a -\u003e IO a) -\u003e IO b) -\u003e IO b",
          "source": "src/GHC-IO.html#uninterruptibleMask",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:uninterruptibleMask\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:uninterruptibleMask\"]"
        },
        "index": {
          "description": "Like mask but the masked computation is not interruptible see Control.Exception THIS SHOULD BE USED WITH GREAT CARE because if thread executing in uninterruptibleMask blocks for any reason then the thread and possibly the program if this is the main thread will be unresponsive and unkillable This function should only be necessary if you need to mask exceptions around an interruptible operation and you can guarantee that the interruptible operation will only block for short period of time",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "uninterruptibleMask",
          "normalized": "((a b IO c-\u003eIO c)-\u003eIO d)-\u003eIO d",
          "package": "base",
          "partial": "Mask",
          "signature": "((forall a. IO a-\u003eIO a)-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:uninterruptibleMask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003euninterruptibleMask\u003c/a\u003e\u003c/code\u003e, but does not pass a \u003ccode\u003erestore\u003c/code\u003e action\n to the argument.\n\u003c/p\u003e",
          "module": "[\"Control.Exception.Base\",\"Control.Exception\"]",
          "name": "uninterruptibleMask_",
          "package": "base",
          "signature": "IO a -\u003e IO a",
          "source": "src/GHC-IO.html#uninterruptibleMask_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:uninterruptibleMask_\",\"http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:uninterruptibleMask_\"]"
        },
        "index": {
          "description": "Like uninterruptibleMask but does not pass restore action to the argument",
          "hierarchy": "Control Exception Base",
          "module": "Control.Exception.Base",
          "name": "uninterruptibleMask_",
          "normalized": "IO a-\u003eIO a",
          "package": "base",
          "partial": "Mask",
          "signature": "IO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception-Base.html#v:uninterruptibleMask_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides support for raising and catching both built-in\n and user-defined exceptions.\n\u003c/p\u003e\u003cp\u003eIn addition to exceptions thrown by \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e operations, exceptions may\n be thrown by pure code (imprecise exceptions) or by external events\n (asynchronous exceptions), but may only be caught in the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad.\n For more details, see:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003cem\u003eA semantics for imprecise exceptions\u003c/em\u003e, by Simon Peyton Jones,\n    Alastair Reid, Tony Hoare, Simon Marlow, Fergus Henderson,\n    in \u003cem\u003ePLDI'99\u003c/em\u003e.\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eAsynchronous exceptions in Haskell\u003c/em\u003e, by Simon Marlow, Simon Peyton\n    Jones, Andy Moran and John Reppy, in \u003cem\u003ePLDI'01\u003c/em\u003e.\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eAn Extensible Dynamically-Typed Hierarchy of Exceptions\u003c/em\u003e,\n    by Simon Marlow, in \u003cem\u003eHaskell '06\u003c/em\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Control.Exception",
          "name": "Exception",
          "package": "base",
          "source": "src/Control-Exception.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides support for raising and catching both built-in and user-defined exceptions In addition to exceptions thrown by IO operations exceptions may be thrown by pure code imprecise exceptions or by external events asynchronous exceptions but may only be caught in the IO monad For more details see semantics for imprecise exceptions by Simon Peyton Jones Alastair Reid Tony Hoare Simon Marlow Fergus Henderson in PLDI Asynchronous exceptions in Haskell by Simon Marlow Simon Peyton Jones Andy Moran and John Reppy in PLDI An Extensible Dynamically-Typed Hierarchy of Exceptions by Simon Marlow in Haskell",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "Exception",
          "package": "base",
          "partial": "Exception",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArithmetic exceptions.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "ArithException",
          "package": "base",
          "source": "src/GHC-Exception.html#ArithException",
          "type": "data"
        },
        "index": {
          "description": "Arithmetic exceptions",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "ArithException",
          "package": "base",
          "partial": "Arith Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:ArithException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExceptions generated by array operations\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "ArrayException",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#ArrayException",
          "type": "data"
        },
        "index": {
          "description": "Exceptions generated by array operations",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "ArrayException",
          "package": "base",
          "partial": "Array Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:ArrayException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eassert\u003c/a\u003e\u003c/code\u003e was applied to \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "AssertionFailed",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#AssertionFailed",
          "type": "data"
        },
        "index": {
          "description": "assert was applied to False",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "AssertionFailed",
          "package": "base",
          "partial": "Assertion Failed",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:AssertionFailed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAsynchronous exceptions.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "AsyncException",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#AsyncException",
          "type": "data"
        },
        "index": {
          "description": "Asynchronous exceptions",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "AsyncException",
          "package": "base",
          "partial": "Async Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:AsyncException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe thread is blocked on an \u003ccode\u003eMVar\u003c/code\u003e, but there are no other references\n to the \u003ccode\u003eMVar\u003c/code\u003e so it can't ever continue.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "BlockedIndefinitelyOnMVar",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#BlockedIndefinitelyOnMVar",
          "type": "data"
        },
        "index": {
          "description": "The thread is blocked on an MVar but there are no other references to the MVar so it can ever continue",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "BlockedIndefinitelyOnMVar",
          "package": "base",
          "partial": "Blocked Indefinitely On MVar",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:BlockedIndefinitelyOnMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe thread is waiting to retry an STM transaction, but there are no\n other references to any \u003ccode\u003eTVar\u003c/code\u003es involved, so it can't ever continue.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "BlockedIndefinitelyOnSTM",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#BlockedIndefinitelyOnSTM",
          "type": "data"
        },
        "index": {
          "description": "The thread is waiting to retry an STM transaction but there are no other references to any TVar involved so it can ever continue",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "BlockedIndefinitelyOnSTM",
          "package": "base",
          "partial": "Blocked Indefinitely On STM",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:BlockedIndefinitelyOnSTM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere are no runnable threads, so the program is deadlocked.\n The \u003ccode\u003eDeadlock\u003c/code\u003e exception is raised in the main thread only.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "Deadlock",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#Deadlock",
          "type": "data"
        },
        "index": {
          "description": "There are no runnable threads so the program is deadlocked The Deadlock exception is raised in the main thread only",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "Deadlock",
          "package": "base",
          "partial": "Deadlock",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:Deadlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is thrown when the user calls \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e. The \u003ccode\u003eString\u003c/code\u003e is the\n argument given to \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "ErrorCall",
          "package": "base",
          "source": "src/GHC-Exception.html#ErrorCall",
          "type": "data"
        },
        "index": {
          "description": "This is thrown when the user calls error The String is the argument given to error",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "ErrorCall",
          "package": "base",
          "partial": "Error Call",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:ErrorCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAny type that you wish to throw or catch as an exception must be an\ninstance of the \u003ccode\u003eException\u003c/code\u003e class. The simplest case is a new exception\ntype directly below the root:\n\u003c/p\u003e\u003cpre\u003e data MyException = ThisException | ThatException\n     deriving (Show, Typeable)\n\n instance Exception MyException\n\u003c/pre\u003e\u003cp\u003eThe default method definitions in the \u003ccode\u003eException\u003c/code\u003e class do what we need\nin this case. You can now throw and catch \u003ccode\u003eThisException\u003c/code\u003e and\n\u003ccode\u003eThatException\u003c/code\u003e as exceptions:\n\u003c/p\u003e\u003cpre\u003e\n*Main\u003e throw ThisException `catch` \\e -\u003e putStrLn (\"Caught \" ++ show (e :: MyException))\nCaught ThisException\n\u003c/pre\u003e\u003cp\u003eIn more complicated examples, you may wish to define a whole hierarchy\nof exceptions:\n\u003c/p\u003e\u003cpre\u003e ---------------------------------------------------------------------\n -- Make the root exception type for all the exceptions in a compiler\n\n data SomeCompilerException = forall e . Exception e =\u003e SomeCompilerException e\n     deriving Typeable\n\n instance Show SomeCompilerException where\n     show (SomeCompilerException e) = show e\n\n instance Exception SomeCompilerException\n\n compilerExceptionToException :: Exception e =\u003e e -\u003e SomeException\n compilerExceptionToException = toException . SomeCompilerException\n\n compilerExceptionFromException :: Exception e =\u003e SomeException -\u003e Maybe e\n compilerExceptionFromException x = do\n     SomeCompilerException a \u003c- fromException x\n     cast a\n\n ---------------------------------------------------------------------\n -- Make a subhierarchy for exceptions in the frontend of the compiler\n\n data SomeFrontendException = forall e . Exception e =\u003e SomeFrontendException e\n     deriving Typeable\n\n instance Show SomeFrontendException where\n     show (SomeFrontendException e) = show e\n\n instance Exception SomeFrontendException where\n     toException = compilerExceptionToException\n     fromException = compilerExceptionFromException\n\n frontendExceptionToException :: Exception e =\u003e e -\u003e SomeException\n frontendExceptionToException = toException . SomeFrontendException\n\n frontendExceptionFromException :: Exception e =\u003e SomeException -\u003e Maybe e\n frontendExceptionFromException x = do\n     SomeFrontendException a \u003c- fromException x\n     cast a\n\n ---------------------------------------------------------------------\n -- Make an exception type for a particular frontend compiler exception\n\n data MismatchedParentheses = MismatchedParentheses\n     deriving (Typeable, Show)\n\n instance Exception MismatchedParentheses where\n     toException   = frontendExceptionToException\n     fromException = frontendExceptionFromException\n\u003c/pre\u003e\u003cp\u003eWe can now catch a \u003ccode\u003eMismatchedParentheses\u003c/code\u003e exception as\n\u003ccode\u003eMismatchedParentheses\u003c/code\u003e, \u003ccode\u003eSomeFrontendException\u003c/code\u003e or\n\u003ccode\u003eSomeCompilerException\u003c/code\u003e, but not other types, e.g. \u003ccode\u003eIOException\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: MismatchedParentheses))\nCaught MismatchedParentheses\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: SomeFrontendException))\nCaught MismatchedParentheses\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: SomeCompilerException))\nCaught MismatchedParentheses\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: IOException))\n*** Exception: MismatchedParentheses\n\u003c/pre\u003e",
          "module": "Control.Exception",
          "name": "Exception",
          "package": "base",
          "source": "src/GHC-Exception.html#Exception",
          "type": "class"
        },
        "index": {
          "description": "Any type that you wish to throw or catch as an exception must be an instance of the Exception class The simplest case is new exception type directly below the root data MyException ThisException ThatException deriving Show Typeable instance Exception MyException The default method definitions in the Exception class do what we need in this case You can now throw and catch ThisException and ThatException as exceptions Main throw ThisException catch putStrLn Caught show MyException Caught ThisException In more complicated examples you may wish to define whole hierarchy of exceptions Make the root exception type for all the exceptions in compiler data SomeCompilerException forall Exception SomeCompilerException deriving Typeable instance Show SomeCompilerException where show SomeCompilerException show instance Exception SomeCompilerException compilerExceptionToException Exception SomeException compilerExceptionToException toException SomeCompilerException compilerExceptionFromException Exception SomeException Maybe compilerExceptionFromException do SomeCompilerException fromException cast Make subhierarchy for exceptions in the frontend of the compiler data SomeFrontendException forall Exception SomeFrontendException deriving Typeable instance Show SomeFrontendException where show SomeFrontendException show instance Exception SomeFrontendException where toException compilerExceptionToException fromException compilerExceptionFromException frontendExceptionToException Exception SomeException frontendExceptionToException toException SomeFrontendException frontendExceptionFromException Exception SomeException Maybe frontendExceptionFromException do SomeFrontendException fromException cast Make an exception type for particular frontend compiler exception data MismatchedParentheses MismatchedParentheses deriving Typeable Show instance Exception MismatchedParentheses where toException frontendExceptionToException fromException frontendExceptionFromException We can now catch MismatchedParentheses exception as MismatchedParentheses SomeFrontendException or SomeCompilerException but not other types e.g IOException Main throw MismatchedParentheses catch putStrLn Caught show MismatchedParentheses Caught MismatchedParentheses Main throw MismatchedParentheses catch putStrLn Caught show SomeFrontendException Caught MismatchedParentheses Main throw MismatchedParentheses catch putStrLn Caught show SomeCompilerException Caught MismatchedParentheses Main throw MismatchedParentheses catch putStrLn Caught show IOException Exception MismatchedParentheses",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "Exception",
          "package": "base",
          "partial": "Exception",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:Exception"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYou need this when using \u003ccode\u003e\u003ca\u003ecatches\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "Handler",
          "package": "base",
          "source": "src/Control-Exception.html#Handler",
          "type": "data"
        },
        "index": {
          "description": "You need this when using catches",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "Handler",
          "package": "base",
          "partial": "Handler",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:Handler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExceptions that occur in the \u003ccode\u003eIO\u003c/code\u003e monad.\n An \u003ccode\u003eIOException\u003c/code\u003e records a more specific error type, a descriptive\n string and maybe the handle that was used when the error was\n flagged.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "IOException",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#IOException",
          "type": "data"
        },
        "index": {
          "description": "Exceptions that occur in the IO monad An IOException records more specific error type descriptive string and maybe the handle that was used when the error was flagged",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "IOException",
          "package": "base",
          "partial": "IOException",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:IOException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes the behaviour of a thread when an asynchronous\n exception is received.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "MaskingState",
          "package": "base",
          "source": "src/GHC-IO.html#MaskingState",
          "type": "data"
        },
        "index": {
          "description": "Describes the behaviour of thread when an asynchronous exception is received",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "MaskingState",
          "package": "base",
          "partial": "Masking State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:MaskingState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown when the program attempts to call \u003ccode\u003eatomically\u003c/code\u003e, from the \u003ccode\u003estm\u003c/code\u003e\n package, inside another call to \u003ccode\u003eatomically\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "NestedAtomically",
          "package": "base",
          "source": "src/Control-Exception-Base.html#NestedAtomically",
          "type": "data"
        },
        "index": {
          "description": "Thrown when the program attempts to call atomically from the stm package inside another call to atomically",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "NestedAtomically",
          "package": "base",
          "partial": "Nested Atomically",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:NestedAtomically"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class method without a definition (neither a default definition,\n nor a definition in the appropriate instance) was called. The\n \u003ccode\u003eString\u003c/code\u003e gives information about which method it was.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "NoMethodError",
          "package": "base",
          "source": "src/Control-Exception-Base.html#NoMethodError",
          "type": "data"
        },
        "index": {
          "description": "class method without definition neither default definition nor definition in the appropriate instance was called The String gives information about which method it was",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "NoMethodError",
          "package": "base",
          "partial": "No Method Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:NoMethodError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown when the runtime system detects that the computation is\n guaranteed not to terminate. Note that there is no guarantee that\n the runtime system will notice whether any given computation is\n guaranteed to terminate or not.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "NonTermination",
          "package": "base",
          "source": "src/Control-Exception-Base.html#NonTermination",
          "type": "data"
        },
        "index": {
          "description": "Thrown when the runtime system detects that the computation is guaranteed not to terminate Note that there is no guarantee that the runtime system will notice whether any given computation is guaranteed to terminate or not",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "NonTermination",
          "package": "base",
          "partial": "Non Termination",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:NonTermination"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern match failed. The \u003ccode\u003eString\u003c/code\u003e gives information about the\n source location of the pattern.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "PatternMatchFail",
          "package": "base",
          "source": "src/Control-Exception-Base.html#PatternMatchFail",
          "type": "data"
        },
        "index": {
          "description": "pattern match failed The String gives information about the source location of the pattern",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "PatternMatchFail",
          "package": "base",
          "partial": "Pattern Match Fail",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:PatternMatchFail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn uninitialised record field was used. The \u003ccode\u003eString\u003c/code\u003e gives\n information about the source location where the record was\n constructed.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "RecConError",
          "package": "base",
          "source": "src/Control-Exception-Base.html#RecConError",
          "type": "data"
        },
        "index": {
          "description": "An uninitialised record field was used The String gives information about the source location where the record was constructed",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "RecConError",
          "package": "base",
          "partial": "Rec Con Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:RecConError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA record selector was applied to a constructor without the\n appropriate field. This can only happen with a datatype with\n multiple constructors, where some fields are in one constructor\n but not another. The \u003ccode\u003eString\u003c/code\u003e gives information about the source\n location of the record selector.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "RecSelError",
          "package": "base",
          "source": "src/Control-Exception-Base.html#RecSelError",
          "type": "data"
        },
        "index": {
          "description": "record selector was applied to constructor without the appropriate field This can only happen with datatype with multiple constructors where some fields are in one constructor but not another The String gives information about the source location of the record selector",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "RecSelError",
          "package": "base",
          "partial": "Rec Sel Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:RecSelError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA record update was performed on a constructor without the\n appropriate field. This can only happen with a datatype with\n multiple constructors, where some fields are in one constructor\n but not another. The \u003ccode\u003eString\u003c/code\u003e gives information about the source\n location of the record update.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "RecUpdError",
          "package": "base",
          "source": "src/Control-Exception-Base.html#RecUpdError",
          "type": "data"
        },
        "index": {
          "description": "record update was performed on constructor without the appropriate field This can only happen with datatype with multiple constructors where some fields are in one constructor but not another The String gives information about the source location of the record update",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "RecUpdError",
          "package": "base",
          "partial": "Rec Upd Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:RecUpdError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003eSomeException\u003c/code\u003e type is the root of the exception type hierarchy.\nWhen an exception of type \u003ccode\u003ee\u003c/code\u003e is thrown, behind the scenes it is\nencapsulated in a \u003ccode\u003eSomeException\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "SomeException",
          "package": "base",
          "source": "src/GHC-Exception.html#SomeException",
          "type": "data"
        },
        "index": {
          "description": "The SomeException type is the root of the exception type hierarchy When an exception of type is thrown behind the scenes it is encapsulated in SomeException",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "SomeException",
          "package": "base",
          "partial": "Some Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#t:SomeException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception",
          "name": "Handler",
          "package": "base",
          "signature": "Handler (e -\u003e IO a)",
          "source": "src/Control-Exception.html#Handler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "Handler",
          "normalized": "Handler(a-\u003eIO b)",
          "package": "base",
          "partial": "Handler",
          "signature": "Handler(e-\u003eIO a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:Handler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen invoked inside \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e, this function allows a blocked\n asynchronous exception to be raised, if one exists.  It is\n equivalent to performing an interruptible operation (see\n \u003ca name=\"interruptible\"/\u003e), but does not involve any actual blocking.\n\u003c/p\u003e\u003cp\u003eWhen called outside \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e, or inside \u003ccode\u003e\u003ca\u003euninterruptibleMask\u003c/a\u003e\u003c/code\u003e, this\n function has no effect.\n\u003c/p\u003e",
          "module": "Control.Exception",
          "name": "allowInterrupt",
          "package": "base",
          "signature": "IO ()",
          "source": "src/Control-Exception.html#allowInterrupt",
          "type": "function"
        },
        "index": {
          "description": "When invoked inside mask this function allows blocked asynchronous exception to be raised if one exists It is equivalent to performing an interruptible operation see but does not involve any actual blocking When called outside mask or inside uninterruptibleMask this function has no effect",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "allowInterrupt",
          "normalized": "IO()",
          "package": "base",
          "partial": "Interrupt",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:allowInterrupt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSometimes you want to catch two different sorts of exception. You could\ndo something like\n\u003c/p\u003e\u003cpre\u003e f = expr `catch` \\ (ex :: ArithException) -\u003e handleArith ex\n          `catch` \\ (ex :: IOException)    -\u003e handleIO    ex\n\u003c/pre\u003e\u003cp\u003eHowever, there are a couple of problems with this approach. The first is\nthat having two exception handlers is inefficient. However, the more\nserious issue is that the second exception handler will catch exceptions\nin the first, e.g. in the example above, if \u003ccode\u003ehandleArith\u003c/code\u003e throws an\n\u003ccode\u003eIOException\u003c/code\u003e then the second exception handler will catch it.\n\u003c/p\u003e\u003cp\u003eInstead, we provide a function \u003ccode\u003e\u003ca\u003ecatches\u003c/a\u003e\u003c/code\u003e, which would be used thus:\n\u003c/p\u003e\u003cpre\u003e f = expr `catches` [Handler (\\ (ex :: ArithException) -\u003e handleArith ex),\n                     Handler (\\ (ex :: IOException)    -\u003e handleIO    ex)]\n\u003c/pre\u003e",
          "module": "Control.Exception",
          "name": "catches",
          "package": "base",
          "signature": "IO a -\u003e [Handler a] -\u003e IO a",
          "source": "src/Control-Exception.html#catches",
          "type": "function"
        },
        "index": {
          "description": "Sometimes you want to catch two different sorts of exception You could do something like expr catch ex ArithException handleArith ex catch ex IOException handleIO ex However there are couple of problems with this approach The first is that having two exception handlers is inefficient However the more serious issue is that the second exception handler will catch exceptions in the first e.g in the example above if handleArith throws an IOException then the second exception handler will catch it Instead we provide function catches which would be used thus expr catches Handler ex ArithException handleArith ex Handler ex IOException handleIO ex",
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "catches",
          "normalized": "IO a-\u003e[Handler a]-\u003eIO a",
          "package": "base",
          "signature": "IO a-\u003e[Handler a]-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:catches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception",
          "name": "fromException",
          "package": "base",
          "signature": "SomeException -\u003e Maybe e",
          "source": "src/GHC-Exception.html#fromException",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "fromException",
          "normalized": "SomeException-\u003eMaybe a",
          "package": "base",
          "partial": "Exception",
          "signature": "SomeException-\u003eMaybe e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:fromException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception",
          "name": "toException",
          "package": "base",
          "signature": "e -\u003e SomeException",
          "source": "src/GHC-Exception.html#toException",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Exception",
          "module": "Control.Exception",
          "name": "toException",
          "normalized": "a-\u003eSomeException",
          "package": "base",
          "partial": "Exception",
          "signature": "e-\u003eSomeException",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Exception.html#v:toException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMonadic fixpoints.\n\u003c/p\u003e\u003cp\u003eFor a detailed discussion, see Levent Erkok's thesis,\n \u003cem\u003eValue Recursion in Monadic Computations\u003c/em\u003e, Oregon Graduate Institute, 2002.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.Fix",
          "name": "Fix",
          "package": "base",
          "source": "src/Control-Monad-Fix.html",
          "type": "module"
        },
        "index": {
          "description": "Monadic fixpoints For detailed discussion see Levent Erkok thesis Value Recursion in Monadic Computations Oregon Graduate Institute",
          "hierarchy": "Control Monad Fix",
          "module": "Control.Monad.Fix",
          "name": "Fix",
          "package": "base",
          "partial": "Fix",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Fix.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonads having fixed points with a 'knot-tying' semantics.\n Instances of \u003ccode\u003e\u003ca\u003eMonadFix\u003c/a\u003e\u003c/code\u003e should satisfy the following laws:\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003cem\u003epurity\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003emfix\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e . h)  =  \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efix\u003c/a\u003e\u003c/code\u003e h)\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003eleft shrinking\u003c/em\u003e (or \u003cem\u003etightening\u003c/em\u003e)\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003emfix\u003c/a\u003e\u003c/code\u003e (\\x -\u003e a \u003e\u003e= \\y -\u003e f x y)  =  a \u003e\u003e= \\y -\u003e \u003ccode\u003e\u003ca\u003emfix\u003c/a\u003e\u003c/code\u003e (\\x -\u003e f x y)\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003esliding\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003emfix\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eliftM\u003c/a\u003e\u003c/code\u003e h . f)  =  \u003ccode\u003e\u003ca\u003eliftM\u003c/a\u003e\u003c/code\u003e h (\u003ccode\u003e\u003ca\u003emfix\u003c/a\u003e\u003c/code\u003e (f . h))\u003c/code\u003e,\n      for strict \u003ccode\u003eh\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003enesting\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003emfix\u003c/a\u003e\u003c/code\u003e (\\x -\u003e \u003ccode\u003e\u003ca\u003emfix\u003c/a\u003e\u003c/code\u003e (\\y -\u003e f x y))  =  \u003ccode\u003e\u003ca\u003emfix\u003c/a\u003e\u003c/code\u003e (\\x -\u003e f x x)\u003c/code\u003e\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eThis class is used in the translation of the recursive \u003ccode\u003edo\u003c/code\u003e notation\n supported by GHC and Hugs.\n\u003c/p\u003e",
          "module": "Control.Monad.Fix",
          "name": "MonadFix",
          "package": "base",
          "source": "src/Control-Monad-Fix.html#MonadFix",
          "type": "class"
        },
        "index": {
          "description": "Monads having fixed points with knot-tying semantics Instances of MonadFix should satisfy the following laws purity mfix return return fix left shrinking or tightening mfix mfix sliding mfix liftM liftM mfix for strict nesting mfix mfix mfix This class is used in the translation of the recursive do notation supported by GHC and Hugs",
          "hierarchy": "Control Monad Fix",
          "module": "Control.Monad.Fix",
          "name": "MonadFix",
          "package": "base",
          "partial": "Monad Fix",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Fix.html#t:MonadFix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003efix\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e is the least fixed point of the function \u003ccode\u003ef\u003c/code\u003e,\n i.e. the least defined \u003ccode\u003ex\u003c/code\u003e such that \u003ccode\u003ef x = x\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Monad.Fix\",\"Data.Function\"]",
          "name": "fix",
          "package": "base",
          "signature": "(a -\u003e a) -\u003e a",
          "source": "src/Data-Function.html#fix",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Monad-Fix.html#v:fix\",\"http://hackage.haskell.org/package/base/docs/Data-Function.html#v:fix\"]"
        },
        "index": {
          "description": "fix is the least fixed point of the function i.e the least defined such that",
          "hierarchy": "Control Monad Fix",
          "module": "Control.Monad.Fix",
          "name": "fix",
          "normalized": "(a-\u003ea)-\u003ea",
          "package": "base",
          "signature": "(a-\u003ea)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Fix.html#v:fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe fixed point of a monadic computation.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003emfix\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e executes the action \u003ccode\u003ef\u003c/code\u003e only once, with the eventual\n output fed back as the input.  Hence \u003ccode\u003ef\u003c/code\u003e should not be strict,\n for then \u003ccode\u003e\u003ccode\u003e\u003ca\u003emfix\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e would diverge.\n\u003c/p\u003e",
          "module": "Control.Monad.Fix",
          "name": "mfix",
          "package": "base",
          "signature": "(a -\u003e m a) -\u003e m a",
          "source": "src/Control-Monad-Fix.html#mfix",
          "type": "method"
        },
        "index": {
          "description": "The fixed point of monadic computation mfix executes the action only once with the eventual output fed back as the input Hence should not be strict for then mfix would diverge",
          "hierarchy": "Control Monad Fix",
          "module": "Control.Monad.Fix",
          "name": "mfix",
          "normalized": "(a-\u003eb a)-\u003eb a",
          "package": "base",
          "signature": "(a-\u003em a)-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Fix.html#v:mfix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003cem\u003eThis module is DEPRECATED and will be removed in the future!\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e instances for \u003ccode\u003e(-\u003e) r\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e instances for \u003ccode\u003e(,) a\u003c/code\u003e and \u003ccode\u003e\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.Instances",
          "name": "Instances",
          "package": "base",
          "source": "src/Control-Monad-Instances.html",
          "type": "module"
        },
        "index": {
          "description": "This module is DEPRECATED and will be removed in the future Functor and Monad instances for and Functor instances for and Either",
          "hierarchy": "Control Monad Instances",
          "module": "Control.Monad.Instances",
          "name": "Instances",
          "package": "base",
          "partial": "Instances",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Instances.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e class is used for types that can be mapped over.\nInstances of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e should satisfy the following laws:\n\u003c/p\u003e\u003cpre\u003e fmap id  ==  id\n fmap (f . g)  ==  fmap f . fmap g\n\u003c/pre\u003e\u003cp\u003eThe instances of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e for lists, \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\nsatisfy these laws.\n\u003c/p\u003e",
          "module": "Control.Monad.Instances",
          "name": "Functor",
          "package": "base",
          "source": "src/GHC-Base.html#Functor",
          "type": "class"
        },
        "index": {
          "description": "The Functor class is used for types that can be mapped over Instances of Functor should satisfy the following laws fmap id id fmap fmap fmap The instances of Functor for lists Maybe and IO satisfy these laws",
          "hierarchy": "Control Monad Instances",
          "module": "Control.Monad.Instances",
          "name": "Functor",
          "package": "base",
          "partial": "Functor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Instances.html#t:Functor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e class defines the basic operations over a \u003cem\u003emonad\u003c/em\u003e,\na concept from a branch of mathematics known as \u003cem\u003ecategory theory\u003c/em\u003e.\nFrom the perspective of a Haskell programmer, however, it is best to\nthink of a monad as an \u003cem\u003eabstract datatype\u003c/em\u003e of actions.\nHaskell's \u003ccode\u003edo\u003c/code\u003e expressions provide a convenient syntax for writing\nmonadic expressions.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eInstances of \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e should satisfy the following laws:\n\u003c/p\u003e\u003cpre\u003e return a \u003e\u003e= k  ==  k a\n m \u003e\u003e= return  ==  m\n m \u003e\u003e= (\\x -\u003e k x \u003e\u003e= h)  ==  (m \u003e\u003e= k) \u003e\u003e= h\n\u003c/pre\u003e\u003cp\u003eInstances of both \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e should additionally satisfy the law:\n\u003c/p\u003e\u003cpre\u003e fmap f xs  ==  xs \u003e\u003e= return . f\n\u003c/pre\u003e\u003cp\u003eThe instances of \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e for lists, \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\ndefined in the \u003ca\u003ePrelude\u003c/a\u003e satisfy these laws.\n\u003c/p\u003e",
          "module": "Control.Monad.Instances",
          "name": "Monad",
          "package": "base",
          "source": "src/GHC-Base.html#Monad",
          "type": "class"
        },
        "index": {
          "description": "The Monad class defines the basic operations over monad concept from branch of mathematics known as category theory From the perspective of Haskell programmer however it is best to think of monad as an abstract datatype of actions Haskell do expressions provide convenient syntax for writing monadic expressions Minimal complete definition and return Instances of Monad should satisfy the following laws return return Instances of both Monad and Functor should additionally satisfy the law fmap xs xs return The instances of Monad for lists Maybe and IO defined in the Prelude satisfy these laws",
          "hierarchy": "Control Monad Instances",
          "module": "Control.Monad.Instances",
          "name": "Monad",
          "package": "base",
          "partial": "Monad",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Instances.html#t:Monad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequentially compose two actions, discarding any value produced\n by the first, like sequencing operators (such as the semicolon)\n in imperative languages.\n\u003c/p\u003e",
          "module": "Control.Monad.Instances",
          "name": "(\u003e\u003e)",
          "package": "base",
          "signature": "forall a b.  m a -\u003e m b -\u003e m b",
          "source": "src/GHC-Base.html#%3E%3E",
          "type": "method"
        },
        "index": {
          "description": "Sequentially compose two actions discarding any value produced by the first like sequencing operators such as the semicolon in imperative languages",
          "hierarchy": "Control Monad Instances",
          "module": "Control.Monad.Instances",
          "name": "(\u003e\u003e) \u003e\u003e",
          "normalized": "a b c d b-\u003ed e-\u003ed e",
          "package": "base",
          "signature": "forall a b. m a-\u003em b-\u003em b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Instances.html#v:-62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequentially compose two actions, passing any value produced\n by the first as an argument to the second.\n\u003c/p\u003e",
          "module": "Control.Monad.Instances",
          "name": "(\u003e\u003e=)",
          "package": "base",
          "signature": "forall a b.  m a -\u003e (a -\u003e m b) -\u003e m b",
          "source": "src/GHC-Base.html#%3E%3E%3D",
          "type": "method"
        },
        "index": {
          "description": "Sequentially compose two actions passing any value produced by the first as an argument to the second",
          "hierarchy": "Control Monad Instances",
          "module": "Control.Monad.Instances",
          "name": "(\u003e\u003e=) \u003e\u003e=",
          "normalized": "a b c d b-\u003e(b-\u003ed e)-\u003ed e",
          "package": "base",
          "signature": "forall a b. m a-\u003e(a-\u003em b)-\u003em b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Instances.html#v:-62--62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFail with a message.  This operation is not part of the\n mathematical definition of a monad, but is invoked on pattern-match\n failure in a \u003ccode\u003edo\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Control.Monad.Instances",
          "name": "fail",
          "package": "base",
          "signature": "String -\u003e m a",
          "source": "src/GHC-Base.html#fail",
          "type": "method"
        },
        "index": {
          "description": "Fail with message This operation is not part of the mathematical definition of monad but is invoked on pattern-match failure in do expression",
          "hierarchy": "Control Monad Instances",
          "module": "Control.Monad.Instances",
          "name": "fail",
          "normalized": "String-\u003ea b",
          "package": "base",
          "signature": "String-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Instances.html#v:fail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Instances",
          "name": "fmap",
          "package": "base",
          "signature": "(a -\u003e b) -\u003e f a -\u003e f b",
          "source": "src/GHC-Base.html#fmap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Instances",
          "module": "Control.Monad.Instances",
          "name": "fmap",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "base",
          "signature": "(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Instances.html#v:fmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject a value into the monadic type.\n\u003c/p\u003e",
          "module": "Control.Monad.Instances",
          "name": "return",
          "package": "base",
          "signature": "a -\u003e m a",
          "source": "src/GHC-Base.html#return",
          "type": "method"
        },
        "index": {
          "description": "Inject value into the monadic type",
          "hierarchy": "Control Monad Instances",
          "module": "Control.Monad.Instances",
          "name": "return",
          "normalized": "a-\u003eb a",
          "package": "base",
          "signature": "a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Instances.html#v:return"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module presents an identical interface to \u003ca\u003eControl.Monad.ST\u003c/a\u003e,\n except that the monad delays evaluation of state operations until\n a value depending on them is required.\n\u003c/p\u003e\u003cp\u003eSafe API only.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.ST.Lazy.Safe",
          "name": "Safe",
          "package": "base",
          "source": "src/Control-Monad-ST-Lazy-Safe.html",
          "type": "module"
        },
        "index": {
          "description": "This module presents an identical interface to Control.Monad.ST except that the monad delays evaluation of state operations until value depending on them is required Safe API only",
          "hierarchy": "Control Monad ST Lazy Safe",
          "module": "Control.Monad.ST.Lazy.Safe",
          "name": "Safe",
          "package": "base",
          "partial": "Safe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Safe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eRealWorld\u003c/code\u003e is deeply magical.  It is \u003cem\u003eprimitive\u003c/em\u003e, but it is not\n \t\u003cem\u003eunlifted\u003c/em\u003e (hence \u003ccode\u003eptrArg\u003c/code\u003e).  We never manipulate values of type\n \t\u003ccode\u003eRealWorld\u003c/code\u003e; it's only used in the type system, to parameterise \u003ccode\u003eState#\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Control.Monad.ST.Lazy.Safe",
          "name": "RealWorld",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "RealWorld is deeply magical It is primitive but it is not unlifted hence ptrArg We never manipulate values of type RealWorld it only used in the type system to parameterise State",
          "hierarchy": "Control Monad ST Lazy Safe",
          "module": "Control.Monad.ST.Lazy.Safe",
          "name": "RealWorld",
          "package": "base",
          "partial": "Real World",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Safe.html#t:RealWorld"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe lazy state-transformer monad.\n A computation of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eST\u003c/a\u003e\u003c/code\u003e s a\u003c/code\u003e transforms an internal state indexed\n by \u003ccode\u003es\u003c/code\u003e, and returns a value of type \u003ccode\u003ea\u003c/code\u003e.\n The \u003ccode\u003es\u003c/code\u003e parameter is either\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e an unstantiated type variable (inside invocations of \u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e), or\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eRealWorld\u003c/a\u003e\u003c/code\u003e (inside invocations of \u003ccode\u003e\u003ca\u003estToIO\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIt serves to keep the internal states of different invocations of\n \u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e separate from each other and from invocations of \u003ccode\u003e\u003ca\u003estToIO\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e\u003e\u003e\u003c/a\u003e\u003c/code\u003e operations are not strict in the state.  For example,\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e (writeSTRef _|_ v \u003e\u003e= readSTRef _|_ \u003e\u003e return 2) = 2\u003c/pre\u003e",
          "module": "Control.Monad.ST.Lazy.Safe",
          "name": "ST",
          "package": "base",
          "source": "src/Control-Monad-ST-Lazy-Imp.html#ST",
          "type": "data"
        },
        "index": {
          "description": "The lazy state-transformer monad computation of type ST transforms an internal state indexed by and returns value of type The parameter is either an unstantiated type variable inside invocations of runST or RealWorld inside invocations of stToIO It serves to keep the internal states of different invocations of runST separate from each other and from invocations of stToIO The and operations are not strict in the state For example runST writeSTRef readSTRef return",
          "hierarchy": "Control Monad ST Lazy Safe",
          "module": "Control.Monad.ST.Lazy.Safe",
          "name": "ST",
          "package": "base",
          "partial": "ST",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Safe.html#t:ST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllow the result of a state transformer computation to be used (lazily)\n inside the computation.\n Note that if \u003ccode\u003ef\u003c/code\u003e is strict, \u003ccode\u003e\u003ccode\u003e\u003ca\u003efixST\u003c/a\u003e\u003c/code\u003e f = _|_\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Monad.ST.Lazy.Safe\",\"Control.Monad.ST.Lazy\"]",
          "name": "fixST",
          "package": "base",
          "signature": "(a -\u003e ST s a) -\u003e ST s a",
          "source": "src/Control-Monad-ST-Lazy-Imp.html#fixST",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Safe.html#v:fixST\",\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy.html#v:fixST\"]"
        },
        "index": {
          "description": "Allow the result of state transformer computation to be used lazily inside the computation Note that if is strict fixST",
          "hierarchy": "Control Monad ST Lazy Safe",
          "module": "Control.Monad.ST.Lazy.Safe",
          "name": "fixST",
          "normalized": "(a-\u003eST b a)-\u003eST b a",
          "package": "base",
          "partial": "ST",
          "signature": "(a-\u003eST s a)-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Safe.html#v:fixST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a lazy \u003ccode\u003e\u003ca\u003eST\u003c/a\u003e\u003c/code\u003e computation into a strict one.\n\u003c/p\u003e",
          "module": "[\"Control.Monad.ST.Lazy.Safe\",\"Control.Monad.ST.Lazy\"]",
          "name": "lazyToStrictST",
          "package": "base",
          "signature": "ST s a -\u003e ST s a",
          "source": "src/Control-Monad-ST-Lazy-Imp.html#lazyToStrictST",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Safe.html#v:lazyToStrictST\",\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy.html#v:lazyToStrictST\"]"
        },
        "index": {
          "description": "Convert lazy ST computation into strict one",
          "hierarchy": "Control Monad ST Lazy Safe",
          "module": "Control.Monad.ST.Lazy.Safe",
          "name": "lazyToStrictST",
          "normalized": "ST a b-\u003eST a b",
          "package": "base",
          "partial": "To Strict ST",
          "signature": "ST s a-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Safe.html#v:lazyToStrictST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the value computed by a state transformer computation.\n The \u003ccode\u003eforall\u003c/code\u003e ensures that the internal state used by the \u003ccode\u003e\u003ca\u003eST\u003c/a\u003e\u003c/code\u003e\n computation is inaccessible to the rest of the program.\n\u003c/p\u003e",
          "module": "[\"Control.Monad.ST.Lazy.Safe\",\"Control.Monad.ST.Lazy\"]",
          "name": "runST",
          "package": "base",
          "signature": "(forall s.  ST s a) -\u003e a",
          "source": "src/Control-Monad-ST-Lazy-Imp.html#runST",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Safe.html#v:runST\",\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy.html#v:runST\"]"
        },
        "index": {
          "description": "Return the value computed by state transformer computation The forall ensures that the internal state used by the ST computation is inaccessible to the rest of the program",
          "hierarchy": "Control Monad ST Lazy Safe",
          "module": "Control.Monad.ST.Lazy.Safe",
          "name": "runST",
          "normalized": "(a b ST c d)-\u003ed",
          "package": "base",
          "partial": "ST",
          "signature": "(forall s. ST s a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Safe.html#v:runST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA monad transformer embedding lazy state transformers in the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\n monad.  The \u003ccode\u003e\u003ca\u003eRealWorld\u003c/a\u003e\u003c/code\u003e parameter indicates that the internal state\n used by the \u003ccode\u003e\u003ca\u003eST\u003c/a\u003e\u003c/code\u003e computation is a special one supplied by the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\n monad, and thus distinct from those used by invocations of \u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Monad.ST.Lazy.Safe\",\"Control.Monad.ST.Lazy\"]",
          "name": "stToIO",
          "package": "base",
          "signature": "ST RealWorld a -\u003e IO a",
          "source": "src/Control-Monad-ST-Lazy-Imp.html#stToIO",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Safe.html#v:stToIO\",\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy.html#v:stToIO\"]"
        },
        "index": {
          "description": "monad transformer embedding lazy state transformers in the IO monad The RealWorld parameter indicates that the internal state used by the ST computation is special one supplied by the IO monad and thus distinct from those used by invocations of runST",
          "hierarchy": "Control Monad ST Lazy Safe",
          "module": "Control.Monad.ST.Lazy.Safe",
          "name": "stToIO",
          "normalized": "ST RealWorld a-\u003eIO a",
          "package": "base",
          "partial": "To IO",
          "signature": "ST RealWorld a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Safe.html#v:stToIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a strict \u003ccode\u003e\u003ca\u003eST\u003c/a\u003e\u003c/code\u003e computation into a lazy one.  The strict state\nthread passed to \u003ccode\u003e\u003ca\u003estrictToLazyST\u003c/a\u003e\u003c/code\u003e is not performed until the result of\nthe lazy state thread it returns is demanded.\n\u003c/p\u003e",
          "module": "[\"Control.Monad.ST.Lazy.Safe\",\"Control.Monad.ST.Lazy\"]",
          "name": "strictToLazyST",
          "package": "base",
          "signature": "ST s a -\u003e ST s a",
          "source": "src/Control-Monad-ST-Lazy-Imp.html#strictToLazyST",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Safe.html#v:strictToLazyST\",\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy.html#v:strictToLazyST\"]"
        },
        "index": {
          "description": "Convert strict ST computation into lazy one The strict state thread passed to strictToLazyST is not performed until the result of the lazy state thread it returns is demanded",
          "hierarchy": "Control Monad ST Lazy Safe",
          "module": "Control.Monad.ST.Lazy.Safe",
          "name": "strictToLazyST",
          "normalized": "ST a b-\u003eST a b",
          "package": "base",
          "partial": "To Lazy ST",
          "signature": "ST s a-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Safe.html#v:strictToLazyST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module presents an identical interface to \u003ca\u003eControl.Monad.ST\u003c/a\u003e,\n except that the monad delays evaluation of state operations until\n a value depending on them is required.\n\u003c/p\u003e\u003cp\u003eUnsafe API.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.ST.Lazy.Unsafe",
          "name": "Unsafe",
          "package": "base",
          "source": "src/Control-Monad-ST-Lazy-Unsafe.html",
          "type": "module"
        },
        "index": {
          "description": "This module presents an identical interface to Control.Monad.ST except that the monad delays evaluation of state operations until value depending on them is required Unsafe API",
          "hierarchy": "Control Monad ST Lazy Unsafe",
          "module": "Control.Monad.ST.Lazy.Unsafe",
          "name": "Unsafe",
          "package": "base",
          "partial": "Unsafe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Unsafe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.ST.Lazy.Unsafe",
          "name": "unsafeIOToST",
          "package": "base",
          "signature": "IO a -\u003e ST s a",
          "source": "src/Control-Monad-ST-Lazy-Imp.html#unsafeIOToST",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad ST Lazy Unsafe",
          "module": "Control.Monad.ST.Lazy.Unsafe",
          "name": "unsafeIOToST",
          "normalized": "IO a-\u003eST b a",
          "package": "base",
          "partial": "IOTo ST",
          "signature": "IO a-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Unsafe.html#v:unsafeIOToST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.ST.Lazy.Unsafe",
          "name": "unsafeInterleaveST",
          "package": "base",
          "signature": "ST s a -\u003e ST s a",
          "source": "src/Control-Monad-ST-Lazy-Imp.html#unsafeInterleaveST",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad ST Lazy Unsafe",
          "module": "Control.Monad.ST.Lazy.Unsafe",
          "name": "unsafeInterleaveST",
          "normalized": "ST a b-\u003eST a b",
          "package": "base",
          "partial": "Interleave ST",
          "signature": "ST s a-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy-Unsafe.html#v:unsafeInterleaveST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module presents an identical interface to \u003ca\u003eControl.Monad.ST\u003c/a\u003e,\n except that the monad delays evaluation of state operations until\n a value depending on them is required.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.ST.Lazy",
          "name": "Lazy",
          "package": "base",
          "source": "src/Control-Monad-ST-Lazy.html",
          "type": "module"
        },
        "index": {
          "description": "This module presents an identical interface to Control.Monad.ST except that the monad delays evaluation of state operations until value depending on them is required",
          "hierarchy": "Control Monad ST Lazy",
          "module": "Control.Monad.ST.Lazy",
          "name": "Lazy",
          "package": "base",
          "partial": "Lazy",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eRealWorld\u003c/code\u003e is deeply magical.  It is \u003cem\u003eprimitive\u003c/em\u003e, but it is not\n \t\u003cem\u003eunlifted\u003c/em\u003e (hence \u003ccode\u003eptrArg\u003c/code\u003e).  We never manipulate values of type\n \t\u003ccode\u003eRealWorld\u003c/code\u003e; it's only used in the type system, to parameterise \u003ccode\u003eState#\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Control.Monad.ST.Lazy",
          "name": "RealWorld",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "RealWorld is deeply magical It is primitive but it is not unlifted hence ptrArg We never manipulate values of type RealWorld it only used in the type system to parameterise State",
          "hierarchy": "Control Monad ST Lazy",
          "module": "Control.Monad.ST.Lazy",
          "name": "RealWorld",
          "package": "base",
          "partial": "Real World",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy.html#t:RealWorld"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe lazy state-transformer monad.\n A computation of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eST\u003c/a\u003e\u003c/code\u003e s a\u003c/code\u003e transforms an internal state indexed\n by \u003ccode\u003es\u003c/code\u003e, and returns a value of type \u003ccode\u003ea\u003c/code\u003e.\n The \u003ccode\u003es\u003c/code\u003e parameter is either\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e an unstantiated type variable (inside invocations of \u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e), or\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eRealWorld\u003c/a\u003e\u003c/code\u003e (inside invocations of \u003ccode\u003e\u003ca\u003estToIO\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIt serves to keep the internal states of different invocations of\n \u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e separate from each other and from invocations of \u003ccode\u003e\u003ca\u003estToIO\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e\u003e\u003e\u003c/a\u003e\u003c/code\u003e operations are not strict in the state.  For example,\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e (writeSTRef _|_ v \u003e\u003e= readSTRef _|_ \u003e\u003e return 2) = 2\u003c/pre\u003e",
          "module": "Control.Monad.ST.Lazy",
          "name": "ST",
          "package": "base",
          "source": "src/Control-Monad-ST-Lazy-Imp.html#ST",
          "type": "data"
        },
        "index": {
          "description": "The lazy state-transformer monad computation of type ST transforms an internal state indexed by and returns value of type The parameter is either an unstantiated type variable inside invocations of runST or RealWorld inside invocations of stToIO It serves to keep the internal states of different invocations of runST separate from each other and from invocations of stToIO The and operations are not strict in the state For example runST writeSTRef readSTRef return",
          "hierarchy": "Control Monad ST Lazy",
          "module": "Control.Monad.ST.Lazy",
          "name": "ST",
          "package": "base",
          "partial": "ST",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy.html#t:ST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Please import from Control.Monad.ST.Lazy.Unsafe instead; This will be removed in the next release\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.ST.Lazy",
          "name": "unsafeIOToST",
          "package": "base",
          "signature": "IO a -\u003e ST s a",
          "source": "src/Control-Monad-ST-Lazy.html#unsafeIOToST",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Please import from Control.Monad.ST.Lazy.Unsafe instead This will be removed in the next release",
          "hierarchy": "Control Monad ST Lazy",
          "module": "Control.Monad.ST.Lazy",
          "name": "unsafeIOToST",
          "normalized": "IO a-\u003eST b a",
          "package": "base",
          "partial": "IOTo ST",
          "signature": "IO a-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy.html#v:unsafeIOToST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Please import from Control.Monad.ST.Lazy.Unsafe instead; This will be removed in the next release\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.ST.Lazy",
          "name": "unsafeInterleaveST",
          "package": "base",
          "signature": "ST s a -\u003e ST s a",
          "source": "src/Control-Monad-ST-Lazy.html#unsafeInterleaveST",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Please import from Control.Monad.ST.Lazy.Unsafe instead This will be removed in the next release",
          "hierarchy": "Control Monad ST Lazy",
          "module": "Control.Monad.ST.Lazy",
          "name": "unsafeInterleaveST",
          "normalized": "ST a b-\u003eST a b",
          "package": "base",
          "partial": "Interleave ST",
          "signature": "ST s a-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Lazy.html#v:unsafeInterleaveST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis library provides support for \u003cem\u003estrict\u003c/em\u003e state threads, as\n described in the PLDI '94 paper by John Launchbury and Simon Peyton\n Jones \u003cem\u003eLazy Functional State Threads\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eSafe API Only.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.ST.Safe",
          "name": "Safe",
          "package": "base",
          "source": "src/Control-Monad-ST-Safe.html",
          "type": "module"
        },
        "index": {
          "description": "This library provides support for strict state threads as described in the PLDI paper by John Launchbury and Simon Peyton Jones Lazy Functional State Threads Safe API Only",
          "hierarchy": "Control Monad ST Safe",
          "module": "Control.Monad.ST.Safe",
          "name": "Safe",
          "package": "base",
          "partial": "Safe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Safe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eRealWorld\u003c/code\u003e is deeply magical.  It is \u003cem\u003eprimitive\u003c/em\u003e, but it is not\n \t\u003cem\u003eunlifted\u003c/em\u003e (hence \u003ccode\u003eptrArg\u003c/code\u003e).  We never manipulate values of type\n \t\u003ccode\u003eRealWorld\u003c/code\u003e; it's only used in the type system, to parameterise \u003ccode\u003eState#\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Control.Monad.ST.Safe",
          "name": "RealWorld",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "RealWorld is deeply magical It is primitive but it is not unlifted hence ptrArg We never manipulate values of type RealWorld it only used in the type system to parameterise State",
          "hierarchy": "Control Monad ST Safe",
          "module": "Control.Monad.ST.Safe",
          "name": "RealWorld",
          "package": "base",
          "partial": "Real World",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Safe.html#t:RealWorld"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe strict state-transformer monad.\n A computation of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eST\u003c/a\u003e\u003c/code\u003e s a\u003c/code\u003e transforms an internal state indexed\n by \u003ccode\u003es\u003c/code\u003e, and returns a value of type \u003ccode\u003ea\u003c/code\u003e.\n The \u003ccode\u003es\u003c/code\u003e parameter is either\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e an uninstantiated type variable (inside invocations of \u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e), or\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eRealWorld\u003c/a\u003e\u003c/code\u003e (inside invocations of \u003ccode\u003e\u003ca\u003estToIO\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIt serves to keep the internal states of different invocations\n of \u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e separate from each other and from invocations of\n \u003ccode\u003e\u003ca\u003estToIO\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e\u003e\u003e\u003c/a\u003e\u003c/code\u003e operations are strict in the state (though not in\n values stored in the state).  For example,\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e (writeSTRef _|_ v \u003e\u003e= f) = _|_\u003c/pre\u003e",
          "module": "Control.Monad.ST.Safe",
          "name": "ST",
          "package": "base",
          "source": "src/GHC-ST.html#ST",
          "type": "data"
        },
        "index": {
          "description": "The strict state-transformer monad computation of type ST transforms an internal state indexed by and returns value of type The parameter is either an uninstantiated type variable inside invocations of runST or RealWorld inside invocations of stToIO It serves to keep the internal states of different invocations of runST separate from each other and from invocations of stToIO The and operations are strict in the state though not in values stored in the state For example runST writeSTRef",
          "hierarchy": "Control Monad ST Safe",
          "module": "Control.Monad.ST.Safe",
          "name": "ST",
          "package": "base",
          "partial": "ST",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Safe.html#t:ST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllow the result of a state transformer computation to be used (lazily)\n inside the computation.\n Note that if \u003ccode\u003ef\u003c/code\u003e is strict, \u003ccode\u003e\u003ccode\u003e\u003ca\u003efixST\u003c/a\u003e\u003c/code\u003e f = _|_\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Monad.ST.Safe\",\"Control.Monad.ST\"]",
          "name": "fixST",
          "package": "base",
          "signature": "(a -\u003e ST s a) -\u003e ST s a",
          "source": "src/GHC-ST.html#fixST",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Safe.html#v:fixST\",\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST.html#v:fixST\"]"
        },
        "index": {
          "description": "Allow the result of state transformer computation to be used lazily inside the computation Note that if is strict fixST",
          "hierarchy": "Control Monad ST Safe",
          "module": "Control.Monad.ST.Safe",
          "name": "fixST",
          "normalized": "(a-\u003eST b a)-\u003eST b a",
          "package": "base",
          "partial": "ST",
          "signature": "(a-\u003eST s a)-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Safe.html#v:fixST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the value computed by a state transformer computation.\n The \u003ccode\u003eforall\u003c/code\u003e ensures that the internal state used by the \u003ccode\u003e\u003ca\u003eST\u003c/a\u003e\u003c/code\u003e\n computation is inaccessible to the rest of the program.\n\u003c/p\u003e",
          "module": "[\"Control.Monad.ST.Safe\",\"Control.Monad.ST\"]",
          "name": "runST",
          "package": "base",
          "signature": "(forall s.  ST s a) -\u003e a",
          "source": "src/GHC-ST.html#runST",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Safe.html#v:runST\",\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST.html#v:runST\"]"
        },
        "index": {
          "description": "Return the value computed by state transformer computation The forall ensures that the internal state used by the ST computation is inaccessible to the rest of the program",
          "hierarchy": "Control Monad ST Safe",
          "module": "Control.Monad.ST.Safe",
          "name": "runST",
          "normalized": "(a b ST c d)-\u003ed",
          "package": "base",
          "partial": "ST",
          "signature": "(forall s. ST s a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Safe.html#v:runST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA monad transformer embedding strict state transformers in the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\n monad.  The \u003ccode\u003e\u003ca\u003eRealWorld\u003c/a\u003e\u003c/code\u003e parameter indicates that the internal state\n used by the \u003ccode\u003e\u003ca\u003eST\u003c/a\u003e\u003c/code\u003e computation is a special one supplied by the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\n monad, and thus distinct from those used by invocations of \u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Monad.ST.Safe\",\"Control.Monad.ST\"]",
          "name": "stToIO",
          "package": "base",
          "signature": "ST RealWorld a -\u003e IO a",
          "source": "src/GHC-IO.html#stToIO",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Safe.html#v:stToIO\",\"http://hackage.haskell.org/package/base/docs/Control-Monad-ST.html#v:stToIO\"]"
        },
        "index": {
          "description": "monad transformer embedding strict state transformers in the IO monad The RealWorld parameter indicates that the internal state used by the ST computation is special one supplied by the IO monad and thus distinct from those used by invocations of runST",
          "hierarchy": "Control Monad ST Safe",
          "module": "Control.Monad.ST.Safe",
          "name": "stToIO",
          "normalized": "ST RealWorld a-\u003eIO a",
          "package": "base",
          "partial": "To IO",
          "signature": "ST RealWorld a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Safe.html#v:stToIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe strict ST monad (re-export of \u003ca\u003eControl.Monad.ST\u003c/a\u003e)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.ST.Strict",
          "name": "Strict",
          "package": "base",
          "source": "src/Control-Monad-ST-Strict.html",
          "type": "module"
        },
        "index": {
          "description": "The strict ST monad re-export of Control.Monad.ST",
          "hierarchy": "Control Monad ST Strict",
          "module": "Control.Monad.ST.Strict",
          "name": "Strict",
          "package": "base",
          "partial": "Strict",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Strict.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis library provides support for \u003cem\u003estrict\u003c/em\u003e state threads, as\n described in the PLDI '94 paper by John Launchbury and Simon Peyton\n Jones \u003cem\u003eLazy Functional State Threads\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eUnsafe API.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.ST.Unsafe",
          "name": "Unsafe",
          "package": "base",
          "source": "src/Control-Monad-ST-Unsafe.html",
          "type": "module"
        },
        "index": {
          "description": "This library provides support for strict state threads as described in the PLDI paper by John Launchbury and Simon Peyton Jones Lazy Functional State Threads Unsafe API",
          "hierarchy": "Control Monad ST Unsafe",
          "module": "Control.Monad.ST.Unsafe",
          "name": "Unsafe",
          "package": "base",
          "partial": "Unsafe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Unsafe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.ST.Unsafe",
          "name": "unsafeIOToST",
          "package": "base",
          "signature": "IO a -\u003e ST s a",
          "source": "src/GHC-IO.html#unsafeIOToST",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad ST Unsafe",
          "module": "Control.Monad.ST.Unsafe",
          "name": "unsafeIOToST",
          "normalized": "IO a-\u003eST b a",
          "package": "base",
          "partial": "IOTo ST",
          "signature": "IO a-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Unsafe.html#v:unsafeIOToST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.ST.Unsafe",
          "name": "unsafeInterleaveST",
          "package": "base",
          "signature": "ST s a -\u003e ST s a",
          "source": "src/GHC-ST.html#unsafeInterleaveST",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad ST Unsafe",
          "module": "Control.Monad.ST.Unsafe",
          "name": "unsafeInterleaveST",
          "normalized": "ST a b-\u003eST a b",
          "package": "base",
          "partial": "Interleave ST",
          "signature": "ST s a-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Unsafe.html#v:unsafeInterleaveST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.ST.Unsafe",
          "name": "unsafeSTToIO",
          "package": "base",
          "signature": "ST s a -\u003e IO a",
          "source": "src/GHC-IO.html#unsafeSTToIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad ST Unsafe",
          "module": "Control.Monad.ST.Unsafe",
          "name": "unsafeSTToIO",
          "normalized": "ST a b-\u003eIO b",
          "package": "base",
          "partial": "STTo IO",
          "signature": "ST s a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST-Unsafe.html#v:unsafeSTToIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis library provides support for \u003cem\u003estrict\u003c/em\u003e state threads, as\n described in the PLDI '94 paper by John Launchbury and Simon Peyton\n Jones \u003cem\u003eLazy Functional State Threads\u003c/em\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.ST",
          "name": "ST",
          "package": "base",
          "source": "src/Control-Monad-ST.html",
          "type": "module"
        },
        "index": {
          "description": "This library provides support for strict state threads as described in the PLDI paper by John Launchbury and Simon Peyton Jones Lazy Functional State Threads",
          "hierarchy": "Control Monad ST",
          "module": "Control.Monad.ST",
          "name": "ST",
          "package": "base",
          "partial": "ST",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eRealWorld\u003c/code\u003e is deeply magical.  It is \u003cem\u003eprimitive\u003c/em\u003e, but it is not\n \t\u003cem\u003eunlifted\u003c/em\u003e (hence \u003ccode\u003eptrArg\u003c/code\u003e).  We never manipulate values of type\n \t\u003ccode\u003eRealWorld\u003c/code\u003e; it's only used in the type system, to parameterise \u003ccode\u003eState#\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Control.Monad.ST",
          "name": "RealWorld",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "RealWorld is deeply magical It is primitive but it is not unlifted hence ptrArg We never manipulate values of type RealWorld it only used in the type system to parameterise State",
          "hierarchy": "Control Monad ST",
          "module": "Control.Monad.ST",
          "name": "RealWorld",
          "package": "base",
          "partial": "Real World",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST.html#t:RealWorld"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe strict state-transformer monad.\n A computation of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eST\u003c/a\u003e\u003c/code\u003e s a\u003c/code\u003e transforms an internal state indexed\n by \u003ccode\u003es\u003c/code\u003e, and returns a value of type \u003ccode\u003ea\u003c/code\u003e.\n The \u003ccode\u003es\u003c/code\u003e parameter is either\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e an uninstantiated type variable (inside invocations of \u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e), or\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eRealWorld\u003c/a\u003e\u003c/code\u003e (inside invocations of \u003ccode\u003e\u003ca\u003estToIO\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIt serves to keep the internal states of different invocations\n of \u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e separate from each other and from invocations of\n \u003ccode\u003e\u003ca\u003estToIO\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e\u003e\u003e\u003c/a\u003e\u003c/code\u003e operations are strict in the state (though not in\n values stored in the state).  For example,\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e (writeSTRef _|_ v \u003e\u003e= f) = _|_\u003c/pre\u003e",
          "module": "Control.Monad.ST",
          "name": "ST",
          "package": "base",
          "source": "src/GHC-ST.html#ST",
          "type": "data"
        },
        "index": {
          "description": "The strict state-transformer monad computation of type ST transforms an internal state indexed by and returns value of type The parameter is either an uninstantiated type variable inside invocations of runST or RealWorld inside invocations of stToIO It serves to keep the internal states of different invocations of runST separate from each other and from invocations of stToIO The and operations are strict in the state though not in values stored in the state For example runST writeSTRef",
          "hierarchy": "Control Monad ST",
          "module": "Control.Monad.ST",
          "name": "ST",
          "package": "base",
          "partial": "ST",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST.html#t:ST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Please import from Control.Monad.ST.Unsafe instead; This will be removed in the next release\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.ST",
          "name": "unsafeIOToST",
          "package": "base",
          "signature": "IO a -\u003e ST s a",
          "source": "src/Control-Monad-ST.html#unsafeIOToST",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Please import from Control.Monad.ST.Unsafe instead This will be removed in the next release",
          "hierarchy": "Control Monad ST",
          "module": "Control.Monad.ST",
          "name": "unsafeIOToST",
          "normalized": "IO a-\u003eST b a",
          "package": "base",
          "partial": "IOTo ST",
          "signature": "IO a-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST.html#v:unsafeIOToST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Please import from Control.Monad.ST.Unsafe instead; This will be removed in the next release\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.ST",
          "name": "unsafeInterleaveST",
          "package": "base",
          "signature": "ST s a -\u003e ST s a",
          "source": "src/Control-Monad-ST.html#unsafeInterleaveST",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Please import from Control.Monad.ST.Unsafe instead This will be removed in the next release",
          "hierarchy": "Control Monad ST",
          "module": "Control.Monad.ST",
          "name": "unsafeInterleaveST",
          "normalized": "ST a b-\u003eST a b",
          "package": "base",
          "partial": "Interleave ST",
          "signature": "ST s a-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST.html#v:unsafeInterleaveST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Please import from Control.Monad.ST.Unsafe instead; This will be removed in the next release\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.ST",
          "name": "unsafeSTToIO",
          "package": "base",
          "signature": "ST s a -\u003e IO a",
          "source": "src/Control-Monad-ST.html#unsafeSTToIO",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Please import from Control.Monad.ST.Unsafe instead This will be removed in the next release",
          "hierarchy": "Control Monad ST",
          "module": "Control.Monad.ST",
          "name": "unsafeSTToIO",
          "normalized": "ST a b-\u003eIO b",
          "package": "base",
          "partial": "STTo IO",
          "signature": "ST s a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-ST.html#v:unsafeSTToIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMonadic zipping (used for monad comprehensions)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.Zip",
          "name": "Zip",
          "package": "base",
          "source": "src/Control-Monad-Zip.html",
          "type": "module"
        },
        "index": {
          "description": "Monadic zipping used for monad comprehensions",
          "hierarchy": "Control Monad Zip",
          "module": "Control.Monad.Zip",
          "name": "Zip",
          "package": "base",
          "partial": "Zip",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Zip.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eMonadZip\u003c/a\u003e\u003c/code\u003e type class. Minimal definition: \u003ccode\u003e\u003ca\u003emzip\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003emzipWith\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eInstances should satisfy the laws:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Naturality :\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e liftM (f *** g) (mzip ma mb) = mzip (liftM f ma) (liftM g mb)\n\u003c/pre\u003e\u003cul\u003e\u003cli\u003e Information Preservation:\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e liftM (const ()) ma = liftM (const ()) mb\n ==\u003e\n munzip (mzip ma mb) = (ma, mb)\n\u003c/pre\u003e",
          "module": "Control.Monad.Zip",
          "name": "MonadZip",
          "package": "base",
          "source": "src/Control-Monad-Zip.html#MonadZip",
          "type": "class"
        },
        "index": {
          "description": "MonadZip type class Minimal definition mzip or mzipWith Instances should satisfy the laws Naturality liftM mzip ma mb mzip liftM ma liftM mb Information Preservation liftM const ma liftM const mb munzip mzip ma mb ma mb",
          "hierarchy": "Control Monad Zip",
          "module": "Control.Monad.Zip",
          "name": "MonadZip",
          "package": "base",
          "partial": "Monad Zip",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Zip.html#t:MonadZip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Zip",
          "name": "munzip",
          "package": "base",
          "signature": "m (a, b) -\u003e (m a, m b)",
          "source": "src/Control-Monad-Zip.html#munzip",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Zip",
          "module": "Control.Monad.Zip",
          "name": "munzip",
          "normalized": "a(b,c)-\u003e(a b,a c)",
          "package": "base",
          "signature": "m(a,b)-\u003e(m a,m b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Zip.html#v:munzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Zip",
          "name": "mzip",
          "package": "base",
          "signature": "m a -\u003e m b -\u003e m (a, b)",
          "source": "src/Control-Monad-Zip.html#mzip",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Zip",
          "module": "Control.Monad.Zip",
          "name": "mzip",
          "normalized": "a b-\u003ea c-\u003ea(b,c)",
          "package": "base",
          "signature": "m a-\u003em b-\u003em(a,b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Zip.html#v:mzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Zip",
          "name": "mzipWith",
          "package": "base",
          "signature": "(a -\u003e b -\u003e c) -\u003e m a -\u003e m b -\u003e m c",
          "source": "src/Control-Monad-Zip.html#mzipWith",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad Zip",
          "module": "Control.Monad.Zip",
          "name": "mzipWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
          "package": "base",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003em a-\u003em b-\u003em c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad-Zip.html#v:mzipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eMonadPlus\u003c/a\u003e\u003c/code\u003e classes,\n with some useful operations on monads.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad",
          "name": "Monad",
          "package": "base",
          "source": "src/Control-Monad.html",
          "type": "module"
        },
        "index": {
          "description": "The Functor Monad and MonadPlus classes with some useful operations on monads",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "Monad",
          "package": "base",
          "partial": "Monad",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e class is used for types that can be mapped over.\nInstances of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e should satisfy the following laws:\n\u003c/p\u003e\u003cpre\u003e fmap id  ==  id\n fmap (f . g)  ==  fmap f . fmap g\n\u003c/pre\u003e\u003cp\u003eThe instances of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e for lists, \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\nsatisfy these laws.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "Functor",
          "package": "base",
          "source": "src/GHC-Base.html#Functor",
          "type": "class"
        },
        "index": {
          "description": "The Functor class is used for types that can be mapped over Instances of Functor should satisfy the following laws fmap id id fmap fmap fmap The instances of Functor for lists Maybe and IO satisfy these laws",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "Functor",
          "package": "base",
          "partial": "Functor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#t:Functor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e class defines the basic operations over a \u003cem\u003emonad\u003c/em\u003e,\na concept from a branch of mathematics known as \u003cem\u003ecategory theory\u003c/em\u003e.\nFrom the perspective of a Haskell programmer, however, it is best to\nthink of a monad as an \u003cem\u003eabstract datatype\u003c/em\u003e of actions.\nHaskell's \u003ccode\u003edo\u003c/code\u003e expressions provide a convenient syntax for writing\nmonadic expressions.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eInstances of \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e should satisfy the following laws:\n\u003c/p\u003e\u003cpre\u003e return a \u003e\u003e= k  ==  k a\n m \u003e\u003e= return  ==  m\n m \u003e\u003e= (\\x -\u003e k x \u003e\u003e= h)  ==  (m \u003e\u003e= k) \u003e\u003e= h\n\u003c/pre\u003e\u003cp\u003eInstances of both \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e should additionally satisfy the law:\n\u003c/p\u003e\u003cpre\u003e fmap f xs  ==  xs \u003e\u003e= return . f\n\u003c/pre\u003e\u003cp\u003eThe instances of \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e for lists, \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\ndefined in the \u003ca\u003ePrelude\u003c/a\u003e satisfy these laws.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "Monad",
          "package": "base",
          "source": "src/GHC-Base.html#Monad",
          "type": "class"
        },
        "index": {
          "description": "The Monad class defines the basic operations over monad concept from branch of mathematics known as category theory From the perspective of Haskell programmer however it is best to think of monad as an abstract datatype of actions Haskell do expressions provide convenient syntax for writing monadic expressions Minimal complete definition and return Instances of Monad should satisfy the following laws return return Instances of both Monad and Functor should additionally satisfy the law fmap xs xs return The instances of Monad for lists Maybe and IO defined in the Prelude satisfy these laws",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "Monad",
          "package": "base",
          "partial": "Monad",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#t:Monad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonads that also support choice and failure.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "MonadPlus",
          "package": "base",
          "source": "src/Control-Monad.html#MonadPlus",
          "type": "class"
        },
        "index": {
          "description": "Monads that also support choice and failure",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "MonadPlus",
          "package": "base",
          "partial": "Monad Plus",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#t:MonadPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight-to-left Kleisli composition of monads. \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e\u003e=\u003e\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e, with the arguments flipped\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "(\u003c=\u003c)",
          "package": "base",
          "signature": "(b -\u003e m c) -\u003e (a -\u003e m b) -\u003e a -\u003e m c",
          "source": "src/Control-Monad.html#%3C%3D%3C",
          "type": "function"
        },
        "index": {
          "description": "Right-to-left Kleisli composition of monads with the arguments flipped",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "(\u003c=\u003c) \u003c=\u003c",
          "normalized": "(a-\u003eb c)-\u003e(d-\u003eb a)-\u003ed-\u003eb c",
          "package": "base",
          "signature": "(b-\u003em c)-\u003e(a-\u003em b)-\u003ea-\u003em c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:-60--61--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e, but with the arguments interchanged.\n\u003c/p\u003e",
          "module": "[\"Control.Monad\",\"Prelude\"]",
          "name": "(=\u003c\u003c)",
          "package": "base",
          "signature": "(a -\u003e m b) -\u003e m a -\u003e m b",
          "source": "src/Control-Monad.html#%3D%3C%3C",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:-61--60--60-\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:-61--60--60-\"]"
        },
        "index": {
          "description": "Same as but with the arguments interchanged",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "(=\u003c\u003c) =\u003c\u003c",
          "normalized": "(a-\u003eb c)-\u003eb a-\u003eb c",
          "package": "base",
          "signature": "(a-\u003em b)-\u003em a-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:-61--60--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft-to-right Kleisli composition of monads.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "(\u003e=\u003e)",
          "package": "base",
          "signature": "(a -\u003e m b) -\u003e (b -\u003e m c) -\u003e a -\u003e m c",
          "source": "src/Control-Monad.html#%3E%3D%3E",
          "type": "function"
        },
        "index": {
          "description": "Left-to-right Kleisli composition of monads",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "(\u003e=\u003e) \u003e=\u003e",
          "normalized": "(a-\u003eb c)-\u003e(c-\u003eb d)-\u003ea-\u003eb d",
          "package": "base",
          "signature": "(a-\u003em b)-\u003e(b-\u003em c)-\u003ea-\u003em c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:-62--61--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequentially compose two actions, discarding any value produced\n by the first, like sequencing operators (such as the semicolon)\n in imperative languages.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "(\u003e\u003e)",
          "package": "base",
          "signature": "forall a b.  m a -\u003e m b -\u003e m b",
          "source": "src/GHC-Base.html#%3E%3E",
          "type": "method"
        },
        "index": {
          "description": "Sequentially compose two actions discarding any value produced by the first like sequencing operators such as the semicolon in imperative languages",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "(\u003e\u003e) \u003e\u003e",
          "normalized": "a b c d b-\u003ed e-\u003ed e",
          "package": "base",
          "signature": "forall a b. m a-\u003em b-\u003em b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:-62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequentially compose two actions, passing any value produced\n by the first as an argument to the second.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "(\u003e\u003e=)",
          "package": "base",
          "signature": "forall a b.  m a -\u003e (a -\u003e m b) -\u003e m b",
          "source": "src/GHC-Base.html#%3E%3E%3D",
          "type": "method"
        },
        "index": {
          "description": "Sequentially compose two actions passing any value produced by the first as an argument to the second",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "(\u003e\u003e=) \u003e\u003e=",
          "normalized": "a b c d b-\u003e(b-\u003ed e)-\u003ed e",
          "package": "base",
          "signature": "forall a b. m a-\u003e(a-\u003em b)-\u003em b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:-62--62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn many situations, the \u003ccode\u003e\u003ca\u003eliftM\u003c/a\u003e\u003c/code\u003e operations can be replaced by uses of\n\u003ccode\u003e\u003ca\u003eap\u003c/a\u003e\u003c/code\u003e, which promotes function application. \n\u003c/p\u003e\u003cpre\u003e       return f `ap` x1 `ap` ... `ap` xn\n\u003c/pre\u003e\u003cp\u003eis equivalent to \n\u003c/p\u003e\u003cpre\u003e       liftMn f x1 x2 ... xn\n\u003c/pre\u003e",
          "module": "Control.Monad",
          "name": "ap",
          "package": "base",
          "signature": "m (a -\u003e b) -\u003e m a -\u003e m b",
          "source": "src/Control-Monad.html#ap",
          "type": "function"
        },
        "index": {
          "description": "In many situations the liftM operations can be replaced by uses of ap which promotes function application return ap x1 ap ap xn is equivalent to liftMn x1 x2 xn",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "ap",
          "normalized": "a(b-\u003ec)-\u003ea b-\u003ea c",
          "package": "base",
          "signature": "m(a-\u003eb)-\u003em a-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:ap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFail with a message.  This operation is not part of the\n mathematical definition of a monad, but is invoked on pattern-match\n failure in a \u003ccode\u003edo\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "fail",
          "package": "base",
          "signature": "String -\u003e m a",
          "source": "src/GHC-Base.html#fail",
          "type": "method"
        },
        "index": {
          "description": "Fail with message This operation is not part of the mathematical definition of monad but is invoked on pattern-match failure in do expression",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "fail",
          "normalized": "String-\u003ea b",
          "package": "base",
          "signature": "String-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:fail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis generalizes the list-based \u003ccode\u003e\u003ca\u003efilter\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "filterM",
          "package": "base",
          "signature": "(a -\u003e m Bool) -\u003e [a] -\u003e m [a]",
          "source": "src/Control-Monad.html#filterM",
          "type": "function"
        },
        "index": {
          "description": "This generalizes the list-based filter function",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "filterM",
          "normalized": "(a-\u003eb Bool)-\u003e[a]-\u003eb[a]",
          "package": "base",
          "signature": "(a-\u003em Bool)-\u003e[a]-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:filterM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad",
          "name": "fmap",
          "package": "base",
          "signature": "(a -\u003e b) -\u003e f a -\u003e f b",
          "source": "src/GHC-Base.html#fmap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "fmap",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "base",
          "signature": "(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:fmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efoldM\u003c/a\u003e\u003c/code\u003e function is analogous to \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, except that its result is\nencapsulated in a monad. Note that \u003ccode\u003e\u003ca\u003efoldM\u003c/a\u003e\u003c/code\u003e works from left-to-right over\nthe list arguments. This could be an issue where \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e\u003e\u003e\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e and the `folded\nfunction' are not commutative.\n\u003c/p\u003e\u003cpre\u003e       foldM f a1 [x1, x2, ..., xm]\n\u003c/pre\u003e\u003cp\u003e==  \n\u003c/p\u003e\u003cpre\u003e       do\n         a2 \u003c- f a1 x1\n         a3 \u003c- f a2 x2\n         ...\n         f am xm\n\u003c/pre\u003e\u003cp\u003eIf right-to-left evaluation is required, the input list should be reversed.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "foldM",
          "package": "base",
          "signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e [b] -\u003e m a",
          "source": "src/Control-Monad.html#foldM",
          "type": "function"
        },
        "index": {
          "description": "The foldM function is analogous to foldl except that its result is encapsulated in monad Note that foldM works from left-to-right over the list arguments This could be an issue where and the folded function are not commutative foldM a1 x1 x2 xm do a2 a1 x1 a3 a2 x2 am xm If right-to-left evaluation is required the input list should be reversed",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "foldM",
          "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003e[b]-\u003ec a",
          "package": "base",
          "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003e[b]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:foldM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003efoldM\u003c/a\u003e\u003c/code\u003e, but discards the result.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "foldM_",
          "package": "base",
          "signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e [b] -\u003e m ()",
          "source": "src/Control-Monad.html#foldM_",
          "type": "function"
        },
        "index": {
          "description": "Like foldM but discards the result",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "foldM_",
          "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003e[b]-\u003ec()",
          "package": "base",
          "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003e[b]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:foldM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eforM\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e with its arguments flipped\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "forM",
          "package": "base",
          "signature": "[a] -\u003e (a -\u003e m b) -\u003e m [b]",
          "source": "src/Control-Monad.html#forM",
          "type": "function"
        },
        "index": {
          "description": "forM is mapM with its arguments flipped",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "forM",
          "normalized": "[a]-\u003e(a-\u003eb c)-\u003eb[c]",
          "package": "base",
          "signature": "[a]-\u003e(a-\u003em b)-\u003em[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:forM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eforM_\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e with its arguments flipped\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "forM_",
          "package": "base",
          "signature": "[a] -\u003e (a -\u003e m b) -\u003e m ()",
          "source": "src/Control-Monad.html#forM_",
          "type": "function"
        },
        "index": {
          "description": "forM is mapM with its arguments flipped",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "forM_",
          "normalized": "[a]-\u003e(a-\u003eb c)-\u003eb()",
          "package": "base",
          "signature": "[a]-\u003e(a-\u003em b)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:forM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eforever\u003c/a\u003e\u003c/code\u003e act\u003c/code\u003e repeats the action infinitely.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "forever",
          "package": "base",
          "signature": "m a -\u003e m b",
          "source": "src/Control-Monad.html#forever",
          "type": "function"
        },
        "index": {
          "description": "forever act repeats the action infinitely",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "forever",
          "normalized": "a b-\u003ea c",
          "package": "base",
          "signature": "m a-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:forever"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eguard\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e is \u003ccode\u003e\u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e ()\u003c/code\u003e if \u003ccode\u003eb\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e,\n and \u003ccode\u003e\u003ca\u003emzero\u003c/a\u003e\u003c/code\u003e if \u003ccode\u003eb\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "guard",
          "package": "base",
          "signature": "Bool -\u003e m ()",
          "source": "src/Control-Monad.html#guard",
          "type": "function"
        },
        "index": {
          "description": "guard is return if is True and mzero if is False",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "guard",
          "normalized": "Bool-\u003ea()",
          "package": "base",
          "signature": "Bool-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:guard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e function is the conventional monad join operator. It is used to\n remove one level of monadic structure, projecting its bound argument into the\n outer level.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "join",
          "package": "base",
          "signature": "m (m a) -\u003e m a",
          "source": "src/Control-Monad.html#join",
          "type": "function"
        },
        "index": {
          "description": "The join function is the conventional monad join operator It is used to remove one level of monadic structure projecting its bound argument into the outer level",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "join",
          "normalized": "a(a b)-\u003ea b",
          "package": "base",
          "signature": "m(m a)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:join"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePromote a function to a monad.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "liftM",
          "package": "base",
          "signature": "(a1 -\u003e r) -\u003e m a1 -\u003e m r",
          "source": "src/Control-Monad.html#liftM",
          "type": "function"
        },
        "index": {
          "description": "Promote function to monad",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "liftM",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "base",
          "signature": "(a-\u003er)-\u003em a-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:liftM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePromote a function to a monad, scanning the monadic arguments from\n left to right.  For example,\n\u003c/p\u003e\u003cpre\u003e    liftM2 (+) [0,1] [0,2] = [0,2,1,3]\n    liftM2 (+) (Just 1) Nothing = Nothing\n\u003c/pre\u003e",
          "module": "Control.Monad",
          "name": "liftM2",
          "package": "base",
          "signature": "(a1 -\u003e a2 -\u003e r) -\u003e m a1 -\u003e m a2 -\u003e m r",
          "source": "src/Control-Monad.html#liftM2",
          "type": "function"
        },
        "index": {
          "description": "Promote function to monad scanning the monadic arguments from left to right For example liftM2 liftM2 Just Nothing Nothing",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "liftM2",
          "normalized": "(a-\u003ea-\u003eb)-\u003ec a-\u003ec a-\u003ec b",
          "package": "base",
          "signature": "(a-\u003ea-\u003er)-\u003em a-\u003em a-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:liftM2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePromote a function to a monad, scanning the monadic arguments from\n left to right (cf. \u003ccode\u003e\u003ca\u003eliftM2\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "liftM3",
          "package": "base",
          "signature": "(a1 -\u003e a2 -\u003e a3 -\u003e r) -\u003e m a1 -\u003e m a2 -\u003e m a3 -\u003e m r",
          "source": "src/Control-Monad.html#liftM3",
          "type": "function"
        },
        "index": {
          "description": "Promote function to monad scanning the monadic arguments from left to right cf liftM2",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "liftM3",
          "normalized": "(a-\u003ea-\u003ea-\u003eb)-\u003ec a-\u003ec a-\u003ec a-\u003ec b",
          "package": "base",
          "signature": "(a-\u003ea-\u003ea-\u003er)-\u003em a-\u003em a-\u003em a-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:liftM3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePromote a function to a monad, scanning the monadic arguments from\n left to right (cf. \u003ccode\u003e\u003ca\u003eliftM2\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "liftM4",
          "package": "base",
          "signature": "(a1 -\u003e a2 -\u003e a3 -\u003e a4 -\u003e r) -\u003e m a1 -\u003e m a2 -\u003e m a3 -\u003e m a4 -\u003e m r",
          "source": "src/Control-Monad.html#liftM4",
          "type": "function"
        },
        "index": {
          "description": "Promote function to monad scanning the monadic arguments from left to right cf liftM2",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "liftM4",
          "normalized": "(a-\u003ea-\u003ea-\u003ea-\u003eb)-\u003ec a-\u003ec a-\u003ec a-\u003ec a-\u003ec b",
          "package": "base",
          "signature": "(a-\u003ea-\u003ea-\u003ea-\u003er)-\u003em a-\u003em a-\u003em a-\u003em a-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:liftM4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePromote a function to a monad, scanning the monadic arguments from\n left to right (cf. \u003ccode\u003e\u003ca\u003eliftM2\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "liftM5",
          "package": "base",
          "signature": "(a1 -\u003e a2 -\u003e a3 -\u003e a4 -\u003e a5 -\u003e r) -\u003e m a1 -\u003e m a2 -\u003e m a3 -\u003e m a4 -\u003e m a5 -\u003e m r",
          "source": "src/Control-Monad.html#liftM5",
          "type": "function"
        },
        "index": {
          "description": "Promote function to monad scanning the monadic arguments from left to right cf liftM2",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "liftM5",
          "normalized": "(a-\u003ea-\u003ea-\u003ea-\u003ea-\u003eb)-\u003ec a-\u003ec a-\u003ec a-\u003ec a-\u003ec a-\u003ec b",
          "package": "base",
          "signature": "(a-\u003ea-\u003ea-\u003ea-\u003ea-\u003er)-\u003em a-\u003em a-\u003em a-\u003em a-\u003em a-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:liftM5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emapAndUnzipM\u003c/a\u003e\u003c/code\u003e function maps its first argument over a list, returning\n the result as a pair of lists. This function is mainly used with complicated\n data structures or a state-transforming monad.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "mapAndUnzipM",
          "package": "base",
          "signature": "(a -\u003e m (b, c)) -\u003e [a] -\u003e m ([b], [c])",
          "source": "src/Control-Monad.html#mapAndUnzipM",
          "type": "function"
        },
        "index": {
          "description": "The mapAndUnzipM function maps its first argument over list returning the result as pair of lists This function is mainly used with complicated data structures or state-transforming monad",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "mapAndUnzipM",
          "normalized": "(a-\u003eb(c,d))-\u003e[a]-\u003eb([c],[d])",
          "package": "base",
          "partial": "And Unzip",
          "signature": "(a-\u003em(b,c))-\u003e[a]-\u003em([b],[c])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:mapAndUnzipM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esequence\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Monad\",\"Prelude\"]",
          "name": "mapM",
          "package": "base",
          "signature": "(a -\u003e m b) -\u003e [a] -\u003e m [b]",
          "source": "src/Control-Monad.html#mapM",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:mapM\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:mapM\"]"
        },
        "index": {
          "description": "mapM is equivalent to sequence map",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "mapM",
          "normalized": "(a-\u003eb c)-\u003e[a]-\u003eb[c]",
          "package": "base",
          "signature": "(a-\u003em b)-\u003e[a]-\u003em[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:mapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esequence_\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Monad\",\"Prelude\"]",
          "name": "mapM_",
          "package": "base",
          "signature": "(a -\u003e m b) -\u003e [a] -\u003e m ()",
          "source": "src/Control-Monad.html#mapM_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:mapM_\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:mapM_\"]"
        },
        "index": {
          "description": "mapM is equivalent to sequence map",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "mapM_",
          "normalized": "(a-\u003eb c)-\u003e[a]-\u003eb()",
          "package": "base",
          "signature": "(a-\u003em b)-\u003e[a]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:mapM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDirect \u003ccode\u003e\u003ca\u003eMonadPlus\u003c/a\u003e\u003c/code\u003e equivalent of \u003ccode\u003e\u003ca\u003efilter\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003efilter\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e = \u003ccode\u003e(mfilter:: (a -\u003e Bool) -\u003e [a] -\u003e [a]\u003c/code\u003e\n applicable to any \u003ccode\u003e\u003ca\u003eMonadPlus\u003c/a\u003e\u003c/code\u003e, for example\n \u003ccode\u003emfilter odd (Just 1) == Just 1\u003c/code\u003e\n \u003ccode\u003emfilter odd (Just 2) == Nothing\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "mfilter",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e m a -\u003e m a",
          "source": "src/Control-Monad.html#mfilter",
          "type": "function"
        },
        "index": {
          "description": "Direct MonadPlus equivalent of filter filter mfilter Bool applicable to any MonadPlus for example mfilter odd Just Just mfilter odd Just Nothing",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "mfilter",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
          "package": "base",
          "signature": "(a-\u003eBool)-\u003em a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:mfilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean associative operation\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "mplus",
          "package": "base",
          "signature": "m a -\u003e m a -\u003e m a",
          "source": "src/Control-Monad.html#mplus",
          "type": "method"
        },
        "index": {
          "description": "an associative operation",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "mplus",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "base",
          "signature": "m a-\u003em a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:mplus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis generalizes the list-based \u003ccode\u003e\u003ca\u003econcat\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "msum",
          "package": "base",
          "signature": "[m a] -\u003e m a",
          "source": "src/Control-Monad.html#msum",
          "type": "function"
        },
        "index": {
          "description": "This generalizes the list-based concat function",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "msum",
          "normalized": "[a b]-\u003ea b",
          "package": "base",
          "signature": "[m a]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:msum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe identity of \u003ccode\u003e\u003ca\u003emplus\u003c/a\u003e\u003c/code\u003e.  It should also satisfy the equations\n\u003c/p\u003e\u003cpre\u003e mzero \u003e\u003e= f  =  mzero\n v \u003e\u003e mzero   =  mzero\n\u003c/pre\u003e",
          "module": "Control.Monad",
          "name": "mzero",
          "package": "base",
          "signature": "m a",
          "source": "src/Control-Monad.html#mzero",
          "type": "method"
        },
        "index": {
          "description": "the identity of mplus It should also satisfy the equations mzero mzero mzero mzero",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "mzero",
          "package": "base",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:mzero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ereplicateM\u003c/a\u003e\u003c/code\u003e n act\u003c/code\u003e performs the action \u003ccode\u003en\u003c/code\u003e times,\n gathering the results.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "replicateM",
          "package": "base",
          "signature": "Int -\u003e m a -\u003e m [a]",
          "source": "src/Control-Monad.html#replicateM",
          "type": "function"
        },
        "index": {
          "description": "replicateM act performs the action times gathering the results",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "replicateM",
          "normalized": "Int-\u003ea b-\u003ea[b]",
          "package": "base",
          "signature": "Int-\u003em a-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:replicateM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ereplicateM\u003c/a\u003e\u003c/code\u003e, but discards the result.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "replicateM_",
          "package": "base",
          "signature": "Int -\u003e m a -\u003e m ()",
          "source": "src/Control-Monad.html#replicateM_",
          "type": "function"
        },
        "index": {
          "description": "Like replicateM but discards the result",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "replicateM_",
          "normalized": "Int-\u003ea b-\u003ea()",
          "package": "base",
          "signature": "Int-\u003em a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:replicateM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject a value into the monadic type.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "return",
          "package": "base",
          "signature": "a -\u003e m a",
          "source": "src/GHC-Base.html#return",
          "type": "method"
        },
        "index": {
          "description": "Inject value into the monadic type",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "return",
          "normalized": "a-\u003eb a",
          "package": "base",
          "signature": "a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:return"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate each action in the sequence from left to right,\n and collect the results.\n\u003c/p\u003e",
          "module": "[\"Control.Monad\",\"Prelude\"]",
          "name": "sequence",
          "package": "base",
          "signature": "[m a] -\u003e m [a]",
          "source": "src/Control-Monad.html#sequence",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:sequence\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:sequence\"]"
        },
        "index": {
          "description": "Evaluate each action in the sequence from left to right and collect the results",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "sequence",
          "normalized": "[a b]-\u003ea[b]",
          "package": "base",
          "signature": "[m a]-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:sequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate each action in the sequence from left to right,\n and ignore the results.\n\u003c/p\u003e",
          "module": "[\"Control.Monad\",\"Prelude\"]",
          "name": "sequence_",
          "package": "base",
          "signature": "[m a] -\u003e m ()",
          "source": "src/Control-Monad.html#sequence_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:sequence_\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:sequence_\"]"
        },
        "index": {
          "description": "Evaluate each action in the sequence from left to right and ignore the results",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "sequence_",
          "normalized": "[a b]-\u003ea()",
          "package": "base",
          "signature": "[m a]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:sequence_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe reverse of \u003ccode\u003e\u003ca\u003ewhen\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "unless",
          "package": "base",
          "signature": "Bool -\u003e m () -\u003e m ()",
          "source": "src/Control-Monad.html#unless",
          "type": "function"
        },
        "index": {
          "description": "The reverse of when",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "unless",
          "normalized": "Bool-\u003ea()-\u003ea()",
          "package": "base",
          "signature": "Bool-\u003em()-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:unless"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003evoid\u003c/a\u003e\u003c/code\u003e value\u003c/code\u003e discards or ignores the result of evaluation, such as the return value of an \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e action.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "void",
          "package": "base",
          "signature": "f a -\u003e f ()",
          "source": "src/Control-Monad.html#void",
          "type": "function"
        },
        "index": {
          "description": "void value discards or ignores the result of evaluation such as the return value of an IO action",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "void",
          "normalized": "a b-\u003ea()",
          "package": "base",
          "signature": "f a-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:void"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConditional execution of monadic expressions. For example, \n\u003c/p\u003e\u003cpre\u003e       when debug (putStr \"Debugging\\n\")\n\u003c/pre\u003e\u003cp\u003ewill output the string \u003ccode\u003eDebugging\\n\u003c/code\u003e if the Boolean value \u003ccode\u003edebug\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e,\nand otherwise do nothing.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "when",
          "package": "base",
          "signature": "Bool -\u003e m () -\u003e m ()",
          "source": "src/Control-Monad.html#when",
          "type": "function"
        },
        "index": {
          "description": "Conditional execution of monadic expressions For example when debug putStr Debugging will output the string Debugging if the Boolean value debug is True and otherwise do nothing",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "when",
          "normalized": "Bool-\u003ea()-\u003ea()",
          "package": "base",
          "signature": "Bool-\u003em()-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:when"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezipWithM\u003c/a\u003e\u003c/code\u003e function generalizes \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e to arbitrary monads.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "zipWithM",
          "package": "base",
          "signature": "(a -\u003e b -\u003e m c) -\u003e [a] -\u003e [b] -\u003e m [c]",
          "source": "src/Control-Monad.html#zipWithM",
          "type": "function"
        },
        "index": {
          "description": "The zipWithM function generalizes zipWith to arbitrary monads",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "zipWithM",
          "normalized": "(a-\u003eb-\u003ec d)-\u003e[a]-\u003e[b]-\u003ec[d]",
          "package": "base",
          "partial": "With",
          "signature": "(a-\u003eb-\u003em c)-\u003e[a]-\u003e[b]-\u003em[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:zipWithM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ezipWithM_\u003c/a\u003e\u003c/code\u003e is the extension of \u003ccode\u003e\u003ca\u003ezipWithM\u003c/a\u003e\u003c/code\u003e which ignores the final result.\n\u003c/p\u003e",
          "module": "Control.Monad",
          "name": "zipWithM_",
          "package": "base",
          "signature": "(a -\u003e b -\u003e m c) -\u003e [a] -\u003e [b] -\u003e m ()",
          "source": "src/Control-Monad.html#zipWithM_",
          "type": "function"
        },
        "index": {
          "description": "zipWithM is the extension of zipWithM which ignores the final result",
          "hierarchy": "Control Monad",
          "module": "Control.Monad",
          "name": "zipWithM_",
          "normalized": "(a-\u003eb-\u003ec d)-\u003e[a]-\u003e[b]-\u003ec()",
          "package": "base",
          "partial": "With",
          "signature": "(a-\u003eb-\u003em c)-\u003e[a]-\u003e[b]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:zipWithM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines bitwise operations for signed and unsigned\n integers.  Instances of the class \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e for the \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e types are available from this module, and instances for\n explicitly sized integral types are available from the\n \u003ca\u003eData.Int\u003c/a\u003e and \u003ca\u003eData.Word\u003c/a\u003e modules.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Bits",
          "name": "Bits",
          "package": "base",
          "source": "src/Data-Bits.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines bitwise operations for signed and unsigned integers Instances of the class Bits for the Int and Integer types are available from this module and instances for explicitly sized integral types are available from the Data.Int and Data.Word modules",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "Bits",
          "package": "base",
          "partial": "Bits",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e class defines bitwise operations over integral types.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Bits are numbered from 0 with bit 0 being the least\n  significant bit.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003e.&.\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e.|.\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003exor\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ecomplement\u003c/a\u003e\u003c/code\u003e,\n(\u003ccode\u003e\u003ca\u003eshift\u003c/a\u003e\u003c/code\u003e or (\u003ccode\u003e\u003ca\u003eshiftL\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eshiftR\u003c/a\u003e\u003c/code\u003e)), (\u003ccode\u003e\u003ca\u003erotate\u003c/a\u003e\u003c/code\u003e or (\u003ccode\u003e\u003ca\u003erotateL\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003erotateR\u003c/a\u003e\u003c/code\u003e)),\n\u003ccode\u003e\u003ca\u003ebitSize\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eisSigned\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003etestBit\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ebit\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003epopCount\u003c/a\u003e\u003c/code\u003e.  The latter three can\nbe implemented using \u003ccode\u003e\u003ca\u003etestBitDefault\u003c/a\u003e\u003c/code\u003e, 'bitDefault, and \u003ccode\u003e\u003ca\u003epopCountDefault\u003c/a\u003e\u003c/code\u003e, if\n\u003ccode\u003ea\u003c/code\u003e is also an instance of \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "Bits",
          "package": "base",
          "source": "src/Data-Bits.html#Bits",
          "type": "class"
        },
        "index": {
          "description": "The Bits class defines bitwise operations over integral types Bits are numbered from with bit being the least significant bit Minimal complete definition xor complement shift or shiftL and shiftR rotate or rotateL and rotateR bitSize isSigned testBit bit and popCount The latter three can be implemented using testBitDefault bitDefault and popCountDefault if is also an instance of Num",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "Bits",
          "package": "base",
          "partial": "Bits",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#t:Bits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBitwise \"or\"\n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "(.|.)",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Data-Bits.html#.%7C.",
          "type": "method"
        },
        "index": {
          "description": "Bitwise or",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "(.|.) .|.",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:.-124-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBitwise \"and\"\n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "(.&.)",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Data-Bits.html#.%26.",
          "type": "method"
        },
        "index": {
          "description": "Bitwise and",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "(.&.) .&.",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:.-38-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ebit i\u003c/code\u003e is a value with the \u003ccode\u003ei\u003c/code\u003eth bit set and all other bits clear\n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "bit",
          "package": "base",
          "signature": "Int -\u003e a",
          "source": "src/Data-Bits.html#bit",
          "type": "method"
        },
        "index": {
          "description": "bit is value with the th bit set and all other bits clear",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "bit",
          "normalized": "Int-\u003ea",
          "package": "base",
          "signature": "Int-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:bit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault implementation for \u003ccode\u003e\u003ca\u003ebit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that: \u003ccode\u003ebitDefault i = 1 \u003ccode\u003e\u003ca\u003eshiftL\u003c/a\u003e\u003c/code\u003e i\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "bitDefault",
          "package": "base",
          "signature": "Int -\u003e a",
          "source": "src/Data-Bits.html#bitDefault",
          "type": "function"
        },
        "index": {
          "description": "Default implementation for bit Note that bitDefault shiftL",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "bitDefault",
          "normalized": "Int-\u003ea",
          "package": "base",
          "partial": "Default",
          "signature": "Int-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:bitDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the number of bits in the type of the argument.  The actual\n        value of the argument is ignored.  The function \u003ccode\u003e\u003ca\u003ebitSize\u003c/a\u003e\u003c/code\u003e is\n        undefined for types that do not have a fixed bitsize, like \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "bitSize",
          "package": "base",
          "signature": "a -\u003e Int",
          "source": "src/Data-Bits.html#bitSize",
          "type": "method"
        },
        "index": {
          "description": "Return the number of bits in the type of the argument The actual value of the argument is ignored The function bitSize is undefined for types that do not have fixed bitsize like Integer",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "bitSize",
          "normalized": "a-\u003eInt",
          "package": "base",
          "partial": "Size",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:bitSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ex `clearBit` i\u003c/code\u003e is the same as \u003ccode\u003ex .&. complement (bit i)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "clearBit",
          "package": "base",
          "signature": "a -\u003e Int -\u003e a",
          "source": "src/Data-Bits.html#clearBit",
          "type": "method"
        },
        "index": {
          "description": "clearBit is the same as complement bit",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "clearBit",
          "normalized": "a-\u003eInt-\u003ea",
          "package": "base",
          "partial": "Bit",
          "signature": "a-\u003eInt-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:clearBit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse all the bits in the argument \n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "complement",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/Data-Bits.html#complement",
          "type": "method"
        },
        "index": {
          "description": "Reverse all the bits in the argument",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "complement",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:complement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ex `complementBit` i\u003c/code\u003e is the same as \u003ccode\u003ex `xor` bit i\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "complementBit",
          "package": "base",
          "signature": "a -\u003e Int -\u003e a",
          "source": "src/Data-Bits.html#complementBit",
          "type": "method"
        },
        "index": {
          "description": "complementBit is the same as xor bit",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "complementBit",
          "normalized": "a-\u003eInt-\u003ea",
          "package": "base",
          "partial": "Bit",
          "signature": "a-\u003eInt-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:complementBit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the argument is a signed type.  The actual\n        value of the argument is ignored \n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "isSigned",
          "package": "base",
          "signature": "a -\u003e Bool",
          "source": "src/Data-Bits.html#isSigned",
          "type": "method"
        },
        "index": {
          "description": "Return True if the argument is signed type The actual value of the argument is ignored",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "isSigned",
          "normalized": "a-\u003eBool",
          "package": "base",
          "partial": "Signed",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:isSigned"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the number of set bits in the argument.  This number is\n        known as the population count or the Hamming weight. \n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "popCount",
          "package": "base",
          "signature": "a -\u003e Int",
          "source": "src/Data-Bits.html#popCount",
          "type": "method"
        },
        "index": {
          "description": "Return the number of set bits in the argument This number is known as the population count or the Hamming weight",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "popCount",
          "normalized": "a-\u003eInt",
          "package": "base",
          "partial": "Count",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:popCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault implementation for \u003ccode\u003e\u003ca\u003epopCount\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis implementation is intentionally naive. Instances are expected to provide\n an optimized implementation for their size.\n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "popCountDefault",
          "package": "base",
          "signature": "a -\u003e Int",
          "source": "src/Data-Bits.html#popCountDefault",
          "type": "function"
        },
        "index": {
          "description": "Default implementation for popCount This implementation is intentionally naive Instances are expected to provide an optimized implementation for their size",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "popCountDefault",
          "normalized": "a-\u003eInt",
          "package": "base",
          "partial": "Count Default",
          "signature": "a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:popCountDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003erotate\u003c/a\u003e\u003c/code\u003e x i\u003c/code\u003e rotates \u003ccode\u003ex\u003c/code\u003e left by \u003ccode\u003ei\u003c/code\u003e bits if \u003ccode\u003ei\u003c/code\u003e is positive,\n        or right by \u003ccode\u003e-i\u003c/code\u003e bits otherwise.\n\u003c/p\u003e\u003cp\u003eFor unbounded types like \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003erotate\u003c/a\u003e\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ca\u003eshift\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eAn instance can define either this unified \u003ccode\u003e\u003ca\u003erotate\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003erotateL\u003c/a\u003e\u003c/code\u003e and\n        \u003ccode\u003e\u003ca\u003erotateR\u003c/a\u003e\u003c/code\u003e, depending on which is more convenient for the type in\n        question. \n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "rotate",
          "package": "base",
          "signature": "a -\u003e Int -\u003e a",
          "source": "src/Data-Bits.html#rotate",
          "type": "method"
        },
        "index": {
          "description": "rotate rotates left by bits if is positive or right by bits otherwise For unbounded types like Integer rotate is equivalent to shift An instance can define either this unified rotate or rotateL and rotateR depending on which is more convenient for the type in question",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "rotate",
          "normalized": "a-\u003eInt-\u003ea",
          "package": "base",
          "signature": "a-\u003eInt-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:rotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotate the argument left by the specified number of bits\n        (which must be non-negative).\n\u003c/p\u003e\u003cp\u003eAn instance can define either this and \u003ccode\u003e\u003ca\u003erotateR\u003c/a\u003e\u003c/code\u003e or the unified\n        \u003ccode\u003e\u003ca\u003erotate\u003c/a\u003e\u003c/code\u003e, depending on which is more convenient for the type in\n        question. \n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "rotateL",
          "package": "base",
          "signature": "a -\u003e Int -\u003e a",
          "source": "src/Data-Bits.html#rotateL",
          "type": "method"
        },
        "index": {
          "description": "Rotate the argument left by the specified number of bits which must be non-negative An instance can define either this and rotateR or the unified rotate depending on which is more convenient for the type in question",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "rotateL",
          "normalized": "a-\u003eInt-\u003ea",
          "package": "base",
          "signature": "a-\u003eInt-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:rotateL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotate the argument right by the specified number of bits\n        (which must be non-negative).\n\u003c/p\u003e\u003cp\u003eAn instance can define either this and \u003ccode\u003e\u003ca\u003erotateL\u003c/a\u003e\u003c/code\u003e or the unified\n        \u003ccode\u003e\u003ca\u003erotate\u003c/a\u003e\u003c/code\u003e, depending on which is more convenient for the type in\n        question. \n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "rotateR",
          "package": "base",
          "signature": "a -\u003e Int -\u003e a",
          "source": "src/Data-Bits.html#rotateR",
          "type": "method"
        },
        "index": {
          "description": "Rotate the argument right by the specified number of bits which must be non-negative An instance can define either this and rotateL or the unified rotate depending on which is more convenient for the type in question",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "rotateR",
          "normalized": "a-\u003eInt-\u003ea",
          "package": "base",
          "signature": "a-\u003eInt-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:rotateR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ex `setBit` i\u003c/code\u003e is the same as \u003ccode\u003ex .|. bit i\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "setBit",
          "package": "base",
          "signature": "a -\u003e Int -\u003e a",
          "source": "src/Data-Bits.html#setBit",
          "type": "method"
        },
        "index": {
          "description": "setBit is the same as bit",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "setBit",
          "normalized": "a-\u003eInt-\u003ea",
          "package": "base",
          "partial": "Bit",
          "signature": "a-\u003eInt-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:setBit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eshift\u003c/a\u003e\u003c/code\u003e x i\u003c/code\u003e shifts \u003ccode\u003ex\u003c/code\u003e left by \u003ccode\u003ei\u003c/code\u003e bits if \u003ccode\u003ei\u003c/code\u003e is positive,\n        or right by \u003ccode\u003e-i\u003c/code\u003e bits otherwise.\n        Right shifts perform sign extension on signed number types;\n        i.e. they fill the top bits with 1 if the \u003ccode\u003ex\u003c/code\u003e is negative\n        and with 0 otherwise.\n\u003c/p\u003e\u003cp\u003eAn instance can define either this unified \u003ccode\u003e\u003ca\u003eshift\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eshiftL\u003c/a\u003e\u003c/code\u003e and\n        \u003ccode\u003e\u003ca\u003eshiftR\u003c/a\u003e\u003c/code\u003e, depending on which is more convenient for the type in\n        question. \n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "shift",
          "package": "base",
          "signature": "a -\u003e Int -\u003e a",
          "source": "src/Data-Bits.html#shift",
          "type": "method"
        },
        "index": {
          "description": "shift shifts left by bits if is positive or right by bits otherwise Right shifts perform sign extension on signed number types i.e they fill the top bits with if the is negative and with otherwise An instance can define either this unified shift or shiftL and shiftR depending on which is more convenient for the type in question",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "shift",
          "normalized": "a-\u003eInt-\u003ea",
          "package": "base",
          "signature": "a-\u003eInt-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:shift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShift the argument left by the specified number of bits\n        (which must be non-negative).\n\u003c/p\u003e\u003cp\u003eAn instance can define either this and \u003ccode\u003e\u003ca\u003eshiftR\u003c/a\u003e\u003c/code\u003e or the unified\n        \u003ccode\u003e\u003ca\u003eshift\u003c/a\u003e\u003c/code\u003e, depending on which is more convenient for the type in\n        question. \n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "shiftL",
          "package": "base",
          "signature": "a -\u003e Int -\u003e a",
          "source": "src/Data-Bits.html#shiftL",
          "type": "method"
        },
        "index": {
          "description": "Shift the argument left by the specified number of bits which must be non-negative An instance can define either this and shiftR or the unified shift depending on which is more convenient for the type in question",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "shiftL",
          "normalized": "a-\u003eInt-\u003ea",
          "package": "base",
          "signature": "a-\u003eInt-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:shiftL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShift the first argument right by the specified number of bits. The\n        result is undefined for negative shift amounts and shift amounts\n        greater or equal to the \u003ccode\u003e\u003ca\u003ebitSize\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eRight shifts perform sign extension on signed number types;\n        i.e. they fill the top bits with 1 if the \u003ccode\u003ex\u003c/code\u003e is negative\n        and with 0 otherwise.\n\u003c/p\u003e\u003cp\u003eAn instance can define either this and \u003ccode\u003e\u003ca\u003eshiftL\u003c/a\u003e\u003c/code\u003e or the unified\n        \u003ccode\u003e\u003ca\u003eshift\u003c/a\u003e\u003c/code\u003e, depending on which is more convenient for the type in\n        question. \n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "shiftR",
          "package": "base",
          "signature": "a -\u003e Int -\u003e a",
          "source": "src/Data-Bits.html#shiftR",
          "type": "method"
        },
        "index": {
          "description": "Shift the first argument right by the specified number of bits The result is undefined for negative shift amounts and shift amounts greater or equal to the bitSize Right shifts perform sign extension on signed number types i.e they fill the top bits with if the is negative and with otherwise An instance can define either this and shiftL or the unified shift depending on which is more convenient for the type in question",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "shiftR",
          "normalized": "a-\u003eInt-\u003ea",
          "package": "base",
          "signature": "a-\u003eInt-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:shiftR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the \u003ccode\u003en\u003c/code\u003eth bit of the argument is 1\n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "testBit",
          "package": "base",
          "signature": "a -\u003e Int -\u003e Bool",
          "source": "src/Data-Bits.html#testBit",
          "type": "method"
        },
        "index": {
          "description": "Return True if the th bit of the argument is",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "testBit",
          "normalized": "a-\u003eInt-\u003eBool",
          "package": "base",
          "partial": "Bit",
          "signature": "a-\u003eInt-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:testBit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault implementation for \u003ccode\u003e\u003ca\u003etestBit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that: \u003ccode\u003etestBitDefault x i = (x .&. bit i) /= 0\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "testBitDefault",
          "package": "base",
          "signature": "a -\u003e Int -\u003e Bool",
          "source": "src/Data-Bits.html#testBitDefault",
          "type": "function"
        },
        "index": {
          "description": "Default implementation for testBit Note that testBitDefault bit",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "testBitDefault",
          "normalized": "a-\u003eInt-\u003eBool",
          "package": "base",
          "partial": "Bit Default",
          "signature": "a-\u003eInt-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:testBitDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShift the argument left by the specified number of bits.  The\n        result is undefined for negative shift amounts and shift amounts\n        greater or equal to the \u003ccode\u003e\u003ca\u003ebitSize\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eDefaults to \u003ccode\u003e\u003ca\u003eshiftL\u003c/a\u003e\u003c/code\u003e unless defined explicitly by an instance. \n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "unsafeShiftL",
          "package": "base",
          "signature": "a -\u003e Int -\u003e a",
          "source": "src/Data-Bits.html#unsafeShiftL",
          "type": "method"
        },
        "index": {
          "description": "Shift the argument left by the specified number of bits The result is undefined for negative shift amounts and shift amounts greater or equal to the bitSize Defaults to shiftL unless defined explicitly by an instance",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "unsafeShiftL",
          "normalized": "a-\u003eInt-\u003ea",
          "package": "base",
          "partial": "Shift",
          "signature": "a-\u003eInt-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:unsafeShiftL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShift the first argument right by the specified number of bits, which\n        must be non-negative an smaller than the number of bits in the type.\n\u003c/p\u003e\u003cp\u003eRight shifts perform sign extension on signed number types;\n        i.e. they fill the top bits with 1 if the \u003ccode\u003ex\u003c/code\u003e is negative\n        and with 0 otherwise.\n\u003c/p\u003e\u003cp\u003eDefaults to \u003ccode\u003e\u003ca\u003eshiftR\u003c/a\u003e\u003c/code\u003e unless defined explicitly by an instance. \n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "unsafeShiftR",
          "package": "base",
          "signature": "a -\u003e Int -\u003e a",
          "source": "src/Data-Bits.html#unsafeShiftR",
          "type": "method"
        },
        "index": {
          "description": "Shift the first argument right by the specified number of bits which must be non-negative an smaller than the number of bits in the type Right shifts perform sign extension on signed number types i.e they fill the top bits with if the is negative and with otherwise Defaults to shiftR unless defined explicitly by an instance",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "unsafeShiftR",
          "normalized": "a-\u003eInt-\u003ea",
          "package": "base",
          "partial": "Shift",
          "signature": "a-\u003eInt-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:unsafeShiftR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBitwise \"xor\"\n\u003c/p\u003e",
          "module": "Data.Bits",
          "name": "xor",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Data-Bits.html#xor",
          "type": "method"
        },
        "index": {
          "description": "Bitwise xor",
          "hierarchy": "Data Bits",
          "module": "Data.Bits",
          "name": "xor",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bits.html#v:xor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e type and related functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Bool",
          "name": "Bool",
          "package": "base",
          "source": "src/Data-Bool.html",
          "type": "module"
        },
        "index": {
          "description": "The Bool type and related functions",
          "hierarchy": "Data Bool",
          "module": "Data.Bool",
          "name": "Bool",
          "package": "base",
          "partial": "Bool",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bool.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Bool",
          "name": "Bool",
          "package": "base",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Bool",
          "module": "Data.Bool",
          "name": "Bool",
          "package": "base",
          "partial": "Bool",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoolean \"or\"\n\u003c/p\u003e",
          "module": "[\"Data.Bool\",\"Prelude\"]",
          "name": "(||)",
          "package": "base",
          "signature": "Bool -\u003e Bool -\u003e Bool",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Bool.html#v:-124--124-\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:-124--124-\"]"
        },
        "index": {
          "description": "Boolean or",
          "hierarchy": "Data Bool",
          "module": "Data.Bool",
          "name": "(||) ||",
          "normalized": "Bool-\u003eBool-\u003eBool",
          "package": "base",
          "signature": "Bool-\u003eBool-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bool.html#v:-124--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoolean \"and\"\n\u003c/p\u003e",
          "module": "[\"Data.Bool\",\"Prelude\"]",
          "name": "(&&)",
          "package": "base",
          "signature": "Bool -\u003e Bool -\u003e Bool",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Bool.html#v:-38--38-\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:-38--38-\"]"
        },
        "index": {
          "description": "Boolean and",
          "hierarchy": "Data Bool",
          "module": "Data.Bool",
          "name": "(&&) &&",
          "normalized": "Bool-\u003eBool-\u003eBool",
          "package": "base",
          "signature": "Bool-\u003eBool-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bool.html#v:-38--38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Bool\",\"Prelude\"]",
          "name": "False",
          "package": "base",
          "signature": "False",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Bool.html#v:False\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:False\"]"
        },
        "index": {
          "hierarchy": "Data Bool",
          "module": "Data.Bool",
          "name": "False",
          "package": "base",
          "partial": "False",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bool.html#v:False"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Bool\",\"Prelude\"]",
          "name": "True",
          "package": "base",
          "signature": "True",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Bool.html#v:True\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:True\"]"
        },
        "index": {
          "hierarchy": "Data Bool",
          "module": "Data.Bool",
          "name": "True",
          "package": "base",
          "partial": "True",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bool.html#v:True"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoolean \"not\"\n\u003c/p\u003e",
          "module": "[\"Data.Bool\",\"Prelude\"]",
          "name": "not",
          "package": "base",
          "signature": "Bool -\u003e Bool",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Bool.html#v:not\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:not\"]"
        },
        "index": {
          "description": "Boolean not",
          "hierarchy": "Data Bool",
          "module": "Data.Bool",
          "name": "not",
          "normalized": "Bool-\u003eBool",
          "package": "base",
          "signature": "Bool-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bool.html#v:not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eotherwise\u003c/a\u003e\u003c/code\u003e is defined as the value \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.  It helps to make\n guards more readable.  eg.\n\u003c/p\u003e\u003cpre\u003e  f x | x \u003c 0     = ...\n      | otherwise = ...\n\u003c/pre\u003e",
          "module": "[\"Data.Bool\",\"Prelude\"]",
          "name": "otherwise",
          "package": "base",
          "signature": "Bool",
          "source": "src/GHC-Base.html#otherwise",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Bool.html#v:otherwise\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:otherwise\"]"
        },
        "index": {
          "description": "otherwise is defined as the value True It helps to make guards more readable eg otherwise",
          "hierarchy": "Data Bool",
          "module": "Data.Bool",
          "name": "otherwise",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Bool.html#v:otherwise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe Char type and associated operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Char",
          "name": "Char",
          "package": "base",
          "source": "src/Data-Char.html",
          "type": "module"
        },
        "index": {
          "description": "The Char type and associated operations",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "Char",
          "package": "base",
          "partial": "Char",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe character type \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e is an enumeration whose values represent\nUnicode (or equivalently ISO/IEC 10646) characters (see\n\u003ca\u003ehttp://www.unicode.org/\u003c/a\u003e for details).  This set extends the ISO 8859-1\n(Latin-1) character set (the first 256 characters), which is itself an extension\nof the ASCII character set (the first 128 characters).  A character literal in\nHaskell has type \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eTo convert a \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e to or from the corresponding \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e value defined\nby Unicode, use \u003ccode\u003e\u003ca\u003etoEnum\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efromEnum\u003c/a\u003e\u003c/code\u003e from the\n\u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e class respectively (or equivalently \u003ccode\u003eord\u003c/code\u003e and \u003ccode\u003echr\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "Char",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "The character type Char is an enumeration whose values represent Unicode or equivalently ISO IEC characters see http www.unicode.org for details This set extends the ISO Latin-1 character set the first characters which is itself an extension of the ASCII character set the first characters character literal in Haskell has type Char To convert Char to or from the corresponding Int value defined by Unicode use toEnum and fromEnum from the Enum class respectively or equivalently ord and chr",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "Char",
          "package": "base",
          "partial": "Char",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#t:Char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnicode General Categories (column 2 of the UnicodeData table)\n in the order they are listed in the Unicode standard.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "GeneralCategory",
          "package": "base",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "data"
        },
        "index": {
          "description": "Unicode General Categories column of the UnicodeData table in the order they are listed in the Unicode standard",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "GeneralCategory",
          "package": "base",
          "partial": "General Category",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#t:GeneralCategory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePe: Punctuation, Close\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "ClosePunctuation",
          "package": "base",
          "signature": "ClosePunctuation",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Pe Punctuation Close",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "ClosePunctuation",
          "package": "base",
          "partial": "Close Punctuation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:ClosePunctuation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePc: Punctuation, Connector\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "ConnectorPunctuation",
          "package": "base",
          "signature": "ConnectorPunctuation",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Pc Punctuation Connector",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "ConnectorPunctuation",
          "package": "base",
          "partial": "Connector Punctuation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:ConnectorPunctuation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCc: Other, Control\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "Control",
          "package": "base",
          "signature": "Control",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Cc Other Control",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "Control",
          "package": "base",
          "partial": "Control",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:Control"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSc: Symbol, Currency\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "CurrencySymbol",
          "package": "base",
          "signature": "CurrencySymbol",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Sc Symbol Currency",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "CurrencySymbol",
          "package": "base",
          "partial": "Currency Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:CurrencySymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePd: Punctuation, Dash\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "DashPunctuation",
          "package": "base",
          "signature": "DashPunctuation",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Pd Punctuation Dash",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "DashPunctuation",
          "package": "base",
          "partial": "Dash Punctuation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:DashPunctuation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNd: Number, Decimal\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "DecimalNumber",
          "package": "base",
          "signature": "DecimalNumber",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Nd Number Decimal",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "DecimalNumber",
          "package": "base",
          "partial": "Decimal Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:DecimalNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMe: Mark, Enclosing\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "EnclosingMark",
          "package": "base",
          "signature": "EnclosingMark",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Me Mark Enclosing",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "EnclosingMark",
          "package": "base",
          "partial": "Enclosing Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:EnclosingMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePf: Punctuation, Final quote\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "FinalQuote",
          "package": "base",
          "signature": "FinalQuote",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Pf Punctuation Final quote",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "FinalQuote",
          "package": "base",
          "partial": "Final Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:FinalQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCf: Other, Format\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "Format",
          "package": "base",
          "signature": "Format",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Cf Other Format",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "Format",
          "package": "base",
          "partial": "Format",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:Format"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePi: Punctuation, Initial quote\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "InitialQuote",
          "package": "base",
          "signature": "InitialQuote",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Pi Punctuation Initial quote",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "InitialQuote",
          "package": "base",
          "partial": "Initial Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:InitialQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNl: Number, Letter\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "LetterNumber",
          "package": "base",
          "signature": "LetterNumber",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Nl Number Letter",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "LetterNumber",
          "package": "base",
          "partial": "Letter Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:LetterNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZl: Separator, Line\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "LineSeparator",
          "package": "base",
          "signature": "LineSeparator",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Zl Separator Line",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "LineSeparator",
          "package": "base",
          "partial": "Line Separator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:LineSeparator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLl: Letter, Lowercase\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "LowercaseLetter",
          "package": "base",
          "signature": "LowercaseLetter",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Ll Letter Lowercase",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "LowercaseLetter",
          "package": "base",
          "partial": "Lowercase Letter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:LowercaseLetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSm: Symbol, Math\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "MathSymbol",
          "package": "base",
          "signature": "MathSymbol",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Sm Symbol Math",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "MathSymbol",
          "package": "base",
          "partial": "Math Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:MathSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLm: Letter, Modifier\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "ModifierLetter",
          "package": "base",
          "signature": "ModifierLetter",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Lm Letter Modifier",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "ModifierLetter",
          "package": "base",
          "partial": "Modifier Letter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:ModifierLetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSk: Symbol, Modifier\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "ModifierSymbol",
          "package": "base",
          "signature": "ModifierSymbol",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Sk Symbol Modifier",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "ModifierSymbol",
          "package": "base",
          "partial": "Modifier Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:ModifierSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMn: Mark, Non-Spacing\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "NonSpacingMark",
          "package": "base",
          "signature": "NonSpacingMark",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Mn Mark Non-Spacing",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "NonSpacingMark",
          "package": "base",
          "partial": "Non Spacing Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:NonSpacingMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCn: Other, Not Assigned\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "NotAssigned",
          "package": "base",
          "signature": "NotAssigned",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Cn Other Not Assigned",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "NotAssigned",
          "package": "base",
          "partial": "Not Assigned",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:NotAssigned"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePs: Punctuation, Open\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "OpenPunctuation",
          "package": "base",
          "signature": "OpenPunctuation",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Ps Punctuation Open",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "OpenPunctuation",
          "package": "base",
          "partial": "Open Punctuation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:OpenPunctuation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLo: Letter, Other\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "OtherLetter",
          "package": "base",
          "signature": "OtherLetter",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Lo Letter Other",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "OtherLetter",
          "package": "base",
          "partial": "Other Letter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:OtherLetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo: Number, Other\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "OtherNumber",
          "package": "base",
          "signature": "OtherNumber",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "No Number Other",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "OtherNumber",
          "package": "base",
          "partial": "Other Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:OtherNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePo: Punctuation, Other\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "OtherPunctuation",
          "package": "base",
          "signature": "OtherPunctuation",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Po Punctuation Other",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "OtherPunctuation",
          "package": "base",
          "partial": "Other Punctuation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:OtherPunctuation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSo: Symbol, Other\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "OtherSymbol",
          "package": "base",
          "signature": "OtherSymbol",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "So Symbol Other",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "OtherSymbol",
          "package": "base",
          "partial": "Other Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:OtherSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZp: Separator, Paragraph\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "ParagraphSeparator",
          "package": "base",
          "signature": "ParagraphSeparator",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Zp Separator Paragraph",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "ParagraphSeparator",
          "package": "base",
          "partial": "Paragraph Separator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:ParagraphSeparator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCo: Other, Private Use\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "PrivateUse",
          "package": "base",
          "signature": "PrivateUse",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Co Other Private Use",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "PrivateUse",
          "package": "base",
          "partial": "Private Use",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:PrivateUse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZs: Separator, Space\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "Space",
          "package": "base",
          "signature": "Space",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Zs Separator Space",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "Space",
          "package": "base",
          "partial": "Space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:Space"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMc: Mark, Spacing Combining\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "SpacingCombiningMark",
          "package": "base",
          "signature": "SpacingCombiningMark",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Mc Mark Spacing Combining",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "SpacingCombiningMark",
          "package": "base",
          "partial": "Spacing Combining Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:SpacingCombiningMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCs: Other, Surrogate\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "Surrogate",
          "package": "base",
          "signature": "Surrogate",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Cs Other Surrogate",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "Surrogate",
          "package": "base",
          "partial": "Surrogate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:Surrogate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLt: Letter, Titlecase\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "TitlecaseLetter",
          "package": "base",
          "signature": "TitlecaseLetter",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Lt Letter Titlecase",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "TitlecaseLetter",
          "package": "base",
          "partial": "Titlecase Letter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:TitlecaseLetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLu: Letter, Uppercase\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "UppercaseLetter",
          "package": "base",
          "signature": "UppercaseLetter",
          "source": "src/Data-Char.html#GeneralCategory",
          "type": "function"
        },
        "index": {
          "description": "Lu Letter Uppercase",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "UppercaseLetter",
          "package": "base",
          "partial": "Uppercase Letter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:UppercaseLetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003etoEnum\u003c/a\u003e\u003c/code\u003e method restricted to the type \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.Char\",\"GHC.Char\"]",
          "name": "chr",
          "package": "base",
          "signature": "Int -\u003e Char",
          "source": "src/GHC-Char.html#chr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Char.html#v:chr\",\"http://hackage.haskell.org/package/base/docs/GHC-Char.html#v:chr\"]"
        },
        "index": {
          "description": "The toEnum method restricted to the type Char",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "chr",
          "normalized": "Int-\u003eChar",
          "package": "base",
          "signature": "Int-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:chr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a single digit \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e to the corresponding \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.  \n This function fails unless its argument satisfies \u003ccode\u003e\u003ca\u003eisHexDigit\u003c/a\u003e\u003c/code\u003e,\n but recognises both upper and lower-case hexadecimal digits\n (i.e. \u003ccode\u003e'0'\u003c/code\u003e..\u003ccode\u003e'9'\u003c/code\u003e, \u003ccode\u003e'a'\u003c/code\u003e..\u003ccode\u003e'f'\u003c/code\u003e, \u003ccode\u003e'A'\u003c/code\u003e..\u003ccode\u003e'F'\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "digitToInt",
          "package": "base",
          "signature": "Char -\u003e Int",
          "source": "src/Data-Char.html#digitToInt",
          "type": "function"
        },
        "index": {
          "description": "Convert single digit Char to the corresponding Int This function fails unless its argument satisfies isHexDigit but recognises both upper and lower-case hexadecimal digits i.e",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "digitToInt",
          "normalized": "Char-\u003eInt",
          "package": "base",
          "partial": "To Int",
          "signature": "Char-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:digitToInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Unicode general category of the character.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "generalCategory",
          "package": "base",
          "signature": "Char -\u003e GeneralCategory",
          "source": "src/Data-Char.html#generalCategory",
          "type": "function"
        },
        "index": {
          "description": "The Unicode general category of the character",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "generalCategory",
          "normalized": "Char-\u003eGeneralCategory",
          "package": "base",
          "partial": "Category",
          "signature": "Char-\u003eGeneralCategory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:generalCategory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e in the range \u003ccode\u003e0\u003c/code\u003e..\u003ccode\u003e15\u003c/code\u003e to the corresponding single\n digit \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e.  This function fails on other inputs, and generates\n lower-case hexadecimal digits.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "intToDigit",
          "package": "base",
          "signature": "Int -\u003e Char",
          "source": "src/GHC-Show.html#intToDigit",
          "type": "function"
        },
        "index": {
          "description": "Convert an Int in the range to the corresponding single digit Char This function fails on other inputs and generates lower-case hexadecimal digits",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "intToDigit",
          "normalized": "Int-\u003eChar",
          "package": "base",
          "partial": "To Digit",
          "signature": "Int-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:intToDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects alphabetic Unicode characters (lower-case, upper-case and\n title-case letters, plus letters of caseless scripts and modifiers letters).\n This function is equivalent to \u003ccode\u003e\u003ca\u003eisLetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isAlpha",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-Unicode.html#isAlpha",
          "type": "function"
        },
        "index": {
          "description": "Selects alphabetic Unicode characters lower-case upper-case and title-case letters plus letters of caseless scripts and modifiers letters This function is equivalent to isLetter",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isAlpha",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Alpha",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isAlpha"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects alphabetic or numeric digit Unicode characters.\n\u003c/p\u003e\u003cp\u003eNote that numeric digits outside the ASCII range are selected by this\n function but not by \u003ccode\u003e\u003ca\u003eisDigit\u003c/a\u003e\u003c/code\u003e.  Such digits may be part of identifiers\n but are not used by the printer and reader to represent numbers.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isAlphaNum",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-Unicode.html#isAlphaNum",
          "type": "function"
        },
        "index": {
          "description": "Selects alphabetic or numeric digit Unicode characters Note that numeric digits outside the ASCII range are selected by this function but not by isDigit Such digits may be part of identifiers but are not used by the printer and reader to represent numbers",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isAlphaNum",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Alpha Num",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isAlphaNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects the first 128 characters of the Unicode character set,\n corresponding to the ASCII character set.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isAscii",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-Unicode.html#isAscii",
          "type": "function"
        },
        "index": {
          "description": "Selects the first characters of the Unicode character set corresponding to the ASCII character set",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isAscii",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Ascii",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isAscii"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects ASCII lower-case letters,\n i.e. characters satisfying both \u003ccode\u003e\u003ca\u003eisAscii\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eisLower\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isAsciiLower",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-Unicode.html#isAsciiLower",
          "type": "function"
        },
        "index": {
          "description": "Selects ASCII lower-case letters i.e characters satisfying both isAscii and isLower",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isAsciiLower",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Ascii Lower",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isAsciiLower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects ASCII upper-case letters,\n i.e. characters satisfying both \u003ccode\u003e\u003ca\u003eisAscii\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eisUpper\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isAsciiUpper",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-Unicode.html#isAsciiUpper",
          "type": "function"
        },
        "index": {
          "description": "Selects ASCII upper-case letters i.e characters satisfying both isAscii and isUpper",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isAsciiUpper",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Ascii Upper",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isAsciiUpper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects control characters, which are the non-printing characters of\n the Latin-1 subset of Unicode.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isControl",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-Unicode.html#isControl",
          "type": "function"
        },
        "index": {
          "description": "Selects control characters which are the non-printing characters of the Latin-1 subset of Unicode",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isControl",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Control",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isControl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects ASCII digits, i.e. \u003ccode\u003e'0'\u003c/code\u003e..\u003ccode\u003e'9'\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isDigit",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-Unicode.html#isDigit",
          "type": "function"
        },
        "index": {
          "description": "Selects ASCII digits i.e",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isDigit",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Digit",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects ASCII hexadecimal digits,\n i.e. \u003ccode\u003e'0'\u003c/code\u003e..\u003ccode\u003e'9'\u003c/code\u003e, \u003ccode\u003e'a'\u003c/code\u003e..\u003ccode\u003e'f'\u003c/code\u003e, \u003ccode\u003e'A'\u003c/code\u003e..\u003ccode\u003e'F'\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isHexDigit",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-Unicode.html#isHexDigit",
          "type": "function"
        },
        "index": {
          "description": "Selects ASCII hexadecimal digits i.e",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isHexDigit",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Hex Digit",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isHexDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects the first 256 characters of the Unicode character set,\n corresponding to the ISO 8859-1 (Latin-1) character set.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isLatin1",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-Unicode.html#isLatin1",
          "type": "function"
        },
        "index": {
          "description": "Selects the first characters of the Unicode character set corresponding to the ISO Latin-1 character set",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isLatin1",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Latin",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isLatin1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects alphabetic Unicode characters (lower-case, upper-case and\n title-case letters, plus letters of caseless scripts and modifiers letters).\n This function is equivalent to \u003ccode\u003e\u003ca\u003eisAlpha\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isLetter",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/Data-Char.html#isLetter",
          "type": "function"
        },
        "index": {
          "description": "Selects alphabetic Unicode characters lower-case upper-case and title-case letters plus letters of caseless scripts and modifiers letters This function is equivalent to isAlpha",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isLetter",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Letter",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isLetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects lower-case alphabetic Unicode characters (letters).\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isLower",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-Unicode.html#isLower",
          "type": "function"
        },
        "index": {
          "description": "Selects lower-case alphabetic Unicode characters letters",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isLower",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Lower",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isLower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects Unicode mark characters, e.g. accents and the like, which\n combine with preceding letters.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isMark",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/Data-Char.html#isMark",
          "type": "function"
        },
        "index": {
          "description": "Selects Unicode mark characters e.g accents and the like which combine with preceding letters",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isMark",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Mark",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects Unicode numeric characters, including digits from various\n scripts, Roman numerals, etc.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isNumber",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/Data-Char.html#isNumber",
          "type": "function"
        },
        "index": {
          "description": "Selects Unicode numeric characters including digits from various scripts Roman numerals etc",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isNumber",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Number",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects ASCII octal digits, i.e. \u003ccode\u003e'0'\u003c/code\u003e..\u003ccode\u003e'7'\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isOctDigit",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-Unicode.html#isOctDigit",
          "type": "function"
        },
        "index": {
          "description": "Selects ASCII octal digits i.e",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isOctDigit",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Oct Digit",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isOctDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects printable Unicode characters\n (letters, numbers, marks, punctuation, symbols and spaces).\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isPrint",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-Unicode.html#isPrint",
          "type": "function"
        },
        "index": {
          "description": "Selects printable Unicode characters letters numbers marks punctuation symbols and spaces",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isPrint",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Print",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isPrint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects Unicode punctuation characters, including various kinds\n of connectors, brackets and quotes.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isPunctuation",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/Data-Char.html#isPunctuation",
          "type": "function"
        },
        "index": {
          "description": "Selects Unicode punctuation characters including various kinds of connectors brackets and quotes",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isPunctuation",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Punctuation",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isPunctuation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects Unicode space and separator characters.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isSeparator",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/Data-Char.html#isSeparator",
          "type": "function"
        },
        "index": {
          "description": "Selects Unicode space and separator characters",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isSeparator",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Separator",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isSeparator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e for any Unicode space character, and the control\n characters \u003ccode\u003e\\t\u003c/code\u003e, \u003ccode\u003e\\n\u003c/code\u003e, \u003ccode\u003e\\r\u003c/code\u003e, \u003ccode\u003e\\f\u003c/code\u003e, \u003ccode\u003e\\v\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isSpace",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-Unicode.html#isSpace",
          "type": "function"
        },
        "index": {
          "description": "Returns True for any Unicode space character and the control characters",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isSpace",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Space",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects Unicode symbol characters, including mathematical and\n currency symbols.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isSymbol",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/Data-Char.html#isSymbol",
          "type": "function"
        },
        "index": {
          "description": "Selects Unicode symbol characters including mathematical and currency symbols",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isSymbol",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Symbol",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelects upper-case or title-case alphabetic Unicode characters (letters).\n Title case is used by a small number of letter ligatures like the\n single-character form of \u003cem\u003eLj\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "isUpper",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-Unicode.html#isUpper",
          "type": "function"
        },
        "index": {
          "description": "Selects upper-case or title-case alphabetic Unicode characters letters Title case is used by small number of letter ligatures like the single-character form of Lj",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "isUpper",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Upper",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:isUpper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a string representation of a character, using Haskell\n source-language escape conventions.  For example:\n\u003c/p\u003e\u003cpre\u003e lexLitChar  \"\\\\nHello\"  =  [(\"\\\\n\", \"Hello\")]\n\u003c/pre\u003e",
          "module": "Data.Char",
          "name": "lexLitChar",
          "package": "base",
          "signature": "ReadS String",
          "source": "src/GHC-Read.html#lexLitChar",
          "type": "function"
        },
        "index": {
          "description": "Read string representation of character using Haskell source-language escape conventions For example lexLitChar nHello Hello",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "lexLitChar",
          "package": "base",
          "partial": "Lit Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:lexLitChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efromEnum\u003c/a\u003e\u003c/code\u003e method restricted to the type \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "ord",
          "package": "base",
          "signature": "Char -\u003e Int",
          "source": "src/GHC-Base.html#ord",
          "type": "function"
        },
        "index": {
          "description": "The fromEnum method restricted to the type Char",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "ord",
          "normalized": "Char-\u003eInt",
          "package": "base",
          "signature": "Char-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:ord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a string representation of a character, using Haskell\n source-language escape conventions, and convert it to the character\n that it encodes.  For example:\n\u003c/p\u003e\u003cpre\u003e readLitChar \"\\\\nHello\"  =  [('\\n', \"Hello\")]\n\u003c/pre\u003e",
          "module": "Data.Char",
          "name": "readLitChar",
          "package": "base",
          "signature": "ReadS Char",
          "source": "src/GHC-Read.html#readLitChar",
          "type": "function"
        },
        "index": {
          "description": "Read string representation of character using Haskell source-language escape conventions and convert it to the character that it encodes For example readLitChar nHello Hello",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "readLitChar",
          "package": "base",
          "partial": "Lit Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:readLitChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a character to a string using only printable characters,\n using Haskell source-language escape conventions.  For example:\n\u003c/p\u003e\u003cpre\u003e showLitChar '\\n' s  =  \"\\\\n\" ++ s\n\u003c/pre\u003e",
          "module": "Data.Char",
          "name": "showLitChar",
          "package": "base",
          "signature": "Char -\u003e ShowS",
          "source": "src/GHC-Show.html#showLitChar",
          "type": "function"
        },
        "index": {
          "description": "Convert character to string using only printable characters using Haskell source-language escape conventions For example showLitChar",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "showLitChar",
          "normalized": "Char-\u003eShowS",
          "package": "base",
          "partial": "Lit Char",
          "signature": "Char-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:showLitChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a letter to the corresponding lower-case letter, if any.\n Any other character is returned unchanged.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "toLower",
          "package": "base",
          "signature": "Char -\u003e Char",
          "source": "src/GHC-Unicode.html#toLower",
          "type": "function"
        },
        "index": {
          "description": "Convert letter to the corresponding lower-case letter if any Any other character is returned unchanged",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "toLower",
          "normalized": "Char-\u003eChar",
          "package": "base",
          "partial": "Lower",
          "signature": "Char-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:toLower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a letter to the corresponding title-case or upper-case\n letter, if any.  (Title case differs from upper case only for a small\n number of ligature letters.)\n Any other character is returned unchanged.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "toTitle",
          "package": "base",
          "signature": "Char -\u003e Char",
          "source": "src/GHC-Unicode.html#toTitle",
          "type": "function"
        },
        "index": {
          "description": "Convert letter to the corresponding title-case or upper-case letter if any Title case differs from upper case only for small number of ligature letters Any other character is returned unchanged",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "toTitle",
          "normalized": "Char-\u003eChar",
          "package": "base",
          "partial": "Title",
          "signature": "Char-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:toTitle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a letter to the corresponding upper-case letter, if any.\n Any other character is returned unchanged.\n\u003c/p\u003e",
          "module": "Data.Char",
          "name": "toUpper",
          "package": "base",
          "signature": "Char -\u003e Char",
          "source": "src/GHC-Unicode.html#toUpper",
          "type": "function"
        },
        "index": {
          "description": "Convert letter to the corresponding upper-case letter if any Any other character is returned unchanged",
          "hierarchy": "Data Char",
          "module": "Data.Char",
          "name": "toUpper",
          "normalized": "Char-\u003eChar",
          "package": "base",
          "partial": "Upper",
          "signature": "Char-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Char.html#v:toUpper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eComplex numbers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Complex",
          "name": "Complex",
          "package": "base",
          "source": "src/Data-Complex.html",
          "type": "module"
        },
        "index": {
          "description": "Complex numbers",
          "hierarchy": "Data Complex",
          "module": "Data.Complex",
          "name": "Complex",
          "package": "base",
          "partial": "Complex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Complex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComplex numbers are an algebraic type.\n\u003c/p\u003e\u003cp\u003eFor a complex number \u003ccode\u003ez\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e z\u003c/code\u003e is a number with the magnitude of \u003ccode\u003ez\u003c/code\u003e,\n but oriented in the positive real direction, whereas \u003ccode\u003e\u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e z\u003c/code\u003e\n has the phase of \u003ccode\u003ez\u003c/code\u003e, but unit magnitude.\n\u003c/p\u003e",
          "module": "Data.Complex",
          "name": "Complex",
          "package": "base",
          "source": "src/Data-Complex.html#Complex",
          "type": "data"
        },
        "index": {
          "description": "Complex numbers are an algebraic type For complex number abs is number with the magnitude of but oriented in the positive real direction whereas signum has the phase of but unit magnitude",
          "hierarchy": "Data Complex",
          "module": "Data.Complex",
          "name": "Complex",
          "package": "base",
          "partial": "Complex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Complex.html#t:Complex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eforms a complex number from its real and imaginary\n rectangular components.\n\u003c/p\u003e",
          "module": "Data.Complex",
          "name": ":+",
          "package": "base",
          "signature": "a :+ !a",
          "source": "src/Data-Complex.html#Complex",
          "type": "function"
        },
        "index": {
          "description": "forms complex number from its real and imaginary rectangular components",
          "hierarchy": "Data Complex",
          "module": "Data.Complex",
          "name": ":+",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Complex.html#v::-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ecis\u003c/a\u003e\u003c/code\u003e t\u003c/code\u003e is a complex value with magnitude \u003ccode\u003e1\u003c/code\u003e\n and phase \u003ccode\u003et\u003c/code\u003e (modulo \u003ccode\u003e2*\u003ccode\u003e\u003ca\u003epi\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Data.Complex",
          "name": "cis",
          "package": "base",
          "signature": "a -\u003e Complex a",
          "source": "src/Data-Complex.html#cis",
          "type": "function"
        },
        "index": {
          "description": "cis is complex value with magnitude and phase modulo pi",
          "hierarchy": "Data Complex",
          "module": "Data.Complex",
          "name": "cis",
          "normalized": "a-\u003eComplex a",
          "package": "base",
          "signature": "a-\u003eComplex a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Complex.html#v:cis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe conjugate of a complex number.\n\u003c/p\u003e",
          "module": "Data.Complex",
          "name": "conjugate",
          "package": "base",
          "signature": "Complex a -\u003e Complex a",
          "source": "src/Data-Complex.html#conjugate",
          "type": "function"
        },
        "index": {
          "description": "The conjugate of complex number",
          "hierarchy": "Data Complex",
          "module": "Data.Complex",
          "name": "conjugate",
          "normalized": "Complex a-\u003eComplex a",
          "package": "base",
          "signature": "Complex a-\u003eComplex a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Complex.html#v:conjugate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtracts the imaginary part of a complex number.\n\u003c/p\u003e",
          "module": "Data.Complex",
          "name": "imagPart",
          "package": "base",
          "signature": "Complex a -\u003e a",
          "source": "src/Data-Complex.html#imagPart",
          "type": "function"
        },
        "index": {
          "description": "Extracts the imaginary part of complex number",
          "hierarchy": "Data Complex",
          "module": "Data.Complex",
          "name": "imagPart",
          "normalized": "Complex a-\u003ea",
          "package": "base",
          "partial": "Part",
          "signature": "Complex a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Complex.html#v:imagPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe nonnegative magnitude of a complex number.\n\u003c/p\u003e",
          "module": "Data.Complex",
          "name": "magnitude",
          "package": "base",
          "signature": "Complex a -\u003e a",
          "source": "src/Data-Complex.html#magnitude",
          "type": "function"
        },
        "index": {
          "description": "The nonnegative magnitude of complex number",
          "hierarchy": "Data Complex",
          "module": "Data.Complex",
          "name": "magnitude",
          "normalized": "Complex a-\u003ea",
          "package": "base",
          "signature": "Complex a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Complex.html#v:magnitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForm a complex number from polar components of magnitude and phase.\n\u003c/p\u003e",
          "module": "Data.Complex",
          "name": "mkPolar",
          "package": "base",
          "signature": "a -\u003e a -\u003e Complex a",
          "source": "src/Data-Complex.html#mkPolar",
          "type": "function"
        },
        "index": {
          "description": "Form complex number from polar components of magnitude and phase",
          "hierarchy": "Data Complex",
          "module": "Data.Complex",
          "name": "mkPolar",
          "normalized": "a-\u003ea-\u003eComplex a",
          "package": "base",
          "partial": "Polar",
          "signature": "a-\u003ea-\u003eComplex a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Complex.html#v:mkPolar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe phase of a complex number, in the range \u003ccode\u003e(-\u003ccode\u003e\u003ca\u003epi\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003epi\u003c/a\u003e\u003c/code\u003e]\u003c/code\u003e.\n If the magnitude is zero, then so is the phase.\n\u003c/p\u003e",
          "module": "Data.Complex",
          "name": "phase",
          "package": "base",
          "signature": "Complex a -\u003e a",
          "source": "src/Data-Complex.html#phase",
          "type": "function"
        },
        "index": {
          "description": "The phase of complex number in the range pi pi If the magnitude is zero then so is the phase",
          "hierarchy": "Data Complex",
          "module": "Data.Complex",
          "name": "phase",
          "normalized": "Complex a-\u003ea",
          "package": "base",
          "signature": "Complex a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Complex.html#v:phase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003epolar\u003c/a\u003e\u003c/code\u003e takes a complex number and\n returns a (magnitude, phase) pair in canonical form:\n the magnitude is nonnegative, and the phase in the range \u003ccode\u003e(-\u003ccode\u003e\u003ca\u003epi\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003epi\u003c/a\u003e\u003c/code\u003e]\u003c/code\u003e;\n if the magnitude is zero, then so is the phase.\n\u003c/p\u003e",
          "module": "Data.Complex",
          "name": "polar",
          "package": "base",
          "signature": "Complex a -\u003e (a, a)",
          "source": "src/Data-Complex.html#polar",
          "type": "function"
        },
        "index": {
          "description": "The function polar takes complex number and returns magnitude phase pair in canonical form the magnitude is nonnegative and the phase in the range pi pi if the magnitude is zero then so is the phase",
          "hierarchy": "Data Complex",
          "module": "Data.Complex",
          "name": "polar",
          "normalized": "Complex a-\u003e(a,a)",
          "package": "base",
          "signature": "Complex a-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Complex.html#v:polar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtracts the real part of a complex number.\n\u003c/p\u003e",
          "module": "Data.Complex",
          "name": "realPart",
          "package": "base",
          "signature": "Complex a -\u003e a",
          "source": "src/Data-Complex.html#realPart",
          "type": "function"
        },
        "index": {
          "description": "Extracts the real part of complex number",
          "hierarchy": "Data Complex",
          "module": "Data.Complex",
          "name": "realPart",
          "normalized": "Complex a-\u003ea",
          "package": "base",
          "partial": "Part",
          "signature": "Complex a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Complex.html#v:realPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\"Scrap your boilerplate\" --- Generic programming in Haskell.\n See \u003ca\u003ehttp://www.cs.vu.nl/boilerplate/\u003c/a\u003e. This module provides\n the \u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e class with its primitives for generic programming, along\n with instances for many datatypes. It corresponds to a merge between\n the previous \u003ca\u003eData.Generics.Basics\u003c/a\u003e and almost all of \n \u003ca\u003eData.Generics.Instances\u003c/a\u003e. The instances that are not present\n in this module were moved to the \u003ccode\u003eData.Generics.Instances\u003c/code\u003e module\n in the \u003ccode\u003esyb\u003c/code\u003e package.\n\u003c/p\u003e\u003cp\u003eFor more information, please visit the new\n SYB wiki: \u003ca\u003ehttp://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Data",
          "name": "Data",
          "package": "base",
          "source": "src/Data-Data.html",
          "type": "module"
        },
        "index": {
          "description": "Scrap your boilerplate Generic programming in Haskell See http www.cs.vu.nl boilerplate This module provides the Data class with its primitives for generic programming along with instances for many datatypes It corresponds to merge between the previous Data.Generics.Basics and almost all of Data.Generics.Instances The instances that are not present in this module were moved to the Data.Generics.Instances module in the syb package For more information please visit the new SYB wiki http www.cs.uu.nl wiki bin view GenericProgramming SYB",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "Data",
          "package": "base",
          "partial": "Data",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnique index for datatype constructors,\n counting from 1 in the order they are given in the program text.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "ConIndex",
          "package": "base",
          "source": "src/Data-Data.html#ConIndex",
          "type": "type"
        },
        "index": {
          "description": "Unique index for datatype constructors counting from in the order they are given in the program text",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "ConIndex",
          "package": "base",
          "partial": "Con Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#t:ConIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresentation of constructors. Note that equality on constructors\n with different types may not work -- i.e. the constructors for \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e may compare equal.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "Constr",
          "package": "base",
          "source": "src/Data-Data.html#Constr",
          "type": "data"
        },
        "index": {
          "description": "Representation of constructors Note that equality on constructors with different types may not work i.e the constructors for False and Nothing may compare equal",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "Constr",
          "package": "base",
          "partial": "Constr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#t:Constr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePublic representation of constructors\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "ConstrRep",
          "package": "base",
          "source": "src/Data-Data.html#ConstrRep",
          "type": "data"
        },
        "index": {
          "description": "Public representation of constructors",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "ConstrRep",
          "package": "base",
          "partial": "Constr Rep",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#t:ConstrRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e class comprehends a fundamental primitive \u003ccode\u003e\u003ca\u003egfoldl\u003c/a\u003e\u003c/code\u003e for\nfolding over constructor applications, say terms. This primitive can\nbe instantiated in several ways to map over the immediate subterms\nof a term; see the \u003ccode\u003egmap\u003c/code\u003e combinators later in this class.  Indeed, a\ngeneric programmer does not necessarily need to use the ingenious gfoldl\nprimitive but rather the intuitive \u003ccode\u003egmap\u003c/code\u003e combinators.  The \u003ccode\u003e\u003ca\u003egfoldl\u003c/a\u003e\u003c/code\u003e\nprimitive is completed by means to query top-level constructors, to\nturn constructor representations into proper terms, and to list all\npossible datatype constructors.  This completion allows us to serve\ngeneric programming scenarios like read, show, equality, term generation.\n\u003c/p\u003e\u003cp\u003eThe combinators \u003ccode\u003e\u003ca\u003egmapT\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003egmapQ\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003egmapM\u003c/a\u003e\u003c/code\u003e, etc are all provided with\ndefault definitions in terms of \u003ccode\u003e\u003ca\u003egfoldl\u003c/a\u003e\u003c/code\u003e, leaving open the opportunity\nto provide datatype-specific definitions.\n(The inclusion of the \u003ccode\u003egmap\u003c/code\u003e combinators as members of class \u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e\nallows the programmer or the compiler to derive specialised, and maybe\nmore efficient code per datatype.  \u003cem\u003eNote\u003c/em\u003e: \u003ccode\u003e\u003ca\u003egfoldl\u003c/a\u003e\u003c/code\u003e is more higher-order\nthan the \u003ccode\u003egmap\u003c/code\u003e combinators.  This is subject to ongoing benchmarking\nexperiments.  It might turn out that the \u003ccode\u003egmap\u003c/code\u003e combinators will be\nmoved out of the class \u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e.)\n\u003c/p\u003e\u003cp\u003eConceptually, the definition of the \u003ccode\u003egmap\u003c/code\u003e combinators in terms of the\nprimitive \u003ccode\u003e\u003ca\u003egfoldl\u003c/a\u003e\u003c/code\u003e requires the identification of the \u003ccode\u003e\u003ca\u003egfoldl\u003c/a\u003e\u003c/code\u003e function\narguments.  Technically, we also need to identify the type constructor\n\u003ccode\u003ec\u003c/code\u003e for the construction of the result type from the folded term type.\n\u003c/p\u003e\u003cp\u003eIn the definition of \u003ccode\u003egmapQ\u003c/code\u003e\u003cem\u003ex\u003c/em\u003e combinators, we use phantom type\nconstructors for the \u003ccode\u003ec\u003c/code\u003e in the type of \u003ccode\u003e\u003ca\u003egfoldl\u003c/a\u003e\u003c/code\u003e because the result type\nof a query does not involve the (polymorphic) type of the term argument.\nIn the definition of \u003ccode\u003e\u003ca\u003egmapQl\u003c/a\u003e\u003c/code\u003e we simply use the plain constant type\nconstructor because \u003ccode\u003e\u003ca\u003egfoldl\u003c/a\u003e\u003c/code\u003e is left-associative anyway and so it is\nreadily suited to fold a left-associative binary operation over the\nimmediate subterms.  In the definition of gmapQr, extra effort is\nneeded. We use a higher-order accumulation trick to mediate between\nleft-associative constructor application vs. right-associative binary\noperation (e.g., \u003ccode\u003e(:)\u003c/code\u003e).  When the query is meant to compute a value\nof type \u003ccode\u003er\u003c/code\u003e, then the result type withing generic folding is \u003ccode\u003er -\u003e r\u003c/code\u003e.\nSo the result of folding is a function to which we finally pass the\nright unit.\n\u003c/p\u003e\u003cp\u003eWith the \u003ccode\u003e-XDeriveDataTypeable\u003c/code\u003e option, GHC can generate instances of the\n\u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e class automatically.  For example, given the declaration\n\u003c/p\u003e\u003cpre\u003e data T a b = C1 a b | C2 deriving (Typeable, Data)\n\u003c/pre\u003e\u003cp\u003eGHC will generate an instance that is equivalent to\n\u003c/p\u003e\u003cpre\u003e instance (Data a, Data b) =\u003e Data (T a b) where\n     gfoldl k z (C1 a b) = z C1 `k` a `k` b\n     gfoldl k z C2       = z C2\n\n     gunfold k z c = case constrIndex c of\n                         1 -\u003e k (k (z C1))\n                         2 -\u003e z C2\n\n     toConstr (C1 _ _) = con_C1\n     toConstr C2       = con_C2\n\n     dataTypeOf _ = ty_T\n\n con_C1 = mkConstr ty_T \"C1\" [] Prefix\n con_C2 = mkConstr ty_T \"C2\" [] Prefix\n ty_T   = mkDataType \"Module.T\" [con_C1, con_C2]\n\u003c/pre\u003e\u003cp\u003eThis is suitable for datatypes that are exported transparently.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "Data",
          "package": "base",
          "source": "src/Data-Data.html#Data",
          "type": "class"
        },
        "index": {
          "description": "The Data class comprehends fundamental primitive gfoldl for folding over constructor applications say terms This primitive can be instantiated in several ways to map over the immediate subterms of term see the gmap combinators later in this class Indeed generic programmer does not necessarily need to use the ingenious gfoldl primitive but rather the intuitive gmap combinators The gfoldl primitive is completed by means to query top-level constructors to turn constructor representations into proper terms and to list all possible datatype constructors This completion allows us to serve generic programming scenarios like read show equality term generation The combinators gmapT gmapQ gmapM etc are all provided with default definitions in terms of gfoldl leaving open the opportunity to provide datatype-specific definitions The inclusion of the gmap combinators as members of class Data allows the programmer or the compiler to derive specialised and maybe more efficient code per datatype Note gfoldl is more higher-order than the gmap combinators This is subject to ongoing benchmarking experiments It might turn out that the gmap combinators will be moved out of the class Data Conceptually the definition of the gmap combinators in terms of the primitive gfoldl requires the identification of the gfoldl function arguments Technically we also need to identify the type constructor for the construction of the result type from the folded term type In the definition of gmapQ combinators we use phantom type constructors for the in the type of gfoldl because the result type of query does not involve the polymorphic type of the term argument In the definition of gmapQl we simply use the plain constant type constructor because gfoldl is left-associative anyway and so it is readily suited to fold left-associative binary operation over the immediate subterms In the definition of gmapQr extra effort is needed We use higher-order accumulation trick to mediate between left-associative constructor application vs right-associative binary operation e.g When the query is meant to compute value of type then the result type withing generic folding is So the result of folding is function to which we finally pass the right unit With the XDeriveDataTypeable option GHC can generate instances of the Data class automatically For example given the declaration data C1 C2 deriving Typeable Data GHC will generate an instance that is equivalent to instance Data Data Data where gfoldl C1 C1 gfoldl C2 C2 gunfold case constrIndex of C1 C2 toConstr C1 con C1 toConstr C2 con C2 dataTypeOf ty con C1 mkConstr ty C1 Prefix con C2 mkConstr ty C2 Prefix ty mkDataType Module.T con C1 con C2 This is suitable for datatypes that are exported transparently",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "Data",
          "package": "base",
          "partial": "Data",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#t:Data"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePublic representation of datatypes\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "DataRep",
          "package": "base",
          "source": "src/Data-Data.html#DataRep",
          "type": "data"
        },
        "index": {
          "description": "Public representation of datatypes",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "DataRep",
          "package": "base",
          "partial": "Data Rep",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#t:DataRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresentation of datatypes.\n A package of constructor representations with names of type and module.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "DataType",
          "package": "base",
          "source": "src/Data-Data.html#DataType",
          "type": "data"
        },
        "index": {
          "description": "Representation of datatypes package of constructor representations with names of type and module",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "DataType",
          "package": "base",
          "partial": "Data Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#t:DataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFixity of constructors\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "Fixity",
          "package": "base",
          "source": "src/Data-Data.html#Fixity",
          "type": "data"
        },
        "index": {
          "description": "Fixity of constructors",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "Fixity",
          "package": "base",
          "partial": "Fixity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#t:Fixity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Data",
          "name": "AlgConstr",
          "package": "base",
          "signature": "AlgConstr ConIndex",
          "source": "src/Data-Data.html#ConstrRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "AlgConstr",
          "package": "base",
          "partial": "Alg Constr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:AlgConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Data",
          "name": "AlgRep",
          "package": "base",
          "signature": "AlgRep [Constr]",
          "source": "src/Data-Data.html#DataRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "AlgRep",
          "normalized": "AlgRep[Constr]",
          "package": "base",
          "partial": "Alg Rep",
          "signature": "AlgRep[Constr]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:AlgRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Data",
          "name": "CharConstr",
          "package": "base",
          "signature": "CharConstr Char",
          "source": "src/Data-Data.html#ConstrRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "CharConstr",
          "package": "base",
          "partial": "Char Constr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:CharConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Data",
          "name": "CharRep",
          "package": "base",
          "signature": "CharRep",
          "source": "src/Data-Data.html#DataRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "CharRep",
          "package": "base",
          "partial": "Char Rep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:CharRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Data",
          "name": "FloatConstr",
          "package": "base",
          "signature": "FloatConstr Rational",
          "source": "src/Data-Data.html#ConstrRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "FloatConstr",
          "package": "base",
          "partial": "Float Constr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:FloatConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Data",
          "name": "FloatRep",
          "package": "base",
          "signature": "FloatRep",
          "source": "src/Data-Data.html#DataRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "FloatRep",
          "package": "base",
          "partial": "Float Rep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:FloatRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Data",
          "name": "Infix",
          "package": "base",
          "signature": "Infix",
          "source": "src/Data-Data.html#Fixity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "Infix",
          "package": "base",
          "partial": "Infix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:Infix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Data",
          "name": "IntConstr",
          "package": "base",
          "signature": "IntConstr Integer",
          "source": "src/Data-Data.html#ConstrRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "IntConstr",
          "package": "base",
          "partial": "Int Constr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:IntConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Data",
          "name": "IntRep",
          "package": "base",
          "signature": "IntRep",
          "source": "src/Data-Data.html#DataRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "IntRep",
          "package": "base",
          "partial": "Int Rep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:IntRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Data",
          "name": "NoRep",
          "package": "base",
          "signature": "NoRep",
          "source": "src/Data-Data.html#DataRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "NoRep",
          "package": "base",
          "partial": "No Rep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:NoRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Data",
          "name": "Prefix",
          "package": "base",
          "signature": "Prefix",
          "source": "src/Data-Data.html#Fixity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "Prefix",
          "package": "base",
          "partial": "Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:Prefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the field labels of a constructor.  The list of labels\n is returned in the same order as they were given in the original \n constructor declaration.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "constrFields",
          "package": "base",
          "signature": "Constr -\u003e [String]",
          "source": "src/Data-Data.html#constrFields",
          "type": "function"
        },
        "index": {
          "description": "Gets the field labels of constructor The list of labels is returned in the same order as they were given in the original constructor declaration",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "constrFields",
          "normalized": "Constr-\u003e[String]",
          "package": "base",
          "partial": "Fields",
          "signature": "Constr-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:constrFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the fixity of a constructor\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "constrFixity",
          "package": "base",
          "signature": "Constr -\u003e Fixity",
          "source": "src/Data-Data.html#constrFixity",
          "type": "function"
        },
        "index": {
          "description": "Gets the fixity of constructor",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "constrFixity",
          "normalized": "Constr-\u003eFixity",
          "package": "base",
          "partial": "Fixity",
          "signature": "Constr-\u003eFixity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:constrFixity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the index of a constructor (algebraic datatypes only)\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "constrIndex",
          "package": "base",
          "signature": "Constr -\u003e ConIndex",
          "source": "src/Data-Data.html#constrIndex",
          "type": "function"
        },
        "index": {
          "description": "Gets the index of constructor algebraic datatypes only",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "constrIndex",
          "normalized": "Constr-\u003eConIndex",
          "package": "base",
          "partial": "Index",
          "signature": "Constr-\u003eConIndex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:constrIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the public presentation of constructors\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "constrRep",
          "package": "base",
          "signature": "Constr -\u003e ConstrRep",
          "source": "src/Data-Data.html#constrRep",
          "type": "function"
        },
        "index": {
          "description": "Gets the public presentation of constructors",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "constrRep",
          "normalized": "Constr-\u003eConstrRep",
          "package": "base",
          "partial": "Rep",
          "signature": "Constr-\u003eConstrRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:constrRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the datatype of a constructor\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "constrType",
          "package": "base",
          "signature": "Constr -\u003e DataType",
          "source": "src/Data-Data.html#constrType",
          "type": "function"
        },
        "index": {
          "description": "Gets the datatype of constructor",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "constrType",
          "normalized": "Constr-\u003eDataType",
          "package": "base",
          "partial": "Type",
          "signature": "Constr-\u003eDataType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:constrType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMediate types and unary type constructors.\n In \u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e instances of the form \u003ccode\u003eT a\u003c/code\u003e, \u003ccode\u003e\u003ca\u003edataCast1\u003c/a\u003e\u003c/code\u003e should be defined\n as \u003ccode\u003e\u003ca\u003egcast1\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe default definition is \u003ccode\u003e\u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, which is appropriate\n for non-unary type constructors.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "dataCast1",
          "package": "base",
          "signature": "c (t d)) -\u003e Maybe (c a)",
          "source": "src/Data-Data.html#dataCast1",
          "type": "method"
        },
        "index": {
          "description": "Mediate types and unary type constructors In Data instances of the form dataCast1 should be defined as gcast1 The default definition is const Nothing which is appropriate for non-unary type constructors",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "dataCast1",
          "normalized": "a(b c))-\u003eMaybe(a d)",
          "package": "base",
          "partial": "Cast",
          "signature": "c(t d))-\u003eMaybe(c a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:dataCast1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMediate types and binary type constructors.\n In \u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e instances of the form \u003ccode\u003eT a b\u003c/code\u003e, \u003ccode\u003e\u003ca\u003edataCast2\u003c/a\u003e\u003c/code\u003e should be\n defined as \u003ccode\u003e\u003ca\u003egcast2\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe default definition is \u003ccode\u003e\u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, which is appropriate\n for non-binary type constructors.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "dataCast2",
          "package": "base",
          "signature": "c (t d e)) -\u003e Maybe (c a)",
          "source": "src/Data-Data.html#dataCast2",
          "type": "method"
        },
        "index": {
          "description": "Mediate types and binary type constructors In Data instances of the form dataCast2 should be defined as gcast2 The default definition is const Nothing which is appropriate for non-binary type constructors",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "dataCast2",
          "normalized": "a(b c d))-\u003eMaybe(a e)",
          "package": "base",
          "partial": "Cast",
          "signature": "c(t d e))-\u003eMaybe(c a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:dataCast2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the constructors of an algebraic datatype\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "dataTypeConstrs",
          "package": "base",
          "signature": "DataType -\u003e [Constr]",
          "source": "src/Data-Data.html#dataTypeConstrs",
          "type": "function"
        },
        "index": {
          "description": "Gets the constructors of an algebraic datatype",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "dataTypeConstrs",
          "normalized": "DataType-\u003e[Constr]",
          "package": "base",
          "partial": "Type Constrs",
          "signature": "DataType-\u003e[Constr]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:dataTypeConstrs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the type constructor including the module\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "dataTypeName",
          "package": "base",
          "signature": "DataType -\u003e String",
          "source": "src/Data-Data.html#dataTypeName",
          "type": "function"
        },
        "index": {
          "description": "Gets the type constructor including the module",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "dataTypeName",
          "normalized": "DataType-\u003eString",
          "package": "base",
          "partial": "Type Name",
          "signature": "DataType-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:dataTypeName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe outer type constructor of the type\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "dataTypeOf",
          "package": "base",
          "signature": "a -\u003e DataType",
          "source": "src/Data-Data.html#dataTypeOf",
          "type": "method"
        },
        "index": {
          "description": "The outer type constructor of the type",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "dataTypeOf",
          "normalized": "a-\u003eDataType",
          "package": "base",
          "partial": "Type Of",
          "signature": "a-\u003eDataType",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:dataTypeOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the public presentation of a datatype\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "dataTypeRep",
          "package": "base",
          "signature": "DataType -\u003e DataRep",
          "source": "src/Data-Data.html#dataTypeRep",
          "type": "function"
        },
        "index": {
          "description": "Gets the public presentation of datatype",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "dataTypeRep",
          "normalized": "DataType-\u003eDataRep",
          "package": "base",
          "partial": "Type Rep",
          "signature": "DataType-\u003eDataRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:dataTypeRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a term skeleton\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "fromConstr",
          "package": "base",
          "signature": "Constr -\u003e a",
          "source": "src/Data-Data.html#fromConstr",
          "type": "function"
        },
        "index": {
          "description": "Build term skeleton",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "fromConstr",
          "normalized": "Constr-\u003ea",
          "package": "base",
          "partial": "Constr",
          "signature": "Constr-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:fromConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a term and use a generic function for subterms\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "fromConstrB",
          "package": "base",
          "signature": "d) -\u003e Constr -\u003e a",
          "source": "src/Data-Data.html#fromConstrB",
          "type": "function"
        },
        "index": {
          "description": "Build term and use generic function for subterms",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "fromConstrB",
          "normalized": "a)-\u003eConstr-\u003eb",
          "package": "base",
          "partial": "Constr",
          "signature": "d)-\u003eConstr-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:fromConstrB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic variation on \u003ccode\u003e\u003ca\u003efromConstrB\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "fromConstrM",
          "package": "base",
          "signature": "m d) -\u003e Constr -\u003e m a",
          "source": "src/Data-Data.html#fromConstrM",
          "type": "function"
        },
        "index": {
          "description": "Monadic variation on fromConstrB",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "fromConstrM",
          "normalized": "a b)-\u003eConstr-\u003ea c",
          "package": "base",
          "partial": "Constr",
          "signature": "m d)-\u003eConstr-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:fromConstrM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft-associative fold operation for constructor applications.\n\u003c/p\u003e\u003cp\u003eThe type of \u003ccode\u003e\u003ca\u003egfoldl\u003c/a\u003e\u003c/code\u003e is a headache, but operationally it is a simple\n generalisation of a list fold.\n\u003c/p\u003e\u003cp\u003eThe default definition for \u003ccode\u003e\u003ca\u003egfoldl\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, which is\n suitable for abstract datatypes with no substructures.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "gfoldl",
          "package": "base",
          "signature": "gfoldl",
          "source": "src/Data-Data.html#gfoldl",
          "type": "method"
        },
        "index": {
          "description": "Left-associative fold operation for constructor applications The type of gfoldl is headache but operationally it is simple generalisation of list fold The default definition for gfoldl is const id which is suitable for abstract datatypes with no substructures",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "gfoldl",
          "package": "base",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:gfoldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generic monadic transformation that maps over the immediate subterms\n\u003c/p\u003e\u003cp\u003eThe default definition instantiates the type constructor \u003ccode\u003ec\u003c/code\u003e in\n the type of \u003ccode\u003e\u003ca\u003egfoldl\u003c/a\u003e\u003c/code\u003e to the monad datatype constructor, defining\n injection and projection using \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "gmapM",
          "package": "base",
          "signature": "d -\u003e m d) -\u003e a -\u003e m a",
          "source": "src/Data-Data.html#gmapM",
          "type": "method"
        },
        "index": {
          "description": "generic monadic transformation that maps over the immediate subterms The default definition instantiates the type constructor in the type of gfoldl to the monad datatype constructor defining injection and projection using return and",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "gmapM",
          "normalized": "a-\u003eb a)-\u003ec-\u003eb c",
          "package": "base",
          "signature": "d-\u003em d)-\u003ea-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:gmapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransformation of one immediate subterm with success\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "gmapMo",
          "package": "base",
          "signature": "d -\u003e m d) -\u003e a -\u003e m a",
          "source": "src/Data-Data.html#gmapMo",
          "type": "method"
        },
        "index": {
          "description": "Transformation of one immediate subterm with success",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "gmapMo",
          "normalized": "a-\u003eb a)-\u003ec-\u003eb c",
          "package": "base",
          "partial": "Mo",
          "signature": "d-\u003em d)-\u003ea-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:gmapMo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransformation of at least one immediate subterm does not fail\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "gmapMp",
          "package": "base",
          "signature": "d -\u003e m d) -\u003e a -\u003e m a",
          "source": "src/Data-Data.html#gmapMp",
          "type": "method"
        },
        "index": {
          "description": "Transformation of at least one immediate subterm does not fail",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "gmapMp",
          "normalized": "a-\u003eb a)-\u003ec-\u003eb c",
          "package": "base",
          "partial": "Mp",
          "signature": "d-\u003em d)-\u003ea-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:gmapMp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generic query that processes the immediate subterms and returns a list\n of results.  The list is given in the same order as originally specified\n in the declaratoin of the data constructors.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "gmapQ",
          "package": "base",
          "signature": "d -\u003e u) -\u003e a -\u003e [u]",
          "source": "src/Data-Data.html#gmapQ",
          "type": "method"
        },
        "index": {
          "description": "generic query that processes the immediate subterms and returns list of results The list is given in the same order as originally specified in the declaratoin of the data constructors",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "gmapQ",
          "normalized": "a-\u003eb)-\u003ec-\u003e[b]",
          "package": "base",
          "signature": "d-\u003eu)-\u003ea-\u003e[u]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:gmapQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generic query that processes one child by index (zero-based)\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "gmapQi",
          "package": "base",
          "signature": "d -\u003e u) -\u003e a -\u003e u",
          "source": "src/Data-Data.html#gmapQi",
          "type": "method"
        },
        "index": {
          "description": "generic query that processes one child by index zero-based",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "gmapQi",
          "normalized": "a-\u003eb)-\u003ec-\u003eb",
          "package": "base",
          "partial": "Qi",
          "signature": "d-\u003eu)-\u003ea-\u003eu",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:gmapQi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generic query with a left-associative binary operator\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "gmapQl",
          "package": "base",
          "signature": "d -\u003e r') -\u003e a -\u003e r",
          "source": "src/Data-Data.html#gmapQl",
          "type": "method"
        },
        "index": {
          "description": "generic query with left-associative binary operator",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "gmapQl",
          "normalized": "a-\u003eb)-\u003ec-\u003ed",
          "package": "base",
          "partial": "Ql",
          "signature": "d-\u003er')-\u003ea-\u003er",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:gmapQl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generic query with a right-associative binary operator\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "gmapQr",
          "package": "base",
          "signature": "d -\u003e r') -\u003e a -\u003e r",
          "source": "src/Data-Data.html#gmapQr",
          "type": "method"
        },
        "index": {
          "description": "generic query with right-associative binary operator",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "gmapQr",
          "normalized": "a-\u003eb)-\u003ec-\u003ed",
          "package": "base",
          "partial": "Qr",
          "signature": "d-\u003er')-\u003ea-\u003er",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:gmapQr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generic transformation that maps over the immediate subterms\n\u003c/p\u003e\u003cp\u003eThe default definition instantiates the type constructor \u003ccode\u003ec\u003c/code\u003e in the\n type of \u003ccode\u003e\u003ca\u003egfoldl\u003c/a\u003e\u003c/code\u003e to an identity datatype constructor, using the\n isomorphism pair as injection and projection.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "gmapT",
          "package": "base",
          "signature": "b -\u003e b) -\u003e a -\u003e a",
          "source": "src/Data-Data.html#gmapT",
          "type": "method"
        },
        "index": {
          "description": "generic transformation that maps over the immediate subterms The default definition instantiates the type constructor in the type of gfoldl to an identity datatype constructor using the isomorphism pair as injection and projection",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "gmapT",
          "normalized": "a-\u003ea)-\u003eb-\u003eb",
          "package": "base",
          "signature": "b-\u003eb)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:gmapT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnfolding constructor applications\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "gunfold",
          "package": "base",
          "signature": "c (b -\u003e r) -\u003e c r) -\u003e (forall r.  r -\u003e c r) -\u003e Constr -\u003e c a",
          "source": "src/Data-Data.html#gunfold",
          "type": "method"
        },
        "index": {
          "description": "Unfolding constructor applications",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "gunfold",
          "normalized": "a(b-\u003ec)-\u003ea c)-\u003e(d e c-\u003ea c)-\u003eConstr-\u003ea f",
          "package": "base",
          "signature": "c(b-\u003er)-\u003ec r)-\u003e(forall r. r-\u003ec r)-\u003eConstr-\u003ec a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:gunfold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the constructor for an index (algebraic datatypes only)\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "indexConstr",
          "package": "base",
          "signature": "DataType -\u003e ConIndex -\u003e Constr",
          "source": "src/Data-Data.html#indexConstr",
          "type": "function"
        },
        "index": {
          "description": "Gets the constructor for an index algebraic datatypes only",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "indexConstr",
          "normalized": "DataType-\u003eConIndex-\u003eConstr",
          "package": "base",
          "partial": "Constr",
          "signature": "DataType-\u003eConIndex-\u003eConstr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:indexConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest for an algebraic type\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "isAlgType",
          "package": "base",
          "signature": "DataType -\u003e Bool",
          "source": "src/Data-Data.html#isAlgType",
          "type": "function"
        },
        "index": {
          "description": "Test for an algebraic type",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "isAlgType",
          "normalized": "DataType-\u003eBool",
          "package": "base",
          "partial": "Alg Type",
          "signature": "DataType-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:isAlgType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest for a non-representable type\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "isNorepType",
          "package": "base",
          "signature": "DataType -\u003e Bool",
          "source": "src/Data-Data.html#isNorepType",
          "type": "function"
        },
        "index": {
          "description": "Test for non-representable type",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "isNorepType",
          "normalized": "DataType-\u003eBool",
          "package": "base",
          "partial": "Norep Type",
          "signature": "DataType-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:isNorepType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the maximum constructor index of an algebraic datatype\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "maxConstrIndex",
          "package": "base",
          "signature": "DataType -\u003e ConIndex",
          "source": "src/Data-Data.html#maxConstrIndex",
          "type": "function"
        },
        "index": {
          "description": "Gets the maximum constructor index of an algebraic datatype",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "maxConstrIndex",
          "normalized": "DataType-\u003eConIndex",
          "package": "base",
          "partial": "Constr Index",
          "signature": "DataType-\u003eConIndex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:maxConstrIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMakes a constructor for \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "mkCharConstr",
          "package": "base",
          "signature": "DataType -\u003e Char -\u003e Constr",
          "source": "src/Data-Data.html#mkCharConstr",
          "type": "function"
        },
        "index": {
          "description": "Makes constructor for Char",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "mkCharConstr",
          "normalized": "DataType-\u003eChar-\u003eConstr",
          "package": "base",
          "partial": "Char Constr",
          "signature": "DataType-\u003eChar-\u003eConstr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:mkCharConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs the \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e type\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "mkCharType",
          "package": "base",
          "signature": "String -\u003e DataType",
          "source": "src/Data-Data.html#mkCharType",
          "type": "function"
        },
        "index": {
          "description": "Constructs the Char type",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "mkCharType",
          "normalized": "String-\u003eDataType",
          "package": "base",
          "partial": "Char Type",
          "signature": "String-\u003eDataType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:mkCharType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs a constructor\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "mkConstr",
          "package": "base",
          "signature": "DataType -\u003e String -\u003e [String] -\u003e Fixity -\u003e Constr",
          "source": "src/Data-Data.html#mkConstr",
          "type": "function"
        },
        "index": {
          "description": "Constructs constructor",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "mkConstr",
          "normalized": "DataType-\u003eString-\u003e[String]-\u003eFixity-\u003eConstr",
          "package": "base",
          "partial": "Constr",
          "signature": "DataType-\u003eString-\u003e[String]-\u003eFixity-\u003eConstr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:mkConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs an algebraic datatype\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "mkDataType",
          "package": "base",
          "signature": "String -\u003e [Constr] -\u003e DataType",
          "source": "src/Data-Data.html#mkDataType",
          "type": "function"
        },
        "index": {
          "description": "Constructs an algebraic datatype",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "mkDataType",
          "normalized": "String-\u003e[Constr]-\u003eDataType",
          "package": "base",
          "partial": "Data Type",
          "signature": "String-\u003e[Constr]-\u003eDataType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:mkDataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use mkRealConstr instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis function is now deprecated. Please use \u003ccode\u003e\u003ca\u003emkRealConstr\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "mkFloatConstr",
          "package": "base",
          "signature": "DataType -\u003e Double -\u003e Constr",
          "source": "src/Data-Data.html#mkFloatConstr",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use mkRealConstr instead This function is now deprecated Please use mkRealConstr instead",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "mkFloatConstr",
          "normalized": "DataType-\u003eDouble-\u003eConstr",
          "package": "base",
          "partial": "Float Constr",
          "signature": "DataType-\u003eDouble-\u003eConstr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:mkFloatConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs the \u003ccode\u003e\u003ca\u003eFloat\u003c/a\u003e\u003c/code\u003e type\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "mkFloatType",
          "package": "base",
          "signature": "String -\u003e DataType",
          "source": "src/Data-Data.html#mkFloatType",
          "type": "function"
        },
        "index": {
          "description": "Constructs the Float type",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "mkFloatType",
          "normalized": "String-\u003eDataType",
          "package": "base",
          "partial": "Float Type",
          "signature": "String-\u003eDataType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:mkFloatType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use mkIntegralConstr instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis function is now deprecated. Please use \u003ccode\u003e\u003ca\u003emkIntegralConstr\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "mkIntConstr",
          "package": "base",
          "signature": "DataType -\u003e Integer -\u003e Constr",
          "source": "src/Data-Data.html#mkIntConstr",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use mkIntegralConstr instead This function is now deprecated Please use mkIntegralConstr instead",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "mkIntConstr",
          "normalized": "DataType-\u003eInteger-\u003eConstr",
          "package": "base",
          "partial": "Int Constr",
          "signature": "DataType-\u003eInteger-\u003eConstr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:mkIntConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs the \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e type\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "mkIntType",
          "package": "base",
          "signature": "String -\u003e DataType",
          "source": "src/Data-Data.html#mkIntType",
          "type": "function"
        },
        "index": {
          "description": "Constructs the Int type",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "mkIntType",
          "normalized": "String-\u003eDataType",
          "package": "base",
          "partial": "Int Type",
          "signature": "String-\u003eDataType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:mkIntType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Data",
          "name": "mkIntegralConstr",
          "package": "base",
          "signature": "DataType -\u003e a -\u003e Constr",
          "source": "src/Data-Data.html#mkIntegralConstr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "mkIntegralConstr",
          "normalized": "DataType-\u003ea-\u003eConstr",
          "package": "base",
          "partial": "Integral Constr",
          "signature": "DataType-\u003ea-\u003eConstr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:mkIntegralConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs a non-representation for a non-presentable type\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "mkNoRepType",
          "package": "base",
          "signature": "String -\u003e DataType",
          "source": "src/Data-Data.html#mkNoRepType",
          "type": "function"
        },
        "index": {
          "description": "Constructs non-representation for non-presentable type",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "mkNoRepType",
          "normalized": "String-\u003eDataType",
          "package": "base",
          "partial": "No Rep Type",
          "signature": "String-\u003eDataType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:mkNoRepType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use mkNoRepType instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eDeprecated version (misnamed)\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "mkNorepType",
          "package": "base",
          "signature": "String -\u003e DataType",
          "source": "src/Data-Data.html#mkNorepType",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use mkNoRepType instead Deprecated version misnamed",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "mkNorepType",
          "normalized": "String-\u003eDataType",
          "package": "base",
          "partial": "Norep Type",
          "signature": "String-\u003eDataType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:mkNorepType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Data",
          "name": "mkRealConstr",
          "package": "base",
          "signature": "DataType -\u003e a -\u003e Constr",
          "source": "src/Data-Data.html#mkRealConstr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "mkRealConstr",
          "normalized": "DataType-\u003ea-\u003eConstr",
          "package": "base",
          "partial": "Real Constr",
          "signature": "DataType-\u003ea-\u003eConstr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:mkRealConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use mkCharConstr instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis function is now deprecated. Please use \u003ccode\u003e\u003ca\u003emkCharConstr\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "mkStringConstr",
          "package": "base",
          "signature": "DataType -\u003e String -\u003e Constr",
          "source": "src/Data-Data.html#mkStringConstr",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use mkCharConstr instead This function is now deprecated Please use mkCharConstr instead",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "mkStringConstr",
          "normalized": "DataType-\u003eString-\u003eConstr",
          "package": "base",
          "partial": "String Constr",
          "signature": "DataType-\u003eString-\u003eConstr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:mkStringConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use mkCharType instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis function is now deprecated. Please use \u003ccode\u003e\u003ca\u003emkCharType\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "mkStringType",
          "package": "base",
          "signature": "String -\u003e DataType",
          "source": "src/Data-Data.html#mkStringType",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use mkCharType instead This function is now deprecated Please use mkCharType instead",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "mkStringType",
          "normalized": "String-\u003eDataType",
          "package": "base",
          "partial": "String Type",
          "signature": "String-\u003eDataType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:mkStringType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup a constructor via a string\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "readConstr",
          "package": "base",
          "signature": "DataType -\u003e String -\u003e Maybe Constr",
          "source": "src/Data-Data.html#readConstr",
          "type": "function"
        },
        "index": {
          "description": "Lookup constructor via string",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "readConstr",
          "normalized": "DataType-\u003eString-\u003eMaybe Constr",
          "package": "base",
          "partial": "Constr",
          "signature": "DataType-\u003eString-\u003eMaybe Constr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:readConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLook up a constructor by its representation\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "repConstr",
          "package": "base",
          "signature": "DataType -\u003e ConstrRep -\u003e Constr",
          "source": "src/Data-Data.html#repConstr",
          "type": "function"
        },
        "index": {
          "description": "Look up constructor by its representation",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "repConstr",
          "normalized": "DataType-\u003eConstrRep-\u003eConstr",
          "package": "base",
          "partial": "Constr",
          "signature": "DataType-\u003eConstrRep-\u003eConstr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:repConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the string for a constructor\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "showConstr",
          "package": "base",
          "signature": "Constr -\u003e String",
          "source": "src/Data-Data.html#showConstr",
          "type": "function"
        },
        "index": {
          "description": "Gets the string for constructor",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "showConstr",
          "normalized": "Constr-\u003eString",
          "package": "base",
          "partial": "Constr",
          "signature": "Constr-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:showConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtaining the constructor from a given datum.\n For proper terms, this is meant to be the top-level constructor.\n Primitive datatypes are here viewed as potentially infinite sets of\n values (i.e., constructors).\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "toConstr",
          "package": "base",
          "signature": "a -\u003e Constr",
          "source": "src/Data-Data.html#toConstr",
          "type": "method"
        },
        "index": {
          "description": "Obtaining the constructor from given datum For proper terms this is meant to be the top-level constructor Primitive datatypes are here viewed as potentially infinite sets of values i.e constructors",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "toConstr",
          "normalized": "a-\u003eConstr",
          "package": "base",
          "partial": "Constr",
          "signature": "a-\u003eConstr",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:toConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the module of a type constructor:\n take *.*.*... before name\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "tyconModule",
          "package": "base",
          "signature": "String -\u003e String",
          "source": "src/Data-Data.html#tyconModule",
          "type": "function"
        },
        "index": {
          "description": "Gets the module of type constructor take before name",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "tyconModule",
          "normalized": "String-\u003eString",
          "package": "base",
          "partial": "Module",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:tyconModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the unqualified type constructor:\n drop *.*.*... before name\n\u003c/p\u003e",
          "module": "Data.Data",
          "name": "tyconUQname",
          "package": "base",
          "signature": "String -\u003e String",
          "source": "src/Data-Data.html#tyconUQname",
          "type": "function"
        },
        "index": {
          "description": "Gets the unqualified type constructor drop before name",
          "hierarchy": "Data Data",
          "module": "Data.Data",
          "name": "tyconUQname",
          "normalized": "String-\u003eString",
          "package": "base",
          "partial": "UQname",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Data.html#v:tyconUQname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe Dynamic interface provides basic support for dynamic types.\n\u003c/p\u003e\u003cp\u003eOperations for injecting values of arbitrary type into\n a dynamically typed value, Dynamic, are provided, together\n with operations for converting dynamic values into a concrete\n (monomorphic) type.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Dynamic",
          "name": "Dynamic",
          "package": "base",
          "source": "src/Data-Dynamic.html",
          "type": "module"
        },
        "index": {
          "description": "The Dynamic interface provides basic support for dynamic types Operations for injecting values of arbitrary type into dynamically typed value Dynamic are provided together with operations for converting dynamic values into concrete monomorphic type",
          "hierarchy": "Data Dynamic",
          "module": "Data.Dynamic",
          "name": "Dynamic",
          "package": "base",
          "partial": "Dynamic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Dynamic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value of type \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e is an object encapsulated together with its type.\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e may only represent a monomorphic value; an attempt to\n  create a value of type \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e from a polymorphically-typed\n  expression will result in an ambiguity error (see \u003ccode\u003e\u003ca\u003etoDyn\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003eing a value of type \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e returns a pretty-printed representation\n  of the object's type; useful for debugging.\n\u003c/p\u003e",
          "module": "Data.Dynamic",
          "name": "Dynamic",
          "package": "base",
          "source": "src/Data-Dynamic.html#Dynamic",
          "type": "data"
        },
        "index": {
          "description": "value of type Dynamic is an object encapsulated together with its type Dynamic may only represent monomorphic value an attempt to create value of type Dynamic from polymorphically-typed expression will result in an ambiguity error see toDyn Show ing value of type Dynamic returns pretty-printed representation of the object type useful for debugging",
          "hierarchy": "Data Dynamic",
          "module": "Data.Dynamic",
          "name": "Dynamic",
          "package": "base",
          "partial": "Dynamic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Dynamic.html#t:Dynamic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Dynamic",
          "name": "dynApp",
          "package": "base",
          "signature": "Dynamic -\u003e Dynamic -\u003e Dynamic",
          "source": "src/Data-Dynamic.html#dynApp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Dynamic",
          "module": "Data.Dynamic",
          "name": "dynApp",
          "normalized": "Dynamic-\u003eDynamic-\u003eDynamic",
          "package": "base",
          "partial": "App",
          "signature": "Dynamic-\u003eDynamic-\u003eDynamic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Dynamic.html#v:dynApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Dynamic",
          "name": "dynApply",
          "package": "base",
          "signature": "Dynamic -\u003e Dynamic -\u003e Maybe Dynamic",
          "source": "src/Data-Dynamic.html#dynApply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Dynamic",
          "module": "Data.Dynamic",
          "name": "dynApply",
          "normalized": "Dynamic-\u003eDynamic-\u003eMaybe Dynamic",
          "package": "base",
          "partial": "Apply",
          "signature": "Dynamic-\u003eDynamic-\u003eMaybe Dynamic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Dynamic.html#v:dynApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Dynamic",
          "name": "dynTypeRep",
          "package": "base",
          "signature": "Dynamic -\u003e TypeRep",
          "source": "src/Data-Dynamic.html#dynTypeRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Dynamic",
          "module": "Data.Dynamic",
          "name": "dynTypeRep",
          "normalized": "Dynamic-\u003eTypeRep",
          "package": "base",
          "partial": "Type Rep",
          "signature": "Dynamic-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Dynamic.html#v:dynTypeRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e object back into an ordinary Haskell value of\n the correct type.  See also \u003ccode\u003e\u003ca\u003efromDynamic\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Dynamic",
          "name": "fromDyn",
          "package": "base",
          "signature": "Dynamic-\u003e a-\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Converts Dynamic object back into an ordinary Haskell value of the correct type See also fromDynamic",
          "hierarchy": "Data Dynamic",
          "module": "Data.Dynamic",
          "name": "fromDyn",
          "normalized": "Dynamic-\u003ea-\u003ea",
          "package": "base",
          "partial": "Dyn",
          "signature": "Dynamic-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Dynamic.html#v:fromDyn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e object back into an ordinary Haskell value of\n the correct type.  See also \u003ccode\u003e\u003ca\u003efromDyn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Dynamic",
          "name": "fromDynamic",
          "package": "base",
          "signature": "Dynamic-\u003e Maybe a",
          "type": "function"
        },
        "index": {
          "description": "Converts Dynamic object back into an ordinary Haskell value of the correct type See also fromDyn",
          "hierarchy": "Data Dynamic",
          "module": "Data.Dynamic",
          "name": "fromDynamic",
          "normalized": "Dynamic-\u003eMaybe a",
          "package": "base",
          "partial": "Dynamic",
          "signature": "Dynamic-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Dynamic.html#v:fromDynamic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts an arbitrary value into an object of type \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e.  \n\u003c/p\u003e\u003cp\u003eThe type of the object must be an instance of \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e, which\n ensures that only monomorphically-typed objects may be converted to\n \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e.  To convert a polymorphic object into \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e, give it\n a monomorphic type signature.  For example:\n\u003c/p\u003e\u003cpre\u003e    toDyn (id :: Int -\u003e Int)\n\u003c/pre\u003e",
          "module": "Data.Dynamic",
          "name": "toDyn",
          "package": "base",
          "signature": "a -\u003e Dynamic",
          "source": "src/Data-Dynamic.html#toDyn",
          "type": "function"
        },
        "index": {
          "description": "Converts an arbitrary value into an object of type Dynamic The type of the object must be an instance of Typeable which ensures that only monomorphically-typed objects may be converted to Dynamic To convert polymorphic object into Dynamic give it monomorphic type signature For example toDyn id Int Int",
          "hierarchy": "Data Dynamic",
          "module": "Data.Dynamic",
          "name": "toDyn",
          "normalized": "a-\u003eDynamic",
          "package": "base",
          "partial": "Dyn",
          "signature": "a-\u003eDynamic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Dynamic.html#v:toDyn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe Either type, and associated operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Either",
          "name": "Either",
          "package": "base",
          "source": "src/Data-Either.html",
          "type": "module"
        },
        "index": {
          "description": "The Either type and associated operations",
          "hierarchy": "Data Either",
          "module": "Data.Either",
          "name": "Either",
          "package": "base",
          "partial": "Either",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Either.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e type represents values with two possibilities: a value of\ntype \u003ccode\u003e\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a b\u003c/code\u003e is either \u003ccode\u003e\u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e or \u003ccode\u003e\u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e type is sometimes used to represent a value which is\neither correct or an error; by convention, the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e constructor is\nused to hold an error value and the \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e constructor is used to\nhold a correct value (mnemonic: \"right\" also means \"correct\").\n\u003c/p\u003e",
          "module": "Data.Either",
          "name": "Either",
          "package": "base",
          "source": "src/Data-Either.html#Either",
          "type": "data"
        },
        "index": {
          "description": "The Either type represents values with two possibilities value of type Either is either Left or Right The Either type is sometimes used to represent value which is either correct or an error by convention the Left constructor is used to hold an error value and the Right constructor is used to hold correct value mnemonic right also means correct",
          "hierarchy": "Data Either",
          "module": "Data.Either",
          "name": "Either",
          "package": "base",
          "partial": "Either",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Either.html#t:Either"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Either\",\"Prelude\"]",
          "name": "Left",
          "package": "base",
          "signature": "Left a",
          "source": "src/Data-Either.html#Either",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Either.html#v:Left\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:Left\"]"
        },
        "index": {
          "hierarchy": "Data Either",
          "module": "Data.Either",
          "name": "Left",
          "package": "base",
          "partial": "Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Either.html#v:Left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Either\",\"Prelude\"]",
          "name": "Right",
          "package": "base",
          "signature": "Right b",
          "source": "src/Data-Either.html#Either",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Either.html#v:Right\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:Right\"]"
        },
        "index": {
          "hierarchy": "Data Either",
          "module": "Data.Either",
          "name": "Right",
          "package": "base",
          "partial": "Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Either.html#v:Right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCase analysis for the \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e type.\n If the value is \u003ccode\u003e\u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e, apply the first function to \u003ccode\u003ea\u003c/code\u003e;\n if it is \u003ccode\u003e\u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e, apply the second function to \u003ccode\u003eb\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.Either\",\"Prelude\"]",
          "name": "either",
          "package": "base",
          "signature": "(a -\u003e c) -\u003e (b -\u003e c) -\u003e Either a b -\u003e c",
          "source": "src/Data-Either.html#either",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Either.html#v:either\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:either\"]"
        },
        "index": {
          "description": "Case analysis for the Either type If the value is Left apply the first function to if it is Right apply the second function to",
          "hierarchy": "Data Either",
          "module": "Data.Either",
          "name": "either",
          "normalized": "(a-\u003eb)-\u003e(c-\u003eb)-\u003eEither a c-\u003eb",
          "package": "base",
          "signature": "(a-\u003ec)-\u003e(b-\u003ec)-\u003eEither a b-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Either.html#v:either"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtracts from a list of \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e all the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e elements\n All the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e elements are extracted in order.\n\u003c/p\u003e",
          "module": "Data.Either",
          "name": "lefts",
          "package": "base",
          "signature": "[Either a b] -\u003e [a]",
          "source": "src/Data-Either.html#lefts",
          "type": "function"
        },
        "index": {
          "description": "Extracts from list of Either all the Left elements All the Left elements are extracted in order",
          "hierarchy": "Data Either",
          "module": "Data.Either",
          "name": "lefts",
          "normalized": "[Either a b]-\u003e[a]",
          "package": "base",
          "signature": "[Either a b]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Either.html#v:lefts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartitions a list of \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e into two lists\n All the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e elements are extracted, in order, to the first\n component of the output.  Similarly the \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e elements are extracted\n to the second component of the output.\n\u003c/p\u003e",
          "module": "Data.Either",
          "name": "partitionEithers",
          "package": "base",
          "signature": "[Either a b] -\u003e ([a], [b])",
          "source": "src/Data-Either.html#partitionEithers",
          "type": "function"
        },
        "index": {
          "description": "Partitions list of Either into two lists All the Left elements are extracted in order to the first component of the output Similarly the Right elements are extracted to the second component of the output",
          "hierarchy": "Data Either",
          "module": "Data.Either",
          "name": "partitionEithers",
          "normalized": "[Either a b]-\u003e([a],[b])",
          "package": "base",
          "partial": "Eithers",
          "signature": "[Either a b]-\u003e([a],[b])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Either.html#v:partitionEithers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtracts from a list of \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e all the \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e elements\n All the \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e elements are extracted in order.\n\u003c/p\u003e",
          "module": "Data.Either",
          "name": "rights",
          "package": "base",
          "signature": "[Either a b] -\u003e [b]",
          "source": "src/Data-Either.html#rights",
          "type": "function"
        },
        "index": {
          "description": "Extracts from list of Either all the Right elements All the Right elements are extracted in order",
          "hierarchy": "Data Either",
          "module": "Data.Either",
          "name": "rights",
          "normalized": "[Either a b]-\u003e[b]",
          "package": "base",
          "signature": "[Either a b]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Either.html#v:rights"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eEquality\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Eq",
          "name": "Eq",
          "package": "base",
          "source": "src/Data-Eq.html",
          "type": "module"
        },
        "index": {
          "description": "Equality",
          "hierarchy": "Data Eq",
          "module": "Data.Eq",
          "name": "Eq",
          "package": "base",
          "partial": "Eq",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Eq.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e class defines equality (\u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e) and inequality (\u003ccode\u003e\u003ca\u003e/=\u003c/a\u003e\u003c/code\u003e).\n All the basic datatypes exported by the \u003ca\u003ePrelude\u003c/a\u003e are instances of \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e,\n and \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e may be derived for any datatype whose constituents are also\n instances of \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: either \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003e/=\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Eq",
          "name": "Eq",
          "package": "base",
          "type": "class"
        },
        "index": {
          "description": "The Eq class defines equality and inequality All the basic datatypes exported by the Prelude are instances of Eq and Eq may be derived for any datatype whose constituents are also instances of Eq Minimal complete definition either or",
          "hierarchy": "Data Eq",
          "module": "Data.Eq",
          "name": "Eq",
          "package": "base",
          "partial": "Eq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Eq",
          "name": "(/=)",
          "package": "base",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Eq",
          "module": "Data.Eq",
          "name": "(/=) /=",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "base",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Eq.html#v:-47--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Eq",
          "name": "(==)",
          "package": "base",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Eq",
          "module": "Data.Eq",
          "name": "(==) ==",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "base",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Eq.html#v:-61--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines a \"Fixed\" type for fixed-precision arithmetic.\n The parameter to Fixed is any type that's an instance of HasResolution.\n HasResolution has a single method that gives the resolution of the Fixed type.\n\u003c/p\u003e\u003cp\u003eThis module also contains generalisations of div, mod, and divmod to work\n with any Real instance.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Fixed",
          "name": "Fixed",
          "package": "base",
          "source": "src/Data-Fixed.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines Fixed type for fixed-precision arithmetic The parameter to Fixed is any type that an instance of HasResolution HasResolution has single method that gives the resolution of the Fixed type This module also contains generalisations of div mod and divmod to work with any Real instance",
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "Fixed",
          "package": "base",
          "partial": "Fixed",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eresolution of 10^-2 = .01, useful for many monetary currencies\n\u003c/p\u003e",
          "module": "Data.Fixed",
          "name": "Centi",
          "package": "base",
          "source": "src/Data-Fixed.html#Centi",
          "type": "type"
        },
        "index": {
          "description": "resolution of useful for many monetary currencies",
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "Centi",
          "package": "base",
          "partial": "Centi",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:Centi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eresolution of 10^-1 = .1\n\u003c/p\u003e",
          "module": "Data.Fixed",
          "name": "Deci",
          "package": "base",
          "source": "src/Data-Fixed.html#Deci",
          "type": "type"
        },
        "index": {
          "description": "resolution of",
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "Deci",
          "package": "base",
          "partial": "Deci",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:Deci"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Fixed",
          "name": "E0",
          "package": "base",
          "source": "src/Data-Fixed.html#E0",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "E0",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:E0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Fixed",
          "name": "E1",
          "package": "base",
          "source": "src/Data-Fixed.html#E1",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "E1",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:E1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Fixed",
          "name": "E12",
          "package": "base",
          "source": "src/Data-Fixed.html#E12",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "E12",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:E12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Fixed",
          "name": "E2",
          "package": "base",
          "source": "src/Data-Fixed.html#E2",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "E2",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:E2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Fixed",
          "name": "E3",
          "package": "base",
          "source": "src/Data-Fixed.html#E3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "E3",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:E3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Fixed",
          "name": "E6",
          "package": "base",
          "source": "src/Data-Fixed.html#E6",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "E6",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:E6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Fixed",
          "name": "E9",
          "package": "base",
          "source": "src/Data-Fixed.html#E9",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "E9",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:E9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type parameter should be an instance of \u003ccode\u003e\u003ca\u003eHasResolution\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Fixed",
          "name": "Fixed",
          "package": "base",
          "source": "src/Data-Fixed.html#Fixed",
          "type": "data"
        },
        "index": {
          "description": "The type parameter should be an instance of HasResolution",
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "Fixed",
          "package": "base",
          "partial": "Fixed",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:Fixed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Fixed",
          "name": "HasResolution",
          "package": "base",
          "source": "src/Data-Fixed.html#HasResolution",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "HasResolution",
          "package": "base",
          "partial": "Has Resolution",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:HasResolution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eresolution of 10^-6 = .000001\n\u003c/p\u003e",
          "module": "Data.Fixed",
          "name": "Micro",
          "package": "base",
          "source": "src/Data-Fixed.html#Micro",
          "type": "type"
        },
        "index": {
          "description": "resolution of",
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "Micro",
          "package": "base",
          "partial": "Micro",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:Micro"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eresolution of 10^-3 = .001\n\u003c/p\u003e",
          "module": "Data.Fixed",
          "name": "Milli",
          "package": "base",
          "source": "src/Data-Fixed.html#Milli",
          "type": "type"
        },
        "index": {
          "description": "resolution of",
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "Milli",
          "package": "base",
          "partial": "Milli",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:Milli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eresolution of 10^-9 = .000000001\n\u003c/p\u003e",
          "module": "Data.Fixed",
          "name": "Nano",
          "package": "base",
          "source": "src/Data-Fixed.html#Nano",
          "type": "type"
        },
        "index": {
          "description": "resolution of",
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "Nano",
          "package": "base",
          "partial": "Nano",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:Nano"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eresolution of 10^-12 = .000000000001\n\u003c/p\u003e",
          "module": "Data.Fixed",
          "name": "Pico",
          "package": "base",
          "source": "src/Data-Fixed.html#Pico",
          "type": "type"
        },
        "index": {
          "description": "resolution of",
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "Pico",
          "package": "base",
          "partial": "Pico",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:Pico"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eresolution of 1, this works the same as Integer\n\u003c/p\u003e",
          "module": "Data.Fixed",
          "name": "Uni",
          "package": "base",
          "source": "src/Data-Fixed.html#Uni",
          "type": "type"
        },
        "index": {
          "description": "resolution of this works the same as Integer",
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "Uni",
          "package": "base",
          "partial": "Uni",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#t:Uni"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeneralisation of \u003ccode\u003e\u003ca\u003ediv\u003c/a\u003e\u003c/code\u003e to any instance of Real\n\u003c/p\u003e",
          "module": "Data.Fixed",
          "name": "div'",
          "package": "base",
          "signature": "a -\u003e a -\u003e b",
          "source": "src/Data-Fixed.html#div%27",
          "type": "function"
        },
        "index": {
          "description": "generalisation of div to any instance of Real",
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "div'",
          "normalized": "a-\u003ea-\u003eb",
          "package": "base",
          "signature": "a-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#v:div-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeneralisation of \u003ccode\u003e\u003ca\u003edivMod\u003c/a\u003e\u003c/code\u003e to any instance of Real\n\u003c/p\u003e",
          "module": "Data.Fixed",
          "name": "divMod'",
          "package": "base",
          "signature": "a -\u003e a -\u003e (b, a)",
          "source": "src/Data-Fixed.html#divMod%27",
          "type": "function"
        },
        "index": {
          "description": "generalisation of divMod to any instance of Real",
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "divMod'",
          "normalized": "a-\u003ea-\u003e(b,a)",
          "package": "base",
          "partial": "Mod'",
          "signature": "a-\u003ea-\u003e(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#v:divMod-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeneralisation of \u003ccode\u003e\u003ca\u003emod\u003c/a\u003e\u003c/code\u003e to any instance of Real\n\u003c/p\u003e",
          "module": "Data.Fixed",
          "name": "mod'",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Data-Fixed.html#mod%27",
          "type": "function"
        },
        "index": {
          "description": "generalisation of mod to any instance of Real",
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "mod'",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#v:mod-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Fixed",
          "name": "resolution",
          "package": "base",
          "signature": "p a -\u003e Integer",
          "source": "src/Data-Fixed.html#resolution",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "resolution",
          "normalized": "a b-\u003eInteger",
          "package": "base",
          "signature": "p a-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#v:resolution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFirst arg is whether to chop off trailing zeros\n\u003c/p\u003e",
          "module": "Data.Fixed",
          "name": "showFixed",
          "package": "base",
          "signature": "Bool -\u003e Fixed a -\u003e String",
          "source": "src/Data-Fixed.html#showFixed",
          "type": "function"
        },
        "index": {
          "description": "First arg is whether to chop off trailing zeros",
          "hierarchy": "Data Fixed",
          "module": "Data.Fixed",
          "name": "showFixed",
          "normalized": "Bool-\u003eFixed a-\u003eString",
          "package": "base",
          "partial": "Fixed",
          "signature": "Bool-\u003eFixed a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Fixed.html#v:showFixed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eClass of data structures that can be folded to a summary value.\n\u003c/p\u003e\u003cp\u003eMany of these functions generalize \u003ca\u003ePrelude\u003c/a\u003e, \u003ca\u003eControl.Monad\u003c/a\u003e and\n \u003ca\u003eData.List\u003c/a\u003e functions of the same names from lists to any \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e\n functor.  To avoid ambiguity, either import those modules hiding\n these names or qualify uses of these function names with an alias\n for this module.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Foldable",
          "name": "Foldable",
          "package": "base",
          "source": "src/Data-Foldable.html",
          "type": "module"
        },
        "index": {
          "description": "Class of data structures that can be folded to summary value Many of these functions generalize Prelude Control.Monad and Data.List functions of the same names from lists to any Foldable functor To avoid ambiguity either import those modules hiding these names or qualify uses of these function names with an alias for this module",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "Foldable",
          "package": "base",
          "partial": "Foldable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData structures that can be folded.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003efoldMap\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example, given a data type\n\u003c/p\u003e\u003cpre\u003e data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)\n\u003c/pre\u003e\u003cp\u003ea suitable instance would be\n\u003c/p\u003e\u003cpre\u003e instance Foldable Tree where\n    foldMap f Empty = mempty\n    foldMap f (Leaf x) = f x\n    foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r\n\u003c/pre\u003e\u003cp\u003eThis is suitable even for abstract types, as the monoid is assumed\n to satisfy the monoid laws.  Alternatively, one could define \u003ccode\u003efoldr\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e instance Foldable Tree where\n    foldr f z Empty = z\n    foldr f z (Leaf x) = f x z\n    foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l\n\u003c/pre\u003e",
          "module": "Data.Foldable",
          "name": "Foldable",
          "package": "base",
          "source": "src/Data-Foldable.html#Foldable",
          "type": "class"
        },
        "index": {
          "description": "Data structures that can be folded Minimal complete definition foldMap or foldr For example given data type data Tree Empty Leaf Node Tree Tree suitable instance would be instance Foldable Tree where foldMap Empty mempty foldMap Leaf foldMap Node foldMap mappend mappend foldMap This is suitable even for abstract types as the monoid is assumed to satisfy the monoid laws Alternatively one could define foldr instance Foldable Tree where foldr Empty foldr Leaf foldr Node foldr foldr",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "Foldable",
          "package": "base",
          "partial": "Foldable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#t:Foldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermines whether all elements of the structure satisfy the predicate.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "all",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e t a -\u003e Bool",
          "source": "src/Data-Foldable.html#all",
          "type": "function"
        },
        "index": {
          "description": "Determines whether all elements of the structure satisfy the predicate",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "all",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eBool",
          "package": "base",
          "signature": "(a-\u003eBool)-\u003et a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:all"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eand\u003c/a\u003e\u003c/code\u003e returns the conjunction of a container of Bools.  For the\n result to be \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, the container must be finite; \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e, however,\n results from a \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e value finitely far from the left end.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "and",
          "package": "base",
          "signature": "t Bool -\u003e Bool",
          "source": "src/Data-Foldable.html#and",
          "type": "function"
        },
        "index": {
          "description": "and returns the conjunction of container of Bools For the result to be True the container must be finite False however results from False value finitely far from the left end",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "and",
          "normalized": "a Bool-\u003eBool",
          "package": "base",
          "signature": "t Bool-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:and"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermines whether any element of the structure satisfies the predicate.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "any",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e t a -\u003e Bool",
          "source": "src/Data-Foldable.html#any",
          "type": "function"
        },
        "index": {
          "description": "Determines whether any element of the structure satisfies the predicate",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "any",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eBool",
          "package": "base",
          "signature": "(a-\u003eBool)-\u003et a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:any"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe sum of a collection of actions, generalizing \u003ccode\u003e\u003ca\u003econcat\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "asum",
          "package": "base",
          "signature": "t (f a) -\u003e f a",
          "source": "src/Data-Foldable.html#asum",
          "type": "function"
        },
        "index": {
          "description": "The sum of collection of actions generalizing concat",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "asum",
          "normalized": "a(b c)-\u003eb c",
          "package": "base",
          "signature": "t(f a)-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:asum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe concatenation of all the elements of a container of lists.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "concat",
          "package": "base",
          "signature": "t [a] -\u003e [a]",
          "source": "src/Data-Foldable.html#concat",
          "type": "function"
        },
        "index": {
          "description": "The concatenation of all the elements of container of lists",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "concat",
          "normalized": "a[b]-\u003e[b]",
          "package": "base",
          "signature": "t[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap a function over all the elements of a container and concatenate\n the resulting lists.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "concatMap",
          "package": "base",
          "signature": "(a -\u003e [b]) -\u003e t a -\u003e [b]",
          "source": "src/Data-Foldable.html#concatMap",
          "type": "function"
        },
        "index": {
          "description": "Map function over all the elements of container and concatenate the resulting lists",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "concatMap",
          "normalized": "(a-\u003e[b])-\u003ec a-\u003e[b]",
          "package": "base",
          "partial": "Map",
          "signature": "(a-\u003e[b])-\u003et a-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:concatMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes the element occur in the structure?\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "elem",
          "package": "base",
          "signature": "a -\u003e t a -\u003e Bool",
          "source": "src/Data-Foldable.html#elem",
          "type": "function"
        },
        "index": {
          "description": "Does the element occur in the structure",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "elem",
          "normalized": "a-\u003eb a-\u003eBool",
          "package": "base",
          "signature": "a-\u003et a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:elem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efind\u003c/a\u003e\u003c/code\u003e function takes a predicate and a structure and returns\n the leftmost element of the structure matching the predicate, or\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "find",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e t a -\u003e Maybe a",
          "source": "src/Data-Foldable.html#find",
          "type": "function"
        },
        "index": {
          "description": "The find function takes predicate and structure and returns the leftmost element of the structure matching the predicate or Nothing if there is no such element",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "find",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eMaybe a",
          "package": "base",
          "signature": "(a-\u003eBool)-\u003et a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:find"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine the elements of a structure using a monoid.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "fold",
          "package": "base",
          "signature": "t m -\u003e m",
          "source": "src/Data-Foldable.html#fold",
          "type": "method"
        },
        "index": {
          "description": "Combine the elements of structure using monoid",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "fold",
          "normalized": "a b-\u003eb",
          "package": "base",
          "signature": "t m-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of the structure to a monoid,\n and combine the results.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "foldMap",
          "package": "base",
          "signature": "(a -\u003e m) -\u003e t a -\u003e m",
          "source": "src/Data-Foldable.html#foldMap",
          "type": "method"
        },
        "index": {
          "description": "Map each element of the structure to monoid and combine the results",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "foldMap",
          "normalized": "(a-\u003eb)-\u003ec a-\u003eb",
          "package": "base",
          "partial": "Map",
          "signature": "(a-\u003em)-\u003et a-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:foldMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft-associative fold of a structure.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e f z = \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e f z . \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Data.Foldable",
          "name": "foldl",
          "package": "base",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e t b -\u003e a",
          "source": "src/Data-Foldable.html#foldl",
          "type": "method"
        },
        "index": {
          "description": "Left-associative fold of structure foldl foldl toList",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "foldl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
          "package": "base",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003et b-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:foldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft-associative fold of a structure.\n but with strict application of the operator.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e f z = \u003ccode\u003e\u003ca\u003efoldl'\u003c/a\u003e\u003c/code\u003e f z . \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Data.Foldable",
          "name": "foldl'",
          "package": "base",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e t b -\u003e a",
          "source": "src/Data-Foldable.html#foldl%27",
          "type": "method"
        },
        "index": {
          "description": "Left-associative fold of structure but with strict application of the operator foldl foldl toList",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "foldl'",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
          "package": "base",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003et b-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:foldl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e that has no base case,\n and thus may only be applied to non-empty structures.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e f = \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e f . \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Data.Foldable",
          "name": "foldl1",
          "package": "base",
          "signature": "(a -\u003e a -\u003e a) -\u003e t a -\u003e a",
          "source": "src/Data-Foldable.html#foldl1",
          "type": "method"
        },
        "index": {
          "description": "variant of foldl that has no base case and thus may only be applied to non-empty structures foldl1 foldl1 toList",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "foldl1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
          "package": "base",
          "signature": "(a-\u003ea-\u003ea)-\u003et a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:foldl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic fold over the elements of a structure,\n associating to the left, i.e. from left to right.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "foldlM",
          "package": "base",
          "signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e t b -\u003e m a",
          "source": "src/Data-Foldable.html#foldlM",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold over the elements of structure associating to the left i.e from left to right",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "foldlM",
          "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec a",
          "package": "base",
          "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003et b-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:foldlM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight-associative fold of a structure.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e f z = \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e f z . \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Data.Foldable",
          "name": "foldr",
          "package": "base",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e t a -\u003e b",
          "source": "src/Data-Foldable.html#foldr",
          "type": "method"
        },
        "index": {
          "description": "Right-associative fold of structure foldr foldr toList",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "foldr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
          "package": "base",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003et a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:foldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight-associative fold of a structure, \n but with strict application of the operator.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "foldr'",
          "package": "base",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e t a -\u003e b",
          "source": "src/Data-Foldable.html#foldr%27",
          "type": "method"
        },
        "index": {
          "description": "Right-associative fold of structure but with strict application of the operator",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "foldr'",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
          "package": "base",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003et a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:foldr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e that has no base case,\n and thus may only be applied to non-empty structures.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e f = \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e f . \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Data.Foldable",
          "name": "foldr1",
          "package": "base",
          "signature": "(a -\u003e a -\u003e a) -\u003e t a -\u003e a",
          "source": "src/Data-Foldable.html#foldr1",
          "type": "method"
        },
        "index": {
          "description": "variant of foldr that has no base case and thus may only be applied to non-empty structures foldr1 foldr1 toList",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "foldr1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
          "package": "base",
          "signature": "(a-\u003ea-\u003ea)-\u003et a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:foldr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic fold over the elements of a structure,\n associating to the right, i.e. from right to left.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "foldrM",
          "package": "base",
          "signature": "(a -\u003e b -\u003e m b) -\u003e b -\u003e t a -\u003e m b",
          "source": "src/Data-Foldable.html#foldrM",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold over the elements of structure associating to the right i.e from right to left",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "foldrM",
          "normalized": "(a-\u003eb-\u003ec b)-\u003eb-\u003ed a-\u003ec b",
          "package": "base",
          "signature": "(a-\u003eb-\u003em b)-\u003eb-\u003et a-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:foldrM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eforM_\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e with its arguments flipped.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "forM_",
          "package": "base",
          "signature": "t a -\u003e (a -\u003e m b) -\u003e m ()",
          "source": "src/Data-Foldable.html#forM_",
          "type": "function"
        },
        "index": {
          "description": "forM is mapM with its arguments flipped",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "forM_",
          "normalized": "a b-\u003e(b-\u003ec d)-\u003ec()",
          "package": "base",
          "signature": "t a-\u003e(a-\u003em b)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:forM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efor_\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003etraverse_\u003c/a\u003e\u003c/code\u003e with its arguments flipped.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "for_",
          "package": "base",
          "signature": "t a -\u003e (a -\u003e f b) -\u003e f ()",
          "source": "src/Data-Foldable.html#for_",
          "type": "function"
        },
        "index": {
          "description": "for is traverse with its arguments flipped",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "for_",
          "normalized": "a b-\u003e(b-\u003ec d)-\u003ec()",
          "package": "base",
          "signature": "t a-\u003e(a-\u003ef b)-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:for_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure to a monadic action, evaluate\n these actions from left to right, and ignore the results.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "mapM_",
          "package": "base",
          "signature": "(a -\u003e m b) -\u003e t a -\u003e m ()",
          "source": "src/Data-Foldable.html#mapM_",
          "type": "function"
        },
        "index": {
          "description": "Map each element of structure to monadic action evaluate these actions from left to right and ignore the results",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "mapM_",
          "normalized": "(a-\u003eb c)-\u003ed a-\u003eb()",
          "package": "base",
          "signature": "(a-\u003em b)-\u003et a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:mapM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe largest element of a non-empty structure.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "maximum",
          "package": "base",
          "signature": "t a -\u003e a",
          "source": "src/Data-Foldable.html#maximum",
          "type": "function"
        },
        "index": {
          "description": "The largest element of non-empty structure",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "maximum",
          "normalized": "a b-\u003eb",
          "package": "base",
          "signature": "t a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:maximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe largest element of a non-empty structure with respect to the\n given comparison function.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "maximumBy",
          "package": "base",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e t a -\u003e a",
          "source": "src/Data-Foldable.html#maximumBy",
          "type": "function"
        },
        "index": {
          "description": "The largest element of non-empty structure with respect to the given comparison function",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "maximumBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003ea",
          "package": "base",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003et a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:maximumBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe least element of a non-empty structure.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "minimum",
          "package": "base",
          "signature": "t a -\u003e a",
          "source": "src/Data-Foldable.html#minimum",
          "type": "function"
        },
        "index": {
          "description": "The least element of non-empty structure",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "minimum",
          "normalized": "a b-\u003eb",
          "package": "base",
          "signature": "t a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:minimum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe least element of a non-empty structure with respect to the\n given comparison function.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "minimumBy",
          "package": "base",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e t a -\u003e a",
          "source": "src/Data-Foldable.html#minimumBy",
          "type": "function"
        },
        "index": {
          "description": "The least element of non-empty structure with respect to the given comparison function",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "minimumBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003ea",
          "package": "base",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003et a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:minimumBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe sum of a collection of actions, generalizing \u003ccode\u003e\u003ca\u003econcat\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "msum",
          "package": "base",
          "signature": "t (m a) -\u003e m a",
          "source": "src/Data-Foldable.html#msum",
          "type": "function"
        },
        "index": {
          "description": "The sum of collection of actions generalizing concat",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "msum",
          "normalized": "a(b c)-\u003eb c",
          "package": "base",
          "signature": "t(m a)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:msum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003enotElem\u003c/a\u003e\u003c/code\u003e is the negation of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "notElem",
          "package": "base",
          "signature": "a -\u003e t a -\u003e Bool",
          "source": "src/Data-Foldable.html#notElem",
          "type": "function"
        },
        "index": {
          "description": "notElem is the negation of elem",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "notElem",
          "normalized": "a-\u003eb a-\u003eBool",
          "package": "base",
          "partial": "Elem",
          "signature": "a-\u003et a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:notElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eor\u003c/a\u003e\u003c/code\u003e returns the disjunction of a container of Bools.  For the\n result to be \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e, the container must be finite; \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, however,\n results from a \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e value finitely far from the left end.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "or",
          "package": "base",
          "signature": "t Bool -\u003e Bool",
          "source": "src/Data-Foldable.html#or",
          "type": "function"
        },
        "index": {
          "description": "or returns the disjunction of container of Bools For the result to be False the container must be finite True however results from True value finitely far from the left end",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "or",
          "normalized": "a Bool-\u003eBool",
          "package": "base",
          "signature": "t Bool-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eproduct\u003c/a\u003e\u003c/code\u003e function computes the product of the numbers of a structure.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "product",
          "package": "base",
          "signature": "t a -\u003e a",
          "source": "src/Data-Foldable.html#product",
          "type": "function"
        },
        "index": {
          "description": "The product function computes the product of the numbers of structure",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "product",
          "normalized": "a b-\u003eb",
          "package": "base",
          "signature": "t a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:product"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate each action in the structure from left to right,\n and ignore the results.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "sequenceA_",
          "package": "base",
          "signature": "t (f a) -\u003e f ()",
          "source": "src/Data-Foldable.html#sequenceA_",
          "type": "function"
        },
        "index": {
          "description": "Evaluate each action in the structure from left to right and ignore the results",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "sequenceA_",
          "normalized": "a(b c)-\u003eb()",
          "package": "base",
          "signature": "t(f a)-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:sequenceA_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate each monadic action in the structure from left to right,\n and ignore the results.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "sequence_",
          "package": "base",
          "signature": "t (m a) -\u003e m ()",
          "source": "src/Data-Foldable.html#sequence_",
          "type": "function"
        },
        "index": {
          "description": "Evaluate each monadic action in the structure from left to right and ignore the results",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "sequence_",
          "normalized": "a(b c)-\u003eb()",
          "package": "base",
          "signature": "t(m a)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:sequence_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003esum\u003c/a\u003e\u003c/code\u003e function computes the sum of the numbers of a structure.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "sum",
          "package": "base",
          "signature": "t a -\u003e a",
          "source": "src/Data-Foldable.html#sum",
          "type": "function"
        },
        "index": {
          "description": "The sum function computes the sum of the numbers of structure",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "sum",
          "normalized": "a b-\u003eb",
          "package": "base",
          "signature": "t a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of elements of a structure.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "toList",
          "package": "base",
          "signature": "t a -\u003e [a]",
          "source": "src/Data-Foldable.html#toList",
          "type": "function"
        },
        "index": {
          "description": "List of elements of structure",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "toList",
          "normalized": "a b-\u003e[b]",
          "package": "base",
          "partial": "List",
          "signature": "t a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure to an action, evaluate\n these actions from left to right, and ignore the results.\n\u003c/p\u003e",
          "module": "Data.Foldable",
          "name": "traverse_",
          "package": "base",
          "signature": "(a -\u003e f b) -\u003e t a -\u003e f ()",
          "source": "src/Data-Foldable.html#traverse_",
          "type": "function"
        },
        "index": {
          "description": "Map each element of structure to an action evaluate these actions from left to right and ignore the results",
          "hierarchy": "Data Foldable",
          "module": "Data.Foldable",
          "name": "traverse_",
          "normalized": "(a-\u003eb c)-\u003ed a-\u003eb()",
          "package": "base",
          "signature": "(a-\u003ef b)-\u003et a-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Foldable.html#v:traverse_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimple combinators working solely on and with functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Function",
          "name": "Function",
          "package": "base",
          "source": "src/Data-Function.html",
          "type": "module"
        },
        "index": {
          "description": "Simple combinators working solely on and with functions",
          "hierarchy": "Data Function",
          "module": "Data.Function",
          "name": "Function",
          "package": "base",
          "partial": "Function",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Function.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplication operator.  This operator is redundant, since ordinary\n application \u003ccode\u003e(f x)\u003c/code\u003e means the same as \u003ccode\u003e(f \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e x)\u003c/code\u003e. However, \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e has\n low, right-associative binding precedence, so it sometimes allows\n parentheses to be omitted; for example:\n\u003c/p\u003e\u003cpre\u003e     f $ g $ h x  =  f (g (h x))\n\u003c/pre\u003e\u003cp\u003eIt is also useful in higher-order situations, such as \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e 0) xs\u003c/code\u003e,\n or \u003ccode\u003e\u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e) fs xs\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.Function\",\"Prelude\"]",
          "name": "($)",
          "package": "base",
          "signature": "(a -\u003e b) -\u003e a -\u003e b",
          "source": "src/GHC-Base.html#%24",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Function.html#v:-36-\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:-36-\"]"
        },
        "index": {
          "description": "Application operator This operator is redundant since ordinary application means the same as However has low right-associative binding precedence so it sometimes allows parentheses to be omitted for example It is also useful in higher-order situations such as map xs or zipWith fs xs",
          "hierarchy": "Data Function",
          "module": "Data.Function",
          "name": "($) $",
          "normalized": "(a-\u003eb)-\u003ea-\u003eb",
          "package": "base",
          "signature": "(a-\u003eb)-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Function.html#v:-36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction composition.\n\u003c/p\u003e",
          "module": "[\"Data.Function\",\"Prelude\"]",
          "name": "(.)",
          "package": "base",
          "signature": "(b -\u003e c) -\u003e (a -\u003e b) -\u003e a -\u003e c",
          "source": "src/GHC-Base.html#.",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Function.html#v:.\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:.\"]"
        },
        "index": {
          "description": "Function composition",
          "hierarchy": "Data Function",
          "module": "Data.Function",
          "name": "(.) .",
          "normalized": "(a-\u003eb)-\u003e(c-\u003ea)-\u003ec-\u003eb",
          "package": "base",
          "signature": "(b-\u003ec)-\u003e(a-\u003eb)-\u003ea-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Function.html#v:."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstant function.\n\u003c/p\u003e",
          "module": "[\"Data.Function\",\"Prelude\"]",
          "name": "const",
          "package": "base",
          "signature": "a -\u003e b -\u003e a",
          "source": "src/GHC-Base.html#const",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Function.html#v:const\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:const\"]"
        },
        "index": {
          "description": "Constant function",
          "hierarchy": "Data Function",
          "module": "Data.Function",
          "name": "const",
          "normalized": "a-\u003eb-\u003ea",
          "package": "base",
          "signature": "a-\u003eb-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Function.html#v:const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e takes its (first) two arguments in the reverse order of \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.Function\",\"Prelude\"]",
          "name": "flip",
          "package": "base",
          "signature": "(a -\u003e b -\u003e c) -\u003e b -\u003e a -\u003e c",
          "source": "src/GHC-Base.html#flip",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Function.html#v:flip\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:flip\"]"
        },
        "index": {
          "description": "flip takes its first two arguments in the reverse order of",
          "hierarchy": "Data Function",
          "module": "Data.Function",
          "name": "flip",
          "normalized": "(a-\u003eb-\u003ec)-\u003eb-\u003ea-\u003ec",
          "package": "base",
          "signature": "(a-\u003eb-\u003ec)-\u003eb-\u003ea-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Function.html#v:flip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentity function.\n\u003c/p\u003e",
          "module": "[\"Data.Function\",\"Prelude\"]",
          "name": "id",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Base.html#id",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Function.html#v:id\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:id\"]"
        },
        "index": {
          "description": "Identity function",
          "hierarchy": "Data Function",
          "module": "Data.Function",
          "name": "id",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Function.html#v:id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e(*) `on` f = \\x y -\u003e f x * f y\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eTypical usage: \u003ccode\u003e\u003ccode\u003e\u003ca\u003esortBy\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e `on` \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eAlgebraic properties:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e(*) `on` \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e = (*)\u003c/code\u003e (if \u003ccode\u003e(*) &#8713; {&#8869;, \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e &#8869;}\u003c/code\u003e)\n\u003c/li\u003e\u003cli\u003e\u003cpre\u003e((*) `on` f) `on` g = (*) `on` (f . g)\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e on f . \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e on g = \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e on (g . f)\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e",
          "module": "Data.Function",
          "name": "on",
          "package": "base",
          "signature": "(b -\u003e b -\u003e c) -\u003e (a -\u003e b) -\u003e a -\u003e a -\u003e c",
          "source": "src/Data-Function.html#on",
          "type": "function"
        },
        "index": {
          "description": "on Typical usage sortBy compare on fst Algebraic properties on id if const on on on flip on flip on flip on",
          "hierarchy": "Data Function",
          "module": "Data.Function",
          "name": "on",
          "normalized": "(a-\u003ea-\u003eb)-\u003e(c-\u003ea)-\u003ec-\u003ec-\u003eb",
          "package": "base",
          "signature": "(b-\u003eb-\u003ec)-\u003e(a-\u003eb)-\u003ea-\u003ea-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Function.html#v:on"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctors: uniform action over a parameterized type, generalizing the\n \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e function on lists.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Functor",
          "name": "Functor",
          "package": "base",
          "source": "src/Data-Functor.html",
          "type": "module"
        },
        "index": {
          "description": "Functors uniform action over parameterized type generalizing the map function on lists",
          "hierarchy": "Data Functor",
          "module": "Data.Functor",
          "name": "Functor",
          "package": "base",
          "partial": "Functor",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Functor.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e class is used for types that can be mapped over.\nInstances of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e should satisfy the following laws:\n\u003c/p\u003e\u003cpre\u003e fmap id  ==  id\n fmap (f . g)  ==  fmap f . fmap g\n\u003c/pre\u003e\u003cp\u003eThe instances of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e for lists, \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\nsatisfy these laws.\n\u003c/p\u003e",
          "module": "Data.Functor",
          "name": "Functor",
          "package": "base",
          "source": "src/GHC-Base.html#Functor",
          "type": "class"
        },
        "index": {
          "description": "The Functor class is used for types that can be mapped over Instances of Functor should satisfy the following laws fmap id id fmap fmap fmap The instances of Functor for lists Maybe and IO satisfy these laws",
          "hierarchy": "Data Functor",
          "module": "Data.Functor",
          "name": "Functor",
          "package": "base",
          "partial": "Functor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Functor.html#t:Functor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace all locations in the input with the same value.\n The default definition is \u003ccode\u003e\u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, but this may be\n overridden with a more efficient version.\n\u003c/p\u003e",
          "module": "Data.Functor",
          "name": "(\u003c$)",
          "package": "base",
          "signature": "a -\u003e f b -\u003e f a",
          "source": "src/GHC-Base.html#%3C%24",
          "type": "method"
        },
        "index": {
          "description": "Replace all locations in the input with the same value The default definition is fmap const but this may be overridden with more efficient version",
          "hierarchy": "Data Functor",
          "module": "Data.Functor",
          "name": "(\u003c$) \u003c$",
          "normalized": "a-\u003eb c-\u003eb a",
          "package": "base",
          "signature": "a-\u003ef b-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Functor.html#v:-60--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor",
          "name": "fmap",
          "package": "base",
          "signature": "(a -\u003e b) -\u003e f a -\u003e f b",
          "source": "src/GHC-Base.html#fmap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Functor",
          "module": "Data.Functor",
          "name": "fmap",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "base",
          "signature": "(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Functor.html#v:fmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Data.HashTable will be removed in GHC 7.8. Please use an alternative, e.g. the hashtables package, instead.\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eAn implementation of extensible hash tables, as described in\n Per-Ake Larson, \u003cem\u003eDynamic Hash Tables\u003c/em\u003e, CACM 31(4), April 1988,\n pp. 446--457.  The implementation is also derived from the one\n in GHC's runtime system (\u003ccode\u003eghc/rts/Hash.{c,h}\u003c/code\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.HashTable",
          "name": "HashTable",
          "package": "base",
          "source": "src/Data-HashTable.html",
          "type": "module"
        },
        "index": {
          "description": "Deprecated Data.HashTable will be removed in GHC Please use an alternative e.g the hashtables package instead An implementation of extensible hash tables as described in Per-Ake Larson Dynamic Hash Tables CACM April pp The implementation is also derived from the one in GHC runtime system ghc rts Hash",
          "hierarchy": "Data HashTable",
          "module": "Data.HashTable",
          "name": "HashTable",
          "package": "base",
          "partial": "Hash Table",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-HashTable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.HashTable",
          "name": "HashTable",
          "package": "base",
          "source": "src/Data-HashTable.html#HashTable",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data HashTable",
          "module": "Data.HashTable",
          "name": "HashTable",
          "package": "base",
          "partial": "Hash Table",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-HashTable.html#t:HashTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove an entry from the hash table.\n\u003c/p\u003e",
          "module": "Data.HashTable",
          "name": "delete",
          "package": "base",
          "signature": "HashTable key val -\u003e key -\u003e IO ()",
          "source": "src/Data-HashTable.html#delete",
          "type": "function"
        },
        "index": {
          "description": "Remove an entry from the hash table",
          "hierarchy": "Data HashTable",
          "module": "Data.HashTable",
          "name": "delete",
          "normalized": "HashTable a b-\u003ea-\u003eIO()",
          "package": "base",
          "signature": "HashTable key val-\u003ekey-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-HashTable.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a list of key/value pairs into a hash table.  Equality on keys\n is taken from the Eq instance for the key type.\n\u003c/p\u003e",
          "module": "Data.HashTable",
          "name": "fromList",
          "package": "base",
          "signature": "(key -\u003e Int32) -\u003e [(key, val)] -\u003e IO (HashTable key val)",
          "source": "src/Data-HashTable.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "Convert list of key value pairs into hash table Equality on keys is taken from the Eq instance for the key type",
          "hierarchy": "Data HashTable",
          "module": "Data.HashTable",
          "name": "fromList",
          "normalized": "(a-\u003eInt)-\u003e[(a,b)]-\u003eIO(HashTable a b)",
          "package": "base",
          "partial": "List",
          "signature": "(key-\u003eInt)-\u003e[(key,val)]-\u003eIO(HashTable key val)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-HashTable.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA sample (and useful) hash function for Int and Int32,\n implemented by extracting the uppermost 32 bits of the 64-bit\n result of multiplying by a 33-bit constant.  The constant is from\n Knuth, derived from the golden ratio:\n\u003c/p\u003e\u003cpre\u003e golden = round ((sqrt 5 - 1) * 2^32)\n\u003c/pre\u003e\u003cp\u003eWe get good key uniqueness on small inputs\n (a problem with previous versions):\n  (length $ group $ sort $ map hashInt [-32767..65536]) == 65536 + 32768\n\u003c/p\u003e",
          "module": "Data.HashTable",
          "name": "hashInt",
          "package": "base",
          "signature": "Int -\u003e Int32",
          "source": "src/Data-HashTable.html#hashInt",
          "type": "function"
        },
        "index": {
          "description": "sample and useful hash function for Int and Int32 implemented by extracting the uppermost bits of the bit result of multiplying by bit constant The constant is from Knuth derived from the golden ratio golden round sqrt We get good key uniqueness on small inputs problem with previous versions length group sort map hashInt",
          "hierarchy": "Data HashTable",
          "module": "Data.HashTable",
          "name": "hashInt",
          "normalized": "Int-\u003eInt",
          "package": "base",
          "partial": "Int",
          "signature": "Int-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-HashTable.html#v:hashInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA sample hash function for Strings.  We keep multiplying by the\n golden ratio and adding.  The implementation is:\n\u003c/p\u003e\u003cpre\u003e hashString = foldl' f golden\n   where f m c = fromIntegral (ord c) * magic + hashInt32 m\n         magic = 0xdeadbeef\n\u003c/pre\u003e\u003cp\u003eWhere hashInt32 works just as hashInt shown above.\n\u003c/p\u003e\u003cp\u003eKnuth argues that repeated multiplication by the golden ratio\n will minimize gaps in the hash space, and thus it's a good choice\n for combining together multiple keys to form one.\n\u003c/p\u003e\u003cp\u003eHere we know that individual characters c are often small, and this\n produces frequent collisions if we use ord c alone.  A\n particular problem are the shorter low ASCII and ISO-8859-1\n character strings.  We pre-multiply by a magic twiddle factor to\n obtain a good distribution.  In fact, given the following test:\n\u003c/p\u003e\u003cpre\u003e testp :: Int32 -\u003e Int\n testp k = (n - ) . length . group . sort . map hs . take n $ ls\n   where ls = [] : [c : l | l \u003c- ls, c \u003c- ['\\0'..'\\xff']]\n         hs = foldl' f golden\n         f m c = fromIntegral (ord c) * k + hashInt32 m\n         n = 100000\n\u003c/pre\u003e\u003cp\u003eWe discover that testp magic = 0.\n\u003c/p\u003e",
          "module": "Data.HashTable",
          "name": "hashString",
          "package": "base",
          "signature": "String -\u003e Int32",
          "source": "src/Data-HashTable.html#hashString",
          "type": "function"
        },
        "index": {
          "description": "sample hash function for Strings We keep multiplying by the golden ratio and adding The implementation is hashString foldl golden where fromIntegral ord magic hashInt32 magic xdeadbeef Where hashInt32 works just as hashInt shown above Knuth argues that repeated multiplication by the golden ratio will minimize gaps in the hash space and thus it good choice for combining together multiple keys to form one Here we know that individual characters are often small and this produces frequent collisions if we use ord alone particular problem are the shorter low ASCII and ISO-8859-1 character strings We pre-multiply by magic twiddle factor to obtain good distribution In fact given the following test testp Int32 Int testp length group sort map hs take ls where ls ls xff hs foldl golden fromIntegral ord hashInt32 We discover that testp magic",
          "hierarchy": "Data HashTable",
          "module": "Data.HashTable",
          "name": "hashString",
          "normalized": "String-\u003eInt",
          "package": "base",
          "partial": "String",
          "signature": "String-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-HashTable.html#v:hashString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInserts a key/value mapping into the hash table.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e doesn't remove the old entry from the table -\n the behaviour is like an association list, where \u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e returns\n the most-recently-inserted mapping for a key in the table.  The\n reason for this is to keep \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e as efficient as possible.  If\n you need to update a mapping, then we provide \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.HashTable",
          "name": "insert",
          "package": "base",
          "signature": "HashTable key val -\u003e key -\u003e val -\u003e IO ()",
          "source": "src/Data-HashTable.html#insert",
          "type": "function"
        },
        "index": {
          "description": "Inserts key value mapping into the hash table Note that insert doesn remove the old entry from the table the behaviour is like an association list where lookup returns the most-recently-inserted mapping for key in the table The reason for this is to keep insert as efficient as possible If you need to update mapping then we provide update",
          "hierarchy": "Data HashTable",
          "module": "Data.HashTable",
          "name": "insert",
          "normalized": "HashTable a b-\u003ea-\u003eb-\u003eIO()",
          "package": "base",
          "signature": "HashTable key val-\u003ekey-\u003eval-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-HashTable.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function is useful for determining whether your hash\n function is working well for your data set.  It returns the longest\n chain of key/value pairs in the hash table for which all the keys\n hash to the same bucket.  If this chain is particularly long (say,\n longer than 14 elements or so), then it might be a good idea to try\n a different hash function.\n\u003c/p\u003e",
          "module": "Data.HashTable",
          "name": "longestChain",
          "package": "base",
          "signature": "HashTable key val -\u003e IO [(key, val)]",
          "source": "src/Data-HashTable.html#longestChain",
          "type": "function"
        },
        "index": {
          "description": "This function is useful for determining whether your hash function is working well for your data set It returns the longest chain of key value pairs in the hash table for which all the keys hash to the same bucket If this chain is particularly long say longer than elements or so then it might be good idea to try different hash function",
          "hierarchy": "Data HashTable",
          "module": "Data.HashTable",
          "name": "longestChain",
          "normalized": "HashTable a b-\u003eIO[(a,b)]",
          "package": "base",
          "partial": "Chain",
          "signature": "HashTable key val-\u003eIO[(key,val)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-HashTable.html#v:longestChain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLooks up the value of a key in the hash table.\n\u003c/p\u003e",
          "module": "Data.HashTable",
          "name": "lookup",
          "package": "base",
          "signature": "HashTable key val -\u003e key -\u003e IO (Maybe val)",
          "source": "src/Data-HashTable.html#lookup",
          "type": "function"
        },
        "index": {
          "description": "Looks up the value of key in the hash table",
          "hierarchy": "Data HashTable",
          "module": "Data.HashTable",
          "name": "lookup",
          "normalized": "HashTable a b-\u003ea-\u003eIO(Maybe b)",
          "package": "base",
          "signature": "HashTable key val-\u003ekey-\u003eIO(Maybe val)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-HashTable.html#v:lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a new hash table.  The following property should hold for the \u003ccode\u003eeq\u003c/code\u003e\n and \u003ccode\u003ehash\u003c/code\u003e functions passed to \u003ccode\u003e\u003ca\u003enew\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e   eq A B  =\u003e  hash A == hash B\n\u003c/pre\u003e",
          "module": "Data.HashTable",
          "name": "new",
          "package": "base",
          "signature": "(key -\u003e key -\u003e Bool)-\u003e (key -\u003e Int32)-\u003e IO (HashTable key val)",
          "type": "function"
        },
        "index": {
          "description": "Creates new hash table The following property should hold for the eq and hash functions passed to new eq hash hash",
          "hierarchy": "Data HashTable",
          "module": "Data.HashTable",
          "name": "new",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e(a-\u003eInt)-\u003eIO(HashTable a b)",
          "package": "base",
          "signature": "(key-\u003ekey-\u003eBool)-\u003e(key-\u003eInt)-\u003eIO(HashTable key val)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-HashTable.html#v:new"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a new hash table with the given minimum size.\n\u003c/p\u003e",
          "module": "Data.HashTable",
          "name": "newHint",
          "package": "base",
          "signature": "(key -\u003e key -\u003e Bool)-\u003e (key -\u003e Int32)-\u003e Int-\u003e IO (HashTable key val)",
          "type": "function"
        },
        "index": {
          "description": "Creates new hash table with the given minimum size",
          "hierarchy": "Data HashTable",
          "module": "Data.HashTable",
          "name": "newHint",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e(a-\u003eInt)-\u003eInt-\u003eIO(HashTable a b)",
          "package": "base",
          "partial": "Hint",
          "signature": "(key-\u003ekey-\u003eBool)-\u003e(key-\u003eInt)-\u003eInt-\u003eIO(HashTable key val)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-HashTable.html#v:newHint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA prime larger than the maximum hash table size\n\u003c/p\u003e",
          "module": "Data.HashTable",
          "name": "prime",
          "package": "base",
          "signature": "Int32",
          "source": "src/Data-HashTable.html#prime",
          "type": "function"
        },
        "index": {
          "description": "prime larger than the maximum hash table size",
          "hierarchy": "Data HashTable",
          "module": "Data.HashTable",
          "name": "prime",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-HashTable.html#v:prime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a hash table to a list of key/value pairs.\n\u003c/p\u003e",
          "module": "Data.HashTable",
          "name": "toList",
          "package": "base",
          "signature": "HashTable key val -\u003e IO [(key, val)]",
          "source": "src/Data-HashTable.html#toList",
          "type": "function"
        },
        "index": {
          "description": "Converts hash table to list of key value pairs",
          "hierarchy": "Data HashTable",
          "module": "Data.HashTable",
          "name": "toList",
          "normalized": "HashTable a b-\u003eIO[(a,b)]",
          "package": "base",
          "partial": "List",
          "signature": "HashTable key val-\u003eIO[(key,val)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-HashTable.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdates an entry in the hash table, returning \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if there was\n already an entry for this key, or \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise.  After \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e\n there will always be exactly one entry for the given key in the table.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e is more efficient than \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e if you don't care about\n multiple entries, or you know for sure that multiple entries can't\n occur.  However, \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e is more efficient than \u003ccode\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/code\u003e followed\n by \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.HashTable",
          "name": "update",
          "package": "base",
          "signature": "HashTable key val -\u003e key -\u003e val -\u003e IO Bool",
          "source": "src/Data-HashTable.html#update",
          "type": "function"
        },
        "index": {
          "description": "Updates an entry in the hash table returning True if there was already an entry for this key or False otherwise After update there will always be exactly one entry for the given key in the table insert is more efficient than update if you don care about multiple entries or you know for sure that multiple entries can occur However update is more efficient than delete followed by insert",
          "hierarchy": "Data HashTable",
          "module": "Data.HashTable",
          "name": "update",
          "normalized": "HashTable a b-\u003ea-\u003eb-\u003eIO Bool",
          "package": "base",
          "signature": "HashTable key val-\u003ekey-\u003eval-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-HashTable.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMutable references in the IO monad.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.IORef",
          "name": "IORef",
          "package": "base",
          "source": "src/Data-IORef.html",
          "type": "module"
        },
        "index": {
          "description": "Mutable references in the IO monad",
          "hierarchy": "Data IORef",
          "module": "Data.IORef",
          "name": "IORef",
          "package": "base",
          "partial": "IORef",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-IORef.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA mutable variable in the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad\n\u003c/p\u003e",
          "module": "Data.IORef",
          "name": "IORef",
          "package": "base",
          "source": "src/GHC-IORef.html#IORef",
          "type": "data"
        },
        "index": {
          "description": "mutable variable in the IO monad",
          "hierarchy": "Data IORef",
          "module": "Data.IORef",
          "name": "IORef",
          "package": "base",
          "partial": "IORef",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-IORef.html#t:IORef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAtomically modifies the contents of an \u003ccode\u003e\u003ca\u003eIORef\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function is useful for using \u003ccode\u003e\u003ca\u003eIORef\u003c/a\u003e\u003c/code\u003e in a safe way in a multithreaded\n program.  If you only have one \u003ccode\u003e\u003ca\u003eIORef\u003c/a\u003e\u003c/code\u003e, then using \u003ccode\u003e\u003ca\u003eatomicModifyIORef\u003c/a\u003e\u003c/code\u003e to\n access and modify it will prevent race conditions.\n\u003c/p\u003e\u003cp\u003eExtending the atomicity to multiple \u003ccode\u003e\u003ca\u003eIORef\u003c/a\u003e\u003c/code\u003es is problematic, so it\n is recommended that if you need to do anything more complicated\n then using \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e instead is a good idea.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eatomicModifyIORef\u003c/a\u003e\u003c/code\u003e does not apply the function strictly.  This is important\n to know even if all you are doing is replacing the value.  For example, this\n will leak memory:\n\u003c/p\u003e\u003cpre\u003eref \u003c- newIORef '1'\nforever $ atomicModifyIORef ref (\\_ -\u003e ('2', ()))\n\u003c/pre\u003e\u003cp\u003eUse \u003ccode\u003e\u003ca\u003eatomicModifyIORef'\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eatomicWriteIORef\u003c/a\u003e\u003c/code\u003e to avoid this problem.\n\u003c/p\u003e",
          "module": "Data.IORef",
          "name": "atomicModifyIORef",
          "package": "base",
          "signature": "IORef a -\u003e (a -\u003e (a, b)) -\u003e IO b",
          "source": "src/Data-IORef.html#atomicModifyIORef",
          "type": "function"
        },
        "index": {
          "description": "Atomically modifies the contents of an IORef This function is useful for using IORef in safe way in multithreaded program If you only have one IORef then using atomicModifyIORef to access and modify it will prevent race conditions Extending the atomicity to multiple IORef is problematic so it is recommended that if you need to do anything more complicated then using MVar instead is good idea atomicModifyIORef does not apply the function strictly This is important to know even if all you are doing is replacing the value For example this will leak memory ref newIORef forever atomicModifyIORef ref Use atomicModifyIORef or atomicWriteIORef to avoid this problem",
          "hierarchy": "Data IORef",
          "module": "Data.IORef",
          "name": "atomicModifyIORef",
          "normalized": "IORef a-\u003e(a-\u003e(a,b))-\u003eIO b",
          "package": "base",
          "partial": "Modify IORef",
          "signature": "IORef a-\u003e(a-\u003e(a,b))-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-IORef.html#v:atomicModifyIORef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrict version of \u003ccode\u003e\u003ca\u003eatomicModifyIORef\u003c/a\u003e\u003c/code\u003e.  This forces both the value stored\n in the \u003ccode\u003e\u003ca\u003eIORef\u003c/a\u003e\u003c/code\u003e as well as the value returned.\n\u003c/p\u003e",
          "module": "Data.IORef",
          "name": "atomicModifyIORef'",
          "package": "base",
          "signature": "IORef a -\u003e (a -\u003e (a, b)) -\u003e IO b",
          "source": "src/Data-IORef.html#atomicModifyIORef%27",
          "type": "function"
        },
        "index": {
          "description": "Strict version of atomicModifyIORef This forces both the value stored in the IORef as well as the value returned",
          "hierarchy": "Data IORef",
          "module": "Data.IORef",
          "name": "atomicModifyIORef'",
          "normalized": "IORef a-\u003e(a-\u003e(a,b))-\u003eIO b",
          "package": "base",
          "partial": "Modify IORef'",
          "signature": "IORef a-\u003e(a-\u003e(a,b))-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-IORef.html#v:atomicModifyIORef-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003ewriteIORef\u003c/a\u003e\u003c/code\u003e with the \"barrier to reordering\" property that\n \u003ccode\u003e\u003ca\u003eatomicModifyIORef\u003c/a\u003e\u003c/code\u003e has.\n\u003c/p\u003e",
          "module": "Data.IORef",
          "name": "atomicWriteIORef",
          "package": "base",
          "signature": "IORef a -\u003e a -\u003e IO ()",
          "source": "src/Data-IORef.html#atomicWriteIORef",
          "type": "function"
        },
        "index": {
          "description": "Variant of writeIORef with the barrier to reordering property that atomicModifyIORef has",
          "hierarchy": "Data IORef",
          "module": "Data.IORef",
          "name": "atomicWriteIORef",
          "normalized": "IORef a-\u003ea-\u003eIO()",
          "package": "base",
          "partial": "Write IORef",
          "signature": "IORef a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-IORef.html#v:atomicWriteIORef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a \u003ccode\u003e\u003ca\u003eWeak\u003c/a\u003e\u003c/code\u003e pointer to an \u003ccode\u003e\u003ca\u003eIORef\u003c/a\u003e\u003c/code\u003e, using the second argument as a finalizer\n to run when \u003ccode\u003e\u003ca\u003eIORef\u003c/a\u003e\u003c/code\u003e is garbage-collected\n\u003c/p\u003e",
          "module": "Data.IORef",
          "name": "mkWeakIORef",
          "package": "base",
          "signature": "IORef a -\u003e IO () -\u003e IO (Weak (IORef a))",
          "source": "src/Data-IORef.html#mkWeakIORef",
          "type": "function"
        },
        "index": {
          "description": "Make Weak pointer to an IORef using the second argument as finalizer to run when IORef is garbage-collected",
          "hierarchy": "Data IORef",
          "module": "Data.IORef",
          "name": "mkWeakIORef",
          "normalized": "IORef a-\u003eIO()-\u003eIO(Weak(IORef a))",
          "package": "base",
          "partial": "Weak IORef",
          "signature": "IORef a-\u003eIO()-\u003eIO(Weak(IORef a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-IORef.html#v:mkWeakIORef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMutate the contents of an \u003ccode\u003e\u003ca\u003eIORef\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eBe warned that \u003ccode\u003e\u003ca\u003emodifyIORef\u003c/a\u003e\u003c/code\u003e does not apply the function strictly.  This\n means if the program calls \u003ccode\u003e\u003ca\u003emodifyIORef\u003c/a\u003e\u003c/code\u003e many times, but seldomly uses the\n value, thunks will pile up in memory resulting in a space leak.  This is a\n common mistake made when using an IORef as a counter.  For example, the\n following will likely produce a stack overflow:\n\u003c/p\u003e\u003cpre\u003eref \u003c- newIORef 0\nreplicateM_ 1000000 $ modifyIORef ref (+1)\nreadIORef ref \u003e\u003e= print\n\u003c/pre\u003e\u003cp\u003eTo avoid this problem, use \u003ccode\u003e\u003ca\u003emodifyIORef'\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Data.IORef",
          "name": "modifyIORef",
          "package": "base",
          "signature": "IORef a -\u003e (a -\u003e a) -\u003e IO ()",
          "source": "src/Data-IORef.html#modifyIORef",
          "type": "function"
        },
        "index": {
          "description": "Mutate the contents of an IORef Be warned that modifyIORef does not apply the function strictly This means if the program calls modifyIORef many times but seldomly uses the value thunks will pile up in memory resulting in space leak This is common mistake made when using an IORef as counter For example the following will likely produce stack overflow ref newIORef replicateM modifyIORef ref readIORef ref print To avoid this problem use modifyIORef instead",
          "hierarchy": "Data IORef",
          "module": "Data.IORef",
          "name": "modifyIORef",
          "normalized": "IORef a-\u003e(a-\u003ea)-\u003eIO()",
          "package": "base",
          "partial": "IORef",
          "signature": "IORef a-\u003e(a-\u003ea)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-IORef.html#v:modifyIORef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrict version of \u003ccode\u003e\u003ca\u003emodifyIORef\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.IORef",
          "name": "modifyIORef'",
          "package": "base",
          "signature": "IORef a -\u003e (a -\u003e a) -\u003e IO ()",
          "source": "src/Data-IORef.html#modifyIORef%27",
          "type": "function"
        },
        "index": {
          "description": "Strict version of modifyIORef",
          "hierarchy": "Data IORef",
          "module": "Data.IORef",
          "name": "modifyIORef'",
          "normalized": "IORef a-\u003e(a-\u003ea)-\u003eIO()",
          "package": "base",
          "partial": "IORef'",
          "signature": "IORef a-\u003e(a-\u003ea)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-IORef.html#v:modifyIORef-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a new \u003ccode\u003e\u003ca\u003eIORef\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.IORef",
          "name": "newIORef",
          "package": "base",
          "signature": "a -\u003e IO (IORef a)",
          "source": "src/GHC-IORef.html#newIORef",
          "type": "function"
        },
        "index": {
          "description": "Build new IORef",
          "hierarchy": "Data IORef",
          "module": "Data.IORef",
          "name": "newIORef",
          "normalized": "a-\u003eIO(IORef a)",
          "package": "base",
          "partial": "IORef",
          "signature": "a-\u003eIO(IORef a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-IORef.html#v:newIORef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the value of an \u003ccode\u003e\u003ca\u003eIORef\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.IORef",
          "name": "readIORef",
          "package": "base",
          "signature": "IORef a -\u003e IO a",
          "source": "src/GHC-IORef.html#readIORef",
          "type": "function"
        },
        "index": {
          "description": "Read the value of an IORef",
          "hierarchy": "Data IORef",
          "module": "Data.IORef",
          "name": "readIORef",
          "normalized": "IORef a-\u003eIO a",
          "package": "base",
          "partial": "IORef",
          "signature": "IORef a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-IORef.html#v:readIORef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a new value into an \u003ccode\u003e\u003ca\u003eIORef\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.IORef",
          "name": "writeIORef",
          "package": "base",
          "signature": "IORef a -\u003e a -\u003e IO ()",
          "source": "src/GHC-IORef.html#writeIORef",
          "type": "function"
        },
        "index": {
          "description": "Write new value into an IORef",
          "hierarchy": "Data IORef",
          "module": "Data.IORef",
          "name": "writeIORef",
          "normalized": "IORef a-\u003ea-\u003eIO()",
          "package": "base",
          "partial": "IORef",
          "signature": "IORef a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-IORef.html#v:writeIORef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSigned integer types\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Int",
          "name": "Int",
          "package": "base",
          "source": "src/Data-Int.html",
          "type": "module"
        },
        "index": {
          "description": "Signed integer types",
          "hierarchy": "Data Int",
          "module": "Data.Int",
          "name": "Int",
          "package": "base",
          "partial": "Int",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Int.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA fixed-precision integer type with at least the range \u003ccode\u003e[-2^29 .. 2^29-1]\u003c/code\u003e.\n The exact range for a given implementation can be determined by using\n \u003ccode\u003e\u003ca\u003eminBound\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emaxBound\u003c/a\u003e\u003c/code\u003e from the \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "Data.Int",
          "name": "Int",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "fixed-precision integer type with at least the range The exact range for given implementation can be determined by using minBound and maxBound from the Bounded class",
          "hierarchy": "Data Int",
          "module": "Data.Int",
          "name": "Int",
          "package": "base",
          "partial": "Int",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e16-bit signed integer type\n\u003c/p\u003e",
          "module": "Data.Int",
          "name": "Int16",
          "package": "base",
          "source": "src/GHC-Int.html#Int16",
          "type": "data"
        },
        "index": {
          "description": "bit signed integer type",
          "hierarchy": "Data Int",
          "module": "Data.Int",
          "name": "Int16",
          "package": "base",
          "partial": "Int",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e32-bit signed integer type\n\u003c/p\u003e",
          "module": "Data.Int",
          "name": "Int32",
          "package": "base",
          "source": "src/GHC-Int.html#Int32",
          "type": "data"
        },
        "index": {
          "description": "bit signed integer type",
          "hierarchy": "Data Int",
          "module": "Data.Int",
          "name": "Int32",
          "package": "base",
          "partial": "Int",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e64-bit signed integer type\n\u003c/p\u003e",
          "module": "Data.Int",
          "name": "Int64",
          "package": "base",
          "source": "src/GHC-Int.html#Int64",
          "type": "data"
        },
        "index": {
          "description": "bit signed integer type",
          "hierarchy": "Data Int",
          "module": "Data.Int",
          "name": "Int64",
          "package": "base",
          "partial": "Int",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int64"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8-bit signed integer type\n\u003c/p\u003e",
          "module": "Data.Int",
          "name": "Int8",
          "package": "base",
          "source": "src/GHC-Int.html#Int8",
          "type": "data"
        },
        "index": {
          "description": "bit signed integer type",
          "hierarchy": "Data Int",
          "module": "Data.Int",
          "name": "Int8",
          "package": "base",
          "partial": "Int",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eIx\u003c/a\u003e\u003c/code\u003e class is used to map a contiguous subrange of values in\n type onto integers.  It is used primarily for array indexing\n (see the array package).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Ix",
          "name": "Ix",
          "package": "base",
          "source": "src/Data-Ix.html",
          "type": "module"
        },
        "index": {
          "description": "The Ix class is used to map contiguous subrange of values in type onto integers It is used primarily for array indexing see the array package",
          "hierarchy": "Data Ix",
          "module": "Data.Ix",
          "name": "Ix",
          "package": "base",
          "partial": "Ix",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ix.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eIx\u003c/a\u003e\u003c/code\u003e class is used to map a contiguous subrange of values in\n a type onto integers.  It is used primarily for array indexing\n (see the array package).\n\u003c/p\u003e\u003cp\u003eThe first argument \u003ccode\u003e(l,u)\u003c/code\u003e of each of these operations is a pair\n specifying the lower and upper bounds of a contiguous subrange of values.\n\u003c/p\u003e\u003cp\u003eAn implementation is entitled to assume the following laws about these\n operations:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ccode\u003e\u003ca\u003einRange\u003c/a\u003e\u003c/code\u003e (l,u) i == \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e i (\u003ccode\u003e\u003ca\u003erange\u003c/a\u003e\u003c/code\u003e (l,u))\u003c/code\u003e \u003ccode\u003e \u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ccode\u003e\u003ca\u003erange\u003c/a\u003e\u003c/code\u003e (l,u) \u003ccode\u003e\u003ca\u003e!!\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eindex\u003c/a\u003e\u003c/code\u003e (l,u) i == i\u003c/code\u003e, when \u003ccode\u003e\u003ccode\u003e\u003ca\u003einRange\u003c/a\u003e\u003c/code\u003e (l,u) i\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eindex\u003c/a\u003e\u003c/code\u003e (l,u)) (\u003ccode\u003e\u003ca\u003erange\u003c/a\u003e\u003c/code\u003e (l,u))) == [0..\u003ccode\u003e\u003ca\u003erangeSize\u003c/a\u003e\u003c/code\u003e (l,u)-1]\u003c/code\u003e \u003ccode\u003e \u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ccode\u003e\u003ca\u003erangeSize\u003c/a\u003e\u003c/code\u003e (l,u) == \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003erange\u003c/a\u003e\u003c/code\u003e (l,u))\u003c/code\u003e \u003ccode\u003e \u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eMinimal complete instance: \u003ccode\u003e\u003ca\u003erange\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eindex\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003einRange\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Ix",
          "name": "Ix",
          "package": "base",
          "source": "src/GHC-Arr.html#Ix",
          "type": "class"
        },
        "index": {
          "description": "The Ix class is used to map contiguous subrange of values in type onto integers It is used primarily for array indexing see the array package The first argument of each of these operations is pair specifying the lower and upper bounds of contiguous subrange of values An implementation is entitled to assume the following laws about these operations inRange elem range range index when inRange map index range rangeSize rangeSize length range Minimal complete instance range index and inRange",
          "hierarchy": "Data Ix",
          "module": "Data.Ix",
          "name": "Ix",
          "package": "base",
          "partial": "Ix",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ix.html#t:Ix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e the given subscript lies in the range defined\n the bounding pair.\n\u003c/p\u003e",
          "module": "Data.Ix",
          "name": "inRange",
          "package": "base",
          "signature": "(a, a) -\u003e a -\u003e Bool",
          "source": "src/GHC-Arr.html#inRange",
          "type": "method"
        },
        "index": {
          "description": "Returns True the given subscript lies in the range defined the bounding pair",
          "hierarchy": "Data Ix",
          "module": "Data.Ix",
          "name": "inRange",
          "normalized": "(a,a)-\u003ea-\u003eBool",
          "package": "base",
          "partial": "Range",
          "signature": "(a,a)-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ix.html#v:inRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe position of a subscript in the subrange.\n\u003c/p\u003e",
          "module": "Data.Ix",
          "name": "index",
          "package": "base",
          "signature": "(a, a) -\u003e a -\u003e Int",
          "source": "src/GHC-Arr.html#index",
          "type": "method"
        },
        "index": {
          "description": "The position of subscript in the subrange",
          "hierarchy": "Data Ix",
          "module": "Data.Ix",
          "name": "index",
          "normalized": "(a,a)-\u003ea-\u003eInt",
          "package": "base",
          "signature": "(a,a)-\u003ea-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ix.html#v:index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe list of values in the subrange defined by a bounding pair.\n\u003c/p\u003e",
          "module": "Data.Ix",
          "name": "range",
          "package": "base",
          "signature": "(a, a) -\u003e [a]",
          "source": "src/GHC-Arr.html#range",
          "type": "method"
        },
        "index": {
          "description": "The list of values in the subrange defined by bounding pair",
          "hierarchy": "Data Ix",
          "module": "Data.Ix",
          "name": "range",
          "normalized": "(a,a)-\u003e[a]",
          "package": "base",
          "signature": "(a,a)-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ix.html#v:range"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe size of the subrange defined by a bounding pair.\n\u003c/p\u003e",
          "module": "Data.Ix",
          "name": "rangeSize",
          "package": "base",
          "signature": "(a, a) -\u003e Int",
          "source": "src/GHC-Arr.html#rangeSize",
          "type": "method"
        },
        "index": {
          "description": "The size of the subrange defined by bounding pair",
          "hierarchy": "Data Ix",
          "module": "Data.Ix",
          "name": "rangeSize",
          "normalized": "(a,a)-\u003eInt",
          "package": "base",
          "partial": "Size",
          "signature": "(a,a)-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ix.html#v:rangeSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOperations on lists.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.List",
          "name": "List",
          "package": "base",
          "source": "src/Data-List.html",
          "type": "module"
        },
        "index": {
          "description": "Operations on lists",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "List",
          "package": "base",
          "partial": "List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList index (subscript) operator, starting from 0.\n It is an instance of the more general \u003ccode\u003e\u003ca\u003egenericIndex\u003c/a\u003e\u003c/code\u003e,\n which takes an index of any integral type.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "(!!)",
          "package": "base",
          "signature": "[a] -\u003e Int -\u003e a",
          "source": "src/GHC-List.html#%21%21",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:-33--33-\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:-33--33-\"]"
        },
        "index": {
          "description": "List index subscript operator starting from It is an instance of the more general genericIndex which takes an index of any integral type",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "(!!) !!",
          "normalized": "[a]-\u003eInt-\u003ea",
          "package": "base",
          "signature": "[a]-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:-33--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAppend two lists, i.e.,\n\u003c/p\u003e\u003cpre\u003e [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]\n [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]\n\u003c/pre\u003e\u003cp\u003eIf the first list is not finite, the result is the first list.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "(++)",
          "package": "base",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/GHC-Base.html#%2B%2B",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:-43--43-\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:-43--43-\"]"
        },
        "index": {
          "description": "Append two lists i.e x1 xm y1 yn x1 xm y1 yn x1 xm y1 x1 xm y1 If the first list is not finite the result is the first list",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "(++) ++",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "base",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:-43--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003e\\\\\u003c/a\u003e\u003c/code\u003e function is list difference (non-associative).\n In the result of \u003ccode\u003exs\u003c/code\u003e \u003ccode\u003e\u003ca\u003e\\\\\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eys\u003c/code\u003e, the first occurrence of each element of\n \u003ccode\u003eys\u003c/code\u003e in turn (if any) has been removed from \u003ccode\u003exs\u003c/code\u003e.  Thus\n\u003c/p\u003e\u003cpre\u003e (xs ++ ys) \\\\ xs == ys.\n\u003c/pre\u003e\u003cp\u003eIt is a special case of \u003ccode\u003e\u003ca\u003edeleteFirstsBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer\n to supply their own equality test.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "(\\\\)",
          "package": "base",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#%5C%5C",
          "type": "function"
        },
        "index": {
          "description": "The function is list difference non-associative In the result of xs ys the first occurrence of each element of ys in turn if any has been removed from xs Thus xs ys xs ys It is special case of deleteFirstsBy which allows the programmer to supply their own equality test",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "(\\\\) \\\\",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "base",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:-92--92-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplied to a predicate and a list, \u003ccode\u003e\u003ca\u003eall\u003c/a\u003e\u003c/code\u003e determines if all elements\n of the list satisfy the predicate. For the result to be\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, the list must be finite; \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e, however, results from a \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e\n value for the predicate applied to an element at a finite index of a finite or infinite list.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "all",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e Bool",
          "source": "src/GHC-List.html#all",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:all\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:all\"]"
        },
        "index": {
          "description": "Applied to predicate and list all determines if all elements of the list satisfy the predicate For the result to be True the list must be finite False however results from False value for the predicate applied to an element at finite index of finite or infinite list",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "all",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003eBool",
          "package": "base",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:all"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eand\u003c/a\u003e\u003c/code\u003e returns the conjunction of a Boolean list.  For the result to be\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, the list must be finite; \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e, however, results from a \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e\n value at a finite index of a finite or infinite list.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "and",
          "package": "base",
          "signature": "[Bool] -\u003e Bool",
          "source": "src/GHC-List.html#and",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:and\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:and\"]"
        },
        "index": {
          "description": "and returns the conjunction of Boolean list For the result to be True the list must be finite False however results from False value at finite index of finite or infinite list",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "and",
          "normalized": "[Bool]-\u003eBool",
          "package": "base",
          "signature": "[Bool]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:and"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplied to a predicate and a list, \u003ccode\u003e\u003ca\u003eany\u003c/a\u003e\u003c/code\u003e determines if any element\n of the list satisfies the predicate.  For the result to be\n \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e, the list must be finite; \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, however, results from a \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n value for the predicate applied to an element at a finite index of a finite or infinite list.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "any",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e Bool",
          "source": "src/GHC-List.html#any",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:any\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:any\"]"
        },
        "index": {
          "description": "Applied to predicate and list any determines if any element of the list satisfies the predicate For the result to be False the list must be finite True however results from True value for the predicate applied to an element at finite index of finite or infinite list",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "any",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003eBool",
          "package": "base",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:any"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ebreak\u003c/a\u003e\u003c/code\u003e, applied to a predicate \u003ccode\u003ep\u003c/code\u003e and a list \u003ccode\u003exs\u003c/code\u003e, returns a tuple where\n first element is longest prefix (possibly empty) of \u003ccode\u003exs\u003c/code\u003e of elements that\n \u003cem\u003edo not satisfy\u003c/em\u003e \u003ccode\u003ep\u003c/code\u003e and second element is the remainder of the list:\n\u003c/p\u003e\u003cpre\u003e break (\u003e 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])\n break (\u003c 9) [1,2,3] == ([],[1,2,3])\n break (\u003e 9) [1,2,3] == ([1,2,3],[])\n\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ebreak\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e . p)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "break",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e ([a], [a])",
          "source": "src/GHC-List.html#break",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:break\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:break\"]"
        },
        "index": {
          "description": "break applied to predicate and list xs returns tuple where first element is longest prefix possibly empty of xs of elements that do not satisfy and second element is the remainder of the list break break break break is equivalent to span not",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "break",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "package": "base",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:break"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConcatenate a list of lists.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "concat",
          "package": "base",
          "signature": "[[a]] -\u003e [a]",
          "source": "src/GHC-List.html#concat",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:concat\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:concat\"]"
        },
        "index": {
          "description": "Concatenate list of lists",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "concat",
          "normalized": "[[a]]-\u003e[a]",
          "package": "base",
          "signature": "[[a]]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap a function over a list and concatenate the results.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "concatMap",
          "package": "base",
          "signature": "(a -\u003e [b]) -\u003e [a] -\u003e [b]",
          "source": "src/GHC-List.html#concatMap",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:concatMap\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:concatMap\"]"
        },
        "index": {
          "description": "Map function over list and concatenate the results",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "concatMap",
          "normalized": "(a-\u003e[b])-\u003e[a]-\u003e[b]",
          "package": "base",
          "partial": "Map",
          "signature": "(a-\u003e[b])-\u003e[a]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:concatMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ecycle\u003c/a\u003e\u003c/code\u003e ties a finite list into a circular one, or equivalently,\n the infinite repetition of the original list.  It is the identity\n on infinite lists.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "cycle",
          "package": "base",
          "signature": "[a] -\u003e [a]",
          "source": "src/GHC-List.html#cycle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:cycle\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:cycle\"]"
        },
        "index": {
          "description": "cycle ties finite list into circular one or equivalently the infinite repetition of the original list It is the identity on infinite lists",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "cycle",
          "normalized": "[a]-\u003e[a]",
          "package": "base",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ex\u003c/code\u003e removes the first occurrence of \u003ccode\u003ex\u003c/code\u003e from its list argument.\n For example,\n\u003c/p\u003e\u003cpre\u003e delete 'a' \"banana\" == \"bnana\"\n\u003c/pre\u003e\u003cp\u003eIt is a special case of \u003ccode\u003e\u003ca\u003edeleteBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to\n supply their own equality test.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "delete",
          "package": "base",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#delete",
          "type": "function"
        },
        "index": {
          "description": "delete removes the first occurrence of from its list argument For example delete banana bnana It is special case of deleteBy which allows the programmer to supply their own equality test",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "delete",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "base",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003edeleteBy\u003c/a\u003e\u003c/code\u003e function behaves like \u003ccode\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/code\u003e, but takes a\n user-supplied equality predicate.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "deleteBy",
          "package": "base",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e a -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#deleteBy",
          "type": "function"
        },
        "index": {
          "description": "The deleteBy function behaves like delete but takes user-supplied equality predicate",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "deleteBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003ea-\u003e[a]-\u003e[a]",
          "package": "base",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003ea-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:deleteBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003edeleteFirstsBy\u003c/a\u003e\u003c/code\u003e function takes a predicate and two lists and\n returns the first list with the first occurrence of each element of\n the second list removed.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "deleteFirstsBy",
          "package": "base",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#deleteFirstsBy",
          "type": "function"
        },
        "index": {
          "description": "The deleteFirstsBy function takes predicate and two lists and returns the first list with the first occurrence of each element of the second list removed",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "deleteFirstsBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "base",
          "partial": "Firsts By",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:deleteFirstsBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en xs\u003c/code\u003e returns the suffix of \u003ccode\u003exs\u003c/code\u003e\n after the first \u003ccode\u003en\u003c/code\u003e elements, or \u003ccode\u003e[]\u003c/code\u003e if \u003ccode\u003en \u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e xs\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e drop 6 \"Hello World!\" == \"World!\"\n drop 3 [1,2,3,4,5] == [4,5]\n drop 3 [1,2] == []\n drop 3 [] == []\n drop (-1) [1,2] == [1,2]\n drop 0 [1,2] == [1,2]\n\u003c/pre\u003e\u003cp\u003eIt is an instance of the more general \u003ccode\u003e\u003ca\u003egenericDrop\u003c/a\u003e\u003c/code\u003e,\n in which \u003ccode\u003en\u003c/code\u003e may be of any integral type.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "drop",
          "package": "base",
          "signature": "Int -\u003e [a] -\u003e [a]",
          "source": "src/GHC-List.html#drop",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:drop\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:drop\"]"
        },
        "index": {
          "description": "drop xs returns the suffix of xs after the first elements or if length xs drop Hello World World drop drop drop drop drop It is an instance of the more general genericDrop in which may be of any integral type",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "drop",
          "normalized": "Int-\u003e[a]-\u003e[a]",
          "package": "base",
          "signature": "Int-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edropWhile\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e returns the suffix remaining after \u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e dropWhile (\u003c 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]\n dropWhile (\u003c 9) [1,2,3] == []\n dropWhile (\u003c 0) [1,2,3] == [1,2,3]\n\u003c/pre\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "dropWhile",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [a]",
          "source": "src/GHC-List.html#dropWhile",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:dropWhile\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:dropWhile\"]"
        },
        "index": {
          "description": "dropWhile xs returns the suffix remaining after takeWhile xs dropWhile dropWhile dropWhile",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "dropWhile",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "package": "base",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:dropWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003edropWhileEnd\u003c/a\u003e\u003c/code\u003e function drops the largest suffix of a list\n in which the given predicate holds for all elements.  For example:\n\u003c/p\u003e\u003cpre\u003e dropWhileEnd isSpace \"foo\\n\" == \"foo\"\n dropWhileEnd isSpace \"foo bar\" == \"foo bar\"\n dropWhileEnd isSpace (\"foo\\n\" ++ undefined) == \"foo\" ++ undefined\n\u003c/pre\u003e",
          "module": "Data.List",
          "name": "dropWhileEnd",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#dropWhileEnd",
          "type": "function"
        },
        "index": {
          "description": "The dropWhileEnd function drops the largest suffix of list in which the given predicate holds for all elements For example dropWhileEnd isSpace foo foo dropWhileEnd isSpace foo bar foo bar dropWhileEnd isSpace foo undefined foo undefined",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "dropWhileEnd",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "package": "base",
          "partial": "While End",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:dropWhileEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e is the list membership predicate, usually written in infix form,\n e.g., \u003ccode\u003ex `elem` xs\u003c/code\u003e.  For the result to be\n \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e, the list must be finite; \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, however, results from an element equal to \u003ccode\u003ex\u003c/code\u003e found at a finite index of a finite or infinite list.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "elem",
          "package": "base",
          "signature": "a -\u003e [a] -\u003e Bool",
          "source": "src/GHC-List.html#elem",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:elem\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:elem\"]"
        },
        "index": {
          "description": "elem is the list membership predicate usually written in infix form e.g elem xs For the result to be False the list must be finite True however results from an element equal to found at finite index of finite or infinite list",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "elem",
          "normalized": "a-\u003e[a]-\u003eBool",
          "package": "base",
          "signature": "a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:elem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eelemIndex\u003c/a\u003e\u003c/code\u003e function returns the index of the first element\n in the given list which is equal (by \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e) to the query element,\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "elemIndex",
          "package": "base",
          "signature": "a -\u003e [a] -\u003e Maybe Int",
          "source": "src/Data-List.html#elemIndex",
          "type": "function"
        },
        "index": {
          "description": "The elemIndex function returns the index of the first element in the given list which is equal by to the query element or Nothing if there is no such element",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "elemIndex",
          "normalized": "a-\u003e[a]-\u003eMaybe Int",
          "package": "base",
          "partial": "Index",
          "signature": "a-\u003e[a]-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:elemIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eelemIndices\u003c/a\u003e\u003c/code\u003e function extends \u003ccode\u003e\u003ca\u003eelemIndex\u003c/a\u003e\u003c/code\u003e, by returning the\n indices of all elements equal to the query element, in ascending order.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "elemIndices",
          "package": "base",
          "signature": "a -\u003e [a] -\u003e [Int]",
          "source": "src/Data-List.html#elemIndices",
          "type": "function"
        },
        "index": {
          "description": "The elemIndices function extends elemIndex by returning the indices of all elements equal to the query element in ascending order",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "elemIndices",
          "normalized": "a-\u003e[a]-\u003e[Int]",
          "package": "base",
          "partial": "Indices",
          "signature": "a-\u003e[a]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:elemIndices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efilter\u003c/a\u003e\u003c/code\u003e, applied to a predicate and a list, returns the list of\n those elements that satisfy the predicate; i.e.,\n\u003c/p\u003e\u003cpre\u003e filter p xs = [ x | x \u003c- xs, p x]\n\u003c/pre\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "filter",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [a]",
          "source": "src/GHC-List.html#filter",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:filter\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:filter\"]"
        },
        "index": {
          "description": "filter applied to predicate and list returns the list of those elements that satisfy the predicate i.e filter xs xs",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "filter",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "package": "base",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efind\u003c/a\u003e\u003c/code\u003e function takes a predicate and a list and returns the\n first element in the list matching the predicate, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if\n there is no such element.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "find",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e Maybe a",
          "source": "src/Data-List.html#find",
          "type": "function"
        },
        "index": {
          "description": "The find function takes predicate and list and returns the first element in the list matching the predicate or Nothing if there is no such element",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "find",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003eMaybe a",
          "package": "base",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:find"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e function takes a predicate and a list and returns\n the index of the first element in the list satisfying the predicate,\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "findIndex",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e Maybe Int",
          "source": "src/Data-List.html#findIndex",
          "type": "function"
        },
        "index": {
          "description": "The findIndex function takes predicate and list and returns the index of the first element in the list satisfying the predicate or Nothing if there is no such element",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "findIndex",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003eMaybe Int",
          "package": "base",
          "partial": "Index",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:findIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efindIndices\u003c/a\u003e\u003c/code\u003e function extends \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e, by returning the\n indices of all elements satisfying the predicate, in ascending order.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "findIndices",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [Int]",
          "source": "src/Data-List.html#findIndices",
          "type": "function"
        },
        "index": {
          "description": "The findIndices function extends findIndex by returning the indices of all elements satisfying the predicate in ascending order",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "findIndices",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[Int]",
          "package": "base",
          "partial": "Indices",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:findIndices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, applied to a binary operator, a starting value (typically\n the left-identity of the operator), and a list, reduces the list\n using the binary operator, from left to right:\n\u003c/p\u003e\u003cpre\u003e foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn\n\u003c/pre\u003e\u003cp\u003eThe list must be finite.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "foldl",
          "package": "base",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e [b] -\u003e a",
          "source": "src/GHC-List.html#foldl",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:foldl\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:foldl\"]"
        },
        "index": {
          "description": "foldl applied to binary operator starting value typically the left-identity of the operator and list reduces the list using the binary operator from left to right foldl x1 x2 xn x1 x2 xn The list must be finite",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "foldl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003e[b]-\u003ea",
          "package": "base",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003e[b]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:foldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA strict version of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "foldl'",
          "package": "base",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e [b] -\u003e a",
          "source": "src/Data-List.html#foldl%27",
          "type": "function"
        },
        "index": {
          "description": "strict version of foldl",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "foldl'",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003e[b]-\u003ea",
          "package": "base",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003e[b]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:foldl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e that has no starting value argument,\n and thus must be applied to non-empty lists.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "foldl1",
          "package": "base",
          "signature": "(a -\u003e a -\u003e a) -\u003e [a] -\u003e a",
          "source": "src/Data-List.html#foldl1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:foldl1\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:foldl1\"]"
        },
        "index": {
          "description": "foldl1 is variant of foldl that has no starting value argument and thus must be applied to non-empty lists",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "foldl1",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[a]-\u003ea",
          "package": "base",
          "signature": "(a-\u003ea-\u003ea)-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:foldl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA strict version of \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "foldl1'",
          "package": "base",
          "signature": "(a -\u003e a -\u003e a) -\u003e [a] -\u003e a",
          "source": "src/Data-List.html#foldl1%27",
          "type": "function"
        },
        "index": {
          "description": "strict version of foldl1",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "foldl1'",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[a]-\u003ea",
          "package": "base",
          "signature": "(a-\u003ea-\u003ea)-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:foldl1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e, applied to a binary operator, a starting value (typically\n the right-identity of the operator), and a list, reduces the list\n using the binary operator, from right to left:\n\u003c/p\u003e\u003cpre\u003e foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)\n\u003c/pre\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "foldr",
          "package": "base",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e [a] -\u003e b",
          "source": "src/GHC-Base.html#foldr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:foldr\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:foldr\"]"
        },
        "index": {
          "description": "foldr applied to binary operator starting value typically the right-identity of the operator and list reduces the list using the binary operator from right to left foldr x1 x2 xn x1 x2 xn",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "foldr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003e[a]-\u003eb",
          "package": "base",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003e[a]-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:foldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e that has no starting value argument,\n and thus must be applied to non-empty lists.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "foldr1",
          "package": "base",
          "signature": "(a -\u003e a -\u003e a) -\u003e [a] -\u003e a",
          "source": "src/GHC-List.html#foldr1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:foldr1\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:foldr1\"]"
        },
        "index": {
          "description": "foldr1 is variant of foldr that has no starting value argument and thus must be applied to non-empty lists",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "foldr1",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[a]-\u003ea",
          "package": "base",
          "signature": "(a-\u003ea-\u003ea)-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:foldr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egenericDrop\u003c/a\u003e\u003c/code\u003e function is an overloaded version of \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e, which\n accepts any \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e value as the number of elements to drop.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "genericDrop",
          "package": "base",
          "signature": "i -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#genericDrop",
          "type": "function"
        },
        "index": {
          "description": "The genericDrop function is an overloaded version of drop which accepts any Integral value as the number of elements to drop",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "genericDrop",
          "normalized": "a-\u003e[b]-\u003e[b]",
          "package": "base",
          "partial": "Drop",
          "signature": "i-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:genericDrop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egenericIndex\u003c/a\u003e\u003c/code\u003e function is an overloaded version of \u003ccode\u003e\u003ca\u003e!!\u003c/a\u003e\u003c/code\u003e, which\n accepts any \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e value as the index.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "genericIndex",
          "package": "base",
          "signature": "[b] -\u003e a -\u003e b",
          "source": "src/Data-List.html#genericIndex",
          "type": "function"
        },
        "index": {
          "description": "The genericIndex function is an overloaded version of which accepts any Integral value as the index",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "genericIndex",
          "normalized": "[a]-\u003eb-\u003ea",
          "package": "base",
          "partial": "Index",
          "signature": "[b]-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:genericIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egenericLength\u003c/a\u003e\u003c/code\u003e function is an overloaded version of \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e.  In\n particular, instead of returning an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e, it returns any type which is\n an instance of \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e.  It is, however, less efficient than \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "genericLength",
          "package": "base",
          "signature": "[b] -\u003e i",
          "source": "src/Data-List.html#genericLength",
          "type": "function"
        },
        "index": {
          "description": "The genericLength function is an overloaded version of length In particular instead of returning an Int it returns any type which is an instance of Num It is however less efficient than length",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "genericLength",
          "normalized": "[a]-\u003eb",
          "package": "base",
          "partial": "Length",
          "signature": "[b]-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:genericLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egenericReplicate\u003c/a\u003e\u003c/code\u003e function is an overloaded version of \u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e,\n which accepts any \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e value as the number of repetitions to make.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "genericReplicate",
          "package": "base",
          "signature": "i -\u003e a -\u003e [a]",
          "source": "src/Data-List.html#genericReplicate",
          "type": "function"
        },
        "index": {
          "description": "The genericReplicate function is an overloaded version of replicate which accepts any Integral value as the number of repetitions to make",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "genericReplicate",
          "normalized": "a-\u003eb-\u003e[b]",
          "package": "base",
          "partial": "Replicate",
          "signature": "i-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:genericReplicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egenericSplitAt\u003c/a\u003e\u003c/code\u003e function is an overloaded version of \u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e, which\n accepts any \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e value as the position at which to split.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "genericSplitAt",
          "package": "base",
          "signature": "i -\u003e [b] -\u003e ([b], [b])",
          "source": "src/Data-List.html#genericSplitAt",
          "type": "function"
        },
        "index": {
          "description": "The genericSplitAt function is an overloaded version of splitAt which accepts any Integral value as the position at which to split",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "genericSplitAt",
          "normalized": "a-\u003e[b]-\u003e([b],[b])",
          "package": "base",
          "partial": "Split At",
          "signature": "i-\u003e[b]-\u003e([b],[b])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:genericSplitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egenericTake\u003c/a\u003e\u003c/code\u003e function is an overloaded version of \u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e, which\n accepts any \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e value as the number of elements to take.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "genericTake",
          "package": "base",
          "signature": "i -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#genericTake",
          "type": "function"
        },
        "index": {
          "description": "The genericTake function is an overloaded version of take which accepts any Integral value as the number of elements to take",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "genericTake",
          "normalized": "a-\u003e[b]-\u003e[b]",
          "package": "base",
          "partial": "Take",
          "signature": "i-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:genericTake"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egroup\u003c/a\u003e\u003c/code\u003e function takes a list and returns a list of lists such\n that the concatenation of the result is equal to the argument.  Moreover,\n each sublist in the result contains only equal elements.  For example,\n\u003c/p\u003e\u003cpre\u003e group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]\n\u003c/pre\u003e\u003cp\u003eIt is a special case of \u003ccode\u003e\u003ca\u003egroupBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to supply\n their own equality test.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "group",
          "package": "base",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Data-List.html#group",
          "type": "function"
        },
        "index": {
          "description": "The group function takes list and returns list of lists such that the concatenation of the result is equal to the argument Moreover each sublist in the result contains only equal elements For example group Mississippi ss ss pp It is special case of groupBy which allows the programmer to supply their own equality test",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "group",
          "normalized": "[a]-\u003e[[a]]",
          "package": "base",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:group"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egroupBy\u003c/a\u003e\u003c/code\u003e function is the non-overloaded version of \u003ccode\u003e\u003ca\u003egroup\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "groupBy",
          "package": "base",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
          "source": "src/Data-List.html#groupBy",
          "type": "function"
        },
        "index": {
          "description": "The groupBy function is the non-overloaded version of group",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "groupBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "package": "base",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:groupBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the first element of a list, which must be non-empty.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "head",
          "package": "base",
          "signature": "[a] -\u003e a",
          "source": "src/GHC-List.html#head",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:head\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:head\"]"
        },
        "index": {
          "description": "Extract the first element of list which must be non-empty",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "head",
          "normalized": "[a]-\u003ea",
          "package": "base",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn all the elements of a list except the last one.\n The list must be non-empty.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "init",
          "package": "base",
          "signature": "[a] -\u003e [a]",
          "source": "src/GHC-List.html#init",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:init\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:init\"]"
        },
        "index": {
          "description": "Return all the elements of list except the last one The list must be non-empty",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "init",
          "normalized": "[a]-\u003e[a]",
          "package": "base",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:init"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003einits\u003c/a\u003e\u003c/code\u003e function returns all initial segments of the argument,\n shortest first.  For example,\n\u003c/p\u003e\u003cpre\u003e inits \"abc\" == [\"\",\"a\",\"ab\",\"abc\"]\n\u003c/pre\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ca\u003einits\u003c/a\u003e\u003c/code\u003e has the following strictness property:\n \u003ccode\u003einits _|_ = [] : _|_\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "inits",
          "package": "base",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Data-List.html#inits",
          "type": "function"
        },
        "index": {
          "description": "The inits function returns all initial segments of the argument shortest first For example inits abc ab abc Note that inits has the following strictness property inits",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "inits",
          "normalized": "[a]-\u003e[[a]]",
          "package": "base",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:inits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e function takes an element and a list and inserts the\n element into the list at the first position where it is less\n than or equal to the next element.  In particular, if the list\n is sorted before the call, the result will also be sorted.\n It is a special case of \u003ccode\u003e\u003ca\u003einsertBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to\n supply their own comparison function.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "insert",
          "package": "base",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#insert",
          "type": "function"
        },
        "index": {
          "description": "The insert function takes an element and list and inserts the element into the list at the first position where it is less than or equal to the next element In particular if the list is sorted before the call the result will also be sorted It is special case of insertBy which allows the programmer to supply their own comparison function",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "insert",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "base",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe non-overloaded version of \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "insertBy",
          "package": "base",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e a -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#insertBy",
          "type": "function"
        },
        "index": {
          "description": "The non-overloaded version of insert",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "insertBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003ea-\u003e[a]-\u003e[a]",
          "package": "base",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003ea-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:insertBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eintercalate\u003c/a\u003e\u003c/code\u003e \u003ccode\u003exs xss\u003c/code\u003e is equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003econcat\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eintersperse\u003c/a\u003e\u003c/code\u003e xs xss))\u003c/code\u003e.\n It inserts the list \u003ccode\u003exs\u003c/code\u003e in between the lists in \u003ccode\u003exss\u003c/code\u003e and concatenates the\n result.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "intercalate",
          "package": "base",
          "signature": "[a] -\u003e [[a]] -\u003e [a]",
          "source": "src/Data-List.html#intercalate",
          "type": "function"
        },
        "index": {
          "description": "intercalate xs xss is equivalent to concat intersperse xs xss It inserts the list xs in between the lists in xss and concatenates the result",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "intercalate",
          "normalized": "[a]-\u003e[[a]]-\u003e[a]",
          "package": "base",
          "signature": "[a]-\u003e[[a]]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:intercalate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eintersect\u003c/a\u003e\u003c/code\u003e function takes the list intersection of two lists.\n For example,\n\u003c/p\u003e\u003cpre\u003e [1,2,3,4] `intersect` [2,4,6,8] == [2,4]\n\u003c/pre\u003e\u003cp\u003eIf the first list contains duplicates, so will the result.\n\u003c/p\u003e\u003cpre\u003e [1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]\n\u003c/pre\u003e\u003cp\u003eIt is a special case of \u003ccode\u003e\u003ca\u003eintersectBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to\n supply their own equality test. If the element is found in both the first\n and the second list, the element from the first list will be used.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "intersect",
          "package": "base",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#intersect",
          "type": "function"
        },
        "index": {
          "description": "The intersect function takes the list intersection of two lists For example intersect If the first list contains duplicates so will the result intersect It is special case of intersectBy which allows the programmer to supply their own equality test If the element is found in both the first and the second list the element from the first list will be used",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "intersect",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "base",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:intersect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eintersectBy\u003c/a\u003e\u003c/code\u003e function is the non-overloaded version of \u003ccode\u003e\u003ca\u003eintersect\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "intersectBy",
          "package": "base",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#intersectBy",
          "type": "function"
        },
        "index": {
          "description": "The intersectBy function is the non-overloaded version of intersect",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "intersectBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "base",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:intersectBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eintersperse\u003c/a\u003e\u003c/code\u003e function takes an element and a list and\n `intersperses' that element between the elements of the list.\n For example,\n\u003c/p\u003e\u003cpre\u003e intersperse ',' \"abcde\" == \"a,b,c,d,e\"\n\u003c/pre\u003e",
          "module": "Data.List",
          "name": "intersperse",
          "package": "base",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#intersperse",
          "type": "function"
        },
        "index": {
          "description": "The intersperse function takes an element and list and intersperses that element between the elements of the list For example intersperse abcde",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "intersperse",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "base",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:intersperse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eisInfixOf\u003c/a\u003e\u003c/code\u003e function takes two lists and returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n iff the first list is contained, wholly and intact,\n anywhere within the second.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003eisInfixOf \"Haskell\" \"I really like Haskell.\" == True\nisInfixOf \"Ial\" \"I really like Haskell.\" == False\n\u003c/pre\u003e",
          "module": "Data.List",
          "name": "isInfixOf",
          "package": "base",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/Data-List.html#isInfixOf",
          "type": "function"
        },
        "index": {
          "description": "The isInfixOf function takes two lists and returns True iff the first list is contained wholly and intact anywhere within the second Example isInfixOf Haskell really like Haskell True isInfixOf Ial really like Haskell False",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "isInfixOf",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "base",
          "partial": "Infix Of",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:isInfixOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eisPrefixOf\u003c/a\u003e\u003c/code\u003e function takes two lists and returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n iff the first list is a prefix of the second.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "isPrefixOf",
          "package": "base",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/Data-List.html#isPrefixOf",
          "type": "function"
        },
        "index": {
          "description": "The isPrefixOf function takes two lists and returns True iff the first list is prefix of the second",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "isPrefixOf",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "base",
          "partial": "Prefix Of",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:isPrefixOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eisSuffixOf\u003c/a\u003e\u003c/code\u003e function takes two lists and returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n iff the first list is a suffix of the second.\n Both lists must be finite.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "isSuffixOf",
          "package": "base",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/Data-List.html#isSuffixOf",
          "type": "function"
        },
        "index": {
          "description": "The isSuffixOf function takes two lists and returns True iff the first list is suffix of the second Both lists must be finite",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "isSuffixOf",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "base",
          "partial": "Suffix Of",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:isSuffixOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eiterate\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ef x\u003c/code\u003e returns an infinite list of repeated applications\n of \u003ccode\u003ef\u003c/code\u003e to \u003ccode\u003ex\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e iterate f x == [x, f x, f (f x), ...]\n\u003c/pre\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "iterate",
          "package": "base",
          "signature": "(a -\u003e a) -\u003e a -\u003e [a]",
          "source": "src/GHC-List.html#iterate",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:iterate\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:iterate\"]"
        },
        "index": {
          "description": "iterate returns an infinite list of repeated applications of to iterate",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "iterate",
          "normalized": "(a-\u003ea)-\u003ea-\u003e[a]",
          "package": "base",
          "signature": "(a-\u003ea)-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:iterate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the last element of a list, which must be finite and non-empty.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "last",
          "package": "base",
          "signature": "[a] -\u003e a",
          "source": "src/GHC-List.html#last",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:last\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:last\"]"
        },
        "index": {
          "description": "Extract the last element of list which must be finite and non-empty",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "last",
          "normalized": "[a]-\u003ea",
          "package": "base",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:last"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e returns the length of a finite list as an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n It is an instance of the more general \u003ccode\u003e\u003ca\u003egenericLength\u003c/a\u003e\u003c/code\u003e,\n the result type of which may be any kind of number.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "length",
          "package": "base",
          "signature": "[a] -\u003e Int",
          "source": "src/GHC-List.html#length",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:length\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:length\"]"
        },
        "index": {
          "description": "length returns the length of finite list as an Int It is an instance of the more general genericLength the result type of which may be any kind of number",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "length",
          "normalized": "[a]-\u003eInt",
          "package": "base",
          "signature": "[a]-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e breaks a string up into a list of strings at newline\n characters.  The resulting strings do not contain newlines.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Data.String\",\"Prelude\"]",
          "name": "lines",
          "package": "base",
          "signature": "String -\u003e [String]",
          "source": "src/Data-List.html#lines",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:lines\",\"http://hackage.haskell.org/package/base/docs/Data-String.html#v:lines\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:lines\"]"
        },
        "index": {
          "description": "lines breaks string up into list of strings at newline characters The resulting strings do not contain newlines",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "lines",
          "normalized": "String-\u003e[String]",
          "package": "base",
          "signature": "String-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:lines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ekey assocs\u003c/code\u003e looks up a key in an association list.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "lookup",
          "package": "base",
          "signature": "a -\u003e [(a, b)] -\u003e Maybe b",
          "source": "src/GHC-List.html#lookup",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:lookup\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:lookup\"]"
        },
        "index": {
          "description": "lookup key assocs looks up key in an association list",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "lookup",
          "normalized": "a-\u003e[(a,b)]-\u003eMaybe b",
          "package": "base",
          "signature": "a-\u003e[(a,b)]-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ef xs\u003c/code\u003e is the list obtained by applying \u003ccode\u003ef\u003c/code\u003e to each element\n of \u003ccode\u003exs\u003c/code\u003e, i.e.,\n\u003c/p\u003e\u003cpre\u003e map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]\n map f [x1, x2, ...] == [f x1, f x2, ...]\n\u003c/pre\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "map",
          "package": "base",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e [b]",
          "source": "src/GHC-Base.html#map",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:map\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:map\"]"
        },
        "index": {
          "description": "map xs is the list obtained by applying to each element of xs i.e map x1 x2 xn x1 x2 xn map x1 x2 x1 x2",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003e[b]",
          "package": "base",
          "signature": "(a-\u003eb)-\u003e[a]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e function behaves like a combination of \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e; it applies a function to each element of a list, passing\n an accumulating parameter from left to right, and returning a final\n value of this accumulator together with the new list.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "mapAccumL",
          "package": "base",
          "signature": "(acc -\u003e x -\u003e (acc, y)) -\u003e acc -\u003e [x] -\u003e (acc, [y])",
          "source": "src/Data-List.html#mapAccumL",
          "type": "function"
        },
        "index": {
          "description": "The mapAccumL function behaves like combination of map and foldl it applies function to each element of list passing an accumulating parameter from left to right and returning final value of this accumulator together with the new list",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "mapAccumL",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003e[b]-\u003e(a,[c])",
          "package": "base",
          "partial": "Accum",
          "signature": "(acc-\u003ex-\u003e(acc,y))-\u003eacc-\u003e[x]-\u003e(acc,[y])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:mapAccumL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emapAccumR\u003c/a\u003e\u003c/code\u003e function behaves like a combination of \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e; it applies a function to each element of a list, passing\n an accumulating parameter from right to left, and returning a final\n value of this accumulator together with the new list.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "mapAccumR",
          "package": "base",
          "signature": "(acc -\u003e x -\u003e (acc, y)) -\u003e acc -\u003e [x] -\u003e (acc, [y])",
          "source": "src/Data-List.html#mapAccumR",
          "type": "function"
        },
        "index": {
          "description": "The mapAccumR function behaves like combination of map and foldr it applies function to each element of list passing an accumulating parameter from right to left and returning final value of this accumulator together with the new list",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "mapAccumR",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003e[b]-\u003e(a,[c])",
          "package": "base",
          "partial": "Accum",
          "signature": "(acc-\u003ex-\u003e(acc,y))-\u003eacc-\u003e[x]-\u003e(acc,[y])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:mapAccumR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emaximum\u003c/a\u003e\u003c/code\u003e returns the maximum value from a list,\n which must be non-empty, finite, and of an ordered type.\n It is a special case of \u003ccode\u003e\u003ca\u003emaximumBy\u003c/a\u003e\u003c/code\u003e, which allows the\n programmer to supply their own comparison function.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "maximum",
          "package": "base",
          "signature": "[a] -\u003e a",
          "source": "src/Data-List.html#maximum",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:maximum\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:maximum\"]"
        },
        "index": {
          "description": "maximum returns the maximum value from list which must be non-empty finite and of an ordered type It is special case of maximumBy which allows the programmer to supply their own comparison function",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "maximum",
          "normalized": "[a]-\u003ea",
          "package": "base",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:maximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emaximumBy\u003c/a\u003e\u003c/code\u003e function takes a comparison function and a list\n and returns the greatest element of the list by the comparison function.\n The list must be finite and non-empty.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "maximumBy",
          "package": "base",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e [a] -\u003e a",
          "source": "src/Data-List.html#maximumBy",
          "type": "function"
        },
        "index": {
          "description": "The maximumBy function takes comparison function and list and returns the greatest element of the list by the comparison function The list must be finite and non-empty",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "maximumBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003ea",
          "package": "base",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:maximumBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eminimum\u003c/a\u003e\u003c/code\u003e returns the minimum value from a list,\n which must be non-empty, finite, and of an ordered type.\n It is a special case of \u003ccode\u003e\u003ca\u003eminimumBy\u003c/a\u003e\u003c/code\u003e, which allows the\n programmer to supply their own comparison function.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "minimum",
          "package": "base",
          "signature": "[a] -\u003e a",
          "source": "src/Data-List.html#minimum",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:minimum\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:minimum\"]"
        },
        "index": {
          "description": "minimum returns the minimum value from list which must be non-empty finite and of an ordered type It is special case of minimumBy which allows the programmer to supply their own comparison function",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "minimum",
          "normalized": "[a]-\u003ea",
          "package": "base",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:minimum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eminimumBy\u003c/a\u003e\u003c/code\u003e function takes a comparison function and a list\n and returns the least element of the list by the comparison function.\n The list must be finite and non-empty.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "minimumBy",
          "package": "base",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e [a] -\u003e a",
          "source": "src/Data-List.html#minimumBy",
          "type": "function"
        },
        "index": {
          "description": "The minimumBy function takes comparison function and list and returns the least element of the list by the comparison function The list must be finite and non-empty",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "minimumBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003ea",
          "package": "base",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:minimumBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003enotElem\u003c/a\u003e\u003c/code\u003e is the negation of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "notElem",
          "package": "base",
          "signature": "a -\u003e [a] -\u003e Bool",
          "source": "src/GHC-List.html#notElem",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:notElem\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:notElem\"]"
        },
        "index": {
          "description": "notElem is the negation of elem",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "notElem",
          "normalized": "a-\u003e[a]-\u003eBool",
          "package": "base",
          "partial": "Elem",
          "signature": "a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:notElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n^2)\u003c/em\u003e. The \u003ccode\u003e\u003ca\u003enub\u003c/a\u003e\u003c/code\u003e function removes duplicate elements from a list.\n In particular, it keeps only the first occurrence of each element.\n (The name \u003ccode\u003e\u003ca\u003enub\u003c/a\u003e\u003c/code\u003e means `essence'.)\n It is a special case of \u003ccode\u003e\u003ca\u003enubBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to supply\n their own equality test.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "nub",
          "package": "base",
          "signature": "[a] -\u003e [a]",
          "source": "src/Data-List.html#nub",
          "type": "function"
        },
        "index": {
          "description": "The nub function removes duplicate elements from list In particular it keeps only the first occurrence of each element The name nub means essence It is special case of nubBy which allows the programmer to supply their own equality test",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "nub",
          "normalized": "[a]-\u003e[a]",
          "package": "base",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:nub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003enubBy\u003c/a\u003e\u003c/code\u003e function behaves just like \u003ccode\u003e\u003ca\u003enub\u003c/a\u003e\u003c/code\u003e, except it uses a\n user-supplied equality predicate instead of the overloaded \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e\n function.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "nubBy",
          "package": "base",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#nubBy",
          "type": "function"
        },
        "index": {
          "description": "The nubBy function behaves just like nub except it uses user-supplied equality predicate instead of the overloaded function",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "nubBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]",
          "package": "base",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:nubBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether a list is empty.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "null",
          "package": "base",
          "signature": "[a] -\u003e Bool",
          "source": "src/GHC-List.html#null",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:null\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:null\"]"
        },
        "index": {
          "description": "Test whether list is empty",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "null",
          "normalized": "[a]-\u003eBool",
          "package": "base",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eor\u003c/a\u003e\u003c/code\u003e returns the disjunction of a Boolean list.  For the result to be\n \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e, the list must be finite; \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, however, results from a \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n value at a finite index of a finite or infinite list.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "or",
          "package": "base",
          "signature": "[Bool] -\u003e Bool",
          "source": "src/GHC-List.html#or",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:or\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:or\"]"
        },
        "index": {
          "description": "or returns the disjunction of Boolean list For the result to be False the list must be finite True however results from True value at finite index of finite or infinite list",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "or",
          "normalized": "[Bool]-\u003eBool",
          "package": "base",
          "signature": "[Bool]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e function takes a predicate a list and returns\n the pair of lists of elements which do and do not satisfy the\n predicate, respectively; i.e.,\n\u003c/p\u003e\u003cpre\u003e partition p xs == (filter p xs, filter (not . p) xs)\n\u003c/pre\u003e",
          "module": "Data.List",
          "name": "partition",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e ([a], [a])",
          "source": "src/Data-List.html#partition",
          "type": "function"
        },
        "index": {
          "description": "The partition function takes predicate list and returns the pair of lists of elements which do and do not satisfy the predicate respectively i.e partition xs filter xs filter not xs",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "partition",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "package": "base",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:partition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003epermutations\u003c/a\u003e\u003c/code\u003e function returns the list of all permutations of the argument.\n\u003c/p\u003e\u003cpre\u003e permutations \"abc\" == [\"abc\",\"bac\",\"cba\",\"bca\",\"cab\",\"acb\"]\n\u003c/pre\u003e",
          "module": "Data.List",
          "name": "permutations",
          "package": "base",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Data-List.html#permutations",
          "type": "function"
        },
        "index": {
          "description": "The permutations function returns the list of all permutations of the argument permutations abc abc bac cba bca cab acb",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "permutations",
          "normalized": "[a]-\u003e[[a]]",
          "package": "base",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:permutations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eproduct\u003c/a\u003e\u003c/code\u003e function computes the product of a finite list of numbers.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "product",
          "package": "base",
          "signature": "[a] -\u003e a",
          "source": "src/Data-List.html#product",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:product\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:product\"]"
        },
        "index": {
          "description": "The product function computes the product of finite list of numbers",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "product",
          "normalized": "[a]-\u003ea",
          "package": "base",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:product"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003erepeat\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ex\u003c/code\u003e is an infinite list, with \u003ccode\u003ex\u003c/code\u003e the value of every element.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "repeat",
          "package": "base",
          "signature": "a -\u003e [a]",
          "source": "src/GHC-List.html#repeat",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:repeat\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:repeat\"]"
        },
        "index": {
          "description": "repeat is an infinite list with the value of every element",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "repeat",
          "normalized": "a-\u003e[a]",
          "package": "base",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en x\u003c/code\u003e is a list of length \u003ccode\u003en\u003c/code\u003e with \u003ccode\u003ex\u003c/code\u003e the value of\n every element.\n It is an instance of the more general \u003ccode\u003e\u003ca\u003egenericReplicate\u003c/a\u003e\u003c/code\u003e,\n in which \u003ccode\u003en\u003c/code\u003e may be of any integral type.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "replicate",
          "package": "base",
          "signature": "Int -\u003e a -\u003e [a]",
          "source": "src/GHC-List.html#replicate",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:replicate\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:replicate\"]"
        },
        "index": {
          "description": "replicate is list of length with the value of every element It is an instance of the more general genericReplicate in which may be of any integral type",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "replicate",
          "normalized": "Int-\u003ea-\u003e[a]",
          "package": "base",
          "signature": "Int-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e \u003ccode\u003exs\u003c/code\u003e returns the elements of \u003ccode\u003exs\u003c/code\u003e in reverse order.\n \u003ccode\u003exs\u003c/code\u003e must be finite.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "reverse",
          "package": "base",
          "signature": "[a] -\u003e [a]",
          "source": "src/GHC-List.html#reverse",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:reverse\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:reverse\"]"
        },
        "index": {
          "description": "reverse xs returns the elements of xs in reverse order xs must be finite",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "reverse",
          "normalized": "[a]-\u003e[a]",
          "package": "base",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e is similar to \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, but returns a list of successive\n reduced values from the left:\n\u003c/p\u003e\u003cpre\u003e scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]\n\u003c/pre\u003e\u003cp\u003eNote that\n\u003c/p\u003e\u003cpre\u003e last (scanl f z xs) == foldl f z xs.\n\u003c/pre\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "scanl",
          "package": "base",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e [b] -\u003e [a]",
          "source": "src/GHC-List.html#scanl",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:scanl\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:scanl\"]"
        },
        "index": {
          "description": "scanl is similar to foldl but returns list of successive reduced values from the left scanl x1 x2 x1 x1 x2 Note that last scanl xs foldl xs",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "scanl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003e[b]-\u003e[a]",
          "package": "base",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003e[b]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:scanl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanl1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e that has no starting value argument:\n\u003c/p\u003e\u003cpre\u003e scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]\n\u003c/pre\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "scanl1",
          "package": "base",
          "signature": "(a -\u003e a -\u003e a) -\u003e [a] -\u003e [a]",
          "source": "src/GHC-List.html#scanl1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:scanl1\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:scanl1\"]"
        },
        "index": {
          "description": "scanl1 is variant of scanl that has no starting value argument scanl1 x1 x2 x1 x1 x2",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "scanl1",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[a]-\u003e[a]",
          "package": "base",
          "signature": "(a-\u003ea-\u003ea)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:scanl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanr\u003c/a\u003e\u003c/code\u003e is the right-to-left dual of \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e.\n Note that\n\u003c/p\u003e\u003cpre\u003e head (scanr f z xs) == foldr f z xs.\n\u003c/pre\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "scanr",
          "package": "base",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e [a] -\u003e [b]",
          "source": "src/GHC-List.html#scanr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:scanr\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:scanr\"]"
        },
        "index": {
          "description": "scanr is the right-to-left dual of scanl Note that head scanr xs foldr xs",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "scanr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003e[a]-\u003e[b]",
          "package": "base",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003e[a]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:scanr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanr1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003escanr\u003c/a\u003e\u003c/code\u003e that has no starting value argument.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "scanr1",
          "package": "base",
          "signature": "(a -\u003e a -\u003e a) -\u003e [a] -\u003e [a]",
          "source": "src/GHC-List.html#scanr1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:scanr1\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:scanr1\"]"
        },
        "index": {
          "description": "scanr1 is variant of scanr that has no starting value argument",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "scanr1",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[a]-\u003e[a]",
          "package": "base",
          "signature": "(a-\u003ea-\u003ea)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:scanr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003esort\u003c/a\u003e\u003c/code\u003e function implements a stable sorting algorithm.\n It is a special case of \u003ccode\u003e\u003ca\u003esortBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to supply\n their own comparison function.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "sort",
          "package": "base",
          "signature": "[a] -\u003e [a]",
          "source": "src/Data-List.html#sort",
          "type": "function"
        },
        "index": {
          "description": "The sort function implements stable sorting algorithm It is special case of sortBy which allows the programmer to supply their own comparison function",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "sort",
          "normalized": "[a]-\u003e[a]",
          "package": "base",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:sort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003esortBy\u003c/a\u003e\u003c/code\u003e function is the non-overloaded version of \u003ccode\u003e\u003ca\u003esort\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "sortBy",
          "package": "base",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#sortBy",
          "type": "function"
        },
        "index": {
          "description": "The sortBy function is the non-overloaded version of sort",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "sortBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003e[a]",
          "package": "base",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:sortBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e, applied to a predicate \u003ccode\u003ep\u003c/code\u003e and a list \u003ccode\u003exs\u003c/code\u003e, returns a tuple where\n first element is longest prefix (possibly empty) of \u003ccode\u003exs\u003c/code\u003e of elements that\n satisfy \u003ccode\u003ep\u003c/code\u003e and second element is the remainder of the list:\n\u003c/p\u003e\u003cpre\u003e span (\u003c 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])\n span (\u003c 9) [1,2,3] == ([1,2,3],[])\n span (\u003c 0) [1,2,3] == ([],[1,2,3])\n\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e is equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e p xs, \u003ccode\u003e\u003ca\u003edropWhile\u003c/a\u003e\u003c/code\u003e p xs)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "span",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e ([a], [a])",
          "source": "src/GHC-List.html#span",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:span\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:span\"]"
        },
        "index": {
          "description": "span applied to predicate and list xs returns tuple where first element is longest prefix possibly empty of xs of elements that satisfy and second element is the remainder of the list span span span span xs is equivalent to takeWhile xs dropWhile xs",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "span",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "package": "base",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:span"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en xs\u003c/code\u003e returns a tuple where first element is \u003ccode\u003exs\u003c/code\u003e prefix of\n length \u003ccode\u003en\u003c/code\u003e and second element is the remainder of the list:\n\u003c/p\u003e\u003cpre\u003e splitAt 6 \"Hello World!\" == (\"Hello \",\"World!\")\n splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])\n splitAt 1 [1,2,3] == ([1],[2,3])\n splitAt 3 [1,2,3] == ([1,2,3],[])\n splitAt 4 [1,2,3] == ([1,2,3],[])\n splitAt 0 [1,2,3] == ([],[1,2,3])\n splitAt (-1) [1,2,3] == ([],[1,2,3])\n\u003c/pre\u003e\u003cp\u003eIt is equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n xs, \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e n xs)\u003c/code\u003e when \u003ccode\u003en\u003c/code\u003e is not \u003ccode\u003e_|_\u003c/code\u003e\n (\u003ccode\u003esplitAt _|_ xs = _|_\u003c/code\u003e).\n \u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e is an instance of the more general \u003ccode\u003e\u003ca\u003egenericSplitAt\u003c/a\u003e\u003c/code\u003e,\n in which \u003ccode\u003en\u003c/code\u003e may be of any integral type.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "splitAt",
          "package": "base",
          "signature": "Int -\u003e [a] -\u003e ([a], [a])",
          "source": "src/GHC-List.html#splitAt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:splitAt\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:splitAt\"]"
        },
        "index": {
          "description": "splitAt xs returns tuple where first element is xs prefix of length and second element is the remainder of the list splitAt Hello World Hello World splitAt splitAt splitAt splitAt splitAt splitAt It is equivalent to take xs drop xs when is not splitAt xs splitAt is an instance of the more general genericSplitAt in which may be of any integral type",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "splitAt",
          "normalized": "Int-\u003e[a]-\u003e([a],[a])",
          "package": "base",
          "partial": "At",
          "signature": "Int-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:splitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003estripPrefix\u003c/a\u003e\u003c/code\u003e function drops the given prefix from a list.\n It returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the list did not start with the prefix\n given, or \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the list after the prefix, if it does.\n\u003c/p\u003e\u003cpre\u003e stripPrefix \"foo\" \"foobar\" == Just \"bar\"\n stripPrefix \"foo\" \"foo\" == Just \"\"\n stripPrefix \"foo\" \"barfoo\" == Nothing\n stripPrefix \"foo\" \"barfoobaz\" == Nothing\n\u003c/pre\u003e",
          "module": "Data.List",
          "name": "stripPrefix",
          "package": "base",
          "signature": "[a] -\u003e [a] -\u003e Maybe [a]",
          "source": "src/Data-List.html#stripPrefix",
          "type": "function"
        },
        "index": {
          "description": "The stripPrefix function drops the given prefix from list It returns Nothing if the list did not start with the prefix given or Just the list after the prefix if it does stripPrefix foo foobar Just bar stripPrefix foo foo Just stripPrefix foo barfoo Nothing stripPrefix foo barfoobaz Nothing",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "stripPrefix",
          "normalized": "[a]-\u003e[a]-\u003eMaybe[a]",
          "package": "base",
          "partial": "Prefix",
          "signature": "[a]-\u003e[a]-\u003eMaybe[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:stripPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003esubsequences\u003c/a\u003e\u003c/code\u003e function returns the list of all subsequences of the argument.\n\u003c/p\u003e\u003cpre\u003e subsequences \"abc\" == [\"\",\"a\",\"b\",\"ab\",\"c\",\"ac\",\"bc\",\"abc\"]\n\u003c/pre\u003e",
          "module": "Data.List",
          "name": "subsequences",
          "package": "base",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Data-List.html#subsequences",
          "type": "function"
        },
        "index": {
          "description": "The subsequences function returns the list of all subsequences of the argument subsequences abc ab ac bc abc",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "subsequences",
          "normalized": "[a]-\u003e[[a]]",
          "package": "base",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:subsequences"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003esum\u003c/a\u003e\u003c/code\u003e function computes the sum of a finite list of numbers.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "sum",
          "package": "base",
          "signature": "[a] -\u003e a",
          "source": "src/Data-List.html#sum",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:sum\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:sum\"]"
        },
        "index": {
          "description": "The sum function computes the sum of finite list of numbers",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "sum",
          "normalized": "[a]-\u003ea",
          "package": "base",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the elements after the head of a list, which must be non-empty.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "tail",
          "package": "base",
          "signature": "[a] -\u003e [a]",
          "source": "src/GHC-List.html#tail",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:tail\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:tail\"]"
        },
        "index": {
          "description": "Extract the elements after the head of list which must be non-empty",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "tail",
          "normalized": "[a]-\u003e[a]",
          "package": "base",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:tail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003etails\u003c/a\u003e\u003c/code\u003e function returns all final segments of the argument,\n longest first.  For example,\n\u003c/p\u003e\u003cpre\u003e tails \"abc\" == [\"abc\", \"bc\", \"c\",\"\"]\n\u003c/pre\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ca\u003etails\u003c/a\u003e\u003c/code\u003e has the following strictness property:\n \u003ccode\u003etails _|_ = _|_ : _|_\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "tails",
          "package": "base",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Data-List.html#tails",
          "type": "function"
        },
        "index": {
          "description": "The tails function returns all final segments of the argument longest first For example tails abc abc bc Note that tails has the following strictness property tails",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "tails",
          "normalized": "[a]-\u003e[[a]]",
          "package": "base",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:tails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en\u003c/code\u003e, applied to a list \u003ccode\u003exs\u003c/code\u003e, returns the prefix of \u003ccode\u003exs\u003c/code\u003e\n of length \u003ccode\u003en\u003c/code\u003e, or \u003ccode\u003exs\u003c/code\u003e itself if \u003ccode\u003en \u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e xs\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e take 5 \"Hello World!\" == \"Hello\"\n take 3 [1,2,3,4,5] == [1,2,3]\n take 3 [1,2] == [1,2]\n take 3 [] == []\n take (-1) [1,2] == []\n take 0 [1,2] == []\n\u003c/pre\u003e\u003cp\u003eIt is an instance of the more general \u003ccode\u003e\u003ca\u003egenericTake\u003c/a\u003e\u003c/code\u003e,\n in which \u003ccode\u003en\u003c/code\u003e may be of any integral type.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "take",
          "package": "base",
          "signature": "Int -\u003e [a] -\u003e [a]",
          "source": "src/GHC-List.html#take",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:take\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:take\"]"
        },
        "index": {
          "description": "take applied to list xs returns the prefix of xs of length or xs itself if length xs take Hello World Hello take take take take take It is an instance of the more general genericTake in which may be of any integral type",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "take",
          "normalized": "Int-\u003e[a]-\u003e[a]",
          "package": "base",
          "signature": "Int-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e, applied to a predicate \u003ccode\u003ep\u003c/code\u003e and a list \u003ccode\u003exs\u003c/code\u003e, returns the\n longest prefix (possibly empty) of \u003ccode\u003exs\u003c/code\u003e of elements that satisfy \u003ccode\u003ep\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e takeWhile (\u003c 3) [1,2,3,4,1,2,3,4] == [1,2]\n takeWhile (\u003c 9) [1,2,3] == [1,2,3]\n takeWhile (\u003c 0) [1,2,3] == []\n\u003c/pre\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "takeWhile",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [a]",
          "source": "src/GHC-List.html#takeWhile",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:takeWhile\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:takeWhile\"]"
        },
        "index": {
          "description": "takeWhile applied to predicate and list xs returns the longest prefix possibly empty of xs of elements that satisfy takeWhile takeWhile takeWhile",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "takeWhile",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "package": "base",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:takeWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003etranspose\u003c/a\u003e\u003c/code\u003e function transposes the rows and columns of its argument.\n For example,\n\u003c/p\u003e\u003cpre\u003e transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]\n\u003c/pre\u003e",
          "module": "Data.List",
          "name": "transpose",
          "package": "base",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Data-List.html#transpose",
          "type": "function"
        },
        "index": {
          "description": "The transpose function transposes the rows and columns of its argument For example transpose",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "transpose",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "base",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e function is a `dual' to \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e: while \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e\n reduces a list to a summary value, \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e builds a list from\n a seed value.  The function takes the element and returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if it is done producing the list or returns \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e(a,b)\u003c/code\u003e, in which\n case, \u003ccode\u003ea\u003c/code\u003e is a prepended to the list and \u003ccode\u003eb\u003c/code\u003e is used as the next\n element in a recursive call.  For example,\n\u003c/p\u003e\u003cpre\u003e iterate f == unfoldr (\\x -\u003e Just (x, f x))\n\u003c/pre\u003e\u003cp\u003eIn some cases, \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e can undo a \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e operation:\n\u003c/p\u003e\u003cpre\u003e unfoldr f' (foldr f z xs) == xs\n\u003c/pre\u003e\u003cp\u003eif the following holds:\n\u003c/p\u003e\u003cpre\u003e f' (f x y) = Just (x,y)\n f' z       = Nothing\n\u003c/pre\u003e\u003cp\u003eA simple use of unfoldr:\n\u003c/p\u003e\u003cpre\u003e unfoldr (\\b -\u003e if b == 0 then Nothing else Just (b, b-1)) 10\n  [10,9,8,7,6,5,4,3,2,1]\n\u003c/pre\u003e",
          "module": "Data.List",
          "name": "unfoldr",
          "package": "base",
          "signature": "(b -\u003e Maybe (a, b)) -\u003e b -\u003e [a]",
          "source": "src/Data-List.html#unfoldr",
          "type": "function"
        },
        "index": {
          "description": "The unfoldr function is dual to foldr while foldr reduces list to summary value unfoldr builds list from seed value The function takes the element and returns Nothing if it is done producing the list or returns Just in which case is prepended to the list and is used as the next element in recursive call For example iterate unfoldr Just In some cases unfoldr can undo foldr operation unfoldr foldr xs xs if the following holds Just Nothing simple use of unfoldr unfoldr if then Nothing else Just b-1",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "unfoldr",
          "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003e[b]",
          "package": "base",
          "signature": "(b-\u003eMaybe(a,b))-\u003eb-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:unfoldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e function returns the list union of the two lists.\n For example,\n\u003c/p\u003e\u003cpre\u003e \"dog\" `union` \"cow\" == \"dogcw\"\n\u003c/pre\u003e\u003cp\u003eDuplicates, and elements of the first list, are removed from the\n the second list, but if the first list contains duplicates, so will\n the result.\n It is a special case of \u003ccode\u003e\u003ca\u003eunionBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to supply\n their own equality test.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "union",
          "package": "base",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#union",
          "type": "function"
        },
        "index": {
          "description": "The union function returns the list union of the two lists For example dog union cow dogcw Duplicates and elements of the first list are removed from the the second list but if the first list contains duplicates so will the result It is special case of unionBy which allows the programmer to supply their own equality test",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "union",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "base",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunionBy\u003c/a\u003e\u003c/code\u003e function is the non-overloaded version of \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "unionBy",
          "package": "base",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [a] -\u003e [a]",
          "source": "src/Data-List.html#unionBy",
          "type": "function"
        },
        "index": {
          "description": "The unionBy function is the non-overloaded version of union",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "unionBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "base",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:unionBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunlines\u003c/a\u003e\u003c/code\u003e is an inverse operation to \u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e.\n It joins lines, after appending a terminating newline to each.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Data.String\",\"Prelude\"]",
          "name": "unlines",
          "package": "base",
          "signature": "[String] -\u003e String",
          "source": "src/Data-List.html#unlines",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:unlines\",\"http://hackage.haskell.org/package/base/docs/Data-String.html#v:unlines\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:unlines\"]"
        },
        "index": {
          "description": "unlines is an inverse operation to lines It joins lines after appending terminating newline to each",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "unlines",
          "normalized": "[String]-\u003eString",
          "package": "base",
          "signature": "[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:unlines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunwords\u003c/a\u003e\u003c/code\u003e is an inverse operation to \u003ccode\u003e\u003ca\u003ewords\u003c/a\u003e\u003c/code\u003e.\n It joins words with separating spaces.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Data.String\",\"Prelude\"]",
          "name": "unwords",
          "package": "base",
          "signature": "[String] -\u003e String",
          "source": "src/Data-List.html#unwords",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:unwords\",\"http://hackage.haskell.org/package/base/docs/Data-String.html#v:unwords\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:unwords\"]"
        },
        "index": {
          "description": "unwords is an inverse operation to words It joins words with separating spaces",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "unwords",
          "normalized": "[String]-\u003eString",
          "package": "base",
          "signature": "[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:unwords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e transforms a list of pairs into a list of first components\n and a list of second components.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "unzip",
          "package": "base",
          "signature": "[(a, b)] -\u003e ([a], [b])",
          "source": "src/GHC-List.html#unzip",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:unzip\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:unzip\"]"
        },
        "index": {
          "description": "unzip transforms list of pairs into list of first components and list of second components",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "unzip",
          "normalized": "[(a,b)]-\u003e([a],[b])",
          "package": "base",
          "signature": "[(a,b)]-\u003e([a],[b])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:unzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunzip3\u003c/a\u003e\u003c/code\u003e function takes a list of triples and returns three\n lists, analogous to \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "unzip3",
          "package": "base",
          "signature": "[(a, b, c)] -\u003e ([a], [b], [c])",
          "source": "src/GHC-List.html#unzip3",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:unzip3\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:unzip3\"]"
        },
        "index": {
          "description": "The unzip3 function takes list of triples and returns three lists analogous to unzip",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "unzip3",
          "normalized": "[(a,b,c)]-\u003e([a],[b],[c])",
          "package": "base",
          "signature": "[(a,b,c)]-\u003e([a],[b],[c])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:unzip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunzip4\u003c/a\u003e\u003c/code\u003e function takes a list of quadruples and returns four\n lists, analogous to \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "unzip4",
          "package": "base",
          "signature": "[(a, b, c, d)] -\u003e ([a], [b], [c], [d])",
          "source": "src/Data-List.html#unzip4",
          "type": "function"
        },
        "index": {
          "description": "The unzip4 function takes list of quadruples and returns four lists analogous to unzip",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "unzip4",
          "normalized": "[(a,b,c,d)]-\u003e([a],[b],[c],[d])",
          "package": "base",
          "signature": "[(a,b,c,d)]-\u003e([a],[b],[c],[d])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:unzip4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunzip5\u003c/a\u003e\u003c/code\u003e function takes a list of five-tuples and returns five\n lists, analogous to \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "unzip5",
          "package": "base",
          "signature": "[(a, b, c, d, e)] -\u003e ([a], [b], [c], [d], [e])",
          "source": "src/Data-List.html#unzip5",
          "type": "function"
        },
        "index": {
          "description": "The unzip5 function takes list of five-tuples and returns five lists analogous to unzip",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "unzip5",
          "normalized": "[(a,b,c,d,e)]-\u003e([a],[b],[c],[d],[e])",
          "package": "base",
          "signature": "[(a,b,c,d,e)]-\u003e([a],[b],[c],[d],[e])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:unzip5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunzip6\u003c/a\u003e\u003c/code\u003e function takes a list of six-tuples and returns six\n lists, analogous to \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "unzip6",
          "package": "base",
          "signature": "[(a, b, c, d, e, f)] -\u003e ([a], [b], [c], [d], [e], [f])",
          "source": "src/Data-List.html#unzip6",
          "type": "function"
        },
        "index": {
          "description": "The unzip6 function takes list of six-tuples and returns six lists analogous to unzip",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "unzip6",
          "normalized": "[(a,b,c,d,e,f)]-\u003e([a],[b],[c],[d],[e],[f])",
          "package": "base",
          "signature": "[(a,b,c,d,e,f)]-\u003e([a],[b],[c],[d],[e],[f])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:unzip6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunzip7\u003c/a\u003e\u003c/code\u003e function takes a list of seven-tuples and returns\n seven lists, analogous to \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "unzip7",
          "package": "base",
          "signature": "[(a, b, c, d, e, f, g)] -\u003e ([a], [b], [c], [d], [e], [f], [g])",
          "source": "src/Data-List.html#unzip7",
          "type": "function"
        },
        "index": {
          "description": "The unzip7 function takes list of seven-tuples and returns seven lists analogous to unzip",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "unzip7",
          "normalized": "[(a,b,c,d,e,f,g)]-\u003e([a],[b],[c],[d],[e],[f],[g])",
          "package": "base",
          "signature": "[(a,b,c,d,e,f,g)]-\u003e([a],[b],[c],[d],[e],[f],[g])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:unzip7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ewords\u003c/a\u003e\u003c/code\u003e breaks a string up into a list of words, which were delimited\n by white space.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Data.String\",\"Prelude\"]",
          "name": "words",
          "package": "base",
          "signature": "String -\u003e [String]",
          "source": "src/Data-List.html#words",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:words\",\"http://hackage.haskell.org/package/base/docs/Data-String.html#v:words\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:words\"]"
        },
        "index": {
          "description": "words breaks string up into list of words which were delimited by white space",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "words",
          "normalized": "String-\u003e[String]",
          "package": "base",
          "signature": "String-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:words"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e takes two lists and returns a list of corresponding pairs.\n If one input list is short, excess elements of the longer list are\n discarded.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "zip",
          "package": "base",
          "signature": "[a] -\u003e [b] -\u003e [(a, b)]",
          "source": "src/GHC-List.html#zip",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:zip\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:zip\"]"
        },
        "index": {
          "description": "zip takes two lists and returns list of corresponding pairs If one input list is short excess elements of the longer list are discarded",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "zip",
          "normalized": "[a]-\u003e[b]-\u003e[(a,b)]",
          "package": "base",
          "signature": "[a]-\u003e[b]-\u003e[(a,b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:zip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ezip3\u003c/a\u003e\u003c/code\u003e takes three lists and returns a list of triples, analogous to\n \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "zip3",
          "package": "base",
          "signature": "[a] -\u003e [b] -\u003e [c] -\u003e [(a, b, c)]",
          "source": "src/GHC-List.html#zip3",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:zip3\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:zip3\"]"
        },
        "index": {
          "description": "zip3 takes three lists and returns list of triples analogous to zip",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "zip3",
          "normalized": "[a]-\u003e[b]-\u003e[c]-\u003e[(a,b,c)]",
          "package": "base",
          "signature": "[a]-\u003e[b]-\u003e[c]-\u003e[(a,b,c)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:zip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezip4\u003c/a\u003e\u003c/code\u003e function takes four lists and returns a list of\n quadruples, analogous to \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "zip4",
          "package": "base",
          "signature": "[a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [(a, b, c, d)]",
          "source": "src/Data-List.html#zip4",
          "type": "function"
        },
        "index": {
          "description": "The zip4 function takes four lists and returns list of quadruples analogous to zip",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "zip4",
          "normalized": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[(a,b,c,d)]",
          "package": "base",
          "signature": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[(a,b,c,d)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:zip4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezip5\u003c/a\u003e\u003c/code\u003e function takes five lists and returns a list of\n five-tuples, analogous to \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "zip5",
          "package": "base",
          "signature": "[a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [e] -\u003e [(a, b, c, d, e)]",
          "source": "src/Data-List.html#zip5",
          "type": "function"
        },
        "index": {
          "description": "The zip5 function takes five lists and returns list of five-tuples analogous to zip",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "zip5",
          "normalized": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[(a,b,c,d,e)]",
          "package": "base",
          "signature": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[(a,b,c,d,e)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:zip5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezip6\u003c/a\u003e\u003c/code\u003e function takes six lists and returns a list of six-tuples,\n analogous to \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "zip6",
          "package": "base",
          "signature": "[a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [e] -\u003e [f] -\u003e [(a, b, c, d, e, f)]",
          "source": "src/Data-List.html#zip6",
          "type": "function"
        },
        "index": {
          "description": "The zip6 function takes six lists and returns list of six-tuples analogous to zip",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "zip6",
          "normalized": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[(a,b,c,d,e,f)]",
          "package": "base",
          "signature": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[(a,b,c,d,e,f)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:zip6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezip7\u003c/a\u003e\u003c/code\u003e function takes seven lists and returns a list of\n seven-tuples, analogous to \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "zip7",
          "package": "base",
          "signature": "[a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [e] -\u003e [f] -\u003e [g] -\u003e [(a, b, c, d, e, f, g)]",
          "source": "src/Data-List.html#zip7",
          "type": "function"
        },
        "index": {
          "description": "The zip7 function takes seven lists and returns list of seven-tuples analogous to zip",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "zip7",
          "normalized": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[g]-\u003e[(a,b,c,d,e,f,g)]",
          "package": "base",
          "signature": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[g]-\u003e[(a,b,c,d,e,f,g)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:zip7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e generalises \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e by zipping with the function given\n as the first argument, instead of a tupling function.\n For example, \u003ccode\u003e\u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e (+)\u003c/code\u003e is applied to two lists to produce the\n list of corresponding sums.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "zipWith",
          "package": "base",
          "signature": "(a -\u003e b -\u003e c) -\u003e [a] -\u003e [b] -\u003e [c]",
          "source": "src/GHC-List.html#zipWith",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:zipWith\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:zipWith\"]"
        },
        "index": {
          "description": "zipWith generalises zip by zipping with the function given as the first argument instead of tupling function For example zipWith is applied to two lists to produce the list of corresponding sums",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003e[a]-\u003e[b]-\u003e[c]",
          "package": "base",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003e[a]-\u003e[b]-\u003e[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezipWith3\u003c/a\u003e\u003c/code\u003e function takes a function which combines three\n elements, as well as three lists and returns a list of their point-wise\n combination, analogous to \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.List\",\"Prelude\"]",
          "name": "zipWith3",
          "package": "base",
          "signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e [a] -\u003e [b] -\u003e [c] -\u003e [d]",
          "source": "src/GHC-List.html#zipWith3",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-List.html#v:zipWith3\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:zipWith3\"]"
        },
        "index": {
          "description": "The zipWith3 function takes function which combines three elements as well as three lists and returns list of their point-wise combination analogous to zipWith",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "zipWith3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]",
          "package": "base",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:zipWith3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezipWith4\u003c/a\u003e\u003c/code\u003e function takes a function which combines four\n elements, as well as four lists and returns a list of their point-wise\n combination, analogous to \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "zipWith4",
          "package": "base",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e [a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [e]",
          "source": "src/Data-List.html#zipWith4",
          "type": "function"
        },
        "index": {
          "description": "The zipWith4 function takes function which combines four elements as well as four lists and returns list of their point-wise combination analogous to zipWith",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "zipWith4",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]",
          "package": "base",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:zipWith4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezipWith5\u003c/a\u003e\u003c/code\u003e function takes a function which combines five\n elements, as well as five lists and returns a list of their point-wise\n combination, analogous to \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "zipWith5",
          "package": "base",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e [a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [e] -\u003e [f]",
          "source": "src/Data-List.html#zipWith5",
          "type": "function"
        },
        "index": {
          "description": "The zipWith5 function takes function which combines five elements as well as five lists and returns list of their point-wise combination analogous to zipWith",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "zipWith5",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]",
          "package": "base",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:zipWith5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezipWith6\u003c/a\u003e\u003c/code\u003e function takes a function which combines six\n elements, as well as six lists and returns a list of their point-wise\n combination, analogous to \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "zipWith6",
          "package": "base",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e [a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [e] -\u003e [f] -\u003e [g]",
          "source": "src/Data-List.html#zipWith6",
          "type": "function"
        },
        "index": {
          "description": "The zipWith6 function takes function which combines six elements as well as six lists and returns list of their point-wise combination analogous to zipWith",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "zipWith6",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[g]",
          "package": "base",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[g]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:zipWith6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezipWith7\u003c/a\u003e\u003c/code\u003e function takes a function which combines seven\n elements, as well as seven lists and returns a list of their point-wise\n combination, analogous to \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List",
          "name": "zipWith7",
          "package": "base",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g -\u003e h) -\u003e [a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [e] -\u003e [f] -\u003e [g] -\u003e [h]",
          "source": "src/Data-List.html#zipWith7",
          "type": "function"
        },
        "index": {
          "description": "The zipWith7 function takes function which combines seven elements as well as seven lists and returns list of their point-wise combination analogous to zipWith",
          "hierarchy": "Data List",
          "module": "Data.List",
          "name": "zipWith7",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg-\u003eh)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[g]-\u003e[h]",
          "package": "base",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg-\u003eh)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[g]-\u003e[h]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-List.html#v:zipWith7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe Maybe type, and associated operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Maybe",
          "name": "Maybe",
          "package": "base",
          "source": "src/Data-Maybe.html",
          "type": "module"
        },
        "index": {
          "description": "The Maybe type and associated operations",
          "hierarchy": "Data Maybe",
          "module": "Data.Maybe",
          "name": "Maybe",
          "package": "base",
          "partial": "Maybe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Maybe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e type encapsulates an optional value.  A value of type\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e either contains a value of type \u003ccode\u003ea\u003c/code\u003e (represented as \u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e), \n or it is empty (represented as \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e).  Using \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e is a good way to \n deal with errors or exceptional cases without resorting to drastic\n measures such as \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e type is also a monad.  It is a simple kind of error\n monad, where all errors are represented by \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.  A richer\n error monad can be built using the \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Data.Maybe",
          "name": "Maybe",
          "package": "base",
          "source": "src/Data-Maybe.html#Maybe",
          "type": "data"
        },
        "index": {
          "description": "The Maybe type encapsulates an optional value value of type Maybe either contains value of type represented as Just or it is empty represented as Nothing Using Maybe is good way to deal with errors or exceptional cases without resorting to drastic measures such as error The Maybe type is also monad It is simple kind of error monad where all errors are represented by Nothing richer error monad can be built using the Either type",
          "hierarchy": "Data Maybe",
          "module": "Data.Maybe",
          "name": "Maybe",
          "package": "base",
          "partial": "Maybe",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Maybe.html#t:Maybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Maybe\",\"Prelude\"]",
          "name": "Just",
          "package": "base",
          "signature": "Just a",
          "source": "src/Data-Maybe.html#Maybe",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:Just\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:Just\"]"
        },
        "index": {
          "hierarchy": "Data Maybe",
          "module": "Data.Maybe",
          "name": "Just",
          "package": "base",
          "partial": "Just",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:Just"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Maybe\",\"Prelude\"]",
          "name": "Nothing",
          "package": "base",
          "signature": "Nothing",
          "source": "src/Data-Maybe.html#Maybe",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:Nothing\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:Nothing\"]"
        },
        "index": {
          "hierarchy": "Data Maybe",
          "module": "Data.Maybe",
          "name": "Nothing",
          "package": "base",
          "partial": "Nothing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:Nothing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ecatMaybes\u003c/a\u003e\u003c/code\u003e function takes a list of \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003es and returns\n a list of all the \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e values. \n\u003c/p\u003e",
          "module": "Data.Maybe",
          "name": "catMaybes",
          "package": "base",
          "signature": "[Maybe a] -\u003e [a]",
          "source": "src/Data-Maybe.html#catMaybes",
          "type": "function"
        },
        "index": {
          "description": "The catMaybes function takes list of Maybe and returns list of all the Just values",
          "hierarchy": "Data Maybe",
          "module": "Data.Maybe",
          "name": "catMaybes",
          "normalized": "[Maybe a]-\u003e[a]",
          "package": "base",
          "partial": "Maybes",
          "signature": "[Maybe a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:catMaybes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efromJust\u003c/a\u003e\u003c/code\u003e function extracts the element out of a \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e and\n throws an error if its argument is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Maybe",
          "name": "fromJust",
          "package": "base",
          "signature": "Maybe a -\u003e a",
          "source": "src/Data-Maybe.html#fromJust",
          "type": "function"
        },
        "index": {
          "description": "The fromJust function extracts the element out of Just and throws an error if its argument is Nothing",
          "hierarchy": "Data Maybe",
          "module": "Data.Maybe",
          "name": "fromJust",
          "normalized": "Maybe a-\u003ea",
          "package": "base",
          "partial": "Just",
          "signature": "Maybe a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:fromJust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efromMaybe\u003c/a\u003e\u003c/code\u003e function takes a default value and and \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e\n value.  If the \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, it returns the default values;\n otherwise, it returns the value contained in the \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Maybe",
          "name": "fromMaybe",
          "package": "base",
          "signature": "a -\u003e Maybe a -\u003e a",
          "source": "src/Data-Maybe.html#fromMaybe",
          "type": "function"
        },
        "index": {
          "description": "The fromMaybe function takes default value and and Maybe value If the Maybe is Nothing it returns the default values otherwise it returns the value contained in the Maybe",
          "hierarchy": "Data Maybe",
          "module": "Data.Maybe",
          "name": "fromMaybe",
          "normalized": "a-\u003eMaybe a-\u003ea",
          "package": "base",
          "partial": "Maybe",
          "signature": "a-\u003eMaybe a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:fromMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eisJust\u003c/a\u003e\u003c/code\u003e function returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e iff its argument is of the\n form \u003ccode\u003eJust _\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Maybe",
          "name": "isJust",
          "package": "base",
          "signature": "Maybe a -\u003e Bool",
          "source": "src/Data-Maybe.html#isJust",
          "type": "function"
        },
        "index": {
          "description": "The isJust function returns True iff its argument is of the form Just",
          "hierarchy": "Data Maybe",
          "module": "Data.Maybe",
          "name": "isJust",
          "normalized": "Maybe a-\u003eBool",
          "package": "base",
          "partial": "Just",
          "signature": "Maybe a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:isJust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eisNothing\u003c/a\u003e\u003c/code\u003e function returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e iff its argument is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Maybe",
          "name": "isNothing",
          "package": "base",
          "signature": "Maybe a -\u003e Bool",
          "source": "src/Data-Maybe.html#isNothing",
          "type": "function"
        },
        "index": {
          "description": "The isNothing function returns True iff its argument is Nothing",
          "hierarchy": "Data Maybe",
          "module": "Data.Maybe",
          "name": "isNothing",
          "normalized": "Maybe a-\u003eBool",
          "package": "base",
          "partial": "Nothing",
          "signature": "Maybe a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:isNothing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003elistToMaybe\u003c/a\u003e\u003c/code\u003e function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e on an empty list\n or \u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e where \u003ccode\u003ea\u003c/code\u003e is the first element of the list.\n\u003c/p\u003e",
          "module": "Data.Maybe",
          "name": "listToMaybe",
          "package": "base",
          "signature": "[a] -\u003e Maybe a",
          "source": "src/Data-Maybe.html#listToMaybe",
          "type": "function"
        },
        "index": {
          "description": "The listToMaybe function returns Nothing on an empty list or Just where is the first element of the list",
          "hierarchy": "Data Maybe",
          "module": "Data.Maybe",
          "name": "listToMaybe",
          "normalized": "[a]-\u003eMaybe a",
          "package": "base",
          "partial": "To Maybe",
          "signature": "[a]-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:listToMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emapMaybe\u003c/a\u003e\u003c/code\u003e function is a version of \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e which can throw\n out elements.  In particular, the functional argument returns\n something of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e.  If this is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, no element\n is added on to the result list.  If it just \u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e, then \u003ccode\u003eb\u003c/code\u003e is\n included in the result list.\n\u003c/p\u003e",
          "module": "Data.Maybe",
          "name": "mapMaybe",
          "package": "base",
          "signature": "(a -\u003e Maybe b) -\u003e [a] -\u003e [b]",
          "source": "src/Data-Maybe.html#mapMaybe",
          "type": "function"
        },
        "index": {
          "description": "The mapMaybe function is version of map which can throw out elements In particular the functional argument returns something of type Maybe If this is Nothing no element is added on to the result list If it just Just then is included in the result list",
          "hierarchy": "Data Maybe",
          "module": "Data.Maybe",
          "name": "mapMaybe",
          "normalized": "(a-\u003eMaybe b)-\u003e[a]-\u003e[b]",
          "package": "base",
          "partial": "Maybe",
          "signature": "(a-\u003eMaybe b)-\u003e[a]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:mapMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emaybe\u003c/a\u003e\u003c/code\u003e function takes a default value, a function, and a \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e\n value.  If the \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e value is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the function returns the\n default value.  Otherwise, it applies the function to the value inside\n the \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e and returns the result.\n\u003c/p\u003e",
          "module": "[\"Data.Maybe\",\"Prelude\"]",
          "name": "maybe",
          "package": "base",
          "signature": "b -\u003e (a -\u003e b) -\u003e Maybe a -\u003e b",
          "source": "src/Data-Maybe.html#maybe",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:maybe\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:maybe\"]"
        },
        "index": {
          "description": "The maybe function takes default value function and Maybe value If the Maybe value is Nothing the function returns the default value Otherwise it applies the function to the value inside the Just and returns the result",
          "hierarchy": "Data Maybe",
          "module": "Data.Maybe",
          "name": "maybe",
          "normalized": "a-\u003e(b-\u003ea)-\u003eMaybe b-\u003ea",
          "package": "base",
          "signature": "b-\u003e(a-\u003eb)-\u003eMaybe a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:maybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emaybeToList\u003c/a\u003e\u003c/code\u003e function returns an empty list when given\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e or a singleton list when not given \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Maybe",
          "name": "maybeToList",
          "package": "base",
          "signature": "Maybe a -\u003e [a]",
          "source": "src/Data-Maybe.html#maybeToList",
          "type": "function"
        },
        "index": {
          "description": "The maybeToList function returns an empty list when given Nothing or singleton list when not given Nothing",
          "hierarchy": "Data Maybe",
          "module": "Data.Maybe",
          "name": "maybeToList",
          "normalized": "Maybe a-\u003e[a]",
          "package": "base",
          "partial": "To List",
          "signature": "Maybe a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:maybeToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA class for monoids (types with an associative binary operation that\n has an identity) with various general-purpose instances.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Monoid",
          "name": "Monoid",
          "package": "base",
          "source": "src/Data-Monoid.html",
          "type": "module"
        },
        "index": {
          "description": "class for monoids types with an associative binary operation that has an identity with various general-purpose instances",
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "Monoid",
          "package": "base",
          "partial": "Monoid",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoolean monoid under conjunction.\n\u003c/p\u003e",
          "module": "Data.Monoid",
          "name": "All",
          "package": "base",
          "source": "src/Data-Monoid.html#All",
          "type": "newtype"
        },
        "index": {
          "description": "Boolean monoid under conjunction",
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "All",
          "package": "base",
          "partial": "All",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:All"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoolean monoid under disjunction.\n\u003c/p\u003e",
          "module": "Data.Monoid",
          "name": "Any",
          "package": "base",
          "source": "src/Data-Monoid.html#Any",
          "type": "newtype"
        },
        "index": {
          "description": "Boolean monoid under disjunction",
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "Any",
          "package": "base",
          "partial": "Any",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Any"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe dual of a monoid, obtained by swapping the arguments of \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Monoid",
          "name": "Dual",
          "package": "base",
          "source": "src/Data-Monoid.html#Dual",
          "type": "newtype"
        },
        "index": {
          "description": "The dual of monoid obtained by swapping the arguments of mappend",
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "Dual",
          "package": "base",
          "partial": "Dual",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Dual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe monoid of endomorphisms under composition.\n\u003c/p\u003e",
          "module": "Data.Monoid",
          "name": "Endo",
          "package": "base",
          "source": "src/Data-Monoid.html#Endo",
          "type": "newtype"
        },
        "index": {
          "description": "The monoid of endomorphisms under composition",
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "Endo",
          "package": "base",
          "partial": "Endo",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Endo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaybe monoid returning the leftmost non-Nothing value.\n\u003c/p\u003e",
          "module": "Data.Monoid",
          "name": "First",
          "package": "base",
          "source": "src/Data-Monoid.html#First",
          "type": "newtype"
        },
        "index": {
          "description": "Maybe monoid returning the leftmost non-Nothing value",
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "First",
          "package": "base",
          "partial": "First",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:First"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaybe monoid returning the rightmost non-Nothing value.\n\u003c/p\u003e",
          "module": "Data.Monoid",
          "name": "Last",
          "package": "base",
          "source": "src/Data-Monoid.html#Last",
          "type": "newtype"
        },
        "index": {
          "description": "Maybe monoid returning the rightmost non-Nothing value",
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "Last",
          "package": "base",
          "partial": "Last",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Last"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class of monoids (types with an associative binary operation that\n has an identity).  Instances should satisfy the following laws:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003emappend mempty x = x\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003emappend x mempty = x\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003emappend x (mappend y z) = mappend (mappend x y) z\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003emconcat = \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e mappend mempty\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe method names refer to the monoid of lists under concatenation,\n but there are many other instances.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSome types can be viewed as a monoid in more than one way,\n e.g. both addition and multiplication on numbers.\n In such cases we often define \u003ccode\u003enewtype\u003c/code\u003es and make those instances\n of \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e, e.g. \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eProduct\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Monoid",
          "name": "Monoid",
          "package": "base",
          "source": "src/Data-Monoid.html#Monoid",
          "type": "class"
        },
        "index": {
          "description": "The class of monoids types with an associative binary operation that has an identity Instances should satisfy the following laws mappend mempty mappend mempty mappend mappend mappend mappend mconcat foldr mappend mempty The method names refer to the monoid of lists under concatenation but there are many other instances Minimal complete definition mempty and mappend Some types can be viewed as monoid in more than one way e.g both addition and multiplication on numbers In such cases we often define newtype and make those instances of Monoid e.g Sum and Product",
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "Monoid",
          "package": "base",
          "partial": "Monoid",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Monoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonoid under multiplication.\n\u003c/p\u003e",
          "module": "Data.Monoid",
          "name": "Product",
          "package": "base",
          "source": "src/Data-Monoid.html#Product",
          "type": "newtype"
        },
        "index": {
          "description": "Monoid under multiplication",
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "Product",
          "package": "base",
          "partial": "Product",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Product"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonoid under addition.\n\u003c/p\u003e",
          "module": "Data.Monoid",
          "name": "Sum",
          "package": "base",
          "source": "src/Data-Monoid.html#Sum",
          "type": "newtype"
        },
        "index": {
          "description": "Monoid under addition",
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "Sum",
          "package": "base",
          "partial": "Sum",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn infix synonym for \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Monoid",
          "name": "(\u003c\u003e)",
          "package": "base",
          "signature": "m -\u003e m -\u003e m",
          "source": "src/Data-Monoid.html#%3C%3E",
          "type": "function"
        },
        "index": {
          "description": "An infix synonym for mappend",
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "(\u003c\u003e) \u003c\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "m-\u003em-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:-60--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "All",
          "package": "base",
          "signature": "All",
          "source": "src/Data-Monoid.html#All",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "All",
          "package": "base",
          "partial": "All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:All"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "Any",
          "package": "base",
          "signature": "Any",
          "source": "src/Data-Monoid.html#Any",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "Any",
          "package": "base",
          "partial": "Any",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:Any"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "Dual",
          "package": "base",
          "signature": "Dual",
          "source": "src/Data-Monoid.html#Dual",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "Dual",
          "package": "base",
          "partial": "Dual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:Dual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "Endo",
          "package": "base",
          "signature": "Endo",
          "source": "src/Data-Monoid.html#Endo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "Endo",
          "package": "base",
          "partial": "Endo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:Endo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "First",
          "package": "base",
          "signature": "First",
          "source": "src/Data-Monoid.html#First",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "First",
          "package": "base",
          "partial": "First",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:First"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "Last",
          "package": "base",
          "signature": "Last",
          "source": "src/Data-Monoid.html#Last",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "Last",
          "package": "base",
          "partial": "Last",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:Last"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "Product",
          "package": "base",
          "signature": "Product",
          "source": "src/Data-Monoid.html#Product",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "Product",
          "package": "base",
          "partial": "Product",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:Product"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "Sum",
          "package": "base",
          "signature": "Sum",
          "source": "src/Data-Monoid.html#Sum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "Sum",
          "package": "base",
          "partial": "Sum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:Sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "appEndo",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/Data-Monoid.html#Endo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "appEndo",
          "normalized": "a-\u003ea",
          "package": "base",
          "partial": "Endo",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:appEndo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "getAll",
          "package": "base",
          "signature": "Bool",
          "source": "src/Data-Monoid.html#All",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "getAll",
          "package": "base",
          "partial": "All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:getAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "getAny",
          "package": "base",
          "signature": "Bool",
          "source": "src/Data-Monoid.html#Any",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "getAny",
          "package": "base",
          "partial": "Any",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:getAny"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "getDual",
          "package": "base",
          "signature": "a",
          "source": "src/Data-Monoid.html#Dual",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "getDual",
          "package": "base",
          "partial": "Dual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:getDual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "getFirst",
          "package": "base",
          "signature": "Maybe a",
          "source": "src/Data-Monoid.html#First",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "getFirst",
          "package": "base",
          "partial": "First",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:getFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "getLast",
          "package": "base",
          "signature": "Maybe a",
          "source": "src/Data-Monoid.html#Last",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "getLast",
          "package": "base",
          "partial": "Last",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:getLast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "getProduct",
          "package": "base",
          "signature": "a",
          "source": "src/Data-Monoid.html#Product",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "getProduct",
          "package": "base",
          "partial": "Product",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:getProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid",
          "name": "getSum",
          "package": "base",
          "signature": "a",
          "source": "src/Data-Monoid.html#Sum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "getSum",
          "package": "base",
          "partial": "Sum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:getSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn associative operation\n\u003c/p\u003e",
          "module": "Data.Monoid",
          "name": "mappend",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Data-Monoid.html#mappend",
          "type": "method"
        },
        "index": {
          "description": "An associative operation",
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "mappend",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mappend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold a list using the monoid.\n For most types, the default definition for \u003ccode\u003e\u003ca\u003emconcat\u003c/a\u003e\u003c/code\u003e will be\n used, but the function is included in the class definition so\n that an optimized version can be provided for specific types.\n\u003c/p\u003e",
          "module": "Data.Monoid",
          "name": "mconcat",
          "package": "base",
          "signature": "[a] -\u003e a",
          "source": "src/Data-Monoid.html#mconcat",
          "type": "method"
        },
        "index": {
          "description": "Fold list using the monoid For most types the default definition for mconcat will be used but the function is included in the class definition so that an optimized version can be provided for specific types",
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "mconcat",
          "normalized": "[a]-\u003ea",
          "package": "base",
          "signature": "[a]-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mconcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentity of \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Monoid",
          "name": "mempty",
          "package": "base",
          "signature": "a",
          "source": "src/Data-Monoid.html#mempty",
          "type": "method"
        },
        "index": {
          "description": "Identity of mappend",
          "hierarchy": "Data Monoid",
          "module": "Data.Monoid",
          "name": "mempty",
          "package": "base",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOrderings\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Ord",
          "name": "Ord",
          "package": "base",
          "source": "src/Data-Ord.html",
          "type": "module"
        },
        "index": {
          "description": "Orderings",
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "Ord",
          "package": "base",
          "partial": "Ord",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eDown\u003c/a\u003e\u003c/code\u003e type allows you to reverse sort order conveniently.  A value of type\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eDown\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e contains a value of type \u003ccode\u003ea\u003c/code\u003e (represented as \u003ccode\u003e\u003ccode\u003e\u003ca\u003eDown\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e).\n If \u003ccode\u003ea\u003c/code\u003e has an \u003ccode\u003e\u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e instance associated with it then comparing two\n values thus wrapped will give you the opposite of their normal sort order.\n This is particularly useful when sorting in generalised list comprehensions,\n as in: \u003ccode\u003ethen sortWith by \u003ccode\u003e\u003ca\u003eDown\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Ord",
          "name": "Down",
          "package": "base",
          "source": "src/Data-Ord.html#Down",
          "type": "newtype"
        },
        "index": {
          "description": "The Down type allows you to reverse sort order conveniently value of type Down contains value of type represented as Down If has an Ord instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order This is particularly useful when sorting in generalised list comprehensions as in then sortWith by Down",
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "Down",
          "package": "base",
          "partial": "Down",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Down"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e class is used for totally ordered datatypes.\n\u003c/p\u003e\u003cp\u003eInstances of \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e can be derived for any user-defined\n datatype whose constituent types are in \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e.  The declared order\n of the constructors in the data declaration determines the ordering\n in derived \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e instances.  The \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e datatype allows a single\n comparison to determine the precise ordering of two objects.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: either \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003e\u003c=\u003c/a\u003e\u003c/code\u003e.\n Using \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e can be more efficient for complex types.\n\u003c/p\u003e",
          "module": "Data.Ord",
          "name": "Ord",
          "package": "base",
          "type": "class"
        },
        "index": {
          "description": "The Ord class is used for totally ordered datatypes Instances of Ord can be derived for any user-defined datatype whose constituent types are in Ord The declared order of the constructors in the data declaration determines the ordering in derived Ord instances The Ordering datatype allows single comparison to determine the precise ordering of two objects Minimal complete definition either compare or Using compare can be more efficient for complex types",
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "Ord",
          "package": "base",
          "partial": "Ord",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ord",
          "name": "Ordering",
          "package": "base",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "Ordering",
          "package": "base",
          "partial": "Ordering",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ordering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ord",
          "name": "(\u003c)",
          "package": "base",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "(\u003c) \u003c",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "base",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:-60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ord",
          "name": "(\u003c=)",
          "package": "base",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "(\u003c=) \u003c=",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "base",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:-60--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ord",
          "name": "(\u003e)",
          "package": "base",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "(\u003e) \u003e",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "base",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ord",
          "name": "(\u003e=)",
          "package": "base",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "(\u003e=) \u003e=",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "base",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:-62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Ord\",\"GHC.Exts\"]",
          "name": "Down",
          "package": "base",
          "signature": "Down a",
          "source": "src/Data-Ord.html#Down",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:Down\",\"http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:Down\"]"
        },
        "index": {
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "Down",
          "package": "base",
          "partial": "Down",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:Down"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Ord\",\"Prelude\"]",
          "name": "EQ",
          "package": "base",
          "signature": "EQ",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:EQ\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:EQ\"]"
        },
        "index": {
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "EQ",
          "package": "base",
          "partial": "EQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:EQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Ord\",\"Prelude\"]",
          "name": "GT",
          "package": "base",
          "signature": "GT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:GT\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:GT\"]"
        },
        "index": {
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "GT",
          "package": "base",
          "partial": "GT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:GT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Ord\",\"Prelude\"]",
          "name": "LT",
          "package": "base",
          "signature": "LT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:LT\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:LT\"]"
        },
        "index": {
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "LT",
          "package": "base",
          "partial": "LT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:LT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ord",
          "name": "compare",
          "package": "base",
          "signature": "a -\u003e a -\u003e Ordering",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "compare",
          "normalized": "a-\u003ea-\u003eOrdering",
          "package": "base",
          "signature": "a-\u003ea-\u003eOrdering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:compare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e comparing p x y = compare (p x) (p y)\n\u003c/pre\u003e\u003cp\u003eUseful combinator for use in conjunction with the \u003ccode\u003exxxBy\u003c/code\u003e family\n of functions from \u003ca\u003eData.List\u003c/a\u003e, for example:\n\u003c/p\u003e\u003cpre\u003e   ... sortBy (comparing fst) ...\n\u003c/pre\u003e",
          "module": "Data.Ord",
          "name": "comparing",
          "package": "base",
          "signature": "(b -\u003e a) -\u003e b -\u003e b -\u003e Ordering",
          "source": "src/Data-Ord.html#comparing",
          "type": "function"
        },
        "index": {
          "description": "comparing compare Useful combinator for use in conjunction with the xxxBy family of functions from Data.List for example sortBy comparing fst",
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "comparing",
          "normalized": "(a-\u003eb)-\u003ea-\u003ea-\u003eOrdering",
          "package": "base",
          "signature": "(b-\u003ea)-\u003eb-\u003eb-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:comparing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ord",
          "name": "max",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "max",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:max"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ord",
          "name": "min",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Ord",
          "module": "Data.Ord",
          "name": "min",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:min"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eStandard functions on rational numbers\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Ratio",
          "name": "Ratio",
          "package": "base",
          "source": "src/Data-Ratio.html",
          "type": "module"
        },
        "index": {
          "description": "Standard functions on rational numbers",
          "hierarchy": "Data Ratio",
          "module": "Data.Ratio",
          "name": "Ratio",
          "package": "base",
          "partial": "Ratio",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ratio.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRational numbers, with numerator and denominator of some \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Data.Ratio",
          "name": "Ratio",
          "package": "base",
          "source": "src/GHC-Real.html#Ratio",
          "type": "data"
        },
        "index": {
          "description": "Rational numbers with numerator and denominator of some Integral type",
          "hierarchy": "Data Ratio",
          "module": "Data.Ratio",
          "name": "Ratio",
          "package": "base",
          "partial": "Ratio",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ratio.html#t:Ratio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArbitrary-precision rational numbers, represented as a ratio of\n two \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e values.  A rational number may be constructed using\n the \u003ccode\u003e\u003ca\u003e%\u003c/a\u003e\u003c/code\u003e operator.\n\u003c/p\u003e",
          "module": "Data.Ratio",
          "name": "Rational",
          "package": "base",
          "source": "src/GHC-Real.html#Rational",
          "type": "type"
        },
        "index": {
          "description": "Arbitrary-precision rational numbers represented as ratio of two Integer values rational number may be constructed using the operator",
          "hierarchy": "Data Ratio",
          "module": "Data.Ratio",
          "name": "Rational",
          "package": "base",
          "partial": "Rational",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ratio.html#t:Rational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForms the ratio of two integral numbers.\n\u003c/p\u003e",
          "module": "Data.Ratio",
          "name": "(%)",
          "package": "base",
          "signature": "a -\u003e a -\u003e Ratio a",
          "source": "src/GHC-Real.html#%25",
          "type": "function"
        },
        "index": {
          "description": "Forms the ratio of two integral numbers",
          "hierarchy": "Data Ratio",
          "module": "Data.Ratio",
          "name": "(%) %",
          "normalized": "a-\u003ea-\u003eRatio a",
          "package": "base",
          "signature": "a-\u003ea-\u003eRatio a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ratio.html#v:-37-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eapproxRational\u003c/a\u003e\u003c/code\u003e, applied to two real fractional numbers \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003eepsilon\u003c/code\u003e,\n returns the simplest rational number within \u003ccode\u003eepsilon\u003c/code\u003e of \u003ccode\u003ex\u003c/code\u003e.\n A rational number \u003ccode\u003ey\u003c/code\u003e is said to be \u003cem\u003esimpler\u003c/em\u003e than another \u003ccode\u003ey'\u003c/code\u003e if\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003enumerator\u003c/a\u003e\u003c/code\u003e y) \u003c= \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003enumerator\u003c/a\u003e\u003c/code\u003e y')\u003c/code\u003e, and\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ccode\u003e\u003ca\u003edenominator\u003c/a\u003e\u003c/code\u003e y \u003c= \u003ccode\u003e\u003ca\u003edenominator\u003c/a\u003e\u003c/code\u003e y'\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAny real interval contains a unique simplest rational;\n in particular, note that \u003ccode\u003e0/1\u003c/code\u003e is the simplest rational of all.\n\u003c/p\u003e",
          "module": "Data.Ratio",
          "name": "approxRational",
          "package": "base",
          "signature": "a -\u003e a -\u003e Rational",
          "source": "src/Data-Ratio.html#approxRational",
          "type": "function"
        },
        "index": {
          "description": "approxRational applied to two real fractional numbers and epsilon returns the simplest rational number within epsilon of rational number is said to be simpler than another if abs numerator abs numerator and denominator denominator Any real interval contains unique simplest rational in particular note that is the simplest rational of all",
          "hierarchy": "Data Ratio",
          "module": "Data.Ratio",
          "name": "approxRational",
          "normalized": "a-\u003ea-\u003eRational",
          "package": "base",
          "partial": "Rational",
          "signature": "a-\u003ea-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ratio.html#v:approxRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the denominator of the ratio in reduced form:\n the numerator and denominator have no common factor and the denominator\n is positive.\n\u003c/p\u003e",
          "module": "Data.Ratio",
          "name": "denominator",
          "package": "base",
          "signature": "Ratio a -\u003e a",
          "source": "src/GHC-Real.html#denominator",
          "type": "function"
        },
        "index": {
          "description": "Extract the denominator of the ratio in reduced form the numerator and denominator have no common factor and the denominator is positive",
          "hierarchy": "Data Ratio",
          "module": "Data.Ratio",
          "name": "denominator",
          "normalized": "Ratio a-\u003ea",
          "package": "base",
          "signature": "Ratio a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ratio.html#v:denominator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the numerator of the ratio in reduced form:\n the numerator and denominator have no common factor and the denominator\n is positive.\n\u003c/p\u003e",
          "module": "Data.Ratio",
          "name": "numerator",
          "package": "base",
          "signature": "Ratio a -\u003e a",
          "source": "src/GHC-Real.html#numerator",
          "type": "function"
        },
        "index": {
          "description": "Extract the numerator of the ratio in reduced form the numerator and denominator have no common factor and the denominator is positive",
          "hierarchy": "Data Ratio",
          "module": "Data.Ratio",
          "name": "numerator",
          "normalized": "Ratio a-\u003ea",
          "package": "base",
          "signature": "Ratio a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Ratio.html#v:numerator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMutable references in the lazy ST monad.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.STRef.Lazy",
          "name": "Lazy",
          "package": "base",
          "source": "src/Data-STRef-Lazy.html",
          "type": "module"
        },
        "index": {
          "description": "Mutable references in the lazy ST monad",
          "hierarchy": "Data STRef Lazy",
          "module": "Data.STRef.Lazy",
          "name": "Lazy",
          "package": "base",
          "partial": "Lazy",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-STRef-Lazy.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea value of type \u003ccode\u003eSTRef s a\u003c/code\u003e is a mutable variable in state thread \u003ccode\u003es\u003c/code\u003e,\n containing a value of type \u003ccode\u003ea\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.STRef.Lazy",
          "name": "STRef",
          "package": "base",
          "source": "src/GHC-STRef.html#STRef",
          "type": "data"
        },
        "index": {
          "description": "value of type STRef is mutable variable in state thread containing value of type",
          "hierarchy": "Data STRef Lazy",
          "module": "Data.STRef.Lazy",
          "name": "STRef",
          "package": "base",
          "partial": "STRef",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-STRef-Lazy.html#t:STRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.STRef.Lazy",
          "name": "modifySTRef",
          "package": "base",
          "signature": "STRef s a -\u003e (a -\u003e a) -\u003e ST s ()",
          "source": "src/Data-STRef-Lazy.html#modifySTRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data STRef Lazy",
          "module": "Data.STRef.Lazy",
          "name": "modifySTRef",
          "normalized": "STRef a b-\u003e(b-\u003eb)-\u003eST a()",
          "package": "base",
          "partial": "STRef",
          "signature": "STRef s a-\u003e(a-\u003ea)-\u003eST s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-STRef-Lazy.html#v:modifySTRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.STRef.Lazy",
          "name": "newSTRef",
          "package": "base",
          "signature": "a -\u003e ST s (STRef s a)",
          "source": "src/Data-STRef-Lazy.html#newSTRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data STRef Lazy",
          "module": "Data.STRef.Lazy",
          "name": "newSTRef",
          "normalized": "a-\u003eST b(STRef b a)",
          "package": "base",
          "partial": "STRef",
          "signature": "a-\u003eST s(STRef s a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-STRef-Lazy.html#v:newSTRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.STRef.Lazy",
          "name": "readSTRef",
          "package": "base",
          "signature": "STRef s a -\u003e ST s a",
          "source": "src/Data-STRef-Lazy.html#readSTRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data STRef Lazy",
          "module": "Data.STRef.Lazy",
          "name": "readSTRef",
          "normalized": "STRef a b-\u003eST a b",
          "package": "base",
          "partial": "STRef",
          "signature": "STRef s a-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-STRef-Lazy.html#v:readSTRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.STRef.Lazy",
          "name": "writeSTRef",
          "package": "base",
          "signature": "STRef s a -\u003e a -\u003e ST s ()",
          "source": "src/Data-STRef-Lazy.html#writeSTRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data STRef Lazy",
          "module": "Data.STRef.Lazy",
          "name": "writeSTRef",
          "normalized": "STRef a b-\u003eb-\u003eST a()",
          "package": "base",
          "partial": "STRef",
          "signature": "STRef s a-\u003ea-\u003eST s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-STRef-Lazy.html#v:writeSTRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMutable references in the (strict) ST monad (re-export of \u003ca\u003eData.STRef\u003c/a\u003e)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.STRef.Strict",
          "name": "Strict",
          "package": "base",
          "source": "src/Data-STRef-Strict.html",
          "type": "module"
        },
        "index": {
          "description": "Mutable references in the strict ST monad re-export of Data.STRef",
          "hierarchy": "Data STRef Strict",
          "module": "Data.STRef.Strict",
          "name": "Strict",
          "package": "base",
          "partial": "Strict",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-STRef-Strict.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMutable references in the (strict) ST monad.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.STRef",
          "name": "STRef",
          "package": "base",
          "source": "src/Data-STRef.html",
          "type": "module"
        },
        "index": {
          "description": "Mutable references in the strict ST monad",
          "hierarchy": "Data STRef",
          "module": "Data.STRef",
          "name": "STRef",
          "package": "base",
          "partial": "STRef",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-STRef.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea value of type \u003ccode\u003eSTRef s a\u003c/code\u003e is a mutable variable in state thread \u003ccode\u003es\u003c/code\u003e,\n containing a value of type \u003ccode\u003ea\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.STRef",
          "name": "STRef",
          "package": "base",
          "source": "src/GHC-STRef.html#STRef",
          "type": "data"
        },
        "index": {
          "description": "value of type STRef is mutable variable in state thread containing value of type",
          "hierarchy": "Data STRef",
          "module": "Data.STRef",
          "name": "STRef",
          "package": "base",
          "partial": "STRef",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-STRef.html#t:STRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMutate the contents of an \u003ccode\u003e\u003ca\u003eSTRef\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eBe warned that \u003ccode\u003e\u003ca\u003emodifySTRef\u003c/a\u003e\u003c/code\u003e does not apply the function strictly.  This\n means if the program calls \u003ccode\u003e\u003ca\u003emodifySTRef\u003c/a\u003e\u003c/code\u003e many times, but seldomly uses the\n value, thunks will pile up in memory resulting in a space leak.  This is a\n common mistake made when using an STRef as a counter.  For example, the\n following will leak memory and likely produce a stack overflow:\n\u003c/p\u003e\u003cpre\u003eprint $ runST $ do\n    ref \u003c- newSTRef 0\n    replicateM_ 1000000 $ modifySTRef ref (+1)\n    readSTRef ref\n\u003c/pre\u003e\u003cp\u003eTo avoid this problem, use \u003ccode\u003e\u003ca\u003emodifySTRef'\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Data.STRef",
          "name": "modifySTRef",
          "package": "base",
          "signature": "STRef s a -\u003e (a -\u003e a) -\u003e ST s ()",
          "source": "src/Data-STRef.html#modifySTRef",
          "type": "function"
        },
        "index": {
          "description": "Mutate the contents of an STRef Be warned that modifySTRef does not apply the function strictly This means if the program calls modifySTRef many times but seldomly uses the value thunks will pile up in memory resulting in space leak This is common mistake made when using an STRef as counter For example the following will leak memory and likely produce stack overflow print runST do ref newSTRef replicateM modifySTRef ref readSTRef ref To avoid this problem use modifySTRef instead",
          "hierarchy": "Data STRef",
          "module": "Data.STRef",
          "name": "modifySTRef",
          "normalized": "STRef a b-\u003e(b-\u003eb)-\u003eST a()",
          "package": "base",
          "partial": "STRef",
          "signature": "STRef s a-\u003e(a-\u003ea)-\u003eST s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-STRef.html#v:modifySTRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrict version of \u003ccode\u003e\u003ca\u003emodifySTRef\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.STRef",
          "name": "modifySTRef'",
          "package": "base",
          "signature": "STRef s a -\u003e (a -\u003e a) -\u003e ST s ()",
          "source": "src/Data-STRef.html#modifySTRef%27",
          "type": "function"
        },
        "index": {
          "description": "Strict version of modifySTRef",
          "hierarchy": "Data STRef",
          "module": "Data.STRef",
          "name": "modifySTRef'",
          "normalized": "STRef a b-\u003e(b-\u003eb)-\u003eST a()",
          "package": "base",
          "partial": "STRef'",
          "signature": "STRef s a-\u003e(a-\u003ea)-\u003eST s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-STRef.html#v:modifySTRef-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a new \u003ccode\u003e\u003ca\u003eSTRef\u003c/a\u003e\u003c/code\u003e in the current state thread\n\u003c/p\u003e",
          "module": "Data.STRef",
          "name": "newSTRef",
          "package": "base",
          "signature": "a -\u003e ST s (STRef s a)",
          "source": "src/GHC-STRef.html#newSTRef",
          "type": "function"
        },
        "index": {
          "description": "Build new STRef in the current state thread",
          "hierarchy": "Data STRef",
          "module": "Data.STRef",
          "name": "newSTRef",
          "normalized": "a-\u003eST b(STRef b a)",
          "package": "base",
          "partial": "STRef",
          "signature": "a-\u003eST s(STRef s a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-STRef.html#v:newSTRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the value of an \u003ccode\u003e\u003ca\u003eSTRef\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.STRef",
          "name": "readSTRef",
          "package": "base",
          "signature": "STRef s a -\u003e ST s a",
          "source": "src/GHC-STRef.html#readSTRef",
          "type": "function"
        },
        "index": {
          "description": "Read the value of an STRef",
          "hierarchy": "Data STRef",
          "module": "Data.STRef",
          "name": "readSTRef",
          "normalized": "STRef a b-\u003eST a b",
          "package": "base",
          "partial": "STRef",
          "signature": "STRef s a-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-STRef.html#v:readSTRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a new value into an \u003ccode\u003e\u003ca\u003eSTRef\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.STRef",
          "name": "writeSTRef",
          "package": "base",
          "signature": "STRef s a -\u003e a -\u003e ST s ()",
          "source": "src/GHC-STRef.html#writeSTRef",
          "type": "function"
        },
        "index": {
          "description": "Write new value into an STRef",
          "hierarchy": "Data STRef",
          "module": "Data.STRef",
          "name": "writeSTRef",
          "normalized": "STRef a b-\u003eb-\u003eST a()",
          "package": "base",
          "partial": "STRef",
          "signature": "STRef s a-\u003ea-\u003eST s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-STRef.html#v:writeSTRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003eString\u003c/code\u003e type and associated operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.String",
          "name": "String",
          "package": "base",
          "source": "src/Data-String.html",
          "type": "module"
        },
        "index": {
          "description": "The String type and associated operations",
          "hierarchy": "Data String",
          "module": "Data.String",
          "name": "String",
          "package": "base",
          "partial": "String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-String.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass for string-like datastructures; used by the overloaded string\n   extension (-foverloaded-strings in GHC).\n\u003c/p\u003e",
          "module": "Data.String",
          "name": "IsString",
          "package": "base",
          "source": "src/Data-String.html#IsString",
          "type": "class"
        },
        "index": {
          "description": "Class for string-like datastructures used by the overloaded string extension foverloaded-strings in GHC",
          "hierarchy": "Data String",
          "module": "Data.String",
          "name": "IsString",
          "package": "base",
          "partial": "Is String",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-String.html#t:IsString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e is a list of characters.  String constants in Haskell are values\n of type \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.String",
          "name": "String",
          "package": "base",
          "source": "src/GHC-Base.html#String",
          "type": "type"
        },
        "index": {
          "description": "String is list of characters String constants in Haskell are values of type String",
          "hierarchy": "Data String",
          "module": "Data.String",
          "name": "String",
          "package": "base",
          "partial": "String",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-String.html#t:String"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.String",
          "name": "fromString",
          "package": "base",
          "signature": "String -\u003e a",
          "source": "src/Data-String.html#fromString",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data String",
          "module": "Data.String",
          "name": "fromString",
          "normalized": "String-\u003ea",
          "package": "base",
          "partial": "String",
          "signature": "String-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-String.html#v:fromString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eClass of data structures that can be traversed from left to right,\n performing an action on each element.\n\u003c/p\u003e\u003cp\u003eSee also\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003cem\u003eApplicative Programming with Effects\u003c/em\u003e,\n    by Conor McBride and Ross Paterson, online at\n    \u003ca\u003ehttp://www.soi.city.ac.uk/~ross/papers/Applicative.html\u003c/a\u003e.\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eThe Essence of the Iterator Pattern\u003c/em\u003e,\n    by Jeremy Gibbons and Bruno Oliveira,\n    in \u003cem\u003eMathematically-Structured Functional Programming\u003c/em\u003e, 2006, and online at\n    \u003ca\u003ehttp://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/#iterator\u003c/a\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNote that the functions \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esequence\u003c/a\u003e\u003c/code\u003e generalize \u003ca\u003ePrelude\u003c/a\u003e\n functions of the same names from lists to any \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e functor.\n To avoid ambiguity, either import the \u003ca\u003ePrelude\u003c/a\u003e hiding these names\n or qualify uses of these function names with an alias for this module.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Traversable",
          "name": "Traversable",
          "package": "base",
          "source": "src/Data-Traversable.html",
          "type": "module"
        },
        "index": {
          "description": "Class of data structures that can be traversed from left to right performing an action on each element See also Applicative Programming with Effects by Conor McBride and Ross Paterson online at http www.soi.city.ac.uk ross papers Applicative.html The Essence of the Iterator Pattern by Jeremy Gibbons and Bruno Oliveira in Mathematically-Structured Functional Programming and online at http web.comlab.ox.ac.uk oucl work jeremy.gibbons publications iterator Note that the functions mapM and sequence generalize Prelude functions of the same names from lists to any Traversable functor To avoid ambiguity either import the Prelude hiding these names or qualify uses of these function names with an alias for this module",
          "hierarchy": "Data Traversable",
          "module": "Data.Traversable",
          "name": "Traversable",
          "package": "base",
          "partial": "Traversable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Traversable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunctors representing data structures that can be traversed from\n left to right.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003esequenceA\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eInstances are similar to \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, e.g. given a data type\n\u003c/p\u003e\u003cpre\u003e data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)\n\u003c/pre\u003e\u003cp\u003ea suitable instance would be\n\u003c/p\u003e\u003cpre\u003e instance Traversable Tree where\n    traverse f Empty = pure Empty\n    traverse f (Leaf x) = Leaf \u003c$\u003e f x\n    traverse f (Node l k r) = Node \u003c$\u003e traverse f l \u003c*\u003e f k \u003c*\u003e traverse f r\n\u003c/pre\u003e\u003cp\u003eThis is suitable even for abstract types, as the laws for \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e\n imply a form of associativity.\n\u003c/p\u003e\u003cp\u003eThe superclass instances should satisfy the following:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e In the \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e instance, \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e should be equivalent to traversal\n    with the identity applicative functor (\u003ccode\u003e\u003ca\u003efmapDefault\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003cli\u003e In the \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e instance, \u003ccode\u003e\u003ca\u003efoldMap\u003c/a\u003e\u003c/code\u003e should be\n    equivalent to traversal with a constant applicative functor\n    (\u003ccode\u003e\u003ca\u003efoldMapDefault\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Data.Traversable",
          "name": "Traversable",
          "package": "base",
          "source": "src/Data-Traversable.html#Traversable",
          "type": "class"
        },
        "index": {
          "description": "Functors representing data structures that can be traversed from left to right Minimal complete definition traverse or sequenceA Instances are similar to Functor e.g given data type data Tree Empty Leaf Node Tree Tree suitable instance would be instance Traversable Tree where traverse Empty pure Empty traverse Leaf Leaf traverse Node Node traverse traverse This is suitable even for abstract types as the laws for imply form of associativity The superclass instances should satisfy the following In the Functor instance fmap should be equivalent to traversal with the identity applicative functor fmapDefault In the Foldable instance foldMap should be equivalent to traversal with constant applicative functor foldMapDefault",
          "hierarchy": "Data Traversable",
          "module": "Data.Traversable",
          "name": "Traversable",
          "package": "base",
          "partial": "Traversable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Traversable.html#t:Traversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function may be used as a value for \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e in a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e\n   instance, provided that \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e is defined. (Using\n   \u003ccode\u003e\u003ca\u003efmapDefault\u003c/a\u003e\u003c/code\u003e with a \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e instance defined only by\n   \u003ccode\u003e\u003ca\u003esequenceA\u003c/a\u003e\u003c/code\u003e will result in infinite recursion.)\n\u003c/p\u003e",
          "module": "Data.Traversable",
          "name": "fmapDefault",
          "package": "base",
          "signature": "(a -\u003e b) -\u003e t a -\u003e t b",
          "source": "src/Data-Traversable.html#fmapDefault",
          "type": "function"
        },
        "index": {
          "description": "This function may be used as value for fmap in Functor instance provided that traverse is defined Using fmapDefault with Traversable instance defined only by sequenceA will result in infinite recursion",
          "hierarchy": "Data Traversable",
          "module": "Data.Traversable",
          "name": "fmapDefault",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "base",
          "partial": "Default",
          "signature": "(a-\u003eb)-\u003et a-\u003et b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Traversable.html#v:fmapDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function may be used as a value for \u003ccode\u003e\u003ca\u003efoldMap\u003c/a\u003e\u003c/code\u003e\n in a \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "Data.Traversable",
          "name": "foldMapDefault",
          "package": "base",
          "signature": "(a -\u003e m) -\u003e t a -\u003e m",
          "source": "src/Data-Traversable.html#foldMapDefault",
          "type": "function"
        },
        "index": {
          "description": "This function may be used as value for foldMap in Foldable instance",
          "hierarchy": "Data Traversable",
          "module": "Data.Traversable",
          "name": "foldMapDefault",
          "normalized": "(a-\u003eb)-\u003ec a-\u003eb",
          "package": "base",
          "partial": "Map Default",
          "signature": "(a-\u003em)-\u003et a-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Traversable.html#v:foldMapDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efor\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e with its arguments flipped.\n\u003c/p\u003e",
          "module": "Data.Traversable",
          "name": "for",
          "package": "base",
          "signature": "t a -\u003e (a -\u003e f b) -\u003e f (t b)",
          "source": "src/Data-Traversable.html#for",
          "type": "function"
        },
        "index": {
          "description": "for is traverse with its arguments flipped",
          "hierarchy": "Data Traversable",
          "module": "Data.Traversable",
          "name": "for",
          "normalized": "a b-\u003e(b-\u003ec d)-\u003ec(a d)",
          "package": "base",
          "signature": "t a-\u003e(a-\u003ef b)-\u003ef(t b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Traversable.html#v:for"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eforM\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e with its arguments flipped.\n\u003c/p\u003e",
          "module": "Data.Traversable",
          "name": "forM",
          "package": "base",
          "signature": "t a -\u003e (a -\u003e m b) -\u003e m (t b)",
          "source": "src/Data-Traversable.html#forM",
          "type": "function"
        },
        "index": {
          "description": "forM is mapM with its arguments flipped",
          "hierarchy": "Data Traversable",
          "module": "Data.Traversable",
          "name": "forM",
          "normalized": "a b-\u003e(b-\u003ec d)-\u003ec(a d)",
          "package": "base",
          "signature": "t a-\u003e(a-\u003em b)-\u003em(t b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Traversable.html#v:forM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e function behaves like a combination of \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e\n and \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e; it applies a function to each element of a structure,\n passing an accumulating parameter from left to right, and returning\n a final value of this accumulator together with the new structure.\n\u003c/p\u003e",
          "module": "Data.Traversable",
          "name": "mapAccumL",
          "package": "base",
          "signature": "(a -\u003e b -\u003e (a, c)) -\u003e a -\u003e t b -\u003e (a, t c)",
          "source": "src/Data-Traversable.html#mapAccumL",
          "type": "function"
        },
        "index": {
          "description": "The mapAccumL function behaves like combination of fmap and foldl it applies function to each element of structure passing an accumulating parameter from left to right and returning final value of this accumulator together with the new structure",
          "hierarchy": "Data Traversable",
          "module": "Data.Traversable",
          "name": "mapAccumL",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003ed b-\u003e(a,d c)",
          "package": "base",
          "partial": "Accum",
          "signature": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003et b-\u003e(a,t c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Traversable.html#v:mapAccumL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emapAccumR\u003c/a\u003e\u003c/code\u003e function behaves like a combination of \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e\n and \u003ccode\u003efoldr\u003c/code\u003e; it applies a function to each element of a structure,\n passing an accumulating parameter from right to left, and returning\n a final value of this accumulator together with the new structure.\n\u003c/p\u003e",
          "module": "Data.Traversable",
          "name": "mapAccumR",
          "package": "base",
          "signature": "(a -\u003e b -\u003e (a, c)) -\u003e a -\u003e t b -\u003e (a, t c)",
          "source": "src/Data-Traversable.html#mapAccumR",
          "type": "function"
        },
        "index": {
          "description": "The mapAccumR function behaves like combination of fmap and foldr it applies function to each element of structure passing an accumulating parameter from right to left and returning final value of this accumulator together with the new structure",
          "hierarchy": "Data Traversable",
          "module": "Data.Traversable",
          "name": "mapAccumR",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003ed b-\u003e(a,d c)",
          "package": "base",
          "partial": "Accum",
          "signature": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003et b-\u003e(a,t c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Traversable.html#v:mapAccumR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure to a monadic action, evaluate\n these actions from left to right, and collect the results.\n\u003c/p\u003e",
          "module": "Data.Traversable",
          "name": "mapM",
          "package": "base",
          "signature": "(a -\u003e m b) -\u003e t a -\u003e m (t b)",
          "source": "src/Data-Traversable.html#mapM",
          "type": "method"
        },
        "index": {
          "description": "Map each element of structure to monadic action evaluate these actions from left to right and collect the results",
          "hierarchy": "Data Traversable",
          "module": "Data.Traversable",
          "name": "mapM",
          "normalized": "(a-\u003eb c)-\u003ed a-\u003eb(d c)",
          "package": "base",
          "signature": "(a-\u003em b)-\u003et a-\u003em(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Traversable.html#v:mapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate each monadic action in the structure from left to right,\n and collect the results.\n\u003c/p\u003e",
          "module": "Data.Traversable",
          "name": "sequence",
          "package": "base",
          "signature": "t (m a) -\u003e m (t a)",
          "source": "src/Data-Traversable.html#sequence",
          "type": "method"
        },
        "index": {
          "description": "Evaluate each monadic action in the structure from left to right and collect the results",
          "hierarchy": "Data Traversable",
          "module": "Data.Traversable",
          "name": "sequence",
          "normalized": "a(b c)-\u003eb(a c)",
          "package": "base",
          "signature": "t(m a)-\u003em(t a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Traversable.html#v:sequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate each action in the structure from left to right,\n and collect the results.\n\u003c/p\u003e",
          "module": "Data.Traversable",
          "name": "sequenceA",
          "package": "base",
          "signature": "t (f a) -\u003e f (t a)",
          "source": "src/Data-Traversable.html#sequenceA",
          "type": "method"
        },
        "index": {
          "description": "Evaluate each action in the structure from left to right and collect the results",
          "hierarchy": "Data Traversable",
          "module": "Data.Traversable",
          "name": "sequenceA",
          "normalized": "a(b c)-\u003eb(a c)",
          "package": "base",
          "signature": "t(f a)-\u003ef(t a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Traversable.html#v:sequenceA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure to an action, evaluate\n these actions from left to right, and collect the results.\n\u003c/p\u003e",
          "module": "Data.Traversable",
          "name": "traverse",
          "package": "base",
          "signature": "(a -\u003e f b) -\u003e t a -\u003e f (t b)",
          "source": "src/Data-Traversable.html#traverse",
          "type": "method"
        },
        "index": {
          "description": "Map each element of structure to an action evaluate these actions from left to right and collect the results",
          "hierarchy": "Data Traversable",
          "module": "Data.Traversable",
          "name": "traverse",
          "normalized": "(a-\u003eb c)-\u003ed a-\u003eb(d c)",
          "package": "base",
          "signature": "(a-\u003ef b)-\u003et a-\u003ef(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Traversable.html#v:traverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe tuple data types, and associated functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Tuple",
          "name": "Tuple",
          "package": "base",
          "source": "src/Data-Tuple.html",
          "type": "module"
        },
        "index": {
          "description": "The tuple data types and associated functions",
          "hierarchy": "Data Tuple",
          "module": "Data.Tuple",
          "name": "Tuple",
          "package": "base",
          "partial": "Tuple",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Tuple.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ecurry\u003c/a\u003e\u003c/code\u003e converts an uncurried function to a curried function.\n\u003c/p\u003e",
          "module": "[\"Data.Tuple\",\"Prelude\"]",
          "name": "curry",
          "package": "base",
          "signature": "((a, b) -\u003e c) -\u003e a -\u003e b -\u003e c",
          "source": "src/Data-Tuple.html#curry",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Tuple.html#v:curry\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:curry\"]"
        },
        "index": {
          "description": "curry converts an uncurried function to curried function",
          "hierarchy": "Data Tuple",
          "module": "Data.Tuple",
          "name": "curry",
          "normalized": "((a,b)-\u003ec)-\u003ea-\u003eb-\u003ec",
          "package": "base",
          "signature": "((a,b)-\u003ec)-\u003ea-\u003eb-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Tuple.html#v:curry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the first component of a pair.\n\u003c/p\u003e",
          "module": "[\"Data.Tuple\",\"Prelude\"]",
          "name": "fst",
          "package": "base",
          "signature": "(a, b) -\u003e a",
          "source": "src/Data-Tuple.html#fst",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Tuple.html#v:fst\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:fst\"]"
        },
        "index": {
          "description": "Extract the first component of pair",
          "hierarchy": "Data Tuple",
          "module": "Data.Tuple",
          "name": "fst",
          "normalized": "(a,b)-\u003ea",
          "package": "base",
          "signature": "(a,b)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Tuple.html#v:fst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the second component of a pair.\n\u003c/p\u003e",
          "module": "[\"Data.Tuple\",\"Prelude\"]",
          "name": "snd",
          "package": "base",
          "signature": "(a, b) -\u003e b",
          "source": "src/Data-Tuple.html#snd",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Tuple.html#v:snd\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:snd\"]"
        },
        "index": {
          "description": "Extract the second component of pair",
          "hierarchy": "Data Tuple",
          "module": "Data.Tuple",
          "name": "snd",
          "normalized": "(a,b)-\u003eb",
          "package": "base",
          "signature": "(a,b)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Tuple.html#v:snd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwap the components of a pair.\n\u003c/p\u003e",
          "module": "Data.Tuple",
          "name": "swap",
          "package": "base",
          "signature": "(a, b) -\u003e (b, a)",
          "source": "src/Data-Tuple.html#swap",
          "type": "function"
        },
        "index": {
          "description": "Swap the components of pair",
          "hierarchy": "Data Tuple",
          "module": "Data.Tuple",
          "name": "swap",
          "normalized": "(a,b)-\u003e(b,a)",
          "package": "base",
          "signature": "(a,b)-\u003e(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Tuple.html#v:swap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003euncurry\u003c/a\u003e\u003c/code\u003e converts a curried function to a function on pairs.\n\u003c/p\u003e",
          "module": "[\"Data.Tuple\",\"Prelude\"]",
          "name": "uncurry",
          "package": "base",
          "signature": "(a -\u003e b -\u003e c) -\u003e (a, b) -\u003e c",
          "source": "src/Data-Tuple.html#uncurry",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Tuple.html#v:uncurry\",\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:uncurry\"]"
        },
        "index": {
          "description": "uncurry converts curried function to function on pairs",
          "hierarchy": "Data Tuple",
          "module": "Data.Tuple",
          "name": "uncurry",
          "normalized": "(a-\u003eb-\u003ec)-\u003e(a,b)-\u003ec",
          "package": "base",
          "signature": "(a-\u003eb-\u003ec)-\u003e(a,b)-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Tuple.html#v:uncurry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe representations of the types TyCon and TypeRep, and the\n function mkTyCon which is used by derived instances of Typeable to\n construct a TyCon.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Typeable.Internal",
          "name": "Internal",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html",
          "type": "module"
        },
        "index": {
          "description": "The representations of the types TyCon and TypeRep and the function mkTyCon which is used by derived instances of Typeable to construct TyCon",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "Internal",
          "package": "base",
          "partial": "Internal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "Fingerprint",
          "package": "base",
          "source": "src/GHC-Fingerprint-Type.html#Fingerprint",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "Fingerprint",
          "package": "base",
          "partial": "Fingerprint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#t:Fingerprint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abstract representation of a type constructor.  \u003ccode\u003e\u003ca\u003eTyCon\u003c/a\u003e\u003c/code\u003e objects can\n be built using \u003ccode\u003e\u003ca\u003emkTyCon\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Typeable.Internal",
          "name": "TyCon",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#TyCon",
          "type": "data"
        },
        "index": {
          "description": "An abstract representation of type constructor TyCon objects can be built using mkTyCon",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "TyCon",
          "package": "base",
          "partial": "Ty Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#t:TyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA concrete representation of a (monomorphic) type.  \u003ccode\u003e\u003ca\u003eTypeRep\u003c/a\u003e\u003c/code\u003e\n supports reasonably efficient equality.\n\u003c/p\u003e",
          "module": "Data.Typeable.Internal",
          "name": "TypeRep",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#TypeRep",
          "type": "data"
        },
        "index": {
          "description": "concrete representation of monomorphic type TypeRep supports reasonably efficient equality",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "TypeRep",
          "package": "base",
          "partial": "Type Rep",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#t:TypeRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e allows a concrete representation of a type to\n be calculated.\n\u003c/p\u003e",
          "module": "Data.Typeable.Internal",
          "name": "Typeable",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable",
          "type": "class"
        },
        "index": {
          "description": "The class Typeable allows concrete representation of type to be calculated",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "Typeable",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#t:Typeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant for unary type constructors\n\u003c/p\u003e",
          "module": "Data.Typeable.Internal",
          "name": "Typeable1",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable1",
          "type": "class"
        },
        "index": {
          "description": "Variant for unary type constructors",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "Typeable1",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#t:Typeable1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant for binary type constructors\n\u003c/p\u003e",
          "module": "Data.Typeable.Internal",
          "name": "Typeable2",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable2",
          "type": "class"
        },
        "index": {
          "description": "Variant for binary type constructors",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "Typeable2",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#t:Typeable2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant for 3-ary type constructors\n\u003c/p\u003e",
          "module": "Data.Typeable.Internal",
          "name": "Typeable3",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable3",
          "type": "class"
        },
        "index": {
          "description": "Variant for ary type constructors",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "Typeable3",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#t:Typeable3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant for 4-ary type constructors\n\u003c/p\u003e",
          "module": "Data.Typeable.Internal",
          "name": "Typeable4",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable4",
          "type": "class"
        },
        "index": {
          "description": "Variant for ary type constructors",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "Typeable4",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#t:Typeable4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant for 5-ary type constructors\n\u003c/p\u003e",
          "module": "Data.Typeable.Internal",
          "name": "Typeable5",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable5",
          "type": "class"
        },
        "index": {
          "description": "Variant for ary type constructors",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "Typeable5",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#t:Typeable5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant for 6-ary type constructors\n\u003c/p\u003e",
          "module": "Data.Typeable.Internal",
          "name": "Typeable6",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable6",
          "type": "class"
        },
        "index": {
          "description": "Variant for ary type constructors",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "Typeable6",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#t:Typeable6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant for 7-ary type constructors\n\u003c/p\u003e",
          "module": "Data.Typeable.Internal",
          "name": "Typeable7",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable7",
          "type": "class"
        },
        "index": {
          "description": "Variant for ary type constructors",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "Typeable7",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#t:Typeable7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Typeable.Internal\",\"GHC.Fingerprint.Type\",\"GHC.Fingerprint\"]",
          "name": "Fingerprint",
          "package": "base",
          "signature": "Fingerprint !Word64 !Word64",
          "source": "src/GHC-Fingerprint-Type.html#Fingerprint",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:Fingerprint\",\"http://hackage.haskell.org/package/base/docs/GHC-Fingerprint-Type.html#v:Fingerprint\",\"http://hackage.haskell.org/package/base/docs/GHC-Fingerprint.html#v:Fingerprint\"]"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "Fingerprint",
          "package": "base",
          "partial": "Fingerprint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:Fingerprint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "TyCon",
          "package": "base",
          "signature": "TyCon",
          "source": "src/Data-Typeable-Internal.html#TyCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "TyCon",
          "package": "base",
          "partial": "Ty Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:TyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "TypeRep",
          "package": "base",
          "signature": "TypeRep !Fingerprint TyCon [TypeRep]",
          "source": "src/Data-Typeable-Internal.html#TypeRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "TypeRep",
          "normalized": "TypeRep Fingerprint TyCon[TypeRep]",
          "package": "base",
          "partial": "Type Rep",
          "signature": "TypeRep Fingerprint TyCon[TypeRep]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:TypeRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplies a type to a function type.  Returns: \u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e u\u003c/code\u003e if the\n first argument represents a function of type \u003ccode\u003et -\u003e u\u003c/code\u003e and the\n second argument represents a function of type \u003ccode\u003et\u003c/code\u003e.  Otherwise,\n returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "funResultTy",
          "package": "base",
          "signature": "TypeRep -\u003e TypeRep -\u003e Maybe TypeRep",
          "source": "src/Data-Typeable-Internal.html#funResultTy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:funResultTy\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:funResultTy\"]"
        },
        "index": {
          "description": "Applies type to function type Returns Just if the first argument represents function of type and the second argument represents function of type Otherwise returns Nothing",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "funResultTy",
          "normalized": "TypeRep-\u003eTypeRep-\u003eMaybe TypeRep",
          "package": "base",
          "partial": "Result Ty",
          "signature": "TypeRep-\u003eTypeRep-\u003eMaybe TypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:funResultTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "funTc",
          "package": "base",
          "signature": "TyCon",
          "source": "src/Data-Typeable-Internal.html#funTc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "funTc",
          "package": "base",
          "partial": "Tc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:funTc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "listTc",
          "package": "base",
          "signature": "TyCon",
          "source": "src/Data-Typeable-Internal.html#listTc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "listTc",
          "package": "base",
          "partial": "Tc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:listTc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdds a TypeRep argument to a TypeRep.\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "mkAppTy",
          "package": "base",
          "signature": "TypeRep -\u003e TypeRep -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#mkAppTy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:mkAppTy\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:mkAppTy\"]"
        },
        "index": {
          "description": "Adds TypeRep argument to TypeRep",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "mkAppTy",
          "normalized": "TypeRep-\u003eTypeRep-\u003eTypeRep",
          "package": "base",
          "partial": "App Ty",
          "signature": "TypeRep-\u003eTypeRep-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:mkAppTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA special case of \u003ccode\u003e\u003ca\u003emkTyConApp\u003c/a\u003e\u003c/code\u003e, which applies the function \n type constructor to a pair of types.\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "mkFunTy",
          "package": "base",
          "signature": "TypeRep -\u003e TypeRep -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#mkFunTy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:mkFunTy\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:mkFunTy\"]"
        },
        "index": {
          "description": "special case of mkTyConApp which applies the function type constructor to pair of types",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "mkFunTy",
          "normalized": "TypeRep-\u003eTypeRep-\u003eTypeRep",
          "package": "base",
          "partial": "Fun Ty",
          "signature": "TypeRep-\u003eTypeRep-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:mkFunTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "mkTyCon",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Word-35-\"\u003eWord# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Word-35-\"\u003eWord# -\u003e String -\u003e String -\u003e String -\u003e TyCon",
          "source": "src/Data-Typeable-Internal.html#mkTyCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "mkTyCon",
          "normalized": "a b c d GHC Prim.html #t Word Word #-\u003ea b c d GHC Prim.html #t Word Word #-\u003eString-\u003eString-\u003eString-\u003eTyCon",
          "package": "base",
          "partial": "Ty Con",
          "signature": "packages archive doc html GHC Prim.html #t Word Word #-\u003epackages archive doc html GHC Prim.html #t Word Word #-\u003eString-\u003eString-\u003eString-\u003eTyCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:mkTyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuilds a \u003ccode\u003e\u003ca\u003eTyCon\u003c/a\u003e\u003c/code\u003e object representing a type constructor.  An\n implementation of \u003ca\u003eData.Typeable\u003c/a\u003e should ensure that the following holds:\n\u003c/p\u003e\u003cpre\u003e  A==A' ^ B==B' ^ C==C' ==\u003e mkTyCon A B C == mkTyCon A' B' C'\n\u003c/pre\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "mkTyCon3",
          "package": "base",
          "signature": "String-\u003e String-\u003e String-\u003e TyCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:mkTyCon3\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:mkTyCon3\"]"
        },
        "index": {
          "description": "Builds TyCon object representing type constructor An implementation of Data.Typeable should ensure that the following holds mkTyCon mkTyCon",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "mkTyCon3",
          "normalized": "String-\u003eString-\u003eString-\u003eTyCon",
          "package": "base",
          "partial": "Ty Con",
          "signature": "String-\u003eString-\u003eString-\u003eTyCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:mkTyCon3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplies a type constructor to a sequence of types\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "mkTyConApp",
          "package": "base",
          "signature": "TyCon -\u003e [TypeRep] -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#mkTyConApp",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:mkTyConApp\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:mkTyConApp\"]"
        },
        "index": {
          "description": "Applies type constructor to sequence of types",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "mkTyConApp",
          "normalized": "TyCon-\u003e[TypeRep]-\u003eTypeRep",
          "package": "base",
          "partial": "Ty Con App",
          "signature": "TyCon-\u003e[TypeRep]-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:mkTyConApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "showsTypeRep",
          "package": "base",
          "signature": "TypeRep -\u003e ShowS",
          "source": "src/Data-Typeable-Internal.html#showsTypeRep",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:showsTypeRep\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:showsTypeRep\"]"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "showsTypeRep",
          "normalized": "TypeRep-\u003eShowS",
          "package": "base",
          "partial": "Type Rep",
          "signature": "TypeRep-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:showsTypeRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplits a type constructor application\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "splitTyConApp",
          "package": "base",
          "signature": "TypeRep -\u003e (TyCon, [TypeRep])",
          "source": "src/Data-Typeable-Internal.html#splitTyConApp",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:splitTyConApp\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:splitTyConApp\"]"
        },
        "index": {
          "description": "Splits type constructor application",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "splitTyConApp",
          "normalized": "TypeRep-\u003e(TyCon,[TypeRep])",
          "package": "base",
          "partial": "Ty Con App",
          "signature": "TypeRep-\u003e(TyCon,[TypeRep])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:splitTyConApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "tyConHash",
          "package": "base",
          "signature": "Fingerprint",
          "source": "src/Data-Typeable-Internal.html#TyCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "tyConHash",
          "package": "base",
          "partial": "Con Hash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:tyConHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "tyConModule",
          "package": "base",
          "signature": "String",
          "source": "src/Data-Typeable-Internal.html#TyCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "tyConModule",
          "package": "base",
          "partial": "Con Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:tyConModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "tyConName",
          "package": "base",
          "signature": "String",
          "source": "src/Data-Typeable-Internal.html#TyCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "tyConName",
          "package": "base",
          "partial": "Con Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:tyConName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "tyConPackage",
          "package": "base",
          "signature": "String",
          "source": "src/Data-Typeable-Internal.html#TyCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "tyConPackage",
          "package": "base",
          "partial": "Con Package",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:tyConPackage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: renamed to tyConName; tyConModule and tyConPackage are also available.\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eObserve string encoding of a type representation\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "tyConString",
          "package": "base",
          "signature": "TyCon -\u003e String",
          "source": "src/Data-Typeable-Internal.html#tyConString",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:tyConString\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:tyConString\"]"
        },
        "index": {
          "description": "Deprecated renamed to tyConName tyConModule and tyConPackage are also available Observe string encoding of type representation",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "tyConString",
          "normalized": "TyCon-\u003eString",
          "package": "base",
          "partial": "Con String",
          "signature": "TyCon-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:tyConString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes a value of type \u003ccode\u003ea\u003c/code\u003e and returns a concrete representation\n of that type.  The \u003cem\u003evalue\u003c/em\u003e of the argument should be ignored by\n any instance of \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e, so that it is safe to pass \u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e as\n the argument.\n\u003c/p\u003e",
          "module": "Data.Typeable.Internal",
          "name": "typeOf",
          "package": "base",
          "signature": "a -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf",
          "type": "method"
        },
        "index": {
          "description": "Takes value of type and returns concrete representation of that type The value of the argument should be ignored by any instance of Typeable so that it is safe to pass undefined as the argument",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOf",
          "normalized": "a-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "a-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "typeOf1",
          "package": "base",
          "signature": "t a -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOf1",
          "normalized": "a b-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "t a-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor defining a \u003ccode\u003e\u003ca\u003eTypeable1\u003c/a\u003e\u003c/code\u003e instance from any \u003ccode\u003e\u003ca\u003eTypeable2\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "typeOf1Default",
          "package": "base",
          "signature": "t a b -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf1Default",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf1Default\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOf1Default\"]"
        },
        "index": {
          "description": "For defining Typeable1 instance from any Typeable2 instance",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOf1Default",
          "normalized": "a b c-\u003eTypeRep",
          "package": "base",
          "partial": "Of Default",
          "signature": "t a b-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf1Default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "typeOf2",
          "package": "base",
          "signature": "t a b -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOf2",
          "normalized": "a b c-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "t a b-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor defining a \u003ccode\u003e\u003ca\u003eTypeable2\u003c/a\u003e\u003c/code\u003e instance from any \u003ccode\u003e\u003ca\u003eTypeable3\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "typeOf2Default",
          "package": "base",
          "signature": "t a b c -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf2Default",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf2Default\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOf2Default\"]"
        },
        "index": {
          "description": "For defining Typeable2 instance from any Typeable3 instance",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOf2Default",
          "normalized": "a b c d-\u003eTypeRep",
          "package": "base",
          "partial": "Of Default",
          "signature": "t a b c-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf2Default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "typeOf3",
          "package": "base",
          "signature": "t a b c -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf3",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOf3",
          "normalized": "a b c d-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "t a b c-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor defining a \u003ccode\u003e\u003ca\u003eTypeable3\u003c/a\u003e\u003c/code\u003e instance from any \u003ccode\u003e\u003ca\u003eTypeable4\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "typeOf3Default",
          "package": "base",
          "signature": "t a b c d -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf3Default",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf3Default\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOf3Default\"]"
        },
        "index": {
          "description": "For defining Typeable3 instance from any Typeable4 instance",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOf3Default",
          "normalized": "a b c d e-\u003eTypeRep",
          "package": "base",
          "partial": "Of Default",
          "signature": "t a b c d-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf3Default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "typeOf4",
          "package": "base",
          "signature": "t a b c d -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf4",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOf4",
          "normalized": "a b c d e-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "t a b c d-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor defining a \u003ccode\u003e\u003ca\u003eTypeable4\u003c/a\u003e\u003c/code\u003e instance from any \u003ccode\u003e\u003ca\u003eTypeable5\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "typeOf4Default",
          "package": "base",
          "signature": "t a b c d e -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf4Default",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf4Default\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOf4Default\"]"
        },
        "index": {
          "description": "For defining Typeable4 instance from any Typeable5 instance",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOf4Default",
          "normalized": "a b c d e f-\u003eTypeRep",
          "package": "base",
          "partial": "Of Default",
          "signature": "t a b c d e-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf4Default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "typeOf5",
          "package": "base",
          "signature": "t a b c d e -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf5",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOf5",
          "normalized": "a b c d e f-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "t a b c d e-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor defining a \u003ccode\u003e\u003ca\u003eTypeable5\u003c/a\u003e\u003c/code\u003e instance from any \u003ccode\u003e\u003ca\u003eTypeable6\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "typeOf5Default",
          "package": "base",
          "signature": "t a b c d e f -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf5Default",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf5Default\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOf5Default\"]"
        },
        "index": {
          "description": "For defining Typeable5 instance from any Typeable6 instance",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOf5Default",
          "normalized": "a b c d e f g-\u003eTypeRep",
          "package": "base",
          "partial": "Of Default",
          "signature": "t a b c d e f-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf5Default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "typeOf6",
          "package": "base",
          "signature": "t a b c d e f -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf6",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOf6",
          "normalized": "a b c d e f g-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "t a b c d e f-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor defining a \u003ccode\u003e\u003ca\u003eTypeable6\u003c/a\u003e\u003c/code\u003e instance from any \u003ccode\u003e\u003ca\u003eTypeable7\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "typeOf6Default",
          "package": "base",
          "signature": "t a b c d e f g -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf6Default",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf6Default\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOf6Default\"]"
        },
        "index": {
          "description": "For defining Typeable6 instance from any Typeable7 instance",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOf6Default",
          "normalized": "a b c d e f g h-\u003eTypeRep",
          "package": "base",
          "partial": "Of Default",
          "signature": "t a b c d e f g-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf6Default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Internal",
          "name": "typeOf7",
          "package": "base",
          "signature": "t a b c d e f g -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf7",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOf7",
          "normalized": "a b c d e f g h-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "t a b c d e f g-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOf7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor defining a \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e instance from any \u003ccode\u003e\u003ca\u003eTypeable1\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "typeOfDefault",
          "package": "base",
          "signature": "t a -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOfDefault",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOfDefault\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOfDefault\"]"
        },
        "index": {
          "description": "For defining Typeable instance from any Typeable1 instance",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeOfDefault",
          "normalized": "a b-\u003eTypeRep",
          "package": "base",
          "partial": "Of Default",
          "signature": "t a-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeOfDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObserve the argument types of a type representation\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "typeRepArgs",
          "package": "base",
          "signature": "TypeRep -\u003e [TypeRep]",
          "source": "src/Data-Typeable-Internal.html#typeRepArgs",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeRepArgs\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeRepArgs\"]"
        },
        "index": {
          "description": "Observe the argument types of type representation",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeRepArgs",
          "normalized": "TypeRep-\u003e[TypeRep]",
          "package": "base",
          "partial": "Rep Args",
          "signature": "TypeRep-\u003e[TypeRep]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeRepArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObserve the type constructor of a type representation\n\u003c/p\u003e",
          "module": "[\"Data.Typeable.Internal\",\"Data.Typeable\"]",
          "name": "typeRepTyCon",
          "package": "base",
          "signature": "TypeRep -\u003e TyCon",
          "source": "src/Data-Typeable-Internal.html#typeRepTyCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeRepTyCon\",\"http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeRepTyCon\"]"
        },
        "index": {
          "description": "Observe the type constructor of type representation",
          "hierarchy": "Data Typeable Internal",
          "module": "Data.Typeable.Internal",
          "name": "typeRepTyCon",
          "normalized": "TypeRep-\u003eTyCon",
          "package": "base",
          "partial": "Rep Ty Con",
          "signature": "TypeRep-\u003eTyCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable-Internal.html#v:typeRepTyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e class reifies types to some extent by associating type\n representations to types. These type representations can be compared,\n and one can in turn define a type-safe cast operation. To this end,\n an unsafe cast is guarded by a test for type (representation)\n equivalence. The module \u003ca\u003eData.Dynamic\u003c/a\u003e uses Typeable for an\n implementation of dynamics. The module \u003ca\u003eData.Data\u003c/a\u003e uses Typeable\n and type-safe cast (but not dynamics) to support the \"Scrap your\n boilerplate\" style of generic programming.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Typeable",
          "name": "Typeable",
          "package": "base",
          "source": "src/Data-Typeable.html",
          "type": "module"
        },
        "index": {
          "description": "The Typeable class reifies types to some extent by associating type representations to types These type representations can be compared and one can in turn define type-safe cast operation To this end an unsafe cast is guarded by test for type representation equivalence The module Data.Dynamic uses Typeable for an implementation of dynamics The module Data.Data uses Typeable and type-safe cast but not dynamics to support the Scrap your boilerplate style of generic programming",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "Typeable",
          "package": "base",
          "partial": "Typeable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abstract representation of a type constructor.  \u003ccode\u003e\u003ca\u003eTyCon\u003c/a\u003e\u003c/code\u003e objects can\n be built using \u003ccode\u003e\u003ca\u003emkTyCon\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "TyCon",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#TyCon",
          "type": "data"
        },
        "index": {
          "description": "An abstract representation of type constructor TyCon objects can be built using mkTyCon",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "TyCon",
          "package": "base",
          "partial": "Ty Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#t:TyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA concrete representation of a (monomorphic) type.  \u003ccode\u003e\u003ca\u003eTypeRep\u003c/a\u003e\u003c/code\u003e\n supports reasonably efficient equality.\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "TypeRep",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#TypeRep",
          "type": "data"
        },
        "index": {
          "description": "concrete representation of monomorphic type TypeRep supports reasonably efficient equality",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "TypeRep",
          "package": "base",
          "partial": "Type Rep",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#t:TypeRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable",
          "name": "TypeRepKey",
          "package": "base",
          "source": "src/Data-Typeable.html#TypeRepKey",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "TypeRepKey",
          "package": "base",
          "partial": "Type Rep Key",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#t:TypeRepKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e allows a concrete representation of a type to\n be calculated.\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "Typeable",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable",
          "type": "class"
        },
        "index": {
          "description": "The class Typeable allows concrete representation of type to be calculated",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "Typeable",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#t:Typeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant for unary type constructors\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "Typeable1",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable1",
          "type": "class"
        },
        "index": {
          "description": "Variant for unary type constructors",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "Typeable1",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#t:Typeable1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant for binary type constructors\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "Typeable2",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable2",
          "type": "class"
        },
        "index": {
          "description": "Variant for binary type constructors",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "Typeable2",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#t:Typeable2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant for 3-ary type constructors\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "Typeable3",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable3",
          "type": "class"
        },
        "index": {
          "description": "Variant for ary type constructors",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "Typeable3",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#t:Typeable3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant for 4-ary type constructors\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "Typeable4",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable4",
          "type": "class"
        },
        "index": {
          "description": "Variant for ary type constructors",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "Typeable4",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#t:Typeable4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant for 5-ary type constructors\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "Typeable5",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable5",
          "type": "class"
        },
        "index": {
          "description": "Variant for ary type constructors",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "Typeable5",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#t:Typeable5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant for 6-ary type constructors\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "Typeable6",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable6",
          "type": "class"
        },
        "index": {
          "description": "Variant for ary type constructors",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "Typeable6",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#t:Typeable6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant for 7-ary type constructors\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "Typeable7",
          "package": "base",
          "source": "src/Data-Typeable-Internal.html#Typeable7",
          "type": "class"
        },
        "index": {
          "description": "Variant for ary type constructors",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "Typeable7",
          "package": "base",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#t:Typeable7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type-safe cast operation\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "cast",
          "package": "base",
          "signature": "a -\u003e Maybe b",
          "source": "src/Data-Typeable.html#cast",
          "type": "function"
        },
        "index": {
          "description": "The type-safe cast operation",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "cast",
          "normalized": "a-\u003eMaybe b",
          "package": "base",
          "signature": "a-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:cast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA flexible variation parameterised in a type constructor\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "gcast",
          "package": "base",
          "signature": "c a -\u003e Maybe (c b)",
          "source": "src/Data-Typeable.html#gcast",
          "type": "function"
        },
        "index": {
          "description": "flexible variation parameterised in type constructor",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "gcast",
          "normalized": "a b-\u003eMaybe(a c)",
          "package": "base",
          "signature": "c a-\u003eMaybe(c b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:gcast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast for * -\u003e *\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "gcast1",
          "package": "base",
          "signature": "c (t a) -\u003e Maybe (c (t' a))",
          "source": "src/Data-Typeable.html#gcast1",
          "type": "function"
        },
        "index": {
          "description": "Cast for",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "gcast1",
          "normalized": "a(b c)-\u003eMaybe(a(d c))",
          "package": "base",
          "signature": "c(t a)-\u003eMaybe(c(t' a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:gcast1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast for * -\u003e * -\u003e *\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "gcast2",
          "package": "base",
          "signature": "c (t a b) -\u003e Maybe (c (t' a b))",
          "source": "src/Data-Typeable.html#gcast2",
          "type": "function"
        },
        "index": {
          "description": "Cast for",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "gcast2",
          "normalized": "a(b c d)-\u003eMaybe(a(e c d))",
          "package": "base",
          "signature": "c(t a b)-\u003eMaybe(c(t' a b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:gcast2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: either derive Typeable, or use mkTyCon3 instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eBackwards-compatible API\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "mkTyCon",
          "package": "base",
          "signature": "String-\u003e TyCon",
          "type": "function"
        },
        "index": {
          "description": "Deprecated either derive Typeable or use mkTyCon3 instead Backwards-compatible API",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "mkTyCon",
          "normalized": "String-\u003eTyCon",
          "package": "base",
          "partial": "Ty Con",
          "signature": "String-\u003eTyCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:mkTyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable",
          "name": "tyConModule",
          "package": "base",
          "signature": "TyCon -\u003e String",
          "source": "src/Data-Typeable-Internal.html#tyConModule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "tyConModule",
          "normalized": "TyCon-\u003eString",
          "package": "base",
          "partial": "Con Module",
          "signature": "TyCon-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:tyConModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable",
          "name": "tyConName",
          "package": "base",
          "signature": "TyCon -\u003e String",
          "source": "src/Data-Typeable-Internal.html#tyConName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "tyConName",
          "normalized": "TyCon-\u003eString",
          "package": "base",
          "partial": "Con Name",
          "signature": "TyCon-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:tyConName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable",
          "name": "tyConPackage",
          "package": "base",
          "signature": "TyCon -\u003e String",
          "source": "src/Data-Typeable-Internal.html#tyConPackage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "tyConPackage",
          "normalized": "TyCon-\u003eString",
          "package": "base",
          "partial": "Con Package",
          "signature": "TyCon-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:tyConPackage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes a value of type \u003ccode\u003ea\u003c/code\u003e and returns a concrete representation\n of that type.  The \u003cem\u003evalue\u003c/em\u003e of the argument should be ignored by\n any instance of \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e, so that it is safe to pass \u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e as\n the argument.\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "typeOf",
          "package": "base",
          "signature": "a -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf",
          "type": "method"
        },
        "index": {
          "description": "Takes value of type and returns concrete representation of that type The value of the argument should be ignored by any instance of Typeable so that it is safe to pass undefined as the argument",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "typeOf",
          "normalized": "a-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "a-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable",
          "name": "typeOf1",
          "package": "base",
          "signature": "t a -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "typeOf1",
          "normalized": "a b-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "t a-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOf1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable",
          "name": "typeOf2",
          "package": "base",
          "signature": "t a b -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "typeOf2",
          "normalized": "a b c-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "t a b-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOf2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable",
          "name": "typeOf3",
          "package": "base",
          "signature": "t a b c -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf3",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "typeOf3",
          "normalized": "a b c d-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "t a b c-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOf3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable",
          "name": "typeOf4",
          "package": "base",
          "signature": "t a b c d -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf4",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "typeOf4",
          "normalized": "a b c d e-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "t a b c d-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOf4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable",
          "name": "typeOf5",
          "package": "base",
          "signature": "t a b c d e -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf5",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "typeOf5",
          "normalized": "a b c d e f-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "t a b c d e-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOf5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable",
          "name": "typeOf6",
          "package": "base",
          "signature": "t a b c d e f -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf6",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "typeOf6",
          "normalized": "a b c d e f g-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "t a b c d e f-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOf6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable",
          "name": "typeOf7",
          "package": "base",
          "signature": "t a b c d e f g -\u003e TypeRep",
          "source": "src/Data-Typeable-Internal.html#typeOf7",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "typeOf7",
          "normalized": "a b c d e f g h-\u003eTypeRep",
          "package": "base",
          "partial": "Of",
          "signature": "t a b c d e f g-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeOf7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: TypeRep itself is now an instance of Ord\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003e(DEPRECATED) Returns a unique key associated with a \u003ccode\u003e\u003ca\u003eTypeRep\u003c/a\u003e\u003c/code\u003e.\n This function is deprecated because \u003ccode\u003e\u003ca\u003eTypeRep\u003c/a\u003e\u003c/code\u003e itself is now an\n instance of \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e, so mappings can be made directly with \u003ccode\u003e\u003ca\u003eTypeRep\u003c/a\u003e\u003c/code\u003e\n as the key.\n\u003c/p\u003e",
          "module": "Data.Typeable",
          "name": "typeRepKey",
          "package": "base",
          "signature": "TypeRep -\u003e IO TypeRepKey",
          "source": "src/Data-Typeable.html#typeRepKey",
          "type": "function"
        },
        "index": {
          "description": "Deprecated TypeRep itself is now an instance of Ord DEPRECATED Returns unique key associated with TypeRep This function is deprecated because TypeRep itself is now an instance of Ord so mappings can be made directly with TypeRep as the key",
          "hierarchy": "Data Typeable",
          "module": "Data.Typeable",
          "name": "typeRepKey",
          "normalized": "TypeRep-\u003eIO TypeRepKey",
          "package": "base",
          "partial": "Rep Key",
          "signature": "TypeRep-\u003eIO TypeRepKey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Typeable.html#v:typeRepKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn abstract interface to a unique symbol generator.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Unique",
          "name": "Unique",
          "package": "base",
          "source": "src/Data-Unique.html",
          "type": "module"
        },
        "index": {
          "description": "An abstract interface to unique symbol generator",
          "hierarchy": "Data Unique",
          "module": "Data.Unique",
          "name": "Unique",
          "package": "base",
          "partial": "Unique",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Unique.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abstract unique object.  Objects of type \u003ccode\u003e\u003ca\u003eUnique\u003c/a\u003e\u003c/code\u003e may be\n compared for equality and ordering and hashed into \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Unique",
          "name": "Unique",
          "package": "base",
          "source": "src/Data-Unique.html#Unique",
          "type": "data"
        },
        "index": {
          "description": "An abstract unique object Objects of type Unique may be compared for equality and ordering and hashed into Int",
          "hierarchy": "Data Unique",
          "module": "Data.Unique",
          "name": "Unique",
          "package": "base",
          "partial": "Unique",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Unique.html#t:Unique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHashes a \u003ccode\u003e\u003ca\u003eUnique\u003c/a\u003e\u003c/code\u003e into an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.  Two \u003ccode\u003e\u003ca\u003eUnique\u003c/a\u003e\u003c/code\u003es may hash to the\n same value, although in practice this is unlikely.  The \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n returned makes a good hash key.\n\u003c/p\u003e",
          "module": "Data.Unique",
          "name": "hashUnique",
          "package": "base",
          "signature": "Unique -\u003e Int",
          "source": "src/Data-Unique.html#hashUnique",
          "type": "function"
        },
        "index": {
          "description": "Hashes Unique into an Int Two Unique may hash to the same value although in practice this is unlikely The Int returned makes good hash key",
          "hierarchy": "Data Unique",
          "module": "Data.Unique",
          "name": "hashUnique",
          "normalized": "Unique-\u003eInt",
          "package": "base",
          "partial": "Unique",
          "signature": "Unique-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Unique.html#v:hashUnique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a new object of type \u003ccode\u003e\u003ca\u003eUnique\u003c/a\u003e\u003c/code\u003e.  The value returned will\n not compare equal to any other value of type \u003ccode\u003e\u003ca\u003eUnique\u003c/a\u003e\u003c/code\u003e returned by\n previous calls to \u003ccode\u003e\u003ca\u003enewUnique\u003c/a\u003e\u003c/code\u003e.  There is no limit on the number of\n times \u003ccode\u003e\u003ca\u003enewUnique\u003c/a\u003e\u003c/code\u003e may be called.\n\u003c/p\u003e",
          "module": "Data.Unique",
          "name": "newUnique",
          "package": "base",
          "signature": "IO Unique",
          "source": "src/Data-Unique.html#newUnique",
          "type": "function"
        },
        "index": {
          "description": "Creates new object of type Unique The value returned will not compare equal to any other value of type Unique returned by previous calls to newUnique There is no limit on the number of times newUnique may be called",
          "hierarchy": "Data Unique",
          "module": "Data.Unique",
          "name": "newUnique",
          "package": "base",
          "partial": "Unique",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Unique.html#v:newUnique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA general library for representation and manipulation of versions.\n\u003c/p\u003e\u003cp\u003eVersioning schemes are many and varied, so the version\n representation provided by this library is intended to be a\n compromise between complete generality, where almost no common\n functionality could reasonably be provided, and fixing a particular\n versioning scheme, which would probably be too restrictive.\n\u003c/p\u003e\u003cp\u003eSo the approach taken here is to provide a representation which\n subsumes many of the versioning schemes commonly in use, and we\n provide implementations of \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e and conversion to/from \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n which will be appropriate for some applications, but not all.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Version",
          "name": "Version",
          "package": "base",
          "source": "src/Data-Version.html",
          "type": "module"
        },
        "index": {
          "description": "general library for representation and manipulation of versions Versioning schemes are many and varied so the version representation provided by this library is intended to be compromise between complete generality where almost no common functionality could reasonably be provided and fixing particular versioning scheme which would probably be too restrictive So the approach taken here is to provide representation which subsumes many of the versioning schemes commonly in use and we provide implementations of Eq Ord and conversion to from String which will be appropriate for some applications but not all",
          "hierarchy": "Data Version",
          "module": "Data.Version",
          "name": "Version",
          "package": "base",
          "partial": "Version",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Version.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eVersion\u003c/a\u003e\u003c/code\u003e represents the version of a software entity.  \n\u003c/p\u003e\u003cp\u003eAn instance of \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e is provided, which implements exact equality\nmodulo reordering of the tags in the \u003ccode\u003e\u003ca\u003eversionTags\u003c/a\u003e\u003c/code\u003e field.\n\u003c/p\u003e\u003cp\u003eAn instance of \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e is also provided, which gives lexicographic\nordering on the \u003ccode\u003e\u003ca\u003eversionBranch\u003c/a\u003e\u003c/code\u003e fields (i.e. 2.1 \u003e 2.0, 1.2.3 \u003e 1.2.2,\netc.).  This is expected to be sufficient for many uses, but note that\nyou may need to use a more specific ordering for your versioning\nscheme.  For example, some versioning schemes may include pre-releases\nwhich have tags \u003ccode\u003e\"pre1\"\u003c/code\u003e, \u003ccode\u003e\"pre2\"\u003c/code\u003e, and so on, and these would need to\nbe taken into account when determining ordering.  In some cases, date\nordering may be more appropriate, so the application would have to\nlook for \u003ccode\u003edate\u003c/code\u003e tags in the \u003ccode\u003e\u003ca\u003eversionTags\u003c/a\u003e\u003c/code\u003e field and compare those.\nThe bottom line is, don't always assume that \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e and other \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e\noperations are the right thing for every \u003ccode\u003e\u003ca\u003eVersion\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSimilarly, concrete representations of versions may differ.  One\npossible concrete representation is provided (see \u003ccode\u003e\u003ca\u003eshowVersion\u003c/a\u003e\u003c/code\u003e and\n\u003ccode\u003e\u003ca\u003eparseVersion\u003c/a\u003e\u003c/code\u003e), but depending on the application a different concrete\nrepresentation may be more appropriate.\n\u003c/p\u003e",
          "module": "Data.Version",
          "name": "Version",
          "package": "base",
          "source": "src/Data-Version.html#Version",
          "type": "data"
        },
        "index": {
          "description": "Version represents the version of software entity An instance of Eq is provided which implements exact equality modulo reordering of the tags in the versionTags field An instance of Ord is also provided which gives lexicographic ordering on the versionBranch fields i.e etc This is expected to be sufficient for many uses but note that you may need to use more specific ordering for your versioning scheme For example some versioning schemes may include pre-releases which have tags pre1 pre2 and so on and these would need to be taken into account when determining ordering In some cases date ordering may be more appropriate so the application would have to look for date tags in the versionTags field and compare those The bottom line is don always assume that compare and other Ord operations are the right thing for every Version Similarly concrete representations of versions may differ One possible concrete representation is provided see showVersion and parseVersion but depending on the application different concrete representation may be more appropriate",
          "hierarchy": "Data Version",
          "module": "Data.Version",
          "name": "Version",
          "package": "base",
          "partial": "Version",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Version.html#t:Version"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Version",
          "name": "Version",
          "package": "base",
          "signature": "Version",
          "source": "src/Data-Version.html#Version",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Version",
          "module": "Data.Version",
          "name": "Version",
          "package": "base",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Version.html#v:Version"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA parser for versions in the format produced by \u003ccode\u003e\u003ca\u003eshowVersion\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Version",
          "name": "parseVersion",
          "package": "base",
          "signature": "ReadP Version",
          "source": "src/Data-Version.html#parseVersion",
          "type": "function"
        },
        "index": {
          "description": "parser for versions in the format produced by showVersion",
          "hierarchy": "Data Version",
          "module": "Data.Version",
          "name": "parseVersion",
          "package": "base",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Version.html#v:parseVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides one possible concrete representation for \u003ccode\u003e\u003ca\u003eVersion\u003c/a\u003e\u003c/code\u003e.  For\n a version with \u003ccode\u003e\u003ca\u003eversionBranch\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e= [1,2,3]\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eversionTags\u003c/a\u003e\u003c/code\u003e \n \u003ccode\u003e= [\"tag1\",\"tag2\"]\u003c/code\u003e, the output will be \u003ccode\u003e1.2.3-tag1-tag2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Version",
          "name": "showVersion",
          "package": "base",
          "signature": "Version -\u003e String",
          "source": "src/Data-Version.html#showVersion",
          "type": "function"
        },
        "index": {
          "description": "Provides one possible concrete representation for Version For version with versionBranch and versionTags tag1 tag2 the output will be tag1-tag2",
          "hierarchy": "Data Version",
          "module": "Data.Version",
          "name": "showVersion",
          "normalized": "Version-\u003eString",
          "package": "base",
          "partial": "Version",
          "signature": "Version-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Version.html#v:showVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe numeric branch for this version.  This reflects the\n fact that most software versions are tree-structured; there\n is a main trunk which is tagged with versions at various\n points (1,2,3...), and the first branch off the trunk after\n version 3 is 3.1, the second branch off the trunk after\n version 3 is 3.2, and so on.  The tree can be branched\n arbitrarily, just by adding more digits.\n\u003c/p\u003e\u003cp\u003eWe represent the branch as a list of \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e, so\n version 3.2.1 becomes [3,2,1].  Lexicographic ordering\n (i.e. the default instance of \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e[Int]\u003c/code\u003e) gives\n the natural ordering of branches.\n\u003c/p\u003e",
          "module": "Data.Version",
          "name": "versionBranch",
          "package": "base",
          "signature": "[Int]",
          "source": "src/Data-Version.html#Version",
          "type": "function"
        },
        "index": {
          "description": "The numeric branch for this version This reflects the fact that most software versions are tree-structured there is main trunk which is tagged with versions at various points and the first branch off the trunk after version is the second branch off the trunk after version is and so on The tree can be branched arbitrarily just by adding more digits We represent the branch as list of Int so version becomes Lexicographic ordering i.e the default instance of Ord for Int gives the natural ordering of branches",
          "hierarchy": "Data Version",
          "module": "Data.Version",
          "name": "versionBranch",
          "normalized": "[Int]",
          "package": "base",
          "partial": "Branch",
          "signature": "[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Version.html#v:versionBranch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version can be tagged with an arbitrary list of strings.\n The interpretation of the list of tags is entirely dependent\n on the entity that this version applies to.\n\u003c/p\u003e",
          "module": "Data.Version",
          "name": "versionTags",
          "package": "base",
          "signature": "[String]",
          "source": "src/Data-Version.html#Version",
          "type": "function"
        },
        "index": {
          "description": "version can be tagged with an arbitrary list of strings The interpretation of the list of tags is entirely dependent on the entity that this version applies to",
          "hierarchy": "Data Version",
          "module": "Data.Version",
          "name": "versionTags",
          "normalized": "[String]",
          "package": "base",
          "partial": "Tags",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Version.html#v:versionTags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnsigned integer types.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Word",
          "name": "Word",
          "package": "base",
          "source": "src/Data-Word.html",
          "type": "module"
        },
        "index": {
          "description": "Unsigned integer types",
          "hierarchy": "Data Word",
          "module": "Data.Word",
          "name": "Word",
          "package": "base",
          "partial": "Word",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Word.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e is an unsigned integral type, with the same size as \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Word",
          "name": "Word",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "Word is an unsigned integral type with the same size as Int",
          "hierarchy": "Data Word",
          "module": "Data.Word",
          "name": "Word",
          "package": "base",
          "partial": "Word",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Word.html#t:Word"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e16-bit unsigned integer type\n\u003c/p\u003e",
          "module": "Data.Word",
          "name": "Word16",
          "package": "base",
          "source": "src/GHC-Word.html#Word16",
          "type": "data"
        },
        "index": {
          "description": "bit unsigned integer type",
          "hierarchy": "Data Word",
          "module": "Data.Word",
          "name": "Word16",
          "package": "base",
          "partial": "Word",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Word.html#t:Word16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e32-bit unsigned integer type\n\u003c/p\u003e",
          "module": "Data.Word",
          "name": "Word32",
          "package": "base",
          "source": "src/GHC-Word.html#Word32",
          "type": "data"
        },
        "index": {
          "description": "bit unsigned integer type",
          "hierarchy": "Data Word",
          "module": "Data.Word",
          "name": "Word32",
          "package": "base",
          "partial": "Word",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Word.html#t:Word32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e64-bit unsigned integer type\n\u003c/p\u003e",
          "module": "Data.Word",
          "name": "Word64",
          "package": "base",
          "source": "src/GHC-Word.html#Word64",
          "type": "data"
        },
        "index": {
          "description": "bit unsigned integer type",
          "hierarchy": "Data Word",
          "module": "Data.Word",
          "name": "Word64",
          "package": "base",
          "partial": "Word",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Word.html#t:Word64"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8-bit unsigned integer type\n\u003c/p\u003e",
          "module": "Data.Word",
          "name": "Word8",
          "package": "base",
          "source": "src/GHC-Word.html#Word8",
          "type": "data"
        },
        "index": {
          "description": "bit unsigned integer type",
          "hierarchy": "Data Word",
          "module": "Data.Word",
          "name": "Word8",
          "package": "base",
          "partial": "Word",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Data-Word.html#t:Word8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions for tracing and monitoring execution.\n\u003c/p\u003e\u003cp\u003eThese can be useful for investigating bugs or performance problems.\n They should \u003cem\u003enot\u003c/em\u003e be used in production code.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Debug.Trace",
          "name": "Trace",
          "package": "base",
          "source": "src/Debug-Trace.html",
          "type": "module"
        },
        "index": {
          "description": "Functions for tracing and monitoring execution These can be useful for investigating bugs or performance problems They should not be used in production code",
          "hierarchy": "Debug Trace",
          "module": "Debug.Trace",
          "name": "Trace",
          "package": "base",
          "partial": "Trace",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Debug-Trace.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use Debug.Trace.traceIO\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eDeprecated. Use \u003ccode\u003e\u003ca\u003etraceIO\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Debug.Trace",
          "name": "putTraceMsg",
          "package": "base",
          "signature": "String -\u003e IO ()",
          "source": "src/Debug-Trace.html#putTraceMsg",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use Debug.Trace.traceIO Deprecated Use traceIO",
          "hierarchy": "Debug Trace",
          "module": "Debug.Trace",
          "name": "putTraceMsg",
          "normalized": "String-\u003eIO()",
          "package": "base",
          "partial": "Trace Msg",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Debug-Trace.html#v:putTraceMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003etrace\u003c/a\u003e\u003c/code\u003e function outputs the trace message given as its first argument,\nbefore returning the second argument as its result.\n\u003c/p\u003e\u003cp\u003eFor example, this returns the value of \u003ccode\u003ef x\u003c/code\u003e but first outputs the message.\n\u003c/p\u003e\u003cpre\u003e trace (\"calling f with x = \" ++ show x) (f x)\n\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003etrace\u003c/a\u003e\u003c/code\u003e function should \u003cem\u003eonly\u003c/em\u003e be used for debugging, or for monitoring\nexecution. The function is not referentially transparent: its type indicates\nthat it is a pure function but it has the side effect of outputting the\ntrace message.\n\u003c/p\u003e",
          "module": "Debug.Trace",
          "name": "trace",
          "package": "base",
          "signature": "String -\u003e a -\u003e a",
          "source": "src/Debug-Trace.html#trace",
          "type": "function"
        },
        "index": {
          "description": "The trace function outputs the trace message given as its first argument before returning the second argument as its result For example this returns the value of but first outputs the message trace calling with show The trace function should only be used for debugging or for monitoring execution The function is not referentially transparent its type indicates that it is pure function but it has the side effect of outputting the trace message",
          "hierarchy": "Debug Trace",
          "module": "Debug.Trace",
          "name": "trace",
          "normalized": "String-\u003ea-\u003ea",
          "package": "base",
          "signature": "String-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Debug-Trace.html#v:trace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003etraceEvent\u003c/a\u003e\u003c/code\u003e function behaves like \u003ccode\u003e\u003ca\u003etrace\u003c/a\u003e\u003c/code\u003e with the difference that\n the message is emitted to the eventlog, if eventlog profiling is available\n and enabled at runtime.\n\u003c/p\u003e\u003cp\u003eIt is suitable for use in pure code. In an IO context use \u003ccode\u003e\u003ca\u003etraceEventIO\u003c/a\u003e\u003c/code\u003e\n instead.\n\u003c/p\u003e\u003cp\u003eNote that when using GHC's SMP runtime, it is possible (but rare) to get\n duplicate events emitted if two CPUs simultaneously evaluate the same thunk\n that uses \u003ccode\u003e\u003ca\u003etraceEvent\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Debug.Trace",
          "name": "traceEvent",
          "package": "base",
          "signature": "String -\u003e a -\u003e a",
          "source": "src/Debug-Trace.html#traceEvent",
          "type": "function"
        },
        "index": {
          "description": "The traceEvent function behaves like trace with the difference that the message is emitted to the eventlog if eventlog profiling is available and enabled at runtime It is suitable for use in pure code In an IO context use traceEventIO instead Note that when using GHC SMP runtime it is possible but rare to get duplicate events emitted if two CPUs simultaneously evaluate the same thunk that uses traceEvent",
          "hierarchy": "Debug Trace",
          "module": "Debug.Trace",
          "name": "traceEvent",
          "normalized": "String-\u003ea-\u003ea",
          "package": "base",
          "partial": "Event",
          "signature": "String-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Debug-Trace.html#v:traceEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003etraceEventIO\u003c/a\u003e\u003c/code\u003e function emits a message to the eventlog, if eventlog\n profiling is available and enabled at runtime.\n\u003c/p\u003e\u003cp\u003eCompared to \u003ccode\u003e\u003ca\u003etraceEvent\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003etraceEventIO\u003c/a\u003e\u003c/code\u003e sequences the event with respect to\n other IO actions.\n\u003c/p\u003e",
          "module": "Debug.Trace",
          "name": "traceEventIO",
          "package": "base",
          "signature": "String -\u003e IO ()",
          "source": "src/Debug-Trace.html#traceEventIO",
          "type": "function"
        },
        "index": {
          "description": "The traceEventIO function emits message to the eventlog if eventlog profiling is available and enabled at runtime Compared to traceEvent traceEventIO sequences the event with respect to other IO actions",
          "hierarchy": "Debug Trace",
          "module": "Debug.Trace",
          "name": "traceEventIO",
          "normalized": "String-\u003eIO()",
          "package": "base",
          "partial": "Event IO",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Debug-Trace.html#v:traceEventIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003etraceIO\u003c/a\u003e\u003c/code\u003e function outputs the trace message from the IO monad.\n This sequences the output with respect to other IO actions.\n\u003c/p\u003e",
          "module": "Debug.Trace",
          "name": "traceIO",
          "package": "base",
          "signature": "String -\u003e IO ()",
          "source": "src/Debug-Trace.html#traceIO",
          "type": "function"
        },
        "index": {
          "description": "The traceIO function outputs the trace message from the IO monad This sequences the output with respect to other IO actions",
          "hierarchy": "Debug Trace",
          "module": "Debug.Trace",
          "name": "traceIO",
          "normalized": "String-\u003eIO()",
          "package": "base",
          "partial": "IO",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Debug-Trace.html#v:traceIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003etrace\u003c/a\u003e\u003c/code\u003e, but uses \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e on the argument to convert it to a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis makes it convenient for printing the values of interesting variables or\nexpressions inside a function. For example here we print the value of the\nvariables \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ez\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e f x y =\n     traceShow (x, z) $ result\n   where\n     z = ...\n     ...\n\u003c/pre\u003e",
          "module": "Debug.Trace",
          "name": "traceShow",
          "package": "base",
          "signature": "a -\u003e b -\u003e b",
          "source": "src/Debug-Trace.html#traceShow",
          "type": "function"
        },
        "index": {
          "description": "Like trace but uses show on the argument to convert it to String This makes it convenient for printing the values of interesting variables or expressions inside function For example here we print the value of the variables and traceShow result where",
          "hierarchy": "Debug Trace",
          "module": "Debug.Trace",
          "name": "traceShow",
          "normalized": "a-\u003eb-\u003eb",
          "package": "base",
          "partial": "Show",
          "signature": "a-\u003eb-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Debug-Trace.html#v:traceShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elike \u003ccode\u003e\u003ca\u003etrace\u003c/a\u003e\u003c/code\u003e, but additionally prints a call stack if one is\n available.\n\u003c/p\u003e\u003cp\u003eIn the current GHC implementation, the call stack is only\n availble if the program was compiled with \u003ccode\u003e-prof\u003c/code\u003e; otherwise\n \u003ccode\u003e\u003ca\u003etraceStack\u003c/a\u003e\u003c/code\u003e behaves exactly like \u003ccode\u003e\u003ca\u003etrace\u003c/a\u003e\u003c/code\u003e.  Entries in the call\n stack correspond to \u003ccode\u003eSCC\u003c/code\u003e annotations, so it is a good idea to use\n \u003ccode\u003e-fprof-auto\u003c/code\u003e or \u003ccode\u003e-fprof-auto-calls\u003c/code\u003e to add SCC annotations automatically.\n\u003c/p\u003e",
          "module": "Debug.Trace",
          "name": "traceStack",
          "package": "base",
          "signature": "String -\u003e a -\u003e a",
          "source": "src/Debug-Trace.html#traceStack",
          "type": "function"
        },
        "index": {
          "description": "like trace but additionally prints call stack if one is available In the current GHC implementation the call stack is only availble if the program was compiled with prof otherwise traceStack behaves exactly like trace Entries in the call stack correspond to SCC annotations so it is good idea to use fprof-auto or fprof-auto-calls to add SCC annotations automatically",
          "hierarchy": "Debug Trace",
          "module": "Debug.Trace",
          "name": "traceStack",
          "normalized": "String-\u003ea-\u003ea",
          "package": "base",
          "partial": "Stack",
          "signature": "String-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Debug-Trace.html#v:traceStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eC-specific Marshalling support: Handling of C \"errno\" error codes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.C.Error",
          "name": "Error",
          "package": "base",
          "source": "src/Foreign-C-Error.html",
          "type": "module"
        },
        "index": {
          "description": "C-specific Marshalling support Handling of errno error codes",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "Error",
          "package": "base",
          "partial": "Error",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell representation for \u003ccode\u003eerrno\u003c/code\u003e values.\n The implementation is deliberately exposed, to allow users to add\n their own definitions of \u003ccode\u003e\u003ca\u003eErrno\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "Errno",
          "package": "base",
          "source": "src/Foreign-C-Error.html#Errno",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell representation for errno values The implementation is deliberately exposed to allow users to add their own definitions of Errno values",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "Errno",
          "package": "base",
          "partial": "Errno",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#t:Errno"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "Errno",
          "package": "base",
          "signature": "Errno CInt",
          "source": "src/Foreign-C-Error.html#Errno",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "Errno",
          "package": "base",
          "partial": "Errno",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:Errno"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "e2BIG",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#e2BIG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "e2BIG",
          "package": "base",
          "partial": "BIG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:e2BIG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eACCES",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eACCES",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eACCES",
          "package": "base",
          "partial": "ACCES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eACCES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eADDRINUSE",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eADDRINUSE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eADDRINUSE",
          "package": "base",
          "partial": "ADDRINUSE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eADDRINUSE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eADDRNOTAVAIL",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eADDRNOTAVAIL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eADDRNOTAVAIL",
          "package": "base",
          "partial": "ADDRNOTAVAIL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eADDRNOTAVAIL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eADV",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eADV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eADV",
          "package": "base",
          "partial": "ADV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eADV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eAFNOSUPPORT",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eAFNOSUPPORT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eAFNOSUPPORT",
          "package": "base",
          "partial": "AFNOSUPPORT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eAFNOSUPPORT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eAGAIN",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eAGAIN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eAGAIN",
          "package": "base",
          "partial": "AGAIN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eAGAIN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eALREADY",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eALREADY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eALREADY",
          "package": "base",
          "partial": "ALREADY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eALREADY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eBADF",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eBADF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eBADF",
          "package": "base",
          "partial": "BADF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eBADF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eBADMSG",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eBADMSG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eBADMSG",
          "package": "base",
          "partial": "BADMSG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eBADMSG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eBADRPC",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eBADRPC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eBADRPC",
          "package": "base",
          "partial": "BADRPC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eBADRPC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eBUSY",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eBUSY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eBUSY",
          "package": "base",
          "partial": "BUSY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eBUSY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eCHILD",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eCHILD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eCHILD",
          "package": "base",
          "partial": "CHILD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eCHILD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eCOMM",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eCOMM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eCOMM",
          "package": "base",
          "partial": "COMM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eCOMM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eCONNABORTED",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eCONNABORTED",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eCONNABORTED",
          "package": "base",
          "partial": "CONNABORTED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eCONNABORTED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eCONNREFUSED",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eCONNREFUSED",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eCONNREFUSED",
          "package": "base",
          "partial": "CONNREFUSED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eCONNREFUSED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eCONNRESET",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eCONNRESET",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eCONNRESET",
          "package": "base",
          "partial": "CONNRESET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eCONNRESET"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eDEADLK",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eDEADLK",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eDEADLK",
          "package": "base",
          "partial": "DEADLK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eDEADLK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eDESTADDRREQ",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eDESTADDRREQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eDESTADDRREQ",
          "package": "base",
          "partial": "DESTADDRREQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eDESTADDRREQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eDIRTY",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eDIRTY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eDIRTY",
          "package": "base",
          "partial": "DIRTY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eDIRTY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eDOM",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eDOM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eDOM",
          "package": "base",
          "partial": "DOM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eDOM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eDQUOT",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eDQUOT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eDQUOT",
          "package": "base",
          "partial": "DQUOT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eDQUOT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eEXIST",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eEXIST",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eEXIST",
          "package": "base",
          "partial": "EXIST",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eEXIST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eFAULT",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eFAULT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eFAULT",
          "package": "base",
          "partial": "FAULT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eFAULT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eFBIG",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eFBIG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eFBIG",
          "package": "base",
          "partial": "FBIG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eFBIG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eFTYPE",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eFTYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eFTYPE",
          "package": "base",
          "partial": "FTYPE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eFTYPE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eHOSTDOWN",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eHOSTDOWN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eHOSTDOWN",
          "package": "base",
          "partial": "HOSTDOWN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eHOSTDOWN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eHOSTUNREACH",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eHOSTUNREACH",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eHOSTUNREACH",
          "package": "base",
          "partial": "HOSTUNREACH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eHOSTUNREACH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eIDRM",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eIDRM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eIDRM",
          "package": "base",
          "partial": "IDRM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eIDRM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eILSEQ",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eILSEQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eILSEQ",
          "package": "base",
          "partial": "ILSEQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eILSEQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eINPROGRESS",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eINPROGRESS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eINPROGRESS",
          "package": "base",
          "partial": "INPROGRESS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eINPROGRESS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eINTR",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eINTR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eINTR",
          "package": "base",
          "partial": "INTR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eINTR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eINVAL",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eINVAL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eINVAL",
          "package": "base",
          "partial": "INVAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eINVAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eIO",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eIO",
          "package": "base",
          "partial": "IO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eISCONN",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eISCONN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eISCONN",
          "package": "base",
          "partial": "ISCONN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eISCONN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eISDIR",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eISDIR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eISDIR",
          "package": "base",
          "partial": "ISDIR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eISDIR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eLOOP",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eLOOP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eLOOP",
          "package": "base",
          "partial": "LOOP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eLOOP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eMFILE",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eMFILE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eMFILE",
          "package": "base",
          "partial": "MFILE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eMFILE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eMLINK",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eMLINK",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eMLINK",
          "package": "base",
          "partial": "MLINK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eMLINK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eMSGSIZE",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eMSGSIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eMSGSIZE",
          "package": "base",
          "partial": "MSGSIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eMSGSIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eMULTIHOP",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eMULTIHOP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eMULTIHOP",
          "package": "base",
          "partial": "MULTIHOP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eMULTIHOP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNAMETOOLONG",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNAMETOOLONG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNAMETOOLONG",
          "package": "base",
          "partial": "NAMETOOLONG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNAMETOOLONG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNETDOWN",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNETDOWN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNETDOWN",
          "package": "base",
          "partial": "NETDOWN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNETDOWN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNETRESET",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNETRESET",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNETRESET",
          "package": "base",
          "partial": "NETRESET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNETRESET"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNETUNREACH",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNETUNREACH",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNETUNREACH",
          "package": "base",
          "partial": "NETUNREACH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNETUNREACH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNFILE",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNFILE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNFILE",
          "package": "base",
          "partial": "NFILE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNFILE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOBUFS",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOBUFS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOBUFS",
          "package": "base",
          "partial": "NOBUFS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOBUFS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNODATA",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNODATA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNODATA",
          "package": "base",
          "partial": "NODATA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNODATA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNODEV",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNODEV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNODEV",
          "package": "base",
          "partial": "NODEV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNODEV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOENT",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOENT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOENT",
          "package": "base",
          "partial": "NOENT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOENT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOEXEC",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOEXEC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOEXEC",
          "package": "base",
          "partial": "NOEXEC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOEXEC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOLCK",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOLCK",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOLCK",
          "package": "base",
          "partial": "NOLCK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOLCK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOLINK",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOLINK",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOLINK",
          "package": "base",
          "partial": "NOLINK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOLINK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOMEM",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOMEM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOMEM",
          "package": "base",
          "partial": "NOMEM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOMEM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOMSG",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOMSG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOMSG",
          "package": "base",
          "partial": "NOMSG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOMSG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNONET",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNONET",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNONET",
          "package": "base",
          "partial": "NONET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNONET"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOPROTOOPT",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOPROTOOPT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOPROTOOPT",
          "package": "base",
          "partial": "NOPROTOOPT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOPROTOOPT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOSPC",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOSPC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOSPC",
          "package": "base",
          "partial": "NOSPC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOSPC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOSR",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOSR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOSR",
          "package": "base",
          "partial": "NOSR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOSR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOSTR",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOSTR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOSTR",
          "package": "base",
          "partial": "NOSTR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOSTR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOSYS",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOSYS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOSYS",
          "package": "base",
          "partial": "NOSYS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOSYS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOTBLK",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOTBLK",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOTBLK",
          "package": "base",
          "partial": "NOTBLK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOTBLK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOTCONN",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOTCONN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOTCONN",
          "package": "base",
          "partial": "NOTCONN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOTCONN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOTDIR",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOTDIR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOTDIR",
          "package": "base",
          "partial": "NOTDIR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOTDIR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOTEMPTY",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOTEMPTY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOTEMPTY",
          "package": "base",
          "partial": "NOTEMPTY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOTEMPTY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOTSOCK",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOTSOCK",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOTSOCK",
          "package": "base",
          "partial": "NOTSOCK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOTSOCK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNOTTY",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNOTTY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNOTTY",
          "package": "base",
          "partial": "NOTTY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNOTTY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eNXIO",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eNXIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eNXIO",
          "package": "base",
          "partial": "NXIO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eNXIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eOK",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eOK",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eOK",
          "package": "base",
          "partial": "OK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eOK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eOPNOTSUPP",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eOPNOTSUPP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eOPNOTSUPP",
          "package": "base",
          "partial": "OPNOTSUPP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eOPNOTSUPP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "ePERM",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#ePERM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "ePERM",
          "package": "base",
          "partial": "PERM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:ePERM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "ePFNOSUPPORT",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#ePFNOSUPPORT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "ePFNOSUPPORT",
          "package": "base",
          "partial": "PFNOSUPPORT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:ePFNOSUPPORT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "ePIPE",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#ePIPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "ePIPE",
          "package": "base",
          "partial": "PIPE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:ePIPE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "ePROCLIM",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#ePROCLIM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "ePROCLIM",
          "package": "base",
          "partial": "PROCLIM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:ePROCLIM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "ePROCUNAVAIL",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#ePROCUNAVAIL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "ePROCUNAVAIL",
          "package": "base",
          "partial": "PROCUNAVAIL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:ePROCUNAVAIL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "ePROGMISMATCH",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#ePROGMISMATCH",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "ePROGMISMATCH",
          "package": "base",
          "partial": "PROGMISMATCH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:ePROGMISMATCH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "ePROGUNAVAIL",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#ePROGUNAVAIL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "ePROGUNAVAIL",
          "package": "base",
          "partial": "PROGUNAVAIL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:ePROGUNAVAIL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "ePROTO",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#ePROTO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "ePROTO",
          "package": "base",
          "partial": "PROTO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:ePROTO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "ePROTONOSUPPORT",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#ePROTONOSUPPORT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "ePROTONOSUPPORT",
          "package": "base",
          "partial": "PROTONOSUPPORT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:ePROTONOSUPPORT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "ePROTOTYPE",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#ePROTOTYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "ePROTOTYPE",
          "package": "base",
          "partial": "PROTOTYPE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:ePROTOTYPE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eRANGE",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eRANGE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eRANGE",
          "package": "base",
          "partial": "RANGE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eRANGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eREMCHG",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eREMCHG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eREMCHG",
          "package": "base",
          "partial": "REMCHG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eREMCHG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eREMOTE",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eREMOTE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eREMOTE",
          "package": "base",
          "partial": "REMOTE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eREMOTE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eROFS",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eROFS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eROFS",
          "package": "base",
          "partial": "ROFS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eROFS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eRPCMISMATCH",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eRPCMISMATCH",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eRPCMISMATCH",
          "package": "base",
          "partial": "RPCMISMATCH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eRPCMISMATCH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eRREMOTE",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eRREMOTE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eRREMOTE",
          "package": "base",
          "partial": "RREMOTE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eRREMOTE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eSHUTDOWN",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eSHUTDOWN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eSHUTDOWN",
          "package": "base",
          "partial": "SHUTDOWN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eSHUTDOWN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eSOCKTNOSUPPORT",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eSOCKTNOSUPPORT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eSOCKTNOSUPPORT",
          "package": "base",
          "partial": "SOCKTNOSUPPORT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eSOCKTNOSUPPORT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eSPIPE",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eSPIPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eSPIPE",
          "package": "base",
          "partial": "SPIPE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eSPIPE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eSRCH",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eSRCH",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eSRCH",
          "package": "base",
          "partial": "SRCH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eSRCH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eSRMNT",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eSRMNT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eSRMNT",
          "package": "base",
          "partial": "SRMNT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eSRMNT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eSTALE",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eSTALE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eSTALE",
          "package": "base",
          "partial": "STALE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eSTALE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eTIME",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eTIME",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eTIME",
          "package": "base",
          "partial": "TIME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eTIME"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eTIMEDOUT",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eTIMEDOUT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eTIMEDOUT",
          "package": "base",
          "partial": "TIMEDOUT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eTIMEDOUT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eTOOMANYREFS",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eTOOMANYREFS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eTOOMANYREFS",
          "package": "base",
          "partial": "TOOMANYREFS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eTOOMANYREFS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eTXTBSY",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eTXTBSY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eTXTBSY",
          "package": "base",
          "partial": "TXTBSY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eTXTBSY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eUSERS",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eUSERS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eUSERS",
          "package": "base",
          "partial": "USERS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eUSERS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eWOULDBLOCK",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eWOULDBLOCK",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eWOULDBLOCK",
          "package": "base",
          "partial": "WOULDBLOCK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eWOULDBLOCK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Error",
          "name": "eXDEV",
          "package": "base",
          "signature": "Errno",
          "source": "src/Foreign-C-Error.html#eXDEV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "eXDEV",
          "package": "base",
          "partial": "XDEV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:eXDEV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e based on the given \u003ccode\u003e\u003ca\u003eErrno\u003c/a\u003e\u003c/code\u003e value.\n The optional information can be used to improve the accuracy of\n error messages.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "errnoToIOError",
          "package": "base",
          "signature": "String-\u003e Errno-\u003e Maybe Handle-\u003e Maybe String-\u003e IOError",
          "type": "function"
        },
        "index": {
          "description": "Construct an IOError based on the given Errno value The optional information can be used to improve the accuracy of error messages",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "errnoToIOError",
          "normalized": "String-\u003eErrno-\u003eMaybe Handle-\u003eMaybe String-\u003eIOError",
          "package": "base",
          "partial": "To IOError",
          "signature": "String-\u003eErrno-\u003eMaybe Handle-\u003eMaybe String-\u003eIOError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:errnoToIOError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the current value of \u003ccode\u003eerrno\u003c/code\u003e in the current thread.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "getErrno",
          "package": "base",
          "signature": "IO Errno",
          "source": "src/Foreign-C-Error.html#getErrno",
          "type": "function"
        },
        "index": {
          "description": "Get the current value of errno in the current thread",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "getErrno",
          "package": "base",
          "partial": "Errno",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:getErrno"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYield \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the given \u003ccode\u003e\u003ca\u003eErrno\u003c/a\u003e\u003c/code\u003e value is valid on the system.\n This implies that the \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e instance of \u003ccode\u003e\u003ca\u003eErrno\u003c/a\u003e\u003c/code\u003e is also system dependent\n as it is only defined for valid values of \u003ccode\u003e\u003ca\u003eErrno\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "isValidErrno",
          "package": "base",
          "signature": "Errno -\u003e Bool",
          "source": "src/Foreign-C-Error.html#isValidErrno",
          "type": "function"
        },
        "index": {
          "description": "Yield True if the given Errno value is valid on the system This implies that the Eq instance of Errno is also system dependent as it is only defined for valid values of Errno",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "isValidErrno",
          "normalized": "Errno-\u003eBool",
          "package": "base",
          "partial": "Valid Errno",
          "signature": "Errno-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:isValidErrno"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReset the current thread's \u003ccode\u003eerrno\u003c/code\u003e value to \u003ccode\u003e\u003ca\u003eeOK\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "resetErrno",
          "package": "base",
          "signature": "IO ()",
          "source": "src/Foreign-C-Error.html#resetErrno",
          "type": "function"
        },
        "index": {
          "description": "Reset the current thread errno value to eOK",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "resetErrno",
          "normalized": "IO()",
          "package": "base",
          "partial": "Errno",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:resetErrno"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e corresponding to the current value of \u003ccode\u003e\u003ca\u003egetErrno\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrno",
          "package": "base",
          "signature": "String-\u003e IO a",
          "type": "function"
        },
        "index": {
          "description": "Throw an IOError corresponding to the current value of getErrno",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrno",
          "normalized": "String-\u003eIO a",
          "package": "base",
          "partial": "Errno",
          "signature": "String-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrno"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e corresponding to the current value of \u003ccode\u003e\u003ca\u003egetErrno\u003c/a\u003e\u003c/code\u003e\n if the result value of the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e action meets the given predicate.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIf",
          "package": "base",
          "signature": "(a -\u003e Bool)-\u003e String-\u003e IO a-\u003e IO a",
          "type": "function"
        },
        "index": {
          "description": "Throw an IOError corresponding to the current value of getErrno if the result value of the IO action meets the given predicate",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIf",
          "normalized": "(a-\u003eBool)-\u003eString-\u003eIO a-\u003eIO a",
          "package": "base",
          "partial": "Errno If",
          "signature": "(a-\u003eBool)-\u003eString-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e corresponding to the current value of \u003ccode\u003e\u003ca\u003egetErrno\u003c/a\u003e\u003c/code\u003e\n if the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e action returns a result of \u003ccode\u003e-1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfMinus1",
          "package": "base",
          "signature": "String -\u003e IO a -\u003e IO a",
          "source": "src/Foreign-C-Error.html#throwErrnoIfMinus1",
          "type": "function"
        },
        "index": {
          "description": "Throw an IOError corresponding to the current value of getErrno if the IO action returns result of",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfMinus1",
          "normalized": "String-\u003eIO a-\u003eIO a",
          "package": "base",
          "partial": "Errno If Minus",
          "signature": "String-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIfMinus1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e corresponding to the current value of \u003ccode\u003e\u003ca\u003egetErrno\u003c/a\u003e\u003c/code\u003e\n if the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e action returns a result of \u003ccode\u003e-1\u003c/code\u003e, but retries in case of\n an interrupted operation.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfMinus1Retry",
          "package": "base",
          "signature": "String -\u003e IO a -\u003e IO a",
          "source": "src/Foreign-C-Error.html#throwErrnoIfMinus1Retry",
          "type": "function"
        },
        "index": {
          "description": "Throw an IOError corresponding to the current value of getErrno if the IO action returns result of but retries in case of an interrupted operation",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfMinus1Retry",
          "normalized": "String-\u003eIO a-\u003eIO a",
          "package": "base",
          "partial": "Errno If Minus Retry",
          "signature": "String-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIfMinus1Retry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIfMinus1Retry\u003c/a\u003e\u003c/code\u003e, but checks for operations that would block.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfMinus1RetryMayBlock",
          "package": "base",
          "signature": "String -\u003e IO a -\u003e IO b -\u003e IO a",
          "source": "src/Foreign-C-Error.html#throwErrnoIfMinus1RetryMayBlock",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIfMinus1Retry but checks for operations that would block",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfMinus1RetryMayBlock",
          "normalized": "String-\u003eIO a-\u003eIO b-\u003eIO a",
          "package": "base",
          "partial": "Errno If Minus Retry May Block",
          "signature": "String-\u003eIO a-\u003eIO b-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIfMinus1RetryMayBlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIfMinus1RetryMayBlock\u003c/a\u003e\u003c/code\u003e, but discards the result.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfMinus1RetryMayBlock_",
          "package": "base",
          "signature": "String -\u003e IO a -\u003e IO b -\u003e IO ()",
          "source": "src/Foreign-C-Error.html#throwErrnoIfMinus1RetryMayBlock_",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIfMinus1RetryMayBlock but discards the result",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfMinus1RetryMayBlock_",
          "normalized": "String-\u003eIO a-\u003eIO b-\u003eIO()",
          "package": "base",
          "partial": "Errno If Minus Retry May Block",
          "signature": "String-\u003eIO a-\u003eIO b-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIfMinus1RetryMayBlock_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIfMinus1\u003c/a\u003e\u003c/code\u003e, but discards the result.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfMinus1Retry_",
          "package": "base",
          "signature": "String -\u003e IO a -\u003e IO ()",
          "source": "src/Foreign-C-Error.html#throwErrnoIfMinus1Retry_",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIfMinus1 but discards the result",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfMinus1Retry_",
          "normalized": "String-\u003eIO a-\u003eIO()",
          "package": "base",
          "partial": "Errno If Minus Retry",
          "signature": "String-\u003eIO a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIfMinus1Retry_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIfMinus1\u003c/a\u003e\u003c/code\u003e, but discards the result.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfMinus1_",
          "package": "base",
          "signature": "String -\u003e IO a -\u003e IO ()",
          "source": "src/Foreign-C-Error.html#throwErrnoIfMinus1_",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIfMinus1 but discards the result",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfMinus1_",
          "normalized": "String-\u003eIO a-\u003eIO()",
          "package": "base",
          "partial": "Errno If Minus",
          "signature": "String-\u003eIO a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIfMinus1_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e corresponding to the current value of \u003ccode\u003e\u003ca\u003egetErrno\u003c/a\u003e\u003c/code\u003e\n if the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e action returns \u003ccode\u003e\u003ca\u003enullPtr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfNull",
          "package": "base",
          "signature": "String -\u003e IO (Ptr a) -\u003e IO (Ptr a)",
          "source": "src/Foreign-C-Error.html#throwErrnoIfNull",
          "type": "function"
        },
        "index": {
          "description": "Throw an IOError corresponding to the current value of getErrno if the IO action returns nullPtr",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfNull",
          "normalized": "String-\u003eIO(Ptr a)-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Errno If Null",
          "signature": "String-\u003eIO(Ptr a)-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIfNull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e corresponding to the current value of \u003ccode\u003e\u003ca\u003egetErrno\u003c/a\u003e\u003c/code\u003e\n if the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e action returns \u003ccode\u003e\u003ca\u003enullPtr\u003c/a\u003e\u003c/code\u003e,\n but retry in case of an interrupted operation.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfNullRetry",
          "package": "base",
          "signature": "String -\u003e IO (Ptr a) -\u003e IO (Ptr a)",
          "source": "src/Foreign-C-Error.html#throwErrnoIfNullRetry",
          "type": "function"
        },
        "index": {
          "description": "Throw an IOError corresponding to the current value of getErrno if the IO action returns nullPtr but retry in case of an interrupted operation",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfNullRetry",
          "normalized": "String-\u003eIO(Ptr a)-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Errno If Null Retry",
          "signature": "String-\u003eIO(Ptr a)-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIfNullRetry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIfNullRetry\u003c/a\u003e\u003c/code\u003e, but checks for operations that would block.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfNullRetryMayBlock",
          "package": "base",
          "signature": "String -\u003e IO (Ptr a) -\u003e IO b -\u003e IO (Ptr a)",
          "source": "src/Foreign-C-Error.html#throwErrnoIfNullRetryMayBlock",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIfNullRetry but checks for operations that would block",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfNullRetryMayBlock",
          "normalized": "String-\u003eIO(Ptr a)-\u003eIO b-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Errno If Null Retry May Block",
          "signature": "String-\u003eIO(Ptr a)-\u003eIO b-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIfNullRetryMayBlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIf\u003c/a\u003e\u003c/code\u003e, but retry the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e action when it yields the\n error code \u003ccode\u003e\u003ca\u003eeINTR\u003c/a\u003e\u003c/code\u003e - this amounts to the standard retry loop for\n interrupted POSIX system calls.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfRetry",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e String -\u003e IO a -\u003e IO a",
          "source": "src/Foreign-C-Error.html#throwErrnoIfRetry",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIf but retry the IO action when it yields the error code eINTR this amounts to the standard retry loop for interrupted POSIX system calls",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfRetry",
          "normalized": "(a-\u003eBool)-\u003eString-\u003eIO a-\u003eIO a",
          "package": "base",
          "partial": "Errno If Retry",
          "signature": "(a-\u003eBool)-\u003eString-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIfRetry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIfRetry\u003c/a\u003e\u003c/code\u003e, but additionally if the operation \n yields the error code \u003ccode\u003e\u003ca\u003eeAGAIN\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eeWOULDBLOCK\u003c/a\u003e\u003c/code\u003e, an alternative\n action is executed before retrying.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfRetryMayBlock",
          "package": "base",
          "signature": "(a -\u003e Bool)-\u003e String-\u003e IO a-\u003e IO b-\u003e IO a",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIfRetry but additionally if the operation yields the error code eAGAIN or eWOULDBLOCK an alternative action is executed before retrying",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfRetryMayBlock",
          "normalized": "(a-\u003eBool)-\u003eString-\u003eIO a-\u003eIO b-\u003eIO a",
          "package": "base",
          "partial": "Errno If Retry May Block",
          "signature": "(a-\u003eBool)-\u003eString-\u003eIO a-\u003eIO b-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIfRetryMayBlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIfRetryMayBlock\u003c/a\u003e\u003c/code\u003e, but discards the result.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfRetryMayBlock_",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e String -\u003e IO a -\u003e IO b -\u003e IO ()",
          "source": "src/Foreign-C-Error.html#throwErrnoIfRetryMayBlock_",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIfRetryMayBlock but discards the result",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfRetryMayBlock_",
          "normalized": "(a-\u003eBool)-\u003eString-\u003eIO a-\u003eIO b-\u003eIO()",
          "package": "base",
          "partial": "Errno If Retry May Block",
          "signature": "(a-\u003eBool)-\u003eString-\u003eIO a-\u003eIO b-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIfRetryMayBlock_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIfRetry\u003c/a\u003e\u003c/code\u003e, but discards the result.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfRetry_",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e String -\u003e IO a -\u003e IO ()",
          "source": "src/Foreign-C-Error.html#throwErrnoIfRetry_",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIfRetry but discards the result",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIfRetry_",
          "normalized": "(a-\u003eBool)-\u003eString-\u003eIO a-\u003eIO()",
          "package": "base",
          "partial": "Errno If Retry",
          "signature": "(a-\u003eBool)-\u003eString-\u003eIO a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIfRetry_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIf\u003c/a\u003e\u003c/code\u003e, but discards the result of the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e action after\n error handling.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIf_",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e String -\u003e IO a -\u003e IO ()",
          "source": "src/Foreign-C-Error.html#throwErrnoIf_",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIf but discards the result of the IO action after error handling",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoIf_",
          "normalized": "(a-\u003eBool)-\u003eString-\u003eIO a-\u003eIO()",
          "package": "base",
          "partial": "Errno If",
          "signature": "(a-\u003eBool)-\u003eString-\u003eIO a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoIf_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrno\u003c/a\u003e\u003c/code\u003e, but exceptions include the given path when appropriate.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoPath",
          "package": "base",
          "signature": "String -\u003e FilePath -\u003e IO a",
          "source": "src/Foreign-C-Error.html#throwErrnoPath",
          "type": "function"
        },
        "index": {
          "description": "as throwErrno but exceptions include the given path when appropriate",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoPath",
          "normalized": "String-\u003eFilePath-\u003eIO a",
          "package": "base",
          "partial": "Errno Path",
          "signature": "String-\u003eFilePath-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIf\u003c/a\u003e\u003c/code\u003e, but exceptions include the given path when\n   appropriate.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoPathIf",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e String -\u003e FilePath -\u003e IO a -\u003e IO a",
          "source": "src/Foreign-C-Error.html#throwErrnoPathIf",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIf but exceptions include the given path when appropriate",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoPathIf",
          "normalized": "(a-\u003eBool)-\u003eString-\u003eFilePath-\u003eIO a-\u003eIO a",
          "package": "base",
          "partial": "Errno Path If",
          "signature": "(a-\u003eBool)-\u003eString-\u003eFilePath-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoPathIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIfMinus1\u003c/a\u003e\u003c/code\u003e, but exceptions include the given path when\n   appropriate.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoPathIfMinus1",
          "package": "base",
          "signature": "String -\u003e FilePath -\u003e IO a -\u003e IO a",
          "source": "src/Foreign-C-Error.html#throwErrnoPathIfMinus1",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIfMinus1 but exceptions include the given path when appropriate",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoPathIfMinus1",
          "normalized": "String-\u003eFilePath-\u003eIO a-\u003eIO a",
          "package": "base",
          "partial": "Errno Path If Minus",
          "signature": "String-\u003eFilePath-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoPathIfMinus1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIfMinus1_\u003c/a\u003e\u003c/code\u003e, but exceptions include the given path when\n   appropriate.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoPathIfMinus1_",
          "package": "base",
          "signature": "String -\u003e FilePath -\u003e IO a -\u003e IO ()",
          "source": "src/Foreign-C-Error.html#throwErrnoPathIfMinus1_",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIfMinus1 but exceptions include the given path when appropriate",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoPathIfMinus1_",
          "normalized": "String-\u003eFilePath-\u003eIO a-\u003eIO()",
          "package": "base",
          "partial": "Errno Path If Minus",
          "signature": "String-\u003eFilePath-\u003eIO a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoPathIfMinus1_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIfNull\u003c/a\u003e\u003c/code\u003e, but exceptions include the given path when\n   appropriate.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoPathIfNull",
          "package": "base",
          "signature": "String -\u003e FilePath -\u003e IO (Ptr a) -\u003e IO (Ptr a)",
          "source": "src/Foreign-C-Error.html#throwErrnoPathIfNull",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIfNull but exceptions include the given path when appropriate",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoPathIfNull",
          "normalized": "String-\u003eFilePath-\u003eIO(Ptr a)-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Errno Path If Null",
          "signature": "String-\u003eFilePath-\u003eIO(Ptr a)-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoPathIfNull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas \u003ccode\u003e\u003ca\u003ethrowErrnoIf_\u003c/a\u003e\u003c/code\u003e, but exceptions include the given path when\n   appropriate.\n\u003c/p\u003e",
          "module": "Foreign.C.Error",
          "name": "throwErrnoPathIf_",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e String -\u003e FilePath -\u003e IO a -\u003e IO ()",
          "source": "src/Foreign-C-Error.html#throwErrnoPathIf_",
          "type": "function"
        },
        "index": {
          "description": "as throwErrnoIf but exceptions include the given path when appropriate",
          "hierarchy": "Foreign C Error",
          "module": "Foreign.C.Error",
          "name": "throwErrnoPathIf_",
          "normalized": "(a-\u003eBool)-\u003eString-\u003eFilePath-\u003eIO a-\u003eIO()",
          "package": "base",
          "partial": "Errno Path If",
          "signature": "(a-\u003eBool)-\u003eString-\u003eFilePath-\u003eIO a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Error.html#v:throwErrnoPathIf_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUtilities for primitive marshalling of C strings.\n\u003c/p\u003e\u003cp\u003eThe marshalling converts each Haskell character, representing a Unicode\n code point, to one or more bytes in a manner that, by default, is\n determined by the current locale.  As a consequence, no guarantees\n can be made about the relative length of a Haskell string and its\n corresponding C string, and therefore all the marshalling routines\n include memory allocation.  The translation between Unicode and the\n encoding of the current locale may be lossy.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.C.String",
          "name": "String",
          "package": "base",
          "source": "src/Foreign-C-String.html",
          "type": "module"
        },
        "index": {
          "description": "Utilities for primitive marshalling of strings The marshalling converts each Haskell character representing Unicode code point to one or more bytes in manner that by default is determined by the current locale As consequence no guarantees can be made about the relative length of Haskell string and its corresponding string and therefore all the marshalling routines include memory allocation The translation between Unicode and the encoding of the current locale may be lossy",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "String",
          "package": "base",
          "partial": "String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA C string is a reference to an array of C characters terminated by NUL.\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "CString",
          "package": "base",
          "source": "src/Foreign-C-String.html#CString",
          "type": "type"
        },
        "index": {
          "description": "string is reference to an array of characters terminated by NUL",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "CString",
          "package": "base",
          "partial": "CString",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#t:CString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA string with explicit length information in bytes instead of a\n terminating NUL (allowing NUL characters in the middle of the string).\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "CStringLen",
          "package": "base",
          "source": "src/Foreign-C-String.html#CStringLen",
          "type": "type"
        },
        "index": {
          "description": "string with explicit length information in bytes instead of terminating NUL allowing NUL characters in the middle of the string",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "CStringLen",
          "package": "base",
          "partial": "CString Len",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#t:CStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA C wide string is a reference to an array of C wide characters\n terminated by NUL.\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "CWString",
          "package": "base",
          "source": "src/Foreign-C-String.html#CWString",
          "type": "type"
        },
        "index": {
          "description": "wide string is reference to an array of wide characters terminated by NUL",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "CWString",
          "package": "base",
          "partial": "CWString",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#t:CWString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA wide character string with explicit length information in \u003ccode\u003e\u003ca\u003eCWchar\u003c/a\u003e\u003c/code\u003es\n instead of a terminating NUL (allowing NUL characters in the middle\n of the string).\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "CWStringLen",
          "package": "base",
          "source": "src/Foreign-C-String.html#CWStringLen",
          "type": "type"
        },
        "index": {
          "description": "wide character string with explicit length information in CWchar instead of terminating NUL allowing NUL characters in the middle of the string",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "CWStringLen",
          "package": "base",
          "partial": "CWString Len",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#t:CWStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a C byte, representing a Latin-1 character, to the corresponding\n Haskell character.\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "castCCharToChar",
          "package": "base",
          "signature": "CChar -\u003e Char",
          "source": "src/Foreign-C-String.html#castCCharToChar",
          "type": "function"
        },
        "index": {
          "description": "Convert byte representing Latin-1 character to the corresponding Haskell character",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "castCCharToChar",
          "normalized": "CChar-\u003eChar",
          "package": "base",
          "partial": "CChar To Char",
          "signature": "CChar-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:castCCharToChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a C \u003ccode\u003esigned char\u003c/code\u003e, representing a Latin-1 character, to the\n corresponding Haskell character.\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "castCSCharToChar",
          "package": "base",
          "signature": "CSChar -\u003e Char",
          "source": "src/Foreign-C-String.html#castCSCharToChar",
          "type": "function"
        },
        "index": {
          "description": "Convert signed char representing Latin-1 character to the corresponding Haskell character",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "castCSCharToChar",
          "normalized": "CSChar-\u003eChar",
          "package": "base",
          "partial": "CSChar To Char",
          "signature": "CSChar-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:castCSCharToChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a C \u003ccode\u003eunsigned char\u003c/code\u003e, representing a Latin-1 character, to\n the corresponding Haskell character.\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "castCUCharToChar",
          "package": "base",
          "signature": "CUChar -\u003e Char",
          "source": "src/Foreign-C-String.html#castCUCharToChar",
          "type": "function"
        },
        "index": {
          "description": "Convert unsigned char representing Latin-1 character to the corresponding Haskell character",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "castCUCharToChar",
          "normalized": "CUChar-\u003eChar",
          "package": "base",
          "partial": "CUChar To Char",
          "signature": "CUChar-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:castCUCharToChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a Haskell character to a C character.\n This function is only safe on the first 256 characters.\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "castCharToCChar",
          "package": "base",
          "signature": "Char -\u003e CChar",
          "source": "src/Foreign-C-String.html#castCharToCChar",
          "type": "function"
        },
        "index": {
          "description": "Convert Haskell character to character This function is only safe on the first characters",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "castCharToCChar",
          "normalized": "Char-\u003eCChar",
          "package": "base",
          "partial": "Char To CChar",
          "signature": "Char-\u003eCChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:castCharToCChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a Haskell character to a C \u003ccode\u003esigned char\u003c/code\u003e.\n This function is only safe on the first 256 characters.\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "castCharToCSChar",
          "package": "base",
          "signature": "Char -\u003e CSChar",
          "source": "src/Foreign-C-String.html#castCharToCSChar",
          "type": "function"
        },
        "index": {
          "description": "Convert Haskell character to signed char This function is only safe on the first characters",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "castCharToCSChar",
          "normalized": "Char-\u003eCSChar",
          "package": "base",
          "partial": "Char To CSChar",
          "signature": "Char-\u003eCSChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:castCharToCSChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a Haskell character to a C \u003ccode\u003eunsigned char\u003c/code\u003e.\n This function is only safe on the first 256 characters.\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "castCharToCUChar",
          "package": "base",
          "signature": "Char -\u003e CUChar",
          "source": "src/Foreign-C-String.html#castCharToCUChar",
          "type": "function"
        },
        "index": {
          "description": "Convert Haskell character to unsigned char This function is only safe on the first characters",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "castCharToCUChar",
          "normalized": "Char-\u003eCUChar",
          "package": "base",
          "partial": "Char To CUChar",
          "signature": "Char-\u003eCUChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:castCharToCUChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.String",
          "name": "charIsRepresentable",
          "package": "base",
          "signature": "Char -\u003e IO Bool",
          "source": "src/Foreign-C-String.html#charIsRepresentable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "charIsRepresentable",
          "normalized": "Char-\u003eIO Bool",
          "package": "base",
          "partial": "Is Representable",
          "signature": "Char-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:charIsRepresentable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a NUL terminated C string.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the Haskell string may \u003cem\u003enot\u003c/em\u003e contain any NUL characters\n\u003c/li\u003e\u003cli\u003e new storage is allocated for the C string and must be\n   explicitly freed using \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e or\n   \u003ccode\u003e\u003ca\u003efinalizerFree\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Foreign.C.String",
          "name": "newCAString",
          "package": "base",
          "signature": "String -\u003e IO CString",
          "source": "src/Foreign-C-String.html#newCAString",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into NUL terminated string the Haskell string may not contain any NUL characters new storage is allocated for the string and must be explicitly freed using free or finalizerFree",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "newCAString",
          "normalized": "String-\u003eIO CString",
          "package": "base",
          "partial": "CAString",
          "signature": "String-\u003eIO CString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:newCAString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a C string (ie, character array) with\n explicit length information.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e new storage is allocated for the C string and must be\n   explicitly freed using \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e or\n   \u003ccode\u003e\u003ca\u003efinalizerFree\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Foreign.C.String",
          "name": "newCAStringLen",
          "package": "base",
          "signature": "String -\u003e IO CStringLen",
          "source": "src/Foreign-C-String.html#newCAStringLen",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into string ie character array with explicit length information new storage is allocated for the string and must be explicitly freed using free or finalizerFree",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "newCAStringLen",
          "normalized": "String-\u003eIO CStringLen",
          "package": "base",
          "partial": "CAString Len",
          "signature": "String-\u003eIO CStringLen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:newCAStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a NUL terminated C string.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the Haskell string may \u003cem\u003enot\u003c/em\u003e contain any NUL characters\n\u003c/li\u003e\u003cli\u003e new storage is allocated for the C string and must be\n   explicitly freed using \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e or\n   \u003ccode\u003e\u003ca\u003efinalizerFree\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Foreign.C.String",
          "name": "newCString",
          "package": "base",
          "signature": "String -\u003e IO CString",
          "source": "src/Foreign-C-String.html#newCString",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into NUL terminated string the Haskell string may not contain any NUL characters new storage is allocated for the string and must be explicitly freed using free or finalizerFree",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "newCString",
          "normalized": "String-\u003eIO CString",
          "package": "base",
          "partial": "CString",
          "signature": "String-\u003eIO CString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:newCString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a C string (ie, character array) with\n explicit length information.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e new storage is allocated for the C string and must be\n   explicitly freed using \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e or\n   \u003ccode\u003e\u003ca\u003efinalizerFree\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Foreign.C.String",
          "name": "newCStringLen",
          "package": "base",
          "signature": "String -\u003e IO CStringLen",
          "source": "src/Foreign-C-String.html#newCStringLen",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into string ie character array with explicit length information new storage is allocated for the string and must be explicitly freed using free or finalizerFree",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "newCStringLen",
          "normalized": "String-\u003eIO CStringLen",
          "package": "base",
          "partial": "CString Len",
          "signature": "String-\u003eIO CStringLen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:newCStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a NUL terminated C wide string.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the Haskell string may \u003cem\u003enot\u003c/em\u003e contain any NUL characters\n\u003c/li\u003e\u003cli\u003e new storage is allocated for the C wide string and must\n   be explicitly freed using \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e or\n   \u003ccode\u003e\u003ca\u003efinalizerFree\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Foreign.C.String",
          "name": "newCWString",
          "package": "base",
          "signature": "String -\u003e IO CWString",
          "source": "src/Foreign-C-String.html#newCWString",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into NUL terminated wide string the Haskell string may not contain any NUL characters new storage is allocated for the wide string and must be explicitly freed using free or finalizerFree",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "newCWString",
          "normalized": "String-\u003eIO CWString",
          "package": "base",
          "partial": "CWString",
          "signature": "String-\u003eIO CWString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:newCWString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a C wide string (ie, wide character array)\n with explicit length information.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e new storage is allocated for the C wide string and must\n   be explicitly freed using \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e or\n   \u003ccode\u003e\u003ca\u003efinalizerFree\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Foreign.C.String",
          "name": "newCWStringLen",
          "package": "base",
          "signature": "String -\u003e IO CWStringLen",
          "source": "src/Foreign-C-String.html#newCWStringLen",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into wide string ie wide character array with explicit length information new storage is allocated for the wide string and must be explicitly freed using free or finalizerFree",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "newCWStringLen",
          "normalized": "String-\u003eIO CWStringLen",
          "package": "base",
          "partial": "CWString Len",
          "signature": "String-\u003eIO CWStringLen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:newCWStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a NUL terminated C string into a Haskell string.\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "peekCAString",
          "package": "base",
          "signature": "CString -\u003e IO String",
          "source": "src/Foreign-C-String.html#peekCAString",
          "type": "function"
        },
        "index": {
          "description": "Marshal NUL terminated string into Haskell string",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "peekCAString",
          "normalized": "CString-\u003eIO String",
          "package": "base",
          "partial": "CAString",
          "signature": "CString-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:peekCAString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a C string with explicit length into a Haskell string.\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "peekCAStringLen",
          "package": "base",
          "signature": "CStringLen -\u003e IO String",
          "source": "src/Foreign-C-String.html#peekCAStringLen",
          "type": "function"
        },
        "index": {
          "description": "Marshal string with explicit length into Haskell string",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "peekCAStringLen",
          "normalized": "CStringLen-\u003eIO String",
          "package": "base",
          "partial": "CAString Len",
          "signature": "CStringLen-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:peekCAStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a NUL terminated C string into a Haskell string.\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "peekCString",
          "package": "base",
          "signature": "CString -\u003e IO String",
          "source": "src/Foreign-C-String.html#peekCString",
          "type": "function"
        },
        "index": {
          "description": "Marshal NUL terminated string into Haskell string",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "peekCString",
          "normalized": "CString-\u003eIO String",
          "package": "base",
          "partial": "CString",
          "signature": "CString-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:peekCString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a C string with explicit length into a Haskell string.\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "peekCStringLen",
          "package": "base",
          "signature": "CStringLen -\u003e IO String",
          "source": "src/Foreign-C-String.html#peekCStringLen",
          "type": "function"
        },
        "index": {
          "description": "Marshal string with explicit length into Haskell string",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "peekCStringLen",
          "normalized": "CStringLen-\u003eIO String",
          "package": "base",
          "partial": "CString Len",
          "signature": "CStringLen-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:peekCStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a NUL terminated C wide string into a Haskell string.\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "peekCWString",
          "package": "base",
          "signature": "CWString -\u003e IO String",
          "source": "src/Foreign-C-String.html#peekCWString",
          "type": "function"
        },
        "index": {
          "description": "Marshal NUL terminated wide string into Haskell string",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "peekCWString",
          "normalized": "CWString-\u003eIO String",
          "package": "base",
          "partial": "CWString",
          "signature": "CWString-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:peekCWString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a C wide string with explicit length into a Haskell string.\n\u003c/p\u003e",
          "module": "Foreign.C.String",
          "name": "peekCWStringLen",
          "package": "base",
          "signature": "CWStringLen -\u003e IO String",
          "source": "src/Foreign-C-String.html#peekCWStringLen",
          "type": "function"
        },
        "index": {
          "description": "Marshal wide string with explicit length into Haskell string",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "peekCWStringLen",
          "normalized": "CWStringLen-\u003eIO String",
          "package": "base",
          "partial": "CWString Len",
          "signature": "CWStringLen-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:peekCWStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a NUL terminated C string using temporary\n storage.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the Haskell string may \u003cem\u003enot\u003c/em\u003e contain any NUL characters\n\u003c/li\u003e\u003cli\u003e the memory is freed when the subcomputation terminates (either\n   normally or via an exception), so the pointer to the temporary\n   storage must \u003cem\u003enot\u003c/em\u003e be used after this.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Foreign.C.String",
          "name": "withCAString",
          "package": "base",
          "signature": "String -\u003e (CString -\u003e IO a) -\u003e IO a",
          "source": "src/Foreign-C-String.html#withCAString",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into NUL terminated string using temporary storage the Haskell string may not contain any NUL characters the memory is freed when the subcomputation terminates either normally or via an exception so the pointer to the temporary storage must not be used after this",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "withCAString",
          "normalized": "String-\u003e(CString-\u003eIO a)-\u003eIO a",
          "package": "base",
          "partial": "CAString",
          "signature": "String-\u003e(CString-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:withCAString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a C string (ie, character array)\n in temporary storage, with explicit length information.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the memory is freed when the subcomputation terminates (either\n   normally or via an exception), so the pointer to the temporary\n   storage must \u003cem\u003enot\u003c/em\u003e be used after this.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Foreign.C.String",
          "name": "withCAStringLen",
          "package": "base",
          "signature": "String -\u003e (CStringLen -\u003e IO a) -\u003e IO a",
          "source": "src/Foreign-C-String.html#withCAStringLen",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into string ie character array in temporary storage with explicit length information the memory is freed when the subcomputation terminates either normally or via an exception so the pointer to the temporary storage must not be used after this",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "withCAStringLen",
          "normalized": "String-\u003e(CStringLen-\u003eIO a)-\u003eIO a",
          "package": "base",
          "partial": "CAString Len",
          "signature": "String-\u003e(CStringLen-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:withCAStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a NUL terminated C string using temporary\n storage.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the Haskell string may \u003cem\u003enot\u003c/em\u003e contain any NUL characters\n\u003c/li\u003e\u003cli\u003e the memory is freed when the subcomputation terminates (either\n   normally or via an exception), so the pointer to the temporary\n   storage must \u003cem\u003enot\u003c/em\u003e be used after this.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Foreign.C.String",
          "name": "withCString",
          "package": "base",
          "signature": "String -\u003e (CString -\u003e IO a) -\u003e IO a",
          "source": "src/Foreign-C-String.html#withCString",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into NUL terminated string using temporary storage the Haskell string may not contain any NUL characters the memory is freed when the subcomputation terminates either normally or via an exception so the pointer to the temporary storage must not be used after this",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "withCString",
          "normalized": "String-\u003e(CString-\u003eIO a)-\u003eIO a",
          "package": "base",
          "partial": "CString",
          "signature": "String-\u003e(CString-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:withCString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a C string (ie, character array)\n in temporary storage, with explicit length information.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the memory is freed when the subcomputation terminates (either\n   normally or via an exception), so the pointer to the temporary\n   storage must \u003cem\u003enot\u003c/em\u003e be used after this.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Foreign.C.String",
          "name": "withCStringLen",
          "package": "base",
          "signature": "String -\u003e (CStringLen -\u003e IO a) -\u003e IO a",
          "source": "src/Foreign-C-String.html#withCStringLen",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into string ie character array in temporary storage with explicit length information the memory is freed when the subcomputation terminates either normally or via an exception so the pointer to the temporary storage must not be used after this",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "withCStringLen",
          "normalized": "String-\u003e(CStringLen-\u003eIO a)-\u003eIO a",
          "package": "base",
          "partial": "CString Len",
          "signature": "String-\u003e(CStringLen-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:withCStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a NUL terminated C wide string using\n temporary storage.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the Haskell string may \u003cem\u003enot\u003c/em\u003e contain any NUL characters\n\u003c/li\u003e\u003cli\u003e the memory is freed when the subcomputation terminates (either\n   normally or via an exception), so the pointer to the temporary\n   storage must \u003cem\u003enot\u003c/em\u003e be used after this.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Foreign.C.String",
          "name": "withCWString",
          "package": "base",
          "signature": "String -\u003e (CWString -\u003e IO a) -\u003e IO a",
          "source": "src/Foreign-C-String.html#withCWString",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into NUL terminated wide string using temporary storage the Haskell string may not contain any NUL characters the memory is freed when the subcomputation terminates either normally or via an exception so the pointer to the temporary storage must not be used after this",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "withCWString",
          "normalized": "String-\u003e(CWString-\u003eIO a)-\u003eIO a",
          "package": "base",
          "partial": "CWString",
          "signature": "String-\u003e(CWString-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:withCWString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a C wide string (i.e. wide\n character array) in temporary storage, with explicit length\n information.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the memory is freed when the subcomputation terminates (either\n   normally or via an exception), so the pointer to the temporary\n   storage must \u003cem\u003enot\u003c/em\u003e be used after this.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Foreign.C.String",
          "name": "withCWStringLen",
          "package": "base",
          "signature": "String -\u003e (CWStringLen -\u003e IO a) -\u003e IO a",
          "source": "src/Foreign-C-String.html#withCWStringLen",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into wide string i.e wide character array in temporary storage with explicit length information the memory is freed when the subcomputation terminates either normally or via an exception so the pointer to the temporary storage must not be used after this",
          "hierarchy": "Foreign C String",
          "module": "Foreign.C.String",
          "name": "withCWStringLen",
          "normalized": "String-\u003e(CWStringLen-\u003eIO a)-\u003eIO a",
          "package": "base",
          "partial": "CWString Len",
          "signature": "String-\u003e(CWStringLen-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-String.html#v:withCWStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMapping of C types to corresponding Haskell types.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.C.Types",
          "name": "Types",
          "package": "base",
          "source": "src/Foreign-C-Types.html",
          "type": "module"
        },
        "index": {
          "description": "Mapping of types to corresponding Haskell types",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "Types",
          "package": "base",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003echar\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CChar",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CChar",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the char type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CChar",
          "package": "base",
          "partial": "CChar",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003eclock_t\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CClock",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CClock",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the clock type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CClock",
          "package": "base",
          "partial": "CClock",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CClock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003edouble\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CDouble",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CDouble",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the double type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CDouble",
          "package": "base",
          "partial": "CDouble",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003eFILE\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CFile",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CFile",
          "type": "data"
        },
        "index": {
          "description": "Haskell type representing the FILE type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CFile",
          "package": "base",
          "partial": "CFile",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003efloat\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CFloat",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CFloat",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the float type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CFloat",
          "package": "base",
          "partial": "CFloat",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003efpos_t\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CFpos",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CFpos",
          "type": "data"
        },
        "index": {
          "description": "Haskell type representing the fpos type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CFpos",
          "package": "base",
          "partial": "CFpos",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CFpos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003eint\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CInt",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CInt",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the int type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CInt",
          "package": "base",
          "partial": "CInt",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CIntMax",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CIntMax",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CIntMax",
          "package": "base",
          "partial": "CInt Max",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CIntMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CIntPtr",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CIntPtr",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CIntPtr",
          "package": "base",
          "partial": "CInt Ptr",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CIntPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003ejmp_buf\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CJmpBuf",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CJmpBuf",
          "type": "data"
        },
        "index": {
          "description": "Haskell type representing the jmp buf type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CJmpBuf",
          "package": "base",
          "partial": "CJmp Buf",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CJmpBuf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003elong long\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CLLong",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CLLong",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the long long type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CLLong",
          "package": "base",
          "partial": "CLLong",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CLLong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003elong\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CLong",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CLong",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the long type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CLong",
          "package": "base",
          "partial": "CLong",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CLong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003eptrdiff_t\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CPtrdiff",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CPtrdiff",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the ptrdiff type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CPtrdiff",
          "package": "base",
          "partial": "CPtrdiff",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CPtrdiff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003esigned char\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CSChar",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CSChar",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the signed char type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CSChar",
          "package": "base",
          "partial": "CSChar",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CSChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003esuseconds_t\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CSUSeconds",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CSUSeconds",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the suseconds type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CSUSeconds",
          "package": "base",
          "partial": "CSUSeconds",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CSUSeconds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003eshort\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CShort",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CShort",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the short type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CShort",
          "package": "base",
          "partial": "CShort",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CShort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003esig_atomic_t\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CSigAtomic",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CSigAtomic",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the sig atomic type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CSigAtomic",
          "package": "base",
          "partial": "CSig Atomic",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CSigAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003esize_t\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CSize",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CSize",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the size type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CSize",
          "package": "base",
          "partial": "CSize",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003etime_t\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CTime",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CTime",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the time type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CTime",
          "package": "base",
          "partial": "CTime",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003eunsigned char\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CUChar",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CUChar",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the unsigned char type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CUChar",
          "package": "base",
          "partial": "CUChar",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CUChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003eunsigned int\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CUInt",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CUInt",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the unsigned int type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CUInt",
          "package": "base",
          "partial": "CUInt",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CUInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CUIntMax",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CUIntMax",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CUIntMax",
          "package": "base",
          "partial": "CUInt Max",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CUIntMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CUIntPtr",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CUIntPtr",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CUIntPtr",
          "package": "base",
          "partial": "CUInt Ptr",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CUIntPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003eunsigned long long\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CULLong",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CULLong",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the unsigned long long type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CULLong",
          "package": "base",
          "partial": "CULLong",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CULLong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003eunsigned long\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CULong",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CULong",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the unsigned long type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CULong",
          "package": "base",
          "partial": "CULong",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CULong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003euseconds_t\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CUSeconds",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CUSeconds",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the useconds type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CUSeconds",
          "package": "base",
          "partial": "CUSeconds",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CUSeconds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003eunsigned short\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CUShort",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CUShort",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the unsigned short type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CUShort",
          "package": "base",
          "partial": "CUShort",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CUShort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell type representing the C \u003ccode\u003ewchar_t\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Foreign.C.Types",
          "name": "CWchar",
          "package": "base",
          "source": "src/Foreign-C-Types.html#CWchar",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell type representing the wchar type",
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CWchar",
          "package": "base",
          "partial": "CWchar",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CWchar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CChar",
          "package": "base",
          "signature": "CChar Int8",
          "source": "src/Foreign-C-Types.html#CChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CChar",
          "package": "base",
          "partial": "CChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CClock",
          "package": "base",
          "signature": "CClock Int64",
          "source": "src/Foreign-C-Types.html#CClock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CClock",
          "package": "base",
          "partial": "CClock",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CClock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CDouble",
          "package": "base",
          "signature": "CDouble Double",
          "source": "src/Foreign-C-Types.html#CDouble",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CDouble",
          "package": "base",
          "partial": "CDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CFloat",
          "package": "base",
          "signature": "CFloat Float",
          "source": "src/Foreign-C-Types.html#CFloat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CFloat",
          "package": "base",
          "partial": "CFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CInt",
          "package": "base",
          "signature": "CInt Int32",
          "source": "src/Foreign-C-Types.html#CInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CInt",
          "package": "base",
          "partial": "CInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CIntMax",
          "package": "base",
          "signature": "CIntMax Int64",
          "source": "src/Foreign-C-Types.html#CIntMax",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CIntMax",
          "package": "base",
          "partial": "CInt Max",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CIntMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CIntPtr",
          "package": "base",
          "signature": "CIntPtr Int64",
          "source": "src/Foreign-C-Types.html#CIntPtr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CIntPtr",
          "package": "base",
          "partial": "CInt Ptr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CIntPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CLLong",
          "package": "base",
          "signature": "CLLong Int64",
          "source": "src/Foreign-C-Types.html#CLLong",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CLLong",
          "package": "base",
          "partial": "CLLong",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CLLong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CLong",
          "package": "base",
          "signature": "CLong Int64",
          "source": "src/Foreign-C-Types.html#CLong",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CLong",
          "package": "base",
          "partial": "CLong",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CLong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CPtrdiff",
          "package": "base",
          "signature": "CPtrdiff Int64",
          "source": "src/Foreign-C-Types.html#CPtrdiff",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CPtrdiff",
          "package": "base",
          "partial": "CPtrdiff",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CPtrdiff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CSChar",
          "package": "base",
          "signature": "CSChar Int8",
          "source": "src/Foreign-C-Types.html#CSChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CSChar",
          "package": "base",
          "partial": "CSChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CSChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CSUSeconds",
          "package": "base",
          "signature": "CSUSeconds Int64",
          "source": "src/Foreign-C-Types.html#CSUSeconds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CSUSeconds",
          "package": "base",
          "partial": "CSUSeconds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CSUSeconds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CShort",
          "package": "base",
          "signature": "CShort Int16",
          "source": "src/Foreign-C-Types.html#CShort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CShort",
          "package": "base",
          "partial": "CShort",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CShort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CSigAtomic",
          "package": "base",
          "signature": "CSigAtomic Int32",
          "source": "src/Foreign-C-Types.html#CSigAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CSigAtomic",
          "package": "base",
          "partial": "CSig Atomic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CSigAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CSize",
          "package": "base",
          "signature": "CSize Word64",
          "source": "src/Foreign-C-Types.html#CSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CSize",
          "package": "base",
          "partial": "CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CTime",
          "package": "base",
          "signature": "CTime Int64",
          "source": "src/Foreign-C-Types.html#CTime",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CTime",
          "package": "base",
          "partial": "CTime",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CUChar",
          "package": "base",
          "signature": "CUChar Word8",
          "source": "src/Foreign-C-Types.html#CUChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CUChar",
          "package": "base",
          "partial": "CUChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CUChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CUInt",
          "package": "base",
          "signature": "CUInt Word32",
          "source": "src/Foreign-C-Types.html#CUInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CUInt",
          "package": "base",
          "partial": "CUInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CUInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CUIntMax",
          "package": "base",
          "signature": "CUIntMax Word64",
          "source": "src/Foreign-C-Types.html#CUIntMax",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CUIntMax",
          "package": "base",
          "partial": "CUInt Max",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CUIntMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CUIntPtr",
          "package": "base",
          "signature": "CUIntPtr Word64",
          "source": "src/Foreign-C-Types.html#CUIntPtr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CUIntPtr",
          "package": "base",
          "partial": "CUInt Ptr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CUIntPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CULLong",
          "package": "base",
          "signature": "CULLong Word64",
          "source": "src/Foreign-C-Types.html#CULLong",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CULLong",
          "package": "base",
          "partial": "CULLong",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CULLong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CULong",
          "package": "base",
          "signature": "CULong Word64",
          "source": "src/Foreign-C-Types.html#CULong",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CULong",
          "package": "base",
          "partial": "CULong",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CULong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CUSeconds",
          "package": "base",
          "signature": "CUSeconds Word32",
          "source": "src/Foreign-C-Types.html#CUSeconds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CUSeconds",
          "package": "base",
          "partial": "CUSeconds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CUSeconds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CUShort",
          "package": "base",
          "signature": "CUShort Word16",
          "source": "src/Foreign-C-Types.html#CUShort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CUShort",
          "package": "base",
          "partial": "CUShort",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CUShort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.C.Types",
          "name": "CWchar",
          "package": "base",
          "signature": "CWchar Int32",
          "source": "src/Foreign-C-Types.html#CWchar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign C Types",
          "module": "Foreign.C.Types",
          "name": "CWchar",
          "package": "base",
          "partial": "CWchar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#v:CWchar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBundles the C specific FFI library functionality\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.C",
          "name": "C",
          "package": "base",
          "source": "src/Foreign-C.html",
          "type": "module"
        },
        "index": {
          "description": "Bundles the specific FFI library functionality",
          "hierarchy": "Foreign C",
          "module": "Foreign.C",
          "name": "C",
          "package": "base",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-C.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFFI datatypes and operations that use or require concurrency (GHC only).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.Concurrent",
          "name": "Concurrent",
          "package": "base",
          "source": "src/Foreign-Concurrent.html",
          "type": "module"
        },
        "index": {
          "description": "FFI datatypes and operations that use or require concurrency GHC only",
          "hierarchy": "Foreign Concurrent",
          "module": "Foreign.Concurrent",
          "name": "Concurrent",
          "package": "base",
          "partial": "Concurrent",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Concurrent.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function adds a finalizer to the given \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e.\n The finalizer will run after the last reference to the foreign object\n is dropped, but \u003cem\u003ebefore\u003c/em\u003e all previously registered finalizers for the\n same object.\n\u003c/p\u003e",
          "module": "Foreign.Concurrent",
          "name": "addForeignPtrFinalizer",
          "package": "base",
          "signature": "ForeignPtr a -\u003e IO () -\u003e IO ()",
          "source": "src/Foreign-Concurrent.html#addForeignPtrFinalizer",
          "type": "function"
        },
        "index": {
          "description": "This function adds finalizer to the given ForeignPtr The finalizer will run after the last reference to the foreign object is dropped but before all previously registered finalizers for the same object",
          "hierarchy": "Foreign Concurrent",
          "module": "Foreign.Concurrent",
          "name": "addForeignPtrFinalizer",
          "normalized": "ForeignPtr a-\u003eIO()-\u003eIO()",
          "package": "base",
          "partial": "Foreign Ptr Finalizer",
          "signature": "ForeignPtr a-\u003eIO()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Concurrent.html#v:addForeignPtrFinalizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurns a plain memory reference into a foreign object by associating\n a finalizer - given by the monadic operation - with the reference.\n The finalizer will be executed after the last reference to the\n foreign object is dropped.  There is no guarantee of promptness, and\n in fact there is no guarantee that the finalizer will eventually\n run at all.\n\u003c/p\u003e",
          "module": "Foreign.Concurrent",
          "name": "newForeignPtr",
          "package": "base",
          "signature": "Ptr a -\u003e IO () -\u003e IO (ForeignPtr a)",
          "source": "src/Foreign-Concurrent.html#newForeignPtr",
          "type": "function"
        },
        "index": {
          "description": "Turns plain memory reference into foreign object by associating finalizer given by the monadic operation with the reference The finalizer will be executed after the last reference to the foreign object is dropped There is no guarantee of promptness and in fact there is no guarantee that the finalizer will eventually run at all",
          "hierarchy": "Foreign Concurrent",
          "module": "Foreign.Concurrent",
          "name": "newForeignPtr",
          "normalized": "Ptr a-\u003eIO()-\u003eIO(ForeignPtr a)",
          "package": "base",
          "partial": "Foreign Ptr",
          "signature": "Ptr a-\u003eIO()-\u003eIO(ForeignPtr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Concurrent.html#v:newForeignPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e type and operations.  This module is part of the\n Foreign Function Interface (FFI) and will usually be imported via\n the \u003ca\u003eForeign\u003c/a\u003e module.\n\u003c/p\u003e\u003cp\u003eSafe API Only.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "Safe",
          "package": "base",
          "source": "src/Foreign-ForeignPtr-Safe.html",
          "type": "module"
        },
        "index": {
          "description": "The ForeignPtr type and operations This module is part of the Foreign Function Interface FFI and will usually be imported via the Foreign module Safe API Only",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "Safe",
          "package": "base",
          "partial": "Safe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.ForeignPtr.Safe",
          "name": "FinalizerEnvPtr",
          "package": "base",
          "source": "src/GHC-ForeignPtr.html#FinalizerEnvPtr",
          "type": "type"
        },
        "index": {
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "FinalizerEnvPtr",
          "package": "base",
          "partial": "Finalizer Env Ptr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#t:FinalizerEnvPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA finalizer is represented as a pointer to a foreign function that, at\n finalisation time, gets as an argument a plain pointer variant of the\n foreign pointer that the finalizer is associated with.\n\u003c/p\u003e",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "FinalizerPtr",
          "package": "base",
          "source": "src/GHC-ForeignPtr.html#FinalizerPtr",
          "type": "type"
        },
        "index": {
          "description": "finalizer is represented as pointer to foreign function that at finalisation time gets as an argument plain pointer variant of the foreign pointer that the finalizer is associated with",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "FinalizerPtr",
          "package": "base",
          "partial": "Finalizer Ptr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#t:FinalizerPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e represents references to objects that are\n maintained in a foreign language, i.e., that are not part of the\n data structures usually managed by the Haskell storage manager.\n The essential difference between \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003es and vanilla memory\n references of type \u003ccode\u003ePtr a\u003c/code\u003e is that the former may be associated\n with \u003cem\u003efinalizers\u003c/em\u003e. A finalizer is a routine that is invoked when\n the Haskell storage manager detects that - within the Haskell heap\n and stack - there are no more references left that are pointing to\n the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e.  Typically, the finalizer will, then, invoke\n routines in the foreign language that free the resources bound by\n the foreign object.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e is parameterised in the same way as \u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e.  The\n type argument of \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e should normally be an instance of\n class \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "ForeignPtr",
          "package": "base",
          "source": "src/GHC-ForeignPtr.html#ForeignPtr",
          "type": "data"
        },
        "index": {
          "description": "The type ForeignPtr represents references to objects that are maintained in foreign language i.e that are not part of the data structures usually managed by the Haskell storage manager The essential difference between ForeignPtr and vanilla memory references of type Ptr is that the former may be associated with finalizers finalizer is routine that is invoked when the Haskell storage manager detects that within the Haskell heap and stack there are no more references left that are pointing to the ForeignPtr Typically the finalizer will then invoke routines in the foreign language that free the resources bound by the foreign object The ForeignPtr is parameterised in the same way as Ptr The type argument of ForeignPtr should normally be an instance of class Storable",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "ForeignPtr",
          "package": "base",
          "partial": "Foreign Ptr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#t:ForeignPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function adds a finalizer to the given foreign object.  The\n finalizer will run \u003cem\u003ebefore\u003c/em\u003e all other finalizers for the same\n object which have already been registered.\n\u003c/p\u003e",
          "module": "[\"Foreign.ForeignPtr.Safe\",\"Foreign\"]",
          "name": "addForeignPtrFinalizer",
          "package": "base",
          "signature": "FinalizerPtr a -\u003e ForeignPtr a -\u003e IO ()",
          "source": "src/GHC-ForeignPtr.html#addForeignPtrFinalizer",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:addForeignPtrFinalizer\",\"http://hackage.haskell.org/package/base/docs/Foreign.html#v:addForeignPtrFinalizer\"]"
        },
        "index": {
          "description": "This function adds finalizer to the given foreign object The finalizer will run before all other finalizers for the same object which have already been registered",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "addForeignPtrFinalizer",
          "normalized": "FinalizerPtr a-\u003eForeignPtr a-\u003eIO()",
          "package": "base",
          "partial": "Foreign Ptr Finalizer",
          "signature": "FinalizerPtr a-\u003eForeignPtr a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:addForeignPtrFinalizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eaddForeignPtrFinalizerEnv\u003c/a\u003e\u003c/code\u003e but allows the finalizer to be\n passed an additional environment parameter to be passed to the\n finalizer.  The environment passed to the finalizer is fixed by the\n second argument to \u003ccode\u003e\u003ca\u003eaddForeignPtrFinalizerEnv\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Foreign.ForeignPtr.Safe\",\"Foreign\"]",
          "name": "addForeignPtrFinalizerEnv",
          "package": "base",
          "signature": "FinalizerEnvPtr env a -\u003e Ptr env -\u003e ForeignPtr a -\u003e IO ()",
          "source": "src/GHC-ForeignPtr.html#addForeignPtrFinalizerEnv",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:addForeignPtrFinalizerEnv\",\"http://hackage.haskell.org/package/base/docs/Foreign.html#v:addForeignPtrFinalizerEnv\"]"
        },
        "index": {
          "description": "Like addForeignPtrFinalizerEnv but allows the finalizer to be passed an additional environment parameter to be passed to the finalizer The environment passed to the finalizer is fixed by the second argument to addForeignPtrFinalizerEnv",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "addForeignPtrFinalizerEnv",
          "normalized": "FinalizerEnvPtr a b-\u003ePtr a-\u003eForeignPtr b-\u003eIO()",
          "package": "base",
          "partial": "Foreign Ptr Finalizer Env",
          "signature": "FinalizerEnvPtr env a-\u003ePtr env-\u003eForeignPtr a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:addForeignPtrFinalizerEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function casts a \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e\n parameterised by one type into another type.\n\u003c/p\u003e",
          "module": "[\"Foreign.ForeignPtr.Safe\",\"Foreign\"]",
          "name": "castForeignPtr",
          "package": "base",
          "signature": "ForeignPtr a -\u003e ForeignPtr b",
          "source": "src/GHC-ForeignPtr.html#castForeignPtr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:castForeignPtr\",\"http://hackage.haskell.org/package/base/docs/Foreign.html#v:castForeignPtr\"]"
        },
        "index": {
          "description": "This function casts ForeignPtr parameterised by one type into another type",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "castForeignPtr",
          "normalized": "ForeignPtr a-\u003eForeignPtr b",
          "package": "base",
          "partial": "Foreign Ptr",
          "signature": "ForeignPtr a-\u003eForeignPtr b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:castForeignPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCauses the finalizers associated with a foreign pointer to be run\n immediately.\n\u003c/p\u003e",
          "module": "[\"Foreign.ForeignPtr.Safe\",\"Foreign\"]",
          "name": "finalizeForeignPtr",
          "package": "base",
          "signature": "ForeignPtr a -\u003e IO ()",
          "source": "src/GHC-ForeignPtr.html#finalizeForeignPtr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:finalizeForeignPtr\",\"http://hackage.haskell.org/package/base/docs/Foreign.html#v:finalizeForeignPtr\"]"
        },
        "index": {
          "description": "Causes the finalizers associated with foreign pointer to be run immediately",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "finalizeForeignPtr",
          "normalized": "ForeignPtr a-\u003eIO()",
          "package": "base",
          "partial": "Foreign Ptr",
          "signature": "ForeignPtr a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:finalizeForeignPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate some memory and return a \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e to it.  The memory\n will be released automatically when the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e is discarded.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003emallocForeignPtr\u003c/a\u003e\u003c/code\u003e is equivalent to\n\u003c/p\u003e\u003cpre\u003e    do { p \u003c- malloc; newForeignPtr finalizerFree p }\n\u003c/pre\u003e\u003cp\u003ealthough it may be implemented differently internally: you may not\n assume that the memory returned by \u003ccode\u003e\u003ca\u003emallocForeignPtr\u003c/a\u003e\u003c/code\u003e has been\n allocated with \u003ccode\u003e\u003ca\u003emalloc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eGHC notes: \u003ccode\u003e\u003ca\u003emallocForeignPtr\u003c/a\u003e\u003c/code\u003e has a heavily optimised\n implementation in GHC.  It uses pinned memory in the garbage\n collected heap, so the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e does not require a finalizer to\n free the memory.  Use of \u003ccode\u003e\u003ca\u003emallocForeignPtr\u003c/a\u003e\u003c/code\u003e and associated\n functions is strongly recommended in preference to \u003ccode\u003enewForeignPtr\u003c/code\u003e\n with a finalizer.\n\u003c/p\u003e",
          "module": "[\"Foreign.ForeignPtr.Safe\",\"Foreign\"]",
          "name": "mallocForeignPtr",
          "package": "base",
          "signature": "IO (ForeignPtr a)",
          "source": "src/GHC-ForeignPtr.html#mallocForeignPtr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:mallocForeignPtr\",\"http://hackage.haskell.org/package/base/docs/Foreign.html#v:mallocForeignPtr\"]"
        },
        "index": {
          "description": "Allocate some memory and return ForeignPtr to it The memory will be released automatically when the ForeignPtr is discarded mallocForeignPtr is equivalent to do malloc newForeignPtr finalizerFree although it may be implemented differently internally you may not assume that the memory returned by mallocForeignPtr has been allocated with malloc GHC notes mallocForeignPtr has heavily optimised implementation in GHC It uses pinned memory in the garbage collected heap so the ForeignPtr does not require finalizer to free the memory Use of mallocForeignPtr and associated functions is strongly recommended in preference to newForeignPtr with finalizer",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "mallocForeignPtr",
          "package": "base",
          "partial": "Foreign Ptr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:mallocForeignPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function is similar to \u003ccode\u003e\u003ca\u003emallocArray\u003c/a\u003e\u003c/code\u003e,\n but yields a memory area that has a finalizer attached that releases\n the memory area.  As with \u003ccode\u003e\u003ca\u003emallocForeignPtr\u003c/a\u003e\u003c/code\u003e, it is not guaranteed that\n the block of memory was allocated by \u003ccode\u003e\u003ca\u003emalloc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Foreign.ForeignPtr.Safe\",\"Foreign\"]",
          "name": "mallocForeignPtrArray",
          "package": "base",
          "signature": "Int -\u003e IO (ForeignPtr a)",
          "source": "src/Foreign-ForeignPtr-Imp.html#mallocForeignPtrArray",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:mallocForeignPtrArray\",\"http://hackage.haskell.org/package/base/docs/Foreign.html#v:mallocForeignPtrArray\"]"
        },
        "index": {
          "description": "This function is similar to mallocArray but yields memory area that has finalizer attached that releases the memory area As with mallocForeignPtr it is not guaranteed that the block of memory was allocated by malloc",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "mallocForeignPtrArray",
          "normalized": "Int-\u003eIO(ForeignPtr a)",
          "package": "base",
          "partial": "Foreign Ptr Array",
          "signature": "Int-\u003eIO(ForeignPtr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:mallocForeignPtrArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function is similar to \u003ccode\u003e\u003ca\u003emallocArray0\u003c/a\u003e\u003c/code\u003e,\n but yields a memory area that has a finalizer attached that releases\n the memory area.  As with \u003ccode\u003e\u003ca\u003emallocForeignPtr\u003c/a\u003e\u003c/code\u003e, it is not guaranteed that\n the block of memory was allocated by \u003ccode\u003e\u003ca\u003emalloc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Foreign.ForeignPtr.Safe\",\"Foreign\"]",
          "name": "mallocForeignPtrArray0",
          "package": "base",
          "signature": "Int -\u003e IO (ForeignPtr a)",
          "source": "src/Foreign-ForeignPtr-Imp.html#mallocForeignPtrArray0",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:mallocForeignPtrArray0\",\"http://hackage.haskell.org/package/base/docs/Foreign.html#v:mallocForeignPtrArray0\"]"
        },
        "index": {
          "description": "This function is similar to mallocArray0 but yields memory area that has finalizer attached that releases the memory area As with mallocForeignPtr it is not guaranteed that the block of memory was allocated by malloc",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "mallocForeignPtrArray0",
          "normalized": "Int-\u003eIO(ForeignPtr a)",
          "package": "base",
          "partial": "Foreign Ptr Array",
          "signature": "Int-\u003eIO(ForeignPtr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:mallocForeignPtrArray0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function is similar to \u003ccode\u003e\u003ca\u003emallocForeignPtr\u003c/a\u003e\u003c/code\u003e, except that the\n size of the memory required is given explicitly as a number of bytes.\n\u003c/p\u003e",
          "module": "[\"Foreign.ForeignPtr.Safe\",\"Foreign\"]",
          "name": "mallocForeignPtrBytes",
          "package": "base",
          "signature": "Int -\u003e IO (ForeignPtr a)",
          "source": "src/GHC-ForeignPtr.html#mallocForeignPtrBytes",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:mallocForeignPtrBytes\",\"http://hackage.haskell.org/package/base/docs/Foreign.html#v:mallocForeignPtrBytes\"]"
        },
        "index": {
          "description": "This function is similar to mallocForeignPtr except that the size of the memory required is given explicitly as number of bytes",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "mallocForeignPtrBytes",
          "normalized": "Int-\u003eIO(ForeignPtr a)",
          "package": "base",
          "partial": "Foreign Ptr Bytes",
          "signature": "Int-\u003eIO(ForeignPtr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:mallocForeignPtrBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurns a plain memory reference into a foreign pointer, and\n associates a finalizer with the reference.  The finalizer will be\n executed after the last reference to the foreign object is dropped.\n There is no guarantee of promptness, however the finalizer will be\n executed before the program exits.\n\u003c/p\u003e",
          "module": "[\"Foreign.ForeignPtr.Safe\",\"Foreign\"]",
          "name": "newForeignPtr",
          "package": "base",
          "signature": "FinalizerPtr a -\u003e Ptr a -\u003e IO (ForeignPtr a)",
          "source": "src/Foreign-ForeignPtr-Imp.html#newForeignPtr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:newForeignPtr\",\"http://hackage.haskell.org/package/base/docs/Foreign.html#v:newForeignPtr\"]"
        },
        "index": {
          "description": "Turns plain memory reference into foreign pointer and associates finalizer with the reference The finalizer will be executed after the last reference to the foreign object is dropped There is no guarantee of promptness however the finalizer will be executed before the program exits",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "newForeignPtr",
          "normalized": "FinalizerPtr a-\u003ePtr a-\u003eIO(ForeignPtr a)",
          "package": "base",
          "partial": "Foreign Ptr",
          "signature": "FinalizerPtr a-\u003ePtr a-\u003eIO(ForeignPtr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:newForeignPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis variant of \u003ccode\u003e\u003ca\u003enewForeignPtr\u003c/a\u003e\u003c/code\u003e adds a finalizer that expects an\n environment in addition to the finalized pointer.  The environment\n that will be passed to the finalizer is fixed by the second argument to\n \u003ccode\u003e\u003ca\u003enewForeignPtrEnv\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Foreign.ForeignPtr.Safe\",\"Foreign\"]",
          "name": "newForeignPtrEnv",
          "package": "base",
          "signature": "FinalizerEnvPtr env a -\u003e Ptr env -\u003e Ptr a -\u003e IO (ForeignPtr a)",
          "source": "src/Foreign-ForeignPtr-Imp.html#newForeignPtrEnv",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:newForeignPtrEnv\",\"http://hackage.haskell.org/package/base/docs/Foreign.html#v:newForeignPtrEnv\"]"
        },
        "index": {
          "description": "This variant of newForeignPtr adds finalizer that expects an environment in addition to the finalized pointer The environment that will be passed to the finalizer is fixed by the second argument to newForeignPtrEnv",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "newForeignPtrEnv",
          "normalized": "FinalizerEnvPtr a b-\u003ePtr a-\u003ePtr b-\u003eIO(ForeignPtr b)",
          "package": "base",
          "partial": "Foreign Ptr Env",
          "signature": "FinalizerEnvPtr env a-\u003ePtr env-\u003ePtr a-\u003eIO(ForeignPtr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:newForeignPtrEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurns a plain memory reference into a foreign pointer that may be\n associated with finalizers by using \u003ccode\u003e\u003ca\u003eaddForeignPtrFinalizer\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Foreign.ForeignPtr.Safe\",\"Foreign\"]",
          "name": "newForeignPtr_",
          "package": "base",
          "signature": "Ptr a -\u003e IO (ForeignPtr a)",
          "source": "src/GHC-ForeignPtr.html#newForeignPtr_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:newForeignPtr_\",\"http://hackage.haskell.org/package/base/docs/Foreign.html#v:newForeignPtr_\"]"
        },
        "index": {
          "description": "Turns plain memory reference into foreign pointer that may be associated with finalizers by using addForeignPtrFinalizer",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "newForeignPtr_",
          "normalized": "Ptr a-\u003eIO(ForeignPtr a)",
          "package": "base",
          "partial": "Foreign Ptr",
          "signature": "Ptr a-\u003eIO(ForeignPtr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:newForeignPtr_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function ensures that the foreign object in\n question is alive at the given place in the sequence of IO\n actions. In particular \u003ccode\u003e\u003ca\u003ewithForeignPtr\u003c/a\u003e\u003c/code\u003e\n does a \u003ccode\u003e\u003ca\u003etouchForeignPtr\u003c/a\u003e\u003c/code\u003e after it\n executes the user action.\n\u003c/p\u003e\u003cp\u003eNote that this function should not be used to express dependencies\n between finalizers on \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003es.  For example, if the finalizer\n for a \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eF1\u003c/code\u003e calls \u003ccode\u003e\u003ca\u003etouchForeignPtr\u003c/a\u003e\u003c/code\u003e on a second\n \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eF2\u003c/code\u003e, then the only guarantee is that the finalizer\n for \u003ccode\u003eF2\u003c/code\u003e is never started before the finalizer for \u003ccode\u003eF1\u003c/code\u003e.  They\n might be started together if for example both \u003ccode\u003eF1\u003c/code\u003e and \u003ccode\u003eF2\u003c/code\u003e are\n otherwise unreachable, and in that case the scheduler might end up\n running the finalizer for \u003ccode\u003eF2\u003c/code\u003e first.\n\u003c/p\u003e\u003cp\u003eIn general, it is not recommended to use finalizers on separate\n objects with ordering constraints between them.  To express the\n ordering robustly requires explicit synchronisation using \u003ccode\u003eMVar\u003c/code\u003es\n between the finalizers, but even then the runtime sometimes runs\n multiple finalizers sequentially in a single thread (for\n performance reasons), so synchronisation between finalizers could\n result in artificial deadlock.  Another alternative is to use\n explicit reference counting.\n\u003c/p\u003e",
          "module": "[\"Foreign.ForeignPtr.Safe\",\"Foreign\"]",
          "name": "touchForeignPtr",
          "package": "base",
          "signature": "ForeignPtr a -\u003e IO ()",
          "source": "src/GHC-ForeignPtr.html#touchForeignPtr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:touchForeignPtr\",\"http://hackage.haskell.org/package/base/docs/Foreign.html#v:touchForeignPtr\"]"
        },
        "index": {
          "description": "This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions In particular withForeignPtr does touchForeignPtr after it executes the user action Note that this function should not be used to express dependencies between finalizers on ForeignPtr For example if the finalizer for ForeignPtr F1 calls touchForeignPtr on second ForeignPtr F2 then the only guarantee is that the finalizer for F2 is never started before the finalizer for F1 They might be started together if for example both F1 and F2 are otherwise unreachable and in that case the scheduler might end up running the finalizer for F2 first In general it is not recommended to use finalizers on separate objects with ordering constraints between them To express the ordering robustly requires explicit synchronisation using MVar between the finalizers but even then the runtime sometimes runs multiple finalizers sequentially in single thread for performance reasons so synchronisation between finalizers could result in artificial deadlock Another alternative is to use explicit reference counting",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "touchForeignPtr",
          "normalized": "ForeignPtr a-\u003eIO()",
          "package": "base",
          "partial": "Foreign Ptr",
          "signature": "ForeignPtr a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:touchForeignPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a way to look at the pointer living inside a\n foreign object.  This function takes a function which is\n applied to that pointer. The resulting \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e action is then\n executed. The foreign object is kept alive at least during\n the whole action, even if it is not used directly\n inside. Note that it is not safe to return the pointer from\n the action and use it after the action completes. All uses\n of the pointer should be inside the\n \u003ccode\u003e\u003ca\u003ewithForeignPtr\u003c/a\u003e\u003c/code\u003e bracket.  The reason for\n this unsafeness is the same as for\n \u003ccode\u003e\u003ca\u003eunsafeForeignPtrToPtr\u003c/a\u003e\u003c/code\u003e below: the finalizer\n may run earlier than expected, because the compiler can only\n track usage of the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e object, not\n a \u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e object made from it.\n\u003c/p\u003e\u003cp\u003eThis function is normally used for marshalling data to\n or from the object pointed to by the\n \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e, using the operations from the\n \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "[\"Foreign.ForeignPtr.Safe\",\"Foreign\"]",
          "name": "withForeignPtr",
          "package": "base",
          "signature": "ForeignPtr a -\u003e (Ptr a -\u003e IO b) -\u003e IO b",
          "source": "src/Foreign-ForeignPtr-Imp.html#withForeignPtr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:withForeignPtr\",\"http://hackage.haskell.org/package/base/docs/Foreign.html#v:withForeignPtr\"]"
        },
        "index": {
          "description": "This is way to look at the pointer living inside foreign object This function takes function which is applied to that pointer The resulting IO action is then executed The foreign object is kept alive at least during the whole action even if it is not used directly inside Note that it is not safe to return the pointer from the action and use it after the action completes All uses of the pointer should be inside the withForeignPtr bracket The reason for this unsafeness is the same as for unsafeForeignPtrToPtr below the finalizer may run earlier than expected because the compiler can only track usage of the ForeignPtr object not Ptr object made from it This function is normally used for marshalling data to or from the object pointed to by the ForeignPtr using the operations from the Storable class",
          "hierarchy": "Foreign ForeignPtr Safe",
          "module": "Foreign.ForeignPtr.Safe",
          "name": "withForeignPtr",
          "normalized": "ForeignPtr a-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "partial": "Foreign Ptr",
          "signature": "ForeignPtr a-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Safe.html#v:withForeignPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e type and operations.  This module is part of the\n Foreign Function Interface (FFI) and will usually be imported via\n the \u003ca\u003eForeign\u003c/a\u003e module.\n\u003c/p\u003e\u003cp\u003eUnsafe API Only.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.ForeignPtr.Unsafe",
          "name": "Unsafe",
          "package": "base",
          "source": "src/Foreign-ForeignPtr-Unsafe.html",
          "type": "module"
        },
        "index": {
          "description": "The ForeignPtr type and operations This module is part of the Foreign Function Interface FFI and will usually be imported via the Foreign module Unsafe API Only",
          "hierarchy": "Foreign ForeignPtr Unsafe",
          "module": "Foreign.ForeignPtr.Unsafe",
          "name": "Unsafe",
          "package": "base",
          "partial": "Unsafe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Unsafe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function extracts the pointer component of a foreign\n pointer.  This is a potentially dangerous operations, as if the\n argument to \u003ccode\u003e\u003ca\u003eunsafeForeignPtrToPtr\u003c/a\u003e\u003c/code\u003e is the last usage\n occurrence of the given foreign pointer, then its finalizer(s) will\n be run, which potentially invalidates the plain pointer just\n obtained.  Hence, \u003ccode\u003e\u003ca\u003etouchForeignPtr\u003c/a\u003e\u003c/code\u003e must be used\n wherever it has to be guaranteed that the pointer lives on - i.e.,\n has another usage occurrence.\n\u003c/p\u003e\u003cp\u003eTo avoid subtle coding errors, hand written marshalling code\n should preferably use \u003ccode\u003e\u003ca\u003ewithForeignPtr\u003c/a\u003e\u003c/code\u003e rather\n than combinations of \u003ccode\u003e\u003ca\u003eunsafeForeignPtrToPtr\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003etouchForeignPtr\u003c/a\u003e\u003c/code\u003e.  However, the latter routines\n are occasionally preferred in tool generated marshalling code.\n\u003c/p\u003e",
          "module": "Foreign.ForeignPtr.Unsafe",
          "name": "unsafeForeignPtrToPtr",
          "package": "base",
          "signature": "ForeignPtr a -\u003e Ptr a",
          "source": "src/GHC-ForeignPtr.html#unsafeForeignPtrToPtr",
          "type": "function"
        },
        "index": {
          "description": "This function extracts the pointer component of foreign pointer This is potentially dangerous operations as if the argument to unsafeForeignPtrToPtr is the last usage occurrence of the given foreign pointer then its finalizer will be run which potentially invalidates the plain pointer just obtained Hence touchForeignPtr must be used wherever it has to be guaranteed that the pointer lives on i.e has another usage occurrence To avoid subtle coding errors hand written marshalling code should preferably use withForeignPtr rather than combinations of unsafeForeignPtrToPtr and touchForeignPtr However the latter routines are occasionally preferred in tool generated marshalling code",
          "hierarchy": "Foreign ForeignPtr Unsafe",
          "module": "Foreign.ForeignPtr.Unsafe",
          "name": "unsafeForeignPtrToPtr",
          "normalized": "ForeignPtr a-\u003ePtr a",
          "package": "base",
          "partial": "Foreign Ptr To Ptr",
          "signature": "ForeignPtr a-\u003ePtr a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-ForeignPtr-Unsafe.html#v:unsafeForeignPtrToPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe module \u003ca\u003eForeign.Marshal.Alloc\u003c/a\u003e provides operations to allocate and\n deallocate blocks of raw memory (i.e., unstructured chunks of memory\n outside of the area maintained by the Haskell storage manager).  These\n memory blocks are commonly used to pass compound data structures to\n foreign functions or to provide space in which compound result values\n are obtained from foreign functions.\n\u003c/p\u003e\u003cp\u003eIf any of the allocation functions fails, an exception is thrown.\n In some cases, memory exhaustion may mean the process is terminated.\n If \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ereallocBytes\u003c/a\u003e\u003c/code\u003e is applied to a memory area\n that has been allocated with \u003ccode\u003e\u003ca\u003ealloca\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eallocaBytes\u003c/a\u003e\u003c/code\u003e, the\n behaviour is undefined.  Any further access to memory areas allocated with\n \u003ccode\u003e\u003ca\u003ealloca\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eallocaBytes\u003c/a\u003e\u003c/code\u003e, after the computation that was passed to\n the allocation function has terminated, leads to undefined behaviour.  Any\n further access to the memory area referenced by a pointer passed to\n \u003ccode\u003e\u003ca\u003erealloc\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ereallocBytes\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e entails undefined\n behaviour.\n\u003c/p\u003e\u003cp\u003eAll storage allocated by functions that allocate based on a \u003cem\u003esize in bytes\u003c/em\u003e\n must be sufficiently aligned for any of the basic foreign types\n that fits into the newly allocated storage. All storage allocated by\n functions that allocate based on a specific type must be sufficiently\n aligned for that type. Array allocation routines need to obey the same\n alignment constraints for each array element.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.Marshal.Alloc",
          "name": "Alloc",
          "package": "base",
          "source": "src/Foreign-Marshal-Alloc.html",
          "type": "module"
        },
        "index": {
          "description": "The module Foreign.Marshal.Alloc provides operations to allocate and deallocate blocks of raw memory i.e unstructured chunks of memory outside of the area maintained by the Haskell storage manager These memory blocks are commonly used to pass compound data structures to foreign functions or to provide space in which compound result values are obtained from foreign functions If any of the allocation functions fails an exception is thrown In some cases memory exhaustion may mean the process is terminated If free or reallocBytes is applied to memory area that has been allocated with alloca or allocaBytes the behaviour is undefined Any further access to memory areas allocated with alloca or allocaBytes after the computation that was passed to the allocation function has terminated leads to undefined behaviour Any further access to the memory area referenced by pointer passed to realloc reallocBytes or free entails undefined behaviour All storage allocated by functions that allocate based on size in bytes must be sufficiently aligned for any of the basic foreign types that fits into the newly allocated storage All storage allocated by functions that allocate based on specific type must be sufficiently aligned for that type Array allocation routines need to obey the same alignment constraints for each array element",
          "hierarchy": "Foreign Marshal Alloc",
          "module": "Foreign.Marshal.Alloc",
          "name": "Alloc",
          "package": "base",
          "partial": "Alloc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Alloc.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ealloca\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e executes the computation \u003ccode\u003ef\u003c/code\u003e, passing as argument\n a pointer to a temporarily allocated block of memory sufficient to\n hold values of type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe memory is freed when \u003ccode\u003ef\u003c/code\u003e terminates (either normally or via an\n exception), so the pointer passed to \u003ccode\u003ef\u003c/code\u003e must \u003cem\u003enot\u003c/em\u003e be used after this.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Alloc",
          "name": "alloca",
          "package": "base",
          "signature": "(Ptr a -\u003e IO b) -\u003e IO b",
          "source": "src/Foreign-Marshal-Alloc.html#alloca",
          "type": "function"
        },
        "index": {
          "description": "alloca executes the computation passing as argument pointer to temporarily allocated block of memory sufficient to hold values of type The memory is freed when terminates either normally or via an exception so the pointer passed to must not be used after this",
          "hierarchy": "Foreign Marshal Alloc",
          "module": "Foreign.Marshal.Alloc",
          "name": "alloca",
          "normalized": "(Ptr a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "signature": "(Ptr a-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Alloc.html#v:alloca"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eallocaBytes\u003c/a\u003e\u003c/code\u003e n f\u003c/code\u003e executes the computation \u003ccode\u003ef\u003c/code\u003e, passing as argument\n a pointer to a temporarily allocated block of memory of \u003ccode\u003en\u003c/code\u003e bytes.\n The block of memory is sufficiently aligned for any of the basic\n foreign types that fits into a memory block of the allocated size.\n\u003c/p\u003e\u003cp\u003eThe memory is freed when \u003ccode\u003ef\u003c/code\u003e terminates (either normally or via an\n exception), so the pointer passed to \u003ccode\u003ef\u003c/code\u003e must \u003cem\u003enot\u003c/em\u003e be used after this.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Alloc",
          "name": "allocaBytes",
          "package": "base",
          "signature": "Int -\u003e (Ptr a -\u003e IO b) -\u003e IO b",
          "source": "src/Foreign-Marshal-Alloc.html#allocaBytes",
          "type": "function"
        },
        "index": {
          "description": "allocaBytes executes the computation passing as argument pointer to temporarily allocated block of memory of bytes The block of memory is sufficiently aligned for any of the basic foreign types that fits into memory block of the allocated size The memory is freed when terminates either normally or via an exception so the pointer passed to must not be used after this",
          "hierarchy": "Foreign Marshal Alloc",
          "module": "Foreign.Marshal.Alloc",
          "name": "allocaBytes",
          "normalized": "Int-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "partial": "Bytes",
          "signature": "Int-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Alloc.html#v:allocaBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign.Marshal.Alloc",
          "name": "allocaBytesAligned",
          "package": "base",
          "signature": "Int -\u003e Int -\u003e (Ptr a -\u003e IO b) -\u003e IO b",
          "source": "src/Foreign-Marshal-Alloc.html#allocaBytesAligned",
          "type": "function"
        },
        "index": {
          "hierarchy": "Foreign Marshal Alloc",
          "module": "Foreign.Marshal.Alloc",
          "name": "allocaBytesAligned",
          "normalized": "Int-\u003eInt-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "partial": "Bytes Aligned",
          "signature": "Int-\u003eInt-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Alloc.html#v:allocaBytesAligned"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pointer to a foreign function equivalent to \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e, which may be\n used as a finalizer (cf \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e) for storage\n allocated with \u003ccode\u003e\u003ca\u003emalloc\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003emallocBytes\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003erealloc\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ereallocBytes\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Alloc",
          "name": "finalizerFree",
          "package": "base",
          "signature": "FinalizerPtr a",
          "source": "src/Foreign-Marshal-Alloc.html#finalizerFree",
          "type": "function"
        },
        "index": {
          "description": "pointer to foreign function equivalent to free which may be used as finalizer cf ForeignPtr for storage allocated with malloc mallocBytes realloc or reallocBytes",
          "hierarchy": "Foreign Marshal Alloc",
          "module": "Foreign.Marshal.Alloc",
          "name": "finalizerFree",
          "package": "base",
          "partial": "Free",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Alloc.html#v:finalizerFree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFree a block of memory that was allocated with \u003ccode\u003e\u003ca\u003emalloc\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003emallocBytes\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003erealloc\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ereallocBytes\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003enew\u003c/a\u003e\u003c/code\u003e\n or any of the \u003ccode\u003enew\u003c/code\u003e\u003cem\u003eX\u003c/em\u003e functions in \u003ca\u003eForeign.Marshal.Array\u003c/a\u003e or\n \u003ca\u003eForeign.C.String\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Alloc",
          "name": "free",
          "package": "base",
          "signature": "Ptr a -\u003e IO ()",
          "source": "src/Foreign-Marshal-Alloc.html#free",
          "type": "function"
        },
        "index": {
          "description": "Free block of memory that was allocated with malloc mallocBytes realloc reallocBytes new or any of the new functions in Foreign.Marshal.Array or Foreign.C.String",
          "hierarchy": "Foreign Marshal Alloc",
          "module": "Foreign.Marshal.Alloc",
          "name": "free",
          "normalized": "Ptr a-\u003eIO()",
          "package": "base",
          "signature": "Ptr a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Alloc.html#v:free"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate a block of memory that is sufficient to hold values of type\n \u003ccode\u003ea\u003c/code\u003e.  The size of the area allocated is determined by the \u003ccode\u003e\u003ca\u003esizeOf\u003c/a\u003e\u003c/code\u003e\n method from the instance of \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e for the appropriate type.\n\u003c/p\u003e\u003cp\u003eThe memory may be deallocated using \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003efinalizerFree\u003c/a\u003e\u003c/code\u003e when\n no longer required.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Alloc",
          "name": "malloc",
          "package": "base",
          "signature": "IO (Ptr a)",
          "source": "src/Foreign-Marshal-Alloc.html#malloc",
          "type": "function"
        },
        "index": {
          "description": "Allocate block of memory that is sufficient to hold values of type The size of the area allocated is determined by the sizeOf method from the instance of Storable for the appropriate type The memory may be deallocated using free or finalizerFree when no longer required",
          "hierarchy": "Foreign Marshal Alloc",
          "module": "Foreign.Marshal.Alloc",
          "name": "malloc",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Alloc.html#v:malloc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate a block of memory of the given number of bytes.\n The block of memory is sufficiently aligned for any of the basic\n foreign types that fits into a memory block of the allocated size.\n\u003c/p\u003e\u003cp\u003eThe memory may be deallocated using \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003efinalizerFree\u003c/a\u003e\u003c/code\u003e when\n no longer required.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Alloc",
          "name": "mallocBytes",
          "package": "base",
          "signature": "Int -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Alloc.html#mallocBytes",
          "type": "function"
        },
        "index": {
          "description": "Allocate block of memory of the given number of bytes The block of memory is sufficiently aligned for any of the basic foreign types that fits into memory block of the allocated size The memory may be deallocated using free or finalizerFree when no longer required",
          "hierarchy": "Foreign Marshal Alloc",
          "module": "Foreign.Marshal.Alloc",
          "name": "mallocBytes",
          "normalized": "Int-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Bytes",
          "signature": "Int-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Alloc.html#v:mallocBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResize a memory area that was allocated with \u003ccode\u003e\u003ca\u003emalloc\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003emallocBytes\u003c/a\u003e\u003c/code\u003e\n to the size needed to store values of type \u003ccode\u003eb\u003c/code\u003e.  The returned pointer\n may refer to an entirely different memory area, but will be suitably\n aligned to hold values of type \u003ccode\u003eb\u003c/code\u003e.  The contents of the referenced\n memory area will be the same as of the original pointer up to the\n minimum of the original size and the size of values of type \u003ccode\u003eb\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the argument to \u003ccode\u003e\u003ca\u003erealloc\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003enullPtr\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003erealloc\u003c/a\u003e\u003c/code\u003e behaves like\n \u003ccode\u003e\u003ca\u003emalloc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Alloc",
          "name": "realloc",
          "package": "base",
          "signature": "Ptr a -\u003e IO (Ptr b)",
          "source": "src/Foreign-Marshal-Alloc.html#realloc",
          "type": "function"
        },
        "index": {
          "description": "Resize memory area that was allocated with malloc or mallocBytes to the size needed to store values of type The returned pointer may refer to an entirely different memory area but will be suitably aligned to hold values of type The contents of the referenced memory area will be the same as of the original pointer up to the minimum of the original size and the size of values of type If the argument to realloc is nullPtr realloc behaves like malloc",
          "hierarchy": "Foreign Marshal Alloc",
          "module": "Foreign.Marshal.Alloc",
          "name": "realloc",
          "normalized": "Ptr a-\u003eIO(Ptr b)",
          "package": "base",
          "signature": "Ptr a-\u003eIO(Ptr b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Alloc.html#v:realloc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResize a memory area that was allocated with \u003ccode\u003e\u003ca\u003emalloc\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003emallocBytes\u003c/a\u003e\u003c/code\u003e\n to the given size.  The returned pointer may refer to an entirely\n different memory area, but will be sufficiently aligned for any of the\n basic foreign types that fits into a memory block of the given size.\n The contents of the referenced memory area will be the same as of\n the original pointer up to the minimum of the original size and the\n given size.\n\u003c/p\u003e\u003cp\u003eIf the pointer argument to \u003ccode\u003e\u003ca\u003ereallocBytes\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003enullPtr\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ereallocBytes\u003c/a\u003e\u003c/code\u003e\n behaves like \u003ccode\u003e\u003ca\u003emalloc\u003c/a\u003e\u003c/code\u003e.  If the requested size is 0, \u003ccode\u003e\u003ca\u003ereallocBytes\u003c/a\u003e\u003c/code\u003e\n behaves like \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Alloc",
          "name": "reallocBytes",
          "package": "base",
          "signature": "Ptr a -\u003e Int -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Alloc.html#reallocBytes",
          "type": "function"
        },
        "index": {
          "description": "Resize memory area that was allocated with malloc or mallocBytes to the given size The returned pointer may refer to an entirely different memory area but will be sufficiently aligned for any of the basic foreign types that fits into memory block of the given size The contents of the referenced memory area will be the same as of the original pointer up to the minimum of the original size and the given size If the pointer argument to reallocBytes is nullPtr reallocBytes behaves like malloc If the requested size is reallocBytes behaves like free",
          "hierarchy": "Foreign Marshal Alloc",
          "module": "Foreign.Marshal.Alloc",
          "name": "reallocBytes",
          "normalized": "Ptr a-\u003eInt-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Bytes",
          "signature": "Ptr a-\u003eInt-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Alloc.html#v:reallocBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMarshalling support: routines allocating, storing, and retrieving Haskell\n lists that are represented as arrays in the foreign language\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "Array",
          "package": "base",
          "source": "src/Foreign-Marshal-Array.html",
          "type": "module"
        },
        "index": {
          "description": "Marshalling support routines allocating storing and retrieving Haskell lists that are represented as arrays in the foreign language",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "Array",
          "package": "base",
          "partial": "Array",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdvance a pointer into an array by the given number of elements\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "advancePtr",
          "package": "base",
          "signature": "Ptr a -\u003e Int -\u003e Ptr a",
          "source": "src/Foreign-Marshal-Array.html#advancePtr",
          "type": "function"
        },
        "index": {
          "description": "Advance pointer into an array by the given number of elements",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "advancePtr",
          "normalized": "Ptr a-\u003eInt-\u003ePtr a",
          "package": "base",
          "partial": "Ptr",
          "signature": "Ptr a-\u003eInt-\u003ePtr a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:advancePtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTemporarily allocate space for the given number of elements\n (like \u003ccode\u003e\u003ca\u003ealloca\u003c/a\u003e\u003c/code\u003e, but for multiple elements).\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "allocaArray",
          "package": "base",
          "signature": "Int -\u003e (Ptr a -\u003e IO b) -\u003e IO b",
          "source": "src/Foreign-Marshal-Array.html#allocaArray",
          "type": "function"
        },
        "index": {
          "description": "Temporarily allocate space for the given number of elements like alloca but for multiple elements",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "allocaArray",
          "normalized": "Int-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "partial": "Array",
          "signature": "Int-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:allocaArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eallocaArray\u003c/a\u003e\u003c/code\u003e, but add an extra position to hold a special\n termination element.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "allocaArray0",
          "package": "base",
          "signature": "Int -\u003e (Ptr a -\u003e IO b) -\u003e IO b",
          "source": "src/Foreign-Marshal-Array.html#allocaArray0",
          "type": "function"
        },
        "index": {
          "description": "Like allocaArray but add an extra position to hold special termination element",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "allocaArray0",
          "normalized": "Int-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "partial": "Array",
          "signature": "Int-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:allocaArray0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCopy the given number of elements from the second array (source) into the\n first array (destination); the copied areas may \u003cem\u003enot\u003c/em\u003e overlap\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "copyArray",
          "package": "base",
          "signature": "Ptr a -\u003e Ptr a -\u003e Int -\u003e IO ()",
          "source": "src/Foreign-Marshal-Array.html#copyArray",
          "type": "function"
        },
        "index": {
          "description": "Copy the given number of elements from the second array source into the first array destination the copied areas may not overlap",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "copyArray",
          "normalized": "Ptr a-\u003ePtr a-\u003eInt-\u003eIO()",
          "package": "base",
          "partial": "Array",
          "signature": "Ptr a-\u003ePtr a-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:copyArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the number of elements in an array, excluding the terminator\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "lengthArray0",
          "package": "base",
          "signature": "a -\u003e Ptr a -\u003e IO Int",
          "source": "src/Foreign-Marshal-Array.html#lengthArray0",
          "type": "function"
        },
        "index": {
          "description": "Return the number of elements in an array excluding the terminator",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "lengthArray0",
          "normalized": "a-\u003ePtr a-\u003eIO Int",
          "package": "base",
          "partial": "Array",
          "signature": "a-\u003ePtr a-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:lengthArray0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate storage for the given number of elements of a storable type\n (like \u003ccode\u003e\u003ca\u003emalloc\u003c/a\u003e\u003c/code\u003e, but for multiple elements).\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "mallocArray",
          "package": "base",
          "signature": "Int -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Array.html#mallocArray",
          "type": "function"
        },
        "index": {
          "description": "Allocate storage for the given number of elements of storable type like malloc but for multiple elements",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "mallocArray",
          "normalized": "Int-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Array",
          "signature": "Int-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:mallocArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003emallocArray\u003c/a\u003e\u003c/code\u003e, but add an extra position to hold a special\n termination element.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "mallocArray0",
          "package": "base",
          "signature": "Int -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Array.html#mallocArray0",
          "type": "function"
        },
        "index": {
          "description": "Like mallocArray but add an extra position to hold special termination element",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "mallocArray0",
          "normalized": "Int-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Array",
          "signature": "Int-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:mallocArray0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCopy the given number of elements from the second array (source) into the\n first array (destination); the copied areas \u003cem\u003emay\u003c/em\u003e overlap\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "moveArray",
          "package": "base",
          "signature": "Ptr a -\u003e Ptr a -\u003e Int -\u003e IO ()",
          "source": "src/Foreign-Marshal-Array.html#moveArray",
          "type": "function"
        },
        "index": {
          "description": "Copy the given number of elements from the second array source into the first array destination the copied areas may overlap",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "moveArray",
          "normalized": "Ptr a-\u003ePtr a-\u003eInt-\u003eIO()",
          "package": "base",
          "partial": "Array",
          "signature": "Ptr a-\u003ePtr a-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:moveArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a list of storable elements into a newly allocated, consecutive\n sequence of storable values\n (like \u003ccode\u003e\u003ca\u003enew\u003c/a\u003e\u003c/code\u003e, but for multiple elements).\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "newArray",
          "package": "base",
          "signature": "[a] -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Array.html#newArray",
          "type": "function"
        },
        "index": {
          "description": "Write list of storable elements into newly allocated consecutive sequence of storable values like new but for multiple elements",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "newArray",
          "normalized": "[a]-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Array",
          "signature": "[a]-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:newArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a list of storable elements into a newly allocated, consecutive\n sequence of storable values, where the end is fixed by the given end marker\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "newArray0",
          "package": "base",
          "signature": "a -\u003e [a] -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Array.html#newArray0",
          "type": "function"
        },
        "index": {
          "description": "Write list of storable elements into newly allocated consecutive sequence of storable values where the end is fixed by the given end marker",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "newArray0",
          "normalized": "a-\u003e[a]-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Array",
          "signature": "a-\u003e[a]-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:newArray0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an array of given length into a Haskell list.  The implementation\n is tail-recursive and so uses constant stack space.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "peekArray",
          "package": "base",
          "signature": "Int -\u003e Ptr a -\u003e IO [a]",
          "source": "src/Foreign-Marshal-Array.html#peekArray",
          "type": "function"
        },
        "index": {
          "description": "Convert an array of given length into Haskell list The implementation is tail-recursive and so uses constant stack space",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "peekArray",
          "normalized": "Int-\u003ePtr a-\u003eIO[a]",
          "package": "base",
          "partial": "Array",
          "signature": "Int-\u003ePtr a-\u003eIO[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:peekArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an array terminated by the given end marker into a Haskell list\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "peekArray0",
          "package": "base",
          "signature": "a -\u003e Ptr a -\u003e IO [a]",
          "source": "src/Foreign-Marshal-Array.html#peekArray0",
          "type": "function"
        },
        "index": {
          "description": "Convert an array terminated by the given end marker into Haskell list",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "peekArray0",
          "normalized": "a-\u003ePtr a-\u003eIO[a]",
          "package": "base",
          "partial": "Array",
          "signature": "a-\u003ePtr a-\u003eIO[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:peekArray0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite the list elements consecutive into memory\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "pokeArray",
          "package": "base",
          "signature": "Ptr a -\u003e [a] -\u003e IO ()",
          "source": "src/Foreign-Marshal-Array.html#pokeArray",
          "type": "function"
        },
        "index": {
          "description": "Write the list elements consecutive into memory",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "pokeArray",
          "normalized": "Ptr a-\u003e[a]-\u003eIO()",
          "package": "base",
          "partial": "Array",
          "signature": "Ptr a-\u003e[a]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:pokeArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite the list elements consecutive into memory and terminate them with the\n given marker element\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "pokeArray0",
          "package": "base",
          "signature": "a -\u003e Ptr a -\u003e [a] -\u003e IO ()",
          "source": "src/Foreign-Marshal-Array.html#pokeArray0",
          "type": "function"
        },
        "index": {
          "description": "Write the list elements consecutive into memory and terminate them with the given marker element",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "pokeArray0",
          "normalized": "a-\u003ePtr a-\u003e[a]-\u003eIO()",
          "package": "base",
          "partial": "Array",
          "signature": "a-\u003ePtr a-\u003e[a]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:pokeArray0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the size of an array\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "reallocArray",
          "package": "base",
          "signature": "Ptr a -\u003e Int -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Array.html#reallocArray",
          "type": "function"
        },
        "index": {
          "description": "Adjust the size of an array",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "reallocArray",
          "normalized": "Ptr a-\u003eInt-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Array",
          "signature": "Ptr a-\u003eInt-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:reallocArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the size of an array including an extra position for the end marker.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "reallocArray0",
          "package": "base",
          "signature": "Ptr a -\u003e Int -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Array.html#reallocArray0",
          "type": "function"
        },
        "index": {
          "description": "Adjust the size of an array including an extra position for the end marker",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "reallocArray0",
          "normalized": "Ptr a-\u003eInt-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Array",
          "signature": "Ptr a-\u003eInt-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:reallocArray0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTemporarily store a list of storable values in memory\n (like \u003ccode\u003e\u003ca\u003ewith\u003c/a\u003e\u003c/code\u003e, but for multiple elements).\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "withArray",
          "package": "base",
          "signature": "[a] -\u003e (Ptr a -\u003e IO b) -\u003e IO b",
          "source": "src/Foreign-Marshal-Array.html#withArray",
          "type": "function"
        },
        "index": {
          "description": "Temporarily store list of storable values in memory like with but for multiple elements",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "withArray",
          "normalized": "[a]-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "partial": "Array",
          "signature": "[a]-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:withArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ewithArray\u003c/a\u003e\u003c/code\u003e, but a terminator indicates where the array ends\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "withArray0",
          "package": "base",
          "signature": "a -\u003e [a] -\u003e (Ptr a -\u003e IO b) -\u003e IO b",
          "source": "src/Foreign-Marshal-Array.html#withArray0",
          "type": "function"
        },
        "index": {
          "description": "Like withArray but terminator indicates where the array ends",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "withArray0",
          "normalized": "a-\u003e[a]-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "partial": "Array",
          "signature": "a-\u003e[a]-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:withArray0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ewithArray\u003c/a\u003e\u003c/code\u003e, but the action gets the number of values\n as an additional parameter\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "withArrayLen",
          "package": "base",
          "signature": "[a] -\u003e (Int -\u003e Ptr a -\u003e IO b) -\u003e IO b",
          "source": "src/Foreign-Marshal-Array.html#withArrayLen",
          "type": "function"
        },
        "index": {
          "description": "Like withArray but the action gets the number of values as an additional parameter",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "withArrayLen",
          "normalized": "[a]-\u003e(Int-\u003ePtr a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "partial": "Array Len",
          "signature": "[a]-\u003e(Int-\u003ePtr a-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:withArrayLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ewithArrayLen\u003c/a\u003e\u003c/code\u003e, but a terminator indicates where the array ends\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Array",
          "name": "withArrayLen0",
          "package": "base",
          "signature": "a -\u003e [a] -\u003e (Int -\u003e Ptr a -\u003e IO b) -\u003e IO b",
          "source": "src/Foreign-Marshal-Array.html#withArrayLen0",
          "type": "function"
        },
        "index": {
          "description": "Like withArrayLen but terminator indicates where the array ends",
          "hierarchy": "Foreign Marshal Array",
          "module": "Foreign.Marshal.Array",
          "name": "withArrayLen0",
          "normalized": "a-\u003e[a]-\u003e(Int-\u003ePtr a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "partial": "Array Len",
          "signature": "a-\u003e[a]-\u003e(Int-\u003ePtr a-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Array.html#v:withArrayLen0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRoutines for testing return values and raising a \u003ccode\u003e\u003ca\u003euserError\u003c/a\u003e\u003c/code\u003e exception\n in case of values indicating an error state.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.Marshal.Error",
          "name": "Error",
          "package": "base",
          "source": "src/Foreign-Marshal-Error.html",
          "type": "module"
        },
        "index": {
          "description": "Routines for testing return values and raising userError exception in case of values indicating an error state",
          "hierarchy": "Foreign Marshal Error",
          "module": "Foreign.Marshal.Error",
          "name": "Error",
          "package": "base",
          "partial": "Error",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Error.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExecute an \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e action, throwing a \u003ccode\u003e\u003ca\u003euserError\u003c/a\u003e\u003c/code\u003e if the predicate yields\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when applied to the result returned by the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e action.\n If no exception is raised, return the result of the computation.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Error",
          "name": "throwIf",
          "package": "base",
          "signature": "(a -\u003e Bool)-\u003e (a -\u003e String)-\u003e IO a-\u003e IO a",
          "type": "function"
        },
        "index": {
          "description": "Execute an IO action throwing userError if the predicate yields True when applied to the result returned by the IO action If no exception is raised return the result of the computation",
          "hierarchy": "Foreign Marshal Error",
          "module": "Foreign.Marshal.Error",
          "name": "throwIf",
          "normalized": "(a-\u003eBool)-\u003e(a-\u003eString)-\u003eIO a-\u003eIO a",
          "package": "base",
          "partial": "If",
          "signature": "(a-\u003eBool)-\u003e(a-\u003eString)-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Error.html#v:throwIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGuards against negative result values\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Error",
          "name": "throwIfNeg",
          "package": "base",
          "signature": "(a -\u003e String) -\u003e IO a -\u003e IO a",
          "source": "src/Foreign-Marshal-Error.html#throwIfNeg",
          "type": "function"
        },
        "index": {
          "description": "Guards against negative result values",
          "hierarchy": "Foreign Marshal Error",
          "module": "Foreign.Marshal.Error",
          "name": "throwIfNeg",
          "normalized": "(a-\u003eString)-\u003eIO a-\u003eIO a",
          "package": "base",
          "partial": "If Neg",
          "signature": "(a-\u003eString)-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Error.html#v:throwIfNeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ethrowIfNeg\u003c/a\u003e\u003c/code\u003e, but discarding the result\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Error",
          "name": "throwIfNeg_",
          "package": "base",
          "signature": "(a -\u003e String) -\u003e IO a -\u003e IO ()",
          "source": "src/Foreign-Marshal-Error.html#throwIfNeg_",
          "type": "function"
        },
        "index": {
          "description": "Like throwIfNeg but discarding the result",
          "hierarchy": "Foreign Marshal Error",
          "module": "Foreign.Marshal.Error",
          "name": "throwIfNeg_",
          "normalized": "(a-\u003eString)-\u003eIO a-\u003eIO()",
          "package": "base",
          "partial": "If Neg",
          "signature": "(a-\u003eString)-\u003eIO a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Error.html#v:throwIfNeg_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGuards against null pointers\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Error",
          "name": "throwIfNull",
          "package": "base",
          "signature": "String -\u003e IO (Ptr a) -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Error.html#throwIfNull",
          "type": "function"
        },
        "index": {
          "description": "Guards against null pointers",
          "hierarchy": "Foreign Marshal Error",
          "module": "Foreign.Marshal.Error",
          "name": "throwIfNull",
          "normalized": "String-\u003eIO(Ptr a)-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "If Null",
          "signature": "String-\u003eIO(Ptr a)-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Error.html#v:throwIfNull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ethrowIf\u003c/a\u003e\u003c/code\u003e, but discarding the result\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Error",
          "name": "throwIf_",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e (a -\u003e String) -\u003e IO a -\u003e IO ()",
          "source": "src/Foreign-Marshal-Error.html#throwIf_",
          "type": "function"
        },
        "index": {
          "description": "Like throwIf but discarding the result",
          "hierarchy": "Foreign Marshal Error",
          "module": "Foreign.Marshal.Error",
          "name": "throwIf_",
          "normalized": "(a-\u003eBool)-\u003e(a-\u003eString)-\u003eIO a-\u003eIO()",
          "package": "base",
          "partial": "If",
          "signature": "(a-\u003eBool)-\u003e(a-\u003eString)-\u003eIO a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Error.html#v:throwIf_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use Control.Monad.void instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eDiscard the return value of an \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e action\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Error",
          "name": "void",
          "package": "base",
          "signature": "IO a -\u003e IO ()",
          "source": "src/Foreign-Marshal-Error.html#void",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use Control.Monad.void instead Discard the return value of an IO action",
          "hierarchy": "Foreign Marshal Error",
          "module": "Foreign.Marshal.Error",
          "name": "void",
          "normalized": "IO a-\u003eIO()",
          "package": "base",
          "signature": "IO a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Error.html#v:void"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains support for pooled memory management. Under this scheme,\n (re-)allocations belong to a given pool, and everything in a pool is\n deallocated when the pool itself is deallocated. This is useful when\n \u003ccode\u003e\u003ca\u003ealloca\u003c/a\u003e\u003c/code\u003e with its implicit allocation and deallocation\n is not flexible enough, but explicit uses of \u003ccode\u003e\u003ca\u003emalloc\u003c/a\u003e\u003c/code\u003e\n and \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e are too awkward.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "Pool",
          "package": "base",
          "source": "src/Foreign-Marshal-Pool.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains support for pooled memory management Under this scheme re allocations belong to given pool and everything in pool is deallocated when the pool itself is deallocated This is useful when alloca with its implicit allocation and deallocation is not flexible enough but explicit uses of malloc and free are too awkward",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "Pool",
          "package": "base",
          "partial": "Pool",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA memory pool.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "Pool",
          "package": "base",
          "source": "src/Foreign-Marshal-Pool.html#Pool",
          "type": "data"
        },
        "index": {
          "description": "memory pool",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "Pool",
          "package": "base",
          "partial": "Pool",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#t:Pool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeallocate a memory pool and everything which has been allocated in the\n pool itself.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "freePool",
          "package": "base",
          "signature": "Pool -\u003e IO ()",
          "source": "src/Foreign-Marshal-Pool.html#freePool",
          "type": "function"
        },
        "index": {
          "description": "Deallocate memory pool and everything which has been allocated in the pool itself",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "freePool",
          "normalized": "Pool-\u003eIO()",
          "package": "base",
          "partial": "Pool",
          "signature": "Pool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#v:freePool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate a fresh memory pool.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "newPool",
          "package": "base",
          "signature": "IO Pool",
          "source": "src/Foreign-Marshal-Pool.html#newPool",
          "type": "function"
        },
        "index": {
          "description": "Allocate fresh memory pool",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "newPool",
          "package": "base",
          "partial": "Pool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#v:newPool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate space for storable type in the given pool. The size of the area\n allocated is determined by the \u003ccode\u003e\u003ca\u003esizeOf\u003c/a\u003e\u003c/code\u003e method from the instance of\n \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e for the appropriate type.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledMalloc",
          "package": "base",
          "signature": "Pool -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Pool.html#pooledMalloc",
          "type": "function"
        },
        "index": {
          "description": "Allocate space for storable type in the given pool The size of the area allocated is determined by the sizeOf method from the instance of Storable for the appropriate type",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledMalloc",
          "normalized": "Pool-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Malloc",
          "signature": "Pool-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#v:pooledMalloc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate storage for the given number of elements of a storable type in the\n pool.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledMallocArray",
          "package": "base",
          "signature": "Pool -\u003e Int -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Pool.html#pooledMallocArray",
          "type": "function"
        },
        "index": {
          "description": "Allocate storage for the given number of elements of storable type in the pool",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledMallocArray",
          "normalized": "Pool-\u003eInt-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Malloc Array",
          "signature": "Pool-\u003eInt-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#v:pooledMallocArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate storage for the given number of elements of a storable type in the\n pool, but leave room for an extra element to signal the end of the array.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledMallocArray0",
          "package": "base",
          "signature": "Pool -\u003e Int -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Pool.html#pooledMallocArray0",
          "type": "function"
        },
        "index": {
          "description": "Allocate storage for the given number of elements of storable type in the pool but leave room for an extra element to signal the end of the array",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledMallocArray0",
          "normalized": "Pool-\u003eInt-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Malloc Array",
          "signature": "Pool-\u003eInt-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#v:pooledMallocArray0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate the given number of bytes of storage in the pool.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledMallocBytes",
          "package": "base",
          "signature": "Pool -\u003e Int -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Pool.html#pooledMallocBytes",
          "type": "function"
        },
        "index": {
          "description": "Allocate the given number of bytes of storage in the pool",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledMallocBytes",
          "normalized": "Pool-\u003eInt-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Malloc Bytes",
          "signature": "Pool-\u003eInt-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#v:pooledMallocBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate storage for a value in the given pool and marshal the value into\n this storage.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledNew",
          "package": "base",
          "signature": "Pool -\u003e a -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Pool.html#pooledNew",
          "type": "function"
        },
        "index": {
          "description": "Allocate storage for value in the given pool and marshal the value into this storage",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledNew",
          "normalized": "Pool-\u003ea-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "New",
          "signature": "Pool-\u003ea-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#v:pooledNew"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate consecutive storage for a list of values in the given pool and\n marshal these values into it.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledNewArray",
          "package": "base",
          "signature": "Pool -\u003e [a] -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Pool.html#pooledNewArray",
          "type": "function"
        },
        "index": {
          "description": "Allocate consecutive storage for list of values in the given pool and marshal these values into it",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledNewArray",
          "normalized": "Pool-\u003e[a]-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "New Array",
          "signature": "Pool-\u003e[a]-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#v:pooledNewArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate consecutive storage for a list of values in the given pool and\n marshal these values into it, terminating the end with the given marker.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledNewArray0",
          "package": "base",
          "signature": "Pool -\u003e a -\u003e [a] -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Pool.html#pooledNewArray0",
          "type": "function"
        },
        "index": {
          "description": "Allocate consecutive storage for list of values in the given pool and marshal these values into it terminating the end with the given marker",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledNewArray0",
          "normalized": "Pool-\u003ea-\u003e[a]-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "New Array",
          "signature": "Pool-\u003ea-\u003e[a]-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#v:pooledNewArray0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the storage area for an element in the pool to the given size of\n the required type.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledRealloc",
          "package": "base",
          "signature": "Pool -\u003e Ptr a -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Pool.html#pooledRealloc",
          "type": "function"
        },
        "index": {
          "description": "Adjust the storage area for an element in the pool to the given size of the required type",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledRealloc",
          "normalized": "Pool-\u003ePtr a-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Realloc",
          "signature": "Pool-\u003ePtr a-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#v:pooledRealloc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the size of an array in the given pool.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledReallocArray",
          "package": "base",
          "signature": "Pool -\u003e Ptr a -\u003e Int -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Pool.html#pooledReallocArray",
          "type": "function"
        },
        "index": {
          "description": "Adjust the size of an array in the given pool",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledReallocArray",
          "normalized": "Pool-\u003ePtr a-\u003eInt-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Realloc Array",
          "signature": "Pool-\u003ePtr a-\u003eInt-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#v:pooledReallocArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the size of an array with an end marker in the given pool.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledReallocArray0",
          "package": "base",
          "signature": "Pool -\u003e Ptr a -\u003e Int -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Pool.html#pooledReallocArray0",
          "type": "function"
        },
        "index": {
          "description": "Adjust the size of an array with an end marker in the given pool",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledReallocArray0",
          "normalized": "Pool-\u003ePtr a-\u003eInt-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Realloc Array",
          "signature": "Pool-\u003ePtr a-\u003eInt-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#v:pooledReallocArray0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the storage area for an element in the pool to the given size.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledReallocBytes",
          "package": "base",
          "signature": "Pool -\u003e Ptr a -\u003e Int -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Pool.html#pooledReallocBytes",
          "type": "function"
        },
        "index": {
          "description": "Adjust the storage area for an element in the pool to the given size",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "pooledReallocBytes",
          "normalized": "Pool-\u003ePtr a-\u003eInt-\u003eIO(Ptr a)",
          "package": "base",
          "partial": "Realloc Bytes",
          "signature": "Pool-\u003ePtr a-\u003eInt-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#v:pooledReallocBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExecute an action with a fresh memory pool, which gets automatically\n deallocated (including its contents) after the action has finished.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Pool",
          "name": "withPool",
          "package": "base",
          "signature": "(Pool -\u003e IO b) -\u003e IO b",
          "source": "src/Foreign-Marshal-Pool.html#withPool",
          "type": "function"
        },
        "index": {
          "description": "Execute an action with fresh memory pool which gets automatically deallocated including its contents after the action has finished",
          "hierarchy": "Foreign Marshal Pool",
          "module": "Foreign.Marshal.Pool",
          "name": "withPool",
          "normalized": "(Pool-\u003eIO a)-\u003eIO a",
          "package": "base",
          "partial": "Pool",
          "signature": "(Pool-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Pool.html#v:withPool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMarshalling support\n\u003c/p\u003e\u003cp\u003eSafe API Only.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.Marshal.Safe",
          "name": "Safe",
          "package": "base",
          "source": "src/Foreign-Marshal-Safe.html",
          "type": "module"
        },
        "index": {
          "description": "Marshalling support Safe API Only",
          "hierarchy": "Foreign Marshal Safe",
          "module": "Foreign.Marshal.Safe",
          "name": "Safe",
          "package": "base",
          "partial": "Safe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Safe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMarshalling support. Unsafe API.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.Marshal.Unsafe",
          "name": "Unsafe",
          "package": "base",
          "source": "src/Foreign-Marshal-Unsafe.html",
          "type": "module"
        },
        "index": {
          "description": "Marshalling support Unsafe API",
          "hierarchy": "Foreign Marshal Unsafe",
          "module": "Foreign.Marshal.Unsafe",
          "name": "Unsafe",
          "package": "base",
          "partial": "Unsafe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Unsafe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSometimes an external entity is a pure function, except that it passes\narguments and/or results via pointers.  The function\n\u003ccode\u003eunsafeLocalState\u003c/code\u003e permits the packaging of such entities as pure\nfunctions.  \n\u003c/p\u003e\u003cp\u003eThe only IO operations allowed in the IO action passed to\n\u003ccode\u003eunsafeLocalState\u003c/code\u003e are (a) local allocation (\u003ccode\u003ealloca\u003c/code\u003e, \u003ccode\u003eallocaBytes\u003c/code\u003e\nand derived operations such as \u003ccode\u003ewithArray\u003c/code\u003e and \u003ccode\u003ewithCString\u003c/code\u003e), and (b)\npointer operations (\u003ccode\u003eForeign.Storable\u003c/code\u003e and \u003ccode\u003eForeign.Ptr\u003c/code\u003e) on the\npointers to local storage, and (c) foreign functions whose only\nobservable effect is to read and/or write the locally allocated\nmemory.  Passing an IO operation that does not obey these rules\nresults in undefined behaviour.\n\u003c/p\u003e\u003cp\u003eIt is expected that this operation will be\nreplaced in a future revision of Haskell.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Unsafe",
          "name": "unsafeLocalState",
          "package": "base",
          "signature": "IO a -\u003e a",
          "source": "src/Foreign-Marshal-Unsafe.html#unsafeLocalState",
          "type": "function"
        },
        "index": {
          "description": "Sometimes an external entity is pure function except that it passes arguments and or results via pointers The function unsafeLocalState permits the packaging of such entities as pure functions The only IO operations allowed in the IO action passed to unsafeLocalState are local allocation alloca allocaBytes and derived operations such as withArray and withCString and pointer operations Foreign.Storable and Foreign.Ptr on the pointers to local storage and foreign functions whose only observable effect is to read and or write the locally allocated memory Passing an IO operation that does not obey these rules results in undefined behaviour It is expected that this operation will be replaced in future revision of Haskell",
          "hierarchy": "Foreign Marshal Unsafe",
          "module": "Foreign.Marshal.Unsafe",
          "name": "unsafeLocalState",
          "normalized": "IO a-\u003ea",
          "package": "base",
          "partial": "Local State",
          "signature": "IO a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Unsafe.html#v:unsafeLocalState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUtilities for primitive marshaling\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.Marshal.Utils",
          "name": "Utils",
          "package": "base",
          "source": "src/Foreign-Marshal-Utils.html",
          "type": "module"
        },
        "index": {
          "description": "Utilities for primitive marshaling",
          "hierarchy": "Foreign Marshal Utils",
          "module": "Foreign.Marshal.Utils",
          "name": "Utils",
          "package": "base",
          "partial": "Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Utils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCopies the given number of bytes from the second area (source) into the\n first (destination); the copied areas may \u003cem\u003enot\u003c/em\u003e overlap\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Utils",
          "name": "copyBytes",
          "package": "base",
          "signature": "Ptr a -\u003e Ptr a -\u003e Int -\u003e IO ()",
          "source": "src/Foreign-Marshal-Utils.html#copyBytes",
          "type": "function"
        },
        "index": {
          "description": "Copies the given number of bytes from the second area source into the first destination the copied areas may not overlap",
          "hierarchy": "Foreign Marshal Utils",
          "module": "Foreign.Marshal.Utils",
          "name": "copyBytes",
          "normalized": "Ptr a-\u003ePtr a-\u003eInt-\u003eIO()",
          "package": "base",
          "partial": "Bytes",
          "signature": "Ptr a-\u003ePtr a-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Utils.html#v:copyBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a Haskell \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e to its numeric representation\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Utils",
          "name": "fromBool",
          "package": "base",
          "signature": "Bool -\u003e a",
          "source": "src/Foreign-Marshal-Utils.html#fromBool",
          "type": "function"
        },
        "index": {
          "description": "Convert Haskell Bool to its numeric representation",
          "hierarchy": "Foreign Marshal Utils",
          "module": "Foreign.Marshal.Utils",
          "name": "fromBool",
          "normalized": "Bool-\u003ea",
          "package": "base",
          "partial": "Bool",
          "signature": "Bool-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Utils.html#v:fromBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate storage and marshal a storable value wrapped into a \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the \u003ccode\u003e\u003ca\u003enullPtr\u003c/a\u003e\u003c/code\u003e is used to represent \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Foreign.Marshal.Utils",
          "name": "maybeNew",
          "package": "base",
          "signature": "(a -\u003e IO (Ptr b)) -\u003e Maybe a -\u003e IO (Ptr b)",
          "source": "src/Foreign-Marshal-Utils.html#maybeNew",
          "type": "function"
        },
        "index": {
          "description": "Allocate storage and marshal storable value wrapped into Maybe the nullPtr is used to represent Nothing",
          "hierarchy": "Foreign Marshal Utils",
          "module": "Foreign.Marshal.Utils",
          "name": "maybeNew",
          "normalized": "(a-\u003eIO(Ptr b))-\u003eMaybe a-\u003eIO(Ptr b)",
          "package": "base",
          "partial": "New",
          "signature": "(a-\u003eIO(Ptr b))-\u003eMaybe a-\u003eIO(Ptr b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Utils.html#v:maybeNew"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a peek combinator into a one returning \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if applied to a\n \u003ccode\u003e\u003ca\u003enullPtr\u003c/a\u003e\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Foreign.Marshal.Utils",
          "name": "maybePeek",
          "package": "base",
          "signature": "(Ptr a -\u003e IO b) -\u003e Ptr a -\u003e IO (Maybe b)",
          "source": "src/Foreign-Marshal-Utils.html#maybePeek",
          "type": "function"
        },
        "index": {
          "description": "Convert peek combinator into one returning Nothing if applied to nullPtr",
          "hierarchy": "Foreign Marshal Utils",
          "module": "Foreign.Marshal.Utils",
          "name": "maybePeek",
          "normalized": "(Ptr a-\u003eIO b)-\u003ePtr a-\u003eIO(Maybe b)",
          "package": "base",
          "partial": "Peek",
          "signature": "(Ptr a-\u003eIO b)-\u003ePtr a-\u003eIO(Maybe b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Utils.html#v:maybePeek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a \u003ccode\u003ewithXXX\u003c/code\u003e combinator into one marshalling a value wrapped\n into a \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e, using \u003ccode\u003e\u003ca\u003enullPtr\u003c/a\u003e\u003c/code\u003e to represent \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Utils",
          "name": "maybeWith",
          "package": "base",
          "signature": "(a -\u003e (Ptr b -\u003e IO c) -\u003e IO c) -\u003e Maybe a -\u003e (Ptr b -\u003e IO c) -\u003e IO c",
          "source": "src/Foreign-Marshal-Utils.html#maybeWith",
          "type": "function"
        },
        "index": {
          "description": "Converts withXXX combinator into one marshalling value wrapped into Maybe using nullPtr to represent Nothing",
          "hierarchy": "Foreign Marshal Utils",
          "module": "Foreign.Marshal.Utils",
          "name": "maybeWith",
          "normalized": "(a-\u003e(Ptr b-\u003eIO c)-\u003eIO c)-\u003eMaybe a-\u003e(Ptr b-\u003eIO c)-\u003eIO c",
          "package": "base",
          "partial": "With",
          "signature": "(a-\u003e(Ptr b-\u003eIO c)-\u003eIO c)-\u003eMaybe a-\u003e(Ptr b-\u003eIO c)-\u003eIO c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Utils.html#v:maybeWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCopies the given number of bytes from the second area (source) into the\n first (destination); the copied areas \u003cem\u003emay\u003c/em\u003e overlap\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Utils",
          "name": "moveBytes",
          "package": "base",
          "signature": "Ptr a -\u003e Ptr a -\u003e Int -\u003e IO ()",
          "source": "src/Foreign-Marshal-Utils.html#moveBytes",
          "type": "function"
        },
        "index": {
          "description": "Copies the given number of bytes from the second area source into the first destination the copied areas may overlap",
          "hierarchy": "Foreign Marshal Utils",
          "module": "Foreign.Marshal.Utils",
          "name": "moveBytes",
          "normalized": "Ptr a-\u003ePtr a-\u003eInt-\u003eIO()",
          "package": "base",
          "partial": "Bytes",
          "signature": "Ptr a-\u003ePtr a-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Utils.html#v:moveBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate a block of memory and marshal a value into it\n (the combination of \u003ccode\u003e\u003ca\u003emalloc\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003epoke\u003c/a\u003e\u003c/code\u003e).\n The size of the area allocated is determined by the \u003ccode\u003e\u003ca\u003esizeOf\u003c/a\u003e\u003c/code\u003e\n method from the instance of \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e for the appropriate type.\n\u003c/p\u003e\u003cp\u003eThe memory may be deallocated using \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003efinalizerFree\u003c/a\u003e\u003c/code\u003e when no longer required.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Utils",
          "name": "new",
          "package": "base",
          "signature": "a -\u003e IO (Ptr a)",
          "source": "src/Foreign-Marshal-Utils.html#new",
          "type": "function"
        },
        "index": {
          "description": "Allocate block of memory and marshal value into it the combination of malloc and poke The size of the area allocated is determined by the sizeOf method from the instance of Storable for the appropriate type The memory may be deallocated using free or finalizerFree when no longer required",
          "hierarchy": "Foreign Marshal Utils",
          "module": "Foreign.Marshal.Utils",
          "name": "new",
          "normalized": "a-\u003eIO(Ptr a)",
          "package": "base",
          "signature": "a-\u003eIO(Ptr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Utils.html#v:new"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a Boolean in numeric representation to a Haskell value\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Utils",
          "name": "toBool",
          "package": "base",
          "signature": "a -\u003e Bool",
          "source": "src/Foreign-Marshal-Utils.html#toBool",
          "type": "function"
        },
        "index": {
          "description": "Convert Boolean in numeric representation to Haskell value",
          "hierarchy": "Foreign Marshal Utils",
          "module": "Foreign.Marshal.Utils",
          "name": "toBool",
          "normalized": "a-\u003eBool",
          "package": "base",
          "partial": "Bool",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Utils.html#v:toBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ewith\u003c/a\u003e\u003c/code\u003e val f\u003c/code\u003e executes the computation \u003ccode\u003ef\u003c/code\u003e, passing as argument\n a pointer to a temporarily allocated block of memory into which\n \u003ccode\u003eval\u003c/code\u003e has been marshalled (the combination of \u003ccode\u003e\u003ca\u003ealloca\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003epoke\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eThe memory is freed when \u003ccode\u003ef\u003c/code\u003e terminates (either normally or via an\n exception), so the pointer passed to \u003ccode\u003ef\u003c/code\u003e must \u003cem\u003enot\u003c/em\u003e be used after this.\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Utils",
          "name": "with",
          "package": "base",
          "signature": "a -\u003e (Ptr a -\u003e IO b) -\u003e IO b",
          "source": "src/Foreign-Marshal-Utils.html#with",
          "type": "function"
        },
        "index": {
          "description": "with val executes the computation passing as argument pointer to temporarily allocated block of memory into which val has been marshalled the combination of alloca and poke The memory is freed when terminates either normally or via an exception so the pointer passed to must not be used after this",
          "hierarchy": "Foreign Marshal Utils",
          "module": "Foreign.Marshal.Utils",
          "name": "with",
          "normalized": "a-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "signature": "a-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Utils.html#v:with"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplicates a \u003ccode\u003ewithXXX\u003c/code\u003e combinator over a list of objects, yielding a list of\n marshalled objects\n\u003c/p\u003e",
          "module": "Foreign.Marshal.Utils",
          "name": "withMany",
          "package": "base",
          "signature": "(a -\u003e (b -\u003e res) -\u003e res) -\u003e [a] -\u003e ([b] -\u003e res) -\u003e res",
          "source": "src/Foreign-Marshal-Utils.html#withMany",
          "type": "function"
        },
        "index": {
          "description": "Replicates withXXX combinator over list of objects yielding list of marshalled objects",
          "hierarchy": "Foreign Marshal Utils",
          "module": "Foreign.Marshal.Utils",
          "name": "withMany",
          "normalized": "(a-\u003e(b-\u003ec)-\u003ec)-\u003e[a]-\u003e([b]-\u003ec)-\u003ec",
          "package": "base",
          "partial": "Many",
          "signature": "(a-\u003e(b-\u003eres)-\u003eres)-\u003e[a]-\u003e([b]-\u003eres)-\u003eres",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Utils.html#v:withMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMarshalling support\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.Marshal",
          "name": "Marshal",
          "package": "base",
          "source": "src/Foreign-Marshal.html",
          "type": "module"
        },
        "index": {
          "description": "Marshalling support",
          "hierarchy": "Foreign Marshal",
          "module": "Foreign.Marshal",
          "name": "Marshal",
          "package": "base",
          "partial": "Marshal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Please import from Foreign.Marshall.Unsafe instead; This will be removed in the next release\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eSometimes an external entity is a pure function, except that it passes\narguments and/or results via pointers.  The function\n\u003ccode\u003eunsafeLocalState\u003c/code\u003e permits the packaging of such entities as pure\nfunctions.  \n\u003c/p\u003e\u003cp\u003eThe only IO operations allowed in the IO action passed to\n\u003ccode\u003eunsafeLocalState\u003c/code\u003e are (a) local allocation (\u003ccode\u003ealloca\u003c/code\u003e, \u003ccode\u003eallocaBytes\u003c/code\u003e\nand derived operations such as \u003ccode\u003ewithArray\u003c/code\u003e and \u003ccode\u003ewithCString\u003c/code\u003e), and (b)\npointer operations (\u003ccode\u003eForeign.Storable\u003c/code\u003e and \u003ccode\u003eForeign.Ptr\u003c/code\u003e) on the\npointers to local storage, and (c) foreign functions whose only\nobservable effect is to read and/or write the locally allocated\nmemory.  Passing an IO operation that does not obey these rules\nresults in undefined behaviour.\n\u003c/p\u003e\u003cp\u003eIt is expected that this operation will be\nreplaced in a future revision of Haskell.\n\u003c/p\u003e",
          "module": "Foreign.Marshal",
          "name": "unsafeLocalState",
          "package": "base",
          "signature": "IO a -\u003e a",
          "source": "src/Foreign-Marshal.html#unsafeLocalState",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Please import from Foreign.Marshall.Unsafe instead This will be removed in the next release Sometimes an external entity is pure function except that it passes arguments and or results via pointers The function unsafeLocalState permits the packaging of such entities as pure functions The only IO operations allowed in the IO action passed to unsafeLocalState are local allocation alloca allocaBytes and derived operations such as withArray and withCString and pointer operations Foreign.Storable and Foreign.Ptr on the pointers to local storage and foreign functions whose only observable effect is to read and or write the locally allocated memory Passing an IO operation that does not obey these rules results in undefined behaviour It is expected that this operation will be replaced in future revision of Haskell",
          "hierarchy": "Foreign Marshal",
          "module": "Foreign.Marshal",
          "name": "unsafeLocalState",
          "normalized": "IO a-\u003ea",
          "package": "base",
          "partial": "Local State",
          "signature": "IO a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Marshal.html#v:unsafeLocalState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides typed pointers to foreign data.  It is part\n of the Foreign Function Interface (FFI) and will normally be\n imported via the \u003ca\u003eForeign\u003c/a\u003e module.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.Ptr",
          "name": "Ptr",
          "package": "base",
          "source": "src/Foreign-Ptr.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides typed pointers to foreign data It is part of the Foreign Function Interface FFI and will normally be imported via the Foreign module",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "Ptr",
          "package": "base",
          "partial": "Ptr",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e is a pointer to a function callable\n from foreign code.  The type \u003ccode\u003ea\u003c/code\u003e will normally be a \u003cem\u003eforeign type\u003c/em\u003e,\n a function type with zero or more arguments where\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the argument types are \u003cem\u003emarshallable foreign types\u003c/em\u003e,\n   i.e. \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFloat\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt16\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt32\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003eInt64\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord16\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003eWord32\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord64\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e,\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003eStablePtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e or a renaming of any of these\n   using \u003ccode\u003enewtype\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e the return type is either a marshallable foreign type or has the form\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e t\u003c/code\u003e where \u003ccode\u003et\u003c/code\u003e is a marshallable foreign type or \u003ccode\u003e()\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eA value of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e may be a pointer to a foreign function,\n either returned by another foreign function or imported with a\n a static address import like\n\u003c/p\u003e\u003cpre\u003e foreign import ccall \"stdlib.h &free\"\n   p_free :: FunPtr (Ptr a -\u003e IO ())\n\u003c/pre\u003e\u003cp\u003eor a pointer to a Haskell function created using a \u003cem\u003ewrapper\u003c/em\u003e stub\n declared to produce a \u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e of the correct type.  For example:\n\u003c/p\u003e\u003cpre\u003e type Compare = Int -\u003e Int -\u003e Bool\n foreign import ccall \"wrapper\"\n   mkCompare :: Compare -\u003e IO (FunPtr Compare)\n\u003c/pre\u003e\u003cp\u003eCalls to wrapper stubs like \u003ccode\u003emkCompare\u003c/code\u003e allocate storage, which\n should be released with \u003ccode\u003e\u003ca\u003efreeHaskellFunPtr\u003c/a\u003e\u003c/code\u003e when no\n longer required.\n\u003c/p\u003e\u003cp\u003eTo convert \u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e values to corresponding Haskell functions, one\n can define a \u003cem\u003edynamic\u003c/em\u003e stub for the specific foreign type, e.g.\n\u003c/p\u003e\u003cpre\u003e type IntFunction = CInt -\u003e IO ()\n foreign import ccall \"dynamic\" \n   mkFun :: FunPtr IntFunction -\u003e IntFunction\n\u003c/pre\u003e",
          "module": "Foreign.Ptr",
          "name": "FunPtr",
          "package": "base",
          "source": "src/GHC-Ptr.html#FunPtr",
          "type": "data"
        },
        "index": {
          "description": "value of type FunPtr is pointer to function callable from foreign code The type will normally be foreign type function type with zero or more arguments where the argument types are marshallable foreign types i.e Char Int Double Float Bool Int8 Int16 Int32 Int64 Word8 Word16 Word32 Word64 Ptr FunPtr StablePtr or renaming of any of these using newtype the return type is either marshallable foreign type or has the form IO where is marshallable foreign type or value of type FunPtr may be pointer to foreign function either returned by another foreign function or imported with static address import like foreign import ccall stdlib.h free free FunPtr Ptr IO or pointer to Haskell function created using wrapper stub declared to produce FunPtr of the correct type For example type Compare Int Int Bool foreign import ccall wrapper mkCompare Compare IO FunPtr Compare Calls to wrapper stubs like mkCompare allocate storage which should be released with freeHaskellFunPtr when no longer required To convert FunPtr values to corresponding Haskell functions one can define dynamic stub for the specific foreign type e.g type IntFunction CInt IO foreign import ccall dynamic mkFun FunPtr IntFunction IntFunction",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "FunPtr",
          "package": "base",
          "partial": "Fun Ptr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#t:FunPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA signed integral type that can be losslessly converted to and from\n \u003ccode\u003ePtr\u003c/code\u003e.  This type is also compatible with the C99 type \u003ccode\u003eintptr_t\u003c/code\u003e, and\n can be marshalled to and from that type safely.\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "IntPtr",
          "package": "base",
          "source": "src/Foreign-Ptr.html#IntPtr",
          "type": "data"
        },
        "index": {
          "description": "signed integral type that can be losslessly converted to and from Ptr This type is also compatible with the C99 type intptr and can be marshalled to and from that type safely",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "IntPtr",
          "package": "base",
          "partial": "Int Ptr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#t:IntPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e represents a pointer to an object, or an\n array of objects, which may be marshalled to or from Haskell values\n of type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe type \u003ccode\u003ea\u003c/code\u003e will often be an instance of class\n \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e which provides the marshalling operations.\n However this is not essential, and you can provide your own operations\n to access the pointer.  For example you might write small foreign\n functions to get or set the fields of a C \u003ccode\u003estruct\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "Ptr",
          "package": "base",
          "source": "src/GHC-Ptr.html#Ptr",
          "type": "data"
        },
        "index": {
          "description": "value of type Ptr represents pointer to an object or an array of objects which may be marshalled to or from Haskell values of type The type will often be an instance of class Storable which provides the marshalling operations However this is not essential and you can provide your own operations to access the pointer For example you might write small foreign functions to get or set the fields of struct",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "Ptr",
          "package": "base",
          "partial": "Ptr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#t:Ptr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn unsigned integral type that can be losslessly converted to and from\n \u003ccode\u003ePtr\u003c/code\u003e. This type is also compatible with the C99 type \u003ccode\u003euintptr_t\u003c/code\u003e, and\n can be marshalled to and from that type safely.\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "WordPtr",
          "package": "base",
          "source": "src/Foreign-Ptr.html#WordPtr",
          "type": "data"
        },
        "index": {
          "description": "An unsigned integral type that can be losslessly converted to and from Ptr This type is also compatible with the C99 type uintptr and can be marshalled to and from that type safely",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "WordPtr",
          "package": "base",
          "partial": "Word Ptr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#t:WordPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven an arbitrary address and an alignment constraint,\n \u003ccode\u003e\u003ca\u003ealignPtr\u003c/a\u003e\u003c/code\u003e yields the next higher address that fulfills the\n alignment constraint.  An alignment constraint \u003ccode\u003ex\u003c/code\u003e is fulfilled by\n any address divisible by \u003ccode\u003ex\u003c/code\u003e.  This operation is idempotent.\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "alignPtr",
          "package": "base",
          "signature": "Ptr a -\u003e Int -\u003e Ptr a",
          "source": "src/GHC-Ptr.html#alignPtr",
          "type": "function"
        },
        "index": {
          "description": "Given an arbitrary address and an alignment constraint alignPtr yields the next higher address that fulfills the alignment constraint An alignment constraint is fulfilled by any address divisible by This operation is idempotent",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "alignPtr",
          "normalized": "Ptr a-\u003eInt-\u003ePtr a",
          "package": "base",
          "partial": "Ptr",
          "signature": "Ptr a-\u003eInt-\u003ePtr a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#v:alignPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCasts a \u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e of a different type.\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "castFunPtr",
          "package": "base",
          "signature": "FunPtr a -\u003e FunPtr b",
          "source": "src/GHC-Ptr.html#castFunPtr",
          "type": "function"
        },
        "index": {
          "description": "Casts FunPtr to FunPtr of different type",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "castFunPtr",
          "normalized": "FunPtr a-\u003eFunPtr b",
          "package": "base",
          "partial": "Fun Ptr",
          "signature": "FunPtr a-\u003eFunPtr b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#v:castFunPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCasts a \u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e this is valid only on architectures where data and function\n pointers range over the same set of addresses, and should only be used\n for bindings to external libraries whose interface already relies on\n this assumption.\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "castFunPtrToPtr",
          "package": "base",
          "signature": "FunPtr a -\u003e Ptr b",
          "source": "src/GHC-Ptr.html#castFunPtrToPtr",
          "type": "function"
        },
        "index": {
          "description": "Casts FunPtr to Ptr Note this is valid only on architectures where data and function pointers range over the same set of addresses and should only be used for bindings to external libraries whose interface already relies on this assumption",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "castFunPtrToPtr",
          "normalized": "FunPtr a-\u003ePtr b",
          "package": "base",
          "partial": "Fun Ptr To Ptr",
          "signature": "FunPtr a-\u003ePtr b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#v:castFunPtrToPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ecastPtr\u003c/a\u003e\u003c/code\u003e function casts a pointer from one type to another.\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "castPtr",
          "package": "base",
          "signature": "Ptr a -\u003e Ptr b",
          "source": "src/GHC-Ptr.html#castPtr",
          "type": "function"
        },
        "index": {
          "description": "The castPtr function casts pointer from one type to another",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "castPtr",
          "normalized": "Ptr a-\u003ePtr b",
          "package": "base",
          "partial": "Ptr",
          "signature": "Ptr a-\u003ePtr b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#v:castPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCasts a \u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e this is valid only on architectures where data and function\n pointers range over the same set of addresses, and should only be used\n for bindings to external libraries whose interface already relies on\n this assumption.\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "castPtrToFunPtr",
          "package": "base",
          "signature": "Ptr a -\u003e FunPtr b",
          "source": "src/GHC-Ptr.html#castPtrToFunPtr",
          "type": "function"
        },
        "index": {
          "description": "Casts Ptr to FunPtr Note this is valid only on architectures where data and function pointers range over the same set of addresses and should only be used for bindings to external libraries whose interface already relies on this assumption",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "castPtrToFunPtr",
          "normalized": "Ptr a-\u003eFunPtr b",
          "package": "base",
          "partial": "Ptr To Fun Ptr",
          "signature": "Ptr a-\u003eFunPtr b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#v:castPtrToFunPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRelease the storage associated with the given \u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e, which\n must have been obtained from a wrapper stub.  This should be called\n whenever the return value from a foreign import wrapper function is\n no longer required; otherwise, the storage it uses will leak.\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "freeHaskellFunPtr",
          "package": "base",
          "signature": "FunPtr a -\u003e IO ()",
          "source": "src/Foreign-Ptr.html#freeHaskellFunPtr",
          "type": "function"
        },
        "index": {
          "description": "Release the storage associated with the given FunPtr which must have been obtained from wrapper stub This should be called whenever the return value from foreign import wrapper function is no longer required otherwise the storage it uses will leak",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "freeHaskellFunPtr",
          "normalized": "FunPtr a-\u003eIO()",
          "package": "base",
          "partial": "Haskell Fun Ptr",
          "signature": "FunPtr a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#v:freeHaskellFunPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecasts an \u003ccode\u003eIntPtr\u003c/code\u003e to a \u003ccode\u003ePtr\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "intPtrToPtr",
          "package": "base",
          "signature": "IntPtr -\u003e Ptr a",
          "source": "src/Foreign-Ptr.html#intPtrToPtr",
          "type": "function"
        },
        "index": {
          "description": "casts an IntPtr to Ptr",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "intPtrToPtr",
          "normalized": "IntPtr-\u003ePtr a",
          "package": "base",
          "partial": "Ptr To Ptr",
          "signature": "IntPtr-\u003ePtr a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#v:intPtrToPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputes the offset required to get from the second to the first\n argument.  We have \n\u003c/p\u003e\u003cpre\u003e p2 == p1 `plusPtr` (p2 `minusPtr` p1)\n\u003c/pre\u003e",
          "module": "Foreign.Ptr",
          "name": "minusPtr",
          "package": "base",
          "signature": "Ptr a -\u003e Ptr b -\u003e Int",
          "source": "src/GHC-Ptr.html#minusPtr",
          "type": "function"
        },
        "index": {
          "description": "Computes the offset required to get from the second to the first argument We have p2 p1 plusPtr p2 minusPtr p1",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "minusPtr",
          "normalized": "Ptr a-\u003ePtr b-\u003eInt",
          "package": "base",
          "partial": "Ptr",
          "signature": "Ptr a-\u003ePtr b-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#v:minusPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe constant \u003ccode\u003e\u003ca\u003enullFunPtr\u003c/a\u003e\u003c/code\u003e contains a\n distinguished value of \u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e that is not\n associated with a valid memory location.\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "nullFunPtr",
          "package": "base",
          "signature": "FunPtr a",
          "source": "src/GHC-Ptr.html#nullFunPtr",
          "type": "function"
        },
        "index": {
          "description": "The constant nullFunPtr contains distinguished value of FunPtr that is not associated with valid memory location",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "nullFunPtr",
          "package": "base",
          "partial": "Fun Ptr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#v:nullFunPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe constant \u003ccode\u003e\u003ca\u003enullPtr\u003c/a\u003e\u003c/code\u003e contains a distinguished value of \u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e\n that is not associated with a valid memory location.\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "nullPtr",
          "package": "base",
          "signature": "Ptr a",
          "source": "src/GHC-Ptr.html#nullPtr",
          "type": "function"
        },
        "index": {
          "description": "The constant nullPtr contains distinguished value of Ptr that is not associated with valid memory location",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "nullPtr",
          "package": "base",
          "partial": "Ptr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#v:nullPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdvances the given address by the given offset in bytes.\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "plusPtr",
          "package": "base",
          "signature": "Ptr a -\u003e Int -\u003e Ptr b",
          "source": "src/GHC-Ptr.html#plusPtr",
          "type": "function"
        },
        "index": {
          "description": "Advances the given address by the given offset in bytes",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "plusPtr",
          "normalized": "Ptr a-\u003eInt-\u003ePtr b",
          "package": "base",
          "partial": "Ptr",
          "signature": "Ptr a-\u003eInt-\u003ePtr b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#v:plusPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecasts a \u003ccode\u003ePtr\u003c/code\u003e to an \u003ccode\u003eIntPtr\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "ptrToIntPtr",
          "package": "base",
          "signature": "Ptr a -\u003e IntPtr",
          "source": "src/Foreign-Ptr.html#ptrToIntPtr",
          "type": "function"
        },
        "index": {
          "description": "casts Ptr to an IntPtr",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "ptrToIntPtr",
          "normalized": "Ptr a-\u003eIntPtr",
          "package": "base",
          "partial": "To Int Ptr",
          "signature": "Ptr a-\u003eIntPtr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#v:ptrToIntPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecasts a \u003ccode\u003ePtr\u003c/code\u003e to a \u003ccode\u003eWordPtr\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "ptrToWordPtr",
          "package": "base",
          "signature": "Ptr a -\u003e WordPtr",
          "source": "src/Foreign-Ptr.html#ptrToWordPtr",
          "type": "function"
        },
        "index": {
          "description": "casts Ptr to WordPtr",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "ptrToWordPtr",
          "normalized": "Ptr a-\u003eWordPtr",
          "package": "base",
          "partial": "To Word Ptr",
          "signature": "Ptr a-\u003eWordPtr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#v:ptrToWordPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecasts a \u003ccode\u003eWordPtr\u003c/code\u003e to a \u003ccode\u003ePtr\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Foreign.Ptr",
          "name": "wordPtrToPtr",
          "package": "base",
          "signature": "WordPtr -\u003e Ptr a",
          "source": "src/Foreign-Ptr.html#wordPtrToPtr",
          "type": "function"
        },
        "index": {
          "description": "casts WordPtr to Ptr",
          "hierarchy": "Foreign Ptr",
          "module": "Foreign.Ptr",
          "name": "wordPtrToPtr",
          "normalized": "WordPtr-\u003ePtr a",
          "package": "base",
          "partial": "Ptr To Ptr",
          "signature": "WordPtr-\u003ePtr a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html#v:wordPtrToPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA collection of data types, classes, and functions for interfacing\n with another programming language.\n\u003c/p\u003e\u003cp\u003eSafe API Only.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.Safe",
          "name": "Safe",
          "package": "base",
          "source": "src/Foreign-Safe.html",
          "type": "module"
        },
        "index": {
          "description": "collection of data types classes and functions for interfacing with another programming language Safe API Only",
          "hierarchy": "Foreign Safe",
          "module": "Foreign.Safe",
          "name": "Safe",
          "package": "base",
          "partial": "Safe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Safe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module is part of the Foreign Function Interface (FFI) and will usually\n be imported via the module \u003ca\u003eForeign\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.StablePtr",
          "name": "StablePtr",
          "package": "base",
          "source": "src/Foreign-StablePtr.html",
          "type": "module"
        },
        "index": {
          "description": "This module is part of the Foreign Function Interface FFI and will usually be imported via the module Foreign",
          "hierarchy": "Foreign StablePtr",
          "module": "Foreign.StablePtr",
          "name": "StablePtr",
          "package": "base",
          "partial": "Stable Ptr",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-StablePtr.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003cem\u003estable pointer\u003c/em\u003e is a reference to a Haskell expression that is\nguaranteed not to be affected by garbage collection, i.e., it will neither be\ndeallocated nor will the value of the stable pointer itself change during\ngarbage collection (ordinary references may be relocated during garbage\ncollection).  Consequently, stable pointers can be passed to foreign code,\nwhich can treat it as an opaque reference to a Haskell value.\n\u003c/p\u003e\u003cp\u003eA value of type \u003ccode\u003eStablePtr a\u003c/code\u003e is a stable pointer to a Haskell\nexpression of type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.StablePtr",
          "name": "StablePtr",
          "package": "base",
          "source": "src/GHC-Stable.html#StablePtr",
          "type": "data"
        },
        "index": {
          "description": "stable pointer is reference to Haskell expression that is guaranteed not to be affected by garbage collection i.e it will neither be deallocated nor will the value of the stable pointer itself change during garbage collection ordinary references may be relocated during garbage collection Consequently stable pointers can be passed to foreign code which can treat it as an opaque reference to Haskell value value of type StablePtr is stable pointer to Haskell expression of type",
          "hierarchy": "Foreign StablePtr",
          "module": "Foreign.StablePtr",
          "name": "StablePtr",
          "package": "base",
          "partial": "Stable Ptr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-StablePtr.html#t:StablePtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe inverse of \u003ccode\u003e\u003ca\u003ecastStablePtrToPtr\u003c/a\u003e\u003c/code\u003e, i.e., we have the identity\n\u003c/p\u003e\u003cpre\u003e sp == castPtrToStablePtr (castStablePtrToPtr sp)\n\u003c/pre\u003e\u003cp\u003efor any stable pointer \u003ccode\u003esp\u003c/code\u003e on which \u003ccode\u003e\u003ca\u003efreeStablePtr\u003c/a\u003e\u003c/code\u003e has\n not been executed yet.  Moreover, \u003ccode\u003e\u003ca\u003ecastPtrToStablePtr\u003c/a\u003e\u003c/code\u003e may\n only be applied to pointers that have been produced by\n \u003ccode\u003e\u003ca\u003ecastStablePtrToPtr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.StablePtr",
          "name": "castPtrToStablePtr",
          "package": "base",
          "signature": "Ptr () -\u003e StablePtr a",
          "source": "src/GHC-Stable.html#castPtrToStablePtr",
          "type": "function"
        },
        "index": {
          "description": "The inverse of castStablePtrToPtr i.e we have the identity sp castPtrToStablePtr castStablePtrToPtr sp for any stable pointer sp on which freeStablePtr has not been executed yet Moreover castPtrToStablePtr may only be applied to pointers that have been produced by castStablePtrToPtr",
          "hierarchy": "Foreign StablePtr",
          "module": "Foreign.StablePtr",
          "name": "castPtrToStablePtr",
          "normalized": "Ptr()-\u003eStablePtr a",
          "package": "base",
          "partial": "Ptr To Stable Ptr",
          "signature": "Ptr()-\u003eStablePtr a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-StablePtr.html#v:castPtrToStablePtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCoerce a stable pointer to an address. No guarantees are made about\n the resulting value, except that the original stable pointer can be\n recovered by \u003ccode\u003e\u003ca\u003ecastPtrToStablePtr\u003c/a\u003e\u003c/code\u003e.  In particular, the address may not\n refer to an accessible memory location and any attempt to pass it to\n the member functions of the class \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e leads to\n undefined behaviour.\n\u003c/p\u003e",
          "module": "Foreign.StablePtr",
          "name": "castStablePtrToPtr",
          "package": "base",
          "signature": "StablePtr a -\u003e Ptr ()",
          "source": "src/GHC-Stable.html#castStablePtrToPtr",
          "type": "function"
        },
        "index": {
          "description": "Coerce stable pointer to an address No guarantees are made about the resulting value except that the original stable pointer can be recovered by castPtrToStablePtr In particular the address may not refer to an accessible memory location and any attempt to pass it to the member functions of the class Storable leads to undefined behaviour",
          "hierarchy": "Foreign StablePtr",
          "module": "Foreign.StablePtr",
          "name": "castStablePtrToPtr",
          "normalized": "StablePtr a-\u003ePtr()",
          "package": "base",
          "partial": "Stable Ptr To Ptr",
          "signature": "StablePtr a-\u003ePtr()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-StablePtr.html#v:castStablePtrToPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the Haskell value referenced by a stable pointer, i.e., the\n same value that was passed to the corresponding call to\n \u003ccode\u003emakeStablePtr\u003c/code\u003e.  If the argument to \u003ccode\u003e\u003ca\u003edeRefStablePtr\u003c/a\u003e\u003c/code\u003e has\n already been freed using \u003ccode\u003e\u003ca\u003efreeStablePtr\u003c/a\u003e\u003c/code\u003e, the behaviour of\n \u003ccode\u003e\u003ca\u003edeRefStablePtr\u003c/a\u003e\u003c/code\u003e is undefined.\n\u003c/p\u003e",
          "module": "Foreign.StablePtr",
          "name": "deRefStablePtr",
          "package": "base",
          "signature": "StablePtr a -\u003e IO a",
          "source": "src/GHC-Stable.html#deRefStablePtr",
          "type": "function"
        },
        "index": {
          "description": "Obtain the Haskell value referenced by stable pointer i.e the same value that was passed to the corresponding call to makeStablePtr If the argument to deRefStablePtr has already been freed using freeStablePtr the behaviour of deRefStablePtr is undefined",
          "hierarchy": "Foreign StablePtr",
          "module": "Foreign.StablePtr",
          "name": "deRefStablePtr",
          "normalized": "StablePtr a-\u003eIO a",
          "package": "base",
          "partial": "Ref Stable Ptr",
          "signature": "StablePtr a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-StablePtr.html#v:deRefStablePtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDissolve the association between the stable pointer and the Haskell\n value. Afterwards, if the stable pointer is passed to\n \u003ccode\u003e\u003ca\u003edeRefStablePtr\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003efreeStablePtr\u003c/a\u003e\u003c/code\u003e, the behaviour is\n undefined.  However, the stable pointer may still be passed to\n \u003ccode\u003e\u003ca\u003ecastStablePtrToPtr\u003c/a\u003e\u003c/code\u003e, but the \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e ()\u003c/code\u003e value returned\n by \u003ccode\u003e\u003ca\u003ecastStablePtrToPtr\u003c/a\u003e\u003c/code\u003e, in this case, is undefined (in particular,\n it may be \u003ccode\u003e\u003ca\u003enullPtr\u003c/a\u003e\u003c/code\u003e).  Nevertheless, the call\n to \u003ccode\u003e\u003ca\u003ecastStablePtrToPtr\u003c/a\u003e\u003c/code\u003e is guaranteed not to diverge.\n\u003c/p\u003e",
          "module": "Foreign.StablePtr",
          "name": "freeStablePtr",
          "package": "base",
          "signature": "StablePtr a -\u003e IO ()",
          "source": "src/GHC-Stable.html#freeStablePtr",
          "type": "function"
        },
        "index": {
          "description": "Dissolve the association between the stable pointer and the Haskell value Afterwards if the stable pointer is passed to deRefStablePtr or freeStablePtr the behaviour is undefined However the stable pointer may still be passed to castStablePtrToPtr but the Ptr value returned by castStablePtrToPtr in this case is undefined in particular it may be nullPtr Nevertheless the call to castStablePtrToPtr is guaranteed not to diverge",
          "hierarchy": "Foreign StablePtr",
          "module": "Foreign.StablePtr",
          "name": "freeStablePtr",
          "normalized": "StablePtr a-\u003eIO()",
          "package": "base",
          "partial": "Stable Ptr",
          "signature": "StablePtr a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-StablePtr.html#v:freeStablePtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a stable pointer referring to the given Haskell value.\n\u003c/p\u003e",
          "module": "Foreign.StablePtr",
          "name": "newStablePtr",
          "package": "base",
          "signature": "a -\u003e IO (StablePtr a)",
          "source": "src/GHC-Stable.html#newStablePtr",
          "type": "function"
        },
        "index": {
          "description": "Create stable pointer referring to the given Haskell value",
          "hierarchy": "Foreign StablePtr",
          "module": "Foreign.StablePtr",
          "name": "newStablePtr",
          "normalized": "a-\u003eIO(StablePtr a)",
          "package": "base",
          "partial": "Stable Ptr",
          "signature": "a-\u003eIO(StablePtr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-StablePtr.html#v:newStablePtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe module \u003ca\u003eForeign.Storable\u003c/a\u003e provides most elementary support for\n marshalling and is part of the language-independent portion of the\n Foreign Function Interface (FFI), and will normally be imported via\n the \u003ca\u003eForeign\u003c/a\u003e module.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign.Storable",
          "name": "Storable",
          "package": "base",
          "source": "src/Foreign-Storable.html",
          "type": "module"
        },
        "index": {
          "description": "The module Foreign.Storable provides most elementary support for marshalling and is part of the language-independent portion of the Foreign Function Interface FFI and will normally be imported via the Foreign module",
          "hierarchy": "Foreign Storable",
          "module": "Foreign.Storable",
          "name": "Storable",
          "package": "base",
          "partial": "Storable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Storable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe member functions of this class facilitate writing values of\nprimitive types to raw memory (which may have been allocated with the\nabove mentioned routines) and reading values from blocks of raw\nmemory.  The class, furthermore, includes support for computing the\nstorage requirements and alignment restrictions of storable types.\n\u003c/p\u003e\u003cp\u003eMemory addresses are represented as values of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e, for some\n\u003ccode\u003ea\u003c/code\u003e which is an instance of class \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e.  The type argument to\n\u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e helps provide some valuable type safety in FFI code (you can't\nmix pointers of different types without an explicit cast), while\nhelping the Haskell type system figure out which marshalling method is\nneeded for a given pointer.\n\u003c/p\u003e\u003cp\u003eAll marshalling between Haskell and a foreign language ultimately\nboils down to translating Haskell data structures into the binary\nrepresentation of a corresponding data structure of the foreign\nlanguage and vice versa.  To code this marshalling in Haskell, it is\nnecessary to manipulate primitive data types stored in unstructured\nmemory blocks.  The class \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e facilitates this manipulation on\nall types for which it is instantiated, which are the standard basic\ntypes of Haskell, the fixed size \u003ccode\u003eInt\u003c/code\u003e types (\u003ccode\u003e\u003ca\u003eInt8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt16\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003eInt32\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt64\u003c/a\u003e\u003c/code\u003e), the fixed size \u003ccode\u003eWord\u003c/code\u003e types (\u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord16\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003eWord32\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord64\u003c/a\u003e\u003c/code\u003e), \u003ccode\u003e\u003ca\u003eStablePtr\u003c/a\u003e\u003c/code\u003e, all types from \u003ca\u003eForeign.C.Types\u003c/a\u003e,\nas well as \u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003esizeOf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ealignment\u003c/a\u003e\u003c/code\u003e, one of \u003ccode\u003e\u003ca\u003epeek\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003epeekElemOff\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003epeekByteOff\u003c/a\u003e\u003c/code\u003e, and one of \u003ccode\u003e\u003ca\u003epoke\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003epokeElemOff\u003c/a\u003e\u003c/code\u003e and\n\u003ccode\u003e\u003ca\u003epokeByteOff\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.Storable",
          "name": "Storable",
          "package": "base",
          "source": "src/Foreign-Storable.html#Storable",
          "type": "class"
        },
        "index": {
          "description": "The member functions of this class facilitate writing values of primitive types to raw memory which may have been allocated with the above mentioned routines and reading values from blocks of raw memory The class furthermore includes support for computing the storage requirements and alignment restrictions of storable types Memory addresses are represented as values of type Ptr for some which is an instance of class Storable The type argument to Ptr helps provide some valuable type safety in FFI code you can mix pointers of different types without an explicit cast while helping the Haskell type system figure out which marshalling method is needed for given pointer All marshalling between Haskell and foreign language ultimately boils down to translating Haskell data structures into the binary representation of corresponding data structure of the foreign language and vice versa To code this marshalling in Haskell it is necessary to manipulate primitive data types stored in unstructured memory blocks The class Storable facilitates this manipulation on all types for which it is instantiated which are the standard basic types of Haskell the fixed size Int types Int8 Int16 Int32 Int64 the fixed size Word types Word8 Word16 Word32 Word64 StablePtr all types from Foreign.C.Types as well as Ptr Minimal complete definition sizeOf alignment one of peek peekElemOff and peekByteOff and one of poke pokeElemOff and pokeByteOff",
          "hierarchy": "Foreign Storable",
          "module": "Foreign.Storable",
          "name": "Storable",
          "package": "base",
          "partial": "Storable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Storable.html#t:Storable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputes the alignment constraint of the argument.  An\n alignment constraint \u003ccode\u003ex\u003c/code\u003e is fulfilled by any address divisible\n by \u003ccode\u003ex\u003c/code\u003e.  The value of the argument is not used.\n\u003c/p\u003e",
          "module": "Foreign.Storable",
          "name": "alignment",
          "package": "base",
          "signature": "a -\u003e Int",
          "source": "src/Foreign-Storable.html#alignment",
          "type": "method"
        },
        "index": {
          "description": "Computes the alignment constraint of the argument An alignment constraint is fulfilled by any address divisible by The value of the argument is not used",
          "hierarchy": "Foreign Storable",
          "module": "Foreign.Storable",
          "name": "alignment",
          "normalized": "a-\u003eInt",
          "package": "base",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Storable.html#v:alignment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a value from the given memory location.\n\u003c/p\u003e\u003cp\u003eNote that the peek and poke functions might require properly\n  aligned addresses to function correctly.  This is architecture\n  dependent; thus, portable code should ensure that when peeking or\n  poking values of some type \u003ccode\u003ea\u003c/code\u003e, the alignment\n  constraint for \u003ccode\u003ea\u003c/code\u003e, as given by the function\n  \u003ccode\u003e\u003ca\u003ealignment\u003c/a\u003e\u003c/code\u003e is fulfilled.\n\u003c/p\u003e",
          "module": "Foreign.Storable",
          "name": "peek",
          "package": "base",
          "signature": "Ptr a -\u003e IO a",
          "source": "src/Foreign-Storable.html#peek",
          "type": "method"
        },
        "index": {
          "description": "Read value from the given memory location Note that the peek and poke functions might require properly aligned addresses to function correctly This is architecture dependent thus portable code should ensure that when peeking or poking values of some type the alignment constraint for as given by the function alignment is fulfilled",
          "hierarchy": "Foreign Storable",
          "module": "Foreign.Storable",
          "name": "peek",
          "normalized": "Ptr a-\u003eIO a",
          "package": "base",
          "signature": "Ptr a-\u003eIO a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Storable.html#v:peek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a value from a memory location given by a base\n         address and offset.  The following equality holds:\n\u003c/p\u003e\u003cpre\u003e peekByteOff addr off = peek (addr `plusPtr` off)\n\u003c/pre\u003e",
          "module": "Foreign.Storable",
          "name": "peekByteOff",
          "package": "base",
          "signature": "Ptr b -\u003e Int -\u003e IO a",
          "source": "src/Foreign-Storable.html#peekByteOff",
          "type": "method"
        },
        "index": {
          "description": "Read value from memory location given by base address and offset The following equality holds peekByteOff addr off peek addr plusPtr off",
          "hierarchy": "Foreign Storable",
          "module": "Foreign.Storable",
          "name": "peekByteOff",
          "normalized": "Ptr a-\u003eInt-\u003eIO b",
          "package": "base",
          "partial": "Byte Off",
          "signature": "Ptr b-\u003eInt-\u003eIO a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Storable.html#v:peekByteOff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a value from a memory area regarded as an array\n         of values of the same kind.  The first argument specifies\n         the start address of the array and the second the index into\n         the array (the first element of the array has index\n         \u003ccode\u003e0\u003c/code\u003e).  The following equality holds,\n\u003c/p\u003e\u003cpre\u003e peekElemOff addr idx = IOExts.fixIO $ \\result -\u003e\n   peek (addr `plusPtr` (idx * sizeOf result))\n\u003c/pre\u003e\u003cp\u003eNote that this is only a specification, not\n         necessarily the concrete implementation of the\n         function.\n\u003c/p\u003e",
          "module": "Foreign.Storable",
          "name": "peekElemOff",
          "package": "base",
          "signature": "Ptr a -\u003e Int -\u003e IO a",
          "source": "src/Foreign-Storable.html#peekElemOff",
          "type": "method"
        },
        "index": {
          "description": "Read value from memory area regarded as an array of values of the same kind The first argument specifies the start address of the array and the second the index into the array the first element of the array has index The following equality holds peekElemOff addr idx IOExts.fixIO result peek addr plusPtr idx sizeOf result Note that this is only specification not necessarily the concrete implementation of the function",
          "hierarchy": "Foreign Storable",
          "module": "Foreign.Storable",
          "name": "peekElemOff",
          "normalized": "Ptr a-\u003eInt-\u003eIO a",
          "package": "base",
          "partial": "Elem Off",
          "signature": "Ptr a-\u003eInt-\u003eIO a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Storable.html#v:peekElemOff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite the given value to the given memory location.  Alignment\n restrictions might apply; see \u003ccode\u003e\u003ca\u003epeek\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign.Storable",
          "name": "poke",
          "package": "base",
          "signature": "Ptr a -\u003e a -\u003e IO ()",
          "source": "src/Foreign-Storable.html#poke",
          "type": "method"
        },
        "index": {
          "description": "Write the given value to the given memory location Alignment restrictions might apply see peek",
          "hierarchy": "Foreign Storable",
          "module": "Foreign.Storable",
          "name": "poke",
          "normalized": "Ptr a-\u003ea-\u003eIO()",
          "package": "base",
          "signature": "Ptr a-\u003ea-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Storable.html#v:poke"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a value to a memory location given by a base\n         address and offset.  The following equality holds:\n\u003c/p\u003e\u003cpre\u003e pokeByteOff addr off x = poke (addr `plusPtr` off) x\n\u003c/pre\u003e",
          "module": "Foreign.Storable",
          "name": "pokeByteOff",
          "package": "base",
          "signature": "Ptr b -\u003e Int -\u003e a -\u003e IO ()",
          "source": "src/Foreign-Storable.html#pokeByteOff",
          "type": "method"
        },
        "index": {
          "description": "Write value to memory location given by base address and offset The following equality holds pokeByteOff addr off poke addr plusPtr off",
          "hierarchy": "Foreign Storable",
          "module": "Foreign.Storable",
          "name": "pokeByteOff",
          "normalized": "Ptr a-\u003eInt-\u003eb-\u003eIO()",
          "package": "base",
          "partial": "Byte Off",
          "signature": "Ptr b-\u003eInt-\u003ea-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Storable.html#v:pokeByteOff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a value to a memory area regarded as an array of\n         values of the same kind.  The following equality holds:\n\u003c/p\u003e\u003cpre\u003e pokeElemOff addr idx x = \n   poke (addr `plusPtr` (idx * sizeOf x)) x\n\u003c/pre\u003e",
          "module": "Foreign.Storable",
          "name": "pokeElemOff",
          "package": "base",
          "signature": "Ptr a -\u003e Int -\u003e a -\u003e IO ()",
          "source": "src/Foreign-Storable.html#pokeElemOff",
          "type": "method"
        },
        "index": {
          "description": "Write value to memory area regarded as an array of values of the same kind The following equality holds pokeElemOff addr idx poke addr plusPtr idx sizeOf",
          "hierarchy": "Foreign Storable",
          "module": "Foreign.Storable",
          "name": "pokeElemOff",
          "normalized": "Ptr a-\u003eInt-\u003ea-\u003eIO()",
          "package": "base",
          "partial": "Elem Off",
          "signature": "Ptr a-\u003eInt-\u003ea-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Storable.html#v:pokeElemOff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputes the storage requirements (in bytes) of the argument.\n The value of the argument is not used.\n\u003c/p\u003e",
          "module": "Foreign.Storable",
          "name": "sizeOf",
          "package": "base",
          "signature": "a -\u003e Int",
          "source": "src/Foreign-Storable.html#sizeOf",
          "type": "method"
        },
        "index": {
          "description": "Computes the storage requirements in bytes of the argument The value of the argument is not used",
          "hierarchy": "Foreign Storable",
          "module": "Foreign.Storable",
          "name": "sizeOf",
          "normalized": "a-\u003eInt",
          "package": "base",
          "partial": "Of",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign-Storable.html#v:sizeOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA collection of data types, classes, and functions for interfacing\n with another programming language.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign",
          "name": "Foreign",
          "package": "base",
          "source": "src/Foreign.html",
          "type": "module"
        },
        "index": {
          "description": "collection of data types classes and functions for interfacing with another programming language",
          "hierarchy": "Foreign",
          "module": "Foreign",
          "name": "Foreign",
          "package": "base",
          "partial": "Foreign",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Foreign",
          "name": "FinalizerEnvPtr",
          "package": "base",
          "source": "src/GHC-ForeignPtr.html#FinalizerEnvPtr",
          "type": "type"
        },
        "index": {
          "hierarchy": "Foreign",
          "module": "Foreign",
          "name": "FinalizerEnvPtr",
          "package": "base",
          "partial": "Finalizer Env Ptr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign.html#t:FinalizerEnvPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA finalizer is represented as a pointer to a foreign function that, at\n finalisation time, gets as an argument a plain pointer variant of the\n foreign pointer that the finalizer is associated with.\n\u003c/p\u003e",
          "module": "Foreign",
          "name": "FinalizerPtr",
          "package": "base",
          "source": "src/GHC-ForeignPtr.html#FinalizerPtr",
          "type": "type"
        },
        "index": {
          "description": "finalizer is represented as pointer to foreign function that at finalisation time gets as an argument plain pointer variant of the foreign pointer that the finalizer is associated with",
          "hierarchy": "Foreign",
          "module": "Foreign",
          "name": "FinalizerPtr",
          "package": "base",
          "partial": "Finalizer Ptr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign.html#t:FinalizerPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e represents references to objects that are\n maintained in a foreign language, i.e., that are not part of the\n data structures usually managed by the Haskell storage manager.\n The essential difference between \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003es and vanilla memory\n references of type \u003ccode\u003ePtr a\u003c/code\u003e is that the former may be associated\n with \u003cem\u003efinalizers\u003c/em\u003e. A finalizer is a routine that is invoked when\n the Haskell storage manager detects that - within the Haskell heap\n and stack - there are no more references left that are pointing to\n the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e.  Typically, the finalizer will, then, invoke\n routines in the foreign language that free the resources bound by\n the foreign object.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e is parameterised in the same way as \u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e.  The\n type argument of \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e should normally be an instance of\n class \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Foreign",
          "name": "ForeignPtr",
          "package": "base",
          "source": "src/GHC-ForeignPtr.html#ForeignPtr",
          "type": "data"
        },
        "index": {
          "description": "The type ForeignPtr represents references to objects that are maintained in foreign language i.e that are not part of the data structures usually managed by the Haskell storage manager The essential difference between ForeignPtr and vanilla memory references of type Ptr is that the former may be associated with finalizers finalizer is routine that is invoked when the Haskell storage manager detects that within the Haskell heap and stack there are no more references left that are pointing to the ForeignPtr Typically the finalizer will then invoke routines in the foreign language that free the resources bound by the foreign object The ForeignPtr is parameterised in the same way as Ptr The type argument of ForeignPtr should normally be an instance of class Storable",
          "hierarchy": "Foreign",
          "module": "Foreign",
          "name": "ForeignPtr",
          "package": "base",
          "partial": "Foreign Ptr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign.html#t:ForeignPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use Foreign.ForeignPtr.Unsafe.unsafeForeignPtrToPtr instead; This function will be removed in the next release\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign",
          "name": "unsafeForeignPtrToPtr",
          "package": "base",
          "signature": "ForeignPtr a -\u003e Ptr a",
          "source": "src/Foreign-ForeignPtr.html#unsafeForeignPtrToPtr",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use Foreign.ForeignPtr.Unsafe.unsafeForeignPtrToPtr instead This function will be removed in the next release",
          "hierarchy": "Foreign",
          "module": "Foreign",
          "name": "unsafeForeignPtrToPtr",
          "normalized": "ForeignPtr a-\u003ePtr a",
          "package": "base",
          "partial": "Foreign Ptr To Ptr",
          "signature": "ForeignPtr a-\u003ePtr a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign.html#v:unsafeForeignPtrToPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use System.IO.Unsafe.unsafePerformIO instead; This function will be removed in the next release\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Foreign",
          "name": "unsafePerformIO",
          "package": "base",
          "signature": "IO a -\u003e a",
          "source": "src/Foreign.html#unsafePerformIO",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use System.IO.Unsafe.unsafePerformIO instead This function will be removed in the next release",
          "hierarchy": "Foreign",
          "module": "Foreign",
          "name": "unsafePerformIO",
          "normalized": "IO a-\u003ea",
          "package": "base",
          "partial": "Perform IO",
          "signature": "IO a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Foreign.html#v:unsafePerformIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Char",
          "name": "Char",
          "package": "base",
          "source": "src/GHC-Char.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "GHC Char",
          "module": "GHC.Char",
          "name": "Char",
          "package": "base",
          "partial": "Char",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Char.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic concurrency stuff.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.Conc.IO",
          "name": "IO",
          "package": "base",
          "source": "src/GHC-Conc-IO.html",
          "type": "module"
        },
        "index": {
          "description": "Basic concurrency stuff",
          "hierarchy": "GHC Conc IO",
          "module": "GHC.Conc.IO",
          "name": "IO",
          "package": "base",
          "partial": "IO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-IO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClose a file descriptor in a concurrency-safe way (GHC only).  If\n you are using \u003ccode\u003e\u003ca\u003ethreadWaitRead\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ethreadWaitWrite\u003c/a\u003e\u003c/code\u003e to perform\n blocking I/O, you \u003cem\u003emust\u003c/em\u003e use this function to close file\n descriptors, or blocked threads may not be woken.\n\u003c/p\u003e\u003cp\u003eAny threads that are blocked on the file descriptor via\n \u003ccode\u003e\u003ca\u003ethreadWaitRead\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ethreadWaitWrite\u003c/a\u003e\u003c/code\u003e will be unblocked by having\n IO exceptions thrown.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.IO\",\"GHC.Conc\"]",
          "name": "closeFdWith",
          "package": "base",
          "signature": "(Fd -\u003e IO ())-\u003e Fd-\u003e IO ()",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-IO.html#v:closeFdWith\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:closeFdWith\"]"
        },
        "index": {
          "description": "Close file descriptor in concurrency-safe way GHC only If you are using threadWaitRead or threadWaitWrite to perform blocking you must use this function to close file descriptors or blocked threads may not be woken Any threads that are blocked on the file descriptor via threadWaitRead or threadWaitWrite will be unblocked by having IO exceptions thrown",
          "hierarchy": "GHC Conc IO",
          "module": "GHC.Conc.IO",
          "name": "closeFdWith",
          "normalized": "(Fd-\u003eIO())-\u003eFd-\u003eIO()",
          "package": "base",
          "partial": "Fd With",
          "signature": "(Fd-\u003eIO())-\u003eFd-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-IO.html#v:closeFdWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.IO\",\"GHC.Conc\"]",
          "name": "ensureIOManagerIsRunning",
          "package": "base",
          "signature": "IO ()",
          "source": "src/GHC-Conc-IO.html#ensureIOManagerIsRunning",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-IO.html#v:ensureIOManagerIsRunning\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:ensureIOManagerIsRunning\"]"
        },
        "index": {
          "hierarchy": "GHC Conc IO",
          "module": "GHC.Conc.IO",
          "name": "ensureIOManagerIsRunning",
          "normalized": "IO()",
          "package": "base",
          "partial": "IOManager Is Running",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-IO.html#v:ensureIOManagerIsRunning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the value of returned TVar to True after a given number of\n microseconds. The caveats associated with threadDelay also apply.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.IO\",\"GHC.Conc\"]",
          "name": "registerDelay",
          "package": "base",
          "signature": "Int -\u003e IO (TVar Bool)",
          "source": "src/GHC-Conc-IO.html#registerDelay",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-IO.html#v:registerDelay\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:registerDelay\"]"
        },
        "index": {
          "description": "Set the value of returned TVar to True after given number of microseconds The caveats associated with threadDelay also apply",
          "hierarchy": "GHC Conc IO",
          "module": "GHC.Conc.IO",
          "name": "registerDelay",
          "normalized": "Int-\u003eIO(TVar Bool)",
          "package": "base",
          "partial": "Delay",
          "signature": "Int-\u003eIO(TVar Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-IO.html#v:registerDelay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBlock the current thread until data is available to read on the\n given file descriptor (GHC only).\n\u003c/p\u003e\u003cp\u003eThis will throw an \u003ccode\u003eIOError\u003c/code\u003e if the file descriptor was closed\n while this thread was blocked.  To safely close a file descriptor\n that has been used with \u003ccode\u003e\u003ca\u003ethreadWaitRead\u003c/a\u003e\u003c/code\u003e, use \u003ccode\u003e\u003ca\u003ecloseFdWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.IO\",\"GHC.Conc\"]",
          "name": "threadWaitRead",
          "package": "base",
          "signature": "Fd -\u003e IO ()",
          "source": "src/GHC-Conc-IO.html#threadWaitRead",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-IO.html#v:threadWaitRead\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:threadWaitRead\"]"
        },
        "index": {
          "description": "Block the current thread until data is available to read on the given file descriptor GHC only This will throw an IOError if the file descriptor was closed while this thread was blocked To safely close file descriptor that has been used with threadWaitRead use closeFdWith",
          "hierarchy": "GHC Conc IO",
          "module": "GHC.Conc.IO",
          "name": "threadWaitRead",
          "normalized": "Fd-\u003eIO()",
          "package": "base",
          "partial": "Wait Read",
          "signature": "Fd-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-IO.html#v:threadWaitRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBlock the current thread until data can be written to the\n given file descriptor (GHC only).\n\u003c/p\u003e\u003cp\u003eThis will throw an \u003ccode\u003eIOError\u003c/code\u003e if the file descriptor was closed\n while this thread was blocked.  To safely close a file descriptor\n that has been used with \u003ccode\u003e\u003ca\u003ethreadWaitWrite\u003c/a\u003e\u003c/code\u003e, use \u003ccode\u003e\u003ca\u003ecloseFdWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.IO\",\"GHC.Conc\"]",
          "name": "threadWaitWrite",
          "package": "base",
          "signature": "Fd -\u003e IO ()",
          "source": "src/GHC-Conc-IO.html#threadWaitWrite",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-IO.html#v:threadWaitWrite\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:threadWaitWrite\"]"
        },
        "index": {
          "description": "Block the current thread until data can be written to the given file descriptor GHC only This will throw an IOError if the file descriptor was closed while this thread was blocked To safely close file descriptor that has been used with threadWaitWrite use closeFdWith",
          "hierarchy": "GHC Conc IO",
          "module": "GHC.Conc.IO",
          "name": "threadWaitWrite",
          "normalized": "Fd-\u003eIO()",
          "package": "base",
          "partial": "Wait Write",
          "signature": "Fd-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-IO.html#v:threadWaitWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Conc.Signal",
          "name": "Signal",
          "package": "base",
          "source": "src/GHC-Conc-Signal.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "GHC Conc Signal",
          "module": "GHC.Conc.Signal",
          "name": "Signal",
          "package": "base",
          "partial": "Signal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Signal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Conc.Signal",
          "name": "HandlerFun",
          "package": "base",
          "source": "src/GHC-Conc-Signal.html#HandlerFun",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC Conc Signal",
          "module": "GHC.Conc.Signal",
          "name": "HandlerFun",
          "package": "base",
          "partial": "Handler Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Signal.html#t:HandlerFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Conc.Signal",
          "name": "Signal",
          "package": "base",
          "source": "src/GHC-Conc-Signal.html#Signal",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC Conc Signal",
          "module": "GHC.Conc.Signal",
          "name": "Signal",
          "package": "base",
          "partial": "Signal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Signal.html#t:Signal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Signal\",\"GHC.Conc\"]",
          "name": "runHandlers",
          "package": "base",
          "signature": "ForeignPtr Word8 -\u003e Signal -\u003e IO ()",
          "source": "src/GHC-Conc-Signal.html#runHandlers",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Signal.html#v:runHandlers\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:runHandlers\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Signal",
          "module": "GHC.Conc.Signal",
          "name": "runHandlers",
          "normalized": "ForeignPtr Word-\u003eSignal-\u003eIO()",
          "package": "base",
          "partial": "Handlers",
          "signature": "ForeignPtr Word-\u003eSignal-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Signal.html#v:runHandlers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Signal\",\"GHC.Conc\"]",
          "name": "setHandler",
          "package": "base",
          "signature": "Signal -\u003e Maybe (HandlerFun, Dynamic) -\u003e IO (Maybe (HandlerFun, Dynamic))",
          "source": "src/GHC-Conc-Signal.html#setHandler",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Signal.html#v:setHandler\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:setHandler\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Signal",
          "module": "GHC.Conc.Signal",
          "name": "setHandler",
          "normalized": "Signal-\u003eMaybe(HandlerFun,Dynamic)-\u003eIO(Maybe(HandlerFun,Dynamic))",
          "package": "base",
          "partial": "Handler",
          "signature": "Signal-\u003eMaybe(HandlerFun,Dynamic)-\u003eIO(Maybe(HandlerFun,Dynamic))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Signal.html#v:setHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic concurrency stuff.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.Conc.Sync",
          "name": "Sync",
          "package": "base",
          "source": "src/GHC-Conc-Sync.html",
          "type": "module"
        },
        "index": {
          "description": "Basic concurrency stuff",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "Sync",
          "package": "base",
          "partial": "Sync",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Conc.Sync",
          "name": "BlockReason",
          "package": "base",
          "source": "src/GHC-Conc-Sync.html#BlockReason",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "BlockReason",
          "package": "base",
          "partial": "Block Reason",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#t:BlockReason"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA monad supporting atomic memory transactions.\n\u003c/p\u003e",
          "module": "GHC.Conc.Sync",
          "name": "STM",
          "package": "base",
          "source": "src/GHC-Conc-Sync.html#STM",
          "type": "newtype"
        },
        "index": {
          "description": "monad supporting atomic memory transactions",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "STM",
          "package": "base",
          "partial": "STM",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#t:STM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShared memory locations that support atomic memory transactions.\n\u003c/p\u003e",
          "module": "GHC.Conc.Sync",
          "name": "TVar",
          "package": "base",
          "source": "src/GHC-Conc-Sync.html#TVar",
          "type": "data"
        },
        "index": {
          "description": "Shared memory locations that support atomic memory transactions",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "TVar",
          "package": "base",
          "partial": "TVar",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#t:TVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e is an abstract type representing a handle to a thread.\n\u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e is an instance of \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e, where\nthe \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e instance implements an arbitrary total ordering over\n\u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003es. The \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instance lets you convert an arbitrary-valued\n\u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e to string form; showing a \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e value is occasionally\nuseful when debugging or diagnosing the behaviour of a concurrent\nprogram.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote\u003c/em\u003e: in GHC, if you have a \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e, you essentially have\na pointer to the thread itself.  This means the thread itself can't be\ngarbage collected until you drop the \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e.\nThis misfeature will hopefully be corrected at a later date.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote\u003c/em\u003e: Hugs does not provide any operations on other threads;\nit defines \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e as a synonym for ().\n\u003c/p\u003e",
          "module": "GHC.Conc.Sync",
          "name": "ThreadId",
          "package": "base",
          "source": "src/GHC-Conc-Sync.html#ThreadId",
          "type": "data"
        },
        "index": {
          "description": "ThreadId is an abstract type representing handle to thread ThreadId is an instance of Eq Ord and Show where the Ord instance implements an arbitrary total ordering over ThreadId The Show instance lets you convert an arbitrary-valued ThreadId to string form showing ThreadId value is occasionally useful when debugging or diagnosing the behaviour of concurrent program Note in GHC if you have ThreadId you essentially have pointer to the thread itself This means the thread itself can be garbage collected until you drop the ThreadId This misfeature will hopefully be corrected at later date Note Hugs does not provide any operations on other threads it defines ThreadId as synonym for",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "ThreadId",
          "package": "base",
          "partial": "Thread Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#t:ThreadId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current status of a thread\n\u003c/p\u003e",
          "module": "GHC.Conc.Sync",
          "name": "ThreadStatus",
          "package": "base",
          "source": "src/GHC-Conc-Sync.html#ThreadStatus",
          "type": "data"
        },
        "index": {
          "description": "The current status of thread",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "ThreadStatus",
          "package": "base",
          "partial": "Thread Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#t:ThreadStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eblocked on a computation in progress by another thread\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "BlockedOnBlackHole",
          "package": "base",
          "signature": "BlockedOnBlackHole",
          "source": "src/GHC-Conc-Sync.html#BlockReason",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:BlockedOnBlackHole\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:BlockedOnBlackHole\"]"
        },
        "index": {
          "description": "blocked on computation in progress by another thread",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "BlockedOnBlackHole",
          "package": "base",
          "partial": "Blocked On Black Hole",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:BlockedOnBlackHole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eblocked in \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "BlockedOnException",
          "package": "base",
          "signature": "BlockedOnException",
          "source": "src/GHC-Conc-Sync.html#BlockReason",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:BlockedOnException\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:BlockedOnException\"]"
        },
        "index": {
          "description": "blocked in throwTo",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "BlockedOnException",
          "package": "base",
          "partial": "Blocked On Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:BlockedOnException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrently in a foreign call\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "BlockedOnForeignCall",
          "package": "base",
          "signature": "BlockedOnForeignCall",
          "source": "src/GHC-Conc-Sync.html#BlockReason",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:BlockedOnForeignCall\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:BlockedOnForeignCall\"]"
        },
        "index": {
          "description": "currently in foreign call",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "BlockedOnForeignCall",
          "package": "base",
          "partial": "Blocked On Foreign Call",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:BlockedOnForeignCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eblocked on on \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "BlockedOnMVar",
          "package": "base",
          "signature": "BlockedOnMVar",
          "source": "src/GHC-Conc-Sync.html#BlockReason",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:BlockedOnMVar\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:BlockedOnMVar\"]"
        },
        "index": {
          "description": "blocked on on MVar",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "BlockedOnMVar",
          "package": "base",
          "partial": "Blocked On MVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:BlockedOnMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eblocked on some other resource.  Without \u003ccode\u003e-threaded\u003c/code\u003e,\n I/O and \u003ccode\u003ethreadDelay\u003c/code\u003e show up as \u003ccode\u003e\u003ca\u003eBlockedOnOther\u003c/a\u003e\u003c/code\u003e, with \u003ccode\u003e-threaded\u003c/code\u003e\n they show up as \u003ccode\u003e\u003ca\u003eBlockedOnMVar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "BlockedOnOther",
          "package": "base",
          "signature": "BlockedOnOther",
          "source": "src/GHC-Conc-Sync.html#BlockReason",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:BlockedOnOther\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:BlockedOnOther\"]"
        },
        "index": {
          "description": "blocked on some other resource Without threaded and threadDelay show up as BlockedOnOther with threaded they show up as BlockedOnMVar",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "BlockedOnOther",
          "package": "base",
          "partial": "Blocked On Other",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:BlockedOnOther"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eblocked in \u003ccode\u003e\u003ca\u003eretry\u003c/a\u003e\u003c/code\u003e in an STM transaction\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "BlockedOnSTM",
          "package": "base",
          "signature": "BlockedOnSTM",
          "source": "src/GHC-Conc-Sync.html#BlockReason",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:BlockedOnSTM\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:BlockedOnSTM\"]"
        },
        "index": {
          "description": "blocked in retry in an STM transaction",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "BlockedOnSTM",
          "package": "base",
          "partial": "Blocked On STM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:BlockedOnSTM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "STM",
          "package": "base",
          "signature": "STM (\"/packages/archive///doc/html/GHC-Prim.html#t:State-35-\"\u003eState# RealWorld -\u003e (#\"/packages/archive///doc/html/GHC-Prim.html#t:State-35-\"\u003eState# RealWorld, a#))",
          "source": "src/GHC-Conc-Sync.html#STM",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:STM\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:STM\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "STM",
          "normalized": "STM(a b c d GHC Prim.html #t State State # RealWorld-\u003e(# a b c d GHC Prim.html #t State State # RealWorld,e #))",
          "package": "base",
          "partial": "STM",
          "signature": "STM(packages archive doc html GHC Prim.html #t State State # RealWorld-\u003e(# packages archive doc html GHC Prim.html #t State State # RealWorld,a #))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:STM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "TVar",
          "package": "base",
          "signature": "TVar (\"/packages/archive///doc/html/GHC-Prim.html#t:TVar-35-\"\u003eTVar# RealWorld a)",
          "source": "src/GHC-Conc-Sync.html#TVar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:TVar\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:TVar\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "TVar",
          "package": "base",
          "partial": "TVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:TVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe thread is blocked on some resource\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "ThreadBlocked",
          "package": "base",
          "signature": "ThreadBlocked BlockReason",
          "source": "src/GHC-Conc-Sync.html#ThreadStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:ThreadBlocked\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:ThreadBlocked\"]"
        },
        "index": {
          "description": "the thread is blocked on some resource",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "ThreadBlocked",
          "package": "base",
          "partial": "Thread Blocked",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:ThreadBlocked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe thread received an uncaught exception\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "ThreadDied",
          "package": "base",
          "signature": "ThreadDied",
          "source": "src/GHC-Conc-Sync.html#ThreadStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:ThreadDied\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:ThreadDied\"]"
        },
        "index": {
          "description": "the thread received an uncaught exception",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "ThreadDied",
          "package": "base",
          "partial": "Thread Died",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:ThreadDied"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe thread has finished\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "ThreadFinished",
          "package": "base",
          "signature": "ThreadFinished",
          "source": "src/GHC-Conc-Sync.html#ThreadStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:ThreadFinished\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:ThreadFinished\"]"
        },
        "index": {
          "description": "the thread has finished",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "ThreadFinished",
          "package": "base",
          "partial": "Thread Finished",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:ThreadFinished"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "ThreadId",
          "package": "base",
          "signature": "ThreadId \"/packages/archive///doc/html/GHC-Prim.html#t:ThreadId-35-\"\u003eThreadId#",
          "source": "src/GHC-Conc-Sync.html#ThreadId",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:ThreadId\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:ThreadId\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "ThreadId",
          "package": "base",
          "partial": "Thread Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:ThreadId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe thread is currently runnable or running\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "ThreadRunning",
          "package": "base",
          "signature": "ThreadRunning",
          "source": "src/GHC-Conc-Sync.html#ThreadStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:ThreadRunning\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:ThreadRunning\"]"
        },
        "index": {
          "description": "the thread is currently runnable or running",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "ThreadRunning",
          "package": "base",
          "partial": "Thread Running",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:ThreadRunning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ealways is a variant of alwaysSucceeds in which the invariant is\n expressed as an STM Bool action that must return True.  Returning\n False or raising an exception are both treated as invariant failures.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "always",
          "package": "base",
          "signature": "STM Bool -\u003e STM ()",
          "source": "src/GHC-Conc-Sync.html#always",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:always\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:always\"]"
        },
        "index": {
          "description": "always is variant of alwaysSucceeds in which the invariant is expressed as an STM Bool action that must return True Returning False or raising an exception are both treated as invariant failures",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "always",
          "normalized": "STM Bool-\u003eSTM()",
          "package": "base",
          "signature": "STM Bool-\u003eSTM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:always"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ealwaysSucceeds adds a new invariant that must be true when passed\n to alwaysSucceeds, at the end of the current transaction, and at\n the end of every subsequent transaction.  If it fails at any\n of those points then the transaction violating it is aborted\n and the exception raised by the invariant is propagated.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "alwaysSucceeds",
          "package": "base",
          "signature": "STM a -\u003e STM ()",
          "source": "src/GHC-Conc-Sync.html#alwaysSucceeds",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:alwaysSucceeds\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:alwaysSucceeds\"]"
        },
        "index": {
          "description": "alwaysSucceeds adds new invariant that must be true when passed to alwaysSucceeds at the end of the current transaction and at the end of every subsequent transaction If it fails at any of those points then the transaction violating it is aborted and the exception raised by the invariant is propagated",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "alwaysSucceeds",
          "normalized": "STM a-\u003eSTM()",
          "package": "base",
          "partial": "Succeeds",
          "signature": "STM a-\u003eSTM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:alwaysSucceeds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform a series of STM actions atomically.\n\u003c/p\u003e\u003cp\u003eYou cannot use \u003ccode\u003e\u003ca\u003eatomically\u003c/a\u003e\u003c/code\u003e inside an \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eunsafeInterleaveIO\u003c/a\u003e\u003c/code\u003e.\n Any attempt to do so will result in a runtime error.  (Reason: allowing\n this would effectively allow a transaction inside a transaction, depending\n on exactly when the thunk is evaluated.)\n\u003c/p\u003e\u003cp\u003eHowever, see \u003ccode\u003e\u003ca\u003enewTVarIO\u003c/a\u003e\u003c/code\u003e, which can be called inside \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e,\n and which allows top-level TVars to be allocated.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "atomically",
          "package": "base",
          "signature": "STM a -\u003e IO a",
          "source": "src/GHC-Conc-Sync.html#atomically",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:atomically\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:atomically\"]"
        },
        "index": {
          "description": "Perform series of STM actions atomically You cannot use atomically inside an unsafePerformIO or unsafeInterleaveIO Any attempt to do so will result in runtime error Reason allowing this would effectively allow transaction inside transaction depending on exactly when the thunk is evaluated However see newTVarIO which can be called inside unsafePerformIO and which allows top-level TVars to be allocated",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "atomically",
          "normalized": "STM a-\u003eIO a",
          "package": "base",
          "signature": "STM a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:atomically"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eException handling within STM actions.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "catchSTM",
          "package": "base",
          "signature": "STM a -\u003e (e -\u003e STM a) -\u003e STM a",
          "source": "src/GHC-Conc-Sync.html#catchSTM",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:catchSTM\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:catchSTM\"]"
        },
        "index": {
          "description": "Exception handling within STM actions",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "catchSTM",
          "normalized": "STM a-\u003e(b-\u003eSTM a)-\u003eSTM a",
          "package": "base",
          "partial": "STM",
          "signature": "STM a-\u003e(e-\u003eSTM a)-\u003eSTM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:catchSTM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "childHandler",
          "package": "base",
          "signature": "SomeException -\u003e IO ()",
          "source": "src/GHC-Conc-Sync.html#childHandler",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:childHandler\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:childHandler\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "childHandler",
          "normalized": "SomeException-\u003eIO()",
          "package": "base",
          "partial": "Handler",
          "signature": "SomeException-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:childHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: renamed to forkOn\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis function is deprecated; use \u003ccode\u003e\u003ca\u003eforkOn\u003c/a\u003e\u003c/code\u003e instead\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "forkOnIO",
          "package": "base",
          "signature": "Int -\u003e IO () -\u003e IO ThreadId",
          "source": "src/GHC-Conc-Sync.html#forkOnIO",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:forkOnIO\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:forkOnIO\"]"
        },
        "index": {
          "description": "Deprecated renamed to forkOn This function is deprecated use forkOn instead",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "forkOnIO",
          "normalized": "Int-\u003eIO()-\u003eIO ThreadId",
          "package": "base",
          "partial": "On IO",
          "signature": "Int-\u003eIO()-\u003eIO ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:forkOnIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use forkOnWithUnmask instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis function is deprecated; use \u003ccode\u003eforkOnWIthUnmask\u003c/code\u003e instead\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "forkOnIOUnmasked",
          "package": "base",
          "signature": "Int -\u003e IO () -\u003e IO ThreadId",
          "source": "src/GHC-Conc-Sync.html#forkOnIOUnmasked",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:forkOnIOUnmasked\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:forkOnIOUnmasked\"]"
        },
        "index": {
          "description": "Deprecated use forkOnWithUnmask instead This function is deprecated use forkOnWIthUnmask instead",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "forkOnIOUnmasked",
          "normalized": "Int-\u003eIO()-\u003eIO ThreadId",
          "package": "base",
          "partial": "On IOUnmasked",
          "signature": "Int-\u003eIO()-\u003eIO ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:forkOnIOUnmasked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "getNumProcessors",
          "package": "base",
          "signature": "IO Int",
          "source": "src/GHC-Conc-Sync.html#getNumProcessors",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:getNumProcessors\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:getNumProcessors\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "getNumProcessors",
          "package": "base",
          "partial": "Num Processors",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:getNumProcessors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "getUncaughtExceptionHandler",
          "package": "base",
          "signature": "IO (SomeException -\u003e IO ())",
          "source": "src/GHC-Conc-Sync.html#getUncaughtExceptionHandler",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:getUncaughtExceptionHandler\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:getUncaughtExceptionHandler\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "getUncaughtExceptionHandler",
          "normalized": "IO(SomeException-\u003eIO())",
          "package": "base",
          "partial": "Uncaught Exception Handler",
          "signature": "IO(SomeException-\u003eIO())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:getUncaughtExceptionHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003elabelThread\u003c/a\u003e\u003c/code\u003e stores a string as identifier for this thread if\nyou built a RTS with debugging support. This identifier will be used in\nthe debugging output to make distinction of different threads easier\n(otherwise you only have the thread state object's address in the heap).\n\u003c/p\u003e\u003cp\u003eOther applications like the graphical Concurrent Haskell Debugger\n(\u003ca\u003ehttp://www.informatik.uni-kiel.de/~fhu/chd/\u003c/a\u003e) may choose to overload\n\u003ccode\u003e\u003ca\u003elabelThread\u003c/a\u003e\u003c/code\u003e for their purposes as well.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "labelThread",
          "package": "base",
          "signature": "ThreadId -\u003e String -\u003e IO ()",
          "source": "src/GHC-Conc-Sync.html#labelThread",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:labelThread\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:labelThread\"]"
        },
        "index": {
          "description": "labelThread stores string as identifier for this thread if you built RTS with debugging support This identifier will be used in the debugging output to make distinction of different threads easier otherwise you only have the thread state object address in the heap Other applications like the graphical Concurrent Haskell Debugger http www.informatik.uni-kiel.de fhu chd may choose to overload labelThread for their purposes as well",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "labelThread",
          "normalized": "ThreadId-\u003eString-\u003eIO()",
          "package": "base",
          "partial": "Thread",
          "signature": "ThreadId-\u003eString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:labelThread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Conc.Sync",
          "name": "modifyMVar_",
          "package": "base",
          "signature": "MVar a -\u003e (a -\u003e IO a) -\u003e IO ()",
          "source": "src/GHC-Conc-Sync.html#modifyMVar_",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "modifyMVar_",
          "normalized": "MVar a-\u003e(a-\u003eIO a)-\u003eIO()",
          "package": "base",
          "partial": "MVar",
          "signature": "MVar a-\u003e(a-\u003eIO a)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:modifyMVar_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new TVar holding a value supplied\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "newTVar",
          "package": "base",
          "signature": "a -\u003e STM (TVar a)",
          "source": "src/GHC-Conc-Sync.html#newTVar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:newTVar\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:newTVar\"]"
        },
        "index": {
          "description": "Create new TVar holding value supplied",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "newTVar",
          "normalized": "a-\u003eSTM(TVar a)",
          "package": "base",
          "partial": "TVar",
          "signature": "a-\u003eSTM(TVar a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:newTVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eIO\u003c/code\u003e version of \u003ccode\u003e\u003ca\u003enewTVar\u003c/a\u003e\u003c/code\u003e.  This is useful for creating top-level\n \u003ccode\u003e\u003ca\u003eTVar\u003c/a\u003e\u003c/code\u003es using \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e, because using\n \u003ccode\u003e\u003ca\u003eatomically\u003c/a\u003e\u003c/code\u003e inside \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e isn't\n possible.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "newTVarIO",
          "package": "base",
          "signature": "a -\u003e IO (TVar a)",
          "source": "src/GHC-Conc-Sync.html#newTVarIO",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:newTVarIO\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:newTVarIO\"]"
        },
        "index": {
          "description": "IO version of newTVar This is useful for creating top-level TVar using unsafePerformIO because using atomically inside unsafePerformIO isn possible",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "newTVarIO",
          "normalized": "a-\u003eIO(TVar a)",
          "package": "base",
          "partial": "TVar IO",
          "signature": "a-\u003eIO(TVar a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:newTVarIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe value passed to the \u003ccode\u003e+RTS -N\u003c/code\u003e flag.  This is the number of\n Haskell threads that can run truly simultaneously at any given\n time, and is typically set to the number of physical processor cores on\n the machine.\n\u003c/p\u003e\u003cp\u003eStrictly speaking it is better to use \u003ccode\u003e\u003ca\u003egetNumCapabilities\u003c/a\u003e\u003c/code\u003e, because\n the number of capabilities might vary at runtime.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "numCapabilities",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Conc-Sync.html#numCapabilities",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:numCapabilities\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:numCapabilities\"]"
        },
        "index": {
          "description": "the value passed to the RTS flag This is the number of Haskell threads that can run truly simultaneously at any given time and is typically set to the number of physical processor cores on the machine Strictly speaking it is better to use getNumCapabilities because the number of capabilities might vary at runtime",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "numCapabilities",
          "package": "base",
          "partial": "Capabilities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:numCapabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the number of sparks currently in the local spark pool\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "numSparks",
          "package": "base",
          "signature": "IO Int",
          "source": "src/GHC-Conc-Sync.html#numSparks",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:numSparks\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:numSparks\"]"
        },
        "index": {
          "description": "Returns the number of sparks currently in the local spark pool",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "numSparks",
          "package": "base",
          "partial": "Sparks",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:numSparks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose two alternative STM actions (GHC only).  If the first action\n completes without retrying then it forms the result of the orElse.\n Otherwise, if the first action retries, then the second action is\n tried in its place.  If both actions retry then the orElse as a\n whole retries.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "orElse",
          "package": "base",
          "signature": "STM a -\u003e STM a -\u003e STM a",
          "source": "src/GHC-Conc-Sync.html#orElse",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:orElse\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:orElse\"]"
        },
        "index": {
          "description": "Compose two alternative STM actions GHC only If the first action completes without retrying then it forms the result of the orElse Otherwise if the first action retries then the second action is tried in its place If both actions retry then the orElse as whole retries",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "orElse",
          "normalized": "STM a-\u003eSTM a-\u003eSTM a",
          "package": "base",
          "partial": "Else",
          "signature": "STM a-\u003eSTM a-\u003eSTM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:orElse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "par",
          "package": "base",
          "signature": "a -\u003e b -\u003e b",
          "source": "src/GHC-Conc-Sync.html#par",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:par\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:par\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "par",
          "normalized": "a-\u003eb-\u003eb",
          "package": "base",
          "signature": "a-\u003eb-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:par"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "pseq",
          "package": "base",
          "signature": "a -\u003e b -\u003e b",
          "source": "src/GHC-Conc-Sync.html#pseq",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:pseq\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:pseq\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "pseq",
          "normalized": "a-\u003eb-\u003eb",
          "package": "base",
          "signature": "a-\u003eb-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:pseq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the current value stored in a TVar\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "readTVar",
          "package": "base",
          "signature": "TVar a -\u003e STM a",
          "source": "src/GHC-Conc-Sync.html#readTVar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:readTVar\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:readTVar\"]"
        },
        "index": {
          "description": "Return the current value stored in TVar",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "readTVar",
          "normalized": "TVar a-\u003eSTM a",
          "package": "base",
          "partial": "TVar",
          "signature": "TVar a-\u003eSTM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:readTVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the current value stored in a TVar.\n This is equivalent to\n\u003c/p\u003e\u003cpre\u003e  readTVarIO = atomically . readTVar\n\u003c/pre\u003e\u003cp\u003ebut works much faster, because it doesn't perform a complete\n transaction, it just reads the current value of the \u003ccode\u003e\u003ca\u003eTVar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "readTVarIO",
          "package": "base",
          "signature": "TVar a -\u003e IO a",
          "source": "src/GHC-Conc-Sync.html#readTVarIO",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:readTVarIO\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:readTVarIO\"]"
        },
        "index": {
          "description": "Return the current value stored in TVar This is equivalent to readTVarIO atomically readTVar but works much faster because it doesn perform complete transaction it just reads the current value of the TVar",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "readTVarIO",
          "normalized": "TVar a-\u003eIO a",
          "package": "base",
          "partial": "TVar IO",
          "signature": "TVar a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:readTVarIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "reportError",
          "package": "base",
          "signature": "SomeException -\u003e IO ()",
          "source": "src/GHC-Conc-Sync.html#reportError",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:reportError\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:reportError\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "reportError",
          "normalized": "SomeException-\u003eIO()",
          "package": "base",
          "partial": "Error",
          "signature": "SomeException-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:reportError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "reportStackOverflow",
          "package": "base",
          "signature": "IO ()",
          "source": "src/GHC-Conc-Sync.html#reportStackOverflow",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:reportStackOverflow\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:reportStackOverflow\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "reportStackOverflow",
          "normalized": "IO()",
          "package": "base",
          "partial": "Stack Overflow",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:reportStackOverflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetry execution of the current memory transaction because it has seen\n values in TVars which mean that it should not continue (e.g. the TVars\n represent a shared buffer that is now empty).  The implementation may\n block the thread until one of the TVars that it has read from has been\n udpated. (GHC only)\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "retry",
          "package": "base",
          "signature": "STM a",
          "source": "src/GHC-Conc-Sync.html#retry",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:retry\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:retry\"]"
        },
        "index": {
          "description": "Retry execution of the current memory transaction because it has seen values in TVars which mean that it should not continue e.g the TVars represent shared buffer that is now empty The implementation may block the thread until one of the TVars that it has read from has been udpated GHC only",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "retry",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:retry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal function used by the RTS to run sparks.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "runSparks",
          "package": "base",
          "signature": "IO ()",
          "source": "src/GHC-Conc-Sync.html#runSparks",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:runSparks\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:runSparks\"]"
        },
        "index": {
          "description": "Internal function used by the RTS to run sparks",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "runSparks",
          "normalized": "IO()",
          "package": "base",
          "partial": "Sparks",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:runSparks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "setUncaughtExceptionHandler",
          "package": "base",
          "signature": "(SomeException -\u003e IO ()) -\u003e IO ()",
          "source": "src/GHC-Conc-Sync.html#setUncaughtExceptionHandler",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:setUncaughtExceptionHandler\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:setUncaughtExceptionHandler\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "setUncaughtExceptionHandler",
          "normalized": "(SomeException-\u003eIO())-\u003eIO()",
          "package": "base",
          "partial": "Uncaught Exception Handler",
          "signature": "(SomeException-\u003eIO())-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:setUncaughtExceptionHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Conc.Sync",
          "name": "sharedCAF",
          "package": "base",
          "signature": "a -\u003e (Ptr a -\u003e IO (Ptr a)) -\u003e IO a",
          "source": "src/GHC-Conc-Sync.html#sharedCAF",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "sharedCAF",
          "normalized": "a-\u003e(Ptr a-\u003eIO(Ptr a))-\u003eIO a",
          "package": "base",
          "partial": "CAF",
          "signature": "a-\u003e(Ptr a-\u003eIO(Ptr a))-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:sharedCAF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "threadStatus",
          "package": "base",
          "signature": "ThreadId -\u003e IO ThreadStatus",
          "source": "src/GHC-Conc-Sync.html#threadStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:threadStatus\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:threadStatus\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "threadStatus",
          "normalized": "ThreadId-\u003eIO ThreadStatus",
          "package": "base",
          "partial": "Status",
          "signature": "ThreadId-\u003eIO ThreadStatus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:threadStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003ethrow\u003c/a\u003e\u003c/code\u003e that can only be used within the \u003ccode\u003e\u003ca\u003eSTM\u003c/a\u003e\u003c/code\u003e monad.\n\u003c/p\u003e\u003cp\u003eThrowing an exception in \u003ccode\u003eSTM\u003c/code\u003e aborts the transaction and propagates the\n exception.\n\u003c/p\u003e\u003cp\u003eAlthough \u003ccode\u003e\u003ca\u003ethrowSTM\u003c/a\u003e\u003c/code\u003e has a type that is an instance of the type of \u003ccode\u003e\u003ca\u003ethrow\u003c/a\u003e\u003c/code\u003e, the\n two functions are subtly different:\n\u003c/p\u003e\u003cpre\u003e throw e    `seq` x  ===\u003e throw e\n throwSTM e `seq` x  ===\u003e x\n\u003c/pre\u003e\u003cp\u003eThe first example will cause the exception \u003ccode\u003ee\u003c/code\u003e to be raised,\n whereas the second one won't.  In fact, \u003ccode\u003e\u003ca\u003ethrowSTM\u003c/a\u003e\u003c/code\u003e will only cause\n an exception to be raised when it is used within the \u003ccode\u003e\u003ca\u003eSTM\u003c/a\u003e\u003c/code\u003e monad.\n The \u003ccode\u003e\u003ca\u003ethrowSTM\u003c/a\u003e\u003c/code\u003e variant should be used in preference to \u003ccode\u003e\u003ca\u003ethrow\u003c/a\u003e\u003c/code\u003e to\n raise an exception within the \u003ccode\u003e\u003ca\u003eSTM\u003c/a\u003e\u003c/code\u003e monad because it guarantees\n ordering with respect to other \u003ccode\u003e\u003ca\u003eSTM\u003c/a\u003e\u003c/code\u003e operations, whereas \u003ccode\u003e\u003ca\u003ethrow\u003c/a\u003e\u003c/code\u003e\n does not.\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "throwSTM",
          "package": "base",
          "signature": "e -\u003e STM a",
          "source": "src/GHC-Conc-Sync.html#throwSTM",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:throwSTM\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:throwSTM\"]"
        },
        "index": {
          "description": "variant of throw that can only be used within the STM monad Throwing an exception in STM aborts the transaction and propagates the exception Although throwSTM has type that is an instance of the type of throw the two functions are subtly different throw seq throw throwSTM seq The first example will cause the exception to be raised whereas the second one won In fact throwSTM will only cause an exception to be raised when it is used within the STM monad The throwSTM variant should be used in preference to throw to raise an exception within the STM monad because it guarantees ordering with respect to other STM operations whereas throw does not",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "throwSTM",
          "normalized": "a-\u003eSTM b",
          "package": "base",
          "partial": "STM",
          "signature": "e-\u003eSTM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:throwSTM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnsafely performs IO in the STM monad.  Beware: this is a highly\n dangerous thing to do.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The STM implementation will often run transactions multiple\n     times, so you need to be prepared for this if your IO has any\n     side effects.\n\u003c/li\u003e\u003cli\u003e The STM implementation will abort transactions that are known to\n     be invalid and need to be restarted.  This may happen in the middle\n     of \u003ccode\u003e\u003ca\u003eunsafeIOToSTM\u003c/a\u003e\u003c/code\u003e, so make sure you don't acquire any resources\n     that need releasing (exception handlers are ignored when aborting\n     the transaction).  That includes doing any IO using Handles, for\n     example.  Getting this wrong will probably lead to random deadlocks.\n\u003c/li\u003e\u003cli\u003e The transaction may have seen an inconsistent view of memory when\n     the IO runs.  Invariants that you expect to be true throughout\n     your program may not be true inside a transaction, due to the\n     way transactions are implemented.  Normally this wouldn't be visible\n     to the programmer, but using \u003ccode\u003e\u003ca\u003eunsafeIOToSTM\u003c/a\u003e\u003c/code\u003e can expose it.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "unsafeIOToSTM",
          "package": "base",
          "signature": "IO a -\u003e STM a",
          "source": "src/GHC-Conc-Sync.html#unsafeIOToSTM",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:unsafeIOToSTM\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:unsafeIOToSTM\"]"
        },
        "index": {
          "description": "Unsafely performs IO in the STM monad Beware this is highly dangerous thing to do The STM implementation will often run transactions multiple times so you need to be prepared for this if your IO has any side effects The STM implementation will abort transactions that are known to be invalid and need to be restarted This may happen in the middle of unsafeIOToSTM so make sure you don acquire any resources that need releasing exception handlers are ignored when aborting the transaction That includes doing any IO using Handles for example Getting this wrong will probably lead to random deadlocks The transaction may have seen an inconsistent view of memory when the IO runs Invariants that you expect to be true throughout your program may not be true inside transaction due to the way transactions are implemented Normally this wouldn be visible to the programmer but using unsafeIOToSTM can expose it",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "unsafeIOToSTM",
          "normalized": "IO a-\u003eSTM a",
          "package": "base",
          "partial": "IOTo STM",
          "signature": "IO a-\u003eSTM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:unsafeIOToSTM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "withMVar",
          "package": "base",
          "signature": "MVar a -\u003e (a -\u003e IO b) -\u003e IO b",
          "source": "src/GHC-Conc-Sync.html#withMVar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:withMVar\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:withMVar\"]"
        },
        "index": {
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "withMVar",
          "normalized": "MVar a-\u003e(a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "partial": "MVar",
          "signature": "MVar a-\u003e(a-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:withMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite the supplied value into a TVar\n\u003c/p\u003e",
          "module": "[\"GHC.Conc.Sync\",\"GHC.Conc\"]",
          "name": "writeTVar",
          "package": "base",
          "signature": "TVar a -\u003e a -\u003e STM ()",
          "source": "src/GHC-Conc-Sync.html#writeTVar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:writeTVar\",\"http://hackage.haskell.org/package/base/docs/GHC-Conc.html#v:writeTVar\"]"
        },
        "index": {
          "description": "Write the supplied value into TVar",
          "hierarchy": "GHC Conc Sync",
          "module": "GHC.Conc.Sync",
          "name": "writeTVar",
          "normalized": "TVar a-\u003ea-\u003eSTM()",
          "package": "base",
          "partial": "TVar",
          "signature": "TVar a-\u003ea-\u003eSTM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc-Sync.html#v:writeTVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic concurrency stuff.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.Conc",
          "name": "Conc",
          "package": "base",
          "source": "src/GHC-Conc.html",
          "type": "module"
        },
        "index": {
          "description": "Basic concurrency stuff",
          "hierarchy": "GHC Conc",
          "module": "GHC.Conc",
          "name": "Conc",
          "package": "base",
          "partial": "Conc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Conc",
          "name": "BlockReason",
          "package": "base",
          "source": "src/GHC-Conc-Sync.html#BlockReason",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC Conc",
          "module": "GHC.Conc",
          "name": "BlockReason",
          "package": "base",
          "partial": "Block Reason",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc.html#t:BlockReason"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Conc",
          "name": "HandlerFun",
          "package": "base",
          "source": "src/GHC-Conc-Signal.html#HandlerFun",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC Conc",
          "module": "GHC.Conc",
          "name": "HandlerFun",
          "package": "base",
          "partial": "Handler Fun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc.html#t:HandlerFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA monad supporting atomic memory transactions.\n\u003c/p\u003e",
          "module": "GHC.Conc",
          "name": "STM",
          "package": "base",
          "source": "src/GHC-Conc-Sync.html#STM",
          "type": "newtype"
        },
        "index": {
          "description": "monad supporting atomic memory transactions",
          "hierarchy": "GHC Conc",
          "module": "GHC.Conc",
          "name": "STM",
          "package": "base",
          "partial": "STM",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc.html#t:STM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Conc",
          "name": "Signal",
          "package": "base",
          "source": "src/GHC-Conc-Signal.html#Signal",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC Conc",
          "module": "GHC.Conc",
          "name": "Signal",
          "package": "base",
          "partial": "Signal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc.html#t:Signal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShared memory locations that support atomic memory transactions.\n\u003c/p\u003e",
          "module": "GHC.Conc",
          "name": "TVar",
          "package": "base",
          "source": "src/GHC-Conc-Sync.html#TVar",
          "type": "data"
        },
        "index": {
          "description": "Shared memory locations that support atomic memory transactions",
          "hierarchy": "GHC Conc",
          "module": "GHC.Conc",
          "name": "TVar",
          "package": "base",
          "partial": "TVar",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc.html#t:TVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e is an abstract type representing a handle to a thread.\n\u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e is an instance of \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e, where\nthe \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e instance implements an arbitrary total ordering over\n\u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003es. The \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instance lets you convert an arbitrary-valued\n\u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e to string form; showing a \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e value is occasionally\nuseful when debugging or diagnosing the behaviour of a concurrent\nprogram.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote\u003c/em\u003e: in GHC, if you have a \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e, you essentially have\na pointer to the thread itself.  This means the thread itself can't be\ngarbage collected until you drop the \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e.\nThis misfeature will hopefully be corrected at a later date.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote\u003c/em\u003e: Hugs does not provide any operations on other threads;\nit defines \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e as a synonym for ().\n\u003c/p\u003e",
          "module": "GHC.Conc",
          "name": "ThreadId",
          "package": "base",
          "source": "src/GHC-Conc-Sync.html#ThreadId",
          "type": "data"
        },
        "index": {
          "description": "ThreadId is an abstract type representing handle to thread ThreadId is an instance of Eq Ord and Show where the Ord instance implements an arbitrary total ordering over ThreadId The Show instance lets you convert an arbitrary-valued ThreadId to string form showing ThreadId value is occasionally useful when debugging or diagnosing the behaviour of concurrent program Note in GHC if you have ThreadId you essentially have pointer to the thread itself This means the thread itself can be garbage collected until you drop the ThreadId This misfeature will hopefully be corrected at later date Note Hugs does not provide any operations on other threads it defines ThreadId as synonym for",
          "hierarchy": "GHC Conc",
          "module": "GHC.Conc",
          "name": "ThreadId",
          "package": "base",
          "partial": "Thread Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc.html#t:ThreadId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current status of a thread\n\u003c/p\u003e",
          "module": "GHC.Conc",
          "name": "ThreadStatus",
          "package": "base",
          "source": "src/GHC-Conc-Sync.html#ThreadStatus",
          "type": "data"
        },
        "index": {
          "description": "The current status of thread",
          "hierarchy": "GHC Conc",
          "module": "GHC.Conc",
          "name": "ThreadStatus",
          "package": "base",
          "partial": "Thread Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Conc.html#t:ThreadStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNB. the contents of this module are only available on Windows.\n\u003c/p\u003e\u003cp\u003eInstalling Win32 console handlers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.ConsoleHandler",
          "name": "ConsoleHandler",
          "package": "base",
          "source": "src/GHC-ConsoleHandler.html",
          "type": "module"
        },
        "index": {
          "description": "NB the contents of this module are only available on Windows Installing Win32 console handlers",
          "hierarchy": "GHC ConsoleHandler",
          "module": "GHC.ConsoleHandler",
          "name": "ConsoleHandler",
          "package": "base",
          "partial": "Console Handler",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-ConsoleHandler.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "Constants",
          "package": "base",
          "source": "src/GHC-Constants.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "Constants",
          "package": "base",
          "partial": "Constants",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "TargetInt",
          "package": "base",
          "source": "src/GHC-Constants.html#TargetInt",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "TargetInt",
          "package": "base",
          "partial": "Target Int",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#t:TargetInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "TargetWord",
          "package": "base",
          "source": "src/GHC-Constants.html#TargetWord",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "TargetWord",
          "package": "base",
          "partial": "Target Word",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#t:TargetWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "aP_STACK_SPLIM",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#aP_STACK_SPLIM",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "aP_STACK_SPLIM",
          "package": "base",
          "partial": "STACK SPLIM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:aP_STACK_SPLIM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "bITMAP_BITS_SHIFT",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#bITMAP_BITS_SHIFT",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "bITMAP_BITS_SHIFT",
          "package": "base",
          "partial": "ITMAP BITS SHIFT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:bITMAP_BITS_SHIFT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "bLOCKS_PER_MBLOCK",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#bLOCKS_PER_MBLOCK",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "bLOCKS_PER_MBLOCK",
          "package": "base",
          "partial": "LOCKS PER MBLOCK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:bLOCKS_PER_MBLOCK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "bLOCK_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#bLOCK_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "bLOCK_SIZE",
          "package": "base",
          "partial": "LOCK SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:bLOCK_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "bLOCK_SIZE_W",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#bLOCK_SIZE_W",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "bLOCK_SIZE_W",
          "package": "base",
          "partial": "LOCK SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:bLOCK_SIZE_W"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "cINT_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#cINT_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "cINT_SIZE",
          "package": "base",
          "partial": "INT SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:cINT_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "cLONG_LONG_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#cLONG_LONG_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "cLONG_LONG_SIZE",
          "package": "base",
          "partial": "LONG LONG SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:cLONG_LONG_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "cLONG_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#cLONG_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "cLONG_SIZE",
          "package": "base",
          "partial": "LONG SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:cLONG_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "dOUBLE_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#dOUBLE_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "dOUBLE_SIZE",
          "package": "base",
          "partial": "OUBLE SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:dOUBLE_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "iNT64_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#iNT64_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "iNT64_SIZE",
          "package": "base",
          "partial": "NT SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:iNT64_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_CHARLIKE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_CHARLIKE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_CHARLIKE",
          "package": "base",
          "partial": "AX CHARLIKE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_CHARLIKE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_CONTEXT_REDUCTION_DEPTH",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_CONTEXT_REDUCTION_DEPTH",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_CONTEXT_REDUCTION_DEPTH",
          "package": "base",
          "partial": "AX CONTEXT REDUCTION DEPTH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_CONTEXT_REDUCTION_DEPTH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_Double_REG",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_Double_REG",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_Double_REG",
          "package": "base",
          "partial": "AX Double REG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_Double_REG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_Float_REG",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_Float_REG",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_Float_REG",
          "package": "base",
          "partial": "AX Float REG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_Float_REG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_INTLIKE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_INTLIKE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_INTLIKE",
          "package": "base",
          "partial": "AX INTLIKE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_INTLIKE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_Long_REG",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_Long_REG",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_Long_REG",
          "package": "base",
          "partial": "AX Long REG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_Long_REG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_PTR_TAG",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_PTR_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_PTR_TAG",
          "package": "base",
          "partial": "AX PTR TAG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_PTR_TAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_Real_Double_REG",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_Real_Double_REG",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_Real_Double_REG",
          "package": "base",
          "partial": "AX Real Double REG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_Real_Double_REG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_Real_Float_REG",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_Real_Float_REG",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_Real_Float_REG",
          "package": "base",
          "partial": "AX Real Float REG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_Real_Float_REG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_Real_Long_REG",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_Real_Long_REG",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_Real_Long_REG",
          "package": "base",
          "partial": "AX Real Long REG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_Real_Long_REG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_Real_Vanilla_REG",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_Real_Vanilla_REG",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_Real_Vanilla_REG",
          "package": "base",
          "partial": "AX Real Vanilla REG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_Real_Vanilla_REG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_SPEC_AP_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_SPEC_AP_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_SPEC_AP_SIZE",
          "package": "base",
          "partial": "AX SPEC AP SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_SPEC_AP_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_SPEC_CONSTR_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_SPEC_CONSTR_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_SPEC_CONSTR_SIZE",
          "package": "base",
          "partial": "AX SPEC CONSTR SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_SPEC_CONSTR_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_SPEC_FUN_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_SPEC_FUN_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_SPEC_FUN_SIZE",
          "package": "base",
          "partial": "AX SPEC FUN SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_SPEC_FUN_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_SPEC_SELECTEE_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_SPEC_SELECTEE_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_SPEC_SELECTEE_SIZE",
          "package": "base",
          "partial": "AX SPEC SELECTEE SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_SPEC_SELECTEE_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_SPEC_THUNK_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_SPEC_THUNK_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_SPEC_THUNK_SIZE",
          "package": "base",
          "partial": "AX SPEC THUNK SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_SPEC_THUNK_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_TUPLE_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_TUPLE_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_TUPLE_SIZE",
          "package": "base",
          "partial": "AX TUPLE SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_TUPLE_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mAX_Vanilla_REG",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mAX_Vanilla_REG",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mAX_Vanilla_REG",
          "package": "base",
          "partial": "AX Vanilla REG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mAX_Vanilla_REG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mIN_CHARLIKE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mIN_CHARLIKE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mIN_CHARLIKE",
          "package": "base",
          "partial": "IN CHARLIKE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mIN_CHARLIKE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mIN_INTLIKE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mIN_INTLIKE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mIN_INTLIKE",
          "package": "base",
          "partial": "IN INTLIKE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mIN_INTLIKE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mIN_PAYLOAD_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mIN_PAYLOAD_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mIN_PAYLOAD_SIZE",
          "package": "base",
          "partial": "IN PAYLOAD SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mIN_PAYLOAD_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "mUT_ARR_PTRS_CARD_BITS",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#mUT_ARR_PTRS_CARD_BITS",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "mUT_ARR_PTRS_CARD_BITS",
          "package": "base",
          "partial": "UT ARR PTRS CARD BITS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:mUT_ARR_PTRS_CARD_BITS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_Capability_context_switch",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_Capability_context_switch",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_Capability_context_switch",
          "package": "base",
          "partial": "FFSET Capability",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_Capability_context_switch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_Capability_interrupt",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_Capability_interrupt",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_Capability_interrupt",
          "package": "base",
          "partial": "FFSET Capability",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_Capability_interrupt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_Capability_lock",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_Capability_lock",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_Capability_lock",
          "package": "base",
          "partial": "FFSET Capability",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_Capability_lock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_Capability_mut_lists",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_Capability_mut_lists",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_Capability_mut_lists",
          "package": "base",
          "partial": "FFSET Capability",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_Capability_mut_lists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_Capability_no",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_Capability_no",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_Capability_no",
          "package": "base",
          "partial": "FFSET Capability",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_Capability_no"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_Capability_r",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_Capability_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_Capability_r",
          "package": "base",
          "partial": "FFSET Capability",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_Capability_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_Capability_sparks",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_Capability_sparks",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_Capability_sparks",
          "package": "base",
          "partial": "FFSET Capability",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_Capability_sparks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_CostCentreStack_ccsID",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_CostCentreStack_ccsID",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_CostCentreStack_ccsID",
          "package": "base",
          "partial": "FFSET Cost Centre Stack ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_CostCentreStack_ccsID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_CostCentreStack_mem_alloc",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_CostCentreStack_mem_alloc",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_CostCentreStack_mem_alloc",
          "package": "base",
          "partial": "FFSET Cost Centre Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_CostCentreStack_mem_alloc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_CostCentreStack_prevStack",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_CostCentreStack_prevStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_CostCentreStack_prevStack",
          "package": "base",
          "partial": "FFSET Cost Centre Stack Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_CostCentreStack_prevStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_CostCentreStack_scc_count",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_CostCentreStack_scc_count",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_CostCentreStack_scc_count",
          "package": "base",
          "partial": "FFSET Cost Centre Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_CostCentreStack_scc_count"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_CostCentre_ccID",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_CostCentre_ccID",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_CostCentre_ccID",
          "package": "base",
          "partial": "FFSET Cost Centre ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_CostCentre_ccID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_CostCentre_link",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_CostCentre_link",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_CostCentre_link",
          "package": "base",
          "partial": "FFSET Cost Centre",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_CostCentre_link"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_MessageBlackHole_bh",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_MessageBlackHole_bh",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_MessageBlackHole_bh",
          "package": "base",
          "partial": "FFSET Message Black Hole",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_MessageBlackHole_bh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_MessageBlackHole_link",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_MessageBlackHole_link",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_MessageBlackHole_link",
          "package": "base",
          "partial": "FFSET Message Black Hole",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_MessageBlackHole_link"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_MessageBlackHole_tso",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_MessageBlackHole_tso",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_MessageBlackHole_tso",
          "package": "base",
          "partial": "FFSET Message Black Hole",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_MessageBlackHole_tso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_RtsFlags_DebugFlags_apply",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_RtsFlags_DebugFlags_apply",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_RtsFlags_DebugFlags_apply",
          "package": "base",
          "partial": "FFSET Rts Flags Debug Flags",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_RtsFlags_DebugFlags_apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_RtsFlags_DebugFlags_sanity",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_RtsFlags_DebugFlags_sanity",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_RtsFlags_DebugFlags_sanity",
          "package": "base",
          "partial": "FFSET Rts Flags Debug Flags",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_RtsFlags_DebugFlags_sanity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_RtsFlags_DebugFlags_weak",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_RtsFlags_DebugFlags_weak",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_RtsFlags_DebugFlags_weak",
          "package": "base",
          "partial": "FFSET Rts Flags Debug Flags",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_RtsFlags_DebugFlags_weak"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_RtsFlags_GcFlags_initialStkSize",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_RtsFlags_GcFlags_initialStkSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_RtsFlags_GcFlags_initialStkSize",
          "package": "base",
          "partial": "FFSET Rts Flags Gc Flags Stk Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_RtsFlags_GcFlags_initialStkSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_RtsFlags_MiscFlags_tickInterval",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_RtsFlags_MiscFlags_tickInterval",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_RtsFlags_MiscFlags_tickInterval",
          "package": "base",
          "partial": "FFSET Rts Flags Misc Flags Interval",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_RtsFlags_MiscFlags_tickInterval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_RtsFlags_ProfFlags_showCCSOnException",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_RtsFlags_ProfFlags_showCCSOnException",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_RtsFlags_ProfFlags_showCCSOnException",
          "package": "base",
          "partial": "FFSET Rts Flags Prof Flags CCSOn Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_RtsFlags_ProfFlags_showCCSOnException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgAP_STACK_fun",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgAP_STACK_fun",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgAP_STACK_fun",
          "package": "base",
          "partial": "FFSET Stg AP STACK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgAP_STACK_fun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgAP_STACK_payload",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgAP_STACK_payload",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgAP_STACK_payload",
          "package": "base",
          "partial": "FFSET Stg AP STACK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgAP_STACK_payload"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgAP_STACK_size",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgAP_STACK_size",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgAP_STACK_size",
          "package": "base",
          "partial": "FFSET Stg AP STACK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgAP_STACK_size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgAP_fun",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgAP_fun",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgAP_fun",
          "package": "base",
          "partial": "FFSET Stg AP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgAP_fun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgAP_n_args",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgAP_n_args",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgAP_n_args",
          "package": "base",
          "partial": "FFSET Stg AP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgAP_n_args"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgAP_payload",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgAP_payload",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgAP_payload",
          "package": "base",
          "partial": "FFSET Stg AP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgAP_payload"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgArrWords_bytes",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgArrWords_bytes",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgArrWords_bytes",
          "package": "base",
          "partial": "FFSET Stg Arr Words",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgArrWords_bytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgArrWords_payload",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgArrWords_payload",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgArrWords_payload",
          "package": "base",
          "partial": "FFSET Stg Arr Words",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgArrWords_payload"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgAtomicInvariant_code",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgAtomicInvariant_code",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgAtomicInvariant_code",
          "package": "base",
          "partial": "FFSET Stg Atomic Invariant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgAtomicInvariant_code"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgAtomicallyFrame_code",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgAtomicallyFrame_code",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgAtomicallyFrame_code",
          "package": "base",
          "partial": "FFSET Stg Atomically Frame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgAtomicallyFrame_code"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgAtomicallyFrame_next_invariant_to_check",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgAtomicallyFrame_next_invariant_to_check",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgAtomicallyFrame_next_invariant_to_check",
          "package": "base",
          "partial": "FFSET Stg Atomically Frame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgAtomicallyFrame_next_invariant_to_check"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgAtomicallyFrame_result",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgAtomicallyFrame_result",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgAtomicallyFrame_result",
          "package": "base",
          "partial": "FFSET Stg Atomically Frame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgAtomicallyFrame_result"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgBCO_arity",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgBCO_arity",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgBCO_arity",
          "package": "base",
          "partial": "FFSET Stg BCO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgBCO_arity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgBCO_bitmap",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgBCO_bitmap",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgBCO_bitmap",
          "package": "base",
          "partial": "FFSET Stg BCO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgBCO_bitmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgBCO_instrs",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgBCO_instrs",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgBCO_instrs",
          "package": "base",
          "partial": "FFSET Stg BCO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgBCO_instrs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgBCO_literals",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgBCO_literals",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgBCO_literals",
          "package": "base",
          "partial": "FFSET Stg BCO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgBCO_literals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgBCO_ptrs",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgBCO_ptrs",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgBCO_ptrs",
          "package": "base",
          "partial": "FFSET Stg BCO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgBCO_ptrs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgBCO_size",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgBCO_size",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgBCO_size",
          "package": "base",
          "partial": "FFSET Stg BCO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgBCO_size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgBlockingQueue_bh",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgBlockingQueue_bh",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgBlockingQueue_bh",
          "package": "base",
          "partial": "FFSET Stg Blocking Queue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgBlockingQueue_bh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgBlockingQueue_link",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgBlockingQueue_link",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgBlockingQueue_link",
          "package": "base",
          "partial": "FFSET Stg Blocking Queue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgBlockingQueue_link"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgBlockingQueue_owner",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgBlockingQueue_owner",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgBlockingQueue_owner",
          "package": "base",
          "partial": "FFSET Stg Blocking Queue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgBlockingQueue_owner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgBlockingQueue_queue",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgBlockingQueue_queue",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgBlockingQueue_queue",
          "package": "base",
          "partial": "FFSET Stg Blocking Queue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgBlockingQueue_queue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgCatchFrame_exceptions_blocked",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgCatchFrame_exceptions_blocked",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgCatchFrame_exceptions_blocked",
          "package": "base",
          "partial": "FFSET Stg Catch Frame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgCatchFrame_exceptions_blocked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgCatchFrame_handler",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgCatchFrame_handler",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgCatchFrame_handler",
          "package": "base",
          "partial": "FFSET Stg Catch Frame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgCatchFrame_handler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgCatchRetryFrame_alt_code",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgCatchRetryFrame_alt_code",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgCatchRetryFrame_alt_code",
          "package": "base",
          "partial": "FFSET Stg Catch Retry Frame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgCatchRetryFrame_alt_code"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgCatchRetryFrame_first_code",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgCatchRetryFrame_first_code",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgCatchRetryFrame_first_code",
          "package": "base",
          "partial": "FFSET Stg Catch Retry Frame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgCatchRetryFrame_first_code"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgCatchRetryFrame_running_alt_code",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgCatchRetryFrame_running_alt_code",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgCatchRetryFrame_running_alt_code",
          "package": "base",
          "partial": "FFSET Stg Catch Retry Frame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgCatchRetryFrame_running_alt_code"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgCatchSTMFrame_code",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgCatchSTMFrame_code",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgCatchSTMFrame_code",
          "package": "base",
          "partial": "FFSET Stg Catch STMFrame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgCatchSTMFrame_code"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgCatchSTMFrame_handler",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgCatchSTMFrame_handler",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgCatchSTMFrame_handler",
          "package": "base",
          "partial": "FFSET Stg Catch STMFrame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgCatchSTMFrame_handler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgClosure_payload",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgClosure_payload",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgClosure_payload",
          "package": "base",
          "partial": "FFSET Stg Closure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgClosure_payload"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgDeadWeak_link",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgDeadWeak_link",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgDeadWeak_link",
          "package": "base",
          "partial": "FFSET Stg Dead Weak",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgDeadWeak_link"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgEntCounter_allocs",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgEntCounter_allocs",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgEntCounter_allocs",
          "package": "base",
          "partial": "FFSET Stg Ent Counter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgEntCounter_allocs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgEntCounter_entry_count",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgEntCounter_entry_count",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgEntCounter_entry_count",
          "package": "base",
          "partial": "FFSET Stg Ent Counter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgEntCounter_entry_count"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgEntCounter_link",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgEntCounter_link",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgEntCounter_link",
          "package": "base",
          "partial": "FFSET Stg Ent Counter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgEntCounter_link"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgEntCounter_registeredp",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgEntCounter_registeredp",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgEntCounter_registeredp",
          "package": "base",
          "partial": "FFSET Stg Ent Counter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgEntCounter_registeredp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraFwd_arity",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgFunInfoExtraFwd_arity",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraFwd_arity",
          "package": "base",
          "partial": "FFSET Stg Fun Info Extra Fwd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgFunInfoExtraFwd_arity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraFwd_bitmap",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgFunInfoExtraFwd_bitmap",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraFwd_bitmap",
          "package": "base",
          "partial": "FFSET Stg Fun Info Extra Fwd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgFunInfoExtraFwd_bitmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraFwd_fun_type",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgFunInfoExtraFwd_fun_type",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraFwd_fun_type",
          "package": "base",
          "partial": "FFSET Stg Fun Info Extra Fwd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgFunInfoExtraFwd_fun_type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraFwd_slow_apply",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgFunInfoExtraFwd_slow_apply",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraFwd_slow_apply",
          "package": "base",
          "partial": "FFSET Stg Fun Info Extra Fwd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgFunInfoExtraFwd_slow_apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraRev_arity",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgFunInfoExtraRev_arity",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraRev_arity",
          "package": "base",
          "partial": "FFSET Stg Fun Info Extra Rev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgFunInfoExtraRev_arity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraRev_bitmap",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgFunInfoExtraRev_bitmap",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraRev_bitmap",
          "package": "base",
          "partial": "FFSET Stg Fun Info Extra Rev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgFunInfoExtraRev_bitmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraRev_fun_type",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgFunInfoExtraRev_fun_type",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraRev_fun_type",
          "package": "base",
          "partial": "FFSET Stg Fun Info Extra Rev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgFunInfoExtraRev_fun_type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraRev_slow_apply_offset",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgFunInfoExtraRev_slow_apply_offset",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgFunInfoExtraRev_slow_apply_offset",
          "package": "base",
          "partial": "FFSET Stg Fun Info Extra Rev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgFunInfoExtraRev_slow_apply_offset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgHeader_ccs",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgHeader_ccs",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgHeader_ccs",
          "package": "base",
          "partial": "FFSET Stg Header",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgHeader_ccs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgHeader_info",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgHeader_info",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgHeader_info",
          "package": "base",
          "partial": "FFSET Stg Header",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgHeader_info"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgHeader_ldvw",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgHeader_ldvw",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgHeader_ldvw",
          "package": "base",
          "partial": "FFSET Stg Header",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgHeader_ldvw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgInd_indirectee",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgInd_indirectee",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgInd_indirectee",
          "package": "base",
          "partial": "FFSET Stg Ind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgInd_indirectee"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgInvariantCheckQueue_invariant",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgInvariantCheckQueue_invariant",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgInvariantCheckQueue_invariant",
          "package": "base",
          "partial": "FFSET Stg Invariant Check Queue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgInvariantCheckQueue_invariant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgInvariantCheckQueue_my_execution",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgInvariantCheckQueue_my_execution",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgInvariantCheckQueue_my_execution",
          "package": "base",
          "partial": "FFSET Stg Invariant Check Queue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgInvariantCheckQueue_my_execution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgInvariantCheckQueue_next_queue_entry",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgInvariantCheckQueue_next_queue_entry",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgInvariantCheckQueue_next_queue_entry",
          "package": "base",
          "partial": "FFSET Stg Invariant Check Queue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgInvariantCheckQueue_next_queue_entry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgLargeBitmap_bitmap",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgLargeBitmap_bitmap",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgLargeBitmap_bitmap",
          "package": "base",
          "partial": "FFSET Stg Large Bitmap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgLargeBitmap_bitmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgLargeBitmap_size",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgLargeBitmap_size",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgLargeBitmap_size",
          "package": "base",
          "partial": "FFSET Stg Large Bitmap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgLargeBitmap_size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgMVarTSOQueue_link",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgMVarTSOQueue_link",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgMVarTSOQueue_link",
          "package": "base",
          "partial": "FFSET Stg MVar TSOQueue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgMVarTSOQueue_link"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgMVarTSOQueue_tso",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgMVarTSOQueue_tso",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgMVarTSOQueue_tso",
          "package": "base",
          "partial": "FFSET Stg MVar TSOQueue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgMVarTSOQueue_tso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgMVar_head",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgMVar_head",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgMVar_head",
          "package": "base",
          "partial": "FFSET Stg MVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgMVar_head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgMVar_tail",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgMVar_tail",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgMVar_tail",
          "package": "base",
          "partial": "FFSET Stg MVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgMVar_tail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgMVar_value",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgMVar_value",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgMVar_value",
          "package": "base",
          "partial": "FFSET Stg MVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgMVar_value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgMutArrPtrs_ptrs",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgMutArrPtrs_ptrs",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgMutArrPtrs_ptrs",
          "package": "base",
          "partial": "FFSET Stg Mut Arr Ptrs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgMutArrPtrs_ptrs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgMutArrPtrs_size",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgMutArrPtrs_size",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgMutArrPtrs_size",
          "package": "base",
          "partial": "FFSET Stg Mut Arr Ptrs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgMutArrPtrs_size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgMutVar_var",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgMutVar_var",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgMutVar_var",
          "package": "base",
          "partial": "FFSET Stg Mut Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgMutVar_var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgPAP_arity",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgPAP_arity",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgPAP_arity",
          "package": "base",
          "partial": "FFSET Stg PAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgPAP_arity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgPAP_fun",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgPAP_fun",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgPAP_fun",
          "package": "base",
          "partial": "FFSET Stg PAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgPAP_fun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgPAP_n_args",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgPAP_n_args",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgPAP_n_args",
          "package": "base",
          "partial": "FFSET Stg PAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgPAP_n_args"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgPAP_payload",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgPAP_payload",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgPAP_payload",
          "package": "base",
          "partial": "FFSET Stg PAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgPAP_payload"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rCCCS",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rCCCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rCCCS",
          "package": "base",
          "partial": "FFSET Stg Reg Table CCCS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rCCCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rCurrentNursery",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rCurrentNursery",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rCurrentNursery",
          "package": "base",
          "partial": "FFSET Stg Reg Table Current Nursery",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rCurrentNursery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rCurrentTSO",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rCurrentTSO",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rCurrentTSO",
          "package": "base",
          "partial": "FFSET Stg Reg Table Current TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rCurrentTSO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rD1",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rD1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rD1",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rD1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rD2",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rD2",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rD2",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rD2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rF1",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rF1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rF1",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rF1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rF2",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rF2",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rF2",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rF2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rF3",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rF3",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rF3",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rF3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rF4",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rF4",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rF4",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rF4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rHp",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rHp",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rHp",
          "package": "base",
          "partial": "FFSET Stg Reg Table Hp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rHp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rHpAlloc",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rHpAlloc",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rHpAlloc",
          "package": "base",
          "partial": "FFSET Stg Reg Table Hp Alloc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rHpAlloc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rHpLim",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rHpLim",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rHpLim",
          "package": "base",
          "partial": "FFSET Stg Reg Table Hp Lim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rHpLim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rL1",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rL1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rL1",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rL1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rNursery",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rNursery",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rNursery",
          "package": "base",
          "partial": "FFSET Stg Reg Table Nursery",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rNursery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR1",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rR1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR1",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rR1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR10",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rR10",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR10",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rR10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR2",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rR2",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR2",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rR2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR3",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rR3",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR3",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rR3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR4",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rR4",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR4",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rR4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR5",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rR5",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR5",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rR5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR6",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rR6",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR6",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rR6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR7",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rR7",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR7",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rR7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR8",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rR8",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR8",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rR8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR9",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rR9",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rR9",
          "package": "base",
          "partial": "FFSET Stg Reg Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rR9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rRet",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rRet",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rRet",
          "package": "base",
          "partial": "FFSET Stg Reg Table Ret",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rRet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rSp",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rSp",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rSp",
          "package": "base",
          "partial": "FFSET Stg Reg Table Sp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rSp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rSpLim",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgRegTable_rSpLim",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgRegTable_rSpLim",
          "package": "base",
          "partial": "FFSET Stg Reg Table Sp Lim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgRegTable_rSpLim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgStableName_sn",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgStableName_sn",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgStableName_sn",
          "package": "base",
          "partial": "FFSET Stg Stable Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgStableName_sn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgStack_dirty",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgStack_dirty",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgStack_dirty",
          "package": "base",
          "partial": "FFSET Stg Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgStack_dirty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgStack_sp",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgStack_sp",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgStack_sp",
          "package": "base",
          "partial": "FFSET Stg Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgStack_sp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgStack_stack",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgStack_stack",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgStack_stack",
          "package": "base",
          "partial": "FFSET Stg Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgStack_stack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgStack_stack_size",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgStack_stack_size",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgStack_stack_size",
          "package": "base",
          "partial": "FFSET Stg Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgStack_stack_size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTRecHeader_enclosing_trec",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTRecHeader_enclosing_trec",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTRecHeader_enclosing_trec",
          "package": "base",
          "partial": "FFSET Stg TRec Header",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTRecHeader_enclosing_trec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO__link",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO__link",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO__link",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO__link"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_block_info",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO_block_info",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_block_info",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO_block_info"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_blocked_exceptions",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO_blocked_exceptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_blocked_exceptions",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO_blocked_exceptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_bq",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO_bq",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_bq",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO_bq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_cap",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO_cap",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_cap",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO_cap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_cccs",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO_cccs",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_cccs",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO_cccs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_dirty",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO_dirty",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_dirty",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO_dirty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_flags",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO_flags",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_flags",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO_flags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_global_link",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO_global_link",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_global_link",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO_global_link"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_id",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO_id",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_id",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_saved_errno",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO_saved_errno",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_saved_errno",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO_saved_errno"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_stackobj",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO_stackobj",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_stackobj",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO_stackobj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_trec",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO_trec",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_trec",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO_trec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_what_next",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO_what_next",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_what_next",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO_what_next"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_why_blocked",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTSO_why_blocked",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTSO_why_blocked",
          "package": "base",
          "partial": "FFSET Stg TSO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTSO_why_blocked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTVarWatchQueue_closure",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTVarWatchQueue_closure",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTVarWatchQueue_closure",
          "package": "base",
          "partial": "FFSET Stg TVar Watch Queue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTVarWatchQueue_closure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTVarWatchQueue_next_queue_entry",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTVarWatchQueue_next_queue_entry",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTVarWatchQueue_next_queue_entry",
          "package": "base",
          "partial": "FFSET Stg TVar Watch Queue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTVarWatchQueue_next_queue_entry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTVarWatchQueue_prev_queue_entry",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTVarWatchQueue_prev_queue_entry",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTVarWatchQueue_prev_queue_entry",
          "package": "base",
          "partial": "FFSET Stg TVar Watch Queue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTVarWatchQueue_prev_queue_entry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgTVar_current_value",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgTVar_current_value",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgTVar_current_value",
          "package": "base",
          "partial": "FFSET Stg TVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgTVar_current_value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgUpdateFrame_updatee",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgUpdateFrame_updatee",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgUpdateFrame_updatee",
          "package": "base",
          "partial": "FFSET Stg Update Frame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgUpdateFrame_updatee"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgWeak_cfinalizer",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgWeak_cfinalizer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgWeak_cfinalizer",
          "package": "base",
          "partial": "FFSET Stg Weak",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgWeak_cfinalizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgWeak_finalizer",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgWeak_finalizer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgWeak_finalizer",
          "package": "base",
          "partial": "FFSET Stg Weak",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgWeak_finalizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgWeak_key",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgWeak_key",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgWeak_key",
          "package": "base",
          "partial": "FFSET Stg Weak",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgWeak_key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgWeak_link",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgWeak_link",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgWeak_link",
          "package": "base",
          "partial": "FFSET Stg Weak",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgWeak_link"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_StgWeak_value",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_StgWeak_value",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_StgWeak_value",
          "package": "base",
          "partial": "FFSET Stg Weak",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_StgWeak_value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_bdescr_blocks",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_bdescr_blocks",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_bdescr_blocks",
          "package": "base",
          "partial": "FFSET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_bdescr_blocks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_bdescr_free",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_bdescr_free",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_bdescr_free",
          "package": "base",
          "partial": "FFSET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_bdescr_free"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_bdescr_gen_no",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_bdescr_gen_no",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_bdescr_gen_no",
          "package": "base",
          "partial": "FFSET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_bdescr_gen_no"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_bdescr_link",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_bdescr_link",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_bdescr_link",
          "package": "base",
          "partial": "FFSET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_bdescr_link"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_bdescr_start",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_bdescr_start",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_bdescr_start",
          "package": "base",
          "partial": "FFSET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_bdescr_start"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_generation_n_new_large_words",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_generation_n_new_large_words",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_generation_n_new_large_words",
          "package": "base",
          "partial": "FFSET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_generation_n_new_large_words"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_snEntry_addr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_snEntry_addr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_snEntry_addr",
          "package": "base",
          "partial": "FFSET Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_snEntry_addr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_snEntry_sn_obj",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_snEntry_sn_obj",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_snEntry_sn_obj",
          "package": "base",
          "partial": "FFSET Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_snEntry_sn_obj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_stgEagerBlackholeInfo",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_stgEagerBlackholeInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_stgEagerBlackholeInfo",
          "package": "base",
          "partial": "FFSET Eager Blackhole Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_stgEagerBlackholeInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_stgGCEnter1",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_stgGCEnter1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_stgGCEnter1",
          "package": "base",
          "partial": "FFSET GCEnter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_stgGCEnter1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "oFFSET_stgGCFun",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#oFFSET_stgGCFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "oFFSET_stgGCFun",
          "package": "base",
          "partial": "FFSET GCFun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:oFFSET_stgGCFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "pROF_HDR_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#pROF_HDR_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "pROF_HDR_SIZE",
          "package": "base",
          "partial": "ROF HDR SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:pROF_HDR_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "rESERVED_C_STACK_BYTES",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#rESERVED_C_STACK_BYTES",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "rESERVED_C_STACK_BYTES",
          "package": "base",
          "partial": "ESERVED STACK BYTES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:rESERVED_C_STACK_BYTES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "rESERVED_STACK_WORDS",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#rESERVED_STACK_WORDS",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "rESERVED_STACK_WORDS",
          "package": "base",
          "partial": "ESERVED STACK WORDS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:rESERVED_STACK_WORDS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_CostCentreStack",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_CostCentreStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_CostCentreStack",
          "package": "base",
          "partial": "IZEOF Cost Centre Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_CostCentreStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_MessageBlackHole_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_MessageBlackHole_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_MessageBlackHole_NoHdr",
          "package": "base",
          "partial": "IZEOF Message Black Hole No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_MessageBlackHole_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgAP_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgAP_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgAP_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg AP No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgAP_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgAP_NoThunkHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgAP_NoThunkHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgAP_NoThunkHdr",
          "package": "base",
          "partial": "IZEOF Stg AP No Thunk Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgAP_NoThunkHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgAP_STACK_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgAP_STACK_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgAP_STACK_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg AP STACK No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgAP_STACK_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgAP_STACK_NoThunkHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgAP_STACK_NoThunkHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgAP_STACK_NoThunkHdr",
          "package": "base",
          "partial": "IZEOF Stg AP STACK No Thunk Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgAP_STACK_NoThunkHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgArrWords_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgArrWords_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgArrWords_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg Arr Words No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgArrWords_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgAtomicallyFrame_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgAtomicallyFrame_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgAtomicallyFrame_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg Atomically Frame No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgAtomicallyFrame_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgBCO_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgBCO_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgBCO_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg BCO No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgBCO_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgBlockingQueue_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgBlockingQueue_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgBlockingQueue_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg Blocking Queue No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgBlockingQueue_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgCatchFrame_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgCatchFrame_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgCatchFrame_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg Catch Frame No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgCatchFrame_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgCatchRetryFrame_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgCatchRetryFrame_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgCatchRetryFrame_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg Catch Retry Frame No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgCatchRetryFrame_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgCatchSTMFrame_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgCatchSTMFrame_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgCatchSTMFrame_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg Catch STMFrame No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgCatchSTMFrame_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgDeadWeak_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgDeadWeak_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgDeadWeak_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg Dead Weak No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgDeadWeak_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgFunInfoExtraFwd",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgFunInfoExtraFwd",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgFunInfoExtraFwd",
          "package": "base",
          "partial": "IZEOF Stg Fun Info Extra Fwd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgFunInfoExtraFwd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgFunInfoExtraRev",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgFunInfoExtraRev",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgFunInfoExtraRev",
          "package": "base",
          "partial": "IZEOF Stg Fun Info Extra Rev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgFunInfoExtraRev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgMVarTSOQueue_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgMVarTSOQueue_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgMVarTSOQueue_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg MVar TSOQueue No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgMVarTSOQueue_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgMVar_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgMVar_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgMVar_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg MVar No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgMVar_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgMutArrPtrs_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgMutArrPtrs_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgMutArrPtrs_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg Mut Arr Ptrs No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgMutArrPtrs_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgMutVar_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgMutVar_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgMutVar_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg Mut Var No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgMutVar_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgPAP_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgPAP_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgPAP_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg PAP No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgPAP_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgSMPThunkHeader",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgSMPThunkHeader",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgSMPThunkHeader",
          "package": "base",
          "partial": "IZEOF Stg SMPThunk Header",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgSMPThunkHeader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgSelector_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgSelector_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgSelector_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg Selector No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgSelector_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgSelector_NoThunkHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgSelector_NoThunkHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgSelector_NoThunkHdr",
          "package": "base",
          "partial": "IZEOF Stg Selector No Thunk Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgSelector_NoThunkHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgStableName_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgStableName_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgStableName_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg Stable Name No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgStableName_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgStopFrame_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgStopFrame_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgStopFrame_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg Stop Frame No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgStopFrame_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgTSOProfInfo",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgTSOProfInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgTSOProfInfo",
          "package": "base",
          "partial": "IZEOF Stg TSOProf Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgTSOProfInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgUpdateFrame_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgUpdateFrame_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgUpdateFrame_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg Update Frame No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgUpdateFrame_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_StgWeak_NoHdr",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_StgWeak_NoHdr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_StgWeak_NoHdr",
          "package": "base",
          "partial": "IZEOF Stg Weak No Hdr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_StgWeak_NoHdr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_generation",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_generation",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_generation",
          "package": "base",
          "partial": "IZEOF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_generation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sIZEOF_snEntry",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sIZEOF_snEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sIZEOF_snEntry",
          "package": "base",
          "partial": "IZEOF Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sIZEOF_snEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "sTD_HDR_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#sTD_HDR_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "sTD_HDR_SIZE",
          "package": "base",
          "partial": "TD HDR SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:sTD_HDR_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "tAG_BITS",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#tAG_BITS",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "tAG_BITS",
          "package": "base",
          "partial": "AG BITS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:tAG_BITS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "tAG_MASK",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#tAG_MASK",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "tAG_MASK",
          "package": "base",
          "partial": "AG MASK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:tAG_MASK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "tARGET_MAX_CHAR",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#tARGET_MAX_CHAR",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "tARGET_MAX_CHAR",
          "package": "base",
          "partial": "ARGET MAX CHAR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:tARGET_MAX_CHAR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "tARGET_MAX_INT",
          "package": "base",
          "signature": "Integer",
          "source": "src/GHC-Constants.html#tARGET_MAX_INT",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "tARGET_MAX_INT",
          "package": "base",
          "partial": "ARGET MAX INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:tARGET_MAX_INT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "tARGET_MAX_WORD",
          "package": "base",
          "signature": "Integer",
          "source": "src/GHC-Constants.html#tARGET_MAX_WORD",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "tARGET_MAX_WORD",
          "package": "base",
          "partial": "ARGET MAX WORD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:tARGET_MAX_WORD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "tARGET_MIN_INT",
          "package": "base",
          "signature": "Integer",
          "source": "src/GHC-Constants.html#tARGET_MIN_INT",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "tARGET_MIN_INT",
          "package": "base",
          "partial": "ARGET MIN INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:tARGET_MIN_INT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "wORD64_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#wORD64_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "wORD64_SIZE",
          "package": "base",
          "partial": "ORD SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:wORD64_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "wORD_SIZE",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#wORD_SIZE",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "wORD_SIZE",
          "package": "base",
          "partial": "ORD SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:wORD_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Constants",
          "name": "wORD_SIZE_IN_BITS",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Constants.html#wORD_SIZE_IN_BITS",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Constants",
          "module": "GHC.Constants",
          "name": "wORD_SIZE_IN_BITS",
          "package": "base",
          "partial": "ORD SIZE IN BITS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Constants.html#v:wORD_SIZE_IN_BITS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSupport code for desugaring in GHC\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.Desugar",
          "name": "Desugar",
          "package": "base",
          "source": "src/GHC-Desugar.html",
          "type": "module"
        },
        "index": {
          "description": "Support code for desugaring in GHC",
          "hierarchy": "GHC Desugar",
          "module": "GHC.Desugar",
          "name": "Desugar",
          "package": "base",
          "partial": "Desugar",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Desugar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Desugar",
          "name": "AnnotationWrapper",
          "package": "base",
          "source": "src/GHC-Desugar.html#AnnotationWrapper",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC Desugar",
          "module": "GHC.Desugar",
          "name": "AnnotationWrapper",
          "package": "base",
          "partial": "Annotation Wrapper",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Desugar.html#t:AnnotationWrapper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Desugar",
          "name": "(\u003e\u003e\u003e)",
          "package": "base",
          "signature": "forall a b c.  arr a b -\u003e arr b c -\u003e arr a c",
          "source": "src/GHC-Desugar.html#%3E%3E%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Desugar",
          "module": "GHC.Desugar",
          "name": "(\u003e\u003e\u003e) \u003e\u003e\u003e",
          "normalized": "a b c d e b c-\u003ee c f-\u003ee b f",
          "package": "base",
          "signature": "forall a b c. arr a b-\u003earr b c-\u003earr a c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Desugar.html#v:-62--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Desugar",
          "name": "AnnotationWrapper",
          "package": "base",
          "signature": "AnnotationWrapper a",
          "source": "src/GHC-Desugar.html#AnnotationWrapper",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Desugar",
          "module": "GHC.Desugar",
          "name": "AnnotationWrapper",
          "package": "base",
          "partial": "Annotation Wrapper",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Desugar.html#v:AnnotationWrapper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Desugar",
          "name": "toAnnotationWrapper",
          "package": "base",
          "signature": "a -\u003e AnnotationWrapper",
          "source": "src/GHC-Desugar.html#toAnnotationWrapper",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Desugar",
          "module": "GHC.Desugar",
          "name": "toAnnotationWrapper",
          "normalized": "a-\u003eAnnotationWrapper",
          "package": "base",
          "partial": "Annotation Wrapper",
          "signature": "a-\u003eAnnotationWrapper",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Desugar.html#v:toAnnotationWrapper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Environment",
          "name": "Environment",
          "package": "base",
          "source": "src/GHC-Environment.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "GHC Environment",
          "module": "GHC.Environment",
          "name": "Environment",
          "package": "base",
          "partial": "Environment",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Environment.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Environment",
          "name": "getFullArgs",
          "package": "base",
          "signature": "IO [String]",
          "source": "src/GHC-Environment.html#getFullArgs",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Environment",
          "module": "GHC.Environment",
          "name": "getFullArgs",
          "normalized": "IO[String]",
          "package": "base",
          "partial": "Full Args",
          "signature": "IO[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Environment.html#v:getFullArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides scalable event notification for file\n descriptors and timeouts.\n\u003c/p\u003e\u003cp\u003eThis module should be considered GHC internal.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e---------------------------------------------------------------------------\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "GHC.Event",
          "name": "Event",
          "package": "base",
          "source": "src/GHC-Event.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides scalable event notification for file descriptors and timeouts This module should be considered GHC internal",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "Event",
          "package": "base",
          "partial": "Event",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn I/O event.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "Event",
          "package": "base",
          "source": "src/GHC-Event-Internal.html#Event",
          "type": "data"
        },
        "index": {
          "description": "An event",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "Event",
          "package": "base",
          "partial": "Event",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#t:Event"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe event manager state.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "EventManager",
          "package": "base",
          "source": "src/GHC-Event-Manager.html#EventManager",
          "type": "data"
        },
        "index": {
          "description": "The event manager state",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "EventManager",
          "package": "base",
          "partial": "Event Manager",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#t:EventManager"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA file descriptor registration cookie.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "FdKey",
          "package": "base",
          "source": "src/GHC-Event-Manager.html#FdKey",
          "type": "data"
        },
        "index": {
          "description": "file descriptor registration cookie",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "FdKey",
          "package": "base",
          "partial": "Fd Key",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#t:FdKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCallback invoked on I/O events.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "IOCallback",
          "package": "base",
          "source": "src/GHC-Event-Manager.html#IOCallback",
          "type": "type"
        },
        "index": {
          "description": "Callback invoked on events",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "IOCallback",
          "package": "base",
          "partial": "IOCallback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#t:IOCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCallback invoked on timeout events.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "TimeoutCallback",
          "package": "base",
          "source": "src/GHC-Event-Manager.html#TimeoutCallback",
          "type": "type"
        },
        "index": {
          "description": "Callback invoked on timeout events",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "TimeoutCallback",
          "package": "base",
          "partial": "Timeout Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#t:TimeoutCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA timeout registration cookie.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "TimeoutKey",
          "package": "base",
          "source": "src/GHC-Event-Manager.html#TimeoutKey",
          "type": "data"
        },
        "index": {
          "description": "timeout registration cookie",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "TimeoutKey",
          "package": "base",
          "partial": "Timeout Key",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#t:TimeoutKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClose a file descriptor in a race-safe way.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "closeFd",
          "package": "base",
          "signature": "EventManager -\u003e (Fd -\u003e IO ()) -\u003e Fd -\u003e IO ()",
          "source": "src/GHC-Event-Manager.html#closeFd",
          "type": "function"
        },
        "index": {
          "description": "Close file descriptor in race-safe way",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "closeFd",
          "normalized": "EventManager-\u003e(Fd-\u003eIO())-\u003eFd-\u003eIO()",
          "package": "base",
          "partial": "Fd",
          "signature": "EventManager-\u003e(Fd-\u003eIO())-\u003eFd-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:closeFd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData is available to be read.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "evtRead",
          "package": "base",
          "signature": "Event",
          "source": "src/GHC-Event-Internal.html#evtRead",
          "type": "function"
        },
        "index": {
          "description": "Data is available to be read",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "evtRead",
          "package": "base",
          "partial": "Read",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:evtRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe file descriptor is ready to accept a write.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "evtWrite",
          "package": "base",
          "signature": "Event",
          "source": "src/GHC-Event-Internal.html#evtWrite",
          "type": "function"
        },
        "index": {
          "description": "The file descriptor is ready to accept write",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "evtWrite",
          "package": "base",
          "partial": "Write",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:evtWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the system event manager.\n\u003c/p\u003e\u003cp\u003eThis function always returns \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the system event manager when using the\n threaded RTS and \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e otherwise.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "getSystemEventManager",
          "package": "base",
          "signature": "IO (Maybe EventManager)",
          "source": "src/GHC-Event-Thread.html#getSystemEventManager",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the system event manager This function always returns Just the system event manager when using the threaded RTS and Nothing otherwise",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "getSystemEventManager",
          "package": "base",
          "partial": "System Event Manager",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:getSystemEventManager"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStart handling events.  This function loops until told to stop,\n using \u003ccode\u003e\u003ca\u003eshutdown\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote\u003c/em\u003e: This loop can only be run once per \u003ccode\u003e\u003ca\u003eEventManager\u003c/a\u003e\u003c/code\u003e, as it\n closes all of its control resources when it finishes.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "loop",
          "package": "base",
          "signature": "EventManager -\u003e IO ()",
          "source": "src/GHC-Event-Manager.html#loop",
          "type": "function"
        },
        "index": {
          "description": "Start handling events This function loops until told to stop using shutdown Note This loop can only be run once per EventManager as it closes all of its control resources when it finishes",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "loop",
          "normalized": "EventManager-\u003eIO()",
          "package": "base",
          "signature": "EventManager-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:loop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new event manager.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "new",
          "package": "base",
          "signature": "IO EventManager",
          "source": "src/GHC-Event-Manager.html#new",
          "type": "function"
        },
        "index": {
          "description": "Create new event manager",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "new",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:new"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eregisterFd mgr cb fd evs\u003c/code\u003e registers interest in the events \u003ccode\u003eevs\u003c/code\u003e\n on the file descriptor \u003ccode\u003efd\u003c/code\u003e.  \u003ccode\u003ecb\u003c/code\u003e is called for each event that\n occurs.  Returns a cookie that can be handed to \u003ccode\u003e\u003ca\u003eunregisterFd\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "registerFd",
          "package": "base",
          "signature": "EventManager -\u003e IOCallback -\u003e Fd -\u003e Event -\u003e IO FdKey",
          "source": "src/GHC-Event-Manager.html#registerFd",
          "type": "function"
        },
        "index": {
          "description": "registerFd mgr cb fd evs registers interest in the events evs on the file descriptor fd cb is called for each event that occurs Returns cookie that can be handed to unregisterFd",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "registerFd",
          "normalized": "EventManager-\u003eIOCallback-\u003eFd-\u003eEvent-\u003eIO FdKey",
          "package": "base",
          "partial": "Fd",
          "signature": "EventManager-\u003eIOCallback-\u003eFd-\u003eEvent-\u003eIO FdKey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:registerFd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegister interest in the given events, without waking the event\n manager thread.  The \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e return value indicates whether the\n event manager ought to be woken.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "registerFd_",
          "package": "base",
          "signature": "EventManager -\u003e IOCallback -\u003e Fd -\u003e Event -\u003e IO (FdKey, Bool)",
          "source": "src/GHC-Event-Manager.html#registerFd_",
          "type": "function"
        },
        "index": {
          "description": "Register interest in the given events without waking the event manager thread The Bool return value indicates whether the event manager ought to be woken",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "registerFd_",
          "normalized": "EventManager-\u003eIOCallback-\u003eFd-\u003eEvent-\u003eIO(FdKey,Bool)",
          "package": "base",
          "partial": "Fd",
          "signature": "EventManager-\u003eIOCallback-\u003eFd-\u003eEvent-\u003eIO(FdKey,Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:registerFd_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegister a timeout in the given number of microseconds.  The\n returned \u003ccode\u003e\u003ca\u003eTimeoutKey\u003c/a\u003e\u003c/code\u003e can be used to later unregister or update the\n timeout.  The timeout is automatically unregistered after the given\n time has passed.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "registerTimeout",
          "package": "base",
          "signature": "EventManager -\u003e Int -\u003e TimeoutCallback -\u003e IO TimeoutKey",
          "source": "src/GHC-Event-Manager.html#registerTimeout",
          "type": "function"
        },
        "index": {
          "description": "Register timeout in the given number of microseconds The returned TimeoutKey can be used to later unregister or update the timeout The timeout is automatically unregistered after the given time has passed",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "registerTimeout",
          "normalized": "EventManager-\u003eInt-\u003eTimeoutCallback-\u003eIO TimeoutKey",
          "package": "base",
          "partial": "Timeout",
          "signature": "EventManager-\u003eInt-\u003eTimeoutCallback-\u003eIO TimeoutKey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:registerTimeout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAsynchronously shuts down the event manager, if running.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "shutdown",
          "package": "base",
          "signature": "EventManager -\u003e IO ()",
          "source": "src/GHC-Event-Manager.html#shutdown",
          "type": "function"
        },
        "index": {
          "description": "Asynchronously shuts down the event manager if running",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "shutdown",
          "normalized": "EventManager-\u003eIO()",
          "package": "base",
          "signature": "EventManager-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:shutdown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Event",
          "name": "step",
          "package": "base",
          "signature": "EventManager -\u003e TimeoutQueue -\u003e IO (Bool, TimeoutQueue)",
          "source": "src/GHC-Event-Manager.html#step",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "step",
          "normalized": "EventManager-\u003eTimeoutQueue-\u003eIO(Bool,TimeoutQueue)",
          "package": "base",
          "signature": "EventManager-\u003eTimeoutQueue-\u003eIO(Bool,TimeoutQueue)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDrop a previous file descriptor registration.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "unregisterFd",
          "package": "base",
          "signature": "EventManager -\u003e FdKey -\u003e IO ()",
          "source": "src/GHC-Event-Manager.html#unregisterFd",
          "type": "function"
        },
        "index": {
          "description": "Drop previous file descriptor registration",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "unregisterFd",
          "normalized": "EventManager-\u003eFdKey-\u003eIO()",
          "package": "base",
          "partial": "Fd",
          "signature": "EventManager-\u003eFdKey-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:unregisterFd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDrop a previous file descriptor registration, without waking the\n event manager thread.  The return value indicates whether the event\n manager ought to be woken.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "unregisterFd_",
          "package": "base",
          "signature": "EventManager -\u003e FdKey -\u003e IO Bool",
          "source": "src/GHC-Event-Manager.html#unregisterFd_",
          "type": "function"
        },
        "index": {
          "description": "Drop previous file descriptor registration without waking the event manager thread The return value indicates whether the event manager ought to be woken",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "unregisterFd_",
          "normalized": "EventManager-\u003eFdKey-\u003eIO Bool",
          "package": "base",
          "partial": "Fd",
          "signature": "EventManager-\u003eFdKey-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:unregisterFd_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnregister an active timeout.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "unregisterTimeout",
          "package": "base",
          "signature": "EventManager -\u003e TimeoutKey -\u003e IO ()",
          "source": "src/GHC-Event-Manager.html#unregisterTimeout",
          "type": "function"
        },
        "index": {
          "description": "Unregister an active timeout",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "unregisterTimeout",
          "normalized": "EventManager-\u003eTimeoutKey-\u003eIO()",
          "package": "base",
          "partial": "Timeout",
          "signature": "EventManager-\u003eTimeoutKey-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:unregisterTimeout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate an active timeout to fire in the given number of\n microseconds.\n\u003c/p\u003e",
          "module": "GHC.Event",
          "name": "updateTimeout",
          "package": "base",
          "signature": "EventManager -\u003e TimeoutKey -\u003e Int -\u003e IO ()",
          "source": "src/GHC-Event-Manager.html#updateTimeout",
          "type": "function"
        },
        "index": {
          "description": "Update an active timeout to fire in the given number of microseconds",
          "hierarchy": "GHC Event",
          "module": "GHC.Event",
          "name": "updateTimeout",
          "normalized": "EventManager-\u003eTimeoutKey-\u003eInt-\u003eIO()",
          "package": "base",
          "partial": "Timeout",
          "signature": "EventManager-\u003eTimeoutKey-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Event.html#v:updateTimeout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGHC Extensions: this is the Approved Way to get at GHC-specific extensions.\n\u003c/p\u003e\u003cp\u003eNote: no other base module should import this module.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.Exts",
          "name": "Exts",
          "package": "base",
          "source": "src/GHC-Exts.html",
          "type": "module"
        },
        "index": {
          "description": "GHC Extensions this is the Approved Way to get at GHC-specific extensions Note no other base module should import this module",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "Exts",
          "package": "base",
          "partial": "Exts",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe character type \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e is an enumeration whose values represent\nUnicode (or equivalently ISO/IEC 10646) characters (see\n\u003ca\u003ehttp://www.unicode.org/\u003c/a\u003e for details).  This set extends the ISO 8859-1\n(Latin-1) character set (the first 256 characters), which is itself an extension\nof the ASCII character set (the first 128 characters).  A character literal in\nHaskell has type \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eTo convert a \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e to or from the corresponding \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e value defined\nby Unicode, use \u003ccode\u003e\u003ca\u003etoEnum\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efromEnum\u003c/a\u003e\u003c/code\u003e from the\n\u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e class respectively (or equivalently \u003ccode\u003eord\u003c/code\u003e and \u003ccode\u003echr\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "Char",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "The character type Char is an enumeration whose values represent Unicode or equivalently ISO IEC characters see http www.unicode.org for details This set extends the ISO Latin-1 character set the first characters which is itself an extension of the ASCII character set the first characters character literal in Haskell has type Char To convert Char to or from the corresponding Int value defined by Unicode use toEnum and fromEnum from the Enum class respectively or equivalently ord and chr",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "Char",
          "package": "base",
          "partial": "Char",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#t:Char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "Constraint",
          "package": "base",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "Constraint",
          "package": "base",
          "partial": "Constraint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#t:Constraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDouble-precision floating point numbers.\n It is desirable that this type be at least equal in range and precision\n to the IEEE double-precision type.\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "Double",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "Double-precision floating point numbers It is desirable that this type be at least equal in range and precision to the IEEE double-precision type",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "Double",
          "package": "base",
          "partial": "Double",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#t:Double"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eDown\u003c/a\u003e\u003c/code\u003e type allows you to reverse sort order conveniently.  A value of type\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eDown\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e contains a value of type \u003ccode\u003ea\u003c/code\u003e (represented as \u003ccode\u003e\u003ccode\u003e\u003ca\u003eDown\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e).\n If \u003ccode\u003ea\u003c/code\u003e has an \u003ccode\u003e\u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e instance associated with it then comparing two\n values thus wrapped will give you the opposite of their normal sort order.\n This is particularly useful when sorting in generalised list comprehensions,\n as in: \u003ccode\u003ethen sortWith by \u003ccode\u003e\u003ca\u003eDown\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "Down",
          "package": "base",
          "source": "src/Data-Ord.html#Down",
          "type": "newtype"
        },
        "index": {
          "description": "The Down type allows you to reverse sort order conveniently value of type Down contains value of type represented as Down If has an Ord instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order This is particularly useful when sorting in generalised list comprehensions as in then sortWith by Down",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "Down",
          "package": "base",
          "partial": "Down",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#t:Down"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle-precision floating point numbers.\n It is desirable that this type be at least equal in range and precision\n to the IEEE single-precision type.\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "Float",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "Single-precision floating point numbers It is desirable that this type be at least equal in range and precision to the IEEE single-precision type",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "Float",
          "package": "base",
          "partial": "Float",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#t:Float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e is a pointer to a function callable\n from foreign code.  The type \u003ccode\u003ea\u003c/code\u003e will normally be a \u003cem\u003eforeign type\u003c/em\u003e,\n a function type with zero or more arguments where\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the argument types are \u003cem\u003emarshallable foreign types\u003c/em\u003e,\n   i.e. \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFloat\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt16\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt32\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003eInt64\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord16\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003eWord32\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord64\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e,\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003eStablePtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e or a renaming of any of these\n   using \u003ccode\u003enewtype\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e the return type is either a marshallable foreign type or has the form\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e t\u003c/code\u003e where \u003ccode\u003et\u003c/code\u003e is a marshallable foreign type or \u003ccode\u003e()\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eA value of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e may be a pointer to a foreign function,\n either returned by another foreign function or imported with a\n a static address import like\n\u003c/p\u003e\u003cpre\u003e foreign import ccall \"stdlib.h &free\"\n   p_free :: FunPtr (Ptr a -\u003e IO ())\n\u003c/pre\u003e\u003cp\u003eor a pointer to a Haskell function created using a \u003cem\u003ewrapper\u003c/em\u003e stub\n declared to produce a \u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e of the correct type.  For example:\n\u003c/p\u003e\u003cpre\u003e type Compare = Int -\u003e Int -\u003e Bool\n foreign import ccall \"wrapper\"\n   mkCompare :: Compare -\u003e IO (FunPtr Compare)\n\u003c/pre\u003e\u003cp\u003eCalls to wrapper stubs like \u003ccode\u003emkCompare\u003c/code\u003e allocate storage, which\n should be released with \u003ccode\u003e\u003ca\u003efreeHaskellFunPtr\u003c/a\u003e\u003c/code\u003e when no\n longer required.\n\u003c/p\u003e\u003cp\u003eTo convert \u003ccode\u003e\u003ca\u003eFunPtr\u003c/a\u003e\u003c/code\u003e values to corresponding Haskell functions, one\n can define a \u003cem\u003edynamic\u003c/em\u003e stub for the specific foreign type, e.g.\n\u003c/p\u003e\u003cpre\u003e type IntFunction = CInt -\u003e IO ()\n foreign import ccall \"dynamic\" \n   mkFun :: FunPtr IntFunction -\u003e IntFunction\n\u003c/pre\u003e",
          "module": "GHC.Exts",
          "name": "FunPtr",
          "package": "base",
          "source": "src/GHC-Ptr.html#FunPtr",
          "type": "data"
        },
        "index": {
          "description": "value of type FunPtr is pointer to function callable from foreign code The type will normally be foreign type function type with zero or more arguments where the argument types are marshallable foreign types i.e Char Int Double Float Bool Int8 Int16 Int32 Int64 Word8 Word16 Word32 Word64 Ptr FunPtr StablePtr or renaming of any of these using newtype the return type is either marshallable foreign type or has the form IO where is marshallable foreign type or value of type FunPtr may be pointer to foreign function either returned by another foreign function or imported with static address import like foreign import ccall stdlib.h free free FunPtr Ptr IO or pointer to Haskell function created using wrapper stub declared to produce FunPtr of the correct type For example type Compare Int Int Bool foreign import ccall wrapper mkCompare Compare IO FunPtr Compare Calls to wrapper stubs like mkCompare allocate storage which should be released with freeHaskellFunPtr when no longer required To convert FunPtr values to corresponding Haskell functions one can define dynamic stub for the specific foreign type e.g type IntFunction CInt IO foreign import ccall dynamic mkFun FunPtr IntFunction IntFunction",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "FunPtr",
          "package": "base",
          "partial": "Fun Ptr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#t:FunPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA fixed-precision integer type with at least the range \u003ccode\u003e[-2^29 .. 2^29-1]\u003c/code\u003e.\n The exact range for a given implementation can be determined by using\n \u003ccode\u003e\u003ca\u003eminBound\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emaxBound\u003c/a\u003e\u003c/code\u003e from the \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "Int",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "fixed-precision integer type with at least the range The exact range for given implementation can be determined by using minBound and maxBound from the Bounded class",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "Int",
          "package": "base",
          "partial": "Int",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#t:Int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass for string-like datastructures; used by the overloaded string\n   extension (-foverloaded-strings in GHC).\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "IsString",
          "package": "base",
          "source": "src/Data-String.html#IsString",
          "type": "class"
        },
        "index": {
          "description": "Class for string-like datastructures used by the overloaded string extension foverloaded-strings in GHC",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "IsString",
          "package": "base",
          "partial": "Is String",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#t:IsString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e represents a pointer to an object, or an\n array of objects, which may be marshalled to or from Haskell values\n of type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe type \u003ccode\u003ea\u003c/code\u003e will often be an instance of class\n \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e which provides the marshalling operations.\n However this is not essential, and you can provide your own operations\n to access the pointer.  For example you might write small foreign\n functions to get or set the fields of a C \u003ccode\u003estruct\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "Ptr",
          "package": "base",
          "source": "src/GHC-Ptr.html#Ptr",
          "type": "data"
        },
        "index": {
          "description": "value of type Ptr represents pointer to an object or an array of objects which may be marshalled to or from Haskell values of type The type will often be an instance of class Storable which provides the marshalling operations However this is not essential and you can provide your own operations to access the pointer For example you might write small foreign functions to get or set the fields of struct",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "Ptr",
          "package": "base",
          "partial": "Ptr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#t:Ptr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "SpecConstrAnnotation",
          "package": "base",
          "source": "src/GHC-Exts.html#SpecConstrAnnotation",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "SpecConstrAnnotation",
          "package": "base",
          "partial": "Spec Constr Annotation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#t:SpecConstrAnnotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e is an unsigned integral type, with the same size as \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "Word",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "Word is an unsigned integral type with the same size as Int",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "Word",
          "package": "base",
          "partial": "Word",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#t:Word"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "C#",
          "package": "base",
          "signature": "C# \"/packages/archive///doc/html/GHC-Prim.html#t:Char-35-\"\u003eChar#",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "C#",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:C-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "D#",
          "package": "base",
          "signature": "D# \"/packages/archive///doc/html/GHC-Prim.html#t:Double-35-\"\u003eDouble#",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "D#",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:D-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "F#",
          "package": "base",
          "signature": "F# \"/packages/archive///doc/html/GHC-Prim.html#t:Float-35-\"\u003eFloat#",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "F#",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:F-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "ForceSpecConstr",
          "package": "base",
          "signature": "ForceSpecConstr",
          "source": "src/GHC-Exts.html#SpecConstrAnnotation",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "ForceSpecConstr",
          "package": "base",
          "partial": "Force Spec Constr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:ForceSpecConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "FunPtr",
          "package": "base",
          "signature": "FunPtr \"/packages/archive///doc/html/GHC-Prim.html#t:Addr-35-\"\u003eAddr#",
          "source": "src/GHC-Ptr.html#FunPtr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "FunPtr",
          "package": "base",
          "partial": "Fun Ptr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:FunPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "I#",
          "package": "base",
          "signature": "I# \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt#",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "I#",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:I-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "NoSpecConstr",
          "package": "base",
          "signature": "NoSpecConstr",
          "source": "src/GHC-Exts.html#SpecConstrAnnotation",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "NoSpecConstr",
          "package": "base",
          "partial": "No Spec Constr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:NoSpecConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "Ptr",
          "package": "base",
          "signature": "Ptr \"/packages/archive///doc/html/GHC-Prim.html#t:Addr-35-\"\u003eAddr#",
          "source": "src/GHC-Ptr.html#Ptr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "Ptr",
          "package": "base",
          "partial": "Ptr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:Ptr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "W#",
          "package": "base",
          "signature": "W# \"/packages/archive///doc/html/GHC-Prim.html#t:Word-35-\"\u003eWord#",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "W#",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:W-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list producer that can be fused with \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e.\n This function is merely\n\u003c/p\u003e\u003cpre\u003e    augment g xs = g (:) xs\n\u003c/pre\u003e\u003cp\u003ebut GHC's simplifier will transform an expression of the form\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e k z (\u003ccode\u003e\u003ca\u003eaugment\u003c/a\u003e\u003c/code\u003e g xs)\u003c/code\u003e, which may arise after inlining, to\n \u003ccode\u003eg k (\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e k z xs)\u003c/code\u003e, which avoids producing an intermediate list.\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "augment",
          "package": "base",
          "signature": "forall a.  (forall b.  (a -\u003e b -\u003e b) -\u003e b -\u003e b) -\u003e [a] -\u003e [a]",
          "source": "src/GHC-Base.html#augment",
          "type": "function"
        },
        "index": {
          "description": "list producer that can be fused with foldr This function is merely augment xs xs but GHC simplifier will transform an expression of the form foldr augment xs which may arise after inlining to foldr xs which avoids producing an intermediate list",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "augment",
          "normalized": "a b(a c(d-\u003ee-\u003ee)-\u003ee-\u003ee)-\u003e[d]-\u003e[d]",
          "package": "base",
          "signature": "forall a.(forall b.(a-\u003eb-\u003eb)-\u003eb-\u003eb)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:augment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "breakpoint",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Base.html#breakpoint",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "breakpoint",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:breakpoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "breakpointCond",
          "package": "base",
          "signature": "Bool -\u003e a -\u003e a",
          "source": "src/GHC-Base.html#breakpointCond",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "breakpointCond",
          "normalized": "Bool-\u003ea-\u003ea",
          "package": "base",
          "partial": "Cond",
          "signature": "Bool-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:breakpointCond"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list producer that can be fused with \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e.\n This function is merely\n\u003c/p\u003e\u003cpre\u003e    build g = g (:) []\n\u003c/pre\u003e\u003cp\u003ebut GHC's simplifier will transform an expression of the form\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e k z (\u003ccode\u003e\u003ca\u003ebuild\u003c/a\u003e\u003c/code\u003e g)\u003c/code\u003e, which may arise after inlining, to \u003ccode\u003eg k z\u003c/code\u003e,\n which avoids producing an intermediate list.\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "build",
          "package": "base",
          "signature": "forall a.  (forall b.  (a -\u003e b -\u003e b) -\u003e b -\u003e b) -\u003e [a]",
          "source": "src/GHC-Base.html#build",
          "type": "function"
        },
        "index": {
          "description": "list producer that can be fused with foldr This function is merely build but GHC simplifier will transform an expression of the form foldr build which may arise after inlining to which avoids producing an intermediate list",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "build",
          "normalized": "a b(a c(d-\u003ee-\u003ee)-\u003ee-\u003ee)-\u003e[d]",
          "package": "base",
          "signature": "forall a.(forall b.(a-\u003eb-\u003eb)-\u003eb-\u003eb)-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:build"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturns a '[String]' representing the current call stack.  This\n can be useful for debugging.\n\u003c/p\u003e\u003cp\u003eThe implementation uses the call-stack simulation maintined by the\n profiler, so it only works if the program was compiled with \u003ccode\u003e-prof\u003c/code\u003e\n and contains suitable SCC annotations (e.g. by using \u003ccode\u003e-fprof-auto\u003c/code\u003e).\n Otherwise, the list returned is likely to be empty or\n uninformative.\n\u003c/p\u003e",
          "module": "[\"GHC.Exts\",\"GHC.Stack\"]",
          "name": "currentCallStack",
          "package": "base",
          "signature": "IO [String]",
          "source": "src/GHC-Stack.html#currentCallStack",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:currentCallStack\",\"http://hackage.haskell.org/package/base/docs/GHC-Stack.html#v:currentCallStack\"]"
        },
        "index": {
          "description": "returns String representing the current call stack This can be useful for debugging The implementation uses the call-stack simulation maintined by the profiler so it only works if the program was compiled with prof and contains suitable SCC annotations e.g by using fprof-auto Otherwise the list returned is likely to be empty or uninformative",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "currentCallStack",
          "normalized": "IO[String]",
          "package": "base",
          "partial": "Call Stack",
          "signature": "IO[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:currentCallStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "fromString",
          "package": "base",
          "signature": "String -\u003e a",
          "source": "src/Data-String.html#fromString",
          "type": "method"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "fromString",
          "normalized": "String-\u003ea",
          "package": "base",
          "partial": "String",
          "signature": "String-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:fromString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egroupWith\u003c/a\u003e\u003c/code\u003e function uses the user supplied function which\n projects an element out of every list element in order to first sort the\n input list and then to form groups by equality on these projected elements\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "groupWith",
          "package": "base",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e [[a]]",
          "source": "src/GHC-Exts.html#groupWith",
          "type": "function"
        },
        "index": {
          "description": "The groupWith function uses the user supplied function which projects an element out of every list element in order to first sort the input list and then to form groups by equality on these projected elements",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "groupWith",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003e[[a]]",
          "package": "base",
          "partial": "With",
          "signature": "(a-\u003eb)-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:groupWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShift the argument left by the specified number of bits\n (which must be non-negative).\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "iShiftL#",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt#",
          "source": "src/GHC-Base.html#iShiftL%23",
          "type": "function"
        },
        "index": {
          "description": "Shift the argument left by the specified number of bits which must be non-negative",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "iShiftL#",
          "normalized": "a b c d GHC Prim.html #t Int Int #-\u003ea b c d GHC Prim.html #t Int Int #-\u003ea b c d GHC Prim.html #t Int Int #",
          "package": "base",
          "partial": "Shift",
          "signature": "packages archive doc html GHC Prim.html #t Int Int #-\u003epackages archive doc html GHC Prim.html #t Int Int #-\u003epackages archive doc html GHC Prim.html #t Int Int #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:iShiftL-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShift the argument right (signed) by the specified number of bits\n (which must be non-negative).\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "iShiftRA#",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt#",
          "source": "src/GHC-Base.html#iShiftRA%23",
          "type": "function"
        },
        "index": {
          "description": "Shift the argument right signed by the specified number of bits which must be non-negative",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "iShiftRA#",
          "normalized": "a b c d GHC Prim.html #t Int Int #-\u003ea b c d GHC Prim.html #t Int Int #-\u003ea b c d GHC Prim.html #t Int Int #",
          "package": "base",
          "partial": "Shift RA",
          "signature": "packages archive doc html GHC Prim.html #t Int Int #-\u003epackages archive doc html GHC Prim.html #t Int Int #-\u003epackages archive doc html GHC Prim.html #t Int Int #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:iShiftRA-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShift the argument right (unsigned) by the specified number of bits\n (which must be non-negative).\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "iShiftRL#",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt#",
          "source": "src/GHC-Base.html#iShiftRL%23",
          "type": "function"
        },
        "index": {
          "description": "Shift the argument right unsigned by the specified number of bits which must be non-negative",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "iShiftRL#",
          "normalized": "a b c d GHC Prim.html #t Int Int #-\u003ea b c d GHC Prim.html #t Int Int #-\u003ea b c d GHC Prim.html #t Int Int #",
          "package": "base",
          "partial": "Shift RL",
          "signature": "packages archive doc html GHC Prim.html #t Int Int #-\u003epackages archive doc html GHC Prim.html #t Int Int #-\u003epackages archive doc html GHC Prim.html #t Int Int #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:iShiftRL-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe call '(inline f)' reduces to \u003ccode\u003ef\u003c/code\u003e, but \u003ccode\u003e\u003ca\u003einline\u003c/a\u003e\u003c/code\u003e has a BuiltInRule\n that tries to inline \u003ccode\u003ef\u003c/code\u003e (if it has an unfolding) unconditionally\n The \u003ccode\u003eNOINLINE\u003c/code\u003e pragma arranges that inline only gets inlined (and\n hence eliminated) late in compilation, after the rule has had\n a good chance to fire.\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "inline",
          "package": "base",
          "signature": "a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "The call inline reduces to but inline has BuiltInRule that tries to inline if it has an unfolding unconditionally The NOINLINE pragma arranges that inline only gets inlined and hence eliminated late in compilation after the rule has had good chance to fire",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "inline",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:inline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe call '(lazy e)' means the same as \u003ccode\u003ee\u003c/code\u003e, but \u003ccode\u003e\u003ca\u003elazy\u003c/a\u003e\u003c/code\u003e has a \n magical strictness property: it is lazy in its first argument, \n even though its semantics is strict.\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "lazy",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Base.html#lazy",
          "type": "function"
        },
        "index": {
          "description": "The call lazy means the same as but lazy has magical strictness property it is lazy in its first argument even though its semantics is strict",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "lazy",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:lazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "maxTupleSize",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-Exts.html#maxTupleSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "maxTupleSize",
          "package": "base",
          "partial": "Tuple Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:maxTupleSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShift the argument left by the specified number of bits\n (which must be non-negative).\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "shiftL#",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Word-35-\"\u003eWord# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Word-35-\"\u003eWord#",
          "source": "src/GHC-Base.html#shiftL%23",
          "type": "function"
        },
        "index": {
          "description": "Shift the argument left by the specified number of bits which must be non-negative",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "shiftL#",
          "normalized": "a b c d GHC Prim.html #t Word Word #-\u003ea b c d GHC Prim.html #t Int Int #-\u003ea b c d GHC Prim.html #t Word Word #",
          "package": "base",
          "signature": "packages archive doc html GHC Prim.html #t Word Word #-\u003epackages archive doc html GHC Prim.html #t Int Int #-\u003epackages archive doc html GHC Prim.html #t Word Word #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:shiftL-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShift the argument right by the specified number of bits\n (which must be non-negative).\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "shiftRL#",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Word-35-\"\u003eWord# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Word-35-\"\u003eWord#",
          "source": "src/GHC-Base.html#shiftRL%23",
          "type": "function"
        },
        "index": {
          "description": "Shift the argument right by the specified number of bits which must be non-negative",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "shiftRL#",
          "normalized": "a b c d GHC Prim.html #t Word Word #-\u003ea b c d GHC Prim.html #t Int Int #-\u003ea b c d GHC Prim.html #t Word Word #",
          "package": "base",
          "partial": "RL",
          "signature": "packages archive doc html GHC Prim.html #t Word Word #-\u003epackages archive doc html GHC Prim.html #t Int Int #-\u003epackages archive doc html GHC Prim.html #t Word Word #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:shiftRL-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003esortWith\u003c/a\u003e\u003c/code\u003e function sorts a list of elements using the\n user supplied function to project something out of each element\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "sortWith",
          "package": "base",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e [a]",
          "source": "src/GHC-Exts.html#sortWith",
          "type": "function"
        },
        "index": {
          "description": "The sortWith function sorts list of elements using the user supplied function to project something out of each element",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "sortWith",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003e[a]",
          "package": "base",
          "partial": "With",
          "signature": "(a-\u003eb)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:sortWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ethe\u003c/a\u003e\u003c/code\u003e ensures that all the elements of the list are identical\n and then returns that unique element\n\u003c/p\u003e",
          "module": "GHC.Exts",
          "name": "the",
          "package": "base",
          "signature": "[a] -\u003e a",
          "source": "src/GHC-Exts.html#the",
          "type": "function"
        },
        "index": {
          "description": "the ensures that all the elements of the list are identical and then returns that unique element",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "the",
          "normalized": "[a]-\u003ea",
          "package": "base",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:the"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use Debug.Trace.traceEvent or Debug.Trace.traceEventIO\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.Exts",
          "name": "traceEvent",
          "package": "base",
          "signature": "String -\u003e IO ()",
          "source": "src/GHC-Exts.html#traceEvent",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use Debug.Trace.traceEvent or Debug.Trace.traceEventIO",
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "traceEvent",
          "normalized": "String-\u003eIO()",
          "package": "base",
          "partial": "Event",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:traceEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "uncheckedIShiftL64#",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt#",
          "source": "src/GHC-Int.html#uncheckedIShiftL64%23",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "uncheckedIShiftL64#",
          "normalized": "a b c d GHC Prim.html #t Int Int #-\u003ea b c d GHC Prim.html #t Int Int #-\u003ea b c d GHC Prim.html #t Int Int #",
          "package": "base",
          "partial": "IShift",
          "signature": "packages archive doc html GHC Prim.html #t Int Int #-\u003epackages archive doc html GHC Prim.html #t Int Int #-\u003epackages archive doc html GHC Prim.html #t Int Int #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:uncheckedIShiftL64-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "uncheckedIShiftRA64#",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt#",
          "source": "src/GHC-Int.html#uncheckedIShiftRA64%23",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "uncheckedIShiftRA64#",
          "normalized": "a b c d GHC Prim.html #t Int Int #-\u003ea b c d GHC Prim.html #t Int Int #-\u003ea b c d GHC Prim.html #t Int Int #",
          "package": "base",
          "partial": "IShift RA",
          "signature": "packages archive doc html GHC Prim.html #t Int Int #-\u003epackages archive doc html GHC Prim.html #t Int Int #-\u003epackages archive doc html GHC Prim.html #t Int Int #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:uncheckedIShiftRA64-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "uncheckedShiftL64#",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Word-35-\"\u003eWord# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Word-35-\"\u003eWord#",
          "source": "src/GHC-Word.html#uncheckedShiftL64%23",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "uncheckedShiftL64#",
          "normalized": "a b c d GHC Prim.html #t Word Word #-\u003ea b c d GHC Prim.html #t Int Int #-\u003ea b c d GHC Prim.html #t Word Word #",
          "package": "base",
          "partial": "Shift",
          "signature": "packages archive doc html GHC Prim.html #t Word Word #-\u003epackages archive doc html GHC Prim.html #t Int Int #-\u003epackages archive doc html GHC Prim.html #t Word Word #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:uncheckedShiftL64-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Exts",
          "name": "uncheckedShiftRL64#",
          "package": "base",
          "signature": "\"/packages/archive///doc/html/GHC-Prim.html#t:Word-35-\"\u003eWord# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Int-35-\"\u003eInt# -\u003e \"/packages/archive///doc/html/GHC-Prim.html#t:Word-35-\"\u003eWord#",
          "source": "src/GHC-Word.html#uncheckedShiftRL64%23",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Exts",
          "module": "GHC.Exts",
          "name": "uncheckedShiftRL64#",
          "normalized": "a b c d GHC Prim.html #t Word Word #-\u003ea b c d GHC Prim.html #t Int Int #-\u003ea b c d GHC Prim.html #t Word Word #",
          "package": "base",
          "partial": "Shift RL",
          "signature": "packages archive doc html GHC Prim.html #t Word Word #-\u003epackages archive doc html GHC Prim.html #t Int Int #-\u003epackages archive doc html GHC Prim.html #t Word Word #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Exts.html#v:uncheckedShiftRL64-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Fingerprint.Type",
          "name": "Type",
          "package": "base",
          "source": "src/GHC-Fingerprint-Type.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "GHC Fingerprint Type",
          "module": "GHC.Fingerprint.Type",
          "name": "Type",
          "package": "base",
          "partial": "Type",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Fingerprint-Type.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Fingerprint.Type",
          "name": "Fingerprint",
          "package": "base",
          "source": "src/GHC-Fingerprint-Type.html#Fingerprint",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC Fingerprint Type",
          "module": "GHC.Fingerprint.Type",
          "name": "Fingerprint",
          "package": "base",
          "partial": "Fingerprint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Fingerprint-Type.html#t:Fingerprint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Fingerprint",
          "name": "Fingerprint",
          "package": "base",
          "source": "src/GHC-Fingerprint.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "GHC Fingerprint",
          "module": "GHC.Fingerprint",
          "name": "Fingerprint",
          "package": "base",
          "partial": "Fingerprint",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Fingerprint.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Fingerprint",
          "name": "Fingerprint",
          "package": "base",
          "source": "src/GHC-Fingerprint-Type.html#Fingerprint",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC Fingerprint",
          "module": "GHC.Fingerprint",
          "name": "Fingerprint",
          "package": "base",
          "partial": "Fingerprint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Fingerprint.html#t:Fingerprint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Fingerprint",
          "name": "fingerprint0",
          "package": "base",
          "signature": "Fingerprint",
          "source": "src/GHC-Fingerprint.html#fingerprint0",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Fingerprint",
          "module": "GHC.Fingerprint",
          "name": "fingerprint0",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Fingerprint.html#v:fingerprint0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Fingerprint",
          "name": "fingerprintData",
          "package": "base",
          "signature": "Ptr Word8 -\u003e Int -\u003e IO Fingerprint",
          "source": "src/GHC-Fingerprint.html#fingerprintData",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Fingerprint",
          "module": "GHC.Fingerprint",
          "name": "fingerprintData",
          "normalized": "Ptr Word-\u003eInt-\u003eIO Fingerprint",
          "package": "base",
          "partial": "Data",
          "signature": "Ptr Word-\u003eInt-\u003eIO Fingerprint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Fingerprint.html#v:fingerprintData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Fingerprint",
          "name": "fingerprintFingerprints",
          "package": "base",
          "signature": "[Fingerprint] -\u003e Fingerprint",
          "source": "src/GHC-Fingerprint.html#fingerprintFingerprints",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Fingerprint",
          "module": "GHC.Fingerprint",
          "name": "fingerprintFingerprints",
          "normalized": "[Fingerprint]-\u003eFingerprint",
          "package": "base",
          "partial": "Fingerprints",
          "signature": "[Fingerprint]-\u003eFingerprint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Fingerprint.html#v:fingerprintFingerprints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Fingerprint",
          "name": "fingerprintString",
          "package": "base",
          "signature": "String -\u003e Fingerprint",
          "source": "src/GHC-Fingerprint.html#fingerprintString",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Fingerprint",
          "module": "GHC.Fingerprint",
          "name": "fingerprintString",
          "normalized": "String-\u003eFingerprint",
          "package": "base",
          "partial": "String",
          "signature": "String-\u003eFingerprint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Fingerprint.html#v:fingerprintString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eForeign marshalling support for CStrings with configurable encodings\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.Foreign",
          "name": "Foreign",
          "package": "base",
          "source": "src/GHC-Foreign.html",
          "type": "module"
        },
        "index": {
          "description": "Foreign marshalling support for CStrings with configurable encodings",
          "hierarchy": "GHC Foreign",
          "module": "GHC.Foreign",
          "name": "Foreign",
          "package": "base",
          "partial": "Foreign",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Foreign.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermines whether a character can be accurately encoded in a \u003ccode\u003eCString\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003ePretty much anyone who uses this function is in a state of sin because\n whether or not a character is encodable will, in general, depend on the\n context in which it occurs.\n\u003c/p\u003e",
          "module": "GHC.Foreign",
          "name": "charIsRepresentable",
          "package": "base",
          "signature": "TextEncoding -\u003e Char -\u003e IO Bool",
          "source": "src/GHC-Foreign.html#charIsRepresentable",
          "type": "function"
        },
        "index": {
          "description": "Determines whether character can be accurately encoded in CString Pretty much anyone who uses this function is in state of sin because whether or not character is encodable will in general depend on the context in which it occurs",
          "hierarchy": "GHC Foreign",
          "module": "GHC.Foreign",
          "name": "charIsRepresentable",
          "normalized": "TextEncoding-\u003eChar-\u003eIO Bool",
          "package": "base",
          "partial": "Is Representable",
          "signature": "TextEncoding-\u003eChar-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Foreign.html#v:charIsRepresentable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a NUL terminated C string.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the Haskell string may \u003cem\u003enot\u003c/em\u003e contain any NUL characters\n\u003c/li\u003e\u003cli\u003e new storage is allocated for the C string and must be\n   explicitly freed using \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e or\n   \u003ccode\u003e\u003ca\u003efinalizerFree\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "GHC.Foreign",
          "name": "newCString",
          "package": "base",
          "signature": "TextEncoding -\u003e String -\u003e IO CString",
          "source": "src/GHC-Foreign.html#newCString",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into NUL terminated string the Haskell string may not contain any NUL characters new storage is allocated for the string and must be explicitly freed using free or finalizerFree",
          "hierarchy": "GHC Foreign",
          "module": "GHC.Foreign",
          "name": "newCString",
          "normalized": "TextEncoding-\u003eString-\u003eIO CString",
          "package": "base",
          "partial": "CString",
          "signature": "TextEncoding-\u003eString-\u003eIO CString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Foreign.html#v:newCString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a C string (ie, character array) with\n explicit length information.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e new storage is allocated for the C string and must be\n   explicitly freed using \u003ccode\u003e\u003ca\u003efree\u003c/a\u003e\u003c/code\u003e or\n   \u003ccode\u003e\u003ca\u003efinalizerFree\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "GHC.Foreign",
          "name": "newCStringLen",
          "package": "base",
          "signature": "TextEncoding -\u003e String -\u003e IO CStringLen",
          "source": "src/GHC-Foreign.html#newCStringLen",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into string ie character array with explicit length information new storage is allocated for the string and must be explicitly freed using free or finalizerFree",
          "hierarchy": "GHC Foreign",
          "module": "GHC.Foreign",
          "name": "newCStringLen",
          "normalized": "TextEncoding-\u003eString-\u003eIO CStringLen",
          "package": "base",
          "partial": "CString Len",
          "signature": "TextEncoding-\u003eString-\u003eIO CStringLen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Foreign.html#v:newCStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a NUL terminated C string into a Haskell string.\n\u003c/p\u003e",
          "module": "GHC.Foreign",
          "name": "peekCString",
          "package": "base",
          "signature": "TextEncoding -\u003e CString -\u003e IO String",
          "source": "src/GHC-Foreign.html#peekCString",
          "type": "function"
        },
        "index": {
          "description": "Marshal NUL terminated string into Haskell string",
          "hierarchy": "GHC Foreign",
          "module": "GHC.Foreign",
          "name": "peekCString",
          "normalized": "TextEncoding-\u003eCString-\u003eIO String",
          "package": "base",
          "partial": "CString",
          "signature": "TextEncoding-\u003eCString-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Foreign.html#v:peekCString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a C string with explicit length into a Haskell string.\n\u003c/p\u003e",
          "module": "GHC.Foreign",
          "name": "peekCStringLen",
          "package": "base",
          "signature": "TextEncoding -\u003e CStringLen -\u003e IO String",
          "source": "src/GHC-Foreign.html#peekCStringLen",
          "type": "function"
        },
        "index": {
          "description": "Marshal string with explicit length into Haskell string",
          "hierarchy": "GHC Foreign",
          "module": "GHC.Foreign",
          "name": "peekCStringLen",
          "normalized": "TextEncoding-\u003eCStringLen-\u003eIO String",
          "package": "base",
          "partial": "CString Len",
          "signature": "TextEncoding-\u003eCStringLen-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Foreign.html#v:peekCStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a NUL terminated C string using temporary\n storage.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the Haskell string may \u003cem\u003enot\u003c/em\u003e contain any NUL characters\n\u003c/li\u003e\u003cli\u003e the memory is freed when the subcomputation terminates (either\n   normally or via an exception), so the pointer to the temporary\n   storage must \u003cem\u003enot\u003c/em\u003e be used after this.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "GHC.Foreign",
          "name": "withCString",
          "package": "base",
          "signature": "TextEncoding -\u003e String -\u003e (CString -\u003e IO a) -\u003e IO a",
          "source": "src/GHC-Foreign.html#withCString",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into NUL terminated string using temporary storage the Haskell string may not contain any NUL characters the memory is freed when the subcomputation terminates either normally or via an exception so the pointer to the temporary storage must not be used after this",
          "hierarchy": "GHC Foreign",
          "module": "GHC.Foreign",
          "name": "withCString",
          "normalized": "TextEncoding-\u003eString-\u003e(CString-\u003eIO a)-\u003eIO a",
          "package": "base",
          "partial": "CString",
          "signature": "TextEncoding-\u003eString-\u003e(CString-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Foreign.html#v:withCString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarshal a Haskell string into a C string (ie, character array)\n in temporary storage, with explicit length information.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the memory is freed when the subcomputation terminates (either\n   normally or via an exception), so the pointer to the temporary\n   storage must \u003cem\u003enot\u003c/em\u003e be used after this.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "GHC.Foreign",
          "name": "withCStringLen",
          "package": "base",
          "signature": "TextEncoding -\u003e String -\u003e (CStringLen -\u003e IO a) -\u003e IO a",
          "source": "src/GHC-Foreign.html#withCStringLen",
          "type": "function"
        },
        "index": {
          "description": "Marshal Haskell string into string ie character array in temporary storage with explicit length information the memory is freed when the subcomputation terminates either normally or via an exception so the pointer to the temporary storage must not be used after this",
          "hierarchy": "GHC Foreign",
          "module": "GHC.Foreign",
          "name": "withCStringLen",
          "normalized": "TextEncoding-\u003eString-\u003e(CStringLen-\u003eIO a)-\u003eIO a",
          "package": "base",
          "partial": "CString Len",
          "signature": "TextEncoding-\u003eString-\u003e(CStringLen-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Foreign.html#v:withCStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "Generics",
          "package": "base",
          "source": "src/GHC-Generics.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Generics",
          "package": "base",
          "partial": "Generics",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProducts: encode multiple arguments to constructors\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": ":*:",
          "package": "base",
          "source": "src/GHC-Generics.html#%3A%2A%3A",
          "type": "data"
        },
        "index": {
          "description": "Products encode multiple arguments to constructors",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": ":*:",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSums: encode choice between constructors\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": ":+:",
          "package": "base",
          "source": "src/GHC-Generics.html#%3A%2B%3A",
          "type": "data"
        },
        "index": {
          "description": "Sums encode choice between constructors",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": ":+:",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t::-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposition of functors\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": ":.:",
          "package": "base",
          "source": "src/GHC-Generics.html#%3A.%3A",
          "type": "newtype"
        },
        "index": {
          "description": "Composition of functors",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": ":.:",
          "package": "base",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t::.:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDatatype to represent the arity of a tuple.\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "Arity",
          "package": "base",
          "source": "src/GHC-Generics.html#Arity",
          "type": "data"
        },
        "index": {
          "description": "Datatype to represent the arity of tuple",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Arity",
          "package": "base",
          "partial": "Arity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:Arity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDatatype to represent the associativity of a constructor\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "Associativity",
          "package": "base",
          "source": "src/GHC-Generics.html#Associativity",
          "type": "data"
        },
        "index": {
          "description": "Datatype to represent the associativity of constructor",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Associativity",
          "package": "base",
          "partial": "Associativity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:Associativity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTag for M1: constructor\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "C",
          "package": "base",
          "source": "src/GHC-Generics.html#C",
          "type": "data"
        },
        "index": {
          "description": "Tag for M1 constructor",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "C",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType synonym for encoding meta-information for constructors\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "C1",
          "package": "base",
          "source": "src/GHC-Generics.html#C1",
          "type": "type"
        },
        "index": {
          "description": "Type synonym for encoding meta-information for constructors",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "C1",
          "package": "base",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:C1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass for datatypes that represent data constructors\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "Constructor",
          "package": "base",
          "source": "src/GHC-Generics.html#Constructor",
          "type": "class"
        },
        "index": {
          "description": "Class for datatypes that represent data constructors",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Constructor",
          "package": "base",
          "partial": "Constructor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:Constructor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTag for M1: datatype\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "D",
          "package": "base",
          "source": "src/GHC-Generics.html#D",
          "type": "data"
        },
        "index": {
          "description": "Tag for M1 datatype",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "D",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType synonym for encoding meta-information for datatypes\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "D1",
          "package": "base",
          "source": "src/GHC-Generics.html#D1",
          "type": "type"
        },
        "index": {
          "description": "Type synonym for encoding meta-information for datatypes",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "D1",
          "package": "base",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:D1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass for datatypes that represent datatypes\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "Datatype",
          "package": "base",
          "source": "src/GHC-Generics.html#Datatype",
          "type": "class"
        },
        "index": {
          "description": "Class for datatypes that represent datatypes",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Datatype",
          "package": "base",
          "partial": "Datatype",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:Datatype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDatatype to represent the fixity of a constructor. An infix\n | declaration directly corresponds to an application of \u003ccode\u003e\u003ca\u003eInfix\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "Fixity",
          "package": "base",
          "source": "src/GHC-Generics.html#Fixity",
          "type": "data"
        },
        "index": {
          "description": "Datatype to represent the fixity of constructor An infix declaration directly corresponds to an application of Infix",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Fixity",
          "package": "base",
          "partial": "Fixity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:Fixity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresentable types of kind *.\n This class is derivable in GHC with the DeriveGeneric flag on.\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "Generic",
          "package": "base",
          "source": "src/GHC-Generics.html#Generic",
          "type": "class"
        },
        "index": {
          "description": "Representable types of kind This class is derivable in GHC with the DeriveGeneric flag on",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Generic",
          "package": "base",
          "partial": "Generic",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:Generic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresentable types of kind * -\u003e *.\n This class is derivable in GHC with the DeriveGeneric flag on.\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "Generic1",
          "package": "base",
          "source": "src/GHC-Generics.html#Generic1",
          "type": "class"
        },
        "index": {
          "description": "Representable types of kind This class is derivable in GHC with the DeriveGeneric flag on",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Generic1",
          "package": "base",
          "partial": "Generic",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:Generic1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstants, additional parameters and recursion of kind *\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "K1",
          "package": "base",
          "source": "src/GHC-Generics.html#K1",
          "type": "newtype"
        },
        "index": {
          "description": "Constants additional parameters and recursion of kind",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "K1",
          "package": "base",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:K1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMeta-information (constructor names, etc.)\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "M1",
          "package": "base",
          "source": "src/GHC-Generics.html#M1",
          "type": "newtype"
        },
        "index": {
          "description": "Meta-information constructor names etc",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "M1",
          "package": "base",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:M1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed for constructor fields without a name\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "NoSelector",
          "package": "base",
          "source": "src/GHC-Generics.html#NoSelector",
          "type": "data"
        },
        "index": {
          "description": "Used for constructor fields without name",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "NoSelector",
          "package": "base",
          "partial": "No Selector",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:NoSelector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: P is no longer used; use R instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eTag for K1: parameters (other than the last)\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "P",
          "package": "base",
          "source": "src/GHC-Generics.html#P",
          "type": "data"
        },
        "index": {
          "description": "Deprecated is no longer used use instead Tag for K1 parameters other than the last",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "P",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Par0 is no longer used; use Rec0 instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eType synonym for encoding parameters (other than the last)\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "Par0",
          "package": "base",
          "source": "src/GHC-Generics.html#Par0",
          "type": "type"
        },
        "index": {
          "description": "Deprecated Par0 is no longer used use Rec0 instead Type synonym for encoding parameters other than the last",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Par0",
          "package": "base",
          "partial": "Par",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:Par0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed for marking occurrences of the parameter\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "Par1",
          "package": "base",
          "source": "src/GHC-Generics.html#Par1",
          "type": "newtype"
        },
        "index": {
          "description": "Used for marking occurrences of the parameter",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Par1",
          "package": "base",
          "partial": "Par",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:Par1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTag for K1: recursion (of kind *)\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "R",
          "package": "base",
          "source": "src/GHC-Generics.html#R",
          "type": "data"
        },
        "index": {
          "description": "Tag for K1 recursion of kind",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "R",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType synonym for encoding recursion (of kind *)\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "Rec0",
          "package": "base",
          "source": "src/GHC-Generics.html#Rec0",
          "type": "type"
        },
        "index": {
          "description": "Type synonym for encoding recursion of kind",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Rec0",
          "package": "base",
          "partial": "Rec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:Rec0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecursive calls of kind * -\u003e *\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "Rec1",
          "package": "base",
          "source": "src/GHC-Generics.html#Rec1",
          "type": "newtype"
        },
        "index": {
          "description": "Recursive calls of kind",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Rec1",
          "package": "base",
          "partial": "Rec",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:Rec1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTag for M1: record selector\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "S",
          "package": "base",
          "source": "src/GHC-Generics.html#S",
          "type": "data"
        },
        "index": {
          "description": "Tag for M1 record selector",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "S",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType synonym for encoding meta-information for record selectors\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "S1",
          "package": "base",
          "source": "src/GHC-Generics.html#S1",
          "type": "type"
        },
        "index": {
          "description": "Type synonym for encoding meta-information for record selectors",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "S1",
          "package": "base",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:S1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass for datatypes that represent records\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "Selector",
          "package": "base",
          "source": "src/GHC-Generics.html#Selector",
          "type": "class"
        },
        "index": {
          "description": "Class for datatypes that represent records",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Selector",
          "package": "base",
          "partial": "Selector",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:Selector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnit: used for constructors without arguments\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "U1",
          "package": "base",
          "source": "src/GHC-Generics.html#U1",
          "type": "data"
        },
        "index": {
          "description": "Unit used for constructors without arguments",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "U1",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:U1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVoid: used for datatypes without constructors\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "V1",
          "package": "base",
          "source": "src/GHC-Generics.html#V1",
          "type": "data"
        },
        "index": {
          "description": "Void used for datatypes without constructors",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "V1",
          "package": "base",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#t:V1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": ":*:",
          "package": "base",
          "signature": "(f p) :*: (g p)",
          "source": "src/GHC-Generics.html#%3A%2A%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": ":*:",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "Arity",
          "package": "base",
          "signature": "Arity Int",
          "source": "src/GHC-Generics.html#Arity",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Arity",
          "package": "base",
          "partial": "Arity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:Arity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "Comp1",
          "package": "base",
          "signature": "Comp1",
          "source": "src/GHC-Generics.html#%3A.%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Comp1",
          "package": "base",
          "partial": "Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:Comp1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "Infix",
          "package": "base",
          "signature": "Infix Associativity Int",
          "source": "src/GHC-Generics.html#Fixity",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Infix",
          "package": "base",
          "partial": "Infix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:Infix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "K1",
          "package": "base",
          "signature": "K1",
          "source": "src/GHC-Generics.html#K1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "K1",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:K1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "L1",
          "package": "base",
          "signature": "L1 (f p)",
          "source": "src/GHC-Generics.html#%3A%2B%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "L1",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:L1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "LeftAssociative",
          "package": "base",
          "signature": "LeftAssociative",
          "source": "src/GHC-Generics.html#Associativity",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "LeftAssociative",
          "package": "base",
          "partial": "Left Associative",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:LeftAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "M1",
          "package": "base",
          "signature": "M1",
          "source": "src/GHC-Generics.html#M1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "M1",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:M1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "NoArity",
          "package": "base",
          "signature": "NoArity",
          "source": "src/GHC-Generics.html#Arity",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "NoArity",
          "package": "base",
          "partial": "No Arity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:NoArity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "NotAssociative",
          "package": "base",
          "signature": "NotAssociative",
          "source": "src/GHC-Generics.html#Associativity",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "NotAssociative",
          "package": "base",
          "partial": "Not Associative",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:NotAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "Par1",
          "package": "base",
          "signature": "Par1",
          "source": "src/GHC-Generics.html#Par1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Par1",
          "package": "base",
          "partial": "Par",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:Par1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "Prefix",
          "package": "base",
          "signature": "Prefix",
          "source": "src/GHC-Generics.html#Fixity",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Prefix",
          "package": "base",
          "partial": "Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:Prefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "R1",
          "package": "base",
          "signature": "R1 (g p)",
          "source": "src/GHC-Generics.html#%3A%2B%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "R1",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:R1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "Rec1",
          "package": "base",
          "signature": "Rec1",
          "source": "src/GHC-Generics.html#Rec1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "Rec1",
          "package": "base",
          "partial": "Rec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:Rec1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "RightAssociative",
          "package": "base",
          "signature": "RightAssociative",
          "source": "src/GHC-Generics.html#Associativity",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "RightAssociative",
          "package": "base",
          "partial": "Right Associative",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:RightAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "U1",
          "package": "base",
          "signature": "U1",
          "source": "src/GHC-Generics.html#U1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "U1",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:U1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe fixity of the constructor\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "conFixity",
          "package": "base",
          "signature": "* -\u003e *) a -\u003e Fixity",
          "source": "src/GHC-Generics.html#conFixity",
          "type": "method"
        },
        "index": {
          "description": "The fixity of the constructor",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "conFixity",
          "normalized": "*-\u003e*)a-\u003eFixity",
          "package": "base",
          "partial": "Fixity",
          "signature": "*-\u003e*)a-\u003eFixity",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:conFixity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarks if this constructor is a record\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "conIsRecord",
          "package": "base",
          "signature": "* -\u003e *) a -\u003e Bool",
          "source": "src/GHC-Generics.html#conIsRecord",
          "type": "method"
        },
        "index": {
          "description": "Marks if this constructor is record",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "conIsRecord",
          "normalized": "*-\u003e*)a-\u003eBool",
          "package": "base",
          "partial": "Is Record",
          "signature": "*-\u003e*)a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:conIsRecord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of the constructor\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "conName",
          "package": "base",
          "signature": "* -\u003e *) a -\u003e [Char]",
          "source": "src/GHC-Generics.html#conName",
          "type": "method"
        },
        "index": {
          "description": "The name of the constructor",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "conName",
          "normalized": "*-\u003e*)a-\u003e[Char]",
          "package": "base",
          "partial": "Name",
          "signature": "*-\u003e*)a-\u003e[Char]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:conName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of the datatype (unqualified)\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "datatypeName",
          "package": "base",
          "signature": "* -\u003e *) a -\u003e [Char]",
          "source": "src/GHC-Generics.html#datatypeName",
          "type": "method"
        },
        "index": {
          "description": "The name of the datatype unqualified",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "datatypeName",
          "normalized": "*-\u003e*)a-\u003e[Char]",
          "package": "base",
          "partial": "Name",
          "signature": "*-\u003e*)a-\u003e[Char]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:datatypeName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from the datatype to its representation\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "from",
          "package": "base",
          "signature": "a -\u003e Rep a x",
          "source": "src/GHC-Generics.html#from",
          "type": "method"
        },
        "index": {
          "description": "Convert from the datatype to its representation",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "from",
          "normalized": "a-\u003eRep a b",
          "package": "base",
          "signature": "a-\u003eRep a x",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:from"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from the datatype to its representation\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "from1",
          "package": "base",
          "signature": "f a -\u003e Rep1 f a",
          "source": "src/GHC-Generics.html#from1",
          "type": "method"
        },
        "index": {
          "description": "Convert from the datatype to its representation",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "from1",
          "normalized": "a b-\u003eRep a b",
          "package": "base",
          "signature": "f a-\u003eRep f a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:from1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe fully-qualified name of the module where the type is declared\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "moduleName",
          "package": "base",
          "signature": "* -\u003e *) a -\u003e [Char]",
          "source": "src/GHC-Generics.html#moduleName",
          "type": "method"
        },
        "index": {
          "description": "The fully-qualified name of the module where the type is declared",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "moduleName",
          "normalized": "*-\u003e*)a-\u003e[Char]",
          "package": "base",
          "partial": "Name",
          "signature": "*-\u003e*)a-\u003e[Char]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:moduleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the precedence of a fixity value.\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "prec",
          "package": "base",
          "signature": "Fixity -\u003e Int",
          "source": "src/GHC-Generics.html#prec",
          "type": "function"
        },
        "index": {
          "description": "Get the precedence of fixity value",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "prec",
          "normalized": "Fixity-\u003eInt",
          "package": "base",
          "signature": "Fixity-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:prec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of the selector\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "selName",
          "package": "base",
          "signature": "* -\u003e *) a -\u003e [Char]",
          "source": "src/GHC-Generics.html#selName",
          "type": "method"
        },
        "index": {
          "description": "The name of the selector",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "selName",
          "normalized": "*-\u003e*)a-\u003e[Char]",
          "package": "base",
          "partial": "Name",
          "signature": "*-\u003e*)a-\u003e[Char]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:selName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from the representation to the datatype\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "to",
          "package": "base",
          "signature": "Rep a x -\u003e a",
          "source": "src/GHC-Generics.html#to",
          "type": "method"
        },
        "index": {
          "description": "Convert from the representation to the datatype",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "to",
          "normalized": "Rep a b-\u003ea",
          "package": "base",
          "signature": "Rep a x-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:to"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from the representation to the datatype\n\u003c/p\u003e",
          "module": "GHC.Generics",
          "name": "to1",
          "package": "base",
          "signature": "Rep1 f a -\u003e f a",
          "source": "src/GHC-Generics.html#to1",
          "type": "method"
        },
        "index": {
          "description": "Convert from the representation to the datatype",
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "to1",
          "normalized": "Rep a b-\u003ea b",
          "package": "base",
          "signature": "Rep f a-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:to1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "unComp1",
          "package": "base",
          "signature": "f (g p)",
          "source": "src/GHC-Generics.html#%3A.%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "unComp1",
          "package": "base",
          "partial": "Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:unComp1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "unK1",
          "package": "base",
          "signature": "c",
          "source": "src/GHC-Generics.html#K1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "unK1",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:unK1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "unM1",
          "package": "base",
          "signature": "f p",
          "source": "src/GHC-Generics.html#M1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "unM1",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:unM1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "unPar1",
          "package": "base",
          "signature": "p",
          "source": "src/GHC-Generics.html#Par1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "unPar1",
          "package": "base",
          "partial": "Par",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:unPar1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Generics",
          "name": "unRec1",
          "package": "base",
          "signature": "f p",
          "source": "src/GHC-Generics.html#Rec1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Generics",
          "module": "GHC.Generics",
          "name": "unRec1",
          "package": "base",
          "partial": "Rec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Generics.html#v:unRec1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBuffers used in the IO system\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.IO.Buffer",
          "name": "Buffer",
          "package": "base",
          "source": "src/GHC-IO-Buffer.html",
          "type": "module"
        },
        "index": {
          "description": "Buffers used in the IO system",
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "Buffer",
          "package": "base",
          "partial": "Buffer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA mutable array of bytes that can be passed to foreign functions.\n\u003c/p\u003e\u003cp\u003eThe buffer is represented by a record, where the record contains\n the raw buffer and the start/end points of the filled portion.  The\n buffer contents itself is mutable, but the rest of the record is\n immutable.  This is a slightly odd mix, but it turns out to be\n quite practical: by making all the buffer metadata immutable, we\n can have operations on buffer metadata outside of the IO monad.\n\u003c/p\u003e\u003cp\u003eThe \u003ca\u003elive\u003c/a\u003e elements of the buffer are those between the \u003ccode\u003e\u003ca\u003ebufL\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003ebufR\u003c/a\u003e\u003c/code\u003e offsets.  In an empty buffer, \u003ccode\u003e\u003ca\u003ebufL\u003c/a\u003e\u003c/code\u003e is equal to \u003ccode\u003e\u003ca\u003ebufR\u003c/a\u003e\u003c/code\u003e, but\n they might not be zero: for exmaple, the buffer might correspond to\n a memory-mapped file and in which case \u003ccode\u003e\u003ca\u003ebufL\u003c/a\u003e\u003c/code\u003e will point to the\n next location to be written, which is not necessarily the beginning\n of the file.\n\u003c/p\u003e",
          "module": "GHC.IO.Buffer",
          "name": "Buffer",
          "package": "base",
          "source": "src/GHC-IO-Buffer.html#Buffer",
          "type": "data"
        },
        "index": {
          "description": "mutable array of bytes that can be passed to foreign functions The buffer is represented by record where the record contains the raw buffer and the start end points of the filled portion The buffer contents itself is mutable but the rest of the record is immutable This is slightly odd mix but it turns out to be quite practical by making all the buffer metadata immutable we can have operations on buffer metadata outside of the IO monad The live elements of the buffer are those between the bufL and bufR offsets In an empty buffer bufL is equal to bufR but they might not be zero for exmaple the buffer might correspond to memory-mapped file and in which case bufL will point to the next location to be written which is not necessarily the beginning of the file",
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "Buffer",
          "package": "base",
          "partial": "Buffer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#t:Buffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "BufferState",
          "package": "base",
          "source": "src/GHC-IO-Buffer.html#BufferState",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "BufferState",
          "package": "base",
          "partial": "Buffer State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#t:BufferState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "CharBufElem",
          "package": "base",
          "source": "src/GHC-IO-Buffer.html#CharBufElem",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "CharBufElem",
          "package": "base",
          "partial": "Char Buf Elem",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#t:CharBufElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "CharBuffer",
          "package": "base",
          "source": "src/GHC-IO-Buffer.html#CharBuffer",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "CharBuffer",
          "package": "base",
          "partial": "Char Buffer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#t:CharBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "RawBuffer",
          "package": "base",
          "source": "src/GHC-IO-Buffer.html#RawBuffer",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "RawBuffer",
          "package": "base",
          "partial": "Raw Buffer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#t:RawBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "RawCharBuffer",
          "package": "base",
          "source": "src/GHC-IO-Buffer.html#RawCharBuffer",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "RawCharBuffer",
          "package": "base",
          "partial": "Raw Char Buffer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#t:RawCharBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "Buffer",
          "package": "base",
          "signature": "Buffer",
          "source": "src/GHC-IO-Buffer.html#Buffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "Buffer",
          "package": "base",
          "partial": "Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:Buffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "ReadBuffer",
          "package": "base",
          "signature": "ReadBuffer",
          "source": "src/GHC-IO-Buffer.html#BufferState",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "ReadBuffer",
          "package": "base",
          "partial": "Read Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:ReadBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "WriteBuffer",
          "package": "base",
          "signature": "WriteBuffer",
          "source": "src/GHC-IO-Buffer.html#BufferState",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "WriteBuffer",
          "package": "base",
          "partial": "Write Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:WriteBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "bufL",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-IO-Buffer.html#Buffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "bufL",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:bufL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "bufR",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-IO-Buffer.html#Buffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "bufR",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:bufR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "bufRaw",
          "package": "base",
          "signature": "(RawBuffer e)",
          "source": "src/GHC-IO-Buffer.html#Buffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "bufRaw",
          "package": "base",
          "partial": "Raw",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:bufRaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "bufSize",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-IO-Buffer.html#Buffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "bufSize",
          "package": "base",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:bufSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "bufState",
          "package": "base",
          "signature": "BufferState",
          "source": "src/GHC-IO-Buffer.html#Buffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "bufState",
          "package": "base",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:bufState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "bufferAdd",
          "package": "base",
          "signature": "Int -\u003e Buffer e -\u003e Buffer e",
          "source": "src/GHC-IO-Buffer.html#bufferAdd",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "bufferAdd",
          "normalized": "Int-\u003eBuffer a-\u003eBuffer a",
          "package": "base",
          "partial": "Add",
          "signature": "Int-\u003eBuffer e-\u003eBuffer e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:bufferAdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "bufferAdjustL",
          "package": "base",
          "signature": "Int -\u003e Buffer e -\u003e Buffer e",
          "source": "src/GHC-IO-Buffer.html#bufferAdjustL",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "bufferAdjustL",
          "normalized": "Int-\u003eBuffer a-\u003eBuffer a",
          "package": "base",
          "partial": "Adjust",
          "signature": "Int-\u003eBuffer e-\u003eBuffer e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:bufferAdjustL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "bufferAvailable",
          "package": "base",
          "signature": "Buffer e -\u003e Int",
          "source": "src/GHC-IO-Buffer.html#bufferAvailable",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "bufferAvailable",
          "normalized": "Buffer a-\u003eInt",
          "package": "base",
          "partial": "Available",
          "signature": "Buffer e-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:bufferAvailable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "bufferElems",
          "package": "base",
          "signature": "Buffer e -\u003e Int",
          "source": "src/GHC-IO-Buffer.html#bufferElems",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "bufferElems",
          "normalized": "Buffer a-\u003eInt",
          "package": "base",
          "partial": "Elems",
          "signature": "Buffer e-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:bufferElems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "bufferRemove",
          "package": "base",
          "signature": "Int -\u003e Buffer e -\u003e Buffer e",
          "source": "src/GHC-IO-Buffer.html#bufferRemove",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "bufferRemove",
          "normalized": "Int-\u003eBuffer a-\u003eBuffer a",
          "package": "base",
          "partial": "Remove",
          "signature": "Int-\u003eBuffer e-\u003eBuffer e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:bufferRemove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "charSize",
          "package": "base",
          "signature": "Int",
          "source": "src/GHC-IO-Buffer.html#charSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "charSize",
          "package": "base",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:charSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "checkBuffer",
          "package": "base",
          "signature": "Buffer a -\u003e IO ()",
          "source": "src/GHC-IO-Buffer.html#checkBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "checkBuffer",
          "normalized": "Buffer a-\u003eIO()",
          "package": "base",
          "partial": "Buffer",
          "signature": "Buffer a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:checkBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "emptyBuffer",
          "package": "base",
          "signature": "RawBuffer e -\u003e Int -\u003e BufferState -\u003e Buffer e",
          "source": "src/GHC-IO-Buffer.html#emptyBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "emptyBuffer",
          "normalized": "RawBuffer a-\u003eInt-\u003eBufferState-\u003eBuffer a",
          "package": "base",
          "partial": "Buffer",
          "signature": "RawBuffer e-\u003eInt-\u003eBufferState-\u003eBuffer e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:emptyBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "isEmptyBuffer",
          "package": "base",
          "signature": "Buffer e -\u003e Bool",
          "source": "src/GHC-IO-Buffer.html#isEmptyBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "isEmptyBuffer",
          "normalized": "Buffer a-\u003eBool",
          "package": "base",
          "partial": "Empty Buffer",
          "signature": "Buffer e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:isEmptyBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "isFullBuffer",
          "package": "base",
          "signature": "Buffer e -\u003e Bool",
          "source": "src/GHC-IO-Buffer.html#isFullBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "isFullBuffer",
          "normalized": "Buffer a-\u003eBool",
          "package": "base",
          "partial": "Full Buffer",
          "signature": "Buffer e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:isFullBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "isFullCharBuffer",
          "package": "base",
          "signature": "Buffer e -\u003e Bool",
          "source": "src/GHC-IO-Buffer.html#isFullCharBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "isFullCharBuffer",
          "normalized": "Buffer a-\u003eBool",
          "package": "base",
          "partial": "Full Char Buffer",
          "signature": "Buffer e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:isFullCharBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "isWriteBuffer",
          "package": "base",
          "signature": "Buffer e -\u003e Bool",
          "source": "src/GHC-IO-Buffer.html#isWriteBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "isWriteBuffer",
          "normalized": "Buffer a-\u003eBool",
          "package": "base",
          "partial": "Write Buffer",
          "signature": "Buffer e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:isWriteBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "newBuffer",
          "package": "base",
          "signature": "Int -\u003e Int -\u003e BufferState -\u003e IO (Buffer e)",
          "source": "src/GHC-IO-Buffer.html#newBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "newBuffer",
          "normalized": "Int-\u003eInt-\u003eBufferState-\u003eIO(Buffer a)",
          "package": "base",
          "partial": "Buffer",
          "signature": "Int-\u003eInt-\u003eBufferState-\u003eIO(Buffer e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:newBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "newByteBuffer",
          "package": "base",
          "signature": "Int -\u003e BufferState -\u003e IO (Buffer Word8)",
          "source": "src/GHC-IO-Buffer.html#newByteBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "newByteBuffer",
          "normalized": "Int-\u003eBufferState-\u003eIO(Buffer Word)",
          "package": "base",
          "partial": "Byte Buffer",
          "signature": "Int-\u003eBufferState-\u003eIO(Buffer Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:newByteBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "newCharBuffer",
          "package": "base",
          "signature": "Int -\u003e BufferState -\u003e IO CharBuffer",
          "source": "src/GHC-IO-Buffer.html#newCharBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "newCharBuffer",
          "normalized": "Int-\u003eBufferState-\u003eIO CharBuffer",
          "package": "base",
          "partial": "Char Buffer",
          "signature": "Int-\u003eBufferState-\u003eIO CharBuffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:newCharBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "peekCharBuf",
          "package": "base",
          "signature": "RawCharBuffer -\u003e Int -\u003e IO Char",
          "source": "src/GHC-IO-Buffer.html#peekCharBuf",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "peekCharBuf",
          "normalized": "RawCharBuffer-\u003eInt-\u003eIO Char",
          "package": "base",
          "partial": "Char Buf",
          "signature": "RawCharBuffer-\u003eInt-\u003eIO Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:peekCharBuf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "readCharBuf",
          "package": "base",
          "signature": "RawCharBuffer -\u003e Int -\u003e IO (Char, Int)",
          "source": "src/GHC-IO-Buffer.html#readCharBuf",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "readCharBuf",
          "normalized": "RawCharBuffer-\u003eInt-\u003eIO(Char,Int)",
          "package": "base",
          "partial": "Char Buf",
          "signature": "RawCharBuffer-\u003eInt-\u003eIO(Char,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:readCharBuf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "readCharBufPtr",
          "package": "base",
          "signature": "Ptr CharBufElem -\u003e Int -\u003e IO (Char, Int)",
          "source": "src/GHC-IO-Buffer.html#readCharBufPtr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "readCharBufPtr",
          "normalized": "Ptr CharBufElem-\u003eInt-\u003eIO(Char,Int)",
          "package": "base",
          "partial": "Char Buf Ptr",
          "signature": "Ptr CharBufElem-\u003eInt-\u003eIO(Char,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:readCharBufPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "readWord8Buf",
          "package": "base",
          "signature": "RawBuffer Word8 -\u003e Int -\u003e IO Word8",
          "source": "src/GHC-IO-Buffer.html#readWord8Buf",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "readWord8Buf",
          "normalized": "RawBuffer Word-\u003eInt-\u003eIO Word",
          "package": "base",
          "partial": "Word Buf",
          "signature": "RawBuffer Word-\u003eInt-\u003eIO Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:readWord8Buf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eslides the contents of the buffer to the beginning\n\u003c/p\u003e",
          "module": "GHC.IO.Buffer",
          "name": "slideContents",
          "package": "base",
          "signature": "Buffer Word8 -\u003e IO (Buffer Word8)",
          "source": "src/GHC-IO-Buffer.html#slideContents",
          "type": "function"
        },
        "index": {
          "description": "slides the contents of the buffer to the beginning",
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "slideContents",
          "normalized": "Buffer Word-\u003eIO(Buffer Word)",
          "package": "base",
          "partial": "Contents",
          "signature": "Buffer Word-\u003eIO(Buffer Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:slideContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "summaryBuffer",
          "package": "base",
          "signature": "Buffer a -\u003e String",
          "source": "src/GHC-IO-Buffer.html#summaryBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "summaryBuffer",
          "normalized": "Buffer a-\u003eString",
          "package": "base",
          "partial": "Buffer",
          "signature": "Buffer a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:summaryBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "withBuffer",
          "package": "base",
          "signature": "Buffer e -\u003e (Ptr e -\u003e IO a) -\u003e IO a",
          "source": "src/GHC-IO-Buffer.html#withBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "withBuffer",
          "normalized": "Buffer a-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "partial": "Buffer",
          "signature": "Buffer e-\u003e(Ptr e-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:withBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "withRawBuffer",
          "package": "base",
          "signature": "RawBuffer e -\u003e (Ptr e -\u003e IO a) -\u003e IO a",
          "source": "src/GHC-IO-Buffer.html#withRawBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "withRawBuffer",
          "normalized": "RawBuffer a-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
          "package": "base",
          "partial": "Raw Buffer",
          "signature": "RawBuffer e-\u003e(Ptr e-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:withRawBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "writeCharBuf",
          "package": "base",
          "signature": "RawCharBuffer -\u003e Int -\u003e Char -\u003e IO Int",
          "source": "src/GHC-IO-Buffer.html#writeCharBuf",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "writeCharBuf",
          "normalized": "RawCharBuffer-\u003eInt-\u003eChar-\u003eIO Int",
          "package": "base",
          "partial": "Char Buf",
          "signature": "RawCharBuffer-\u003eInt-\u003eChar-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:writeCharBuf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "writeCharBufPtr",
          "package": "base",
          "signature": "Ptr CharBufElem -\u003e Int -\u003e Char -\u003e IO Int",
          "source": "src/GHC-IO-Buffer.html#writeCharBufPtr",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "writeCharBufPtr",
          "normalized": "Ptr CharBufElem-\u003eInt-\u003eChar-\u003eIO Int",
          "package": "base",
          "partial": "Char Buf Ptr",
          "signature": "Ptr CharBufElem-\u003eInt-\u003eChar-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:writeCharBufPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Buffer",
          "name": "writeWord8Buf",
          "package": "base",
          "signature": "RawBuffer Word8 -\u003e Int -\u003e Word8 -\u003e IO ()",
          "source": "src/GHC-IO-Buffer.html#writeWord8Buf",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Buffer",
          "module": "GHC.IO.Buffer",
          "name": "writeWord8Buf",
          "normalized": "RawBuffer Word-\u003eInt-\u003eWord-\u003eIO()",
          "package": "base",
          "partial": "Word Buf",
          "signature": "RawBuffer Word-\u003eInt-\u003eWord-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Buffer.html#v:writeWord8Buf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eClass of buffered IO devices\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.IO.BufferedIO",
          "name": "BufferedIO",
          "package": "base",
          "source": "src/GHC-IO-BufferedIO.html",
          "type": "module"
        },
        "index": {
          "description": "Class of buffered IO devices",
          "hierarchy": "GHC IO BufferedIO",
          "module": "GHC.IO.BufferedIO",
          "name": "BufferedIO",
          "package": "base",
          "partial": "Buffered IO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-BufferedIO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe purpose of \u003ccode\u003e\u003ca\u003eBufferedIO\u003c/a\u003e\u003c/code\u003e is to provide a common interface for I/O\n devices that can read and write data through a buffer.  Devices that\n implement \u003ccode\u003e\u003ca\u003eBufferedIO\u003c/a\u003e\u003c/code\u003e include ordinary files, memory-mapped files,\n and bytestrings.  The underlying device implementing a \u003ccode\u003eHandle\u003c/code\u003e must\n provide \u003ccode\u003e\u003ca\u003eBufferedIO\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "GHC.IO.BufferedIO",
          "name": "BufferedIO",
          "package": "base",
          "source": "src/GHC-IO-BufferedIO.html#BufferedIO",
          "type": "class"
        },
        "index": {
          "description": "The purpose of BufferedIO is to provide common interface for devices that can read and write data through buffer Devices that implement BufferedIO include ordinary files memory-mapped files and bytestrings The underlying device implementing Handle must provide BufferedIO",
          "hierarchy": "GHC IO BufferedIO",
          "module": "GHC.IO.BufferedIO",
          "name": "BufferedIO",
          "package": "base",
          "partial": "Buffered IO",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-BufferedIO.html#t:BufferedIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrepares an empty write buffer.  This lets the device decide\n how to set up a write buffer: the buffer may need to point to a\n specific location in memory, for example.  This is typically used\n by the client when switching from reading to writing on a\n buffered read/write device.\n\u003c/p\u003e\u003cp\u003eThere is no corresponding operation for read buffers, because before\n reading the client will always call \u003ccode\u003e\u003ca\u003efillReadBuffer\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "GHC.IO.BufferedIO",
          "name": "emptyWriteBuffer",
          "package": "base",
          "signature": "dev -\u003e Buffer Word8 -\u003e IO (Buffer Word8)",
          "source": "src/GHC-IO-BufferedIO.html#emptyWriteBuffer",
          "type": "method"
        },
        "index": {
          "description": "Prepares an empty write buffer This lets the device decide how to set up write buffer the buffer may need to point to specific location in memory for example This is typically used by the client when switching from reading to writing on buffered read write device There is no corresponding operation for read buffers because before reading the client will always call fillReadBuffer",
          "hierarchy": "GHC IO BufferedIO",
          "module": "GHC.IO.BufferedIO",
          "name": "emptyWriteBuffer",
          "normalized": "a-\u003eBuffer Word-\u003eIO(Buffer Word)",
          "package": "base",
          "partial": "Write Buffer",
          "signature": "dev-\u003eBuffer Word-\u003eIO(Buffer Word)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-BufferedIO.html#v:emptyWriteBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereads bytes into the buffer, blocking if there are no bytes\n available.  Returns the number of bytes read (zero indicates\n end-of-file), and the new buffer.\n\u003c/p\u003e",
          "module": "GHC.IO.BufferedIO",
          "name": "fillReadBuffer",
          "package": "base",
          "signature": "dev -\u003e Buffer Word8 -\u003e IO (Int, Buffer Word8)",
          "source": "src/GHC-IO-BufferedIO.html#fillReadBuffer",
          "type": "method"
        },
        "index": {
          "description": "reads bytes into the buffer blocking if there are no bytes available Returns the number of bytes read zero indicates end-of-file and the new buffer",
          "hierarchy": "GHC IO BufferedIO",
          "module": "GHC.IO.BufferedIO",
          "name": "fillReadBuffer",
          "normalized": "a-\u003eBuffer Word-\u003eIO(Int,Buffer Word)",
          "package": "base",
          "partial": "Read Buffer",
          "signature": "dev-\u003eBuffer Word-\u003eIO(Int,Buffer Word)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-BufferedIO.html#v:fillReadBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereads bytes into the buffer without blocking.  Returns the\n number of bytes read (Nothing indicates end-of-file), and the new\n buffer.\n\u003c/p\u003e",
          "module": "GHC.IO.BufferedIO",
          "name": "fillReadBuffer0",
          "package": "base",
          "signature": "dev -\u003e Buffer Word8 -\u003e IO (Maybe Int, Buffer Word8)",
          "source": "src/GHC-IO-BufferedIO.html#fillReadBuffer0",
          "type": "method"
        },
        "index": {
          "description": "reads bytes into the buffer without blocking Returns the number of bytes read Nothing indicates end-of-file and the new buffer",
          "hierarchy": "GHC IO BufferedIO",
          "module": "GHC.IO.BufferedIO",
          "name": "fillReadBuffer0",
          "normalized": "a-\u003eBuffer Word-\u003eIO(Maybe Int,Buffer Word)",
          "package": "base",
          "partial": "Read Buffer",
          "signature": "dev-\u003eBuffer Word-\u003eIO(Maybe Int,Buffer Word)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-BufferedIO.html#v:fillReadBuffer0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlush all the data from the supplied write buffer out to the device.\n The returned buffer should be empty, and ready for writing.\n\u003c/p\u003e",
          "module": "GHC.IO.BufferedIO",
          "name": "flushWriteBuffer",
          "package": "base",
          "signature": "dev -\u003e Buffer Word8 -\u003e IO (Buffer Word8)",
          "source": "src/GHC-IO-BufferedIO.html#flushWriteBuffer",
          "type": "method"
        },
        "index": {
          "description": "Flush all the data from the supplied write buffer out to the device The returned buffer should be empty and ready for writing",
          "hierarchy": "GHC IO BufferedIO",
          "module": "GHC.IO.BufferedIO",
          "name": "flushWriteBuffer",
          "normalized": "a-\u003eBuffer Word-\u003eIO(Buffer Word)",
          "package": "base",
          "partial": "Write Buffer",
          "signature": "dev-\u003eBuffer Word-\u003eIO(Buffer Word)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-BufferedIO.html#v:flushWriteBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlush data from the supplied write buffer out to the device\n without blocking.  Returns the number of bytes written and the\n remaining buffer.\n\u003c/p\u003e",
          "module": "GHC.IO.BufferedIO",
          "name": "flushWriteBuffer0",
          "package": "base",
          "signature": "dev -\u003e Buffer Word8 -\u003e IO (Int, Buffer Word8)",
          "source": "src/GHC-IO-BufferedIO.html#flushWriteBuffer0",
          "type": "method"
        },
        "index": {
          "description": "Flush data from the supplied write buffer out to the device without blocking Returns the number of bytes written and the remaining buffer",
          "hierarchy": "GHC IO BufferedIO",
          "module": "GHC.IO.BufferedIO",
          "name": "flushWriteBuffer0",
          "normalized": "a-\u003eBuffer Word-\u003eIO(Int,Buffer Word)",
          "package": "base",
          "partial": "Write Buffer",
          "signature": "dev-\u003eBuffer Word-\u003eIO(Int,Buffer Word)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-BufferedIO.html#v:flushWriteBuffer0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eallocate a new buffer.  The size of the buffer is at the\n discretion of the device; e.g. for a memory-mapped file the\n buffer will probably cover the entire file.\n\u003c/p\u003e",
          "module": "GHC.IO.BufferedIO",
          "name": "newBuffer",
          "package": "base",
          "signature": "dev -\u003e BufferState -\u003e IO (Buffer Word8)",
          "source": "src/GHC-IO-BufferedIO.html#newBuffer",
          "type": "method"
        },
        "index": {
          "description": "allocate new buffer The size of the buffer is at the discretion of the device e.g for memory-mapped file the buffer will probably cover the entire file",
          "hierarchy": "GHC IO BufferedIO",
          "module": "GHC.IO.BufferedIO",
          "name": "newBuffer",
          "normalized": "a-\u003eBufferState-\u003eIO(Buffer Word)",
          "package": "base",
          "partial": "Buffer",
          "signature": "dev-\u003eBufferState-\u003eIO(Buffer Word)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-BufferedIO.html#v:newBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.BufferedIO",
          "name": "readBuf",
          "package": "base",
          "signature": "dev -\u003e Buffer Word8 -\u003e IO (Int, Buffer Word8)",
          "source": "src/GHC-IO-BufferedIO.html#readBuf",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO BufferedIO",
          "module": "GHC.IO.BufferedIO",
          "name": "readBuf",
          "normalized": "a-\u003eBuffer Word-\u003eIO(Int,Buffer Word)",
          "package": "base",
          "partial": "Buf",
          "signature": "dev-\u003eBuffer Word-\u003eIO(Int,Buffer Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-BufferedIO.html#v:readBuf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.BufferedIO",
          "name": "readBufNonBlocking",
          "package": "base",
          "signature": "dev -\u003e Buffer Word8 -\u003e IO (Maybe Int, Buffer Word8)",
          "source": "src/GHC-IO-BufferedIO.html#readBufNonBlocking",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO BufferedIO",
          "module": "GHC.IO.BufferedIO",
          "name": "readBufNonBlocking",
          "normalized": "a-\u003eBuffer Word-\u003eIO(Maybe Int,Buffer Word)",
          "package": "base",
          "partial": "Buf Non Blocking",
          "signature": "dev-\u003eBuffer Word-\u003eIO(Maybe Int,Buffer Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-BufferedIO.html#v:readBufNonBlocking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.BufferedIO",
          "name": "writeBuf",
          "package": "base",
          "signature": "dev -\u003e Buffer Word8 -\u003e IO (Buffer Word8)",
          "source": "src/GHC-IO-BufferedIO.html#writeBuf",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO BufferedIO",
          "module": "GHC.IO.BufferedIO",
          "name": "writeBuf",
          "normalized": "a-\u003eBuffer Word-\u003eIO(Buffer Word)",
          "package": "base",
          "partial": "Buf",
          "signature": "dev-\u003eBuffer Word-\u003eIO(Buffer Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-BufferedIO.html#v:writeBuf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.BufferedIO",
          "name": "writeBufNonBlocking",
          "package": "base",
          "signature": "dev -\u003e Buffer Word8 -\u003e IO (Int, Buffer Word8)",
          "source": "src/GHC-IO-BufferedIO.html#writeBufNonBlocking",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO BufferedIO",
          "module": "GHC.IO.BufferedIO",
          "name": "writeBufNonBlocking",
          "normalized": "a-\u003eBuffer Word-\u003eIO(Int,Buffer Word)",
          "package": "base",
          "partial": "Buf Non Blocking",
          "signature": "dev-\u003eBuffer Word-\u003eIO(Int,Buffer Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-BufferedIO.html#v:writeBufNonBlocking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType classes for I/O providers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.IO.Device",
          "name": "Device",
          "package": "base",
          "source": "src/GHC-IO-Device.html",
          "type": "module"
        },
        "index": {
          "description": "Type classes for providers",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "Device",
          "package": "base",
          "partial": "Device",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O operations required for implementing a \u003ccode\u003eHandle\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "IODevice",
          "package": "base",
          "source": "src/GHC-IO-Device.html#IODevice",
          "type": "class"
        },
        "index": {
          "description": "operations required for implementing Handle",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "IODevice",
          "package": "base",
          "partial": "IODevice",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#t:IODevice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of a device that can be used to back a\n \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e (see also \u003ccode\u003e\u003ca\u003emkFileHandle\u003c/a\u003e\u003c/code\u003e). The\n standard libraries provide creation of \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003es via\n Posix file operations with file descriptors (see\n \u003ccode\u003e\u003ca\u003emkHandleFromFD\u003c/a\u003e\u003c/code\u003e) with FD being the underlying\n \u003ccode\u003e\u003ca\u003eIODevice\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e\u003cp\u003eUsers may provide custom instances of \u003ccode\u003e\u003ca\u003eIODevice\u003c/a\u003e\u003c/code\u003e\n which are expected to conform the following rules:\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "IODeviceType",
          "package": "base",
          "source": "src/GHC-IO-Device.html#IODeviceType",
          "type": "data"
        },
        "index": {
          "description": "Type of device that can be used to back Handle see also mkFileHandle The standard libraries provide creation of Handle via Posix file operations with file descriptors see mkHandleFromFD with FD being the underlying IODevice instance Users may provide custom instances of IODevice which are expected to conform the following rules",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "IODeviceType",
          "package": "base",
          "partial": "IODevice Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#t:IODeviceType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA low-level I/O provider where the data is bytes in memory.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "RawIO",
          "package": "base",
          "source": "src/GHC-IO-Device.html#RawIO",
          "type": "class"
        },
        "index": {
          "description": "low-level provider where the data is bytes in memory",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "RawIO",
          "package": "base",
          "partial": "Raw IO",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#t:RawIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA mode that determines the effect of \u003ccode\u003ehSeek\u003c/code\u003e \u003ccode\u003ehdl mode i\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "SeekMode",
          "package": "base",
          "source": "src/GHC-IO-Device.html#SeekMode",
          "type": "data"
        },
        "index": {
          "description": "mode that determines the effect of hSeek hdl mode",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "SeekMode",
          "package": "base",
          "partial": "Seek Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#t:SeekMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe position of \u003ccode\u003ehdl\u003c/code\u003e is set to \u003ccode\u003ei\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Device\",\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "AbsoluteSeek",
          "package": "base",
          "signature": "AbsoluteSeek",
          "source": "src/GHC-IO-Device.html#SeekMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:AbsoluteSeek\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:AbsoluteSeek\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:AbsoluteSeek\"]"
        },
        "index": {
          "description": "the position of hdl is set to",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "AbsoluteSeek",
          "package": "base",
          "partial": "Absolute Seek",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:AbsoluteSeek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe standard libraries do not have direct support\n for this device type, but a user implementation is\n expected to provide a list of file names in\n the directory, in any order, separated by \u003ccode\u003e'\\0'\u003c/code\u003e\n characters, excluding the \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e..\u003c/a\u003e\u003c/code\u003e names. See\n also \u003ccode\u003e\u003ca\u003egetDirectoryContents\u003c/a\u003e\u003c/code\u003e.  Seek\n operations are not supported on directories (other\n than to the zero position).\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "Directory",
          "package": "base",
          "signature": "Directory",
          "source": "src/GHC-IO-Device.html#IODeviceType",
          "type": "function"
        },
        "index": {
          "description": "The standard libraries do not have direct support for this device type but user implementation is expected to provide list of file names in the directory in any order separated by characters excluding the and names See also getDirectoryContents Seek operations are not supported on directories other than to the zero position",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "Directory",
          "package": "base",
          "partial": "Directory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:Directory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ca\u003eraw\u003c/a\u003e (disk) device which supports block binary\n read and write operations and may be seekable only\n to positions of certain granularity (block-\n aligned).\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "RawDevice",
          "package": "base",
          "signature": "RawDevice",
          "source": "src/GHC-IO-Device.html#IODeviceType",
          "type": "function"
        },
        "index": {
          "description": "raw disk device which supports block binary read and write operations and may be seekable only to positions of certain granularity block aligned",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "RawDevice",
          "package": "base",
          "partial": "Raw Device",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:RawDevice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA file that may be read or written, and also\n may be seekable.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "RegularFile",
          "package": "base",
          "signature": "RegularFile",
          "source": "src/GHC-IO-Device.html#IODeviceType",
          "type": "function"
        },
        "index": {
          "description": "file that may be read or written and also may be seekable",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "RegularFile",
          "package": "base",
          "partial": "Regular File",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:RegularFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe position of \u003ccode\u003ehdl\u003c/code\u003e is set to offset \u003ccode\u003ei\u003c/code\u003e\n from the current position.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Device\",\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "RelativeSeek",
          "package": "base",
          "signature": "RelativeSeek",
          "source": "src/GHC-IO-Device.html#SeekMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:RelativeSeek\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:RelativeSeek\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:RelativeSeek\"]"
        },
        "index": {
          "description": "the position of hdl is set to offset from the current position",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "RelativeSeek",
          "package": "base",
          "partial": "Relative Seek",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:RelativeSeek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe position of \u003ccode\u003ehdl\u003c/code\u003e is set to offset \u003ccode\u003ei\u003c/code\u003e\n from the end of the file.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Device\",\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "SeekFromEnd",
          "package": "base",
          "signature": "SeekFromEnd",
          "source": "src/GHC-IO-Device.html#SeekMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:SeekFromEnd\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:SeekFromEnd\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:SeekFromEnd\"]"
        },
        "index": {
          "description": "the position of hdl is set to offset from the end of the file",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "SeekFromEnd",
          "package": "base",
          "partial": "Seek From End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:SeekFromEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA duplex communications channel (results in\n creation of a duplex \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e). The\n standard libraries use this device type when\n creating \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003es for open sockets.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "Stream",
          "package": "base",
          "signature": "Stream",
          "source": "src/GHC-IO-Device.html#IODeviceType",
          "type": "function"
        },
        "index": {
          "description": "duplex communications channel results in creation of duplex Handle The standard libraries use this device type when creating Handle for open sockets",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "Stream",
          "package": "base",
          "partial": "Stream",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:Stream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecloses the device.  Further operations on the device should\n produce exceptions.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "close",
          "package": "base",
          "signature": "a -\u003e IO ()",
          "source": "src/GHC-IO-Device.html#close",
          "type": "method"
        },
        "index": {
          "description": "closes the device Further operations on the device should produce exceptions",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "close",
          "normalized": "a-\u003eIO()",
          "package": "base",
          "signature": "a-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:close"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturns the \u003ccode\u003e\u003ca\u003eIODeviceType\u003c/a\u003e\u003c/code\u003e corresponding to this device.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "devType",
          "package": "base",
          "signature": "a -\u003e IO IODeviceType",
          "source": "src/GHC-IO-Device.html#devType",
          "type": "method"
        },
        "index": {
          "description": "returns the IODeviceType corresponding to this device",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "devType",
          "normalized": "a-\u003eIO IODeviceType",
          "package": "base",
          "partial": "Type",
          "signature": "a-\u003eIO IODeviceType",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:devType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eduplicates the device, if possible.  The new device is expected\n to share a file pointer with the original device (like Unix \u003ccode\u003edup\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "dup",
          "package": "base",
          "signature": "a -\u003e IO a",
          "source": "src/GHC-IO-Device.html#dup",
          "type": "method"
        },
        "index": {
          "description": "duplicates the device if possible The new device is expected to share file pointer with the original device like Unix dup",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "dup",
          "normalized": "a-\u003eIO a",
          "package": "base",
          "signature": "a-\u003eIO a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:dup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edup2 source target\u003c/code\u003e replaces the target device with the source\n device.  The target device is closed first, if necessary, and then\n it is made into a duplicate of the first device (like Unix \u003ccode\u003edup2\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "dup2",
          "package": "base",
          "signature": "a -\u003e a -\u003e IO a",
          "source": "src/GHC-IO-Device.html#dup2",
          "type": "method"
        },
        "index": {
          "description": "dup2 source target replaces the target device with the source device The target device is closed first if necessary and then it is made into duplicate of the first device like Unix dup2",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "dup2",
          "normalized": "a-\u003ea-\u003eIO a",
          "package": "base",
          "signature": "a-\u003ea-\u003eIO a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:dup2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturns the current echoing status.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "getEcho",
          "package": "base",
          "signature": "a -\u003e IO Bool",
          "source": "src/GHC-IO-Device.html#getEcho",
          "type": "method"
        },
        "index": {
          "description": "returns the current echoing status",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "getEcho",
          "normalized": "a-\u003eIO Bool",
          "package": "base",
          "partial": "Echo",
          "signature": "a-\u003eIO Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:getEcho"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturn the size of the data.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "getSize",
          "package": "base",
          "signature": "a -\u003e IO Integer",
          "source": "src/GHC-IO-Device.html#getSize",
          "type": "method"
        },
        "index": {
          "description": "return the size of the data",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "getSize",
          "normalized": "a-\u003eIO Integer",
          "package": "base",
          "partial": "Size",
          "signature": "a-\u003eIO Integer",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:getSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the device supports \u003ccode\u003e\u003ca\u003eseek\u003c/a\u003e\u003c/code\u003e operations.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "isSeekable",
          "package": "base",
          "signature": "a -\u003e IO Bool",
          "source": "src/GHC-IO-Device.html#isSeekable",
          "type": "method"
        },
        "index": {
          "description": "returns True if the device supports seek operations",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "isSeekable",
          "normalized": "a-\u003eIO Bool",
          "package": "base",
          "partial": "Seekable",
          "signature": "a-\u003eIO Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:isSeekable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the device is a terminal or console.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "isTerminal",
          "package": "base",
          "signature": "a -\u003e IO Bool",
          "source": "src/GHC-IO-Device.html#isTerminal",
          "type": "method"
        },
        "index": {
          "description": "returns True if the device is terminal or console",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "isTerminal",
          "normalized": "a-\u003eIO Bool",
          "package": "base",
          "partial": "Terminal",
          "signature": "a-\u003eIO Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:isTerminal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead up to the specified number of bytes, returning the number\n of bytes actually read.  This function should only block if there\n is no data available.  If there is not enough data available,\n then the function should just return the available data. A return\n value of zero indicates that the end of the data stream (e.g. end\n of file) has been reached.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "read",
          "package": "base",
          "signature": "a -\u003e Ptr Word8 -\u003e Int -\u003e IO Int",
          "source": "src/GHC-IO-Device.html#read",
          "type": "method"
        },
        "index": {
          "description": "Read up to the specified number of bytes returning the number of bytes actually read This function should only block if there is no data available If there is not enough data available then the function should just return the available data return value of zero indicates that the end of the data stream e.g end of file has been reached",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "read",
          "normalized": "a-\u003ePtr Word-\u003eInt-\u003eIO Int",
          "package": "base",
          "signature": "a-\u003ePtr Word-\u003eInt-\u003eIO Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:read"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead up to the specified number of bytes, returning the number\n of bytes actually read, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the end of the stream has\n been reached.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "readNonBlocking",
          "package": "base",
          "signature": "a -\u003e Ptr Word8 -\u003e Int -\u003e IO (Maybe Int)",
          "source": "src/GHC-IO-Device.html#readNonBlocking",
          "type": "method"
        },
        "index": {
          "description": "Read up to the specified number of bytes returning the number of bytes actually read or Nothing if the end of the stream has been reached",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "readNonBlocking",
          "normalized": "a-\u003ePtr Word-\u003eInt-\u003eIO(Maybe Int)",
          "package": "base",
          "partial": "Non Blocking",
          "signature": "a-\u003ePtr Word-\u003eInt-\u003eIO(Maybe Int)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:readNonBlocking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eready dev write msecs\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the device has data\n to read (if \u003ccode\u003ewrite\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e) or space to write new data (if\n \u003ccode\u003ewrite\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e).  \u003ccode\u003emsecs\u003c/code\u003e specifies how long to wait, in\n milliseconds.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "ready",
          "package": "base",
          "signature": "a -\u003e Bool -\u003e Int -\u003e IO Bool",
          "source": "src/GHC-IO-Device.html#ready",
          "type": "method"
        },
        "index": {
          "description": "ready dev write msecs returns True if the device has data to read if write is False or space to write new data if write is True msecs specifies how long to wait in milliseconds",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "ready",
          "normalized": "a-\u003eBool-\u003eInt-\u003eIO Bool",
          "package": "base",
          "signature": "a-\u003eBool-\u003eInt-\u003eIO Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:ready"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eseek to the specified position in the data.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "seek",
          "package": "base",
          "signature": "a -\u003e SeekMode -\u003e Integer -\u003e IO ()",
          "source": "src/GHC-IO-Device.html#seek",
          "type": "method"
        },
        "index": {
          "description": "seek to the specified position in the data",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "seek",
          "normalized": "a-\u003eSeekMode-\u003eInteger-\u003eIO()",
          "package": "base",
          "signature": "a-\u003eSeekMode-\u003eInteger-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:seek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efor terminal devices, changes whether characters are echoed on\n the device.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "setEcho",
          "package": "base",
          "signature": "a -\u003e Bool -\u003e IO ()",
          "source": "src/GHC-IO-Device.html#setEcho",
          "type": "method"
        },
        "index": {
          "description": "for terminal devices changes whether characters are echoed on the device",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "setEcho",
          "normalized": "a-\u003eBool-\u003eIO()",
          "package": "base",
          "partial": "Echo",
          "signature": "a-\u003eBool-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:setEcho"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esome devices (e.g. terminals) support a \u003ca\u003eraw\u003c/a\u003e mode where\n characters entered are immediately made available to the program.\n If available, this operations enables raw mode.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "setRaw",
          "package": "base",
          "signature": "a -\u003e Bool -\u003e IO ()",
          "source": "src/GHC-IO-Device.html#setRaw",
          "type": "method"
        },
        "index": {
          "description": "some devices e.g terminals support raw mode where characters entered are immediately made available to the program If available this operations enables raw mode",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "setRaw",
          "normalized": "a-\u003eBool-\u003eIO()",
          "package": "base",
          "partial": "Raw",
          "signature": "a-\u003eBool-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:setRaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echange the size of the data.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "setSize",
          "package": "base",
          "signature": "a -\u003e Integer -\u003e IO ()",
          "source": "src/GHC-IO-Device.html#setSize",
          "type": "method"
        },
        "index": {
          "description": "change the size of the data",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "setSize",
          "normalized": "a-\u003eInteger-\u003eIO()",
          "package": "base",
          "partial": "Size",
          "signature": "a-\u003eInteger-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:setSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturn the current position in the data.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "tell",
          "package": "base",
          "signature": "a -\u003e IO Integer",
          "source": "src/GHC-IO-Device.html#tell",
          "type": "method"
        },
        "index": {
          "description": "return the current position in the data",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "tell",
          "normalized": "a-\u003eIO Integer",
          "package": "base",
          "signature": "a-\u003eIO Integer",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:tell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite the specified number of bytes.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "write",
          "package": "base",
          "signature": "a -\u003e Ptr Word8 -\u003e Int -\u003e IO ()",
          "source": "src/GHC-IO-Device.html#write",
          "type": "method"
        },
        "index": {
          "description": "Write the specified number of bytes",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "write",
          "normalized": "a-\u003ePtr Word-\u003eInt-\u003eIO()",
          "package": "base",
          "signature": "a-\u003ePtr Word-\u003eInt-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:write"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite up to the specified number of bytes without blocking.  Returns\n the actual number of bytes written.\n\u003c/p\u003e",
          "module": "GHC.IO.Device",
          "name": "writeNonBlocking",
          "package": "base",
          "signature": "a -\u003e Ptr Word8 -\u003e Int -\u003e IO Int",
          "source": "src/GHC-IO-Device.html#writeNonBlocking",
          "type": "method"
        },
        "index": {
          "description": "Write up to the specified number of bytes without blocking Returns the actual number of bytes written",
          "hierarchy": "GHC IO Device",
          "module": "GHC.IO.Device",
          "name": "writeNonBlocking",
          "normalized": "a-\u003ePtr Word-\u003eInt-\u003eIO Int",
          "package": "base",
          "partial": "Non Blocking",
          "signature": "a-\u003ePtr Word-\u003eInt-\u003eIO Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Device.html#v:writeNonBlocking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.CodePage",
          "name": "CodePage",
          "package": "base",
          "source": "src/GHC-IO-Encoding-CodePage.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "GHC IO Encoding CodePage",
          "module": "GHC.IO.Encoding.CodePage",
          "name": "CodePage",
          "package": "base",
          "partial": "Code Page",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-CodePage.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTypes for specifying how text encoding/decoding fails\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.IO.Encoding.Failure",
          "name": "Failure",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Failure.html",
          "type": "module"
        },
        "index": {
          "description": "Types for specifying how text encoding decoding fails",
          "hierarchy": "GHC IO Encoding Failure",
          "module": "GHC.IO.Encoding.Failure",
          "name": "Failure",
          "package": "base",
          "partial": "Failure",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Failure.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eCodingFailureMode\u003c/a\u003e\u003c/code\u003e is used to construct \u003ccode\u003eTextEncoding\u003c/code\u003es, and\n specifies how they handle illegal sequences.\n\u003c/p\u003e",
          "module": "GHC.IO.Encoding.Failure",
          "name": "CodingFailureMode",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Failure.html#CodingFailureMode",
          "type": "data"
        },
        "index": {
          "description": "The CodingFailureMode is used to construct TextEncoding and specifies how they handle illegal sequences",
          "hierarchy": "GHC IO Encoding Failure",
          "module": "GHC.IO.Encoding.Failure",
          "name": "CodingFailureMode",
          "package": "base",
          "partial": "Coding Failure Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Failure.html#t:CodingFailureMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an error when an illegal sequence is encountered\n\u003c/p\u003e",
          "module": "GHC.IO.Encoding.Failure",
          "name": "ErrorOnCodingFailure",
          "package": "base",
          "signature": "ErrorOnCodingFailure",
          "source": "src/GHC-IO-Encoding-Failure.html#CodingFailureMode",
          "type": "function"
        },
        "index": {
          "description": "Throw an error when an illegal sequence is encountered",
          "hierarchy": "GHC IO Encoding Failure",
          "module": "GHC.IO.Encoding.Failure",
          "name": "ErrorOnCodingFailure",
          "package": "base",
          "partial": "Error On Coding Failure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Failure.html#v:ErrorOnCodingFailure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempt to ignore and recover if an illegal sequence is\n encountered\n\u003c/p\u003e",
          "module": "GHC.IO.Encoding.Failure",
          "name": "IgnoreCodingFailure",
          "package": "base",
          "signature": "IgnoreCodingFailure",
          "source": "src/GHC-IO-Encoding-Failure.html#CodingFailureMode",
          "type": "function"
        },
        "index": {
          "description": "Attempt to ignore and recover if an illegal sequence is encountered",
          "hierarchy": "GHC IO Encoding Failure",
          "module": "GHC.IO.Encoding.Failure",
          "name": "IgnoreCodingFailure",
          "package": "base",
          "partial": "Ignore Coding Failure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Failure.html#v:IgnoreCodingFailure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the private-use escape mechanism to attempt to allow\n illegal sequences to be roundtripped.\n\u003c/p\u003e",
          "module": "GHC.IO.Encoding.Failure",
          "name": "RoundtripFailure",
          "package": "base",
          "signature": "RoundtripFailure",
          "source": "src/GHC-IO-Encoding-Failure.html#CodingFailureMode",
          "type": "function"
        },
        "index": {
          "description": "Use the private-use escape mechanism to attempt to allow illegal sequences to be roundtripped",
          "hierarchy": "GHC IO Encoding Failure",
          "module": "GHC.IO.Encoding.Failure",
          "name": "RoundtripFailure",
          "package": "base",
          "partial": "Roundtrip Failure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Failure.html#v:RoundtripFailure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace with the closest visual match upon an illegal\n sequence\n\u003c/p\u003e",
          "module": "GHC.IO.Encoding.Failure",
          "name": "TransliterateCodingFailure",
          "package": "base",
          "signature": "TransliterateCodingFailure",
          "source": "src/GHC-IO-Encoding-Failure.html#CodingFailureMode",
          "type": "function"
        },
        "index": {
          "description": "Replace with the closest visual match upon an illegal sequence",
          "hierarchy": "GHC IO Encoding Failure",
          "module": "GHC.IO.Encoding.Failure",
          "name": "TransliterateCodingFailure",
          "package": "base",
          "partial": "Transliterate Coding Failure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Failure.html#v:TransliterateCodingFailure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Failure",
          "name": "codingFailureModeSuffix",
          "package": "base",
          "signature": "CodingFailureMode -\u003e String",
          "source": "src/GHC-IO-Encoding-Failure.html#codingFailureModeSuffix",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Failure",
          "module": "GHC.IO.Encoding.Failure",
          "name": "codingFailureModeSuffix",
          "normalized": "CodingFailureMode-\u003eString",
          "package": "base",
          "partial": "Failure Mode Suffix",
          "signature": "CodingFailureMode-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Failure.html#v:codingFailureModeSuffix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome characters are actually \u003ca\u003esurrogate\u003c/a\u003e codepoints defined for\n use in UTF-16. We need to signal an invalid character if we detect\n them when encoding a sequence of \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003es into \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003es because they\n won't give valid Unicode.\n\u003c/p\u003e\u003cp\u003eWe may also need to signal an invalid character if we detect them\n when encoding a sequence of \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003es into \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003es because the\n \u003ccode\u003e\u003ca\u003eRoundtripFailure\u003c/a\u003e\u003c/code\u003e mode creates these to round-trip bytes through\n our internal UTF-16 encoding.\n\u003c/p\u003e",
          "module": "GHC.IO.Encoding.Failure",
          "name": "isSurrogate",
          "package": "base",
          "signature": "Char -\u003e Bool",
          "source": "src/GHC-IO-Encoding-Failure.html#isSurrogate",
          "type": "function"
        },
        "index": {
          "description": "Some characters are actually surrogate codepoints defined for use in UTF-16 We need to signal an invalid character if we detect them when encoding sequence of Char into Word8 because they won give valid Unicode We may also need to signal an invalid character if we detect them when encoding sequence of Char into Word8 because the RoundtripFailure mode creates these to round-trip bytes through our internal UTF-16 encoding",
          "hierarchy": "GHC IO Encoding Failure",
          "module": "GHC.IO.Encoding.Failure",
          "name": "isSurrogate",
          "normalized": "Char-\u003eBool",
          "package": "base",
          "partial": "Surrogate",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Failure.html#v:isSurrogate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Failure",
          "name": "recoverDecode",
          "package": "base",
          "signature": "CodingFailureMode -\u003e Buffer Word8 -\u003e Buffer Char -\u003e IO (Buffer Word8, Buffer Char)",
          "source": "src/GHC-IO-Encoding-Failure.html#recoverDecode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Failure",
          "module": "GHC.IO.Encoding.Failure",
          "name": "recoverDecode",
          "normalized": "CodingFailureMode-\u003eBuffer Word-\u003eBuffer Char-\u003eIO(Buffer Word,Buffer Char)",
          "package": "base",
          "partial": "Decode",
          "signature": "CodingFailureMode-\u003eBuffer Word-\u003eBuffer Char-\u003eIO(Buffer Word,Buffer Char)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Failure.html#v:recoverDecode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Failure",
          "name": "recoverEncode",
          "package": "base",
          "signature": "CodingFailureMode -\u003e Buffer Char -\u003e Buffer Word8 -\u003e IO (Buffer Char, Buffer Word8)",
          "source": "src/GHC-IO-Encoding-Failure.html#recoverEncode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Failure",
          "module": "GHC.IO.Encoding.Failure",
          "name": "recoverEncode",
          "normalized": "CodingFailureMode-\u003eBuffer Char-\u003eBuffer Word-\u003eIO(Buffer Char,Buffer Word)",
          "package": "base",
          "partial": "Encode",
          "signature": "CodingFailureMode-\u003eBuffer Char-\u003eBuffer Word-\u003eIO(Buffer Char,Buffer Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Failure.html#v:recoverEncode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides text encoding/decoding using iconv\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.IO.Encoding.Iconv",
          "name": "Iconv",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Iconv.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides text encoding decoding using iconv",
          "hierarchy": "GHC IO Encoding Iconv",
          "module": "GHC.IO.Encoding.Iconv",
          "name": "Iconv",
          "package": "base",
          "partial": "Iconv",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Iconv.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Iconv",
          "name": "iconvEncoding",
          "package": "base",
          "signature": "String -\u003e IO TextEncoding",
          "source": "src/GHC-IO-Encoding-Iconv.html#iconvEncoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Iconv",
          "module": "GHC.IO.Encoding.Iconv",
          "name": "iconvEncoding",
          "normalized": "String-\u003eIO TextEncoding",
          "package": "base",
          "partial": "Encoding",
          "signature": "String-\u003eIO TextEncoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Iconv.html#v:iconvEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Iconv",
          "name": "localeEncodingName",
          "package": "base",
          "signature": "String",
          "source": "src/GHC-IO-Encoding-Iconv.html#localeEncodingName",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Iconv",
          "module": "GHC.IO.Encoding.Iconv",
          "name": "localeEncodingName",
          "package": "base",
          "partial": "Encoding Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Iconv.html#v:localeEncodingName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Iconv",
          "name": "mkIconvEncoding",
          "package": "base",
          "signature": "CodingFailureMode -\u003e String -\u003e IO TextEncoding",
          "source": "src/GHC-IO-Encoding-Iconv.html#mkIconvEncoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Iconv",
          "module": "GHC.IO.Encoding.Iconv",
          "name": "mkIconvEncoding",
          "normalized": "CodingFailureMode-\u003eString-\u003eIO TextEncoding",
          "package": "base",
          "partial": "Iconv Encoding",
          "signature": "CodingFailureMode-\u003eString-\u003eIO TextEncoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Iconv.html#v:mkIconvEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUTF-32 Codecs for the IO library\n\u003c/p\u003e\u003cp\u003ePortions Copyright   : (c) Tom Harper 2008-2009,\n                        (c) Bryan O'Sullivan 2009,\n                        (c) Duncan Coutts 2009\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.IO.Encoding.Latin1",
          "name": "Latin1",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Latin1.html",
          "type": "module"
        },
        "index": {
          "description": "UTF-32 Codecs for the IO library Portions Copyright Tom Harper Bryan Sullivan Duncan Coutts",
          "hierarchy": "GHC IO Encoding Latin1",
          "module": "GHC.IO.Encoding.Latin1",
          "name": "Latin1",
          "package": "base",
          "partial": "Latin",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Latin1.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Latin1",
          "name": "latin1",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding-Latin1.html#latin1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Latin1",
          "module": "GHC.IO.Encoding.Latin1",
          "name": "latin1",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Latin1.html#v:latin1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Latin1",
          "name": "latin1_checked",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding-Latin1.html#latin1_checked",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Latin1",
          "module": "GHC.IO.Encoding.Latin1",
          "name": "latin1_checked",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Latin1.html#v:latin1_checked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Latin1",
          "name": "latin1_checked_encode",
          "package": "base",
          "signature": "EncodeBuffer",
          "source": "src/GHC-IO-Encoding-Latin1.html#latin1_checked_encode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Latin1",
          "module": "GHC.IO.Encoding.Latin1",
          "name": "latin1_checked_encode",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Latin1.html#v:latin1_checked_encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Latin1",
          "name": "latin1_decode",
          "package": "base",
          "signature": "DecodeBuffer",
          "source": "src/GHC-IO-Encoding-Latin1.html#latin1_decode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Latin1",
          "module": "GHC.IO.Encoding.Latin1",
          "name": "latin1_decode",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Latin1.html#v:latin1_decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Latin1",
          "name": "latin1_encode",
          "package": "base",
          "signature": "EncodeBuffer",
          "source": "src/GHC-IO-Encoding-Latin1.html#latin1_encode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Latin1",
          "module": "GHC.IO.Encoding.Latin1",
          "name": "latin1_encode",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Latin1.html#v:latin1_encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Latin1",
          "name": "mkLatin1",
          "package": "base",
          "signature": "CodingFailureMode -\u003e TextEncoding",
          "source": "src/GHC-IO-Encoding-Latin1.html#mkLatin1",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Latin1",
          "module": "GHC.IO.Encoding.Latin1",
          "name": "mkLatin1",
          "normalized": "CodingFailureMode-\u003eTextEncoding",
          "package": "base",
          "partial": "Latin",
          "signature": "CodingFailureMode-\u003eTextEncoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Latin1.html#v:mkLatin1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Latin1",
          "name": "mkLatin1_checked",
          "package": "base",
          "signature": "CodingFailureMode -\u003e TextEncoding",
          "source": "src/GHC-IO-Encoding-Latin1.html#mkLatin1_checked",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Latin1",
          "module": "GHC.IO.Encoding.Latin1",
          "name": "mkLatin1_checked",
          "normalized": "CodingFailureMode-\u003eTextEncoding",
          "package": "base",
          "partial": "Latin",
          "signature": "CodingFailureMode-\u003eTextEncoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Latin1.html#v:mkLatin1_checked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTypes for text encoding/decoding\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.IO.Encoding.Types",
          "name": "Types",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Types.html",
          "type": "module"
        },
        "index": {
          "description": "Types for text encoding decoding",
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "Types",
          "package": "base",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Types",
          "name": "BufferCodec",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Types.html#BufferCodec",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "BufferCodec",
          "package": "base",
          "partial": "Buffer Codec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#t:BufferCodec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Types",
          "name": "CodingProgress",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Types.html#CodingProgress",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "CodingProgress",
          "package": "base",
          "partial": "Coding Progress",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#t:CodingProgress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Types",
          "name": "DecodeBuffer",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Types.html#DecodeBuffer",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "DecodeBuffer",
          "package": "base",
          "partial": "Decode Buffer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#t:DecodeBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Types",
          "name": "EncodeBuffer",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Types.html#EncodeBuffer",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "EncodeBuffer",
          "package": "base",
          "partial": "Encode Buffer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#t:EncodeBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Types",
          "name": "TextDecoder",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Types.html#TextDecoder",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "TextDecoder",
          "package": "base",
          "partial": "Text Decoder",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#t:TextDecoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.Types",
          "name": "TextEncoder",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Types.html#TextEncoder",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "TextEncoder",
          "package": "base",
          "partial": "Text Encoder",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#t:TextEncoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e is a specification of a conversion scheme\n between sequences of bytes and sequences of Unicode characters.\n\u003c/p\u003e\u003cp\u003eFor example, UTF-8 is an encoding of Unicode characters into a sequence\n of bytes.  The \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e for UTF-8 is \u003ccode\u003eutf8\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "GHC.IO.Encoding.Types",
          "name": "TextEncoding",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Types.html#TextEncoding",
          "type": "data"
        },
        "index": {
          "description": "TextEncoding is specification of conversion scheme between sequences of bytes and sequences of Unicode characters For example UTF-8 is an encoding of Unicode characters into sequence of bytes The TextEncoding for UTF-8 is utf8",
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "TextEncoding",
          "package": "base",
          "partial": "Text Encoding",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#t:TextEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.IO.Encoding.Types\",\"GHC.IO.Encoding\"]",
          "name": "BufferCodec",
          "package": "base",
          "signature": "BufferCodec",
          "source": "src/GHC-IO-Encoding-Types.html#BufferCodec",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:BufferCodec\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:BufferCodec\"]"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "BufferCodec",
          "package": "base",
          "partial": "Buffer Codec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:BufferCodec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStopped because the input contains insufficient available elements,\n or all of the input sequence has been sucessfully translated.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding.Types\",\"GHC.IO.Encoding\"]",
          "name": "InputUnderflow",
          "package": "base",
          "signature": "InputUnderflow",
          "source": "src/GHC-IO-Encoding-Types.html#CodingProgress",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:InputUnderflow\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:InputUnderflow\"]"
        },
        "index": {
          "description": "Stopped because the input contains insufficient available elements or all of the input sequence has been sucessfully translated",
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "InputUnderflow",
          "package": "base",
          "partial": "Input Underflow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:InputUnderflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStopped because there are sufficient free elements in the output\n to output at least one encoded ASCII character, but the input contains\n an invalid or unrepresentable sequence\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding.Types\",\"GHC.IO.Encoding\"]",
          "name": "InvalidSequence",
          "package": "base",
          "signature": "InvalidSequence",
          "source": "src/GHC-IO-Encoding-Types.html#CodingProgress",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:InvalidSequence\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:InvalidSequence\"]"
        },
        "index": {
          "description": "Stopped because there are sufficient free elements in the output to output at least one encoded ASCII character but the input contains an invalid or unrepresentable sequence",
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "InvalidSequence",
          "package": "base",
          "partial": "Invalid Sequence",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:InvalidSequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStopped because the output contains insufficient free elements\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding.Types\",\"GHC.IO.Encoding\"]",
          "name": "OutputUnderflow",
          "package": "base",
          "signature": "OutputUnderflow",
          "source": "src/GHC-IO-Encoding-Types.html#CodingProgress",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:OutputUnderflow\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:OutputUnderflow\"]"
        },
        "index": {
          "description": "Stopped because the output contains insufficient free elements",
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "OutputUnderflow",
          "package": "base",
          "partial": "Output Underflow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:OutputUnderflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.IO.Encoding.Types\",\"GHC.IO.Encoding\"]",
          "name": "TextEncoding",
          "package": "base",
          "signature": "forall dstate estate . TextEncoding",
          "source": "src/GHC-IO-Encoding-Types.html#TextEncoding",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:TextEncoding\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:TextEncoding\"]"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "TextEncoding",
          "package": "base",
          "partial": "Text Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:TextEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResources associated with the encoding may now be released.\n The \u003ccode\u003eencode\u003c/code\u003e function may not be called again after calling\n \u003ccode\u003eclose\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding.Types\",\"GHC.IO.Encoding\"]",
          "name": "close",
          "package": "base",
          "signature": "IO ()",
          "source": "src/GHC-IO-Encoding-Types.html#BufferCodec",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:close\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:close\"]"
        },
        "index": {
          "description": "Resources associated with the encoding may now be released The encode function may not be called again after calling close",
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "close",
          "normalized": "IO()",
          "package": "base",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:close"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003eencode\u003c/code\u003e function translates elements of the buffer \u003ccode\u003efrom\u003c/code\u003e\n to the buffer \u003ccode\u003eto\u003c/code\u003e.  It should translate as many elements as possible\n given the sizes of the buffers, including translating zero elements\n if there is either not enough room in \u003ccode\u003eto\u003c/code\u003e, or \u003ccode\u003efrom\u003c/code\u003e does not\n contain a complete multibyte sequence.\n\u003c/p\u003e\u003cp\u003eThe fact that as many elements as possible are translated is used by the IO\n library in order to report translation errors at the point they\n actually occur, rather than when the buffer is translated.\n\u003c/p\u003e\u003cp\u003eTo allow us to use iconv as a BufferCode efficiently, character buffers are\n defined to contain lone surrogates instead of those private use characters that\n are used for roundtripping. Thus, Chars poked and peeked from a character buffer\n must undergo surrogatifyRoundtripCharacter and desurrogatifyRoundtripCharacter\n respectively.\n\u003c/p\u003e\u003cp\u003eFor more information on this, see Note [Roundtripping] in GHC.IO.Encoding.Failure.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding.Types\",\"GHC.IO.Encoding\"]",
          "name": "encode",
          "package": "base",
          "signature": "Buffer from -\u003e Buffer to -\u003e IO (CodingProgress, Buffer from, Buffer to)",
          "source": "src/GHC-IO-Encoding-Types.html#BufferCodec",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:encode\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:encode\"]"
        },
        "index": {
          "description": "The encode function translates elements of the buffer from to the buffer to It should translate as many elements as possible given the sizes of the buffers including translating zero elements if there is either not enough room in to or from does not contain complete multibyte sequence The fact that as many elements as possible are translated is used by the IO library in order to report translation errors at the point they actually occur rather than when the buffer is translated To allow us to use iconv as BufferCode efficiently character buffers are defined to contain lone surrogates instead of those private use characters that are used for roundtripping Thus Chars poked and peeked from character buffer must undergo surrogatifyRoundtripCharacter and desurrogatifyRoundtripCharacter respectively For more information on this see Note Roundtripping in GHC.IO.Encoding.Failure",
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "encode",
          "normalized": "Buffer a-\u003eBuffer b-\u003eIO(CodingProgress,Buffer a,Buffer b)",
          "package": "base",
          "signature": "Buffer from-\u003eBuffer to-\u003eIO(CodingProgress,Buffer from,Buffer to)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the current state of the codec.\n\u003c/p\u003e\u003cp\u003eMany codecs are not stateful, and in these case the state can be\n represented as '()'.  Other codecs maintain a state.  For\n example, UTF-16 recognises a BOM (byte-order-mark) character at\n the beginning of the input, and remembers thereafter whether to\n use big-endian or little-endian mode.  In this case, the state\n of the codec would include two pieces of information: whether we\n are at the beginning of the stream (the BOM only occurs at the\n beginning), and if not, whether to use the big or little-endian\n encoding.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding.Types\",\"GHC.IO.Encoding\"]",
          "name": "getState",
          "package": "base",
          "signature": "IO state",
          "source": "src/GHC-IO-Encoding-Types.html#BufferCodec",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:getState\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:getState\"]"
        },
        "index": {
          "description": "Return the current state of the codec Many codecs are not stateful and in these case the state can be represented as Other codecs maintain state For example UTF-16 recognises BOM byte-order-mark character at the beginning of the input and remembers thereafter whether to use big-endian or little-endian mode In this case the state of the codec would include two pieces of information whether we are at the beginning of the stream the BOM only occurs at the beginning and if not whether to use the big or little-endian encoding",
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "getState",
          "package": "base",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:getState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a means of decoding bytes into characters: the result must not\n be shared between several byte sequences or simultaneously across threads\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding.Types\",\"GHC.IO.Encoding\"]",
          "name": "mkTextDecoder",
          "package": "base",
          "signature": "IO (TextDecoder dstate)",
          "source": "src/GHC-IO-Encoding-Types.html#TextEncoding",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:mkTextDecoder\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:mkTextDecoder\"]"
        },
        "index": {
          "description": "Creates means of decoding bytes into characters the result must not be shared between several byte sequences or simultaneously across threads",
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "mkTextDecoder",
          "package": "base",
          "partial": "Text Decoder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:mkTextDecoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a means of encode characters into bytes: the result must not\n be shared between several character sequences or simultaneously across threads\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding.Types\",\"GHC.IO.Encoding\"]",
          "name": "mkTextEncoder",
          "package": "base",
          "signature": "IO (TextEncoder estate)",
          "source": "src/GHC-IO-Encoding-Types.html#TextEncoding",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:mkTextEncoder\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:mkTextEncoder\"]"
        },
        "index": {
          "description": "Creates means of encode characters into bytes the result must not be shared between several character sequences or simultaneously across threads",
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "mkTextEncoder",
          "package": "base",
          "partial": "Text Encoder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:mkTextEncoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003erecover\u003c/code\u003e function is used to continue decoding\n in the presence of invalid or unrepresentable sequences. This includes\n both those detected by \u003ccode\u003eencode\u003c/code\u003e returning \u003ccode\u003eInvalidSequence\u003c/code\u003e and those\n that occur because the input byte sequence appears to be truncated.\n\u003c/p\u003e\u003cp\u003eProgress will usually be made by skipping the first element of the \u003ccode\u003efrom\u003c/code\u003e\n buffer. This function should only be called if you are certain that you\n wish to do this skipping and if the \u003ccode\u003eto\u003c/code\u003e buffer has at least one element\n of free space. Because this function deals with decoding failure, it assumes\n that the from buffer has at least one element.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003erecover\u003c/code\u003e may raise an exception rather than skipping anything.\n\u003c/p\u003e\u003cp\u003eCurrently, some implementations of \u003ccode\u003erecover\u003c/code\u003e may mutate the input buffer.\n In particular, this feature is used to implement transliteration.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding.Types\",\"GHC.IO.Encoding\"]",
          "name": "recover",
          "package": "base",
          "signature": "Buffer from -\u003e Buffer to -\u003e IO (Buffer from, Buffer to)",
          "source": "src/GHC-IO-Encoding-Types.html#BufferCodec",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:recover\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:recover\"]"
        },
        "index": {
          "description": "The recover function is used to continue decoding in the presence of invalid or unrepresentable sequences This includes both those detected by encode returning InvalidSequence and those that occur because the input byte sequence appears to be truncated Progress will usually be made by skipping the first element of the from buffer This function should only be called if you are certain that you wish to do this skipping and if the to buffer has at least one element of free space Because this function deals with decoding failure it assumes that the from buffer has at least one element recover may raise an exception rather than skipping anything Currently some implementations of recover may mutate the input buffer In particular this feature is used to implement transliteration",
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "recover",
          "normalized": "Buffer a-\u003eBuffer b-\u003eIO(Buffer a,Buffer b)",
          "package": "base",
          "signature": "Buffer from-\u003eBuffer to-\u003eIO(Buffer from,Buffer to)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:recover"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.IO.Encoding.Types\",\"GHC.IO.Encoding\"]",
          "name": "setState",
          "package": "base",
          "signature": "state -\u003e IO ()",
          "source": "src/GHC-IO-Encoding-Types.html#BufferCodec",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:setState\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:setState\"]"
        },
        "index": {
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "setState",
          "normalized": "a-\u003eIO()",
          "package": "base",
          "partial": "State",
          "signature": "state-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:setState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea string that can be passed to \u003ccode\u003emkTextEncoding\u003c/code\u003e to\n create an equivalent \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding.Types\",\"GHC.IO.Encoding\"]",
          "name": "textEncodingName",
          "package": "base",
          "signature": "String",
          "source": "src/GHC-IO-Encoding-Types.html#TextEncoding",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:textEncodingName\",\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:textEncodingName\"]"
        },
        "index": {
          "description": "string that can be passed to mkTextEncoding to create an equivalent TextEncoding",
          "hierarchy": "GHC IO Encoding Types",
          "module": "GHC.IO.Encoding.Types",
          "name": "textEncodingName",
          "package": "base",
          "partial": "Encoding Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-Types.html#v:textEncodingName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUTF-16 Codecs for the IO library\n\u003c/p\u003e\u003cp\u003ePortions Copyright   : (c) Tom Harper 2008-2009,\n                        (c) Bryan O'Sullivan 2009,\n                        (c) Duncan Coutts 2009\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.IO.Encoding.UTF16",
          "name": "UTF16",
          "package": "base",
          "source": "src/GHC-IO-Encoding-UTF16.html",
          "type": "module"
        },
        "index": {
          "description": "UTF-16 Codecs for the IO library Portions Copyright Tom Harper Bryan Sullivan Duncan Coutts",
          "hierarchy": "GHC IO Encoding UTF16",
          "module": "GHC.IO.Encoding.UTF16",
          "name": "UTF16",
          "package": "base",
          "partial": "UTF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF16.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF16",
          "name": "mkUTF16",
          "package": "base",
          "signature": "CodingFailureMode -\u003e TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF16.html#mkUTF16",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF16",
          "module": "GHC.IO.Encoding.UTF16",
          "name": "mkUTF16",
          "normalized": "CodingFailureMode-\u003eTextEncoding",
          "package": "base",
          "partial": "UTF",
          "signature": "CodingFailureMode-\u003eTextEncoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF16.html#v:mkUTF16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF16",
          "name": "mkUTF16be",
          "package": "base",
          "signature": "CodingFailureMode -\u003e TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF16.html#mkUTF16be",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF16",
          "module": "GHC.IO.Encoding.UTF16",
          "name": "mkUTF16be",
          "normalized": "CodingFailureMode-\u003eTextEncoding",
          "package": "base",
          "partial": "UTF",
          "signature": "CodingFailureMode-\u003eTextEncoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF16.html#v:mkUTF16be"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF16",
          "name": "mkUTF16le",
          "package": "base",
          "signature": "CodingFailureMode -\u003e TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF16.html#mkUTF16le",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF16",
          "module": "GHC.IO.Encoding.UTF16",
          "name": "mkUTF16le",
          "normalized": "CodingFailureMode-\u003eTextEncoding",
          "package": "base",
          "partial": "UTF",
          "signature": "CodingFailureMode-\u003eTextEncoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF16.html#v:mkUTF16le"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF16.html#utf16",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF16",
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF16.html#v:utf16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16_decode",
          "package": "base",
          "signature": "IORef (Maybe DecodeBuffer) -\u003e DecodeBuffer",
          "source": "src/GHC-IO-Encoding-UTF16.html#utf16_decode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF16",
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16_decode",
          "normalized": "IORef(Maybe DecodeBuffer)-\u003eDecodeBuffer",
          "package": "base",
          "signature": "IORef(Maybe DecodeBuffer)-\u003eDecodeBuffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF16.html#v:utf16_decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16_encode",
          "package": "base",
          "signature": "IORef Bool -\u003e EncodeBuffer",
          "source": "src/GHC-IO-Encoding-UTF16.html#utf16_encode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF16",
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16_encode",
          "normalized": "IORef Bool-\u003eEncodeBuffer",
          "package": "base",
          "signature": "IORef Bool-\u003eEncodeBuffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF16.html#v:utf16_encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16be",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF16.html#utf16be",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF16",
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16be",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF16.html#v:utf16be"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16be_decode",
          "package": "base",
          "signature": "DecodeBuffer",
          "source": "src/GHC-IO-Encoding-UTF16.html#utf16be_decode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF16",
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16be_decode",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF16.html#v:utf16be_decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16be_encode",
          "package": "base",
          "signature": "EncodeBuffer",
          "source": "src/GHC-IO-Encoding-UTF16.html#utf16be_encode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF16",
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16be_encode",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF16.html#v:utf16be_encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16le",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF16.html#utf16le",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF16",
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16le",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF16.html#v:utf16le"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16le_decode",
          "package": "base",
          "signature": "DecodeBuffer",
          "source": "src/GHC-IO-Encoding-UTF16.html#utf16le_decode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF16",
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16le_decode",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF16.html#v:utf16le_decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16le_encode",
          "package": "base",
          "signature": "EncodeBuffer",
          "source": "src/GHC-IO-Encoding-UTF16.html#utf16le_encode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF16",
          "module": "GHC.IO.Encoding.UTF16",
          "name": "utf16le_encode",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF16.html#v:utf16le_encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUTF-32 Codecs for the IO library\n\u003c/p\u003e\u003cp\u003ePortions Copyright   : (c) Tom Harper 2008-2009,\n                        (c) Bryan O'Sullivan 2009,\n                        (c) Duncan Coutts 2009\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.IO.Encoding.UTF32",
          "name": "UTF32",
          "package": "base",
          "source": "src/GHC-IO-Encoding-UTF32.html",
          "type": "module"
        },
        "index": {
          "description": "UTF-32 Codecs for the IO library Portions Copyright Tom Harper Bryan Sullivan Duncan Coutts",
          "hierarchy": "GHC IO Encoding UTF32",
          "module": "GHC.IO.Encoding.UTF32",
          "name": "UTF32",
          "package": "base",
          "partial": "UTF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF32.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF32",
          "name": "mkUTF32",
          "package": "base",
          "signature": "CodingFailureMode -\u003e TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF32.html#mkUTF32",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF32",
          "module": "GHC.IO.Encoding.UTF32",
          "name": "mkUTF32",
          "normalized": "CodingFailureMode-\u003eTextEncoding",
          "package": "base",
          "partial": "UTF",
          "signature": "CodingFailureMode-\u003eTextEncoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF32.html#v:mkUTF32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF32",
          "name": "mkUTF32be",
          "package": "base",
          "signature": "CodingFailureMode -\u003e TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF32.html#mkUTF32be",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF32",
          "module": "GHC.IO.Encoding.UTF32",
          "name": "mkUTF32be",
          "normalized": "CodingFailureMode-\u003eTextEncoding",
          "package": "base",
          "partial": "UTF",
          "signature": "CodingFailureMode-\u003eTextEncoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF32.html#v:mkUTF32be"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF32",
          "name": "mkUTF32le",
          "package": "base",
          "signature": "CodingFailureMode -\u003e TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF32.html#mkUTF32le",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF32",
          "module": "GHC.IO.Encoding.UTF32",
          "name": "mkUTF32le",
          "normalized": "CodingFailureMode-\u003eTextEncoding",
          "package": "base",
          "partial": "UTF",
          "signature": "CodingFailureMode-\u003eTextEncoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF32.html#v:mkUTF32le"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF32.html#utf32",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF32",
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF32.html#v:utf32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32_decode",
          "package": "base",
          "signature": "IORef (Maybe DecodeBuffer) -\u003e DecodeBuffer",
          "source": "src/GHC-IO-Encoding-UTF32.html#utf32_decode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF32",
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32_decode",
          "normalized": "IORef(Maybe DecodeBuffer)-\u003eDecodeBuffer",
          "package": "base",
          "signature": "IORef(Maybe DecodeBuffer)-\u003eDecodeBuffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF32.html#v:utf32_decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32_encode",
          "package": "base",
          "signature": "IORef Bool -\u003e EncodeBuffer",
          "source": "src/GHC-IO-Encoding-UTF32.html#utf32_encode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF32",
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32_encode",
          "normalized": "IORef Bool-\u003eEncodeBuffer",
          "package": "base",
          "signature": "IORef Bool-\u003eEncodeBuffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF32.html#v:utf32_encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32be",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF32.html#utf32be",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF32",
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32be",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF32.html#v:utf32be"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32be_decode",
          "package": "base",
          "signature": "DecodeBuffer",
          "source": "src/GHC-IO-Encoding-UTF32.html#utf32be_decode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF32",
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32be_decode",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF32.html#v:utf32be_decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32be_encode",
          "package": "base",
          "signature": "EncodeBuffer",
          "source": "src/GHC-IO-Encoding-UTF32.html#utf32be_encode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF32",
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32be_encode",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF32.html#v:utf32be_encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32le",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF32.html#utf32le",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF32",
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32le",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF32.html#v:utf32le"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32le_decode",
          "package": "base",
          "signature": "DecodeBuffer",
          "source": "src/GHC-IO-Encoding-UTF32.html#utf32le_decode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF32",
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32le_decode",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF32.html#v:utf32le_decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32le_encode",
          "package": "base",
          "signature": "EncodeBuffer",
          "source": "src/GHC-IO-Encoding-UTF32.html#utf32le_encode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF32",
          "module": "GHC.IO.Encoding.UTF32",
          "name": "utf32le_encode",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF32.html#v:utf32le_encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUTF-8 Codec for the IO library\n\u003c/p\u003e\u003cp\u003ePortions Copyright   : (c) Tom Harper 2008-2009,\n                        (c) Bryan O'Sullivan 2009,\n                        (c) Duncan Coutts 2009\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.IO.Encoding.UTF8",
          "name": "UTF8",
          "package": "base",
          "source": "src/GHC-IO-Encoding-UTF8.html",
          "type": "module"
        },
        "index": {
          "description": "UTF-8 Codec for the IO library Portions Copyright Tom Harper Bryan Sullivan Duncan Coutts",
          "hierarchy": "GHC IO Encoding UTF8",
          "module": "GHC.IO.Encoding.UTF8",
          "name": "UTF8",
          "package": "base",
          "partial": "UTF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF8.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF8",
          "name": "mkUTF8",
          "package": "base",
          "signature": "CodingFailureMode -\u003e TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF8.html#mkUTF8",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF8",
          "module": "GHC.IO.Encoding.UTF8",
          "name": "mkUTF8",
          "normalized": "CodingFailureMode-\u003eTextEncoding",
          "package": "base",
          "partial": "UTF",
          "signature": "CodingFailureMode-\u003eTextEncoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF8.html#v:mkUTF8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF8",
          "name": "mkUTF8_bom",
          "package": "base",
          "signature": "CodingFailureMode -\u003e TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF8.html#mkUTF8_bom",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF8",
          "module": "GHC.IO.Encoding.UTF8",
          "name": "mkUTF8_bom",
          "normalized": "CodingFailureMode-\u003eTextEncoding",
          "package": "base",
          "partial": "UTF",
          "signature": "CodingFailureMode-\u003eTextEncoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF8.html#v:mkUTF8_bom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF8",
          "name": "utf8",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF8.html#utf8",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF8",
          "module": "GHC.IO.Encoding.UTF8",
          "name": "utf8",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF8.html#v:utf8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding.UTF8",
          "name": "utf8_bom",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding-UTF8.html#utf8_bom",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding UTF8",
          "module": "GHC.IO.Encoding.UTF8",
          "name": "utf8_bom",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding-UTF8.html#v:utf8_bom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eText codecs for I/O\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.IO.Encoding",
          "name": "Encoding",
          "package": "base",
          "source": "src/GHC-IO-Encoding.html",
          "type": "module"
        },
        "index": {
          "description": "Text codecs for",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "Encoding",
          "package": "base",
          "partial": "Encoding",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding",
          "name": "BufferCodec",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Types.html#BufferCodec",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "BufferCodec",
          "package": "base",
          "partial": "Buffer Codec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#t:BufferCodec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding",
          "name": "CodingProgress",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Types.html#CodingProgress",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "CodingProgress",
          "package": "base",
          "partial": "Coding Progress",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#t:CodingProgress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding",
          "name": "TextDecoder",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Types.html#TextDecoder",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "TextDecoder",
          "package": "base",
          "partial": "Text Decoder",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#t:TextDecoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding",
          "name": "TextEncoder",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Types.html#TextEncoder",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "TextEncoder",
          "package": "base",
          "partial": "Text Encoder",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#t:TextEncoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e is a specification of a conversion scheme\n between sequences of bytes and sequences of Unicode characters.\n\u003c/p\u003e\u003cp\u003eFor example, UTF-8 is an encoding of Unicode characters into a sequence\n of bytes.  The \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e for UTF-8 is \u003ccode\u003eutf8\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "GHC.IO.Encoding",
          "name": "TextEncoding",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Types.html#TextEncoding",
          "type": "data"
        },
        "index": {
          "description": "TextEncoding is specification of conversion scheme between sequences of bytes and sequences of Unicode characters For example UTF-8 is an encoding of Unicode characters into sequence of bytes The TextEncoding for UTF-8 is utf8",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "TextEncoding",
          "package": "base",
          "partial": "Text Encoding",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#t:TextEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn encoding in which Unicode code points are translated to bytes\n by taking the code point modulo 256.  When decoding, bytes are\n translated directly into the equivalent code point.\n\u003c/p\u003e\u003cp\u003eThis encoding never fails in either direction.  However, encoding\n discards information, so encode followed by decode is not the\n identity.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding\",\"System.IO\"]",
          "name": "char8",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding.html#char8",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:char8\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:char8\"]"
        },
        "index": {
          "description": "An encoding in which Unicode code points are translated to bytes by taking the code point modulo When decoding bytes are translated directly into the equivalent code point This encoding never fails in either direction However encoding discards information so encode followed by decode is not the identity",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "char8",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:char8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Unicode encoding of the current locale, but allowing arbitrary\n undecodable bytes to be round-tripped through it.\n\u003c/p\u003e\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e is used to decode and encode command line arguments\n and environment variables on non-Windows platforms.\n\u003c/p\u003e\u003cp\u003eOn Windows, this encoding *should not* be used if possible because\n the use of code pages is deprecated: Strings should be retrieved\n via the \u003ca\u003ewide\u003c/a\u003e W-family of UTF-16 APIs instead\n\u003c/p\u003e",
          "module": "GHC.IO.Encoding",
          "name": "getFileSystemEncoding",
          "package": "base",
          "signature": "IO TextEncoding",
          "source": "src/GHC-IO-Encoding.html#getFileSystemEncoding",
          "type": "function"
        },
        "index": {
          "description": "The Unicode encoding of the current locale but allowing arbitrary undecodable bytes to be round-tripped through it This TextEncoding is used to decode and encode command line arguments and environment variables on non-Windows platforms On Windows this encoding should not be used if possible because the use of code pages is deprecated Strings should be retrieved via the wide W-family of UTF-16 APIs instead",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "getFileSystemEncoding",
          "package": "base",
          "partial": "File System Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:getFileSystemEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Unicode encoding of the current locale, but where undecodable\n bytes are replaced with their closest visual match. Used for\n the \u003ccode\u003eCString\u003c/code\u003e marshalling functions in \u003ca\u003eForeign.C.String\u003c/a\u003e\n\u003c/p\u003e",
          "module": "GHC.IO.Encoding",
          "name": "getForeignEncoding",
          "package": "base",
          "signature": "IO TextEncoding",
          "source": "src/GHC-IO-Encoding.html#getForeignEncoding",
          "type": "function"
        },
        "index": {
          "description": "The Unicode encoding of the current locale but where undecodable bytes are replaced with their closest visual match Used for the CString marshalling functions in Foreign.C.String",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "getForeignEncoding",
          "package": "base",
          "partial": "Foreign Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:getForeignEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Unicode encoding of the current locale\n\u003c/p\u003e",
          "module": "GHC.IO.Encoding",
          "name": "getLocaleEncoding",
          "package": "base",
          "signature": "IO TextEncoding",
          "source": "src/GHC-IO-Encoding.html#getLocaleEncoding",
          "type": "function"
        },
        "index": {
          "description": "The Unicode encoding of the current locale",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "getLocaleEncoding",
          "package": "base",
          "partial": "Locale Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:getLocaleEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding",
          "name": "initLocaleEncoding",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding.html#initLocaleEncoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "initLocaleEncoding",
          "package": "base",
          "partial": "Locale Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:initLocaleEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Latin1 (ISO8859-1) encoding.  This encoding maps bytes\n directly to the first 256 Unicode code points, and is thus not a\n complete Unicode encoding.  An attempt to write a character greater than\n '\\255' to a \u003ccode\u003eHandle\u003c/code\u003e using the \u003ccode\u003e\u003ca\u003elatin1\u003c/a\u003e\u003c/code\u003e encoding will result in an error.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding\",\"System.IO\"]",
          "name": "latin1",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding.html#latin1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:latin1\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:latin1\"]"
        },
        "index": {
          "description": "The Latin1 ISO8859-1 encoding This encoding maps bytes directly to the first Unicode code points and is thus not complete Unicode encoding An attempt to write character greater than to Handle using the latin1 encoding will result in an error",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "latin1",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:latin1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding",
          "name": "latin1_decode",
          "package": "base",
          "signature": "Buffer Word8 -\u003e CharBuffer -\u003e IO (Buffer Word8, CharBuffer)",
          "source": "src/GHC-IO-Encoding.html#latin1_decode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "latin1_decode",
          "normalized": "Buffer Word-\u003eCharBuffer-\u003eIO(Buffer Word,CharBuffer)",
          "package": "base",
          "signature": "Buffer Word-\u003eCharBuffer-\u003eIO(Buffer Word,CharBuffer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:latin1_decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding",
          "name": "latin1_encode",
          "package": "base",
          "signature": "CharBuffer -\u003e Buffer Word8 -\u003e IO (CharBuffer, Buffer Word8)",
          "source": "src/GHC-IO-Encoding.html#latin1_encode",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "latin1_encode",
          "normalized": "CharBuffer-\u003eBuffer Word-\u003eIO(CharBuffer,Buffer Word)",
          "package": "base",
          "signature": "CharBuffer-\u003eBuffer Word-\u003eIO(CharBuffer,Buffer Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:latin1_encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLook up the named Unicode encoding.  May fail with \n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eisDoesNotExistError\u003c/code\u003e if the encoding is unknown\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe set of known encodings is system-dependent, but includes at least:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003eUTF-8\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e \u003ccode\u003eUTF-16\u003c/code\u003e, \u003ccode\u003eUTF-16BE\u003c/code\u003e, \u003ccode\u003eUTF-16LE\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eUTF-32\u003c/code\u003e, \u003ccode\u003eUTF-32BE\u003c/code\u003e, \u003ccode\u003eUTF-32LE\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOn systems using GNU iconv (e.g. Linux), there is additional\n notation for specifying how illegal characters are handled:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e a suffix of \u003ccode\u003e//IGNORE\u003c/code\u003e, e.g. \u003ccode\u003eUTF-8//IGNORE\u003c/code\u003e, will cause \n    all illegal sequences on input to be ignored, and on output\n    will drop all code points that have no representation in the\n    target encoding.\n\u003c/li\u003e\u003cli\u003e a suffix of \u003ccode\u003e//TRANSLIT\u003c/code\u003e will choose a replacement character\n    for illegal sequences or code points.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOn Windows, you can access supported code pages with the prefix\n \u003ccode\u003eCP\u003c/code\u003e; for example, \u003ccode\u003e\"CP1250\"\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding\",\"System.IO\"]",
          "name": "mkTextEncoding",
          "package": "base",
          "signature": "String -\u003e IO TextEncoding",
          "source": "src/GHC-IO-Encoding.html#mkTextEncoding",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:mkTextEncoding\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:mkTextEncoding\"]"
        },
        "index": {
          "description": "Look up the named Unicode encoding May fail with isDoesNotExistError if the encoding is unknown The set of known encodings is system-dependent but includes at least UTF-8 UTF-16 UTF-16BE UTF-16LE UTF-32 UTF-32BE UTF-32LE On systems using GNU iconv e.g Linux there is additional notation for specifying how illegal characters are handled suffix of IGNORE e.g UTF-8 IGNORE will cause all illegal sequences on input to be ignored and on output will drop all code points that have no representation in the target encoding suffix of TRANSLIT will choose replacement character for illegal sequences or code points On Windows you can access supported code pages with the prefix CP for example CP1250",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "mkTextEncoding",
          "normalized": "String-\u003eIO TextEncoding",
          "package": "base",
          "partial": "Text Encoding",
          "signature": "String-\u003eIO TextEncoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:mkTextEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding",
          "name": "setFileSystemEncoding",
          "package": "base",
          "signature": "TextEncoding -\u003e IO ()",
          "source": "src/GHC-IO-Encoding.html#setFileSystemEncoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "setFileSystemEncoding",
          "normalized": "TextEncoding-\u003eIO()",
          "package": "base",
          "partial": "File System Encoding",
          "signature": "TextEncoding-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:setFileSystemEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding",
          "name": "setForeignEncoding",
          "package": "base",
          "signature": "TextEncoding -\u003e IO ()",
          "source": "src/GHC-IO-Encoding.html#setForeignEncoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "setForeignEncoding",
          "normalized": "TextEncoding-\u003eIO()",
          "package": "base",
          "partial": "Foreign Encoding",
          "signature": "TextEncoding-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:setForeignEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Encoding",
          "name": "setLocaleEncoding",
          "package": "base",
          "signature": "TextEncoding -\u003e IO ()",
          "source": "src/GHC-IO-Encoding.html#setLocaleEncoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "setLocaleEncoding",
          "normalized": "TextEncoding-\u003eIO()",
          "package": "base",
          "partial": "Locale Encoding",
          "signature": "TextEncoding-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:setLocaleEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe UTF-16 Unicode encoding (a byte-order-mark should be used to\n indicate endianness).\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding\",\"System.IO\"]",
          "name": "utf16",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding.html#utf16",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf16\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:utf16\"]"
        },
        "index": {
          "description": "The UTF-16 Unicode encoding byte-order-mark should be used to indicate endianness",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "utf16",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe UTF-16 Unicode encoding (big-endian)\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding\",\"System.IO\"]",
          "name": "utf16be",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding.html#utf16be",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf16be\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:utf16be\"]"
        },
        "index": {
          "description": "The UTF-16 Unicode encoding big-endian",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "utf16be",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf16be"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe UTF-16 Unicode encoding (litte-endian)\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding\",\"System.IO\"]",
          "name": "utf16le",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding.html#utf16le",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf16le\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:utf16le\"]"
        },
        "index": {
          "description": "The UTF-16 Unicode encoding litte-endian",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "utf16le",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf16le"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe UTF-32 Unicode encoding (a byte-order-mark should be used to\n indicate endianness).\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding\",\"System.IO\"]",
          "name": "utf32",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding.html#utf32",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf32\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:utf32\"]"
        },
        "index": {
          "description": "The UTF-32 Unicode encoding byte-order-mark should be used to indicate endianness",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "utf32",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe UTF-32 Unicode encoding (big-endian)\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding\",\"System.IO\"]",
          "name": "utf32be",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding.html#utf32be",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf32be\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:utf32be\"]"
        },
        "index": {
          "description": "The UTF-32 Unicode encoding big-endian",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "utf32be",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf32be"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe UTF-32 Unicode encoding (litte-endian)\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding\",\"System.IO\"]",
          "name": "utf32le",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding.html#utf32le",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf32le\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:utf32le\"]"
        },
        "index": {
          "description": "The UTF-32 Unicode encoding litte-endian",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "utf32le",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf32le"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe UTF-8 Unicode encoding\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding\",\"System.IO\"]",
          "name": "utf8",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding.html#utf8",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf8\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:utf8\"]"
        },
        "index": {
          "description": "The UTF-8 Unicode encoding",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "utf8",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte\n sequence 0xEF 0xBB 0xBF).  This encoding behaves like \u003ccode\u003e\u003ca\u003eutf8\u003c/a\u003e\u003c/code\u003e,\n except that on input, the BOM sequence is ignored at the beginning\n of the stream, and on output, the BOM sequence is prepended.\n\u003c/p\u003e\u003cp\u003eThe byte-order-mark is strictly unnecessary in UTF-8, but is\n sometimes used to identify the encoding of a file.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Encoding\",\"System.IO\"]",
          "name": "utf8_bom",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/GHC-IO-Encoding.html#utf8_bom",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf8_bom\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:utf8_bom\"]"
        },
        "index": {
          "description": "The UTF-8 Unicode encoding with byte-order-mark BOM the byte sequence xEF xBB xBF This encoding behaves like utf8 except that on input the BOM sequence is ignored at the beginning of the stream and on output the BOM sequence is prepended The byte-order-mark is strictly unnecessary in UTF-8 but is sometimes used to identify the encoding of file",
          "hierarchy": "GHC IO Encoding",
          "module": "GHC.IO.Encoding",
          "name": "utf8_bom",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Encoding.html#v:utf8_bom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHandle operations implemented by file descriptors (FDs)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.IO.Handle.FD",
          "name": "FD",
          "package": "base",
          "source": "src/GHC-IO-Handle-FD.html",
          "type": "module"
        },
        "index": {
          "description": "Handle operations implemented by file descriptors FDs",
          "hierarchy": "GHC IO Handle FD",
          "module": "GHC.IO.Handle.FD",
          "name": "FD",
          "package": "base",
          "partial": "FD",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn an existing file descriptor into a Handle.  This is used by\n various external libraries to make Handles.\n\u003c/p\u003e\u003cp\u003eMakes a binary Handle.  This is for historical reasons; it should\n probably be a text Handle with the default encoding and newline\n translation instead.\n\u003c/p\u003e",
          "module": "GHC.IO.Handle.FD",
          "name": "fdToHandle",
          "package": "base",
          "signature": "FD -\u003e IO Handle",
          "source": "src/GHC-IO-Handle-FD.html#fdToHandle",
          "type": "function"
        },
        "index": {
          "description": "Turn an existing file descriptor into Handle This is used by various external libraries to make Handles Makes binary Handle This is for historical reasons it should probably be text Handle with the default encoding and newline translation instead",
          "hierarchy": "GHC IO Handle FD",
          "module": "GHC.IO.Handle.FD",
          "name": "fdToHandle",
          "normalized": "FD-\u003eIO Handle",
          "package": "base",
          "partial": "To Handle",
          "signature": "FD-\u003eIO Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:fdToHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOld API kept to avoid breaking clients\n\u003c/p\u003e",
          "module": "GHC.IO.Handle.FD",
          "name": "fdToHandle'",
          "package": "base",
          "signature": "CInt -\u003e Maybe IODeviceType -\u003e Bool -\u003e FilePath -\u003e IOMode -\u003e Bool -\u003e IO Handle",
          "source": "src/GHC-IO-Handle-FD.html#fdToHandle%27",
          "type": "function"
        },
        "index": {
          "description": "Old API kept to avoid breaking clients",
          "hierarchy": "GHC IO Handle FD",
          "module": "GHC.IO.Handle.FD",
          "name": "fdToHandle'",
          "normalized": "CInt-\u003eMaybe IODeviceType-\u003eBool-\u003eFilePath-\u003eIOMode-\u003eBool-\u003eIO Handle",
          "package": "base",
          "partial": "To Handle'",
          "signature": "CInt-\u003eMaybe IODeviceType-\u003eBool-\u003eFilePath-\u003eIOMode-\u003eBool-\u003eIO Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:fdToHandle-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe computation \u003ccode\u003e\u003ca\u003eisEOF\u003c/a\u003e\u003c/code\u003e is identical to \u003ccode\u003e\u003ca\u003ehIsEOF\u003c/a\u003e\u003c/code\u003e,\n except that it works only on \u003ccode\u003e\u003ca\u003estdin\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle.FD\",\"System.IO\"]",
          "name": "isEOF",
          "package": "base",
          "signature": "IO Bool",
          "source": "src/GHC-IO-Handle-FD.html#isEOF",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:isEOF\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:isEOF\"]"
        },
        "index": {
          "description": "The computation isEOF is identical to hIsEOF except that it works only on stdin",
          "hierarchy": "GHC IO Handle FD",
          "module": "GHC.IO.Handle.FD",
          "name": "isEOF",
          "package": "base",
          "partial": "EOF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:isEOF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Handle.FD",
          "name": "mkHandleFromFD",
          "package": "base",
          "signature": "FD -\u003e IODeviceType -\u003e FilePath -\u003e IOMode -\u003e Bool -\u003e Maybe TextEncoding -\u003e IO Handle",
          "source": "src/GHC-IO-Handle-FD.html#mkHandleFromFD",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Handle FD",
          "module": "GHC.IO.Handle.FD",
          "name": "mkHandleFromFD",
          "normalized": "FD-\u003eIODeviceType-\u003eFilePath-\u003eIOMode-\u003eBool-\u003eMaybe TextEncoding-\u003eIO Handle",
          "package": "base",
          "partial": "Handle From FD",
          "signature": "FD-\u003eIODeviceType-\u003eFilePath-\u003eIOMode-\u003eBool-\u003eMaybe TextEncoding-\u003eIO Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:mkHandleFromFD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eopenFile\u003c/a\u003e\u003c/code\u003e, but open the file in binary mode.\n On Windows, reading a file in text mode (which is the default)\n will translate CRLF to LF, and writing will translate LF to CRLF.\n This is usually what you want with text files.  With binary files\n this is undesirable; also, as usual under Microsoft operating systems,\n text mode treats control-Z as EOF.  Binary mode turns off all special\n treatment of end-of-line and end-of-file characters.\n (See also \u003ccode\u003e\u003ca\u003ehSetBinaryMode\u003c/a\u003e\u003c/code\u003e.)\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle.FD\",\"System.IO\"]",
          "name": "openBinaryFile",
          "package": "base",
          "signature": "FilePath -\u003e IOMode -\u003e IO Handle",
          "source": "src/GHC-IO-Handle-FD.html#openBinaryFile",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:openBinaryFile\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:openBinaryFile\"]"
        },
        "index": {
          "description": "Like openFile but open the file in binary mode On Windows reading file in text mode which is the default will translate CRLF to LF and writing will translate LF to CRLF This is usually what you want with text files With binary files this is undesirable also as usual under Microsoft operating systems text mode treats control-Z as EOF Binary mode turns off all special treatment of end-of-line and end-of-file characters See also hSetBinaryMode",
          "hierarchy": "GHC IO Handle FD",
          "module": "GHC.IO.Handle.FD",
          "name": "openBinaryFile",
          "normalized": "FilePath-\u003eIOMode-\u003eIO Handle",
          "package": "base",
          "partial": "Binary File",
          "signature": "FilePath-\u003eIOMode-\u003eIO Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:openBinaryFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003eopenFile\u003c/a\u003e\u003c/code\u003e \u003ccode\u003efile mode\u003c/code\u003e allocates and returns a new, open\n handle to manage the file \u003ccode\u003efile\u003c/code\u003e.  It manages input if \u003ccode\u003emode\u003c/code\u003e\n is \u003ccode\u003e\u003ca\u003eReadMode\u003c/a\u003e\u003c/code\u003e, output if \u003ccode\u003emode\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eWriteMode\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eAppendMode\u003c/a\u003e\u003c/code\u003e,\n and both input and output if mode is \u003ccode\u003e\u003ca\u003eReadWriteMode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the file does not exist and it is opened for output, it should be\n created as a new file.  If \u003ccode\u003emode\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eWriteMode\u003c/a\u003e\u003c/code\u003e and the file\n already exists, then it should be truncated to zero length.\n Some operating systems delete empty files, so there is no guarantee\n that the file will exist following an \u003ccode\u003e\u003ca\u003eopenFile\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003emode\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eWriteMode\u003c/a\u003e\u003c/code\u003e unless it is subsequently written to successfully.\n The handle is positioned at the end of the file if \u003ccode\u003emode\u003c/code\u003e is\n \u003ccode\u003e\u003ca\u003eAppendMode\u003c/a\u003e\u003c/code\u003e, and otherwise at the beginning (in which case its\n internal position is 0).\n The initial buffer mode is implementation-dependent.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eisAlreadyInUseError\u003c/code\u003e if the file is already open and cannot be reopened;\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eisDoesNotExistError\u003c/code\u003e if the file does not exist; or\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eisPermissionError\u003c/code\u003e if the user does not have permission to open the file.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNote: if you will be working with files containing binary data, you'll want to\n be using \u003ccode\u003e\u003ca\u003eopenBinaryFile\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle.FD\",\"System.IO\"]",
          "name": "openFile",
          "package": "base",
          "signature": "FilePath -\u003e IOMode -\u003e IO Handle",
          "source": "src/GHC-IO-Handle-FD.html#openFile",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:openFile\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:openFile\"]"
        },
        "index": {
          "description": "Computation openFile file mode allocates and returns new open handle to manage the file file It manages input if mode is ReadMode output if mode is WriteMode or AppendMode and both input and output if mode is ReadWriteMode If the file does not exist and it is opened for output it should be created as new file If mode is WriteMode and the file already exists then it should be truncated to zero length Some operating systems delete empty files so there is no guarantee that the file will exist following an openFile with mode WriteMode unless it is subsequently written to successfully The handle is positioned at the end of the file if mode is AppendMode and otherwise at the beginning in which case its internal position is The initial buffer mode is implementation-dependent This operation may fail with isAlreadyInUseError if the file is already open and cannot be reopened isDoesNotExistError if the file does not exist or isPermissionError if the user does not have permission to open the file Note if you will be working with files containing binary data you ll want to be using openBinaryFile",
          "hierarchy": "GHC IO Handle FD",
          "module": "GHC.IO.Handle.FD",
          "name": "openFile",
          "normalized": "FilePath-\u003eIOMode-\u003eIO Handle",
          "package": "base",
          "partial": "File",
          "signature": "FilePath-\u003eIOMode-\u003eIO Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:openFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eopenFile\u003c/a\u003e\u003c/code\u003e, but opens the file in ordinary blocking mode.\n This can be useful for opening a FIFO for reading: if we open in\n non-blocking mode then the open will fail if there are no writers,\n whereas a blocking open will block until a writer appears.\n\u003c/p\u003e",
          "module": "GHC.IO.Handle.FD",
          "name": "openFileBlocking",
          "package": "base",
          "signature": "FilePath -\u003e IOMode -\u003e IO Handle",
          "source": "src/GHC-IO-Handle-FD.html#openFileBlocking",
          "type": "function"
        },
        "index": {
          "description": "Like openFile but opens the file in ordinary blocking mode This can be useful for opening FIFO for reading if we open in non-blocking mode then the open will fail if there are no writers whereas blocking open will block until writer appears",
          "hierarchy": "GHC IO Handle FD",
          "module": "GHC.IO.Handle.FD",
          "name": "openFileBlocking",
          "normalized": "FilePath-\u003eIOMode-\u003eIO Handle",
          "package": "base",
          "partial": "File Blocking",
          "signature": "FilePath-\u003eIOMode-\u003eIO Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:openFileBlocking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA handle managing output to the Haskell program's standard error channel.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle.FD\",\"System.IO\"]",
          "name": "stderr",
          "package": "base",
          "signature": "Handle",
          "source": "src/GHC-IO-Handle-FD.html#stderr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:stderr\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:stderr\"]"
        },
        "index": {
          "description": "handle managing output to the Haskell program standard error channel",
          "hierarchy": "GHC IO Handle FD",
          "module": "GHC.IO.Handle.FD",
          "name": "stderr",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:stderr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA handle managing input from the Haskell program's standard input channel.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle.FD\",\"System.IO\"]",
          "name": "stdin",
          "package": "base",
          "signature": "Handle",
          "source": "src/GHC-IO-Handle-FD.html#stdin",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:stdin\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:stdin\"]"
        },
        "index": {
          "description": "handle managing input from the Haskell program standard input channel",
          "hierarchy": "GHC IO Handle FD",
          "module": "GHC.IO.Handle.FD",
          "name": "stdin",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:stdin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA handle managing output to the Haskell program's standard output channel.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle.FD\",\"System.IO\"]",
          "name": "stdout",
          "package": "base",
          "signature": "Handle",
          "source": "src/GHC-IO-Handle-FD.html#stdout",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:stdout\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:stdout\"]"
        },
        "index": {
          "description": "handle managing output to the Haskell program standard output channel",
          "hierarchy": "GHC IO Handle FD",
          "module": "GHC.IO.Handle.FD",
          "name": "stdout",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle-FD.html#v:stdout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExternal API for GHC's Handle implementation\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.IO.Handle",
          "name": "Handle",
          "package": "base",
          "source": "src/GHC-IO-Handle.html",
          "type": "module"
        },
        "index": {
          "description": "External API for GHC Handle implementation",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "Handle",
          "package": "base",
          "partial": "Handle",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThree kinds of buffering are supported: line-buffering, \n block-buffering or no-buffering.  These modes have the following\n effects. For output, items are written out, or \u003cem\u003eflushed\u003c/em\u003e,\n from the internal buffer according to the buffer mode:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003cem\u003eline-buffering\u003c/em\u003e: the entire output buffer is flushed\n    whenever a newline is output, the buffer overflows, \n    a \u003ccode\u003e\u003ca\u003ehFlush\u003c/a\u003e\u003c/code\u003e is issued, or the handle is closed.\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eblock-buffering\u003c/em\u003e: the entire buffer is written out whenever it\n    overflows, a \u003ccode\u003e\u003ca\u003ehFlush\u003c/a\u003e\u003c/code\u003e is issued, or the handle is closed.\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eno-buffering\u003c/em\u003e: output is written immediately, and never stored\n    in the buffer.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAn implementation is free to flush the buffer more frequently,\n but not less frequently, than specified above.\n The output buffer is emptied as soon as it has been written out.\n\u003c/p\u003e\u003cp\u003eSimilarly, input occurs according to the buffer mode for the handle:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003cem\u003eline-buffering\u003c/em\u003e: when the buffer for the handle is not empty,\n    the next item is obtained from the buffer; otherwise, when the\n    buffer is empty, characters up to and including the next newline\n    character are read into the buffer.  No characters are available\n    until the newline character is available or the buffer is full.\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eblock-buffering\u003c/em\u003e: when the buffer for the handle becomes empty,\n    the next block of data is read into the buffer.\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eno-buffering\u003c/em\u003e: the next input item is read and returned.\n    The \u003ccode\u003e\u003ca\u003ehLookAhead\u003c/a\u003e\u003c/code\u003e operation implies that even a no-buffered\n    handle may require a one-character buffer.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe default buffering mode when a handle is opened is\n implementation-dependent and may depend on the file system object\n which is attached to that handle.\n For most implementations, physical files will normally be block-buffered \n and terminals will normally be line-buffered.\n\u003c/p\u003e",
          "module": "GHC.IO.Handle",
          "name": "BufferMode",
          "package": "base",
          "source": "src/GHC-IO-Handle-Types.html#BufferMode",
          "type": "data"
        },
        "index": {
          "description": "Three kinds of buffering are supported line-buffering block-buffering or no-buffering These modes have the following effects For output items are written out or flushed from the internal buffer according to the buffer mode line-buffering the entire output buffer is flushed whenever newline is output the buffer overflows hFlush is issued or the handle is closed block-buffering the entire buffer is written out whenever it overflows hFlush is issued or the handle is closed no-buffering output is written immediately and never stored in the buffer An implementation is free to flush the buffer more frequently but not less frequently than specified above The output buffer is emptied as soon as it has been written out Similarly input occurs according to the buffer mode for the handle line-buffering when the buffer for the handle is not empty the next item is obtained from the buffer otherwise when the buffer is empty characters up to and including the next newline character are read into the buffer No characters are available until the newline character is available or the buffer is full block-buffering when the buffer for the handle becomes empty the next block of data is read into the buffer no-buffering the next input item is read and returned The hLookAhead operation implies that even no-buffered handle may require one-character buffer The default buffering mode when handle is opened is implementation-dependent and may depend on the file system object which is attached to that handle For most implementations physical files will normally be block-buffered and terminals will normally be line-buffered",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "BufferMode",
          "package": "base",
          "partial": "Buffer Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#t:BufferMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell defines operations to read and write characters from and to files,\n represented by values of type \u003ccode\u003eHandle\u003c/code\u003e.  Each value of this type is a\n \u003cem\u003ehandle\u003c/em\u003e: a record used by the Haskell run-time system to \u003cem\u003emanage\u003c/em\u003e I/O\n with file system objects.  A handle has at least the following properties:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e whether it manages input or output or both;\n\u003c/li\u003e\u003cli\u003e whether it is \u003cem\u003eopen\u003c/em\u003e, \u003cem\u003eclosed\u003c/em\u003e or \u003cem\u003esemi-closed\u003c/em\u003e;\n\u003c/li\u003e\u003cli\u003e whether the object is seekable;\n\u003c/li\u003e\u003cli\u003e whether buffering is disabled, or enabled on a line or block basis;\n\u003c/li\u003e\u003cli\u003e a buffer (whose length may be zero).\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eMost handles will also have a current I/O position indicating where the next\n input or output operation will occur.  A handle is \u003cem\u003ereadable\u003c/em\u003e if it\n manages only input or both input and output; likewise, it is \u003cem\u003ewritable\u003c/em\u003e if\n it manages only output or both input and output.  A handle is \u003cem\u003eopen\u003c/em\u003e when\n first allocated.\n Once it is closed it can no longer be used for either input or output,\n though an implementation cannot re-use its storage while references\n remain to it.  Handles are in the \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e classes.  The string\n produced by showing a handle is system dependent; it should include\n enough information to identify the handle for debugging.  A handle is\n equal according to \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e only to itself; no attempt\n is made to compare the internal state of different handles for equality.\n\u003c/p\u003e",
          "module": "GHC.IO.Handle",
          "name": "Handle",
          "package": "base",
          "source": "src/GHC-IO-Handle-Types.html#Handle",
          "type": "data"
        },
        "index": {
          "description": "Haskell defines operations to read and write characters from and to files represented by values of type Handle Each value of this type is handle record used by the Haskell run-time system to manage with file system objects handle has at least the following properties whether it manages input or output or both whether it is open closed or semi-closed whether the object is seekable whether buffering is disabled or enabled on line or block basis buffer whose length may be zero Most handles will also have current position indicating where the next input or output operation will occur handle is readable if it manages only input or both input and output likewise it is writable if it manages only output or both input and output handle is open when first allocated Once it is closed it can no longer be used for either input or output though an implementation cannot re-use its storage while references remain to it Handles are in the Show and Eq classes The string produced by showing handle is system dependent it should include enough information to identify the handle for debugging handle is equal according to only to itself no attempt is made to compare the internal state of different handles for equality",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "Handle",
          "package": "base",
          "partial": "Handle",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#t:Handle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Handle",
          "name": "HandlePosition",
          "package": "base",
          "source": "src/GHC-IO-Handle.html#HandlePosition",
          "type": "type"
        },
        "index": {
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "HandlePosition",
          "package": "base",
          "partial": "Handle Position",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#t:HandlePosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Handle",
          "name": "HandlePosn",
          "package": "base",
          "source": "src/GHC-IO-Handle.html#HandlePosn",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "HandlePosn",
          "package": "base",
          "partial": "Handle Posn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#t:HandlePosn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe representation of a newline in the external file or stream.\n\u003c/p\u003e",
          "module": "GHC.IO.Handle",
          "name": "Newline",
          "package": "base",
          "source": "src/GHC-IO-Handle-Types.html#Newline",
          "type": "data"
        },
        "index": {
          "description": "The representation of newline in the external file or stream",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "Newline",
          "package": "base",
          "partial": "Newline",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#t:Newline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecifies the translation, if any, of newline characters between\n internal Strings and the external file or stream.  Haskell Strings\n are assumed to represent newlines with the '\\n' character; the\n newline mode specifies how to translate '\\n' on output, and what to\n translate into '\\n' on input.\n\u003c/p\u003e",
          "module": "GHC.IO.Handle",
          "name": "NewlineMode",
          "package": "base",
          "source": "src/GHC-IO-Handle-Types.html#NewlineMode",
          "type": "data"
        },
        "index": {
          "description": "Specifies the translation if any of newline characters between internal Strings and the external file or stream Haskell Strings are assumed to represent newlines with the character the newline mode specifies how to translate on output and what to translate into on input",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "NewlineMode",
          "package": "base",
          "partial": "Newline Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#t:NewlineMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA mode that determines the effect of \u003ccode\u003ehSeek\u003c/code\u003e \u003ccode\u003ehdl mode i\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "GHC.IO.Handle",
          "name": "SeekMode",
          "package": "base",
          "source": "src/GHC-IO-Device.html#SeekMode",
          "type": "data"
        },
        "index": {
          "description": "mode that determines the effect of hSeek hdl mode",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "SeekMode",
          "package": "base",
          "partial": "Seek Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#t:SeekMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eblock-buffering should be enabled if possible.\n The size of the buffer is \u003ccode\u003en\u003c/code\u003e items if the argument\n is \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en\u003c/code\u003e and is otherwise implementation-dependent.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "BlockBuffering",
          "package": "base",
          "signature": "BlockBuffering (Maybe Int)",
          "source": "src/GHC-IO-Handle-Types.html#BufferMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:BlockBuffering\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:BlockBuffering\"]"
        },
        "index": {
          "description": "block-buffering should be enabled if possible The size of the buffer is items if the argument is Just and is otherwise implementation-dependent",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "BlockBuffering",
          "package": "base",
          "partial": "Block Buffering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:BlockBuffering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e'\\r\\n'\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "CRLF",
          "package": "base",
          "signature": "CRLF",
          "source": "src/GHC-IO-Handle-Types.html#Newline",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:CRLF\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:CRLF\"]"
        },
        "index": {
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "CRLF",
          "package": "base",
          "partial": "CRLF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:CRLF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Handle",
          "name": "HandlePosn",
          "package": "base",
          "signature": "HandlePosn Handle HandlePosition",
          "source": "src/GHC-IO-Handle.html#HandlePosn",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "HandlePosn",
          "package": "base",
          "partial": "Handle Posn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:HandlePosn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e'\\n'\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "LF",
          "package": "base",
          "signature": "LF",
          "source": "src/GHC-IO-Handle-Types.html#Newline",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:LF\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:LF\"]"
        },
        "index": {
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "LF",
          "package": "base",
          "partial": "LF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:LF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eline-buffering should be enabled if possible.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "LineBuffering",
          "package": "base",
          "signature": "LineBuffering",
          "source": "src/GHC-IO-Handle-Types.html#BufferMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:LineBuffering\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:LineBuffering\"]"
        },
        "index": {
          "description": "line-buffering should be enabled if possible",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "LineBuffering",
          "package": "base",
          "partial": "Line Buffering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:LineBuffering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "NewlineMode",
          "package": "base",
          "signature": "NewlineMode",
          "source": "src/GHC-IO-Handle-Types.html#NewlineMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:NewlineMode\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:NewlineMode\"]"
        },
        "index": {
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "NewlineMode",
          "package": "base",
          "partial": "Newline Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:NewlineMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebuffering is disabled if possible.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "NoBuffering",
          "package": "base",
          "signature": "NoBuffering",
          "source": "src/GHC-IO-Handle-Types.html#BufferMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:NoBuffering\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:NoBuffering\"]"
        },
        "index": {
          "description": "buffering is disabled if possible",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "NoBuffering",
          "package": "base",
          "partial": "No Buffering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:NoBuffering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehClose\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e makes handle \u003ccode\u003ehdl\u003c/code\u003e closed.  Before the\n computation finishes, if \u003ccode\u003ehdl\u003c/code\u003e is writable its buffer is flushed as\n for \u003ccode\u003e\u003ca\u003ehFlush\u003c/a\u003e\u003c/code\u003e.\n Performing \u003ccode\u003e\u003ca\u003ehClose\u003c/a\u003e\u003c/code\u003e on a handle that has already been closed has no effect; \n doing so is not an error.  All other operations on a closed handle will fail.\n If \u003ccode\u003e\u003ca\u003ehClose\u003c/a\u003e\u003c/code\u003e fails for any reason, any further operations (apart from\n \u003ccode\u003e\u003ca\u003ehClose\u003c/a\u003e\u003c/code\u003e) on the handle will still fail as if \u003ccode\u003ehdl\u003c/code\u003e had been successfully\n closed.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hClose",
          "package": "base",
          "signature": "Handle -\u003e IO ()",
          "source": "src/GHC-IO-Handle.html#hClose",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hClose\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hClose\"]"
        },
        "index": {
          "description": "Computation hClose hdl makes handle hdl closed Before the computation finishes if hdl is writable its buffer is flushed as for hFlush Performing hClose on handle that has already been closed has no effect doing so is not an error All other operations on closed handle will fail If hClose fails for any reason any further operations apart from hClose on the handle will still fail as if hdl had been successfully closed",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hClose",
          "normalized": "Handle-\u003eIO()",
          "package": "base",
          "partial": "Close",
          "signature": "Handle-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IO.Handle",
          "name": "hClose_help",
          "package": "base",
          "signature": "Handle__ -\u003e IO (Handle__, Maybe SomeException)",
          "source": "src/GHC-IO-Handle-Internals.html#hClose_help",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hClose_help",
          "normalized": "Handle__-\u003eIO(Handle__,Maybe SomeException)",
          "package": "base",
          "partial": "Close",
          "signature": "Handle__-\u003eIO(Handle__,Maybe SomeException)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hClose_help"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a duplicate of the original handle, with its own buffer.\n The two Handles will share a file pointer, however.  The original\n handle's buffer is flushed, including discarding any input data,\n before the handle is duplicated.\n\u003c/p\u003e",
          "module": "GHC.IO.Handle",
          "name": "hDuplicate",
          "package": "base",
          "signature": "Handle -\u003e IO Handle",
          "source": "src/GHC-IO-Handle.html#hDuplicate",
          "type": "function"
        },
        "index": {
          "description": "Returns duplicate of the original handle with its own buffer The two Handles will share file pointer however The original handle buffer is flushed including discarding any input data before the handle is duplicated",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hDuplicate",
          "normalized": "Handle-\u003eIO Handle",
          "package": "base",
          "partial": "Duplicate",
          "signature": "Handle-\u003eIO Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hDuplicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMakes the second handle a duplicate of the first handle.  The second \nhandle will be closed first, if it is not already.\n\u003c/p\u003e\u003cp\u003eThis can be used to retarget the standard Handles, for example:\n\u003c/p\u003e\u003cpre\u003e do h \u003c- openFile \"mystdout\" WriteMode\n    hDuplicateTo h stdout\n\u003c/pre\u003e",
          "module": "GHC.IO.Handle",
          "name": "hDuplicateTo",
          "package": "base",
          "signature": "Handle -\u003e Handle -\u003e IO ()",
          "source": "src/GHC-IO-Handle.html#hDuplicateTo",
          "type": "function"
        },
        "index": {
          "description": "Makes the second handle duplicate of the first handle The second handle will be closed first if it is not already This can be used to retarget the standard Handles for example do openFile mystdout WriteMode hDuplicateTo stdout",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hDuplicateTo",
          "normalized": "Handle-\u003eHandle-\u003eIO()",
          "package": "base",
          "partial": "Duplicate To",
          "signature": "Handle-\u003eHandle-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hDuplicateTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor a handle \u003ccode\u003ehdl\u003c/code\u003e which attached to a physical file,\n \u003ccode\u003e\u003ca\u003ehFileSize\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e returns the size of that file in 8-bit bytes.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hFileSize",
          "package": "base",
          "signature": "Handle -\u003e IO Integer",
          "source": "src/GHC-IO-Handle.html#hFileSize",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hFileSize\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hFileSize\"]"
        },
        "index": {
          "description": "For handle hdl which attached to physical file hFileSize hdl returns the size of that file in bit bytes",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hFileSize",
          "normalized": "Handle-\u003eIO Integer",
          "package": "base",
          "partial": "File Size",
          "signature": "Handle-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hFileSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe action \u003ccode\u003e\u003ca\u003ehFlush\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e causes any items buffered for output\n in handle \u003ccode\u003ehdl\u003c/code\u003e to be sent immediately to the operating system.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eisFullError\u003c/code\u003e if the device is full;\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eisPermissionError\u003c/code\u003e if a system resource limit would be exceeded.\n    It is unspecified whether the characters in the buffer are discarded\n    or retained under these circumstances.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hFlush",
          "package": "base",
          "signature": "Handle -\u003e IO ()",
          "source": "src/GHC-IO-Handle.html#hFlush",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hFlush\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hFlush\"]"
        },
        "index": {
          "description": "The action hFlush hdl causes any items buffered for output in handle hdl to be sent immediately to the operating system This operation may fail with isFullError if the device is full isPermissionError if system resource limit would be exceeded It is unspecified whether the characters in the buffer are discarded or retained under these circumstances",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hFlush",
          "normalized": "Handle-\u003eIO()",
          "package": "base",
          "partial": "Flush",
          "signature": "Handle-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hFlush"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe action \u003ccode\u003e\u003ca\u003ehFlushAll\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e flushes all buffered data in \u003ccode\u003ehdl\u003c/code\u003e,\n including any buffered read data.  Buffered read data is flushed\n by seeking the file position back to the point before the bufferred\n data was read, and hence only works if \u003ccode\u003ehdl\u003c/code\u003e is seekable (see\n \u003ccode\u003e\u003ca\u003ehIsSeekable\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eisFullError\u003c/code\u003e if the device is full;\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eisPermissionError\u003c/code\u003e if a system resource limit would be exceeded.\n    It is unspecified whether the characters in the buffer are discarded\n    or retained under these circumstances;\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eisIllegalOperation\u003c/code\u003e if \u003ccode\u003ehdl\u003c/code\u003e has buffered read data, and is not\n    seekable.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "GHC.IO.Handle",
          "name": "hFlushAll",
          "package": "base",
          "signature": "Handle -\u003e IO ()",
          "source": "src/GHC-IO-Handle.html#hFlushAll",
          "type": "function"
        },
        "index": {
          "description": "The action hFlushAll hdl flushes all buffered data in hdl including any buffered read data Buffered read data is flushed by seeking the file position back to the point before the bufferred data was read and hence only works if hdl is seekable see hIsSeekable This operation may fail with isFullError if the device is full isPermissionError if system resource limit would be exceeded It is unspecified whether the characters in the buffer are discarded or retained under these circumstances isIllegalOperation if hdl has buffered read data and is not seekable",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hFlushAll",
          "normalized": "Handle-\u003eIO()",
          "package": "base",
          "partial": "Flush All",
          "signature": "Handle-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hFlushAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBuf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl buf count\u003c/code\u003e reads data from the handle \u003ccode\u003ehdl\u003c/code\u003e\n into the buffer \u003ccode\u003ebuf\u003c/code\u003e until either EOF is reached or\n \u003ccode\u003ecount\u003c/code\u003e 8-bit bytes have been read.\n It returns the number of bytes actually read.  This may be zero if\n EOF was reached before any data was read (or if \u003ccode\u003ecount\u003c/code\u003e is zero).\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBuf\u003c/a\u003e\u003c/code\u003e never raises an EOF exception, instead it returns a value\n smaller than \u003ccode\u003ecount\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the handle is a pipe or socket, and the writing end\n is closed, \u003ccode\u003e\u003ca\u003ehGetBuf\u003c/a\u003e\u003c/code\u003e will behave as if EOF was reached.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBuf\u003c/a\u003e\u003c/code\u003e ignores the prevailing \u003ccode\u003eTextEncoding\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eNewlineMode\u003c/a\u003e\u003c/code\u003e\n on the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e, and reads bytes directly.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hGetBuf",
          "package": "base",
          "signature": "Handle -\u003e Ptr a -\u003e Int -\u003e IO Int",
          "source": "src/GHC-IO-Handle-Text.html#hGetBuf",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetBuf\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hGetBuf\"]"
        },
        "index": {
          "description": "hGetBuf hdl buf count reads data from the handle hdl into the buffer buf until either EOF is reached or count bit bytes have been read It returns the number of bytes actually read This may be zero if EOF was reached before any data was read or if count is zero hGetBuf never raises an EOF exception instead it returns value smaller than count If the handle is pipe or socket and the writing end is closed hGetBuf will behave as if EOF was reached hGetBuf ignores the prevailing TextEncoding and NewlineMode on the Handle and reads bytes directly",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hGetBuf",
          "normalized": "Handle-\u003ePtr a-\u003eInt-\u003eIO Int",
          "package": "base",
          "partial": "Get Buf",
          "signature": "Handle-\u003ePtr a-\u003eInt-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetBuf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufNonBlocking\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl buf count\u003c/code\u003e reads data from the handle \u003ccode\u003ehdl\u003c/code\u003e\n into the buffer \u003ccode\u003ebuf\u003c/code\u003e until either EOF is reached, or\n \u003ccode\u003ecount\u003c/code\u003e 8-bit bytes have been read, or there is no more data available\n to read immediately.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufNonBlocking\u003c/a\u003e\u003c/code\u003e is identical to \u003ccode\u003e\u003ca\u003ehGetBuf\u003c/a\u003e\u003c/code\u003e, except that it will\n never block waiting for data to become available, instead it returns\n only whatever data is available.  To wait for data to arrive before\n calling \u003ccode\u003e\u003ca\u003ehGetBufNonBlocking\u003c/a\u003e\u003c/code\u003e, use \u003ccode\u003e\u003ca\u003ehWaitForInput\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the handle is a pipe or socket, and the writing end\n is closed, \u003ccode\u003e\u003ca\u003ehGetBufNonBlocking\u003c/a\u003e\u003c/code\u003e will behave as if EOF was reached.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufNonBlocking\u003c/a\u003e\u003c/code\u003e ignores the prevailing \u003ccode\u003eTextEncoding\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eNewlineMode\u003c/a\u003e\u003c/code\u003e on the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e, and reads bytes directly.\n\u003c/p\u003e\u003cp\u003eNOTE: on Windows, this function does not work correctly; it\n behaves identically to \u003ccode\u003e\u003ca\u003ehGetBuf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hGetBufNonBlocking",
          "package": "base",
          "signature": "Handle -\u003e Ptr a -\u003e Int -\u003e IO Int",
          "source": "src/GHC-IO-Handle-Text.html#hGetBufNonBlocking",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetBufNonBlocking\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hGetBufNonBlocking\"]"
        },
        "index": {
          "description": "hGetBufNonBlocking hdl buf count reads data from the handle hdl into the buffer buf until either EOF is reached or count bit bytes have been read or there is no more data available to read immediately hGetBufNonBlocking is identical to hGetBuf except that it will never block waiting for data to become available instead it returns only whatever data is available To wait for data to arrive before calling hGetBufNonBlocking use hWaitForInput If the handle is pipe or socket and the writing end is closed hGetBufNonBlocking will behave as if EOF was reached hGetBufNonBlocking ignores the prevailing TextEncoding and NewlineMode on the Handle and reads bytes directly NOTE on Windows this function does not work correctly it behaves identically to hGetBuf",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hGetBufNonBlocking",
          "normalized": "Handle-\u003ePtr a-\u003eInt-\u003eIO Int",
          "package": "base",
          "partial": "Get Buf Non Blocking",
          "signature": "Handle-\u003ePtr a-\u003eInt-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetBufNonBlocking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehGetBuffering\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e returns the current buffering mode\n for \u003ccode\u003ehdl\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hGetBuffering",
          "package": "base",
          "signature": "Handle -\u003e IO BufferMode",
          "source": "src/GHC-IO-Handle.html#hGetBuffering",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetBuffering\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hGetBuffering\"]"
        },
        "index": {
          "description": "Computation hGetBuffering hdl returns the current buffering mode for hdl",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hGetBuffering",
          "normalized": "Handle-\u003eIO BufferMode",
          "package": "base",
          "partial": "Get Buffering",
          "signature": "Handle-\u003eIO BufferMode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetBuffering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehGetChar\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e reads a character from the file or\n channel managed by \u003ccode\u003ehdl\u003c/code\u003e, blocking until a character is available.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisEOFError\u003c/a\u003e\u003c/code\u003e if the end of file has been reached.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hGetChar",
          "package": "base",
          "signature": "Handle -\u003e IO Char",
          "source": "src/GHC-IO-Handle-Text.html#hGetChar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetChar\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hGetChar\"]"
        },
        "index": {
          "description": "Computation hGetChar hdl reads character from the file or channel managed by hdl blocking until character is available This operation may fail with isEOFError if the end of file has been reached",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hGetChar",
          "normalized": "Handle-\u003eIO Char",
          "package": "base",
          "partial": "Get Char",
          "signature": "Handle-\u003eIO Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehGetContents\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e returns the list of characters\n corresponding to the unread portion of the channel or file managed\n by \u003ccode\u003ehdl\u003c/code\u003e, which is put into an intermediate state, \u003cem\u003esemi-closed\u003c/em\u003e.\n In this state, \u003ccode\u003ehdl\u003c/code\u003e is effectively closed,\n but items are read from \u003ccode\u003ehdl\u003c/code\u003e on demand and accumulated in a special\n list returned by \u003ccode\u003e\u003ca\u003ehGetContents\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eAny operation that fails because a handle is closed,\n also fails if a handle is semi-closed.  The only exception is \u003ccode\u003ehClose\u003c/code\u003e.\n A semi-closed handle becomes closed:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e if \u003ccode\u003ehClose\u003c/code\u003e is applied to it;\n\u003c/li\u003e\u003cli\u003e if an I/O error occurs when reading an item from the handle;\n\u003c/li\u003e\u003cli\u003e or once the entire contents of the handle has been read.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOnce a semi-closed handle becomes closed, the contents of the\n associated list becomes fixed.  The contents of this final list is\n only partially specified: it will contain at least all the items of\n the stream that were evaluated prior to the handle becoming closed.\n\u003c/p\u003e\u003cp\u003eAny I/O errors encountered while a handle is semi-closed are simply\n discarded.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisEOFError\u003c/a\u003e\u003c/code\u003e if the end of file has been reached.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hGetContents",
          "package": "base",
          "signature": "Handle -\u003e IO String",
          "source": "src/GHC-IO-Handle-Text.html#hGetContents",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetContents\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hGetContents\"]"
        },
        "index": {
          "description": "Computation hGetContents hdl returns the list of characters corresponding to the unread portion of the channel or file managed by hdl which is put into an intermediate state semi-closed In this state hdl is effectively closed but items are read from hdl on demand and accumulated in special list returned by hGetContents hdl Any operation that fails because handle is closed also fails if handle is semi-closed The only exception is hClose semi-closed handle becomes closed if hClose is applied to it if an error occurs when reading an item from the handle or once the entire contents of the handle has been read Once semi-closed handle becomes closed the contents of the associated list becomes fixed The contents of this final list is only partially specified it will contain at least all the items of the stream that were evaluated prior to the handle becoming closed Any errors encountered while handle is semi-closed are simply discarded This operation may fail with isEOFError if the end of file has been reached",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hGetContents",
          "normalized": "Handle-\u003eIO String",
          "package": "base",
          "partial": "Get Contents",
          "signature": "Handle-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the echoing status of a handle connected to a terminal.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hGetEcho",
          "package": "base",
          "signature": "Handle -\u003e IO Bool",
          "source": "src/GHC-IO-Handle.html#hGetEcho",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetEcho\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hGetEcho\"]"
        },
        "index": {
          "description": "Get the echoing status of handle connected to terminal",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hGetEcho",
          "normalized": "Handle-\u003eIO Bool",
          "package": "base",
          "partial": "Get Echo",
          "signature": "Handle-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetEcho"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the current \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e for the specified \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e, or\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e is in binary mode.\n\u003c/p\u003e\u003cp\u003eNote that the \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e remembers nothing about the state of\n the encoder/decoder in use on this \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.  For example, if the\n encoding in use is UTF-16, then using \u003ccode\u003e\u003ca\u003ehGetEncoding\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003ehSetEncoding\u003c/a\u003e\u003c/code\u003e to save and restore the encoding may result in an\n extra byte-order-mark being written to the file.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hGetEncoding",
          "package": "base",
          "signature": "Handle -\u003e IO (Maybe TextEncoding)",
          "source": "src/GHC-IO-Handle.html#hGetEncoding",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetEncoding\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hGetEncoding\"]"
        },
        "index": {
          "description": "Return the current TextEncoding for the specified Handle or Nothing if the Handle is in binary mode Note that the TextEncoding remembers nothing about the state of the encoder decoder in use on this Handle For example if the encoding in use is UTF-16 then using hGetEncoding and hSetEncoding to save and restore the encoding may result in an extra byte-order-mark being written to the file",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hGetEncoding",
          "normalized": "Handle-\u003eIO(Maybe TextEncoding)",
          "package": "base",
          "partial": "Get Encoding",
          "signature": "Handle-\u003eIO(Maybe TextEncoding)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehGetLine\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e reads a line from the file or\n channel managed by \u003ccode\u003ehdl\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisEOFError\u003c/a\u003e\u003c/code\u003e if the end of file is encountered when reading\n    the \u003cem\u003efirst\u003c/em\u003e character of the line.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIf \u003ccode\u003e\u003ca\u003ehGetLine\u003c/a\u003e\u003c/code\u003e encounters end-of-file at any other point while reading\n in a line, it is treated as a line terminator and the (partial)\n line is returned.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hGetLine",
          "package": "base",
          "signature": "Handle -\u003e IO String",
          "source": "src/GHC-IO-Handle-Text.html#hGetLine",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetLine\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hGetLine\"]"
        },
        "index": {
          "description": "Computation hGetLine hdl reads line from the file or channel managed by hdl This operation may fail with isEOFError if the end of file is encountered when reading the first character of the line If hGetLine encounters end-of-file at any other point while reading in line it is treated as line terminator and the partial line is returned",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hGetLine",
          "normalized": "Handle-\u003eIO String",
          "package": "base",
          "partial": "Get Line",
          "signature": "Handle-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehGetPosn\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e returns the current I/O position of\n \u003ccode\u003ehdl\u003c/code\u003e as a value of the abstract type \u003ccode\u003e\u003ca\u003eHandlePosn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hGetPosn",
          "package": "base",
          "signature": "Handle -\u003e IO HandlePosn",
          "source": "src/GHC-IO-Handle.html#hGetPosn",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetPosn\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hGetPosn\"]"
        },
        "index": {
          "description": "Computation hGetPosn hdl returns the current position of hdl as value of the abstract type HandlePosn",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hGetPosn",
          "normalized": "Handle-\u003eIO HandlePosn",
          "package": "base",
          "partial": "Get Posn",
          "signature": "Handle-\u003eIO HandlePosn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hGetPosn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hIsClosed",
          "package": "base",
          "signature": "Handle -\u003e IO Bool",
          "source": "src/GHC-IO-Handle.html#hIsClosed",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hIsClosed\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hIsClosed\"]"
        },
        "index": {
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hIsClosed",
          "normalized": "Handle-\u003eIO Bool",
          "package": "base",
          "partial": "Is Closed",
          "signature": "Handle-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hIsClosed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor a readable handle \u003ccode\u003ehdl\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ehIsEOF\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e returns\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if no further input can be taken from \u003ccode\u003ehdl\u003c/code\u003e or for a\n physical file, if the current I/O position is equal to the length of\n the file.  Otherwise, it returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNOTE: \u003ccode\u003e\u003ca\u003ehIsEOF\u003c/a\u003e\u003c/code\u003e may block, because it has to attempt to read from\n the stream to determine whether there is any more data to be read.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hIsEOF",
          "package": "base",
          "signature": "Handle -\u003e IO Bool",
          "source": "src/GHC-IO-Handle.html#hIsEOF",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hIsEOF\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hIsEOF\"]"
        },
        "index": {
          "description": "For readable handle hdl hIsEOF hdl returns True if no further input can be taken from hdl or for physical file if the current position is equal to the length of the file Otherwise it returns False NOTE hIsEOF may block because it has to attempt to read from the stream to determine whether there is any more data to be read",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hIsEOF",
          "normalized": "Handle-\u003eIO Bool",
          "package": "base",
          "partial": "Is EOF",
          "signature": "Handle-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hIsEOF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hIsOpen",
          "package": "base",
          "signature": "Handle -\u003e IO Bool",
          "source": "src/GHC-IO-Handle.html#hIsOpen",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hIsOpen\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hIsOpen\"]"
        },
        "index": {
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hIsOpen",
          "normalized": "Handle-\u003eIO Bool",
          "package": "base",
          "partial": "Is Open",
          "signature": "Handle-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hIsOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hIsReadable",
          "package": "base",
          "signature": "Handle -\u003e IO Bool",
          "source": "src/GHC-IO-Handle.html#hIsReadable",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hIsReadable\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hIsReadable\"]"
        },
        "index": {
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hIsReadable",
          "normalized": "Handle-\u003eIO Bool",
          "package": "base",
          "partial": "Is Readable",
          "signature": "Handle-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hIsReadable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hIsSeekable",
          "package": "base",
          "signature": "Handle -\u003e IO Bool",
          "source": "src/GHC-IO-Handle.html#hIsSeekable",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hIsSeekable\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hIsSeekable\"]"
        },
        "index": {
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hIsSeekable",
          "normalized": "Handle-\u003eIO Bool",
          "package": "base",
          "partial": "Is Seekable",
          "signature": "Handle-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hIsSeekable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs the handle connected to a terminal?\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hIsTerminalDevice",
          "package": "base",
          "signature": "Handle -\u003e IO Bool",
          "source": "src/GHC-IO-Handle.html#hIsTerminalDevice",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hIsTerminalDevice\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hIsTerminalDevice\"]"
        },
        "index": {
          "description": "Is the handle connected to terminal",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hIsTerminalDevice",
          "normalized": "Handle-\u003eIO Bool",
          "package": "base",
          "partial": "Is Terminal Device",
          "signature": "Handle-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hIsTerminalDevice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hIsWritable",
          "package": "base",
          "signature": "Handle -\u003e IO Bool",
          "source": "src/GHC-IO-Handle.html#hIsWritable",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hIsWritable\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hIsWritable\"]"
        },
        "index": {
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hIsWritable",
          "normalized": "Handle-\u003eIO Bool",
          "package": "base",
          "partial": "Is Writable",
          "signature": "Handle-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hIsWritable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehLookAhead\u003c/a\u003e\u003c/code\u003e returns the next character from the handle\n without removing it from the input buffer, blocking until a character\n is available.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eisEOFError\u003c/code\u003e if the end of file has been reached.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hLookAhead",
          "package": "base",
          "signature": "Handle -\u003e IO Char",
          "source": "src/GHC-IO-Handle.html#hLookAhead",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hLookAhead\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hLookAhead\"]"
        },
        "index": {
          "description": "Computation hLookAhead returns the next character from the handle without removing it from the input buffer blocking until character is available This operation may fail with isEOFError if the end of file has been reached",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hLookAhead",
          "normalized": "Handle-\u003eIO Char",
          "package": "base",
          "partial": "Look Ahead",
          "signature": "Handle-\u003eIO Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hLookAhead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ehPutBuf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl buf count\u003c/code\u003e writes \u003ccode\u003ecount\u003c/code\u003e 8-bit bytes from the\n buffer \u003ccode\u003ebuf\u003c/code\u003e to the handle \u003ccode\u003ehdl\u003c/code\u003e.  It returns ().\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehPutBuf\u003c/a\u003e\u003c/code\u003e ignores any text encoding that applies to the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e,\n writing the bytes directly to the underlying file or device.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehPutBuf\u003c/a\u003e\u003c/code\u003e ignores the prevailing \u003ccode\u003eTextEncoding\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eNewlineMode\u003c/a\u003e\u003c/code\u003e on the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e, and writes bytes directly.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eResourceVanished\u003c/code\u003e if the handle is a pipe or socket, and the\n    reading end is closed.  (If this is a POSIX system, and the program\n    has not asked to ignore SIGPIPE, then a SIGPIPE may be delivered\n    instead, whose default action is to terminate the program).\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hPutBuf",
          "package": "base",
          "signature": "Handle -\u003e Ptr a -\u003e Int -\u003e IO ()",
          "source": "src/GHC-IO-Handle-Text.html#hPutBuf",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hPutBuf\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hPutBuf\"]"
        },
        "index": {
          "description": "hPutBuf hdl buf count writes count bit bytes from the buffer buf to the handle hdl It returns hPutBuf ignores any text encoding that applies to the Handle writing the bytes directly to the underlying file or device hPutBuf ignores the prevailing TextEncoding and NewlineMode on the Handle and writes bytes directly This operation may fail with ResourceVanished if the handle is pipe or socket and the reading end is closed If this is POSIX system and the program has not asked to ignore SIGPIPE then SIGPIPE may be delivered instead whose default action is to terminate the program",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hPutBuf",
          "normalized": "Handle-\u003ePtr a-\u003eInt-\u003eIO()",
          "package": "base",
          "partial": "Put Buf",
          "signature": "Handle-\u003ePtr a-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hPutBuf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hPutBufNonBlocking",
          "package": "base",
          "signature": "Handle -\u003e Ptr a -\u003e Int -\u003e IO Int",
          "source": "src/GHC-IO-Handle-Text.html#hPutBufNonBlocking",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hPutBufNonBlocking\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hPutBufNonBlocking\"]"
        },
        "index": {
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hPutBufNonBlocking",
          "normalized": "Handle-\u003ePtr a-\u003eInt-\u003eIO Int",
          "package": "base",
          "partial": "Put Buf Non Blocking",
          "signature": "Handle-\u003ePtr a-\u003eInt-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hPutBufNonBlocking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehPutChar\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl ch\u003c/code\u003e writes the character \u003ccode\u003ech\u003c/code\u003e to the\n file or channel managed by \u003ccode\u003ehdl\u003c/code\u003e.  Characters may be buffered if\n buffering is enabled for \u003ccode\u003ehdl\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisFullError\u003c/a\u003e\u003c/code\u003e if the device is full; or\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisPermissionError\u003c/a\u003e\u003c/code\u003e if another system resource limit would be exceeded.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hPutChar",
          "package": "base",
          "signature": "Handle -\u003e Char -\u003e IO ()",
          "source": "src/GHC-IO-Handle-Text.html#hPutChar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hPutChar\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hPutChar\"]"
        },
        "index": {
          "description": "Computation hPutChar hdl ch writes the character ch to the file or channel managed by hdl Characters may be buffered if buffering is enabled for hdl This operation may fail with isFullError if the device is full or isPermissionError if another system resource limit would be exceeded",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hPutChar",
          "normalized": "Handle-\u003eChar-\u003eIO()",
          "package": "base",
          "partial": "Put Char",
          "signature": "Handle-\u003eChar-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hPutChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehPutStr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl s\u003c/code\u003e writes the string\n \u003ccode\u003es\u003c/code\u003e to the file or channel managed by \u003ccode\u003ehdl\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisFullError\u003c/a\u003e\u003c/code\u003e if the device is full; or\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisPermissionError\u003c/a\u003e\u003c/code\u003e if another system resource limit would be exceeded.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hPutStr",
          "package": "base",
          "signature": "Handle -\u003e String -\u003e IO ()",
          "source": "src/GHC-IO-Handle-Text.html#hPutStr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hPutStr\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hPutStr\"]"
        },
        "index": {
          "description": "Computation hPutStr hdl writes the string to the file or channel managed by hdl This operation may fail with isFullError if the device is full or isPermissionError if another system resource limit would be exceeded",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hPutStr",
          "normalized": "Handle-\u003eString-\u003eIO()",
          "package": "base",
          "partial": "Put Str",
          "signature": "Handle-\u003eString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hPutStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehSeek\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl mode i\u003c/code\u003e sets the position of handle\n \u003ccode\u003ehdl\u003c/code\u003e depending on \u003ccode\u003emode\u003c/code\u003e.\n The offset \u003ccode\u003ei\u003c/code\u003e is given in terms of 8-bit bytes.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003ehdl\u003c/code\u003e is block- or line-buffered, then seeking to a position which is not\n in the current buffer will first cause any items in the output buffer to be\n written to the device, and then cause the input buffer to be discarded.\n Some handles may not be seekable (see \u003ccode\u003e\u003ca\u003ehIsSeekable\u003c/a\u003e\u003c/code\u003e), or only support a\n subset of the possible positioning operations (for instance, it may only\n be possible to seek to the end of a tape, or to a positive offset from\n the beginning or current position).\n It is not possible to set a negative I/O position, or for\n a physical file, an I/O position beyond the current end-of-file.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eisIllegalOperationError\u003c/code\u003e if the Handle is not seekable, or does\n     not support the requested seek mode.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eisPermissionError\u003c/code\u003e if a system resource limit would be exceeded.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hSeek",
          "package": "base",
          "signature": "Handle -\u003e SeekMode -\u003e Integer -\u003e IO ()",
          "source": "src/GHC-IO-Handle.html#hSeek",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSeek\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hSeek\"]"
        },
        "index": {
          "description": "Computation hSeek hdl mode sets the position of handle hdl depending on mode The offset is given in terms of bit bytes If hdl is block or line-buffered then seeking to position which is not in the current buffer will first cause any items in the output buffer to be written to the device and then cause the input buffer to be discarded Some handles may not be seekable see hIsSeekable or only support subset of the possible positioning operations for instance it may only be possible to seek to the end of tape or to positive offset from the beginning or current position It is not possible to set negative position or for physical file an position beyond the current end-of-file This operation may fail with isIllegalOperationError if the Handle is not seekable or does not support the requested seek mode isPermissionError if system resource limit would be exceeded",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hSeek",
          "normalized": "Handle-\u003eSeekMode-\u003eInteger-\u003eIO()",
          "package": "base",
          "partial": "Seek",
          "signature": "Handle-\u003eSeekMode-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSeek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect binary mode (\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e) or text mode (\u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e) on a open handle.\n (See also \u003ccode\u003eopenBinaryFile\u003c/code\u003e.)\n\u003c/p\u003e\u003cp\u003eThis has the same effect as calling \u003ccode\u003e\u003ca\u003ehSetEncoding\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003echar8\u003c/a\u003e\u003c/code\u003e, together\n with \u003ccode\u003e\u003ca\u003ehSetNewlineMode\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003enoNewlineTranslation\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hSetBinaryMode",
          "package": "base",
          "signature": "Handle -\u003e Bool -\u003e IO ()",
          "source": "src/GHC-IO-Handle.html#hSetBinaryMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSetBinaryMode\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hSetBinaryMode\"]"
        },
        "index": {
          "description": "Select binary mode True or text mode False on open handle See also openBinaryFile This has the same effect as calling hSetEncoding with char8 together with hSetNewlineMode with noNewlineTranslation",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hSetBinaryMode",
          "normalized": "Handle-\u003eBool-\u003eIO()",
          "package": "base",
          "partial": "Set Binary Mode",
          "signature": "Handle-\u003eBool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSetBinaryMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehSetBuffering\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl mode\u003c/code\u003e sets the mode of buffering for\n handle \u003ccode\u003ehdl\u003c/code\u003e on subsequent reads and writes.\n\u003c/p\u003e\u003cp\u003eIf the buffer mode is changed from \u003ccode\u003e\u003ca\u003eBlockBuffering\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eLineBuffering\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eNoBuffering\u003c/a\u003e\u003c/code\u003e, then\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e if \u003ccode\u003ehdl\u003c/code\u003e is writable, the buffer is flushed as for \u003ccode\u003e\u003ca\u003ehFlush\u003c/a\u003e\u003c/code\u003e;\n\u003c/li\u003e\u003cli\u003e if \u003ccode\u003ehdl\u003c/code\u003e is not writable, the contents of the buffer is discarded.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eisPermissionError\u003c/code\u003e if the handle has already been used for reading\n    or writing and the implementation does not allow the buffering mode\n    to be changed.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hSetBuffering",
          "package": "base",
          "signature": "Handle -\u003e BufferMode -\u003e IO ()",
          "source": "src/GHC-IO-Handle.html#hSetBuffering",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSetBuffering\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hSetBuffering\"]"
        },
        "index": {
          "description": "Computation hSetBuffering hdl mode sets the mode of buffering for handle hdl on subsequent reads and writes If the buffer mode is changed from BlockBuffering or LineBuffering to NoBuffering then if hdl is writable the buffer is flushed as for hFlush if hdl is not writable the contents of the buffer is discarded This operation may fail with isPermissionError if the handle has already been used for reading or writing and the implementation does not allow the buffering mode to be changed",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hSetBuffering",
          "normalized": "Handle-\u003eBufferMode-\u003eIO()",
          "package": "base",
          "partial": "Set Buffering",
          "signature": "Handle-\u003eBufferMode-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSetBuffering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the echoing status of a handle connected to a terminal.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hSetEcho",
          "package": "base",
          "signature": "Handle -\u003e Bool -\u003e IO ()",
          "source": "src/GHC-IO-Handle.html#hSetEcho",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSetEcho\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hSetEcho\"]"
        },
        "index": {
          "description": "Set the echoing status of handle connected to terminal",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hSetEcho",
          "normalized": "Handle-\u003eBool-\u003eIO()",
          "package": "base",
          "partial": "Set Echo",
          "signature": "Handle-\u003eBool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSetEcho"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe action \u003ccode\u003e\u003ca\u003ehSetEncoding\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e \u003ccode\u003eencoding\u003c/code\u003e changes the text encoding\n for the handle \u003ccode\u003ehdl\u003c/code\u003e to \u003ccode\u003eencoding\u003c/code\u003e.  The default encoding when a \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e is\n created is \u003ccode\u003elocaleEncoding\u003c/code\u003e, namely the default encoding for the current\n locale.\n\u003c/p\u003e\u003cp\u003eTo create a \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e with no encoding at all, use \u003ccode\u003eopenBinaryFile\u003c/code\u003e.  To\n stop further encoding or decoding on an existing \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e, use\n \u003ccode\u003e\u003ca\u003ehSetBinaryMode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehSetEncoding\u003c/a\u003e\u003c/code\u003e may need to flush buffered data in order to change\n the encoding.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hSetEncoding",
          "package": "base",
          "signature": "Handle -\u003e TextEncoding -\u003e IO ()",
          "source": "src/GHC-IO-Handle.html#hSetEncoding",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSetEncoding\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hSetEncoding\"]"
        },
        "index": {
          "description": "The action hSetEncoding hdl encoding changes the text encoding for the handle hdl to encoding The default encoding when Handle is created is localeEncoding namely the default encoding for the current locale To create Handle with no encoding at all use openBinaryFile To stop further encoding or decoding on an existing Handle use hSetBinaryMode hSetEncoding may need to flush buffered data in order to change the encoding",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hSetEncoding",
          "normalized": "Handle-\u003eTextEncoding-\u003eIO()",
          "package": "base",
          "partial": "Set Encoding",
          "signature": "Handle-\u003eTextEncoding-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSetEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ehSetFileSize\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e \u003ccode\u003esize\u003c/code\u003e truncates the physical file with handle \u003ccode\u003ehdl\u003c/code\u003e to \u003ccode\u003esize\u003c/code\u003e bytes.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hSetFileSize",
          "package": "base",
          "signature": "Handle -\u003e Integer -\u003e IO ()",
          "source": "src/GHC-IO-Handle.html#hSetFileSize",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSetFileSize\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hSetFileSize\"]"
        },
        "index": {
          "description": "hSetFileSize hdl size truncates the physical file with handle hdl to size bytes",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hSetFileSize",
          "normalized": "Handle-\u003eInteger-\u003eIO()",
          "package": "base",
          "partial": "Set File Size",
          "signature": "Handle-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSetFileSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the \u003ccode\u003e\u003ca\u003eNewlineMode\u003c/a\u003e\u003c/code\u003e on the specified \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.  All buffered\n data is flushed first.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hSetNewlineMode",
          "package": "base",
          "signature": "Handle -\u003e NewlineMode -\u003e IO ()",
          "source": "src/GHC-IO-Handle.html#hSetNewlineMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSetNewlineMode\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hSetNewlineMode\"]"
        },
        "index": {
          "description": "Set the NewlineMode on the specified Handle All buffered data is flushed first",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hSetNewlineMode",
          "normalized": "Handle-\u003eNewlineMode-\u003eIO()",
          "package": "base",
          "partial": "Set Newline Mode",
          "signature": "Handle-\u003eNewlineMode-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSetNewlineMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf a call to \u003ccode\u003e\u003ca\u003ehGetPosn\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e returns a position \u003ccode\u003ep\u003c/code\u003e,\n then computation \u003ccode\u003e\u003ca\u003ehSetPosn\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep\u003c/code\u003e sets the position of \u003ccode\u003ehdl\u003c/code\u003e\n to the position it held at the time of the call to \u003ccode\u003e\u003ca\u003ehGetPosn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eisPermissionError\u003c/code\u003e if a system resource limit would be exceeded.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hSetPosn",
          "package": "base",
          "signature": "HandlePosn -\u003e IO ()",
          "source": "src/GHC-IO-Handle.html#hSetPosn",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSetPosn\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hSetPosn\"]"
        },
        "index": {
          "description": "If call to hGetPosn hdl returns position then computation hSetPosn sets the position of hdl to the position it held at the time of the call to hGetPosn This operation may fail with isPermissionError if system resource limit would be exceeded",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hSetPosn",
          "normalized": "HandlePosn-\u003eIO()",
          "package": "base",
          "partial": "Set Posn",
          "signature": "HandlePosn-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hSetPosn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ehShow\u003c/a\u003e\u003c/code\u003e is in the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad, and gives more comprehensive output\n than the (pure) instance of \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hShow",
          "package": "base",
          "signature": "Handle -\u003e IO String",
          "source": "src/GHC-IO-Handle.html#hShow",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hShow\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hShow\"]"
        },
        "index": {
          "description": "hShow is in the IO monad and gives more comprehensive output than the pure instance of Show for Handle",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hShow",
          "normalized": "Handle-\u003eIO String",
          "package": "base",
          "partial": "Show",
          "signature": "Handle-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehTell\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e returns the current position of the\n handle \u003ccode\u003ehdl\u003c/code\u003e, as the number of bytes from the beginning of\n the file.  The value returned may be subsequently passed to\n \u003ccode\u003e\u003ca\u003ehSeek\u003c/a\u003e\u003c/code\u003e to reposition the handle to the current position.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eisIllegalOperationError\u003c/code\u003e if the Handle is not seekable.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hTell",
          "package": "base",
          "signature": "Handle -\u003e IO Integer",
          "source": "src/GHC-IO-Handle.html#hTell",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hTell\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hTell\"]"
        },
        "index": {
          "description": "Computation hTell hdl returns the current position of the handle hdl as the number of bytes from the beginning of the file The value returned may be subsequently passed to hSeek to reposition the handle to the current position This operation may fail with isIllegalOperationError if the Handle is not seekable",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hTell",
          "normalized": "Handle-\u003eIO Integer",
          "package": "base",
          "partial": "Tell",
          "signature": "Handle-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hTell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehWaitForInput\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl t\u003c/code\u003e\n waits until input is available on handle \u003ccode\u003ehdl\u003c/code\u003e.\n It returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e as soon as input is available on \u003ccode\u003ehdl\u003c/code\u003e,\n or \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if no input is available within \u003ccode\u003et\u003c/code\u003e milliseconds.  Note that\n \u003ccode\u003e\u003ca\u003ehWaitForInput\u003c/a\u003e\u003c/code\u003e waits until one or more full \u003cem\u003echaracters\u003c/em\u003e are available,\n which means that it needs to do decoding, and hence may fail\n with a decoding error.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003et\u003c/code\u003e is less than zero, then \u003ccode\u003ehWaitForInput\u003c/code\u003e waits indefinitely.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisEOFError\u003c/a\u003e\u003c/code\u003e if the end of file has been reached.\n\u003c/li\u003e\u003cli\u003e a decoding error, if the input begins with an invalid byte sequence\n    in this Handle's encoding.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNOTE for GHC users: unless you use the \u003ccode\u003e-threaded\u003c/code\u003e flag,\n \u003ccode\u003ehWaitForInput t\u003c/code\u003e where \u003ccode\u003et \u003e= 0\u003c/code\u003e will block all other Haskell\n threads for the duration of the call.  It behaves like a\n \u003ccode\u003esafe\u003c/code\u003e foreign call in this respect.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "hWaitForInput",
          "package": "base",
          "signature": "Handle -\u003e Int -\u003e IO Bool",
          "source": "src/GHC-IO-Handle-Text.html#hWaitForInput",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hWaitForInput\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:hWaitForInput\"]"
        },
        "index": {
          "description": "Computation hWaitForInput hdl waits until input is available on handle hdl It returns True as soon as input is available on hdl or False if no input is available within milliseconds Note that hWaitForInput waits until one or more full characters are available which means that it needs to do decoding and hence may fail with decoding error If is less than zero then hWaitForInput waits indefinitely This operation may fail with isEOFError if the end of file has been reached decoding error if the input begins with an invalid byte sequence in this Handle encoding NOTE for GHC users unless you use the threaded flag hWaitForInput where will block all other Haskell threads for the duration of the call It behaves like safe foreign call in this respect",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "hWaitForInput",
          "normalized": "Handle-\u003eInt-\u003eIO Bool",
          "package": "base",
          "partial": "Wait For Input",
          "signature": "Handle-\u003eInt-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:hWaitForInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe representation of newlines on input\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "inputNL",
          "package": "base",
          "signature": "Newline",
          "source": "src/GHC-IO-Handle-Types.html#NewlineMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:inputNL\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:inputNL\"]"
        },
        "index": {
          "description": "the representation of newlines on input",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "inputNL",
          "package": "base",
          "partial": "NL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:inputNL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elike \u003ccode\u003e\u003ca\u003emkFileHandle\u003c/a\u003e\u003c/code\u003e, except that a \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e is created with two\n independent buffers, one for reading and one for writing.  Used for\n full-duplex streams, such as network sockets.\n\u003c/p\u003e",
          "module": "GHC.IO.Handle",
          "name": "mkDuplexHandle",
          "package": "base",
          "signature": "dev -\u003e FilePath -\u003e Maybe TextEncoding -\u003e NewlineMode -\u003e IO Handle",
          "source": "src/GHC-IO-Handle-Internals.html#mkDuplexHandle",
          "type": "function"
        },
        "index": {
          "description": "like mkFileHandle except that Handle is created with two independent buffers one for reading and one for writing Used for full-duplex streams such as network sockets",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "mkDuplexHandle",
          "normalized": "a-\u003eFilePath-\u003eMaybe TextEncoding-\u003eNewlineMode-\u003eIO Handle",
          "package": "base",
          "partial": "Duplex Handle",
          "signature": "dev-\u003eFilePath-\u003eMaybe TextEncoding-\u003eNewlineMode-\u003eIO Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:mkDuplexHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emakes a new \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "GHC.IO.Handle",
          "name": "mkFileHandle",
          "package": "base",
          "signature": "dev-\u003e FilePath-\u003e IOMode-\u003e Maybe TextEncoding-\u003e NewlineMode-\u003e IO Handle",
          "type": "function"
        },
        "index": {
          "description": "makes new Handle",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "mkFileHandle",
          "normalized": "a-\u003eFilePath-\u003eIOMode-\u003eMaybe TextEncoding-\u003eNewlineMode-\u003eIO Handle",
          "package": "base",
          "partial": "File Handle",
          "signature": "dev-\u003eFilePath-\u003eIOMode-\u003eMaybe TextEncoding-\u003eNewlineMode-\u003eIO Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:mkFileHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe native newline representation for the current platform: \u003ccode\u003e\u003ca\u003eLF\u003c/a\u003e\u003c/code\u003e\n on Unix systems, \u003ccode\u003e\u003ca\u003eCRLF\u003c/a\u003e\u003c/code\u003e on Windows.\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "nativeNewline",
          "package": "base",
          "signature": "Newline",
          "source": "src/GHC-IO-Handle-Types.html#nativeNewline",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:nativeNewline\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:nativeNewline\"]"
        },
        "index": {
          "description": "The native newline representation for the current platform LF on Unix systems CRLF on Windows",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "nativeNewline",
          "package": "base",
          "partial": "Newline",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:nativeNewline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the native newline representation on both input and output\n\u003c/p\u003e\u003cpre\u003e nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline\n                                    outputNL = nativeNewline }\n\u003c/pre\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "nativeNewlineMode",
          "package": "base",
          "signature": "NewlineMode",
          "source": "src/GHC-IO-Handle-Types.html#nativeNewlineMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:nativeNewlineMode\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:nativeNewlineMode\"]"
        },
        "index": {
          "description": "Use the native newline representation on both input and output nativeNewlineMode NewlineMode inputNL nativeNewline outputNL nativeNewline",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "nativeNewlineMode",
          "package": "base",
          "partial": "Newline Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:nativeNewlineMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDo no newline translation at all.\n\u003c/p\u003e\u003cpre\u003e noNewlineTranslation  = NewlineMode { inputNL  = LF, outputNL = LF }\n\u003c/pre\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "noNewlineTranslation",
          "package": "base",
          "signature": "NewlineMode",
          "source": "src/GHC-IO-Handle-Types.html#noNewlineTranslation",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:noNewlineTranslation\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:noNewlineTranslation\"]"
        },
        "index": {
          "description": "Do no newline translation at all noNewlineTranslation NewlineMode inputNL LF outputNL LF",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "noNewlineTranslation",
          "package": "base",
          "partial": "Newline Translation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:noNewlineTranslation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe representation of newlines on output\n\u003c/p\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "outputNL",
          "package": "base",
          "signature": "Newline",
          "source": "src/GHC-IO-Handle-Types.html#NewlineMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:outputNL\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:outputNL\"]"
        },
        "index": {
          "description": "the representation of newlines on output",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "outputNL",
          "package": "base",
          "partial": "NL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:outputNL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap '\\r\\n' into '\\n' on input, and '\\n' to the native newline\n represetnation on output.  This mode can be used on any platform, and\n works with text files using any newline convention.  The downside is\n that \u003ccode\u003ereadFile \u003e\u003e= writeFile\u003c/code\u003e might yield a different file.\n\u003c/p\u003e\u003cpre\u003e universalNewlineMode  = NewlineMode { inputNL  = CRLF, \n                                       outputNL = nativeNewline }\n\u003c/pre\u003e",
          "module": "[\"GHC.IO.Handle\",\"System.IO\"]",
          "name": "universalNewlineMode",
          "package": "base",
          "signature": "NewlineMode",
          "source": "src/GHC-IO-Handle-Types.html#universalNewlineMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:universalNewlineMode\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:universalNewlineMode\"]"
        },
        "index": {
          "description": "Map into on input and to the native newline represetnation on output This mode can be used on any platform and works with text files using any newline convention The downside is that readFile writeFile might yield different file universalNewlineMode NewlineMode inputNL CRLF outputNL nativeNewline",
          "hierarchy": "GHC IO Handle",
          "module": "GHC.IO.Handle",
          "name": "universalNewlineMode",
          "package": "base",
          "partial": "Newline Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IO-Handle.html#v:universalNewlineMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IP",
          "name": "IP",
          "package": "base",
          "source": "src/GHC-IP.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "GHC IP",
          "module": "GHC.IP",
          "name": "IP",
          "package": "base",
          "partial": "IP",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IP.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe syntax \u003ccode\u003e?x :: a\u003c/code\u003e is desugared into \u003ccode\u003eIP \u003ca\u003ex\u003c/a\u003e a\u003c/code\u003e\n\u003c/p\u003e",
          "module": "GHC.IP",
          "name": "IP",
          "package": "base",
          "source": "src/GHC-IP.html#IP",
          "type": "class"
        },
        "index": {
          "description": "The syntax is desugared into IP",
          "hierarchy": "GHC IP",
          "module": "GHC.IP",
          "name": "IP",
          "package": "base",
          "partial": "IP",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IP.html#t:IP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.IP",
          "name": "ip",
          "package": "base",
          "signature": "a",
          "source": "src/GHC-IP.html#ip",
          "type": "method"
        },
        "index": {
          "hierarchy": "GHC IP",
          "module": "GHC.IP",
          "name": "ip",
          "package": "base",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-IP.html#v:ip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAccess to GHC's call-stack simulation\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.Stack",
          "name": "Stack",
          "package": "base",
          "source": "src/GHC-Stack.html",
          "type": "module"
        },
        "index": {
          "description": "Access to GHC call-stack simulation",
          "hierarchy": "GHC Stack",
          "module": "GHC.Stack",
          "name": "Stack",
          "package": "base",
          "partial": "Stack",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stack.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stack",
          "name": "CostCentre",
          "package": "base",
          "source": "src/GHC-Stack.html#CostCentre",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC Stack",
          "module": "GHC.Stack",
          "name": "CostCentre",
          "package": "base",
          "partial": "Cost Centre",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stack.html#t:CostCentre"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stack",
          "name": "CostCentreStack",
          "package": "base",
          "source": "src/GHC-Stack.html#CostCentreStack",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC Stack",
          "module": "GHC.Stack",
          "name": "CostCentreStack",
          "package": "base",
          "partial": "Cost Centre Stack",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stack.html#t:CostCentreStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stack",
          "name": "ccLabel",
          "package": "base",
          "signature": "Ptr CostCentre -\u003e IO CString",
          "source": "src/GHC-Stack.html#ccLabel",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stack",
          "module": "GHC.Stack",
          "name": "ccLabel",
          "normalized": "Ptr CostCentre-\u003eIO CString",
          "package": "base",
          "partial": "Label",
          "signature": "Ptr CostCentre-\u003eIO CString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stack.html#v:ccLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stack",
          "name": "ccModule",
          "package": "base",
          "signature": "Ptr CostCentre -\u003e IO CString",
          "source": "src/GHC-Stack.html#ccModule",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stack",
          "module": "GHC.Stack",
          "name": "ccModule",
          "normalized": "Ptr CostCentre-\u003eIO CString",
          "package": "base",
          "partial": "Module",
          "signature": "Ptr CostCentre-\u003eIO CString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stack.html#v:ccModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stack",
          "name": "ccSrcSpan",
          "package": "base",
          "signature": "Ptr CostCentre -\u003e IO CString",
          "source": "src/GHC-Stack.html#ccSrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stack",
          "module": "GHC.Stack",
          "name": "ccSrcSpan",
          "normalized": "Ptr CostCentre-\u003eIO CString",
          "package": "base",
          "partial": "Src Span",
          "signature": "Ptr CostCentre-\u003eIO CString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stack.html#v:ccSrcSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stack",
          "name": "ccsCC",
          "package": "base",
          "signature": "Ptr CostCentreStack -\u003e IO (Ptr CostCentre)",
          "source": "src/GHC-Stack.html#ccsCC",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stack",
          "module": "GHC.Stack",
          "name": "ccsCC",
          "normalized": "Ptr CostCentreStack-\u003eIO(Ptr CostCentre)",
          "package": "base",
          "partial": "CC",
          "signature": "Ptr CostCentreStack-\u003eIO(Ptr CostCentre)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stack.html#v:ccsCC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stack",
          "name": "ccsParent",
          "package": "base",
          "signature": "Ptr CostCentreStack -\u003e IO (Ptr CostCentreStack)",
          "source": "src/GHC-Stack.html#ccsParent",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stack",
          "module": "GHC.Stack",
          "name": "ccsParent",
          "normalized": "Ptr CostCentreStack-\u003eIO(Ptr CostCentreStack)",
          "package": "base",
          "partial": "Parent",
          "signature": "Ptr CostCentreStack-\u003eIO(Ptr CostCentreStack)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stack.html#v:ccsParent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stack",
          "name": "ccsToStrings",
          "package": "base",
          "signature": "Ptr CostCentreStack -\u003e IO [String]",
          "source": "src/GHC-Stack.html#ccsToStrings",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stack",
          "module": "GHC.Stack",
          "name": "ccsToStrings",
          "normalized": "Ptr CostCentreStack-\u003eIO[String]",
          "package": "base",
          "partial": "To Strings",
          "signature": "Ptr CostCentreStack-\u003eIO[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stack.html#v:ccsToStrings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stack",
          "name": "getCCSOf",
          "package": "base",
          "signature": "a -\u003e IO (Ptr CostCentreStack)",
          "source": "src/GHC-Stack.html#getCCSOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stack",
          "module": "GHC.Stack",
          "name": "getCCSOf",
          "normalized": "a-\u003eIO(Ptr CostCentreStack)",
          "package": "base",
          "partial": "CCSOf",
          "signature": "a-\u003eIO(Ptr CostCentreStack)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stack.html#v:getCCSOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stack",
          "name": "getCurrentCCS",
          "package": "base",
          "signature": "dummy -\u003e IO (Ptr CostCentreStack)",
          "source": "src/GHC-Stack.html#getCurrentCCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stack",
          "module": "GHC.Stack",
          "name": "getCurrentCCS",
          "normalized": "a-\u003eIO(Ptr CostCentreStack)",
          "package": "base",
          "partial": "Current CCS",
          "signature": "dummy-\u003eIO(Ptr CostCentreStack)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stack.html#v:getCurrentCCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stack",
          "name": "renderStack",
          "package": "base",
          "signature": "[String] -\u003e String",
          "source": "src/GHC-Stack.html#renderStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stack",
          "module": "GHC.Stack",
          "name": "renderStack",
          "normalized": "[String]-\u003eString",
          "package": "base",
          "partial": "Stack",
          "signature": "[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stack.html#v:renderStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stack",
          "name": "whoCreated",
          "package": "base",
          "signature": "a -\u003e IO [String]",
          "source": "src/GHC-Stack.html#whoCreated",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stack",
          "module": "GHC.Stack",
          "name": "whoCreated",
          "normalized": "a-\u003eIO[String]",
          "package": "base",
          "partial": "Created",
          "signature": "a-\u003eIO[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stack.html#v:whoCreated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides access to internal garbage collection and\n memory usage statistics.  These statistics are not available unless\n a program is run with the \u003ccode\u003e-T\u003c/code\u003e RTS flag.\n\u003c/p\u003e\u003cp\u003eThis module is GHC-only and should not be considered portable.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.Stats",
          "name": "Stats",
          "package": "base",
          "source": "src/GHC-Stats.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides access to internal garbage collection and memory usage statistics These statistics are not available unless program is run with the RTS flag This module is GHC-only and should not be considered portable",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "Stats",
          "package": "base",
          "partial": "Stats",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGlobal garbage collection and memory statistics.\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "GCStats",
          "package": "base",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "data"
        },
        "index": {
          "description": "Global garbage collection and memory statistics",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "GCStats",
          "package": "base",
          "partial": "GCStats",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#t:GCStats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stats",
          "name": "GCStats",
          "package": "base",
          "signature": "GCStats",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "GCStats",
          "package": "base",
          "partial": "GCStats",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:GCStats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTotal number of bytes allocated\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "bytesAllocated",
          "package": "base",
          "signature": "Int64",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "Total number of bytes allocated",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "bytesAllocated",
          "package": "base",
          "partial": "Allocated",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:bytesAllocated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of bytes copied during GC\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "bytesCopied",
          "package": "base",
          "signature": "Int64",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "Number of bytes copied during GC",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "bytesCopied",
          "package": "base",
          "partial": "Copied",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:bytesCopied"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTotal CPU time elapsed since program start\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "cpuSeconds",
          "package": "base",
          "signature": "Double",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "Total CPU time elapsed since program start",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "cpuSeconds",
          "package": "base",
          "partial": "Seconds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:cpuSeconds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stats",
          "name": "cumulativeBytesUsed",
          "package": "base",
          "signature": "Int64",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "cumulativeBytesUsed",
          "package": "base",
          "partial": "Bytes Used",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:cumulativeBytesUsed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurrent number of bytes lost to slop\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "currentBytesSlop",
          "package": "base",
          "signature": "Int64",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "Current number of bytes lost to slop",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "currentBytesSlop",
          "package": "base",
          "partial": "Bytes Slop",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:currentBytesSlop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurrent number of live bytes\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "currentBytesUsed",
          "package": "base",
          "signature": "Int64",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "Current number of live bytes",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "currentBytesUsed",
          "package": "base",
          "partial": "Bytes Used",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:currentBytesUsed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCPU time spent running GC\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "gcCpuSeconds",
          "package": "base",
          "signature": "Double",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "CPU time spent running GC",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "gcCpuSeconds",
          "package": "base",
          "partial": "Cpu Seconds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:gcCpuSeconds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWall clock time spent running GC\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "gcWallSeconds",
          "package": "base",
          "signature": "Double",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "Wall clock time spent running GC",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "gcWallSeconds",
          "package": "base",
          "partial": "Wall Seconds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:gcWallSeconds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieves garbage collection and memory statistics as of the last\n garbage collection.  If you would like your statistics as recent as\n possible, first run a \u003ccode\u003e\u003ca\u003eperformGC\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "getGCStats",
          "package": "base",
          "signature": "IO GCStats",
          "source": "src/GHC-Stats.html#getGCStats",
          "type": "function"
        },
        "index": {
          "description": "Retrieves garbage collection and memory statistics as of the last garbage collection If you would like your statistics as recent as possible first run performGC",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "getGCStats",
          "package": "base",
          "partial": "GCStats",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:getGCStats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stats",
          "name": "getGCStatsEnabled",
          "package": "base",
          "signature": "IO Bool",
          "source": "src/GHC-Stats.html#getGCStatsEnabled",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "getGCStatsEnabled",
          "package": "base",
          "partial": "GCStats Enabled",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:getGCStatsEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximum number of bytes lost to slop at any one time so far\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "maxBytesSlop",
          "package": "base",
          "signature": "Int64",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "Maximum number of bytes lost to slop at any one time so far",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "maxBytesSlop",
          "package": "base",
          "partial": "Bytes Slop",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:maxBytesSlop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximum number of live bytes seen so far\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "maxBytesUsed",
          "package": "base",
          "signature": "Int64",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "Maximum number of live bytes seen so far",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "maxBytesUsed",
          "package": "base",
          "partial": "Bytes Used",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:maxBytesUsed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stats",
          "name": "mutatorCpuSeconds",
          "package": "base",
          "signature": "Double",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "mutatorCpuSeconds",
          "package": "base",
          "partial": "Cpu Seconds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:mutatorCpuSeconds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWall clock time spent running mutator threads.  This does not\n include initialization.\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "mutatorWallSeconds",
          "package": "base",
          "signature": "Double",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "Wall clock time spent running mutator threads This does not include initialization",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "mutatorWallSeconds",
          "package": "base",
          "partial": "Wall Seconds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:mutatorWallSeconds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of byte usage samples taken\n | Sum of all byte usage samples, can be used with\n \u003ccode\u003e\u003ca\u003enumByteUsageSamples\u003c/a\u003e\u003c/code\u003e to calculate averages with\n arbitrary weighting (if you are sampling this record multiple\n times).\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "numByteUsageSamples",
          "package": "base",
          "signature": "Int64",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "Number of byte usage samples taken Sum of all byte usage samples can be used with numByteUsageSamples to calculate averages with arbitrary weighting if you are sampling this record multiple times",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "numByteUsageSamples",
          "package": "base",
          "partial": "Byte Usage Samples",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:numByteUsageSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of garbage collections performed\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "numGcs",
          "package": "base",
          "signature": "Int64",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "Number of garbage collections performed",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "numGcs",
          "package": "base",
          "partial": "Gcs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:numGcs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum of number of bytes copied each GC by the most active GC\n thread each GC.  The ratio of \u003ccode\u003e\u003ca\u003eparTotBytesCopied\u003c/a\u003e\u003c/code\u003e divided by\n \u003ccode\u003e\u003ca\u003eparMaxBytesCopied\u003c/a\u003e\u003c/code\u003e approaches 1 for a maximally sequential\n run and approaches the number of threads (set by the RTS flag\n \u003ccode\u003e-N\u003c/code\u003e) for a maximally parallel run.\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "parMaxBytesCopied",
          "package": "base",
          "signature": "Int64",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "Sum of number of bytes copied each GC by the most active GC thread each GC The ratio of parTotBytesCopied divided by parMaxBytesCopied approaches for maximally sequential run and approaches the number of threads set by the RTS flag for maximally parallel run",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "parMaxBytesCopied",
          "package": "base",
          "partial": "Max Bytes Copied",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:parMaxBytesCopied"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.Stats",
          "name": "parTotBytesCopied",
          "package": "base",
          "signature": "Int64",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "parTotBytesCopied",
          "package": "base",
          "partial": "Tot Bytes Copied",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:parTotBytesCopied"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximum number of megabytes allocated\n | CPU time spent running mutator threads.  This does not include\n any profiling overhead or initialization.\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "peakMegabytesAllocated",
          "package": "base",
          "signature": "Int64",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "Maximum number of megabytes allocated CPU time spent running mutator threads This does not include any profiling overhead or initialization",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "peakMegabytesAllocated",
          "package": "base",
          "partial": "Megabytes Allocated",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:peakMegabytesAllocated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTotal wall clock time elapsed since start\n | Number of bytes copied during GC, minus space held by mutable\n lists held by the capabilities.  Can be used with\n \u003ccode\u003e\u003ca\u003eparMaxBytesCopied\u003c/a\u003e\u003c/code\u003e to determine how well parallel GC utilized\n all cores.\n\u003c/p\u003e",
          "module": "GHC.Stats",
          "name": "wallSeconds",
          "package": "base",
          "signature": "Double",
          "source": "src/GHC-Stats.html#GCStats",
          "type": "function"
        },
        "index": {
          "description": "Total wall clock time elapsed since start Number of bytes copied during GC minus space held by mutable lists held by the capabilities Can be used with parMaxBytesCopied to determine how well parallel GC utilized all cores",
          "hierarchy": "GHC Stats",
          "module": "GHC.Stats",
          "name": "wallSeconds",
          "package": "base",
          "partial": "Seconds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-Stats.html#v:wallSeconds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module is an internal GHC module.  It declares the constants used\nin the implementation of type-level natural numbers.  The programmer interface\nfor workin with type-level naturals should be defined in a separate library. \n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.TypeLits",
          "name": "TypeLits",
          "package": "base",
          "source": "src/GHC-TypeLits.html",
          "type": "module"
        },
        "index": {
          "description": "This module is an internal GHC module It declares the constants used in the implementation of type-level natural numbers The programmer interface for workin with type-level naturals should be defined in separate library",
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "TypeLits",
          "package": "base",
          "partial": "Type Lits",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplication of type-level naturals.\n\u003c/p\u003e",
          "module": "GHC.TypeLits",
          "name": "(*)",
          "package": "base",
          "signature": "(*)",
          "type": "function"
        },
        "index": {
          "description": "Multiplication of type-level naturals",
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "(*) *",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAddition of type-level naturals.\n\u003c/p\u003e",
          "module": "GHC.TypeLits",
          "name": "(+)",
          "package": "base",
          "signature": "(+)",
          "type": "function"
        },
        "index": {
          "description": "Addition of type-level naturals",
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "(+) +",
          "normalized": "()",
          "package": "base",
          "signature": "()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComparsion of type-level naturals.\n\u003c/p\u003e",
          "module": "GHC.TypeLits",
          "name": "(\u003c=)",
          "package": "base",
          "source": "src/GHC-TypeLits.html#%3C%3D",
          "type": "class"
        },
        "index": {
          "description": "Comparsion of type-level naturals",
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "(\u003c=) \u003c=",
          "package": "base",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-60--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.TypeLits",
          "name": "(\u003c=?)",
          "package": "base",
          "signature": "(\u003c=?)",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "(\u003c=?) \u003c=?",
          "normalized": "()",
          "package": "base",
          "signature": "()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-60--61--63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExponentiation of type-level naturals.\n\u003c/p\u003e",
          "module": "GHC.TypeLits",
          "name": "(^)",
          "package": "base",
          "signature": "(^)",
          "type": "function"
        },
        "index": {
          "description": "Exponentiation of type-level naturals",
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "(^) ^",
          "normalized": "()",
          "package": "base",
          "signature": "()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.TypeLits",
          "name": "IsEven",
          "package": "base",
          "source": "src/GHC-TypeLits.html#IsEven",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "IsEven",
          "package": "base",
          "partial": "Is Even",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:IsEven"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.TypeLits",
          "name": "IsZero",
          "package": "base",
          "source": "src/GHC-TypeLits.html#IsZero",
          "type": "data"
        },
        "index": {
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "IsZero",
          "package": "base",
          "partial": "Is Zero",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:IsZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type synonym useful for passing kinds as parameters.\n\u003c/p\u003e",
          "module": "GHC.TypeLits",
          "name": "Kind",
          "package": "base",
          "source": "src/GHC-TypeLits.html#Kind",
          "type": "type"
        },
        "index": {
          "description": "type synonym useful for passing kinds as parameters",
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "Kind",
          "package": "base",
          "partial": "Kind",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:Kind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the *kind* of type-level natural numbers.\n\u003c/p\u003e",
          "module": "GHC.TypeLits",
          "name": "Nat",
          "package": "base",
          "source": "src/GHC-TypeLits.html#Nat",
          "type": "data"
        },
        "index": {
          "description": "This is the kind of type-level natural numbers",
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "Nat",
          "package": "base",
          "partial": "Nat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:Nat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.TypeLits",
          "name": "Sing",
          "package": "base",
          "signature": "Sing",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "Sing",
          "package": "base",
          "partial": "Sing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:Sing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class that converts singletons of a given kind into values of some\nrepresentation type (i.e., we \u003ca\u003eforget\u003c/a\u003e the extra information carried\nby the singletons, and convert them to ordinary values).\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ca\u003efromSing\u003c/a\u003e\u003c/code\u003e is overloaded based on the \u003cem\u003ekind\u003c/em\u003e of the values\nand not their type---all types of a given kind are processed by the\nsame instances.\n\u003c/p\u003e",
          "module": "GHC.TypeLits",
          "name": "SingE",
          "package": "base",
          "source": "src/GHC-TypeLits.html#SingE",
          "type": "class"
        },
        "index": {
          "description": "class that converts singletons of given kind into values of some representation type i.e we forget the extra information carried by the singletons and convert them to ordinary values Note that fromSing is overloaded based on the kind of the values and not their type---all types of given kind are processed by the same instances",
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "SingE",
          "package": "base",
          "partial": "Sing",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:SingE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class \u003ccode\u003e\u003ca\u003eSingI\u003c/a\u003e\u003c/code\u003e provides a \"smart\" constructor for singleton types.\n There are built-in instances for the singleton types corresponding\n to type literals.\n\u003c/p\u003e",
          "module": "GHC.TypeLits",
          "name": "SingI",
          "package": "base",
          "source": "src/GHC-TypeLits.html#SingI",
          "type": "class"
        },
        "index": {
          "description": "The class SingI provides smart constructor for singleton types There are built-in instances for the singleton types corresponding to type literals",
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "SingI",
          "package": "base",
          "partial": "Sing",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:SingI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience class, useful when we need to both introduce and eliminate\na given singleton value. Users should never need to define instances of\nthis classes. \n\u003c/p\u003e",
          "module": "GHC.TypeLits",
          "name": "SingRep",
          "package": "base",
          "source": "src/GHC-TypeLits.html#SingRep",
          "type": "class"
        },
        "index": {
          "description": "convenience class useful when we need to both introduce and eliminate given singleton value Users should never need to define instances of this classes",
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "SingRep",
          "package": "base",
          "partial": "Sing Rep",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:SingRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the *kind* of type-level symbols.\n\u003c/p\u003e",
          "module": "GHC.TypeLits",
          "name": "Symbol",
          "package": "base",
          "source": "src/GHC-TypeLits.html#Symbol",
          "type": "data"
        },
        "index": {
          "description": "This is the kind of type-level symbols",
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "Symbol",
          "package": "base",
          "partial": "Symbol",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:Symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.TypeLits",
          "name": "IsEven",
          "package": "base",
          "signature": "(Sing (n + 1)) -\u003e IsEven ((2 * n) + 2)",
          "source": "src/GHC-TypeLits.html#IsEven",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "IsEven",
          "normalized": "(Sing(a))-\u003eIsEven((*a))",
          "package": "base",
          "partial": "Is Even",
          "signature": "(Sing(n))-\u003eIsEven((*n))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#v:IsEven"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.TypeLits",
          "name": "IsEvenZero",
          "package": "base",
          "signature": "IsEven 0",
          "source": "src/GHC-TypeLits.html#IsEven",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "IsEvenZero",
          "package": "base",
          "partial": "Is Even Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#v:IsEvenZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.TypeLits",
          "name": "IsOdd",
          "package": "base",
          "signature": "(Sing n) -\u003e IsEven ((2 * n) + 1)",
          "source": "src/GHC-TypeLits.html#IsEven",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "IsOdd",
          "normalized": "(Sing a)-\u003eIsEven((*a))",
          "package": "base",
          "partial": "Is Odd",
          "signature": "(Sing n)-\u003eIsEven((*n))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#v:IsOdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.TypeLits",
          "name": "IsSucc",
          "package": "base",
          "signature": "(Sing n) -\u003e IsZero (n + 1)",
          "source": "src/GHC-TypeLits.html#IsZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "IsSucc",
          "normalized": "(Sing a)-\u003eIsZero(a)",
          "package": "base",
          "partial": "Is Succ",
          "signature": "(Sing n)-\u003eIsZero(n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#v:IsSucc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.TypeLits",
          "name": "IsZero",
          "package": "base",
          "signature": "IsZero 0",
          "source": "src/GHC-TypeLits.html#IsZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "IsZero",
          "package": "base",
          "partial": "Is Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#v:IsZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.TypeLits",
          "name": "fromSing",
          "package": "base",
          "signature": "k) -\u003e rep",
          "source": "src/GHC-TypeLits.html#fromSing",
          "type": "method"
        },
        "index": {
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "fromSing",
          "normalized": "a)-\u003eb",
          "package": "base",
          "partial": "Sing",
          "signature": "k)-\u003erep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#v:fromSing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.TypeLits",
          "name": "isEven",
          "package": "base",
          "signature": "Sing n -\u003e IsEven n",
          "source": "src/GHC-TypeLits.html#isEven",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "isEven",
          "normalized": "Sing a-\u003eIsEven a",
          "package": "base",
          "partial": "Even",
          "signature": "Sing n-\u003eIsEven n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#v:isEven"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.TypeLits",
          "name": "isZero",
          "package": "base",
          "signature": "Sing n -\u003e IsZero n",
          "source": "src/GHC-TypeLits.html#isZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "isZero",
          "normalized": "Sing a-\u003eIsZero a",
          "package": "base",
          "partial": "Zero",
          "signature": "Sing n-\u003eIsZero n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#v:isZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe only value of type \u003ccode\u003eSing a\u003c/code\u003e\n\u003c/p\u003e",
          "module": "GHC.TypeLits",
          "name": "sing",
          "package": "base",
          "signature": "Sing a",
          "source": "src/GHC-TypeLits.html#sing",
          "type": "method"
        },
        "index": {
          "description": "The only value of type Sing",
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "sing",
          "package": "base",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#v:sing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience function that names a singleton satisfying a certain\nproperty.  If the singleton does not satisfy the property, then the function\nreturns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e. The property is expressed in terms of the underlying\nrepresentation of the singleton. \n\u003c/p\u003e",
          "module": "GHC.TypeLits",
          "name": "singThat",
          "package": "base",
          "signature": "(rep -\u003e Bool) -\u003e Maybe (Sing a)",
          "source": "src/GHC-TypeLits.html#singThat",
          "type": "function"
        },
        "index": {
          "description": "convenience function that names singleton satisfying certain property If the singleton does not satisfy the property then the function returns Nothing The property is expressed in terms of the underlying representation of the singleton",
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "singThat",
          "normalized": "(a-\u003eBool)-\u003eMaybe(Sing b)",
          "package": "base",
          "partial": "That",
          "signature": "(rep-\u003eBool)-\u003eMaybe(Sing a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#v:singThat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.TypeLits",
          "name": "unsafeSingNat",
          "package": "base",
          "signature": "Nat)",
          "source": "src/GHC-TypeLits.html#unsafeSingNat",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "unsafeSingNat",
          "package": "base",
          "partial": "Sing Nat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#v:unsafeSingNat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "GHC.TypeLits",
          "name": "unsafeSingSymbol",
          "package": "base",
          "signature": "Symbol)",
          "source": "src/GHC-TypeLits.html#unsafeSingSymbol",
          "type": "function"
        },
        "index": {
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "unsafeSingSymbol",
          "package": "base",
          "partial": "Sing Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#v:unsafeSingSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience function useful when we need to name a singleton value\nmultiple times.  Without this function, each use of \u003ccode\u003e\u003ca\u003esing\u003c/a\u003e\u003c/code\u003e could potentially\nrefer to a different singleton, and one has to use type signatures to\nensure that they are the same. \n\u003c/p\u003e",
          "module": "GHC.TypeLits",
          "name": "withSing",
          "package": "base",
          "signature": "(Sing a -\u003e b) -\u003e b",
          "source": "src/GHC-TypeLits.html#withSing",
          "type": "function"
        },
        "index": {
          "description": "convenience function useful when we need to name singleton value multiple times Without this function each use of sing could potentially refer to different singleton and one has to use type signatures to ensure that they are the same",
          "hierarchy": "GHC TypeLits",
          "module": "GHC.TypeLits",
          "name": "withSing",
          "normalized": "(Sing a-\u003eb)-\u003eb",
          "package": "base",
          "partial": "Sing",
          "signature": "(Sing a-\u003eb)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#v:withSing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOdds and ends, mostly functions for reading and showing\n \u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e-like kind of values.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric",
          "name": "Numeric",
          "package": "base",
          "source": "src/Numeric.html",
          "type": "module"
        },
        "index": {
          "description": "Odds and ends mostly functions for reading and showing RealFloat like kind of values",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "Numeric",
          "package": "base",
          "partial": "Numeric",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efloatToDigits\u003c/a\u003e\u003c/code\u003e takes a base and a non-negative \u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e number,\n and returns a list of digits and an exponent.\n In particular, if \u003ccode\u003ex\u003e=0\u003c/code\u003e, and\n\u003c/p\u003e\u003cpre\u003e floatToDigits base x = ([d1,d2,...,dn], e)\n\u003c/pre\u003e\u003cp\u003ethen\n\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cpre\u003en \u003e= 1\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003ex = 0.d1d2...dn * (base**e)\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e0 \u003c= di \u003c= base-1\u003c/pre\u003e\u003c/li\u003e\u003c/ol\u003e",
          "module": "Numeric",
          "name": "floatToDigits",
          "package": "base",
          "signature": "Integer -\u003e a -\u003e ([Int], Int)",
          "source": "src/GHC-Float.html#floatToDigits",
          "type": "function"
        },
        "index": {
          "description": "floatToDigits takes base and non-negative RealFloat number and returns list of digits and an exponent In particular if and floatToDigits base d1 d2 dn then d1d2...dn base di base-1",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "floatToDigits",
          "normalized": "Integer-\u003ea-\u003e([Int],Int)",
          "package": "base",
          "partial": "To Digits",
          "signature": "Integer-\u003ea-\u003e([Int],Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:floatToDigits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e value into any type in class \u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "fromRat",
          "package": "base",
          "signature": "Rational -\u003e a",
          "source": "src/GHC-Float.html#fromRat",
          "type": "function"
        },
        "index": {
          "description": "Converts Rational value into any type in class RealFloat",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "fromRat",
          "normalized": "Rational-\u003ea",
          "package": "base",
          "partial": "Rat",
          "signature": "Rational-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:fromRat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReads a non-empty string of decimal digits.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "lexDigits",
          "package": "base",
          "signature": "ReadS String",
          "source": "src/GHC-Read.html#lexDigits",
          "type": "function"
        },
        "index": {
          "description": "Reads non-empty string of decimal digits",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "lexDigits",
          "package": "base",
          "partial": "Digits",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:lexDigits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead an unsigned number in decimal notation.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "readDec",
          "package": "base",
          "signature": "ReadS a",
          "source": "src/Numeric.html#readDec",
          "type": "function"
        },
        "index": {
          "description": "Read an unsigned number in decimal notation",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "readDec",
          "package": "base",
          "partial": "Dec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:readDec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReads an \u003cem\u003eunsigned\u003c/em\u003e \u003ccode\u003e\u003ca\u003eRealFrac\u003c/a\u003e\u003c/code\u003e value,\n expressed in decimal scientific notation.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "readFloat",
          "package": "base",
          "signature": "ReadS a",
          "source": "src/Numeric.html#readFloat",
          "type": "function"
        },
        "index": {
          "description": "Reads an unsigned RealFrac value expressed in decimal scientific notation",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "readFloat",
          "package": "base",
          "partial": "Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:readFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead an unsigned number in hexadecimal notation.\n Both upper or lower case letters are allowed.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "readHex",
          "package": "base",
          "signature": "ReadS a",
          "source": "src/Numeric.html#readHex",
          "type": "function"
        },
        "index": {
          "description": "Read an unsigned number in hexadecimal notation Both upper or lower case letters are allowed",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "readHex",
          "package": "base",
          "partial": "Hex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:readHex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReads an \u003cem\u003eunsigned\u003c/em\u003e \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e value in an arbitrary base.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "readInt",
          "package": "base",
          "signature": "a-\u003e (Char -\u003e Bool)-\u003e (Char -\u003e Int)-\u003e ReadS a",
          "type": "function"
        },
        "index": {
          "description": "Reads an unsigned Integral value in an arbitrary base",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "readInt",
          "normalized": "a-\u003e(Char-\u003eBool)-\u003e(Char-\u003eInt)-\u003eReadS a",
          "package": "base",
          "partial": "Int",
          "signature": "a-\u003e(Char-\u003eBool)-\u003e(Char-\u003eInt)-\u003eReadS a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:readInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead an unsigned number in octal notation.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "readOct",
          "package": "base",
          "signature": "ReadS a",
          "source": "src/Numeric.html#readOct",
          "type": "function"
        },
        "index": {
          "description": "Read an unsigned number in octal notation",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "readOct",
          "package": "base",
          "partial": "Oct",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:readOct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReads a \u003cem\u003esigned\u003c/em\u003e \u003ccode\u003e\u003ca\u003eReal\u003c/a\u003e\u003c/code\u003e value, given a reader for an unsigned value.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "readSigned",
          "package": "base",
          "signature": "ReadS a -\u003e ReadS a",
          "source": "src/Numeric.html#readSigned",
          "type": "function"
        },
        "index": {
          "description": "Reads signed Real value given reader for an unsigned value",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "readSigned",
          "normalized": "ReadS a-\u003eReadS a",
          "package": "base",
          "partial": "Signed",
          "signature": "ReadS a-\u003eReadS a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:readSigned"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a signed \u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e value\n using scientific (exponential) notation (e.g. \u003ccode\u003e2.45e2\u003c/code\u003e, \u003ccode\u003e1.5e-3\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eIn the call \u003ccode\u003e\u003ccode\u003e\u003ca\u003eshowEFloat\u003c/a\u003e\u003c/code\u003e digs val\u003c/code\u003e, if \u003ccode\u003edigs\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e,\n the value is shown to full precision; if \u003ccode\u003edigs\u003c/code\u003e is \u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e d\u003c/code\u003e,\n then at most \u003ccode\u003ed\u003c/code\u003e digits after the decimal point are shown.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "showEFloat",
          "package": "base",
          "signature": "Maybe Int -\u003e a -\u003e ShowS",
          "source": "src/Numeric.html#showEFloat",
          "type": "function"
        },
        "index": {
          "description": "Show signed RealFloat value using scientific exponential notation e.g e2 e-3 In the call showEFloat digs val if digs is Nothing the value is shown to full precision if digs is Just then at most digits after the decimal point are shown",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "showEFloat",
          "normalized": "Maybe Int-\u003ea-\u003eShowS",
          "package": "base",
          "partial": "EFloat",
          "signature": "Maybe Int-\u003ea-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:showEFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a signed \u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e value\n using standard decimal notation (e.g. \u003ccode\u003e245000\u003c/code\u003e, \u003ccode\u003e0.0015\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eIn the call \u003ccode\u003e\u003ccode\u003e\u003ca\u003eshowFFloat\u003c/a\u003e\u003c/code\u003e digs val\u003c/code\u003e, if \u003ccode\u003edigs\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e,\n the value is shown to full precision; if \u003ccode\u003edigs\u003c/code\u003e is \u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e d\u003c/code\u003e,\n then at most \u003ccode\u003ed\u003c/code\u003e digits after the decimal point are shown.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "showFFloat",
          "package": "base",
          "signature": "Maybe Int -\u003e a -\u003e ShowS",
          "source": "src/Numeric.html#showFFloat",
          "type": "function"
        },
        "index": {
          "description": "Show signed RealFloat value using standard decimal notation e.g In the call showFFloat digs val if digs is Nothing the value is shown to full precision if digs is Just then at most digits after the decimal point are shown",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "showFFloat",
          "normalized": "Maybe Int-\u003ea-\u003eShowS",
          "package": "base",
          "partial": "FFloat",
          "signature": "Maybe Int-\u003ea-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:showFFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a signed \u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e value to full precision\n using standard decimal notation for arguments whose absolute value lies\n between \u003ccode\u003e0.1\u003c/code\u003e and \u003ccode\u003e9,999,999\u003c/code\u003e, and scientific notation otherwise.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "showFloat",
          "package": "base",
          "signature": "a -\u003e ShowS",
          "source": "src/GHC-Float.html#showFloat",
          "type": "function"
        },
        "index": {
          "description": "Show signed RealFloat value to full precision using standard decimal notation for arguments whose absolute value lies between and and scientific notation otherwise",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "showFloat",
          "normalized": "a-\u003eShowS",
          "package": "base",
          "partial": "Float",
          "signature": "a-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:showFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a signed \u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e value\n using standard decimal notation for arguments whose absolute value lies \n between \u003ccode\u003e0.1\u003c/code\u003e and \u003ccode\u003e9,999,999\u003c/code\u003e, and scientific notation otherwise.\n\u003c/p\u003e\u003cp\u003eIn the call \u003ccode\u003e\u003ccode\u003e\u003ca\u003eshowGFloat\u003c/a\u003e\u003c/code\u003e digs val\u003c/code\u003e, if \u003ccode\u003edigs\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e,\n the value is shown to full precision; if \u003ccode\u003edigs\u003c/code\u003e is \u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e d\u003c/code\u003e,\n then at most \u003ccode\u003ed\u003c/code\u003e digits after the decimal point are shown.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "showGFloat",
          "package": "base",
          "signature": "Maybe Int -\u003e a -\u003e ShowS",
          "source": "src/Numeric.html#showGFloat",
          "type": "function"
        },
        "index": {
          "description": "Show signed RealFloat value using standard decimal notation for arguments whose absolute value lies between and and scientific notation otherwise In the call showGFloat digs val if digs is Nothing the value is shown to full precision if digs is Just then at most digits after the decimal point are shown",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "showGFloat",
          "normalized": "Maybe Int-\u003ea-\u003eShowS",
          "package": "base",
          "partial": "GFloat",
          "signature": "Maybe Int-\u003ea-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:showGFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow \u003cem\u003enon-negative\u003c/em\u003e \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e numbers in base 16.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "showHex",
          "package": "base",
          "signature": "a -\u003e ShowS",
          "source": "src/Numeric.html#showHex",
          "type": "function"
        },
        "index": {
          "description": "Show non-negative Integral numbers in base",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "showHex",
          "normalized": "a-\u003eShowS",
          "package": "base",
          "partial": "Hex",
          "signature": "a-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:showHex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow \u003cem\u003enon-negative\u003c/em\u003e \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e numbers in base 10.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "showInt",
          "package": "base",
          "signature": "a -\u003e ShowS",
          "source": "src/Numeric.html#showInt",
          "type": "function"
        },
        "index": {
          "description": "Show non-negative Integral numbers in base",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "showInt",
          "normalized": "a-\u003eShowS",
          "package": "base",
          "partial": "Int",
          "signature": "a-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:showInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShows a \u003cem\u003enon-negative\u003c/em\u003e \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e number using the base specified by the\n first argument, and the character representation specified by the second.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "showIntAtBase",
          "package": "base",
          "signature": "a -\u003e (Int -\u003e Char) -\u003e a -\u003e ShowS",
          "source": "src/Numeric.html#showIntAtBase",
          "type": "function"
        },
        "index": {
          "description": "Shows non-negative Integral number using the base specified by the first argument and the character representation specified by the second",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "showIntAtBase",
          "normalized": "a-\u003e(Int-\u003eChar)-\u003ea-\u003eShowS",
          "package": "base",
          "partial": "Int At Base",
          "signature": "a-\u003e(Int-\u003eChar)-\u003ea-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:showIntAtBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow \u003cem\u003enon-negative\u003c/em\u003e \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e numbers in base 8.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "showOct",
          "package": "base",
          "signature": "a -\u003e ShowS",
          "source": "src/Numeric.html#showOct",
          "type": "function"
        },
        "index": {
          "description": "Show non-negative Integral numbers in base",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "showOct",
          "normalized": "a-\u003eShowS",
          "package": "base",
          "partial": "Oct",
          "signature": "a-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:showOct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a possibly-negative \u003ccode\u003e\u003ca\u003eReal\u003c/a\u003e\u003c/code\u003e value to a string.\n\u003c/p\u003e",
          "module": "Numeric",
          "name": "showSigned",
          "package": "base",
          "signature": "(a -\u003e ShowS)-\u003e Int-\u003e a-\u003e ShowS",
          "type": "function"
        },
        "index": {
          "description": "Converts possibly-negative Real value to string",
          "hierarchy": "Numeric",
          "module": "Numeric",
          "name": "showSigned",
          "normalized": "(a-\u003eShowS)-\u003eInt-\u003ea-\u003eShowS",
          "package": "base",
          "partial": "Signed",
          "signature": "(a-\u003eShowS)-\u003eInt-\u003ea-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Numeric.html#v:showSigned"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe Prelude: a standard module imported by default into all Haskell\n modules.  For more documentation, see the Haskell 98 Report\n \u003ca\u003ehttp://www.haskell.org/onlinereport/\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Prelude",
          "name": "Prelude",
          "package": "base",
          "source": "src/Prelude.html",
          "type": "module"
        },
        "index": {
          "description": "The Prelude standard module imported by default into all Haskell modules For more documentation see the Haskell Report http www.haskell.org onlinereport",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Prelude",
          "package": "base",
          "partial": "Prelude",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "Bool",
          "package": "base",
          "type": "data"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Bool",
          "package": "base",
          "partial": "Bool",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Bool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e class is used to name the upper and lower limits of a\n type.  \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e is not a superclass of \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e since types that are not\n totally ordered may also have upper and lower bounds.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e class may be derived for any enumeration type;\n \u003ccode\u003e\u003ca\u003eminBound\u003c/a\u003e\u003c/code\u003e is the first constructor listed in the \u003ccode\u003edata\u003c/code\u003e declaration\n and \u003ccode\u003e\u003ca\u003emaxBound\u003c/a\u003e\u003c/code\u003e is the last.\n \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e may also be derived for single-constructor datatypes whose\n constituent types are in \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Bounded",
          "package": "base",
          "source": "src/GHC-Enum.html#Bounded",
          "type": "class"
        },
        "index": {
          "description": "The Bounded class is used to name the upper and lower limits of type Ord is not superclass of Bounded since types that are not totally ordered may also have upper and lower bounds The Bounded class may be derived for any enumeration type minBound is the first constructor listed in the data declaration and maxBound is the last Bounded may also be derived for single-constructor datatypes whose constituent types are in Bounded",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Bounded",
          "package": "base",
          "partial": "Bounded",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Bounded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe character type \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e is an enumeration whose values represent\nUnicode (or equivalently ISO/IEC 10646) characters (see\n\u003ca\u003ehttp://www.unicode.org/\u003c/a\u003e for details).  This set extends the ISO 8859-1\n(Latin-1) character set (the first 256 characters), which is itself an extension\nof the ASCII character set (the first 128 characters).  A character literal in\nHaskell has type \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eTo convert a \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e to or from the corresponding \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e value defined\nby Unicode, use \u003ccode\u003e\u003ca\u003etoEnum\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efromEnum\u003c/a\u003e\u003c/code\u003e from the\n\u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e class respectively (or equivalently \u003ccode\u003eord\u003c/code\u003e and \u003ccode\u003echr\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Char",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "The character type Char is an enumeration whose values represent Unicode or equivalently ISO IEC characters see http www.unicode.org for details This set extends the ISO Latin-1 character set the first characters which is itself an extension of the ASCII character set the first characters character literal in Haskell has type Char To convert Char to or from the corresponding Int value defined by Unicode use toEnum and fromEnum from the Enum class respectively or equivalently ord and chr",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Char",
          "package": "base",
          "partial": "Char",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDouble-precision floating point numbers.\n It is desirable that this type be at least equal in range and precision\n to the IEEE double-precision type.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Double",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "Double-precision floating point numbers It is desirable that this type be at least equal in range and precision to the IEEE double-precision type",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Double",
          "package": "base",
          "partial": "Double",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Double"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e type represents values with two possibilities: a value of\ntype \u003ccode\u003e\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a b\u003c/code\u003e is either \u003ccode\u003e\u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e or \u003ccode\u003e\u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e type is sometimes used to represent a value which is\neither correct or an error; by convention, the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e constructor is\nused to hold an error value and the \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e constructor is used to\nhold a correct value (mnemonic: \"right\" also means \"correct\").\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Either",
          "package": "base",
          "source": "src/Data-Either.html#Either",
          "type": "data"
        },
        "index": {
          "description": "The Either type represents values with two possibilities value of type Either is either Left or Right The Either type is sometimes used to represent value which is either correct or an error by convention the Left constructor is used to hold an error value and the Right constructor is used to hold correct value mnemonic right also means correct",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Either",
          "package": "base",
          "partial": "Either",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Either"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass \u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e defines operations on sequentially ordered types.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003eenumFrom\u003c/code\u003e... methods are used in Haskell's translation of\n arithmetic sequences.\n\u003c/p\u003e\u003cp\u003eInstances of \u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e may be derived for any enumeration type (types\n whose constructors have no fields).  The nullary constructors are\n assumed to be numbered left-to-right by \u003ccode\u003e\u003ca\u003efromEnum\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e0\u003c/code\u003e through \u003ccode\u003en-1\u003c/code\u003e.\n See Chapter 10 of the \u003cem\u003eHaskell Report\u003c/em\u003e for more details.\n\u003c/p\u003e\u003cp\u003eFor any type that is an instance of class \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e as well as \u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e,\n the following should hold:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The calls \u003ccode\u003e\u003ccode\u003e\u003ca\u003esucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emaxBound\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and \u003ccode\u003e\u003ccode\u003e\u003ca\u003epred\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eminBound\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e should result in\n   a runtime error.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003efromEnum\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003etoEnum\u003c/a\u003e\u003c/code\u003e should give a runtime error if the \n   result value is not representable in the result type.\n   For example, \u003ccode\u003e\u003ccode\u003e\u003ca\u003etoEnum\u003c/a\u003e\u003c/code\u003e 7 :: \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is an error.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eenumFrom\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eenumFromThen\u003c/a\u003e\u003c/code\u003e should be defined with an implicit bound,\n   thus:\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e    enumFrom     x   = enumFromTo     x maxBound\n    enumFromThen x y = enumFromThenTo x y bound\n      where\n        bound | fromEnum y \u003e= fromEnum x = maxBound\n              | otherwise                = minBound\n\u003c/pre\u003e",
          "module": "Prelude",
          "name": "Enum",
          "package": "base",
          "source": "src/GHC-Enum.html#Enum",
          "type": "class"
        },
        "index": {
          "description": "Class Enum defines operations on sequentially ordered types The enumFrom methods are used in Haskell translation of arithmetic sequences Instances of Enum may be derived for any enumeration type types whose constructors have no fields The nullary constructors are assumed to be numbered left-to-right by fromEnum from through n-1 See Chapter of the Haskell Report for more details For any type that is an instance of class Bounded as well as Enum the following should hold The calls succ maxBound and pred minBound should result in runtime error fromEnum and toEnum should give runtime error if the result value is not representable in the result type For example toEnum Bool is an error enumFrom and enumFromThen should be defined with an implicit bound thus enumFrom enumFromTo maxBound enumFromThen enumFromThenTo bound where bound fromEnum fromEnum maxBound otherwise minBound",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Enum",
          "package": "base",
          "partial": "Enum",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Enum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e class defines equality (\u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e) and inequality (\u003ccode\u003e\u003ca\u003e/=\u003c/a\u003e\u003c/code\u003e).\n All the basic datatypes exported by the \u003ca\u003ePrelude\u003c/a\u003e are instances of \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e,\n and \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e may be derived for any datatype whose constituents are also\n instances of \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: either \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003e/=\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Eq",
          "package": "base",
          "type": "class"
        },
        "index": {
          "description": "The Eq class defines equality and inequality All the basic datatypes exported by the Prelude are instances of Eq and Eq may be derived for any datatype whose constituents are also instances of Eq Minimal complete definition either or",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Eq",
          "package": "base",
          "partial": "Eq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Eq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFile and directory names are values of type \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e, whose precise\n meaning is operating system dependent. Files can be opened, yielding a\n handle which can then be used to operate on the contents of that file.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "FilePath",
          "package": "base",
          "source": "src/GHC-IO.html#FilePath",
          "type": "type"
        },
        "index": {
          "description": "File and directory names are values of type String whose precise meaning is operating system dependent Files can be opened yielding handle which can then be used to operate on the contents of that file",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "FilePath",
          "package": "base",
          "partial": "File Path",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:FilePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle-precision floating point numbers.\n It is desirable that this type be at least equal in range and precision\n to the IEEE single-precision type.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Float",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "Single-precision floating point numbers It is desirable that this type be at least equal in range and precision to the IEEE single-precision type",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Float",
          "package": "base",
          "partial": "Float",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrigonometric and hyperbolic functions and related functions.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition:\n      \u003ccode\u003e\u003ca\u003epi\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eexp\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003elog\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003esin\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ecos\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003esinh\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ecosh\u003c/a\u003e\u003c/code\u003e,\n      \u003ccode\u003e\u003ca\u003easin\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eacos\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eatan\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003easinh\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eacosh\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eatanh\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Floating",
          "package": "base",
          "source": "src/GHC-Float.html#Floating",
          "type": "class"
        },
        "index": {
          "description": "Trigonometric and hyperbolic functions and related functions Minimal complete definition pi exp log sin cos sinh cosh asin acos atan asinh acosh and atanh",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Floating",
          "package": "base",
          "partial": "Floating",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Floating"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFractional numbers, supporting real division.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003efromRational\u003c/a\u003e\u003c/code\u003e and (\u003ccode\u003e\u003ca\u003erecip\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e/\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Fractional",
          "package": "base",
          "source": "src/GHC-Real.html#Fractional",
          "type": "class"
        },
        "index": {
          "description": "Fractional numbers supporting real division Minimal complete definition fromRational and recip or",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Fractional",
          "package": "base",
          "partial": "Fractional",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Fractional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e class is used for types that can be mapped over.\nInstances of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e should satisfy the following laws:\n\u003c/p\u003e\u003cpre\u003e fmap id  ==  id\n fmap (f . g)  ==  fmap f . fmap g\n\u003c/pre\u003e\u003cp\u003eThe instances of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e for lists, \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\nsatisfy these laws.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Functor",
          "package": "base",
          "source": "src/GHC-Base.html#Functor",
          "type": "class"
        },
        "index": {
          "description": "The Functor class is used for types that can be mapped over Instances of Functor should satisfy the following laws fmap id id fmap fmap fmap The instances of Functor for lists Maybe and IO satisfy these laws",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Functor",
          "package": "base",
          "partial": "Functor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Functor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e is a computation which, when performed,\ndoes some I/O before returning a value of type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThere is really only one way to \"perform\" an I/O action: bind it to\n\u003ccode\u003eMain.main\u003c/code\u003e in your program.  When your program is run, the I/O will\nbe performed.  It isn't possible to perform I/O from an arbitrary\nfunction, unless that function is itself in the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad and called\nat some point, directly or indirectly, from \u003ccode\u003eMain.main\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e is a monad, so \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e actions can be combined using either the do-notation\nor the \u003ccode\u003e\u003e\u003e\u003c/code\u003e and \u003ccode\u003e\u003e\u003e=\u003c/code\u003e operations from the \u003ccode\u003eMonad\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "IO",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "value of type IO is computation which when performed does some before returning value of type There is really only one way to perform an action bind it to Main.main in your program When your program is run the will be performed It isn possible to perform from an arbitrary function unless that function is itself in the IO monad and called at some point directly or indirectly from Main.main IO is monad so IO actions can be combined using either the do-notation or the and operations from the Monad class",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "IO",
          "package": "base",
          "partial": "IO",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:IO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Haskell 98 type for exceptions in the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad.\n Any I/O operation may raise an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e instead of returning a result.\n For a more general type of exception, including also those that arise\n in pure code, see \u003ca\u003eControl.Exception.Exception\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eIn Haskell 98, this is an opaque type.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "IOError",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#IOError",
          "type": "type"
        },
        "index": {
          "description": "The Haskell type for exceptions in the IO monad Any operation may raise an IOError instead of returning result For more general type of exception including also those that arise in pure code see Control.Exception.Exception In Haskell this is an opaque type",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "IOError",
          "package": "base",
          "partial": "IOError",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:IOError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA fixed-precision integer type with at least the range \u003ccode\u003e[-2^29 .. 2^29-1]\u003c/code\u003e.\n The exact range for a given implementation can be determined by using\n \u003ccode\u003e\u003ca\u003eminBound\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emaxBound\u003c/a\u003e\u003c/code\u003e from the \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Int",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "fixed-precision integer type with at least the range The exact range for given implementation can be determined by using minBound and maxBound from the Bounded class",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Int",
          "package": "base",
          "partial": "Int",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArbitrary-precision integers.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Integer",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "Arbitrary-precision integers",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Integer",
          "package": "base",
          "partial": "Integer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntegral numbers, supporting integer division.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003equotRem\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003etoInteger\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Integral",
          "package": "base",
          "source": "src/GHC-Real.html#Integral",
          "type": "class"
        },
        "index": {
          "description": "Integral numbers supporting integer division Minimal complete definition quotRem and toInteger",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Integral",
          "package": "base",
          "partial": "Integral",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e type encapsulates an optional value.  A value of type\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e either contains a value of type \u003ccode\u003ea\u003c/code\u003e (represented as \u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e), \n or it is empty (represented as \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e).  Using \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e is a good way to \n deal with errors or exceptional cases without resorting to drastic\n measures such as \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e type is also a monad.  It is a simple kind of error\n monad, where all errors are represented by \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.  A richer\n error monad can be built using the \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Maybe",
          "package": "base",
          "source": "src/Data-Maybe.html#Maybe",
          "type": "data"
        },
        "index": {
          "description": "The Maybe type encapsulates an optional value value of type Maybe either contains value of type represented as Just or it is empty represented as Nothing Using Maybe is good way to deal with errors or exceptional cases without resorting to drastic measures such as error The Maybe type is also monad It is simple kind of error monad where all errors are represented by Nothing richer error monad can be built using the Either type",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Maybe",
          "package": "base",
          "partial": "Maybe",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Maybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e class defines the basic operations over a \u003cem\u003emonad\u003c/em\u003e,\na concept from a branch of mathematics known as \u003cem\u003ecategory theory\u003c/em\u003e.\nFrom the perspective of a Haskell programmer, however, it is best to\nthink of a monad as an \u003cem\u003eabstract datatype\u003c/em\u003e of actions.\nHaskell's \u003ccode\u003edo\u003c/code\u003e expressions provide a convenient syntax for writing\nmonadic expressions.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eInstances of \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e should satisfy the following laws:\n\u003c/p\u003e\u003cpre\u003e return a \u003e\u003e= k  ==  k a\n m \u003e\u003e= return  ==  m\n m \u003e\u003e= (\\x -\u003e k x \u003e\u003e= h)  ==  (m \u003e\u003e= k) \u003e\u003e= h\n\u003c/pre\u003e\u003cp\u003eInstances of both \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e should additionally satisfy the law:\n\u003c/p\u003e\u003cpre\u003e fmap f xs  ==  xs \u003e\u003e= return . f\n\u003c/pre\u003e\u003cp\u003eThe instances of \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e for lists, \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\ndefined in the \u003ca\u003ePrelude\u003c/a\u003e satisfy these laws.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Monad",
          "package": "base",
          "source": "src/GHC-Base.html#Monad",
          "type": "class"
        },
        "index": {
          "description": "The Monad class defines the basic operations over monad concept from branch of mathematics known as category theory From the perspective of Haskell programmer however it is best to think of monad as an abstract datatype of actions Haskell do expressions provide convenient syntax for writing monadic expressions Minimal complete definition and return Instances of Monad should satisfy the following laws return return Instances of both Monad and Functor should additionally satisfy the law fmap xs xs return The instances of Monad for lists Maybe and IO defined in the Prelude satisfy these laws",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Monad",
          "package": "base",
          "partial": "Monad",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Monad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBasic numeric class.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: all except \u003ccode\u003e\u003ca\u003enegate\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e(-)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Num",
          "package": "base",
          "source": "src/GHC-Num.html#Num",
          "type": "class"
        },
        "index": {
          "description": "Basic numeric class Minimal complete definition all except negate or",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Num",
          "package": "base",
          "partial": "Num",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Num"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e class is used for totally ordered datatypes.\n\u003c/p\u003e\u003cp\u003eInstances of \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e can be derived for any user-defined\n datatype whose constituent types are in \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e.  The declared order\n of the constructors in the data declaration determines the ordering\n in derived \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e instances.  The \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e datatype allows a single\n comparison to determine the precise ordering of two objects.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: either \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003e\u003c=\u003c/a\u003e\u003c/code\u003e.\n Using \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e can be more efficient for complex types.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Ord",
          "package": "base",
          "type": "class"
        },
        "index": {
          "description": "The Ord class is used for totally ordered datatypes Instances of Ord can be derived for any user-defined datatype whose constituent types are in Ord The declared order of the constructors in the data declaration determines the ordering in derived Ord instances The Ordering datatype allows single comparison to determine the precise ordering of two objects Minimal complete definition either compare or Using compare can be more efficient for complex types",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Ord",
          "package": "base",
          "partial": "Ord",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Ord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "Ordering",
          "package": "base",
          "type": "data"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Ordering",
          "package": "base",
          "partial": "Ordering",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Ordering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArbitrary-precision rational numbers, represented as a ratio of\n two \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e values.  A rational number may be constructed using\n the \u003ccode\u003e\u003ca\u003e%\u003c/a\u003e\u003c/code\u003e operator.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "Rational",
          "package": "base",
          "source": "src/GHC-Real.html#Rational",
          "type": "type"
        },
        "index": {
          "description": "Arbitrary-precision rational numbers represented as ratio of two Integer values rational number may be constructed using the operator",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Rational",
          "package": "base",
          "partial": "Rational",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Rational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParsing of \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003es, producing values.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e (or, for GHC only, \u003ccode\u003e\u003ca\u003ereadPrec\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e\u003cp\u003eDerived instances of \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e make the following assumptions, which\n derived instances of \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e obey:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e If the constructor is defined to be an infix operator, then the\n   derived \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e instance will parse only infix applications of\n   the constructor (not the prefix form).\n\u003c/li\u003e\u003cli\u003e Associativity is not used to reduce the occurrence of parentheses,\n   although precedence may be.\n\u003c/li\u003e\u003cli\u003e If the constructor is defined using record syntax, the derived \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e\n   will parse only the record-syntax form, and furthermore, the fields\n   must be given in the same order as the original declaration.\n\u003c/li\u003e\u003cli\u003e The derived \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e instance allows arbitrary Haskell whitespace\n   between tokens of the input string.  Extra parentheses are also\n   allowed.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eFor example, given the declarations\n\u003c/p\u003e\u003cpre\u003e infixr 5 :^:\n data Tree a =  Leaf a  |  Tree a :^: Tree a\n\u003c/pre\u003e\u003cp\u003ethe derived instance of \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e in Haskell 98 is equivalent to\n\u003c/p\u003e\u003cpre\u003e instance (Read a) =\u003e Read (Tree a) where\n\n         readsPrec d r =  readParen (d \u003e app_prec)\n                          (\\r -\u003e [(Leaf m,t) |\n                                  (\"Leaf\",s) \u003c- lex r,\n                                  (m,t) \u003c- readsPrec (app_prec+1) s]) r\n\n                       ++ readParen (d \u003e up_prec)\n                          (\\r -\u003e [(u:^:v,w) |\n                                  (u,s) \u003c- readsPrec (up_prec+1) r,\n                                  (\":^:\",t) \u003c- lex s,\n                                  (v,w) \u003c- readsPrec (up_prec+1) t]) r\n\n           where app_prec = 10\n                 up_prec = 5\n\u003c/pre\u003e\u003cp\u003eNote that right-associativity of \u003ccode\u003e:^:\u003c/code\u003e is unused.\n\u003c/p\u003e\u003cp\u003eThe derived instance in GHC is equivalent to\n\u003c/p\u003e\u003cpre\u003e instance (Read a) =\u003e Read (Tree a) where\n\n         readPrec = parens $ (prec app_prec $ do\n                                  Ident \"Leaf\" \u003c- lexP\n                                  m \u003c- step readPrec\n                                  return (Leaf m))\n\n                      +++ (prec up_prec $ do\n                                  u \u003c- step readPrec\n                                  Symbol \":^:\" \u003c- lexP\n                                  v \u003c- step readPrec\n                                  return (u :^: v))\n\n           where app_prec = 10\n                 up_prec = 5\n\n         readListPrec = readListPrecDefault\n\u003c/pre\u003e",
          "module": "Prelude",
          "name": "Read",
          "package": "base",
          "source": "src/GHC-Read.html#Read",
          "type": "class"
        },
        "index": {
          "description": "Parsing of String producing values Minimal complete definition readsPrec or for GHC only readPrec Derived instances of Read make the following assumptions which derived instances of Show obey If the constructor is defined to be an infix operator then the derived Read instance will parse only infix applications of the constructor not the prefix form Associativity is not used to reduce the occurrence of parentheses although precedence may be If the constructor is defined using record syntax the derived Read will parse only the record-syntax form and furthermore the fields must be given in the same order as the original declaration The derived Read instance allows arbitrary Haskell whitespace between tokens of the input string Extra parentheses are also allowed For example given the declarations infixr data Tree Leaf Tree Tree the derived instance of Read in Haskell is equivalent to instance Read Read Tree where readsPrec readParen app prec Leaf Leaf lex readsPrec app prec readParen up prec readsPrec up prec lex readsPrec up prec where app prec up prec Note that right-associativity of is unused The derived instance in GHC is equivalent to instance Read Read Tree where readPrec parens prec app prec do Ident Leaf lexP step readPrec return Leaf prec up prec do step readPrec Symbol lexP step readPrec return where app prec up prec readListPrec readListPrecDefault",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Read",
          "package": "base",
          "partial": "Read",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Read"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA parser for a type \u003ccode\u003ea\u003c/code\u003e, represented as a function that takes a\n \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e and returns a list of possible parses as \u003ccode\u003e(a,\u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e pairs.\n\u003c/p\u003e\u003cp\u003eNote that this kind of backtracking parser is very inefficient;\n reading a large structure may be quite slow (cf \u003ccode\u003e\u003ca\u003eReadP\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "ReadS",
          "package": "base",
          "source": "src/Text-ParserCombinators-ReadP.html#ReadS",
          "type": "type"
        },
        "index": {
          "description": "parser for type represented as function that takes String and returns list of possible parses as String pairs Note that this kind of backtracking parser is very inefficient reading large structure may be quite slow cf ReadP",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "ReadS",
          "package": "base",
          "partial": "Read",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:ReadS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "Real",
          "package": "base",
          "source": "src/GHC-Real.html#Real",
          "type": "class"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Real",
          "package": "base",
          "partial": "Real",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Real"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEfficient, machine-independent access to the components of a\n floating-point number.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition:\n      all except \u003ccode\u003e\u003ca\u003eexponent\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003esignificand\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003escaleFloat\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eatan2\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "RealFloat",
          "package": "base",
          "source": "src/GHC-Float.html#RealFloat",
          "type": "class"
        },
        "index": {
          "description": "Efficient machine-independent access to the components of floating-point number Minimal complete definition all except exponent significand scaleFloat and atan2",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "RealFloat",
          "package": "base",
          "partial": "Real Float",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:RealFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtracting components of fractions.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003eproperFraction\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "RealFrac",
          "package": "base",
          "source": "src/GHC-Real.html#RealFrac",
          "type": "class"
        },
        "index": {
          "description": "Extracting components of fractions Minimal complete definition properFraction",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "RealFrac",
          "package": "base",
          "partial": "Real Frac",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:RealFrac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion of values to readable \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eDerived instances of \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e have the following properties, which\n are compatible with derived instances of \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The result of \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e is a syntactically correct Haskell\n   expression containing only constants, given the fixity\n   declarations in force at the point where the type is declared.\n   It contains only the constructor names defined in the data type,\n   parentheses, and spaces.  When labelled constructor fields are\n   used, braces, commas, field names, and equal signs are also used.\n\u003c/li\u003e\u003cli\u003e If the constructor is defined to be an infix operator, then\n   \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e will produce infix applications of the constructor.\n\u003c/li\u003e\u003cli\u003e the representation will be enclosed in parentheses if the\n   precedence of the top-level constructor in \u003ccode\u003ex\u003c/code\u003e is less than \u003ccode\u003ed\u003c/code\u003e\n   (associativity is ignored).  Thus, if \u003ccode\u003ed\u003c/code\u003e is \u003ccode\u003e0\u003c/code\u003e then the result\n   is never surrounded in parentheses; if \u003ccode\u003ed\u003c/code\u003e is \u003ccode\u003e11\u003c/code\u003e it is always\n   surrounded in parentheses, unless it is an atomic expression.\n\u003c/li\u003e\u003cli\u003e If the constructor is defined using record syntax, then \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e\n   will produce the record-syntax form, with the fields given in the\n   same order as the original declaration.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eFor example, given the declarations\n\u003c/p\u003e\u003cpre\u003e infixr 5 :^:\n data Tree a =  Leaf a  |  Tree a :^: Tree a\n\u003c/pre\u003e\u003cp\u003ethe derived instance of \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e is equivalent to\n\u003c/p\u003e\u003cpre\u003e instance (Show a) =\u003e Show (Tree a) where\n\n        showsPrec d (Leaf m) = showParen (d \u003e app_prec) $\n             showString \"Leaf \" . showsPrec (app_prec+1) m\n          where app_prec = 10\n\n        showsPrec d (u :^: v) = showParen (d \u003e up_prec) $\n             showsPrec (up_prec+1) u .\n             showString \" :^: \"      .\n             showsPrec (up_prec+1) v\n          where up_prec = 5\n\u003c/pre\u003e\u003cp\u003eNote that right-associativity of \u003ccode\u003e:^:\u003c/code\u003e is ignored.  For example,\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e (Leaf 1 :^: Leaf 2 :^: Leaf 3)\u003c/code\u003e produces the string\n   \u003ccode\u003e\"Leaf 1 :^: (Leaf 2 :^: Leaf 3)\"\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Prelude",
          "name": "Show",
          "package": "base",
          "source": "src/GHC-Show.html#Show",
          "type": "class"
        },
        "index": {
          "description": "Conversion of values to readable String Minimal complete definition showsPrec or show Derived instances of Show have the following properties which are compatible with derived instances of Read The result of show is syntactically correct Haskell expression containing only constants given the fixity declarations in force at the point where the type is declared It contains only the constructor names defined in the data type parentheses and spaces When labelled constructor fields are used braces commas field names and equal signs are also used If the constructor is defined to be an infix operator then showsPrec will produce infix applications of the constructor the representation will be enclosed in parentheses if the precedence of the top-level constructor in is less than associativity is ignored Thus if is then the result is never surrounded in parentheses if is it is always surrounded in parentheses unless it is an atomic expression If the constructor is defined using record syntax then show will produce the record-syntax form with the fields given in the same order as the original declaration For example given the declarations infixr data Tree Leaf Tree Tree the derived instance of Show is equivalent to instance Show Show Tree where showsPrec Leaf showParen app prec showString Leaf showsPrec app prec where app prec showsPrec showParen up prec showsPrec up prec showString showsPrec up prec where up prec Note that right-associativity of is ignored For example show Leaf Leaf Leaf produces the string Leaf Leaf Leaf",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "Show",
          "package": "base",
          "partial": "Show",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:Show"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003eshows\u003c/code\u003e functions return a function that prepends the\n output \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e to an existing \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.  This allows constant-time\n concatenation of results using function composition.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "ShowS",
          "package": "base",
          "source": "src/GHC-Show.html#ShowS",
          "type": "type"
        },
        "index": {
          "description": "The shows functions return function that prepends the output String to an existing String This allows constant-time concatenation of results using function composition",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "ShowS",
          "package": "base",
          "partial": "Show",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:ShowS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e is a list of characters.  String constants in Haskell are values\n of type \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "String",
          "package": "base",
          "source": "src/GHC-Base.html#String",
          "type": "type"
        },
        "index": {
          "description": "String is list of characters String constants in Haskell are values of type String",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "String",
          "package": "base",
          "partial": "String",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#t:String"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrict (call-by-value) application, defined in terms of \u003ccode\u003e\u003ca\u003eseq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "($!)",
          "package": "base",
          "signature": "(a -\u003e b) -\u003e a -\u003e b",
          "source": "src/Prelude.html#%24%21",
          "type": "function"
        },
        "index": {
          "description": "Strict call-by-value application defined in terms of seq",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "($!) $!",
          "normalized": "(a-\u003eb)-\u003ea-\u003eb",
          "package": "base",
          "signature": "(a-\u003eb)-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:-36--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "(**)",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/GHC-Float.html#%2A%2A",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "(**) **",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:-42--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "(+)",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/GHC-Num.html#%2B",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "(+) +",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efractional division\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "(/)",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/GHC-Real.html#%2F",
          "type": "method"
        },
        "index": {
          "description": "fractional division",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "(/) /",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:-47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "(/=)",
          "package": "base",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "(/=) /=",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "base",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:-47--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "(\u003c)",
          "package": "base",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "(\u003c) \u003c",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "base",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:-60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "(\u003c=)",
          "package": "base",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "(\u003c=) \u003c=",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "base",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:-60--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "(==)",
          "package": "base",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "(==) ==",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "base",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:-61--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "(\u003e)",
          "package": "base",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "(\u003e) \u003e",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "base",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "(\u003e=)",
          "package": "base",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "(\u003e=) \u003e=",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "base",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:-62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequentially compose two actions, discarding any value produced\n by the first, like sequencing operators (such as the semicolon)\n in imperative languages.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "(\u003e\u003e)",
          "package": "base",
          "signature": "forall a b.  m a -\u003e m b -\u003e m b",
          "source": "src/GHC-Base.html#%3E%3E",
          "type": "method"
        },
        "index": {
          "description": "Sequentially compose two actions discarding any value produced by the first like sequencing operators such as the semicolon in imperative languages",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "(\u003e\u003e) \u003e\u003e",
          "normalized": "a b c d b-\u003ed e-\u003ed e",
          "package": "base",
          "signature": "forall a b. m a-\u003em b-\u003em b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:-62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequentially compose two actions, passing any value produced\n by the first as an argument to the second.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "(\u003e\u003e=)",
          "package": "base",
          "signature": "forall a b.  m a -\u003e (a -\u003e m b) -\u003e m b",
          "source": "src/GHC-Base.html#%3E%3E%3D",
          "type": "method"
        },
        "index": {
          "description": "Sequentially compose two actions passing any value produced by the first as an argument to the second",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "(\u003e\u003e=) \u003e\u003e=",
          "normalized": "a b c d b-\u003e(b-\u003ed e)-\u003ed e",
          "package": "base",
          "signature": "forall a b. m a-\u003e(a-\u003em b)-\u003em b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:-62--62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eraise a number to a non-negative integral power\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "(^)",
          "package": "base",
          "signature": "a -\u003e b -\u003e a",
          "source": "src/GHC-Real.html#%5E",
          "type": "function"
        },
        "index": {
          "description": "raise number to non-negative integral power",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "(^) ^",
          "normalized": "a-\u003eb-\u003ea",
          "package": "base",
          "signature": "a-\u003eb-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:-94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eraise a number to an integral power\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "(^^)",
          "package": "base",
          "signature": "a -\u003e b -\u003e a",
          "source": "src/GHC-Real.html#%5E%5E",
          "type": "function"
        },
        "index": {
          "description": "raise number to an integral power",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "(^^) ^^",
          "normalized": "a-\u003eb-\u003ea",
          "package": "base",
          "signature": "a-\u003eb-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:-94--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbsolute value.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "abs",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Num.html#abs",
          "type": "method"
        },
        "index": {
          "description": "Absolute value",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "abs",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:abs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe computation \u003ccode\u003e\u003ca\u003eappendFile\u003c/a\u003e\u003c/code\u003e \u003ccode\u003efile str\u003c/code\u003e function appends the string \u003ccode\u003estr\u003c/code\u003e,\n to the file \u003ccode\u003efile\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ca\u003ewriteFile\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eappendFile\u003c/a\u003e\u003c/code\u003e write a literal string\n to a file.  To write a value of any printable type, as with \u003ccode\u003e\u003ca\u003eprint\u003c/a\u003e\u003c/code\u003e,\n use the \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e function to convert the value to a string first.\n\u003c/p\u003e\u003cpre\u003e main = appendFile \"squares\" (show [(x,x*x) | x \u003c- [0,0.1..2]])\n\u003c/pre\u003e",
          "module": "[\"Prelude\",\"System.IO\"]",
          "name": "appendFile",
          "package": "base",
          "signature": "FilePath -\u003e String -\u003e IO ()",
          "source": "src/System-IO.html#appendFile",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:appendFile\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:appendFile\"]"
        },
        "index": {
          "description": "The computation appendFile file str function appends the string str to the file file Note that writeFile and appendFile write literal string to file To write value of any printable type as with print use the show function to convert the value to string first main appendFile squares show",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "appendFile",
          "normalized": "FilePath-\u003eString-\u003eIO()",
          "package": "base",
          "partial": "File",
          "signature": "FilePath-\u003eString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:appendFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003easTypeOf\u003c/a\u003e\u003c/code\u003e is a type-restricted version of \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e.  It is usually\n used as an infix operator, and its typing forces its first argument\n (which is usually overloaded) to have the same type as the second.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "asTypeOf",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/GHC-Base.html#asTypeOf",
          "type": "function"
        },
        "index": {
          "description": "asTypeOf is type-restricted version of const It is usually used as an infix operator and its typing forces its first argument which is usually overloaded to have the same type as the second",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "asTypeOf",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "partial": "Type Of",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:asTypeOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "asin",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Float.html#asin",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "asin",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:asin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "asinh",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Float.html#asinh",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "asinh",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:asinh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea version of arctangent taking two real floating-point arguments.\n For real floating \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eatan2\u003c/a\u003e\u003c/code\u003e y x\u003c/code\u003e computes the angle\n (from the positive x-axis) of the vector from the origin to the\n point \u003ccode\u003e(x,y)\u003c/code\u003e.  \u003ccode\u003e\u003ccode\u003e\u003ca\u003eatan2\u003c/a\u003e\u003c/code\u003e y x\u003c/code\u003e returns a value in the range [\u003ccode\u003e-pi\u003c/code\u003e,\n \u003ccode\u003epi\u003c/code\u003e].  It follows the Common Lisp semantics for the origin when\n signed zeroes are supported.  \u003ccode\u003e\u003ccode\u003e\u003ca\u003eatan2\u003c/a\u003e\u003c/code\u003e y 1\u003c/code\u003e, with \u003ccode\u003ey\u003c/code\u003e in a type\n that is \u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e, should return the same value as \u003ccode\u003e\u003ccode\u003e\u003ca\u003eatan\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e.\n A default definition of \u003ccode\u003e\u003ca\u003eatan2\u003c/a\u003e\u003c/code\u003e is provided, but implementors\n can provide a more accurate implementation.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "atan2",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/GHC-Float.html#atan2",
          "type": "method"
        },
        "index": {
          "description": "version of arctangent taking two real floating-point arguments For real floating and atan2 computes the angle from the positive x-axis of the vector from the origin to the point atan2 returns value in the range pi pi It follows the Common Lisp semantics for the origin when signed zeroes are supported atan2 with in type that is RealFloat should return the same value as atan default definition of atan2 is provided but implementors can provide more accurate implementation",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "atan2",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:atan2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eceiling\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e returns the least integer not less than \u003ccode\u003ex\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "ceiling",
          "package": "base",
          "signature": "a -\u003e b",
          "source": "src/GHC-Real.html#ceiling",
          "type": "method"
        },
        "index": {
          "description": "ceiling returns the least integer not less than",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "ceiling",
          "normalized": "a-\u003eb",
          "package": "base",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:ceiling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "compare",
          "package": "base",
          "signature": "a -\u003e a -\u003e Ordering",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "compare",
          "normalized": "a-\u003ea-\u003eOrdering",
          "package": "base",
          "signature": "a-\u003ea-\u003eOrdering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:compare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003edecodeFloat\u003c/a\u003e\u003c/code\u003e applied to a real floating-point\n number returns the significand expressed as an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e and an\n appropriately scaled exponent (an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e).  If \u003ccode\u003e\u003ccode\u003e\u003ca\u003edecodeFloat\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e\n yields \u003ccode\u003e(m,n)\u003c/code\u003e, then \u003ccode\u003ex\u003c/code\u003e is equal in value to \u003ccode\u003em*b^^n\u003c/code\u003e, where \u003ccode\u003eb\u003c/code\u003e\n is the floating-point radix, and furthermore, either \u003ccode\u003em\u003c/code\u003e and \u003ccode\u003en\u003c/code\u003e\n are both zero or else \u003ccode\u003eb^(d-1) \u003c= \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e m \u003c b^d\u003c/code\u003e, where \u003ccode\u003ed\u003c/code\u003e is\n the value of \u003ccode\u003e\u003ccode\u003e\u003ca\u003efloatDigits\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e.\n In particular, \u003ccode\u003e\u003ccode\u003e\u003ca\u003edecodeFloat\u003c/a\u003e\u003c/code\u003e 0 = (0,0)\u003c/code\u003e. If the type\n contains a negative zero, also \u003ccode\u003e\u003ccode\u003e\u003ca\u003edecodeFloat\u003c/a\u003e\u003c/code\u003e (-0.0) = (0,0)\u003c/code\u003e.\n \u003cem\u003eThe result of\u003c/em\u003e \u003ccode\u003e\u003ccode\u003e\u003ca\u003edecodeFloat\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e \u003cem\u003eis unspecified if either of\u003c/em\u003e\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eisNaN\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e \u003cem\u003eor\u003c/em\u003e \u003ccode\u003e\u003ccode\u003e\u003ca\u003eisInfinite\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e \u003cem\u003eis\u003c/em\u003e \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "decodeFloat",
          "package": "base",
          "signature": "a -\u003e (Integer, Int)",
          "source": "src/GHC-Float.html#decodeFloat",
          "type": "method"
        },
        "index": {
          "description": "The function decodeFloat applied to real floating-point number returns the significand expressed as an Integer and an appropriately scaled exponent an Int If decodeFloat yields then is equal in value to where is the floating-point radix and furthermore either and are both zero or else d-1 abs where is the value of floatDigits In particular decodeFloat If the type contains negative zero also decodeFloat The result of decodeFloat is unspecified if either of isNaN or isInfinite is True",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "decodeFloat",
          "normalized": "a-\u003e(Integer,Int)",
          "package": "base",
          "partial": "Float",
          "signature": "a-\u003e(Integer,Int)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:decodeFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einteger division truncated toward negative infinity\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "div",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/GHC-Real.html#div",
          "type": "method"
        },
        "index": {
          "description": "integer division truncated toward negative infinity",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "div",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esimultaneous \u003ccode\u003e\u003ca\u003ediv\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emod\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "divMod",
          "package": "base",
          "signature": "a -\u003e a -\u003e (a, a)",
          "source": "src/GHC-Real.html#divMod",
          "type": "method"
        },
        "index": {
          "description": "simultaneous div and mod",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "divMod",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "base",
          "partial": "Mod",
          "signature": "a-\u003ea-\u003e(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:divMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eencodeFloat\u003c/a\u003e\u003c/code\u003e performs the inverse of \u003ccode\u003e\u003ca\u003edecodeFloat\u003c/a\u003e\u003c/code\u003e in the\n sense that for finite \u003ccode\u003ex\u003c/code\u003e with the exception of \u003ccode\u003e-0.0\u003c/code\u003e,\n \u003ccode\u003e\u003ccode\u003euncurry\u003c/code\u003e \u003ccode\u003e\u003ca\u003eencodeFloat\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003edecodeFloat\u003c/a\u003e\u003c/code\u003e x) = x\u003c/code\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eencodeFloat\u003c/a\u003e\u003c/code\u003e m n\u003c/code\u003e is one of the two closest representable\n floating-point numbers to \u003ccode\u003em*b^^n\u003c/code\u003e (or \u003ccode\u003e&#177;Infinity\u003c/code\u003e if overflow\n occurs); usually the closer, but if \u003ccode\u003em\u003c/code\u003e contains too many bits,\n the result may be rounded in the wrong direction.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "encodeFloat",
          "package": "base",
          "signature": "Integer -\u003e Int -\u003e a",
          "source": "src/GHC-Float.html#encodeFloat",
          "type": "method"
        },
        "index": {
          "description": "encodeFloat performs the inverse of decodeFloat in the sense that for finite with the exception of uncurry encodeFloat decodeFloat encodeFloat is one of the two closest representable floating-point numbers to or Infinity if overflow occurs usually the closer but if contains too many bits the result may be rounded in the wrong direction",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "encodeFloat",
          "normalized": "Integer-\u003eInt-\u003ea",
          "package": "base",
          "partial": "Float",
          "signature": "Integer-\u003eInt-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:encodeFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in Haskell's translation of \u003ccode\u003e[n..]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "enumFrom",
          "package": "base",
          "signature": "a -\u003e [a]",
          "source": "src/GHC-Enum.html#enumFrom",
          "type": "method"
        },
        "index": {
          "description": "Used in Haskell translation of",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "enumFrom",
          "normalized": "a-\u003e[a]",
          "package": "base",
          "partial": "From",
          "signature": "a-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:enumFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in Haskell's translation of \u003ccode\u003e[n,n'..]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "enumFromThen",
          "package": "base",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "src/GHC-Enum.html#enumFromThen",
          "type": "method"
        },
        "index": {
          "description": "Used in Haskell translation of",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "enumFromThen",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "base",
          "partial": "From Then",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:enumFromThen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in Haskell's translation of \u003ccode\u003e[n,n'..m]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "enumFromThenTo",
          "package": "base",
          "signature": "a -\u003e a -\u003e a -\u003e [a]",
          "source": "src/GHC-Enum.html#enumFromThenTo",
          "type": "method"
        },
        "index": {
          "description": "Used in Haskell translation of",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "enumFromThenTo",
          "normalized": "a-\u003ea-\u003ea-\u003e[a]",
          "package": "base",
          "partial": "From Then To",
          "signature": "a-\u003ea-\u003ea-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:enumFromThenTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in Haskell's translation of \u003ccode\u003e[n..m]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "enumFromTo",
          "package": "base",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "src/GHC-Enum.html#enumFromTo",
          "type": "method"
        },
        "index": {
          "description": "Used in Haskell translation of n..m",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "enumFromTo",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "base",
          "partial": "From To",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:enumFromTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e stops execution and displays an error message.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "error",
          "package": "base",
          "signature": "[Char] -\u003e a",
          "source": "src/GHC-Err.html#error",
          "type": "function"
        },
        "index": {
          "description": "error stops execution and displays an error message",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "error",
          "normalized": "[Char]-\u003ea",
          "package": "base",
          "signature": "[Char]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "even",
          "package": "base",
          "signature": "a -\u003e Bool",
          "source": "src/GHC-Real.html#even",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "even",
          "normalized": "a-\u003eBool",
          "package": "base",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:even"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "exp",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Float.html#exp",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "exp",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eexponent\u003c/a\u003e\u003c/code\u003e corresponds to the second component of \u003ccode\u003e\u003ca\u003edecodeFloat\u003c/a\u003e\u003c/code\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eexponent\u003c/a\u003e\u003c/code\u003e 0 = 0\u003c/code\u003e and for finite nonzero \u003ccode\u003ex\u003c/code\u003e,\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eexponent\u003c/a\u003e\u003c/code\u003e x = snd (\u003ccode\u003e\u003ca\u003edecodeFloat\u003c/a\u003e\u003c/code\u003e x) + \u003ccode\u003e\u003ca\u003efloatDigits\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e.\n If \u003ccode\u003ex\u003c/code\u003e is a finite floating-point number, it is equal in value to\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003esignificand\u003c/a\u003e\u003c/code\u003e x * b ^^ \u003ccode\u003e\u003ca\u003eexponent\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e, where \u003ccode\u003eb\u003c/code\u003e is the\n floating-point radix.\n The behaviour is unspecified on infinite or \u003ccode\u003eNaN\u003c/code\u003e values.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "exponent",
          "package": "base",
          "signature": "a -\u003e Int",
          "source": "src/GHC-Float.html#exponent",
          "type": "method"
        },
        "index": {
          "description": "exponent corresponds to the second component of decodeFloat exponent and for finite nonzero exponent snd decodeFloat floatDigits If is finite floating-point number it is equal in value to significand exponent where is the floating-point radix The behaviour is unspecified on infinite or NaN values",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "exponent",
          "normalized": "a-\u003eInt",
          "package": "base",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:exponent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFail with a message.  This operation is not part of the\n mathematical definition of a monad, but is invoked on pattern-match\n failure in a \u003ccode\u003edo\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "fail",
          "package": "base",
          "signature": "String -\u003e m a",
          "source": "src/GHC-Base.html#fail",
          "type": "method"
        },
        "index": {
          "description": "Fail with message This operation is not part of the mathematical definition of monad but is invoked on pattern-match failure in do expression",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "fail",
          "normalized": "String-\u003ea b",
          "package": "base",
          "signature": "String-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:fail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea constant function, returning the number of digits of\n \u003ccode\u003e\u003ca\u003efloatRadix\u003c/a\u003e\u003c/code\u003e in the significand\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "floatDigits",
          "package": "base",
          "signature": "a -\u003e Int",
          "source": "src/GHC-Float.html#floatDigits",
          "type": "method"
        },
        "index": {
          "description": "constant function returning the number of digits of floatRadix in the significand",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "floatDigits",
          "normalized": "a-\u003eInt",
          "package": "base",
          "partial": "Digits",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:floatDigits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea constant function, returning the radix of the representation\n (often \u003ccode\u003e2\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "floatRadix",
          "package": "base",
          "signature": "a -\u003e Integer",
          "source": "src/GHC-Float.html#floatRadix",
          "type": "method"
        },
        "index": {
          "description": "constant function returning the radix of the representation often",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "floatRadix",
          "normalized": "a-\u003eInteger",
          "package": "base",
          "partial": "Radix",
          "signature": "a-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:floatRadix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea constant function, returning the lowest and highest values\n the exponent may assume\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "floatRange",
          "package": "base",
          "signature": "a -\u003e (Int, Int)",
          "source": "src/GHC-Float.html#floatRange",
          "type": "method"
        },
        "index": {
          "description": "constant function returning the lowest and highest values the exponent may assume",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "floatRange",
          "normalized": "a-\u003e(Int,Int)",
          "package": "base",
          "partial": "Range",
          "signature": "a-\u003e(Int,Int)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:floatRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003efloor\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e returns the greatest integer not greater than \u003ccode\u003ex\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "floor",
          "package": "base",
          "signature": "a -\u003e b",
          "source": "src/GHC-Real.html#floor",
          "type": "method"
        },
        "index": {
          "description": "floor returns the greatest integer not greater than",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "floor",
          "normalized": "a-\u003eb",
          "package": "base",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:floor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "fmap",
          "package": "base",
          "signature": "(a -\u003e b) -\u003e f a -\u003e f b",
          "source": "src/GHC-Base.html#fmap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "fmap",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "base",
          "signature": "(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:fmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert to an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n It is implementation-dependent what \u003ccode\u003e\u003ca\u003efromEnum\u003c/a\u003e\u003c/code\u003e returns when\n applied to a value that is too large to fit in an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "fromEnum",
          "package": "base",
          "signature": "a -\u003e Int",
          "source": "src/GHC-Enum.html#fromEnum",
          "type": "method"
        },
        "index": {
          "description": "Convert to an Int It is implementation-dependent what fromEnum returns when applied to value that is too large to fit in an Int",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "fromEnum",
          "normalized": "a-\u003eInt",
          "package": "base",
          "partial": "Enum",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:fromEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion from an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e.\n An integer literal represents the application of the function\n \u003ccode\u003e\u003ca\u003efromInteger\u003c/a\u003e\u003c/code\u003e to the appropriate value of type \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e,\n so such literals have type \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e a\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "fromInteger",
          "package": "base",
          "signature": "Integer -\u003e a",
          "source": "src/GHC-Num.html#fromInteger",
          "type": "method"
        },
        "index": {
          "description": "Conversion from an Integer An integer literal represents the application of the function fromInteger to the appropriate value of type Integer so such literals have type Num",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "fromInteger",
          "normalized": "Integer-\u003ea",
          "package": "base",
          "partial": "Integer",
          "signature": "Integer-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:fromInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeneral coercion from integral types\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "fromIntegral",
          "package": "base",
          "signature": "a -\u003e b",
          "source": "src/GHC-Real.html#fromIntegral",
          "type": "function"
        },
        "index": {
          "description": "general coercion from integral types",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "fromIntegral",
          "normalized": "a-\u003eb",
          "package": "base",
          "partial": "Integral",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:fromIntegral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion from a \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e (that is \u003ccode\u003e\u003ccode\u003e\u003ca\u003eRatio\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e).\n A floating literal stands for an application of \u003ccode\u003e\u003ca\u003efromRational\u003c/a\u003e\u003c/code\u003e\n to a value of type \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e, so such literals have type\n \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a) =\u003e a\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "fromRational",
          "package": "base",
          "signature": "Rational -\u003e a",
          "source": "src/GHC-Real.html#fromRational",
          "type": "method"
        },
        "index": {
          "description": "Conversion from Rational that is Ratio Integer floating literal stands for an application of fromRational to value of type Rational so such literals have type Fractional",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "fromRational",
          "normalized": "Rational-\u003ea",
          "package": "base",
          "partial": "Rational",
          "signature": "Rational-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:fromRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003egcd\u003c/a\u003e\u003c/code\u003e x y\u003c/code\u003e is the non-negative factor of both \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e of which\n every common factor of \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e is also a factor; for example\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003egcd\u003c/a\u003e\u003c/code\u003e 4 2 = 2\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003egcd\u003c/a\u003e\u003c/code\u003e (-4) 6 = 2\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003egcd\u003c/a\u003e\u003c/code\u003e 0 4\u003c/code\u003e = \u003ccode\u003e4\u003c/code\u003e. \u003ccode\u003e\u003ccode\u003e\u003ca\u003egcd\u003c/a\u003e\u003c/code\u003e 0 0\u003c/code\u003e = \u003ccode\u003e0\u003c/code\u003e.\n (That is, the common divisor that is \"greatest\" in the divisibility\n preordering.)\n\u003c/p\u003e\u003cp\u003eNote: Since for signed fixed-width integer types, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eminBound\u003c/a\u003e\u003c/code\u003e \u003c 0\u003c/code\u003e,\n the result may be negative if one of the arguments is \u003ccode\u003e\u003ccode\u003e\u003ca\u003eminBound\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e (and\n necessarily is if the other is \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e\u003ccode\u003e\u003ca\u003eminBound\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e) for such types.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "gcd",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/GHC-Real.html#gcd",
          "type": "function"
        },
        "index": {
          "description": "gcd is the non-negative factor of both and of which every common factor of and is also factor for example gcd gcd gcd gcd That is the common divisor that is greatest in the divisibility preordering Note Since for signed fixed-width integer types abs minBound the result may be negative if one of the arguments is minBound and necessarily is if the other is or minBound for such types",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "gcd",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:gcd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a character from the standard input device\n (same as \u003ccode\u003e\u003ca\u003ehGetChar\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003estdin\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"System.IO\"]",
          "name": "getChar",
          "package": "base",
          "signature": "IO Char",
          "source": "src/System-IO.html#getChar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:getChar\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:getChar\"]"
        },
        "index": {
          "description": "Read character from the standard input device same as hGetChar stdin",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "getChar",
          "package": "base",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:getChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egetContents\u003c/a\u003e\u003c/code\u003e operation returns all user input as a single string,\n which is read lazily as it is needed\n (same as \u003ccode\u003e\u003ca\u003ehGetContents\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003estdin\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"System.IO\"]",
          "name": "getContents",
          "package": "base",
          "signature": "IO String",
          "source": "src/System-IO.html#getContents",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:getContents\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:getContents\"]"
        },
        "index": {
          "description": "The getContents operation returns all user input as single string which is read lazily as it is needed same as hGetContents stdin",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "getContents",
          "package": "base",
          "partial": "Contents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:getContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a line from the standard input device\n (same as \u003ccode\u003e\u003ca\u003ehGetLine\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003estdin\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"System.IO\"]",
          "name": "getLine",
          "package": "base",
          "signature": "IO String",
          "source": "src/System-IO.html#getLine",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:getLine\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:getLine\"]"
        },
        "index": {
          "description": "Read line from the standard input device same as hGetLine stdin",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "getLine",
          "package": "base",
          "partial": "Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:getLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003einteract\u003c/a\u003e\u003c/code\u003e function takes a function of type \u003ccode\u003eString-\u003eString\u003c/code\u003e\n as its argument.  The entire input from the standard input device is\n passed to this function as its argument, and the resulting string is\n output on the standard output device.\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"System.IO\"]",
          "name": "interact",
          "package": "base",
          "signature": "(String -\u003e String) -\u003e IO ()",
          "source": "src/System-IO.html#interact",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:interact\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:interact\"]"
        },
        "index": {
          "description": "The interact function takes function of type String String as its argument The entire input from the standard input device is passed to this function as its argument and the resulting string is output on the standard output device",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "interact",
          "normalized": "(String-\u003eString)-\u003eIO()",
          "package": "base",
          "signature": "(String-\u003eString)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:interact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the argument is too small to be represented in\n normalized format\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "isDenormalized",
          "package": "base",
          "signature": "a -\u003e Bool",
          "source": "src/GHC-Float.html#isDenormalized",
          "type": "method"
        },
        "index": {
          "description": "True if the argument is too small to be represented in normalized format",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "isDenormalized",
          "normalized": "a-\u003eBool",
          "package": "base",
          "partial": "Denormalized",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:isDenormalized"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the argument is an IEEE floating point number\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "isIEEE",
          "package": "base",
          "signature": "a -\u003e Bool",
          "source": "src/GHC-Float.html#isIEEE",
          "type": "method"
        },
        "index": {
          "description": "True if the argument is an IEEE floating point number",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "isIEEE",
          "normalized": "a-\u003eBool",
          "package": "base",
          "partial": "IEEE",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:isIEEE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the argument is an IEEE infinity or negative infinity\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "isInfinite",
          "package": "base",
          "signature": "a -\u003e Bool",
          "source": "src/GHC-Float.html#isInfinite",
          "type": "method"
        },
        "index": {
          "description": "True if the argument is an IEEE infinity or negative infinity",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "isInfinite",
          "normalized": "a-\u003eBool",
          "package": "base",
          "partial": "Infinite",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:isInfinite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the argument is an IEEE \"not-a-number\" (NaN) value\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "isNaN",
          "package": "base",
          "signature": "a -\u003e Bool",
          "source": "src/GHC-Float.html#isNaN",
          "type": "method"
        },
        "index": {
          "description": "True if the argument is an IEEE not-a-number NaN value",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "isNaN",
          "normalized": "a-\u003eBool",
          "package": "base",
          "partial": "Na",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:isNaN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the argument is an IEEE negative zero\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "isNegativeZero",
          "package": "base",
          "signature": "a -\u003e Bool",
          "source": "src/GHC-Float.html#isNegativeZero",
          "type": "method"
        },
        "index": {
          "description": "True if the argument is an IEEE negative zero",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "isNegativeZero",
          "normalized": "a-\u003eBool",
          "package": "base",
          "partial": "Negative Zero",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:isNegativeZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003elcm\u003c/a\u003e\u003c/code\u003e x y\u003c/code\u003e is the smallest positive integer that both \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e divide.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "lcm",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/GHC-Real.html#lcm",
          "type": "function"
        },
        "index": {
          "description": "lcm is the smallest positive integer that both and divide",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "lcm",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:lcm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003elex\u003c/a\u003e\u003c/code\u003e function reads a single lexeme from the input, discarding\n initial white space, and returning the characters that constitute the\n lexeme.  If the input string contains only white space, \u003ccode\u003e\u003ca\u003elex\u003c/a\u003e\u003c/code\u003e returns a\n single successful `lexeme' consisting of the empty string.  (Thus\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003elex\u003c/a\u003e\u003c/code\u003e \"\" = [(\"\",\"\")]\u003c/code\u003e.)  If there is no legal lexeme at the\n beginning of the input string, \u003ccode\u003e\u003ca\u003elex\u003c/a\u003e\u003c/code\u003e fails (i.e. returns \u003ccode\u003e[]\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eThis lexer is not completely faithful to the Haskell lexical syntax\n in the following respects:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Qualified names are not handled properly\n\u003c/li\u003e\u003cli\u003e Octal and hexadecimal numerics are not recognized as a single token\n\u003c/li\u003e\u003cli\u003e Comments are not treated properly\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Prelude\",\"Text.Read\"]",
          "name": "lex",
          "package": "base",
          "signature": "ReadS String",
          "source": "src/GHC-Read.html#lex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:lex\",\"http://hackage.haskell.org/package/base/docs/Text-Read.html#v:lex\"]"
        },
        "index": {
          "description": "The lex function reads single lexeme from the input discarding initial white space and returning the characters that constitute the lexeme If the input string contains only white space lex returns single successful lexeme consisting of the empty string Thus lex If there is no legal lexeme at the beginning of the input string lex fails i.e returns This lexer is not completely faithful to the Haskell lexical syntax in the following respects Qualified names are not handled properly Octal and hexadecimal numerics are not recognized as single token Comments are not treated properly",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "lex",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:lex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "max",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "max",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:max"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "min",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "min",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:min"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "minBound",
          "package": "base",
          "signature": "a",
          "source": "src/GHC-Enum.html#minBound",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "minBound",
          "package": "base",
          "partial": "Bound",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:minBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einteger modulus, satisfying\n\u003c/p\u003e\u003cpre\u003e (x `div` y)*y + (x `mod` y) == x\n\u003c/pre\u003e",
          "module": "Prelude",
          "name": "mod",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/GHC-Real.html#mod",
          "type": "method"
        },
        "index": {
          "description": "integer modulus satisfying div mod",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "mod",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnary negation.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "negate",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Num.html#negate",
          "type": "method"
        },
        "index": {
          "description": "Unary negation",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "negate",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "odd",
          "package": "base",
          "signature": "a -\u003e Bool",
          "source": "src/GHC-Real.html#odd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "odd",
          "normalized": "a-\u003eBool",
          "package": "base",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:odd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "pi",
          "package": "base",
          "signature": "a",
          "source": "src/GHC-Float.html#pi",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "pi",
          "package": "base",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:pi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe predecessor of a value.  For numeric types, \u003ccode\u003e\u003ca\u003epred\u003c/a\u003e\u003c/code\u003e subtracts 1.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "pred",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Enum.html#pred",
          "type": "method"
        },
        "index": {
          "description": "the predecessor of value For numeric types pred subtracts",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "pred",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:pred"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eprint\u003c/a\u003e\u003c/code\u003e function outputs a value of any printable type to the\n standard output device.\n Printable types are those that are instances of class \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e; \u003ccode\u003e\u003ca\u003eprint\u003c/a\u003e\u003c/code\u003e\n converts values to strings for output using the \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e operation and\n adds a newline.\n\u003c/p\u003e\u003cp\u003eFor example, a program to print the first 20 integers and their\n powers of 2 could be written as:\n\u003c/p\u003e\u003cpre\u003e main = print ([(n, 2^n) | n \u003c- [0..19]])\n\u003c/pre\u003e",
          "module": "[\"Prelude\",\"System.IO\"]",
          "name": "print",
          "package": "base",
          "signature": "a -\u003e IO ()",
          "source": "src/System-IO.html#print",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:print\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:print\"]"
        },
        "index": {
          "description": "The print function outputs value of any printable type to the standard output device Printable types are those that are instances of class Show print converts values to strings for output using the show operation and adds newline For example program to print the first integers and their powers of could be written as main print",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "print",
          "normalized": "a-\u003eIO()",
          "package": "base",
          "signature": "a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:print"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003eproperFraction\u003c/a\u003e\u003c/code\u003e takes a real fractional number \u003ccode\u003ex\u003c/code\u003e\n and returns a pair \u003ccode\u003e(n,f)\u003c/code\u003e such that \u003ccode\u003ex = n+f\u003c/code\u003e, and:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003en\u003c/code\u003e is an integral number with the same sign as \u003ccode\u003ex\u003c/code\u003e; and\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ef\u003c/code\u003e is a fraction with the same type and sign as \u003ccode\u003ex\u003c/code\u003e,\n   and with absolute value less than \u003ccode\u003e1\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe default definitions of the \u003ccode\u003e\u003ca\u003eceiling\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003efloor\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003etruncate\u003c/a\u003e\u003c/code\u003e\n and \u003ccode\u003e\u003ca\u003eround\u003c/a\u003e\u003c/code\u003e functions are in terms of \u003ccode\u003e\u003ca\u003eproperFraction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "properFraction",
          "package": "base",
          "signature": "a -\u003e (b, a)",
          "source": "src/GHC-Real.html#properFraction",
          "type": "method"
        },
        "index": {
          "description": "The function properFraction takes real fractional number and returns pair such that and is an integral number with the same sign as and is fraction with the same type and sign as and with absolute value less than The default definitions of the ceiling floor truncate and round functions are in terms of properFraction",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "properFraction",
          "normalized": "a-\u003e(b,a)",
          "package": "base",
          "partial": "Fraction",
          "signature": "a-\u003e(b,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:properFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a character to the standard output device\n (same as \u003ccode\u003e\u003ca\u003ehPutChar\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003estdout\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"System.IO\"]",
          "name": "putChar",
          "package": "base",
          "signature": "Char -\u003e IO ()",
          "source": "src/System-IO.html#putChar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:putChar\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:putChar\"]"
        },
        "index": {
          "description": "Write character to the standard output device same as hPutChar stdout",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "putChar",
          "normalized": "Char-\u003eIO()",
          "package": "base",
          "partial": "Char",
          "signature": "Char-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:putChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a string to the standard output device\n (same as \u003ccode\u003e\u003ca\u003ehPutStr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003estdout\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"System.IO\"]",
          "name": "putStr",
          "package": "base",
          "signature": "String -\u003e IO ()",
          "source": "src/System-IO.html#putStr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:putStr\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:putStr\"]"
        },
        "index": {
          "description": "Write string to the standard output device same as hPutStr stdout",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "putStr",
          "normalized": "String-\u003eIO()",
          "package": "base",
          "partial": "Str",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:putStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe same as \u003ccode\u003e\u003ca\u003eputStr\u003c/a\u003e\u003c/code\u003e, but adds a newline character.\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"System.IO\"]",
          "name": "putStrLn",
          "package": "base",
          "signature": "String -\u003e IO ()",
          "source": "src/System-IO.html#putStrLn",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:putStrLn\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:putStrLn\"]"
        },
        "index": {
          "description": "The same as putStr but adds newline character",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "putStrLn",
          "normalized": "String-\u003eIO()",
          "package": "base",
          "partial": "Str Ln",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:putStrLn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einteger division truncated toward zero\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "quot",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/GHC-Real.html#quot",
          "type": "method"
        },
        "index": {
          "description": "integer division truncated toward zero",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "quot",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:quot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esimultaneous \u003ccode\u003e\u003ca\u003equot\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003erem\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "quotRem",
          "package": "base",
          "signature": "a -\u003e a -\u003e (a, a)",
          "source": "src/GHC-Real.html#quotRem",
          "type": "method"
        },
        "index": {
          "description": "simultaneous quot and rem",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "quotRem",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "base",
          "partial": "Rem",
          "signature": "a-\u003ea-\u003e(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:quotRem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eread\u003c/a\u003e\u003c/code\u003e function reads input from a string, which must be\n completely consumed by the input process.\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"Text.Read\"]",
          "name": "read",
          "package": "base",
          "signature": "String -\u003e a",
          "source": "src/Text-Read.html#read",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:read\",\"http://hackage.haskell.org/package/base/docs/Text-Read.html#v:read\"]"
        },
        "index": {
          "description": "The read function reads input from string which must be completely consumed by the input process",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "read",
          "normalized": "String-\u003ea",
          "package": "base",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:read"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ereadFile\u003c/a\u003e\u003c/code\u003e function reads a file and\n returns the contents of the file as a string.\n The file is read lazily, on demand, as with \u003ccode\u003e\u003ca\u003egetContents\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"System.IO\"]",
          "name": "readFile",
          "package": "base",
          "signature": "FilePath -\u003e IO String",
          "source": "src/System-IO.html#readFile",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:readFile\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:readFile\"]"
        },
        "index": {
          "description": "The readFile function reads file and returns the contents of the file as string The file is read lazily on demand as with getContents",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "readFile",
          "normalized": "FilePath-\u003eIO String",
          "package": "base",
          "partial": "File",
          "signature": "FilePath-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:readFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ereadIO\u003c/a\u003e\u003c/code\u003e function is similar to \u003ccode\u003e\u003ca\u003eread\u003c/a\u003e\u003c/code\u003e except that it signals\n parse failure to the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad instead of terminating the program.\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"System.IO\"]",
          "name": "readIO",
          "package": "base",
          "signature": "String -\u003e IO a",
          "source": "src/System-IO.html#readIO",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:readIO\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:readIO\"]"
        },
        "index": {
          "description": "The readIO function is similar to read except that it signals parse failure to the IO monad instead of terminating the program",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "readIO",
          "normalized": "String-\u003eIO a",
          "package": "base",
          "partial": "IO",
          "signature": "String-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:readIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe method \u003ccode\u003e\u003ca\u003ereadList\u003c/a\u003e\u003c/code\u003e is provided to allow the programmer to\n give a specialised way of parsing lists of values.\n For example, this is used by the predefined \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e instance of\n the \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e type, where values of type \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e should be are\n expected to use double quotes, rather than square brackets.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "readList",
          "package": "base",
          "signature": "ReadS [a]",
          "source": "src/GHC-Read.html#readList",
          "type": "method"
        },
        "index": {
          "description": "The method readList is provided to allow the programmer to give specialised way of parsing lists of values For example this is used by the predefined Read instance of the Char type where values of type String should be are expected to use double quotes rather than square brackets",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "readList",
          "normalized": "ReadS[a]",
          "package": "base",
          "partial": "List",
          "signature": "ReadS[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:readList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ereadLn\u003c/a\u003e\u003c/code\u003e function combines \u003ccode\u003e\u003ca\u003egetLine\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ereadIO\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"System.IO\"]",
          "name": "readLn",
          "package": "base",
          "signature": "IO a",
          "source": "src/System-IO.html#readLn",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:readLn\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:readLn\"]"
        },
        "index": {
          "description": "The readLn function combines getLine and readIO",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "readLn",
          "package": "base",
          "partial": "Ln",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:readLn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ereadParen\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e p\u003c/code\u003e parses what \u003ccode\u003ep\u003c/code\u003e parses, but surrounded with\n parentheses.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ereadParen\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e p\u003c/code\u003e parses what \u003ccode\u003ep\u003c/code\u003e parses, but optionally\n surrounded with parentheses.\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"Text.Read\"]",
          "name": "readParen",
          "package": "base",
          "signature": "Bool -\u003e ReadS a -\u003e ReadS a",
          "source": "src/GHC-Read.html#readParen",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:readParen\",\"http://hackage.haskell.org/package/base/docs/Text-Read.html#v:readParen\"]"
        },
        "index": {
          "description": "readParen True parses what parses but surrounded with parentheses readParen False parses what parses but optionally surrounded with parentheses",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "readParen",
          "normalized": "Bool-\u003eReadS a-\u003eReadS a",
          "package": "base",
          "partial": "Paren",
          "signature": "Bool-\u003eReadS a-\u003eReadS a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:readParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eequivalent to \u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e with a precedence of 0.\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"Text.Read\"]",
          "name": "reads",
          "package": "base",
          "signature": "ReadS a",
          "source": "src/Text-Read.html#reads",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:reads\",\"http://hackage.haskell.org/package/base/docs/Text-Read.html#v:reads\"]"
        },
        "index": {
          "description": "equivalent to readsPrec with precedence of",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "reads",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:reads"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eattempts to parse a value from the front of the string, returning\n a list of (parsed value, remaining string) pairs.  If there is no\n successful parse, the returned list is empty.\n\u003c/p\u003e\u003cp\u003eDerived instances of \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e satisfy the following:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e(x,\"\")\u003c/code\u003e is an element of\n   \u003ccode\u003e(\u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e d (\u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e d x \"\"))\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThat is, \u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e parses the string produced by\n \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e, and delivers the value that\n \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e started with.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "readsPrec",
          "package": "base",
          "signature": "readsPrec",
          "source": "src/GHC-Read.html#readsPrec",
          "type": "method"
        },
        "index": {
          "description": "attempts to parse value from the front of the string returning list of parsed value remaining string pairs If there is no successful parse the returned list is empty Derived instances of Read and Show satisfy the following is an element of readsPrec showsPrec That is readsPrec parses the string produced by showsPrec and delivers the value that showsPrec started with",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "readsPrec",
          "package": "base",
          "partial": "Prec",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:readsPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeneral coercion to fractional types\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "realToFrac",
          "package": "base",
          "signature": "a -\u003e b",
          "source": "src/GHC-Real.html#realToFrac",
          "type": "function"
        },
        "index": {
          "description": "general coercion to fractional types",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "realToFrac",
          "normalized": "a-\u003eb",
          "package": "base",
          "partial": "To Frac",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:realToFrac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereciprocal fraction\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "recip",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Real.html#recip",
          "type": "method"
        },
        "index": {
          "description": "reciprocal fraction",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "recip",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einteger remainder, satisfying\n\u003c/p\u003e\u003cpre\u003e (x `quot` y)*y + (x `rem` y) == x\n\u003c/pre\u003e",
          "module": "Prelude",
          "name": "rem",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/GHC-Real.html#rem",
          "type": "method"
        },
        "index": {
          "description": "integer remainder satisfying quot rem",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "rem",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:rem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject a value into the monadic type.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "return",
          "package": "base",
          "signature": "a -\u003e m a",
          "source": "src/GHC-Base.html#return",
          "type": "method"
        },
        "index": {
          "description": "Inject value into the monadic type",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "return",
          "normalized": "a-\u003eb a",
          "package": "base",
          "signature": "a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:return"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eround\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e returns the nearest integer to \u003ccode\u003ex\u003c/code\u003e;\n   the even integer if \u003ccode\u003ex\u003c/code\u003e is equidistant between two integers\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "round",
          "package": "base",
          "signature": "a -\u003e b",
          "source": "src/GHC-Real.html#round",
          "type": "method"
        },
        "index": {
          "description": "round returns the nearest integer to the even integer if is equidistant between two integers",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "round",
          "normalized": "a-\u003eb",
          "package": "base",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:round"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emultiplies a floating-point number by an integer power of the radix\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "scaleFloat",
          "package": "base",
          "signature": "Int -\u003e a -\u003e a",
          "source": "src/GHC-Float.html#scaleFloat",
          "type": "method"
        },
        "index": {
          "description": "multiplies floating-point number by an integer power of the radix",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "scaleFloat",
          "normalized": "Int-\u003ea-\u003ea",
          "package": "base",
          "partial": "Float",
          "signature": "Int-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:scaleFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluates its first argument to head normal form, and then returns its second\n \targument as the result. \n\u003c/p\u003e",
          "module": "Prelude",
          "name": "seq",
          "package": "base",
          "signature": "a -\u003e b -\u003e b",
          "type": "function"
        },
        "index": {
          "description": "Evaluates its first argument to head normal form and then returns its second argument as the result",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "seq",
          "normalized": "a-\u003eb-\u003eb",
          "package": "base",
          "signature": "a-\u003eb-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA specialised variant of \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e, using precedence context\n zero, and returning an ordinary \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "show",
          "package": "base",
          "signature": "a -\u003e String",
          "source": "src/GHC-Show.html#show",
          "type": "method"
        },
        "index": {
          "description": "specialised variant of showsPrec using precedence context zero and returning an ordinary String",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "show",
          "normalized": "a-\u003eString",
          "package": "base",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:show"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eutility function converting a \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e to a show function that\n simply prepends the character unchanged.\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"Text.Show\"]",
          "name": "showChar",
          "package": "base",
          "signature": "Char -\u003e ShowS",
          "source": "src/GHC-Show.html#showChar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:showChar\",\"http://hackage.haskell.org/package/base/docs/Text-Show.html#v:showChar\"]"
        },
        "index": {
          "description": "utility function converting Char to show function that simply prepends the character unchanged",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "showChar",
          "normalized": "Char-\u003eShowS",
          "package": "base",
          "partial": "Char",
          "signature": "Char-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:showChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe method \u003ccode\u003e\u003ca\u003eshowList\u003c/a\u003e\u003c/code\u003e is provided to allow the programmer to\n give a specialised way of showing lists of values.\n For example, this is used by the predefined \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instance of\n the \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e type, where values of type \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e should be shown\n in double quotes, rather than between square brackets.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "showList",
          "package": "base",
          "signature": "[a] -\u003e ShowS",
          "source": "src/GHC-Show.html#showList",
          "type": "method"
        },
        "index": {
          "description": "The method showList is provided to allow the programmer to give specialised way of showing lists of values For example this is used by the predefined Show instance of the Char type where values of type String should be shown in double quotes rather than between square brackets",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "showList",
          "normalized": "[a]-\u003eShowS",
          "package": "base",
          "partial": "List",
          "signature": "[a]-\u003eShowS",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:showList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eutility function that surrounds the inner show function with\n parentheses when the \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e parameter is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"Text.Show\"]",
          "name": "showParen",
          "package": "base",
          "signature": "Bool -\u003e ShowS -\u003e ShowS",
          "source": "src/GHC-Show.html#showParen",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:showParen\",\"http://hackage.haskell.org/package/base/docs/Text-Show.html#v:showParen\"]"
        },
        "index": {
          "description": "utility function that surrounds the inner show function with parentheses when the Bool parameter is True",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "showParen",
          "normalized": "Bool-\u003eShowS-\u003eShowS",
          "package": "base",
          "partial": "Paren",
          "signature": "Bool-\u003eShowS-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:showParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eutility function converting a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e to a show function that\n simply prepends the string unchanged.\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"Text.Show\"]",
          "name": "showString",
          "package": "base",
          "signature": "String -\u003e ShowS",
          "source": "src/GHC-Show.html#showString",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:showString\",\"http://hackage.haskell.org/package/base/docs/Text-Show.html#v:showString\"]"
        },
        "index": {
          "description": "utility function converting String to show function that simply prepends the string unchanged",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "showString",
          "normalized": "String-\u003eShowS",
          "package": "base",
          "partial": "String",
          "signature": "String-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:showString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eequivalent to \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e with a precedence of 0.\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"Text.Show\"]",
          "name": "shows",
          "package": "base",
          "signature": "a -\u003e ShowS",
          "source": "src/GHC-Show.html#shows",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:shows\",\"http://hackage.haskell.org/package/base/docs/Text-Show.html#v:shows\"]"
        },
        "index": {
          "description": "equivalent to showsPrec with precedence of",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "shows",
          "normalized": "a-\u003eShowS",
          "package": "base",
          "signature": "a-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:shows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a value to a readable \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e should satisfy the law\n\u003c/p\u003e\u003cpre\u003e showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)\n\u003c/pre\u003e\u003cp\u003eDerived instances of \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e satisfy the following:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e(x,\"\")\u003c/code\u003e is an element of\n   \u003ccode\u003e(\u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e d (\u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e d x \"\"))\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThat is, \u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e parses the string produced by\n \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e, and delivers the value that \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e started with.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "showsPrec",
          "package": "base",
          "signature": "showsPrec",
          "source": "src/GHC-Show.html#showsPrec",
          "type": "method"
        },
        "index": {
          "description": "Convert value to readable String showsPrec should satisfy the law showsPrec showsPrec Derived instances of Read and Show satisfy the following is an element of readsPrec showsPrec That is readsPrec parses the string produced by showsPrec and delivers the value that showsPrec started with",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "showsPrec",
          "package": "base",
          "partial": "Prec",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:showsPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe first component of \u003ccode\u003e\u003ca\u003edecodeFloat\u003c/a\u003e\u003c/code\u003e, scaled to lie in the open\n interval (\u003ccode\u003e-1\u003c/code\u003e,\u003ccode\u003e1\u003c/code\u003e), either \u003ccode\u003e0.0\u003c/code\u003e or of absolute value \u003ccode\u003e\u003e= 1/b\u003c/code\u003e,\n where \u003ccode\u003eb\u003c/code\u003e is the floating-point radix.\n The behaviour is unspecified on infinite or \u003ccode\u003eNaN\u003c/code\u003e values.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "significand",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Float.html#significand",
          "type": "method"
        },
        "index": {
          "description": "The first component of decodeFloat scaled to lie in the open interval either or of absolute value where is the floating-point radix The behaviour is unspecified on infinite or NaN values",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "significand",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:significand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSign of a number.\n The functions \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e should satisfy the law:\n\u003c/p\u003e\u003cpre\u003e abs x * signum x == x\n\u003c/pre\u003e\u003cp\u003eFor real numbers, the \u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e is either \u003ccode\u003e-1\u003c/code\u003e (negative), \u003ccode\u003e0\u003c/code\u003e (zero)\n or \u003ccode\u003e1\u003c/code\u003e (positive).\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "signum",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Num.html#signum",
          "type": "method"
        },
        "index": {
          "description": "Sign of number The functions abs and signum should satisfy the law abs signum For real numbers the signum is either negative zero or positive",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "signum",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:signum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "sin",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Float.html#sin",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "sin",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:sin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude",
          "name": "sinh",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Float.html#sinh",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "sinh",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:sinh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe same as \u003ccode\u003e\u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e-\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eBecause \u003ccode\u003e-\u003c/code\u003e is treated specially in the Haskell grammar,\n \u003ccode\u003e(-\u003c/code\u003e \u003cem\u003ee\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e is not a section, but an application of prefix negation.\n However, \u003ccode\u003e(\u003ccode\u003e\u003ca\u003esubtract\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e is equivalent to the disallowed section.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "subtract",
          "package": "base",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/GHC-Num.html#subtract",
          "type": "function"
        },
        "index": {
          "description": "the same as flip Because is treated specially in the Haskell grammar is not section but an application of prefix negation However subtract exp is equivalent to the disallowed section",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "subtract",
          "normalized": "a-\u003ea-\u003ea",
          "package": "base",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:subtract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe successor of a value.  For numeric types, \u003ccode\u003e\u003ca\u003esucc\u003c/a\u003e\u003c/code\u003e adds 1.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "succ",
          "package": "base",
          "signature": "a -\u003e a",
          "source": "src/GHC-Enum.html#succ",
          "type": "method"
        },
        "index": {
          "description": "the successor of value For numeric types succ adds",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "succ",
          "normalized": "a-\u003ea",
          "package": "base",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:succ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "toEnum",
          "package": "base",
          "signature": "Int -\u003e a",
          "source": "src/GHC-Enum.html#toEnum",
          "type": "method"
        },
        "index": {
          "description": "Convert from an Int",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "toEnum",
          "normalized": "Int-\u003ea",
          "package": "base",
          "partial": "Enum",
          "signature": "Int-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:toEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econversion to \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "toInteger",
          "package": "base",
          "signature": "a -\u003e Integer",
          "source": "src/GHC-Real.html#toInteger",
          "type": "method"
        },
        "index": {
          "description": "conversion to Integer",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "toInteger",
          "normalized": "a-\u003eInteger",
          "package": "base",
          "partial": "Integer",
          "signature": "a-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:toInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe rational equivalent of its real argument with full precision\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "toRational",
          "package": "base",
          "signature": "a -\u003e Rational",
          "source": "src/GHC-Real.html#toRational",
          "type": "method"
        },
        "index": {
          "description": "the rational equivalent of its real argument with full precision",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "toRational",
          "normalized": "a-\u003eRational",
          "package": "base",
          "partial": "Rational",
          "signature": "a-\u003eRational",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:toRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003etruncate\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e returns the integer nearest \u003ccode\u003ex\u003c/code\u003e between zero and \u003ccode\u003ex\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "truncate",
          "package": "base",
          "signature": "a -\u003e b",
          "source": "src/GHC-Real.html#truncate",
          "type": "method"
        },
        "index": {
          "description": "truncate returns the integer nearest between zero and",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "truncate",
          "normalized": "a-\u003eb",
          "package": "base",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:truncate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA special case of \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n It is expected that compilers will recognize this and insert error\n messages which are more appropriate to the context in which \u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e\n appears. \n\u003c/p\u003e",
          "module": "Prelude",
          "name": "undefined",
          "package": "base",
          "signature": "a",
          "source": "src/GHC-Err.html#undefined",
          "type": "function"
        },
        "index": {
          "description": "special case of error It is expected that compilers will recognize this and insert error messages which are more appropriate to the context in which undefined appears",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "undefined",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:undefined"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003euntil\u003c/a\u003e\u003c/code\u003e p f\u003c/code\u003e yields the result of applying \u003ccode\u003ef\u003c/code\u003e until \u003ccode\u003ep\u003c/code\u003e holds.\n\u003c/p\u003e",
          "module": "Prelude",
          "name": "until",
          "package": "base",
          "signature": "(a -\u003e Bool) -\u003e (a -\u003e a) -\u003e a -\u003e a",
          "source": "src/GHC-Base.html#until",
          "type": "function"
        },
        "index": {
          "description": "until yields the result of applying until holds",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "until",
          "normalized": "(a-\u003eBool)-\u003e(a-\u003ea)-\u003ea-\u003ea",
          "package": "base",
          "signature": "(a-\u003eBool)-\u003e(a-\u003ea)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:until"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e value with a string describing the error.\n The \u003ccode\u003e\u003ca\u003efail\u003c/a\u003e\u003c/code\u003e method of the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e instance of the \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e class raises a\n \u003ccode\u003e\u003ca\u003euserError\u003c/a\u003e\u003c/code\u003e, thus:\n\u003c/p\u003e\u003cpre\u003e instance Monad IO where \n   ...\n   fail s = ioError (userError s)\n\u003c/pre\u003e",
          "module": "[\"Prelude\",\"System.IO.Error\"]",
          "name": "userError",
          "package": "base",
          "signature": "String -\u003e IOError",
          "source": "src/GHC-IO-Exception.html#userError",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:userError\",\"http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:userError\"]"
        },
        "index": {
          "description": "Construct an IOError value with string describing the error The fail method of the IO instance of the Monad class raises userError thus instance Monad IO where fail ioError userError",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "userError",
          "normalized": "String-\u003eIOError",
          "package": "base",
          "partial": "Error",
          "signature": "String-\u003eIOError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:userError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe computation \u003ccode\u003e\u003ca\u003ewriteFile\u003c/a\u003e\u003c/code\u003e \u003ccode\u003efile str\u003c/code\u003e function writes the string \u003ccode\u003estr\u003c/code\u003e,\n to the file \u003ccode\u003efile\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Prelude\",\"System.IO\"]",
          "name": "writeFile",
          "package": "base",
          "signature": "FilePath -\u003e String -\u003e IO ()",
          "source": "src/System-IO.html#writeFile",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Prelude.html#v:writeFile\",\"http://hackage.haskell.org/package/base/docs/System-IO.html#v:writeFile\"]"
        },
        "index": {
          "description": "The computation writeFile file str function writes the string str to the file file",
          "hierarchy": "Prelude",
          "module": "Prelude",
          "name": "writeFile",
          "normalized": "FilePath-\u003eString-\u003eIO()",
          "package": "base",
          "partial": "File",
          "signature": "FilePath-\u003eString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Prelude.html#v:writeFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe standard CPUTime library.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.CPUTime",
          "name": "CPUTime",
          "package": "base",
          "source": "src/System-CPUTime.html",
          "type": "module"
        },
        "index": {
          "description": "The standard CPUTime library",
          "hierarchy": "System CPUTime",
          "module": "System.CPUTime",
          "name": "CPUTime",
          "package": "base",
          "partial": "CPUTime",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-CPUTime.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ecpuTimePrecision\u003c/a\u003e\u003c/code\u003e constant is the smallest measurable difference\n in CPU time that the implementation can record, and is given as an\n integral number of picoseconds.\n\u003c/p\u003e",
          "module": "System.CPUTime",
          "name": "cpuTimePrecision",
          "package": "base",
          "signature": "Integer",
          "source": "src/System-CPUTime.html#cpuTimePrecision",
          "type": "function"
        },
        "index": {
          "description": "The cpuTimePrecision constant is the smallest measurable difference in CPU time that the implementation can record and is given as an integral number of picoseconds",
          "hierarchy": "System CPUTime",
          "module": "System.CPUTime",
          "name": "cpuTimePrecision",
          "package": "base",
          "partial": "Time Precision",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-CPUTime.html#v:cpuTimePrecision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003egetCPUTime\u003c/a\u003e\u003c/code\u003e returns the number of picoseconds CPU time\n used by the current program.  The precision of this result is\n implementation-dependent.\n\u003c/p\u003e",
          "module": "System.CPUTime",
          "name": "getCPUTime",
          "package": "base",
          "signature": "IO Integer",
          "source": "src/System-CPUTime.html#getCPUTime",
          "type": "function"
        },
        "index": {
          "description": "Computation getCPUTime returns the number of picoseconds CPU time used by the current program The precision of this result is implementation-dependent",
          "hierarchy": "System CPUTime",
          "module": "System.CPUTime",
          "name": "getCPUTime",
          "package": "base",
          "partial": "CPUTime",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-CPUTime.html#v:getCPUTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis library provides facilities for parsing the command-line options\n in a standalone program.  It is essentially a Haskell port of the GNU \n \u003ccode\u003egetopt\u003c/code\u003e library.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.Console.GetOpt",
          "name": "GetOpt",
          "package": "base",
          "source": "src/System-Console-GetOpt.html",
          "type": "module"
        },
        "index": {
          "description": "This library provides facilities for parsing the command-line options in standalone program It is essentially Haskell port of the GNU getopt library",
          "hierarchy": "System Console GetOpt",
          "module": "System.Console.GetOpt",
          "name": "GetOpt",
          "package": "base",
          "partial": "Get Opt",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes whether an option takes an argument or not, and if so\n how the argument is injected into a value of type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "System.Console.GetOpt",
          "name": "ArgDescr",
          "package": "base",
          "source": "src/System-Console-GetOpt.html#ArgDescr",
          "type": "data"
        },
        "index": {
          "description": "Describes whether an option takes an argument or not and if so how the argument is injected into value of type",
          "hierarchy": "System Console GetOpt",
          "module": "System.Console.GetOpt",
          "name": "ArgDescr",
          "package": "base",
          "partial": "Arg Descr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html#t:ArgDescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhat to do with options following non-options\n\u003c/p\u003e",
          "module": "System.Console.GetOpt",
          "name": "ArgOrder",
          "package": "base",
          "source": "src/System-Console-GetOpt.html#ArgOrder",
          "type": "data"
        },
        "index": {
          "description": "What to do with options following non-options",
          "hierarchy": "System Console GetOpt",
          "module": "System.Console.GetOpt",
          "name": "ArgOrder",
          "package": "base",
          "partial": "Arg Order",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html#t:ArgOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEach \u003ccode\u003e\u003ca\u003eOptDescr\u003c/a\u003e\u003c/code\u003e describes a single option.\n\u003c/p\u003e\u003cp\u003eThe arguments to \u003ccode\u003e\u003ca\u003eOption\u003c/a\u003e\u003c/code\u003e are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e list of short option characters\n\u003c/li\u003e\u003cli\u003e list of long option strings (without \"--\")\n\u003c/li\u003e\u003cli\u003e argument descriptor\n\u003c/li\u003e\u003cli\u003e explanation of option for user\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "System.Console.GetOpt",
          "name": "OptDescr",
          "package": "base",
          "source": "src/System-Console-GetOpt.html#OptDescr",
          "type": "data"
        },
        "index": {
          "description": "Each OptDescr describes single option The arguments to Option are list of short option characters list of long option strings without argument descriptor explanation of option for user",
          "hierarchy": "System Console GetOpt",
          "module": "System.Console.GetOpt",
          "name": "OptDescr",
          "package": "base",
          "partial": "Opt Descr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html#t:OptDescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eno argument expected\n\u003c/p\u003e",
          "module": "System.Console.GetOpt",
          "name": "NoArg",
          "package": "base",
          "signature": "NoArg a",
          "source": "src/System-Console-GetOpt.html#ArgDescr",
          "type": "function"
        },
        "index": {
          "description": "no argument expected",
          "hierarchy": "System Console GetOpt",
          "module": "System.Console.GetOpt",
          "name": "NoArg",
          "package": "base",
          "partial": "No Arg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html#v:NoArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoptional argument\n\u003c/p\u003e",
          "module": "System.Console.GetOpt",
          "name": "OptArg",
          "package": "base",
          "signature": "OptArg (Maybe String -\u003e a) String",
          "source": "src/System-Console-GetOpt.html#ArgDescr",
          "type": "function"
        },
        "index": {
          "description": "optional argument",
          "hierarchy": "System Console GetOpt",
          "module": "System.Console.GetOpt",
          "name": "OptArg",
          "normalized": "OptArg(Maybe String-\u003ea)String",
          "package": "base",
          "partial": "Opt Arg",
          "signature": "OptArg(Maybe String-\u003ea)String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html#v:OptArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Console.GetOpt",
          "name": "Option",
          "package": "base",
          "signature": "Option [Char] [String] (ArgDescr a) String",
          "source": "src/System-Console-GetOpt.html#OptDescr",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Console GetOpt",
          "module": "System.Console.GetOpt",
          "name": "Option",
          "normalized": "Option[Char][String](ArgDescr a)String",
          "package": "base",
          "partial": "Option",
          "signature": "Option[Char][String](ArgDescr a)String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html#v:Option"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efreely intersperse options and non-options\n\u003c/p\u003e",
          "module": "System.Console.GetOpt",
          "name": "Permute",
          "package": "base",
          "signature": "Permute",
          "source": "src/System-Console-GetOpt.html#ArgOrder",
          "type": "function"
        },
        "index": {
          "description": "freely intersperse options and non-options",
          "hierarchy": "System Console GetOpt",
          "module": "System.Console.GetOpt",
          "name": "Permute",
          "package": "base",
          "partial": "Permute",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html#v:Permute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoption requires argument\n\u003c/p\u003e",
          "module": "System.Console.GetOpt",
          "name": "ReqArg",
          "package": "base",
          "signature": "ReqArg (String -\u003e a) String",
          "source": "src/System-Console-GetOpt.html#ArgDescr",
          "type": "function"
        },
        "index": {
          "description": "option requires argument",
          "hierarchy": "System Console GetOpt",
          "module": "System.Console.GetOpt",
          "name": "ReqArg",
          "normalized": "ReqArg(String-\u003ea)String",
          "package": "base",
          "partial": "Req Arg",
          "signature": "ReqArg(String-\u003ea)String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html#v:ReqArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eno option processing after first non-option\n\u003c/p\u003e",
          "module": "System.Console.GetOpt",
          "name": "RequireOrder",
          "package": "base",
          "signature": "RequireOrder",
          "source": "src/System-Console-GetOpt.html#ArgOrder",
          "type": "function"
        },
        "index": {
          "description": "no option processing after first non-option",
          "hierarchy": "System Console GetOpt",
          "module": "System.Console.GetOpt",
          "name": "RequireOrder",
          "package": "base",
          "partial": "Require Order",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html#v:RequireOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewrap non-options into options\n\u003c/p\u003e",
          "module": "System.Console.GetOpt",
          "name": "ReturnInOrder",
          "package": "base",
          "signature": "ReturnInOrder (String -\u003e a)",
          "source": "src/System-Console-GetOpt.html#ArgOrder",
          "type": "function"
        },
        "index": {
          "description": "wrap non-options into options",
          "hierarchy": "System Console GetOpt",
          "module": "System.Console.GetOpt",
          "name": "ReturnInOrder",
          "normalized": "ReturnInOrder(String-\u003ea)",
          "package": "base",
          "partial": "Return In Order",
          "signature": "ReturnInOrder(String-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html#v:ReturnInOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProcess the command-line, and return the list of values that matched\n(and those that didn't). The arguments are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The order requirements (see \u003ccode\u003e\u003ca\u003eArgOrder\u003c/a\u003e\u003c/code\u003e)\n\u003c/li\u003e\u003cli\u003e The option descriptions (see \u003ccode\u003e\u003ca\u003eOptDescr\u003c/a\u003e\u003c/code\u003e)\n\u003c/li\u003e\u003cli\u003e The actual command line arguments (presumably got from \n  \u003ccode\u003e\u003ca\u003egetArgs\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003egetOpt\u003c/a\u003e\u003c/code\u003e returns a triple consisting of the option arguments, a list\nof non-options, and a list of error messages.\n\u003c/p\u003e",
          "module": "System.Console.GetOpt",
          "name": "getOpt",
          "package": "base",
          "signature": "ArgOrder a -\u003e [OptDescr a] -\u003e [String] -\u003e ([a], [String], [String])",
          "source": "src/System-Console-GetOpt.html#getOpt",
          "type": "function"
        },
        "index": {
          "description": "Process the command-line and return the list of values that matched and those that didn The arguments are The order requirements see ArgOrder The option descriptions see OptDescr The actual command line arguments presumably got from getArgs getOpt returns triple consisting of the option arguments list of non-options and list of error messages",
          "hierarchy": "System Console GetOpt",
          "module": "System.Console.GetOpt",
          "name": "getOpt",
          "normalized": "ArgOrder a-\u003e[OptDescr a]-\u003e[String]-\u003e([a],[String],[String])",
          "package": "base",
          "partial": "Opt",
          "signature": "ArgOrder a-\u003e[OptDescr a]-\u003e[String]-\u003e([a],[String],[String])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html#v:getOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is almost the same as \u003ccode\u003e\u003ca\u003egetOpt\u003c/a\u003e\u003c/code\u003e, but returns a quadruple\nconsisting of the option arguments, a list of non-options, a list of\nunrecognized options, and a list of error messages.\n\u003c/p\u003e",
          "module": "System.Console.GetOpt",
          "name": "getOpt'",
          "package": "base",
          "signature": "ArgOrder a -\u003e [OptDescr a] -\u003e [String] -\u003e ([a], [String], [String], [String])",
          "source": "src/System-Console-GetOpt.html#getOpt%27",
          "type": "function"
        },
        "index": {
          "description": "This is almost the same as getOpt but returns quadruple consisting of the option arguments list of non-options list of unrecognized options and list of error messages",
          "hierarchy": "System Console GetOpt",
          "module": "System.Console.GetOpt",
          "name": "getOpt'",
          "normalized": "ArgOrder a-\u003e[OptDescr a]-\u003e[String]-\u003e([a],[String],[String],[String])",
          "package": "base",
          "partial": "Opt'",
          "signature": "ArgOrder a-\u003e[OptDescr a]-\u003e[String]-\u003e([a],[String],[String],[String])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html#v:getOpt-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a string describing the usage of a command, derived from\n the header (first argument) and the options described by the \n second argument.\n\u003c/p\u003e",
          "module": "System.Console.GetOpt",
          "name": "usageInfo",
          "package": "base",
          "signature": "String -\u003e [OptDescr a] -\u003e String",
          "source": "src/System-Console-GetOpt.html#usageInfo",
          "type": "function"
        },
        "index": {
          "description": "Return string describing the usage of command derived from the header first argument and the options described by the second argument",
          "hierarchy": "System Console GetOpt",
          "module": "System.Console.GetOpt",
          "name": "usageInfo",
          "normalized": "String-\u003e[OptDescr a]-\u003eString",
          "package": "base",
          "partial": "Info",
          "signature": "String-\u003e[OptDescr a]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html#v:usageInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMiscellaneous information about the system environment.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.Environment",
          "name": "Environment",
          "package": "base",
          "source": "src/System-Environment.html",
          "type": "module"
        },
        "index": {
          "description": "Miscellaneous information about the system environment",
          "hierarchy": "System Environment",
          "module": "System.Environment",
          "name": "Environment",
          "package": "base",
          "partial": "Environment",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Environment.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003egetArgs\u003c/a\u003e\u003c/code\u003e returns a list of the program's command\n line arguments (not including the program name).\n\u003c/p\u003e",
          "module": "System.Environment",
          "name": "getArgs",
          "package": "base",
          "signature": "IO [String]",
          "source": "src/System-Environment.html#getArgs",
          "type": "function"
        },
        "index": {
          "description": "Computation getArgs returns list of the program command line arguments not including the program name",
          "hierarchy": "System Environment",
          "module": "System.Environment",
          "name": "getArgs",
          "normalized": "IO[String]",
          "package": "base",
          "partial": "Args",
          "signature": "IO[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Environment.html#v:getArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003egetEnv\u003c/a\u003e\u003c/code\u003e \u003ccode\u003evar\u003c/code\u003e returns the value\n of the environment variable \u003ccode\u003evar\u003c/code\u003e. For the inverse, POSIX users\n can use \u003ccode\u003e\u003ca\u003eputEnv\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis computation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisDoesNotExistError\u003c/a\u003e\u003c/code\u003e if the environment variable\n    does not exist.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "System.Environment",
          "name": "getEnv",
          "package": "base",
          "signature": "String -\u003e IO String",
          "source": "src/System-Environment.html#getEnv",
          "type": "function"
        },
        "index": {
          "description": "Computation getEnv var returns the value of the environment variable var For the inverse POSIX users can use putEnv This computation may fail with isDoesNotExistError if the environment variable does not exist",
          "hierarchy": "System Environment",
          "module": "System.Environment",
          "name": "getEnv",
          "normalized": "String-\u003eIO String",
          "package": "base",
          "partial": "Env",
          "signature": "String-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Environment.html#v:getEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003egetEnvironment\u003c/a\u003e\u003c/code\u003e retrieves the entire environment as a\n list of \u003ccode\u003e(key,value)\u003c/code\u003e pairs.\n\u003c/p\u003e\u003cp\u003eIf an environment entry does not contain an \u003ccode\u003e'='\u003c/code\u003e character,\n the \u003ccode\u003ekey\u003c/code\u003e is the whole entry and the \u003ccode\u003evalue\u003c/code\u003e is the empty string.\n\u003c/p\u003e",
          "module": "System.Environment",
          "name": "getEnvironment",
          "package": "base",
          "signature": "IO [(String, String)]",
          "source": "src/System-Environment.html#getEnvironment",
          "type": "function"
        },
        "index": {
          "description": "getEnvironment retrieves the entire environment as list of key value pairs If an environment entry does not contain an character the key is the whole entry and the value is the empty string",
          "hierarchy": "System Environment",
          "module": "System.Environment",
          "name": "getEnvironment",
          "normalized": "IO[(String,String)]",
          "package": "base",
          "partial": "Environment",
          "signature": "IO[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Environment.html#v:getEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the absolute pathname of the current executable.\n\u003c/p\u003e\u003cp\u003eNote that for scripts and interactive sessions, this is the path to\n the interpreter (e.g. ghci.)\n\u003c/p\u003e",
          "module": "System.Environment",
          "name": "getExecutablePath",
          "package": "base",
          "signature": "IO FilePath",
          "source": "src/System-Environment-ExecutablePath.html#getExecutablePath",
          "type": "function"
        },
        "index": {
          "description": "Returns the absolute pathname of the current executable Note that for scripts and interactive sessions this is the path to the interpreter e.g ghci",
          "hierarchy": "System Environment",
          "module": "System.Environment",
          "name": "getExecutablePath",
          "package": "base",
          "partial": "Executable Path",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Environment.html#v:getExecutablePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003egetProgName\u003c/a\u003e\u003c/code\u003e returns the name of the program as it was\ninvoked.\n\u003c/p\u003e\u003cp\u003eHowever, this is hard-to-impossible to implement on some non-Unix\nOSes, so instead, for maximum portability, we just return the leafname\nof the program as invoked. Even then there are some differences\nbetween platforms: on Windows, for example, a program invoked as foo\nis probably really \u003ccode\u003eFOO.EXE\u003c/code\u003e, and that is what \u003ccode\u003e\u003ca\u003egetProgName\u003c/a\u003e\u003c/code\u003e will return.\n\u003c/p\u003e",
          "module": "System.Environment",
          "name": "getProgName",
          "package": "base",
          "signature": "IO String",
          "source": "src/System-Environment.html#getProgName",
          "type": "function"
        },
        "index": {
          "description": "Computation getProgName returns the name of the program as it was invoked However this is hard-to-impossible to implement on some non-Unix OSes so instead for maximum portability we just return the leafname of the program as invoked Even then there are some differences between platforms on Windows for example program invoked as foo is probably really FOO.EXE and that is what getProgName will return",
          "hierarchy": "System Environment",
          "module": "System.Environment",
          "name": "getProgName",
          "package": "base",
          "partial": "Prog Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Environment.html#v:getProgName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the value of the environment variable \u003ccode\u003evar\u003c/code\u003e, or \u003ccode\u003eNothing\u003c/code\u003e if\n there is no such value.\n\u003c/p\u003e\u003cp\u003eFor POSIX users, this is equivalent to \u003ccode\u003e\u003ca\u003egetEnv\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "System.Environment",
          "name": "lookupEnv",
          "package": "base",
          "signature": "String -\u003e IO (Maybe String)",
          "source": "src/System-Environment.html#lookupEnv",
          "type": "function"
        },
        "index": {
          "description": "Return the value of the environment variable var or Nothing if there is no such value For POSIX users this is equivalent to getEnv",
          "hierarchy": "System Environment",
          "module": "System.Environment",
          "name": "lookupEnv",
          "normalized": "String-\u003eIO(Maybe String)",
          "package": "base",
          "partial": "Env",
          "signature": "String-\u003eIO(Maybe String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Environment.html#v:lookupEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ewithArgs\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eargs act\u003c/code\u003e - while executing action \u003ccode\u003eact\u003c/code\u003e, have \u003ccode\u003e\u003ca\u003egetArgs\u003c/a\u003e\u003c/code\u003e\nreturn \u003ccode\u003eargs\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "System.Environment",
          "name": "withArgs",
          "package": "base",
          "signature": "[String] -\u003e IO a -\u003e IO a",
          "source": "src/System-Environment.html#withArgs",
          "type": "function"
        },
        "index": {
          "description": "withArgs args act while executing action act have getArgs return args",
          "hierarchy": "System Environment",
          "module": "System.Environment",
          "name": "withArgs",
          "normalized": "[String]-\u003eIO a-\u003eIO a",
          "package": "base",
          "partial": "Args",
          "signature": "[String]-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Environment.html#v:withArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ewithProgName\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ename act\u003c/code\u003e - while executing action \u003ccode\u003eact\u003c/code\u003e,\nhave \u003ccode\u003e\u003ca\u003egetProgName\u003c/a\u003e\u003c/code\u003e return \u003ccode\u003ename\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "System.Environment",
          "name": "withProgName",
          "package": "base",
          "signature": "String -\u003e IO a -\u003e IO a",
          "source": "src/System-Environment.html#withProgName",
          "type": "function"
        },
        "index": {
          "description": "withProgName name act while executing action act have getProgName return name",
          "hierarchy": "System Environment",
          "module": "System.Environment",
          "name": "withProgName",
          "normalized": "String-\u003eIO a-\u003eIO a",
          "package": "base",
          "partial": "Prog Name",
          "signature": "String-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Environment.html#v:withProgName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExiting the program.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.Exit",
          "name": "Exit",
          "package": "base",
          "source": "src/System-Exit.html",
          "type": "module"
        },
        "index": {
          "description": "Exiting the program",
          "hierarchy": "System Exit",
          "module": "System.Exit",
          "name": "Exit",
          "package": "base",
          "partial": "Exit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Exit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefines the exit codes that a program can return.\n\u003c/p\u003e",
          "module": "System.Exit",
          "name": "ExitCode",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#ExitCode",
          "type": "data"
        },
        "index": {
          "description": "Defines the exit codes that program can return",
          "hierarchy": "System Exit",
          "module": "System.Exit",
          "name": "ExitCode",
          "package": "base",
          "partial": "Exit Code",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Exit.html#t:ExitCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindicates program failure with an exit code.\n The exact interpretation of the code is\n operating-system dependent.  In particular, some values\n may be prohibited (e.g. 0 on a POSIX-compliant system).\n\u003c/p\u003e",
          "module": "System.Exit",
          "name": "ExitFailure",
          "package": "base",
          "signature": "ExitFailure Int",
          "source": "src/GHC-IO-Exception.html#ExitCode",
          "type": "function"
        },
        "index": {
          "description": "indicates program failure with an exit code The exact interpretation of the code is operating-system dependent In particular some values may be prohibited e.g on POSIX-compliant system",
          "hierarchy": "System Exit",
          "module": "System.Exit",
          "name": "ExitFailure",
          "package": "base",
          "partial": "Exit Failure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Exit.html#v:ExitFailure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindicates successful termination;\n\u003c/p\u003e",
          "module": "System.Exit",
          "name": "ExitSuccess",
          "package": "base",
          "signature": "ExitSuccess",
          "source": "src/GHC-IO-Exception.html#ExitCode",
          "type": "function"
        },
        "index": {
          "description": "indicates successful termination",
          "hierarchy": "System Exit",
          "module": "System.Exit",
          "name": "ExitSuccess",
          "package": "base",
          "partial": "Exit Success",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Exit.html#v:ExitSuccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe computation \u003ccode\u003e\u003ca\u003eexitFailure\u003c/a\u003e\u003c/code\u003e is equivalent to\n \u003ccode\u003e\u003ca\u003eexitWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e(\u003c/code\u003e\u003ccode\u003e\u003ca\u003eExitFailure\u003c/a\u003e\u003c/code\u003e \u003cem\u003eexitfail\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e,\n where \u003cem\u003eexitfail\u003c/em\u003e is implementation-dependent.\n\u003c/p\u003e",
          "module": "System.Exit",
          "name": "exitFailure",
          "package": "base",
          "signature": "IO a",
          "source": "src/System-Exit.html#exitFailure",
          "type": "function"
        },
        "index": {
          "description": "The computation exitFailure is equivalent to exitWith ExitFailure exitfail where exitfail is implementation-dependent",
          "hierarchy": "System Exit",
          "module": "System.Exit",
          "name": "exitFailure",
          "package": "base",
          "partial": "Failure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Exit.html#v:exitFailure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe computation \u003ccode\u003e\u003ca\u003eexitSuccess\u003c/a\u003e\u003c/code\u003e is equivalent to\n \u003ccode\u003e\u003ca\u003eexitWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eExitSuccess\u003c/a\u003e\u003c/code\u003e, It terminates the program\n successfully.\n\u003c/p\u003e",
          "module": "System.Exit",
          "name": "exitSuccess",
          "package": "base",
          "signature": "IO a",
          "source": "src/System-Exit.html#exitSuccess",
          "type": "function"
        },
        "index": {
          "description": "The computation exitSuccess is equivalent to exitWith ExitSuccess It terminates the program successfully",
          "hierarchy": "System Exit",
          "module": "System.Exit",
          "name": "exitSuccess",
          "package": "base",
          "partial": "Success",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Exit.html#v:exitSuccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003eexitWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ecode\u003c/code\u003e throws \u003ccode\u003e\u003ca\u003eExitCode\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ecode\u003c/code\u003e.\n Normally this terminates the program, returning \u003ccode\u003ecode\u003c/code\u003e to the\n program's caller.\n\u003c/p\u003e\u003cp\u003eOn program termination, the standard \u003ccode\u003eHandle\u003c/code\u003es \u003ccode\u003estdout\u003c/code\u003e and\n \u003ccode\u003estderr\u003c/code\u003e are flushed automatically; any other buffered \u003ccode\u003eHandle\u003c/code\u003es\n need to be flushed manually, otherwise the buffered data will be\n discarded.\n\u003c/p\u003e\u003cp\u003eA program that fails in any other way is treated as if it had\n called \u003ccode\u003e\u003ca\u003eexitFailure\u003c/a\u003e\u003c/code\u003e.\n A program that terminates successfully without calling \u003ccode\u003e\u003ca\u003eexitWith\u003c/a\u003e\u003c/code\u003e\n explicitly is treated as it it had called \u003ccode\u003e\u003ca\u003eexitWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eExitSuccess\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eAs an \u003ccode\u003e\u003ca\u003eExitCode\u003c/a\u003e\u003c/code\u003e is not an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eexitWith\u003c/a\u003e\u003c/code\u003e bypasses\n the error handling in the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad and cannot be intercepted by\n \u003ccode\u003ecatch\u003c/code\u003e from the \u003ca\u003ePrelude\u003c/a\u003e.  However it is a \u003ccode\u003eSomeException\u003c/code\u003e, and can\n be caught using the functions of \u003ca\u003eControl.Exception\u003c/a\u003e.  This means\n that cleanup computations added with \u003ccode\u003e\u003ca\u003ebracket\u003c/a\u003e\u003c/code\u003e\n (from \u003ca\u003eControl.Exception\u003c/a\u003e) are also executed properly on \u003ccode\u003e\u003ca\u003eexitWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote: in GHC, \u003ccode\u003e\u003ca\u003eexitWith\u003c/a\u003e\u003c/code\u003e should be called from the main program\n thread in order to exit the process.  When called from another\n thread, \u003ccode\u003e\u003ca\u003eexitWith\u003c/a\u003e\u003c/code\u003e will throw an \u003ccode\u003eExitException\u003c/code\u003e as normal, but the\n exception will not cause the process itself to exit.\n\u003c/p\u003e",
          "module": "System.Exit",
          "name": "exitWith",
          "package": "base",
          "signature": "ExitCode -\u003e IO a",
          "source": "src/System-Exit.html#exitWith",
          "type": "function"
        },
        "index": {
          "description": "Computation exitWith code throws ExitCode code Normally this terminates the program returning code to the program caller On program termination the standard Handle stdout and stderr are flushed automatically any other buffered Handle need to be flushed manually otherwise the buffered data will be discarded program that fails in any other way is treated as if it had called exitFailure program that terminates successfully without calling exitWith explicitly is treated as it it had called exitWith ExitSuccess As an ExitCode is not an IOError exitWith bypasses the error handling in the IO monad and cannot be intercepted by catch from the Prelude However it is SomeException and can be caught using the functions of Control.Exception This means that cleanup computations added with bracket from Control.Exception are also executed properly on exitWith Note in GHC exitWith should be called from the main program thread in order to exit the process When called from another thread exitWith will throw an ExitException as normal but the exception will not cause the process itself to exit",
          "hierarchy": "System Exit",
          "module": "System.Exit",
          "name": "exitWith",
          "normalized": "ExitCode-\u003eIO a",
          "package": "base",
          "partial": "With",
          "signature": "ExitCode-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Exit.html#v:exitWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eStandard IO Errors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.IO.Error",
          "name": "Error",
          "package": "base",
          "source": "src/System-IO-Error.html",
          "type": "module"
        },
        "index": {
          "description": "Standard IO Errors",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "Error",
          "package": "base",
          "partial": "Error",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Haskell 98 type for exceptions in the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad.\n Any I/O operation may raise an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e instead of returning a result.\n For a more general type of exception, including also those that arise\n in pure code, see \u003ca\u003eControl.Exception.Exception\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eIn Haskell 98, this is an opaque type.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "IOError",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#IOError",
          "type": "type"
        },
        "index": {
          "description": "The Haskell type for exceptions in the IO monad Any operation may raise an IOError instead of returning result For more general type of exception including also those that arise in pure code see Control.Exception.Exception In Haskell this is an opaque type",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "IOError",
          "package": "base",
          "partial": "IOError",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#t:IOError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abstract type that contains a value for each variant of \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "IOErrorType",
          "package": "base",
          "source": "src/GHC-IO-Exception.html#IOErrorType",
          "type": "data"
        },
        "index": {
          "description": "An abstract type that contains value for each variant of IOError",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "IOErrorType",
          "package": "base",
          "partial": "IOError Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#t:IOErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error where the operation failed because one of its arguments\n already exists.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "alreadyExistsErrorType",
          "package": "base",
          "signature": "IOErrorType",
          "source": "src/System-IO-Error.html#alreadyExistsErrorType",
          "type": "function"
        },
        "index": {
          "description": "error where the operation failed because one of its arguments already exists",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "alreadyExistsErrorType",
          "package": "base",
          "partial": "Exists Error Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:alreadyExistsErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error where the operation failed because one of its arguments\n is a single-use resource, which is already being used.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "alreadyInUseErrorType",
          "package": "base",
          "signature": "IOErrorType",
          "source": "src/System-IO-Error.html#alreadyInUseErrorType",
          "type": "function"
        },
        "index": {
          "description": "error where the operation failed because one of its arguments is single-use resource which is already being used",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "alreadyInUseErrorType",
          "package": "base",
          "partial": "In Use Error Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:alreadyInUseErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdds a location description and maybe a file path and file handle\n to an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e.  If any of the file handle or file path is not given\n the corresponding value in the \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e remains unaltered.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "annotateIOError",
          "package": "base",
          "signature": "IOError -\u003e String -\u003e Maybe Handle -\u003e Maybe FilePath -\u003e IOError",
          "source": "src/System-IO-Error.html#annotateIOError",
          "type": "function"
        },
        "index": {
          "description": "Adds location description and maybe file path and file handle to an IOError If any of the file handle or file path is not given the corresponding value in the IOError remains unaltered",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "annotateIOError",
          "normalized": "IOError-\u003eString-\u003eMaybe Handle-\u003eMaybe FilePath-\u003eIOError",
          "package": "base",
          "partial": "IOError",
          "signature": "IOError-\u003eString-\u003eMaybe Handle-\u003eMaybe FilePath-\u003eIOError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:annotateIOError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ecatchIOError\u003c/a\u003e\u003c/code\u003e function establishes a handler that receives any\n \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e raised in the action protected by \u003ccode\u003e\u003ca\u003ecatchIOError\u003c/a\u003e\u003c/code\u003e.\n An \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e is caught by\n the most recent handler established by one of the exception handling\n functions.  These handlers are\n not selective: all \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003es are caught.  Exception propagation\n must be explicitly provided in a handler by re-raising any unwanted\n exceptions.  For example, in\n\u003c/p\u003e\u003cpre\u003e f = catchIOError g (\\e -\u003e if IO.isEOFError e then return [] else ioError e)\n\u003c/pre\u003e\u003cp\u003ethe function \u003ccode\u003ef\u003c/code\u003e returns \u003ccode\u003e[]\u003c/code\u003e when an end-of-file exception\n (cf. \u003ccode\u003e\u003ca\u003eisEOFError\u003c/a\u003e\u003c/code\u003e) occurs in \u003ccode\u003eg\u003c/code\u003e; otherwise, the\n exception is propagated to the next outer handler.\n\u003c/p\u003e\u003cp\u003eWhen an exception propagates outside the main program, the Haskell\n system prints the associated \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e value and exits the program.\n\u003c/p\u003e\u003cp\u003eNon-I/O exceptions are not caught by this variant; to catch all\n exceptions, use \u003ccode\u003e\u003ca\u003ecatch\u003c/a\u003e\u003c/code\u003e from \u003ca\u003eControl.Exception\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "catchIOError",
          "package": "base",
          "signature": "IO a -\u003e (IOError -\u003e IO a) -\u003e IO a",
          "source": "src/System-IO-Error.html#catchIOError",
          "type": "function"
        },
        "index": {
          "description": "The catchIOError function establishes handler that receives any IOError raised in the action protected by catchIOError An IOError is caught by the most recent handler established by one of the exception handling functions These handlers are not selective all IOError are caught Exception propagation must be explicitly provided in handler by re-raising any unwanted exceptions For example in catchIOError if IO.isEOFError then return else ioError the function returns when an end-of-file exception cf isEOFError occurs in otherwise the exception is propagated to the next outer handler When an exception propagates outside the main program the Haskell system prints the associated IOError value and exits the program Non-I exceptions are not caught by this variant to catch all exceptions use catch from Control.Exception",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "catchIOError",
          "normalized": "IO a-\u003e(IOError-\u003eIO a)-\u003eIO a",
          "package": "base",
          "partial": "IOError",
          "signature": "IO a-\u003e(IOError-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:catchIOError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error where the operation failed because one of its arguments\n does not exist.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "doesNotExistErrorType",
          "package": "base",
          "signature": "IOErrorType",
          "source": "src/System-IO-Error.html#doesNotExistErrorType",
          "type": "function"
        },
        "index": {
          "description": "error where the operation failed because one of its arguments does not exist",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "doesNotExistErrorType",
          "package": "base",
          "partial": "Not Exist Error Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:doesNotExistErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error where the operation failed because the end of file has\n been reached.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "eofErrorType",
          "package": "base",
          "signature": "IOErrorType",
          "source": "src/System-IO-Error.html#eofErrorType",
          "type": "function"
        },
        "index": {
          "description": "error where the operation failed because the end of file has been reached",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "eofErrorType",
          "package": "base",
          "partial": "Error Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:eofErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error where the operation failed because the device is full.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "fullErrorType",
          "package": "base",
          "signature": "IOErrorType",
          "source": "src/System-IO-Error.html#fullErrorType",
          "type": "function"
        },
        "index": {
          "description": "error where the operation failed because the device is full",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "fullErrorType",
          "package": "base",
          "partial": "Error Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:fullErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error where the operation is not possible.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "illegalOperationErrorType",
          "package": "base",
          "signature": "IOErrorType",
          "source": "src/System-IO-Error.html#illegalOperationErrorType",
          "type": "function"
        },
        "index": {
          "description": "error where the operation is not possible",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "illegalOperationErrorType",
          "package": "base",
          "partial": "Operation Error Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:illegalOperationErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error",
          "name": "ioeGetErrorString",
          "package": "base",
          "signature": "IOError -\u003e String",
          "source": "src/System-IO-Error.html#ioeGetErrorString",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "ioeGetErrorString",
          "normalized": "IOError-\u003eString",
          "package": "base",
          "partial": "Get Error String",
          "signature": "IOError-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:ioeGetErrorString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error",
          "name": "ioeGetErrorType",
          "package": "base",
          "signature": "IOError -\u003e IOErrorType",
          "source": "src/System-IO-Error.html#ioeGetErrorType",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "ioeGetErrorType",
          "normalized": "IOError-\u003eIOErrorType",
          "package": "base",
          "partial": "Get Error Type",
          "signature": "IOError-\u003eIOErrorType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:ioeGetErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error",
          "name": "ioeGetFileName",
          "package": "base",
          "signature": "IOError -\u003e Maybe FilePath",
          "source": "src/System-IO-Error.html#ioeGetFileName",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "ioeGetFileName",
          "normalized": "IOError-\u003eMaybe FilePath",
          "package": "base",
          "partial": "Get File Name",
          "signature": "IOError-\u003eMaybe FilePath",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:ioeGetFileName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error",
          "name": "ioeGetHandle",
          "package": "base",
          "signature": "IOError -\u003e Maybe Handle",
          "source": "src/System-IO-Error.html#ioeGetHandle",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "ioeGetHandle",
          "normalized": "IOError-\u003eMaybe Handle",
          "package": "base",
          "partial": "Get Handle",
          "signature": "IOError-\u003eMaybe Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:ioeGetHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error",
          "name": "ioeGetLocation",
          "package": "base",
          "signature": "IOError -\u003e String",
          "source": "src/System-IO-Error.html#ioeGetLocation",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "ioeGetLocation",
          "normalized": "IOError-\u003eString",
          "package": "base",
          "partial": "Get Location",
          "signature": "IOError-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:ioeGetLocation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error",
          "name": "ioeSetErrorString",
          "package": "base",
          "signature": "IOError -\u003e String -\u003e IOError",
          "source": "src/System-IO-Error.html#ioeSetErrorString",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "ioeSetErrorString",
          "normalized": "IOError-\u003eString-\u003eIOError",
          "package": "base",
          "partial": "Set Error String",
          "signature": "IOError-\u003eString-\u003eIOError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:ioeSetErrorString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error",
          "name": "ioeSetErrorType",
          "package": "base",
          "signature": "IOError -\u003e IOErrorType -\u003e IOError",
          "source": "src/System-IO-Error.html#ioeSetErrorType",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "ioeSetErrorType",
          "normalized": "IOError-\u003eIOErrorType-\u003eIOError",
          "package": "base",
          "partial": "Set Error Type",
          "signature": "IOError-\u003eIOErrorType-\u003eIOError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:ioeSetErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error",
          "name": "ioeSetFileName",
          "package": "base",
          "signature": "IOError -\u003e FilePath -\u003e IOError",
          "source": "src/System-IO-Error.html#ioeSetFileName",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "ioeSetFileName",
          "normalized": "IOError-\u003eFilePath-\u003eIOError",
          "package": "base",
          "partial": "Set File Name",
          "signature": "IOError-\u003eFilePath-\u003eIOError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:ioeSetFileName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error",
          "name": "ioeSetHandle",
          "package": "base",
          "signature": "IOError -\u003e Handle -\u003e IOError",
          "source": "src/System-IO-Error.html#ioeSetHandle",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "ioeSetHandle",
          "normalized": "IOError-\u003eHandle-\u003eIOError",
          "package": "base",
          "partial": "Set Handle",
          "signature": "IOError-\u003eHandle-\u003eIOError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:ioeSetHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error",
          "name": "ioeSetLocation",
          "package": "base",
          "signature": "IOError -\u003e String -\u003e IOError",
          "source": "src/System-IO-Error.html#ioeSetLocation",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "ioeSetLocation",
          "normalized": "IOError-\u003eString-\u003eIOError",
          "package": "base",
          "partial": "Set Location",
          "signature": "IOError-\u003eString-\u003eIOError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:ioeSetLocation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn error indicating that an \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e operation failed because\n one of its arguments already exists.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isAlreadyExistsError",
          "package": "base",
          "signature": "IOError -\u003e Bool",
          "source": "src/System-IO-Error.html#isAlreadyExistsError",
          "type": "function"
        },
        "index": {
          "description": "An error indicating that an IO operation failed because one of its arguments already exists",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isAlreadyExistsError",
          "normalized": "IOError-\u003eBool",
          "package": "base",
          "partial": "Already Exists Error",
          "signature": "IOError-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isAlreadyExistsError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error where the operation failed because one of its arguments\n already exists.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isAlreadyExistsErrorType",
          "package": "base",
          "signature": "IOErrorType -\u003e Bool",
          "source": "src/System-IO-Error.html#isAlreadyExistsErrorType",
          "type": "function"
        },
        "index": {
          "description": "error where the operation failed because one of its arguments already exists",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isAlreadyExistsErrorType",
          "normalized": "IOErrorType-\u003eBool",
          "package": "base",
          "partial": "Already Exists Error Type",
          "signature": "IOErrorType-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isAlreadyExistsErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn error indicating that an \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e operation failed because\n one of its arguments is a single-use resource, which is already\n being used (for example, opening the same file twice for writing\n might give this error).\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isAlreadyInUseError",
          "package": "base",
          "signature": "IOError -\u003e Bool",
          "source": "src/System-IO-Error.html#isAlreadyInUseError",
          "type": "function"
        },
        "index": {
          "description": "An error indicating that an IO operation failed because one of its arguments is single-use resource which is already being used for example opening the same file twice for writing might give this error",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isAlreadyInUseError",
          "normalized": "IOError-\u003eBool",
          "package": "base",
          "partial": "Already In Use Error",
          "signature": "IOError-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isAlreadyInUseError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error where the operation failed because one of its arguments\n is a single-use resource, which is already being used.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isAlreadyInUseErrorType",
          "package": "base",
          "signature": "IOErrorType -\u003e Bool",
          "source": "src/System-IO-Error.html#isAlreadyInUseErrorType",
          "type": "function"
        },
        "index": {
          "description": "error where the operation failed because one of its arguments is single-use resource which is already being used",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isAlreadyInUseErrorType",
          "normalized": "IOErrorType-\u003eBool",
          "package": "base",
          "partial": "Already In Use Error Type",
          "signature": "IOErrorType-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isAlreadyInUseErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn error indicating that an \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e operation failed because\n one of its arguments does not exist.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isDoesNotExistError",
          "package": "base",
          "signature": "IOError -\u003e Bool",
          "source": "src/System-IO-Error.html#isDoesNotExistError",
          "type": "function"
        },
        "index": {
          "description": "An error indicating that an IO operation failed because one of its arguments does not exist",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isDoesNotExistError",
          "normalized": "IOError-\u003eBool",
          "package": "base",
          "partial": "Does Not Exist Error",
          "signature": "IOError-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isDoesNotExistError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error where the operation failed because one of its arguments\n does not exist.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isDoesNotExistErrorType",
          "package": "base",
          "signature": "IOErrorType -\u003e Bool",
          "source": "src/System-IO-Error.html#isDoesNotExistErrorType",
          "type": "function"
        },
        "index": {
          "description": "error where the operation failed because one of its arguments does not exist",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isDoesNotExistErrorType",
          "normalized": "IOErrorType-\u003eBool",
          "package": "base",
          "partial": "Does Not Exist Error Type",
          "signature": "IOErrorType-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isDoesNotExistErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn error indicating that an \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e operation failed because\n the end of file has been reached.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isEOFError",
          "package": "base",
          "signature": "IOError -\u003e Bool",
          "source": "src/System-IO-Error.html#isEOFError",
          "type": "function"
        },
        "index": {
          "description": "An error indicating that an IO operation failed because the end of file has been reached",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isEOFError",
          "normalized": "IOError-\u003eBool",
          "package": "base",
          "partial": "EOFError",
          "signature": "IOError-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isEOFError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error where the operation failed because the end of file has\n been reached.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isEOFErrorType",
          "package": "base",
          "signature": "IOErrorType -\u003e Bool",
          "source": "src/System-IO-Error.html#isEOFErrorType",
          "type": "function"
        },
        "index": {
          "description": "error where the operation failed because the end of file has been reached",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isEOFErrorType",
          "normalized": "IOErrorType-\u003eBool",
          "package": "base",
          "partial": "EOFError Type",
          "signature": "IOErrorType-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isEOFErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn error indicating that an \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e operation failed because\n the device is full.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isFullError",
          "package": "base",
          "signature": "IOError -\u003e Bool",
          "source": "src/System-IO-Error.html#isFullError",
          "type": "function"
        },
        "index": {
          "description": "An error indicating that an IO operation failed because the device is full",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isFullError",
          "normalized": "IOError-\u003eBool",
          "package": "base",
          "partial": "Full Error",
          "signature": "IOError-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isFullError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error where the operation failed because the device is full.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isFullErrorType",
          "package": "base",
          "signature": "IOErrorType -\u003e Bool",
          "source": "src/System-IO-Error.html#isFullErrorType",
          "type": "function"
        },
        "index": {
          "description": "error where the operation failed because the device is full",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isFullErrorType",
          "normalized": "IOErrorType-\u003eBool",
          "package": "base",
          "partial": "Full Error Type",
          "signature": "IOErrorType-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isFullErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn error indicating that an \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e operation failed because\n the operation was not possible.\n Any computation which returns an \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e result may fail with\n \u003ccode\u003e\u003ca\u003eisIllegalOperation\u003c/a\u003e\u003c/code\u003e.  In some cases, an implementation will not be\n able to distinguish between the possible error causes.  In this case\n it should fail with \u003ccode\u003e\u003ca\u003eisIllegalOperation\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isIllegalOperation",
          "package": "base",
          "signature": "IOError -\u003e Bool",
          "source": "src/System-IO-Error.html#isIllegalOperation",
          "type": "function"
        },
        "index": {
          "description": "An error indicating that an IO operation failed because the operation was not possible Any computation which returns an IO result may fail with isIllegalOperation In some cases an implementation will not be able to distinguish between the possible error causes In this case it should fail with isIllegalOperation",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isIllegalOperation",
          "normalized": "IOError-\u003eBool",
          "package": "base",
          "partial": "Illegal Operation",
          "signature": "IOError-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isIllegalOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error where the operation is not possible.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isIllegalOperationErrorType",
          "package": "base",
          "signature": "IOErrorType -\u003e Bool",
          "source": "src/System-IO-Error.html#isIllegalOperationErrorType",
          "type": "function"
        },
        "index": {
          "description": "error where the operation is not possible",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isIllegalOperationErrorType",
          "normalized": "IOErrorType-\u003eBool",
          "package": "base",
          "partial": "Illegal Operation Error Type",
          "signature": "IOErrorType-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isIllegalOperationErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn error indicating that an \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e operation failed because\n the user does not have sufficient operating system privilege\n to perform that operation.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isPermissionError",
          "package": "base",
          "signature": "IOError -\u003e Bool",
          "source": "src/System-IO-Error.html#isPermissionError",
          "type": "function"
        },
        "index": {
          "description": "An error indicating that an IO operation failed because the user does not have sufficient operating system privilege to perform that operation",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isPermissionError",
          "normalized": "IOError-\u003eBool",
          "package": "base",
          "partial": "Permission Error",
          "signature": "IOError-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isPermissionError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error where the operation failed because the user does not\n have sufficient operating system privilege to perform that operation.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isPermissionErrorType",
          "package": "base",
          "signature": "IOErrorType -\u003e Bool",
          "source": "src/System-IO-Error.html#isPermissionErrorType",
          "type": "function"
        },
        "index": {
          "description": "error where the operation failed because the user does not have sufficient operating system privilege to perform that operation",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isPermissionErrorType",
          "normalized": "IOErrorType-\u003eBool",
          "package": "base",
          "partial": "Permission Error Type",
          "signature": "IOErrorType-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isPermissionErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA programmer-defined error value constructed using \u003ccode\u003e\u003ca\u003euserError\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isUserError",
          "package": "base",
          "signature": "IOError -\u003e Bool",
          "source": "src/System-IO-Error.html#isUserError",
          "type": "function"
        },
        "index": {
          "description": "programmer-defined error value constructed using userError",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isUserError",
          "normalized": "IOError-\u003eBool",
          "package": "base",
          "partial": "User Error",
          "signature": "IOError-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isUserError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error that is programmer-defined.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "isUserErrorType",
          "package": "base",
          "signature": "IOErrorType -\u003e Bool",
          "source": "src/System-IO-Error.html#isUserErrorType",
          "type": "function"
        },
        "index": {
          "description": "error that is programmer-defined",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "isUserErrorType",
          "normalized": "IOErrorType-\u003eBool",
          "package": "base",
          "partial": "User Error Type",
          "signature": "IOErrorType-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:isUserErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e of the given type where the second argument\n describes the error location and the third and fourth argument\n contain the file handle and file path of the file involved in the\n error if applicable.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "mkIOError",
          "package": "base",
          "signature": "IOErrorType -\u003e String -\u003e Maybe Handle -\u003e Maybe FilePath -\u003e IOError",
          "source": "src/System-IO-Error.html#mkIOError",
          "type": "function"
        },
        "index": {
          "description": "Construct an IOError of the given type where the second argument describes the error location and the third and fourth argument contain the file handle and file path of the file involved in the error if applicable",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "mkIOError",
          "normalized": "IOErrorType-\u003eString-\u003eMaybe Handle-\u003eMaybe FilePath-\u003eIOError",
          "package": "base",
          "partial": "IOError",
          "signature": "IOErrorType-\u003eString-\u003eMaybe Handle-\u003eMaybe FilePath-\u003eIOError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:mkIOError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCatch any \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e that occurs in the computation and throw a\n modified version.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "modifyIOError",
          "package": "base",
          "signature": "(IOError -\u003e IOError) -\u003e IO a -\u003e IO a",
          "source": "src/System-IO-Error.html#modifyIOError",
          "type": "function"
        },
        "index": {
          "description": "Catch any IOError that occurs in the computation and throw modified version",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "modifyIOError",
          "normalized": "(IOError-\u003eIOError)-\u003eIO a-\u003eIO a",
          "package": "base",
          "partial": "IOError",
          "signature": "(IOError-\u003eIOError)-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:modifyIOError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error where the operation failed because the user does not\n have sufficient operating system privilege to perform that operation.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "permissionErrorType",
          "package": "base",
          "signature": "IOErrorType",
          "source": "src/System-IO-Error.html#permissionErrorType",
          "type": "function"
        },
        "index": {
          "description": "error where the operation failed because the user does not have sufficient operating system privilege to perform that operation",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "permissionErrorType",
          "package": "base",
          "partial": "Error Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:permissionErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe construct \u003ccode\u003e\u003ca\u003etryIOError\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ecomp\u003c/code\u003e exposes IO errors which occur within a\n computation, and which are not fully handled.\n\u003c/p\u003e\u003cp\u003eNon-I/O exceptions are not caught by this variant; to catch all\n exceptions, use \u003ccode\u003e\u003ca\u003etry\u003c/a\u003e\u003c/code\u003e from \u003ca\u003eControl.Exception\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "tryIOError",
          "package": "base",
          "signature": "IO a -\u003e IO (Either IOError a)",
          "source": "src/System-IO-Error.html#tryIOError",
          "type": "function"
        },
        "index": {
          "description": "The construct tryIOError comp exposes IO errors which occur within computation and which are not fully handled Non-I exceptions are not caught by this variant to catch all exceptions use try from Control.Exception",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "tryIOError",
          "normalized": "IO a-\u003eIO(Either IOError a)",
          "package": "base",
          "partial": "IOError",
          "signature": "IO a-\u003eIO(Either IOError a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:tryIOError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI/O error that is programmer-defined.\n\u003c/p\u003e",
          "module": "System.IO.Error",
          "name": "userErrorType",
          "package": "base",
          "signature": "IOErrorType",
          "source": "src/System-IO-Error.html#userErrorType",
          "type": "function"
        },
        "index": {
          "description": "error that is programmer-defined",
          "hierarchy": "System IO Error",
          "module": "System.IO.Error",
          "name": "userErrorType",
          "package": "base",
          "partial": "Error Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Error.html#v:userErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\"Unsafe\" IO operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.IO.Unsafe",
          "name": "Unsafe",
          "package": "base",
          "source": "src/System-IO-Unsafe.html",
          "type": "module"
        },
        "index": {
          "description": "Unsafe IO operations",
          "hierarchy": "System IO Unsafe",
          "module": "System.IO.Unsafe",
          "name": "Unsafe",
          "package": "base",
          "partial": "Unsafe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Unsafe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis version of \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e is more efficient\nbecause it omits the check that the IO is only being performed by a\nsingle thread.  Hence, when you use \u003ccode\u003e\u003ca\u003eunsafeDupablePerformIO\u003c/a\u003e\u003c/code\u003e,\nthere is a possibility that the IO action may be performed multiple\ntimes (on a multiprocessor), and you should therefore ensure that\nit gives the same results each time.\n\u003c/p\u003e",
          "module": "System.IO.Unsafe",
          "name": "unsafeDupablePerformIO",
          "package": "base",
          "signature": "IO a -\u003e a",
          "source": "src/GHC-IO.html#unsafeDupablePerformIO",
          "type": "function"
        },
        "index": {
          "description": "This version of unsafePerformIO is more efficient because it omits the check that the IO is only being performed by single thread Hence when you use unsafeDupablePerformIO there is possibility that the IO action may be performed multiple times on multiprocessor and you should therefore ensure that it gives the same results each time",
          "hierarchy": "System IO Unsafe",
          "module": "System.IO.Unsafe",
          "name": "unsafeDupablePerformIO",
          "normalized": "IO a-\u003ea",
          "package": "base",
          "partial": "Dupable Perform IO",
          "signature": "IO a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Unsafe.html#v:unsafeDupablePerformIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA slightly faster version of \u003ccode\u003e\u003ca\u003efixIO\u003c/a\u003e\u003c/code\u003e that may not be\n safe to use with multiple threads.  The unsafety arises when used\n like this:\n\u003c/p\u003e\u003cpre\u003e  unsafeFixIO $ \\r -\u003e\n     forkIO (print r)\n     return (...)\n\u003c/pre\u003e\u003cp\u003eIn this case, the child thread will receive a \u003ccode\u003eNonTermination\u003c/code\u003e\n exception instead of waiting for the value of \u003ccode\u003er\u003c/code\u003e to be computed.\n\u003c/p\u003e",
          "module": "System.IO.Unsafe",
          "name": "unsafeFixIO",
          "package": "base",
          "signature": "(a -\u003e IO a) -\u003e IO a",
          "source": "src/System-IO-Unsafe.html#unsafeFixIO",
          "type": "function"
        },
        "index": {
          "description": "slightly faster version of fixIO that may not be safe to use with multiple threads The unsafety arises when used like this unsafeFixIO forkIO print return In this case the child thread will receive NonTermination exception instead of waiting for the value of to be computed",
          "hierarchy": "System IO Unsafe",
          "module": "System.IO.Unsafe",
          "name": "unsafeFixIO",
          "normalized": "(a-\u003eIO a)-\u003eIO a",
          "package": "base",
          "partial": "Fix IO",
          "signature": "(a-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Unsafe.html#v:unsafeFixIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunsafeInterleaveIO\u003c/a\u003e\u003c/code\u003e allows \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e computation to be deferred lazily.\nWhen passed a value of type \u003ccode\u003eIO a\u003c/code\u003e, the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e will only be performed\nwhen the value of the \u003ccode\u003ea\u003c/code\u003e is demanded.  This is used to implement lazy\nfile reading, see \u003ccode\u003e\u003ca\u003ehGetContents\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "System.IO.Unsafe",
          "name": "unsafeInterleaveIO",
          "package": "base",
          "signature": "IO a -\u003e IO a",
          "source": "src/GHC-IO.html#unsafeInterleaveIO",
          "type": "function"
        },
        "index": {
          "description": "unsafeInterleaveIO allows IO computation to be deferred lazily When passed value of type IO the IO will only be performed when the value of the is demanded This is used to implement lazy file reading see hGetContents",
          "hierarchy": "System IO Unsafe",
          "module": "System.IO.Unsafe",
          "name": "unsafeInterleaveIO",
          "normalized": "IO a-\u003eIO a",
          "package": "base",
          "partial": "Interleave IO",
          "signature": "IO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Unsafe.html#v:unsafeInterleaveIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the \"back door\" into the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad, allowing\n\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e computation to be performed at any time.  For\nthis to be safe, the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e computation should be\nfree of side effects and independent of its environment.\n\u003c/p\u003e\u003cp\u003eIf the I/O computation wrapped in \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e performs side\neffects, then the relative order in which those side effects take\nplace (relative to the main I/O trunk, or other calls to\n\u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e) is indeterminate.  Furthermore, when using\n\u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e to cause side-effects, you should take the following\nprecautions to ensure the side effects are performed as many times as\nyou expect them to be.  Note that these precautions are necessary for\nGHC, but may not be sufficient, and other compilers may require\ndifferent precautions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Use \u003ccode\u003e{-# NOINLINE foo #-}\u003c/code\u003e as a pragma on any function \u003ccode\u003efoo\u003c/code\u003e\n        that calls \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e.  If the call is inlined,\n        the I/O may be performed more than once.\n\u003c/li\u003e\u003cli\u003e Use the compiler flag \u003ccode\u003e-fno-cse\u003c/code\u003e to prevent common sub-expression\n        elimination being performed on the module, which might combine\n        two side effects that were meant to be separate.  A good example\n        is using multiple global variables (like \u003ccode\u003etest\u003c/code\u003e in the example below).\n\u003c/li\u003e\u003cli\u003e Make sure that the either you switch off let-floating (\u003ccode\u003e-fno-full-laziness\u003c/code\u003e), or that the \n        call to \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e cannot float outside a lambda.  For example, \n        if you say:\n        \u003ccode\u003e\n           f x = unsafePerformIO (newIORef [])\n        \u003c/code\u003e\n        you may get only one reference cell shared between all calls to \u003ccode\u003ef\u003c/code\u003e.\n        Better would be\n        \u003ccode\u003e\n           f x = unsafePerformIO (newIORef [x])\n        \u003c/code\u003e\n        because now it can't float outside the lambda.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIt is less well known that\n\u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e is not type safe.  For example:\n\u003c/p\u003e\u003cpre\u003e     test :: IORef [a]\n     test = unsafePerformIO $ newIORef []\n     \n     main = do\n             writeIORef test [42]\n             bang \u003c- readIORef test\n             print (bang :: [Char])\n\u003c/pre\u003e\u003cp\u003eThis program will core dump.  This problem with polymorphic references\nis well known in the ML community, and does not arise with normal\nmonadic use of references.  There is no easy way to make it impossible\nonce you use \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e.  Indeed, it is\npossible to write \u003ccode\u003ecoerce :: a -\u003e b\u003c/code\u003e with the\nhelp of \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e.  So be careful!\n\u003c/p\u003e",
          "module": "System.IO.Unsafe",
          "name": "unsafePerformIO",
          "package": "base",
          "signature": "IO a -\u003e a",
          "source": "src/GHC-IO.html#unsafePerformIO",
          "type": "function"
        },
        "index": {
          "description": "This is the back door into the IO monad allowing IO computation to be performed at any time For this to be safe the IO computation should be free of side effects and independent of its environment If the computation wrapped in unsafePerformIO performs side effects then the relative order in which those side effects take place relative to the main trunk or other calls to unsafePerformIO is indeterminate Furthermore when using unsafePerformIO to cause side-effects you should take the following precautions to ensure the side effects are performed as many times as you expect them to be Note that these precautions are necessary for GHC but may not be sufficient and other compilers may require different precautions Use NOINLINE foo as pragma on any function foo that calls unsafePerformIO If the call is inlined the may be performed more than once Use the compiler flag fno-cse to prevent common sub-expression elimination being performed on the module which might combine two side effects that were meant to be separate good example is using multiple global variables like test in the example below Make sure that the either you switch off let-floating fno-full-laziness or that the call to unsafePerformIO cannot float outside lambda For example if you say unsafePerformIO newIORef you may get only one reference cell shared between all calls to Better would be unsafePerformIO newIORef because now it can float outside the lambda It is less well known that unsafePerformIO is not type safe For example test IORef test unsafePerformIO newIORef main do writeIORef test bang readIORef test print bang Char This program will core dump This problem with polymorphic references is well known in the ML community and does not arise with normal monadic use of references There is no easy way to make it impossible once you use unsafePerformIO Indeed it is possible to write coerce with the help of unsafePerformIO So be careful",
          "hierarchy": "System IO Unsafe",
          "module": "System.IO.Unsafe",
          "name": "unsafePerformIO",
          "normalized": "IO a-\u003ea",
          "package": "base",
          "partial": "Perform IO",
          "signature": "IO a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO-Unsafe.html#v:unsafePerformIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe standard IO library.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.IO",
          "name": "IO",
          "package": "base",
          "source": "src/System-IO.html",
          "type": "module"
        },
        "index": {
          "description": "The standard IO library",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "IO",
          "package": "base",
          "partial": "IO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThree kinds of buffering are supported: line-buffering, \n block-buffering or no-buffering.  These modes have the following\n effects. For output, items are written out, or \u003cem\u003eflushed\u003c/em\u003e,\n from the internal buffer according to the buffer mode:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003cem\u003eline-buffering\u003c/em\u003e: the entire output buffer is flushed\n    whenever a newline is output, the buffer overflows, \n    a \u003ccode\u003e\u003ca\u003ehFlush\u003c/a\u003e\u003c/code\u003e is issued, or the handle is closed.\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eblock-buffering\u003c/em\u003e: the entire buffer is written out whenever it\n    overflows, a \u003ccode\u003e\u003ca\u003ehFlush\u003c/a\u003e\u003c/code\u003e is issued, or the handle is closed.\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eno-buffering\u003c/em\u003e: output is written immediately, and never stored\n    in the buffer.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAn implementation is free to flush the buffer more frequently,\n but not less frequently, than specified above.\n The output buffer is emptied as soon as it has been written out.\n\u003c/p\u003e\u003cp\u003eSimilarly, input occurs according to the buffer mode for the handle:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003cem\u003eline-buffering\u003c/em\u003e: when the buffer for the handle is not empty,\n    the next item is obtained from the buffer; otherwise, when the\n    buffer is empty, characters up to and including the next newline\n    character are read into the buffer.  No characters are available\n    until the newline character is available or the buffer is full.\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eblock-buffering\u003c/em\u003e: when the buffer for the handle becomes empty,\n    the next block of data is read into the buffer.\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eno-buffering\u003c/em\u003e: the next input item is read and returned.\n    The \u003ccode\u003e\u003ca\u003ehLookAhead\u003c/a\u003e\u003c/code\u003e operation implies that even a no-buffered\n    handle may require a one-character buffer.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe default buffering mode when a handle is opened is\n implementation-dependent and may depend on the file system object\n which is attached to that handle.\n For most implementations, physical files will normally be block-buffered \n and terminals will normally be line-buffered.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "BufferMode",
          "package": "base",
          "source": "src/GHC-IO-Handle-Types.html#BufferMode",
          "type": "data"
        },
        "index": {
          "description": "Three kinds of buffering are supported line-buffering block-buffering or no-buffering These modes have the following effects For output items are written out or flushed from the internal buffer according to the buffer mode line-buffering the entire output buffer is flushed whenever newline is output the buffer overflows hFlush is issued or the handle is closed block-buffering the entire buffer is written out whenever it overflows hFlush is issued or the handle is closed no-buffering output is written immediately and never stored in the buffer An implementation is free to flush the buffer more frequently but not less frequently than specified above The output buffer is emptied as soon as it has been written out Similarly input occurs according to the buffer mode for the handle line-buffering when the buffer for the handle is not empty the next item is obtained from the buffer otherwise when the buffer is empty characters up to and including the next newline character are read into the buffer No characters are available until the newline character is available or the buffer is full block-buffering when the buffer for the handle becomes empty the next block of data is read into the buffer no-buffering the next input item is read and returned The hLookAhead operation implies that even no-buffered handle may require one-character buffer The default buffering mode when handle is opened is implementation-dependent and may depend on the file system object which is attached to that handle For most implementations physical files will normally be block-buffered and terminals will normally be line-buffered",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "BufferMode",
          "package": "base",
          "partial": "Buffer Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#t:BufferMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFile and directory names are values of type \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e, whose precise\n meaning is operating system dependent. Files can be opened, yielding a\n handle which can then be used to operate on the contents of that file.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "FilePath",
          "package": "base",
          "source": "src/GHC-IO.html#FilePath",
          "type": "type"
        },
        "index": {
          "description": "File and directory names are values of type String whose precise meaning is operating system dependent Files can be opened yielding handle which can then be used to operate on the contents of that file",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "FilePath",
          "package": "base",
          "partial": "File Path",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#t:FilePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell defines operations to read and write characters from and to files,\n represented by values of type \u003ccode\u003eHandle\u003c/code\u003e.  Each value of this type is a\n \u003cem\u003ehandle\u003c/em\u003e: a record used by the Haskell run-time system to \u003cem\u003emanage\u003c/em\u003e I/O\n with file system objects.  A handle has at least the following properties:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e whether it manages input or output or both;\n\u003c/li\u003e\u003cli\u003e whether it is \u003cem\u003eopen\u003c/em\u003e, \u003cem\u003eclosed\u003c/em\u003e or \u003cem\u003esemi-closed\u003c/em\u003e;\n\u003c/li\u003e\u003cli\u003e whether the object is seekable;\n\u003c/li\u003e\u003cli\u003e whether buffering is disabled, or enabled on a line or block basis;\n\u003c/li\u003e\u003cli\u003e a buffer (whose length may be zero).\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eMost handles will also have a current I/O position indicating where the next\n input or output operation will occur.  A handle is \u003cem\u003ereadable\u003c/em\u003e if it\n manages only input or both input and output; likewise, it is \u003cem\u003ewritable\u003c/em\u003e if\n it manages only output or both input and output.  A handle is \u003cem\u003eopen\u003c/em\u003e when\n first allocated.\n Once it is closed it can no longer be used for either input or output,\n though an implementation cannot re-use its storage while references\n remain to it.  Handles are in the \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e classes.  The string\n produced by showing a handle is system dependent; it should include\n enough information to identify the handle for debugging.  A handle is\n equal according to \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e only to itself; no attempt\n is made to compare the internal state of different handles for equality.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "Handle",
          "package": "base",
          "source": "src/GHC-IO-Handle-Types.html#Handle",
          "type": "data"
        },
        "index": {
          "description": "Haskell defines operations to read and write characters from and to files represented by values of type Handle Each value of this type is handle record used by the Haskell run-time system to manage with file system objects handle has at least the following properties whether it manages input or output or both whether it is open closed or semi-closed whether the object is seekable whether buffering is disabled or enabled on line or block basis buffer whose length may be zero Most handles will also have current position indicating where the next input or output operation will occur handle is readable if it manages only input or both input and output likewise it is writable if it manages only output or both input and output handle is open when first allocated Once it is closed it can no longer be used for either input or output though an implementation cannot re-use its storage while references remain to it Handles are in the Show and Eq classes The string produced by showing handle is system dependent it should include enough information to identify the handle for debugging handle is equal according to only to itself no attempt is made to compare the internal state of different handles for equality",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "Handle",
          "package": "base",
          "partial": "Handle",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#t:Handle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO",
          "name": "HandlePosn",
          "package": "base",
          "source": "src/GHC-IO-Handle.html#HandlePosn",
          "type": "data"
        },
        "index": {
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "HandlePosn",
          "package": "base",
          "partial": "Handle Posn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#t:HandlePosn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e is a computation which, when performed,\ndoes some I/O before returning a value of type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThere is really only one way to \"perform\" an I/O action: bind it to\n\u003ccode\u003eMain.main\u003c/code\u003e in your program.  When your program is run, the I/O will\nbe performed.  It isn't possible to perform I/O from an arbitrary\nfunction, unless that function is itself in the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad and called\nat some point, directly or indirectly, from \u003ccode\u003eMain.main\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e is a monad, so \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e actions can be combined using either the do-notation\nor the \u003ccode\u003e\u003e\u003e\u003c/code\u003e and \u003ccode\u003e\u003e\u003e=\u003c/code\u003e operations from the \u003ccode\u003eMonad\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "IO",
          "package": "base",
          "type": "data"
        },
        "index": {
          "description": "value of type IO is computation which when performed does some before returning value of type There is really only one way to perform an action bind it to Main.main in your program When your program is run the will be performed It isn possible to perform from an arbitrary function unless that function is itself in the IO monad and called at some point directly or indirectly from Main.main IO is monad so IO actions can be combined using either the do-notation or the and operations from the Monad class",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "IO",
          "package": "base",
          "partial": "IO",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#t:IO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSee \u003ccode\u003e\u003ca\u003eopenFile\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "IOMode",
          "package": "base",
          "source": "src/GHC-IO-IOMode.html#IOMode",
          "type": "data"
        },
        "index": {
          "description": "See openFile",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "IOMode",
          "package": "base",
          "partial": "IOMode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#t:IOMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe representation of a newline in the external file or stream.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "Newline",
          "package": "base",
          "source": "src/GHC-IO-Handle-Types.html#Newline",
          "type": "data"
        },
        "index": {
          "description": "The representation of newline in the external file or stream",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "Newline",
          "package": "base",
          "partial": "Newline",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#t:Newline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecifies the translation, if any, of newline characters between\n internal Strings and the external file or stream.  Haskell Strings\n are assumed to represent newlines with the '\\n' character; the\n newline mode specifies how to translate '\\n' on output, and what to\n translate into '\\n' on input.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "NewlineMode",
          "package": "base",
          "source": "src/GHC-IO-Handle-Types.html#NewlineMode",
          "type": "data"
        },
        "index": {
          "description": "Specifies the translation if any of newline characters between internal Strings and the external file or stream Haskell Strings are assumed to represent newlines with the character the newline mode specifies how to translate on output and what to translate into on input",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "NewlineMode",
          "package": "base",
          "partial": "Newline Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#t:NewlineMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA mode that determines the effect of \u003ccode\u003ehSeek\u003c/code\u003e \u003ccode\u003ehdl mode i\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "SeekMode",
          "package": "base",
          "source": "src/GHC-IO-Device.html#SeekMode",
          "type": "data"
        },
        "index": {
          "description": "mode that determines the effect of hSeek hdl mode",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "SeekMode",
          "package": "base",
          "partial": "Seek Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#t:SeekMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e is a specification of a conversion scheme\n between sequences of bytes and sequences of Unicode characters.\n\u003c/p\u003e\u003cp\u003eFor example, UTF-8 is an encoding of Unicode characters into a sequence\n of bytes.  The \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e for UTF-8 is \u003ccode\u003eutf8\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "TextEncoding",
          "package": "base",
          "source": "src/GHC-IO-Encoding-Types.html#TextEncoding",
          "type": "data"
        },
        "index": {
          "description": "TextEncoding is specification of conversion scheme between sequences of bytes and sequences of Unicode characters For example UTF-8 is an encoding of Unicode characters into sequence of bytes The TextEncoding for UTF-8 is utf8",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "TextEncoding",
          "package": "base",
          "partial": "Text Encoding",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#t:TextEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO",
          "name": "AppendMode",
          "package": "base",
          "signature": "AppendMode",
          "source": "src/GHC-IO-IOMode.html#IOMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "AppendMode",
          "package": "base",
          "partial": "Append Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:AppendMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO",
          "name": "ReadMode",
          "package": "base",
          "signature": "ReadMode",
          "source": "src/GHC-IO-IOMode.html#IOMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "ReadMode",
          "package": "base",
          "partial": "Read Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:ReadMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO",
          "name": "ReadWriteMode",
          "package": "base",
          "signature": "ReadWriteMode",
          "source": "src/GHC-IO-IOMode.html#IOMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "ReadWriteMode",
          "package": "base",
          "partial": "Read Write Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:ReadWriteMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO",
          "name": "WriteMode",
          "package": "base",
          "signature": "WriteMode",
          "source": "src/GHC-IO-IOMode.html#IOMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "WriteMode",
          "package": "base",
          "partial": "Write Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:WriteMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO",
          "name": "fixIO",
          "package": "base",
          "signature": "(a -\u003e IO a) -\u003e IO a",
          "source": "src/System-IO.html#fixIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "fixIO",
          "normalized": "(a-\u003eIO a)-\u003eIO a",
          "package": "base",
          "partial": "IO",
          "signature": "(a-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:fixIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufSome\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl buf count\u003c/code\u003e reads data from the handle \u003ccode\u003ehdl\u003c/code\u003e\n into the buffer \u003ccode\u003ebuf\u003c/code\u003e.  If there is any data available to read,\n then \u003ccode\u003e\u003ca\u003ehGetBufSome\u003c/a\u003e\u003c/code\u003e returns it immediately; it only blocks if there\n is no data to be read.\n\u003c/p\u003e\u003cp\u003eIt returns the number of bytes actually read.  This may be zero if\n EOF was reached before any data was read (or if \u003ccode\u003ecount\u003c/code\u003e is zero).\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufSome\u003c/a\u003e\u003c/code\u003e never raises an EOF exception, instead it returns a value\n smaller than \u003ccode\u003ecount\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the handle is a pipe or socket, and the writing end\n is closed, \u003ccode\u003e\u003ca\u003ehGetBufSome\u003c/a\u003e\u003c/code\u003e will behave as if EOF was reached.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufSome\u003c/a\u003e\u003c/code\u003e ignores the prevailing \u003ccode\u003eTextEncoding\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eNewlineMode\u003c/a\u003e\u003c/code\u003e\n on the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e, and reads bytes directly.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "hGetBufSome",
          "package": "base",
          "signature": "Handle -\u003e Ptr a -\u003e Int -\u003e IO Int",
          "source": "src/GHC-IO-Handle-Text.html#hGetBufSome",
          "type": "function"
        },
        "index": {
          "description": "hGetBufSome hdl buf count reads data from the handle hdl into the buffer buf If there is any data available to read then hGetBufSome returns it immediately it only blocks if there is no data to be read It returns the number of bytes actually read This may be zero if EOF was reached before any data was read or if count is zero hGetBufSome never raises an EOF exception instead it returns value smaller than count If the handle is pipe or socket and the writing end is closed hGetBufSome will behave as if EOF was reached hGetBufSome ignores the prevailing TextEncoding and NewlineMode on the Handle and reads bytes directly",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "hGetBufSome",
          "normalized": "Handle-\u003ePtr a-\u003eInt-\u003eIO Int",
          "package": "base",
          "partial": "Get Buf Some",
          "signature": "Handle-\u003ePtr a-\u003eInt-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:hGetBufSome"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehPrint\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl t\u003c/code\u003e writes the string representation of \u003ccode\u003et\u003c/code\u003e\n given by the \u003ccode\u003e\u003ca\u003eshows\u003c/a\u003e\u003c/code\u003e function to the file or channel managed by \u003ccode\u003ehdl\u003c/code\u003e\n and appends a newline.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisFullError\u003c/a\u003e\u003c/code\u003e if the device is full; or\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisPermissionError\u003c/a\u003e\u003c/code\u003e if another system resource limit would be exceeded.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "System.IO",
          "name": "hPrint",
          "package": "base",
          "signature": "Handle -\u003e a -\u003e IO ()",
          "source": "src/System-IO.html#hPrint",
          "type": "function"
        },
        "index": {
          "description": "Computation hPrint hdl writes the string representation of given by the shows function to the file or channel managed by hdl and appends newline This operation may fail with isFullError if the device is full or isPermissionError if another system resource limit would be exceeded",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "hPrint",
          "normalized": "Handle-\u003ea-\u003eIO()",
          "package": "base",
          "partial": "Print",
          "signature": "Handle-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:hPrint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe same as \u003ccode\u003e\u003ca\u003ehPutStr\u003c/a\u003e\u003c/code\u003e, but adds a newline character.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "hPutStrLn",
          "package": "base",
          "signature": "Handle -\u003e String -\u003e IO ()",
          "source": "src/GHC-IO-Handle-Text.html#hPutStrLn",
          "type": "function"
        },
        "index": {
          "description": "The same as hPutStr but adds newline character",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "hPutStrLn",
          "normalized": "Handle-\u003eString-\u003eIO()",
          "package": "base",
          "partial": "Put Str Ln",
          "signature": "Handle-\u003eString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:hPutStrLn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehReady\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e indicates whether at least one item is\n available for input from handle \u003ccode\u003ehdl\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisEOFError\u003c/a\u003e\u003c/code\u003e if the end of file has been reached.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "System.IO",
          "name": "hReady",
          "package": "base",
          "signature": "Handle -\u003e IO Bool",
          "source": "src/System-IO.html#hReady",
          "type": "function"
        },
        "index": {
          "description": "Computation hReady hdl indicates whether at least one item is available for input from handle hdl This operation may fail with isEOFError if the end of file has been reached",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "hReady",
          "normalized": "Handle-\u003eIO Bool",
          "package": "base",
          "partial": "Ready",
          "signature": "Handle-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:hReady"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Unicode encoding of the current locale\n\u003c/p\u003e\u003cp\u003eThis is the initial locale encoding: if it has been subsequently changed by\n \u003ccode\u003e\u003ca\u003esetLocaleEncoding\u003c/a\u003e\u003c/code\u003e this value will not reflect that change.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "localeEncoding",
          "package": "base",
          "signature": "TextEncoding",
          "source": "src/System-IO.html#localeEncoding",
          "type": "function"
        },
        "index": {
          "description": "The Unicode encoding of the current locale This is the initial locale encoding if it has been subsequently changed by setLocaleEncoding this value will not reflect that change",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "localeEncoding",
          "package": "base",
          "partial": "Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:localeEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eopenTempFile\u003c/a\u003e\u003c/code\u003e, but opens the file in binary mode. See \u003ccode\u003e\u003ca\u003eopenBinaryFile\u003c/a\u003e\u003c/code\u003e for more comments.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "openBinaryTempFile",
          "package": "base",
          "signature": "FilePath -\u003e String -\u003e IO (FilePath, Handle)",
          "source": "src/System-IO.html#openBinaryTempFile",
          "type": "function"
        },
        "index": {
          "description": "Like openTempFile but opens the file in binary mode See openBinaryFile for more comments",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "openBinaryTempFile",
          "normalized": "FilePath-\u003eString-\u003eIO(FilePath,Handle)",
          "package": "base",
          "partial": "Binary Temp File",
          "signature": "FilePath-\u003eString-\u003eIO(FilePath,Handle)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:openBinaryTempFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eopenBinaryTempFile\u003c/a\u003e\u003c/code\u003e, but uses the default file permissions\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "openBinaryTempFileWithDefaultPermissions",
          "package": "base",
          "signature": "FilePath -\u003e String -\u003e IO (FilePath, Handle)",
          "source": "src/System-IO.html#openBinaryTempFileWithDefaultPermissions",
          "type": "function"
        },
        "index": {
          "description": "Like openBinaryTempFile but uses the default file permissions",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "openBinaryTempFileWithDefaultPermissions",
          "normalized": "FilePath-\u003eString-\u003eIO(FilePath,Handle)",
          "package": "base",
          "partial": "Binary Temp File With Default Permissions",
          "signature": "FilePath-\u003eString-\u003eIO(FilePath,Handle)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:openBinaryTempFileWithDefaultPermissions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function creates a temporary file in ReadWrite mode.\n The created file isn't deleted automatically, so you need to delete it manually.\n\u003c/p\u003e\u003cp\u003eThe file is creates with permissions such that only the current\n user can read/write it.\n\u003c/p\u003e\u003cp\u003eWith some exceptions (see below), the file will be created securely\n in the sense that an attacker should not be able to cause\n openTempFile to overwrite another file on the filesystem using your\n credentials, by putting symbolic links (on Unix) in the place where\n the temporary file is to be created.  On Unix the \u003ccode\u003eO_CREAT\u003c/code\u003e and\n \u003ccode\u003eO_EXCL\u003c/code\u003e flags are used to prevent this attack, but note that\n \u003ccode\u003eO_EXCL\u003c/code\u003e is sometimes not supported on NFS filesystems, so if you\n rely on this behaviour it is best to use local filesystems only.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "openTempFile",
          "package": "base",
          "signature": "FilePath-\u003e String-\u003e IO (FilePath, Handle)",
          "type": "function"
        },
        "index": {
          "description": "The function creates temporary file in ReadWrite mode The created file isn deleted automatically so you need to delete it manually The file is creates with permissions such that only the current user can read write it With some exceptions see below the file will be created securely in the sense that an attacker should not be able to cause openTempFile to overwrite another file on the filesystem using your credentials by putting symbolic links on Unix in the place where the temporary file is to be created On Unix the CREAT and EXCL flags are used to prevent this attack but note that EXCL is sometimes not supported on NFS filesystems so if you rely on this behaviour it is best to use local filesystems only",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "openTempFile",
          "normalized": "FilePath-\u003eString-\u003eIO(FilePath,Handle)",
          "package": "base",
          "partial": "Temp File",
          "signature": "FilePath-\u003eString-\u003eIO(FilePath,Handle)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:openTempFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eopenTempFile\u003c/a\u003e\u003c/code\u003e, but uses the default file permissions\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "openTempFileWithDefaultPermissions",
          "package": "base",
          "signature": "FilePath -\u003e String -\u003e IO (FilePath, Handle)",
          "source": "src/System-IO.html#openTempFileWithDefaultPermissions",
          "type": "function"
        },
        "index": {
          "description": "Like openTempFile but uses the default file permissions",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "openTempFileWithDefaultPermissions",
          "normalized": "FilePath-\u003eString-\u003eIO(FilePath,Handle)",
          "package": "base",
          "partial": "Temp File With Default Permissions",
          "signature": "FilePath-\u003eString-\u003eIO(FilePath,Handle)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:openTempFileWithDefaultPermissions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ewithBinaryFile\u003c/a\u003e\u003c/code\u003e name mode act\u003c/code\u003e opens a file using \u003ccode\u003e\u003ca\u003eopenBinaryFile\u003c/a\u003e\u003c/code\u003e\n and passes the resulting handle to the computation \u003ccode\u003eact\u003c/code\u003e.  The handle\n will be closed on exit from \u003ccode\u003e\u003ca\u003ewithBinaryFile\u003c/a\u003e\u003c/code\u003e, whether by normal\n termination or by raising an exception.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "withBinaryFile",
          "package": "base",
          "signature": "FilePath -\u003e IOMode -\u003e (Handle -\u003e IO r) -\u003e IO r",
          "source": "src/System-IO.html#withBinaryFile",
          "type": "function"
        },
        "index": {
          "description": "withBinaryFile name mode act opens file using openBinaryFile and passes the resulting handle to the computation act The handle will be closed on exit from withBinaryFile whether by normal termination or by raising an exception",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "withBinaryFile",
          "normalized": "FilePath-\u003eIOMode-\u003e(Handle-\u003eIO a)-\u003eIO a",
          "package": "base",
          "partial": "Binary File",
          "signature": "FilePath-\u003eIOMode-\u003e(Handle-\u003eIO r)-\u003eIO r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:withBinaryFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ewithFile\u003c/a\u003e\u003c/code\u003e name mode act\u003c/code\u003e opens a file using \u003ccode\u003e\u003ca\u003eopenFile\u003c/a\u003e\u003c/code\u003e and passes\n the resulting handle to the computation \u003ccode\u003eact\u003c/code\u003e.  The handle will be\n closed on exit from \u003ccode\u003e\u003ca\u003ewithFile\u003c/a\u003e\u003c/code\u003e, whether by normal termination or by\n raising an exception.  If closing the handle raises an exception, then\n this exception will be raised by \u003ccode\u003e\u003ca\u003ewithFile\u003c/a\u003e\u003c/code\u003e rather than any exception\n raised by \u003ccode\u003eact\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "System.IO",
          "name": "withFile",
          "package": "base",
          "signature": "FilePath -\u003e IOMode -\u003e (Handle -\u003e IO r) -\u003e IO r",
          "source": "src/System-IO.html#withFile",
          "type": "function"
        },
        "index": {
          "description": "withFile name mode act opens file using openFile and passes the resulting handle to the computation act The handle will be closed on exit from withFile whether by normal termination or by raising an exception If closing the handle raises an exception then this exception will be raised by withFile rather than any exception raised by act",
          "hierarchy": "System IO",
          "module": "System.IO",
          "name": "withFile",
          "normalized": "FilePath-\u003eIOMode-\u003e(Handle-\u003eIO a)-\u003eIO a",
          "package": "base",
          "partial": "File",
          "signature": "FilePath-\u003eIOMode-\u003e(Handle-\u003eIO r)-\u003eIO r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-IO.html#v:withFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInformation about the characteristics of the host \n system lucky enough to run your program.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.Info",
          "name": "Info",
          "package": "base",
          "source": "src/System-Info.html",
          "type": "module"
        },
        "index": {
          "description": "Information about the characteristics of the host system lucky enough to run your program",
          "hierarchy": "System Info",
          "module": "System.Info",
          "name": "Info",
          "package": "base",
          "partial": "Info",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Info.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe machine architecture on which the program is running.\n\u003c/p\u003e",
          "module": "System.Info",
          "name": "arch",
          "package": "base",
          "signature": "String",
          "source": "src/System-Info.html#arch",
          "type": "function"
        },
        "index": {
          "description": "The machine architecture on which the program is running",
          "hierarchy": "System Info",
          "module": "System.Info",
          "name": "arch",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Info.html#v:arch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Haskell implementation with which the program was compiled\n or is being interpreted.\n\u003c/p\u003e",
          "module": "System.Info",
          "name": "compilerName",
          "package": "base",
          "signature": "String",
          "source": "src/System-Info.html#compilerName",
          "type": "function"
        },
        "index": {
          "description": "The Haskell implementation with which the program was compiled or is being interpreted",
          "hierarchy": "System Info",
          "module": "System.Info",
          "name": "compilerName",
          "package": "base",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Info.html#v:compilerName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe version of \u003ccode\u003e\u003ca\u003ecompilerName\u003c/a\u003e\u003c/code\u003e with which the program was compiled\n or is being interpreted.\n\u003c/p\u003e",
          "module": "System.Info",
          "name": "compilerVersion",
          "package": "base",
          "signature": "Version",
          "source": "src/System-Info.html#compilerVersion",
          "type": "function"
        },
        "index": {
          "description": "The version of compilerName with which the program was compiled or is being interpreted",
          "hierarchy": "System Info",
          "module": "System.Info",
          "name": "compilerVersion",
          "package": "base",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Info.html#v:compilerVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe operating system on which the program is running.\n\u003c/p\u003e",
          "module": "System.Info",
          "name": "os",
          "package": "base",
          "signature": "String",
          "source": "src/System-Info.html#os",
          "type": "function"
        },
        "index": {
          "description": "The operating system on which the program is running",
          "hierarchy": "System Info",
          "module": "System.Info",
          "name": "os",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Info.html#v:os"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eStable names are a way of performing fast (O(1)), not-quite-exact\n comparison between objects.\n\u003c/p\u003e\u003cp\u003eStable names solve the following problem: suppose you want to build\n a hash table with Haskell objects as keys, but you want to use\n pointer equality for comparison; maybe because the keys are large\n and hashing would be slow, or perhaps because the keys are infinite\n in size.  We can't build a hash table using the address of the\n object as the key, because objects get moved around by the garbage\n collector, meaning a re-hash would be necessary after every garbage\n collection.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.Mem.StableName",
          "name": "StableName",
          "package": "base",
          "source": "src/System-Mem-StableName.html",
          "type": "module"
        },
        "index": {
          "description": "Stable names are way of performing fast not-quite-exact comparison between objects Stable names solve the following problem suppose you want to build hash table with Haskell objects as keys but you want to use pointer equality for comparison maybe because the keys are large and hashing would be slow or perhaps because the keys are infinite in size We can build hash table using the address of the object as the key because objects get moved around by the garbage collector meaning re-hash would be necessary after every garbage collection",
          "hierarchy": "System Mem StableName",
          "module": "System.Mem.StableName",
          "name": "StableName",
          "package": "base",
          "partial": "Stable Name",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Mem-StableName.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abstract name for an object, that supports equality and hashing.\n\u003c/p\u003e\u003cp\u003eStable names have the following property:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e If \u003ccode\u003esn1 :: StableName\u003c/code\u003e and \u003ccode\u003esn2 :: StableName\u003c/code\u003e and \u003ccode\u003esn1 == sn2\u003c/code\u003e\n   then \u003ccode\u003esn1\u003c/code\u003e and \u003ccode\u003esn2\u003c/code\u003e were created by calls to \u003ccode\u003emakeStableName\u003c/code\u003e on \n   the same object.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe reverse is not necessarily true: if two stable names are not\n  equal, then the objects they name may still be equal.  Note in particular\n  that \u003ccode\u003emkStableName\u003c/code\u003e may return a different \u003ccode\u003e\u003ca\u003eStableName\u003c/a\u003e\u003c/code\u003e after an\n  object is evaluated.\n\u003c/p\u003e\u003cp\u003eStable Names are similar to Stable Pointers (\u003ca\u003eForeign.StablePtr\u003c/a\u003e),\n  but differ in the following ways:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e There is no \u003ccode\u003efreeStableName\u003c/code\u003e operation, unlike \u003ca\u003eForeign.StablePtr\u003c/a\u003es.\n    Stable names are reclaimed by the runtime system when they are no\n    longer needed.\n\u003c/li\u003e\u003cli\u003e There is no \u003ccode\u003edeRefStableName\u003c/code\u003e operation.  You can't get back from\n    a stable name to the original Haskell object.  The reason for\n    this is that the existence of a stable name for an object does not\n    guarantee the existence of the object itself; it can still be garbage\n    collected.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "System.Mem.StableName",
          "name": "StableName",
          "package": "base",
          "source": "src/System-Mem-StableName.html#StableName",
          "type": "data"
        },
        "index": {
          "description": "An abstract name for an object that supports equality and hashing Stable names have the following property If sn1 StableName and sn2 StableName and sn1 sn2 then sn1 and sn2 were created by calls to makeStableName on the same object The reverse is not necessarily true if two stable names are not equal then the objects they name may still be equal Note in particular that mkStableName may return different StableName after an object is evaluated Stable Names are similar to Stable Pointers Foreign.StablePtr but differ in the following ways There is no freeStableName operation unlike Foreign.StablePtr Stable names are reclaimed by the runtime system when they are no longer needed There is no deRefStableName operation You can get back from stable name to the original Haskell object The reason for this is that the existence of stable name for an object does not guarantee the existence of the object itself it can still be garbage collected",
          "hierarchy": "System Mem StableName",
          "module": "System.Mem.StableName",
          "name": "StableName",
          "package": "base",
          "partial": "Stable Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Mem-StableName.html#t:StableName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eStableName\u003c/a\u003e\u003c/code\u003e to an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.  The \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e returned is not\n necessarily unique; several \u003ccode\u003e\u003ca\u003eStableName\u003c/a\u003e\u003c/code\u003es may map to the same \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n (in practice however, the chances of this are small, so the result\n of \u003ccode\u003e\u003ca\u003ehashStableName\u003c/a\u003e\u003c/code\u003e makes a good hash key).\n\u003c/p\u003e",
          "module": "System.Mem.StableName",
          "name": "hashStableName",
          "package": "base",
          "signature": "StableName a -\u003e Int",
          "source": "src/System-Mem-StableName.html#hashStableName",
          "type": "function"
        },
        "index": {
          "description": "Convert StableName to an Int The Int returned is not necessarily unique several StableName may map to the same Int in practice however the chances of this are small so the result of hashStableName makes good hash key",
          "hierarchy": "System Mem StableName",
          "module": "System.Mem.StableName",
          "name": "hashStableName",
          "normalized": "StableName a-\u003eInt",
          "package": "base",
          "partial": "Stable Name",
          "signature": "StableName a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Mem-StableName.html#v:hashStableName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMakes a \u003ccode\u003e\u003ca\u003eStableName\u003c/a\u003e\u003c/code\u003e for an arbitrary object.  The object passed as\n the first argument is not evaluated by \u003ccode\u003e\u003ca\u003emakeStableName\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "System.Mem.StableName",
          "name": "makeStableName",
          "package": "base",
          "signature": "a -\u003e IO (StableName a)",
          "source": "src/System-Mem-StableName.html#makeStableName",
          "type": "function"
        },
        "index": {
          "description": "Makes StableName for an arbitrary object The object passed as the first argument is not evaluated by makeStableName",
          "hierarchy": "System Mem StableName",
          "module": "System.Mem.StableName",
          "name": "makeStableName",
          "normalized": "a-\u003eIO(StableName a)",
          "package": "base",
          "partial": "Stable Name",
          "signature": "a-\u003eIO(StableName a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Mem-StableName.html#v:makeStableName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eIn general terms, a weak pointer is a reference to an object that is\n not followed by the garbage collector - that is, the existence of a\n weak pointer to an object has no effect on the lifetime of that\n object.  A weak pointer can be de-referenced to find out\n whether the object it refers to is still alive or not, and if so\n to return the object itself.\n\u003c/p\u003e\u003cp\u003eWeak pointers are particularly useful for caches and memo tables.\n To build a memo table, you build a data structure \n mapping from the function argument (the key) to its result (the\n value).  When you apply the function to a new argument you first\n check whether the key/value pair is already in the memo table.\n The key point is that the memo table itself should not keep the\n key and value alive.  So the table should contain a weak pointer\n to the key, not an ordinary pointer.  The pointer to the value must\n not be weak, because the only reference to the value might indeed be\n from the memo table.   \n\u003c/p\u003e\u003cp\u003eSo it looks as if the memo table will keep all its values\n alive for ever.  One way to solve this is to purge the table\n occasionally, by deleting entries whose keys have died.\n\u003c/p\u003e\u003cp\u003eThe weak pointers in this library\n support another approach, called \u003cem\u003efinalization\u003c/em\u003e.\n When the key referred to by a weak pointer dies, the storage manager\n arranges to run a programmer-specified finalizer.  In the case of memo\n tables, for example, the finalizer could remove the key/value pair\n from the memo table.  \n\u003c/p\u003e\u003cp\u003eAnother difficulty with the memo table is that the value of a\n key/value pair might itself contain a pointer to the key.\n So the memo table keeps the value alive, which keeps the key alive,\n even though there may be no other references to the key so both should\n die.  The weak pointers in this library provide a slight \n generalisation of the basic weak-pointer idea, in which each\n weak pointer actually contains both a key and a value.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.Mem.Weak",
          "name": "Weak",
          "package": "base",
          "source": "src/System-Mem-Weak.html",
          "type": "module"
        },
        "index": {
          "description": "In general terms weak pointer is reference to an object that is not followed by the garbage collector that is the existence of weak pointer to an object has no effect on the lifetime of that object weak pointer can be de-referenced to find out whether the object it refers to is still alive or not and if so to return the object itself Weak pointers are particularly useful for caches and memo tables To build memo table you build data structure mapping from the function argument the key to its result the value When you apply the function to new argument you first check whether the key value pair is already in the memo table The key point is that the memo table itself should not keep the key and value alive So the table should contain weak pointer to the key not an ordinary pointer The pointer to the value must not be weak because the only reference to the value might indeed be from the memo table So it looks as if the memo table will keep all its values alive for ever One way to solve this is to purge the table occasionally by deleting entries whose keys have died The weak pointers in this library support another approach called finalization When the key referred to by weak pointer dies the storage manager arranges to run programmer-specified finalizer In the case of memo tables for example the finalizer could remove the key value pair from the memo table Another difficulty with the memo table is that the value of key value pair might itself contain pointer to the key So the memo table keeps the value alive which keeps the key alive even though there may be no other references to the key so both should die The weak pointers in this library provide slight generalisation of the basic weak-pointer idea in which each weak pointer actually contains both key and value",
          "hierarchy": "System Mem Weak",
          "module": "System.Mem.Weak",
          "name": "Weak",
          "package": "base",
          "partial": "Weak",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Mem-Weak.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA weak pointer object with a key and a value.  The value has type \u003ccode\u003ev\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eA weak pointer expresses a relationship between two objects, the\n\u003cem\u003ekey\u003c/em\u003e and the \u003cem\u003evalue\u003c/em\u003e:  if the key is considered to be alive by the\ngarbage collector, then the value is also alive.  A reference from\nthe value to the key does \u003cem\u003enot\u003c/em\u003e keep the key alive.\n\u003c/p\u003e\u003cp\u003eA weak pointer may also have a finalizer of type \u003ccode\u003eIO ()\u003c/code\u003e; if it does,\nthen the finalizer will be run at most once, at a time after the key\nhas become unreachable by the program (\"dead\").  The storage manager\nattempts to run the finalizer(s) for an object soon after the object\ndies, but promptness is not guaranteed.  \n\u003c/p\u003e\u003cp\u003eIt is not guaranteed that a finalizer will eventually run, and no\nattempt is made to run outstanding finalizers when the program exits.\nTherefore finalizers should not be relied on to clean up resources -\nother methods (eg. exception handlers) should be employed, possibly in\naddition to finalizers.\n\u003c/p\u003e\u003cp\u003eReferences from the finalizer to the key are treated in the same way\nas references from the value to the key: they do not keep the key\nalive.  A finalizer may therefore ressurrect the key, perhaps by\nstoring it in the same data structure.\n\u003c/p\u003e\u003cp\u003eThe finalizer, and the relationship between the key and the value,\nexist regardless of whether the program keeps a reference to the\n\u003ccode\u003e\u003ca\u003eWeak\u003c/a\u003e\u003c/code\u003e object or not.\n\u003c/p\u003e\u003cp\u003eThere may be multiple weak pointers with the same key.  In this\ncase, the finalizers for each of these weak pointers will all be\nrun in some arbitrary order, or perhaps concurrently, when the key\ndies.  If the programmer specifies a finalizer that assumes it has\nthe only reference to an object (for example, a file that it wishes\nto close), then the programmer must ensure that there is only one\nsuch finalizer.\n\u003c/p\u003e\u003cp\u003eIf there are no other threads to run, the runtime system will check\nfor runnable finalizers before declaring the system to be deadlocked.\n\u003c/p\u003e\u003cp\u003eWARNING: weak pointers to ordinary non-primitive Haskell types are\nparticularly fragile, because the compiler is free to optimise away or\nduplicate the underlying data structure.  Therefore attempting to\nplace a finalizer on an ordinary Haskell type may well result in the\nfinalizer running earlier than you expected.  This is not a problem\nfor caches and memo tables where early finalization is benign.\n\u003c/p\u003e\u003cp\u003eFinalizers \u003cem\u003ecan\u003c/em\u003e be used reliably for types that are created explicitly\nand have identity, such as \u003ccode\u003eIORef\u003c/code\u003e and \u003ccode\u003eMVar\u003c/code\u003e.  However, to place a\nfinalizer on one of these types, you should use the specific operation\nprovided for that type, e.g. \u003ccode\u003emkWeakIORef\u003c/code\u003e and \u003ccode\u003eaddMVarFinalizer\u003c/code\u003e\nrespectively (the non-uniformity is accidental).  These operations\nattach the finalizer to the primitive object inside the box\n(e.g. \u003ccode\u003eMutVar#\u003c/code\u003e in the case of \u003ccode\u003eIORef\u003c/code\u003e), because attaching the\nfinalizer to the box itself fails when the outer box is optimised away\nby the compiler.\n\u003c/p\u003e",
          "module": "System.Mem.Weak",
          "name": "Weak",
          "package": "base",
          "source": "src/GHC-Weak.html#Weak",
          "type": "data"
        },
        "index": {
          "description": "weak pointer object with key and value The value has type weak pointer expresses relationship between two objects the key and the value if the key is considered to be alive by the garbage collector then the value is also alive reference from the value to the key does not keep the key alive weak pointer may also have finalizer of type IO if it does then the finalizer will be run at most once at time after the key has become unreachable by the program dead The storage manager attempts to run the finalizer for an object soon after the object dies but promptness is not guaranteed It is not guaranteed that finalizer will eventually run and no attempt is made to run outstanding finalizers when the program exits Therefore finalizers should not be relied on to clean up resources other methods eg exception handlers should be employed possibly in addition to finalizers References from the finalizer to the key are treated in the same way as references from the value to the key they do not keep the key alive finalizer may therefore ressurrect the key perhaps by storing it in the same data structure The finalizer and the relationship between the key and the value exist regardless of whether the program keeps reference to the Weak object or not There may be multiple weak pointers with the same key In this case the finalizers for each of these weak pointers will all be run in some arbitrary order or perhaps concurrently when the key dies If the programmer specifies finalizer that assumes it has the only reference to an object for example file that it wishes to close then the programmer must ensure that there is only one such finalizer If there are no other threads to run the runtime system will check for runnable finalizers before declaring the system to be deadlocked WARNING weak pointers to ordinary non-primitive Haskell types are particularly fragile because the compiler is free to optimise away or duplicate the underlying data structure Therefore attempting to place finalizer on an ordinary Haskell type may well result in the finalizer running earlier than you expected This is not problem for caches and memo tables where early finalization is benign Finalizers can be used reliably for types that are created explicitly and have identity such as IORef and MVar However to place finalizer on one of these types you should use the specific operation provided for that type e.g mkWeakIORef and addMVarFinalizer respectively the non-uniformity is accidental These operations attach the finalizer to the primitive object inside the box e.g MutVar in the case of IORef because attaching the finalizer to the box itself fails when the outer box is optimised away by the compiler",
          "hierarchy": "System Mem Weak",
          "module": "System.Mem.Weak",
          "name": "Weak",
          "package": "base",
          "partial": "Weak",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Mem-Weak.html#t:Weak"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA specialised version of \u003ccode\u003e\u003ca\u003emkWeakPtr\u003c/a\u003e\u003c/code\u003e, where the \u003ccode\u003e\u003ca\u003eWeak\u003c/a\u003e\u003c/code\u003e object\n  returned is simply thrown away (however the finalizer will be\n  remembered by the garbage collector, and will still be run\n  when the key becomes unreachable).\n\u003c/p\u003e\u003cp\u003eNote: adding a finalizer to a \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e using\n  \u003ccode\u003e\u003ca\u003eaddFinalizer\u003c/a\u003e\u003c/code\u003e won't work; use the specialised version\n  \u003ccode\u003e\u003ca\u003eaddForeignPtrFinalizer\u003c/a\u003e\u003c/code\u003e instead.  For discussion\n  see the \u003ccode\u003e\u003ca\u003eWeak\u003c/a\u003e\u003c/code\u003e type.\n.\n\u003c/p\u003e",
          "module": "System.Mem.Weak",
          "name": "addFinalizer",
          "package": "base",
          "signature": "key -\u003e IO () -\u003e IO ()",
          "source": "src/System-Mem-Weak.html#addFinalizer",
          "type": "function"
        },
        "index": {
          "description": "specialised version of mkWeakPtr where the Weak object returned is simply thrown away however the finalizer will be remembered by the garbage collector and will still be run when the key becomes unreachable Note adding finalizer to ForeignPtr using addFinalizer won work use the specialised version addForeignPtrFinalizer instead For discussion see the Weak type",
          "hierarchy": "System Mem Weak",
          "module": "System.Mem.Weak",
          "name": "addFinalizer",
          "normalized": "a-\u003eIO()-\u003eIO()",
          "package": "base",
          "partial": "Finalizer",
          "signature": "key-\u003eIO()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Mem-Weak.html#v:addFinalizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDereferences a weak pointer.  If the key is still alive, then\n\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e v\u003c/code\u003e is returned (where \u003ccode\u003ev\u003c/code\u003e is the \u003cem\u003evalue\u003c/em\u003e in the weak pointer), otherwise\n\u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e is returned.\n\u003c/p\u003e\u003cp\u003eThe return value of \u003ccode\u003e\u003ca\u003edeRefWeak\u003c/a\u003e\u003c/code\u003e depends on when the garbage collector\nruns, hence it is in the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad.\n\u003c/p\u003e",
          "module": "System.Mem.Weak",
          "name": "deRefWeak",
          "package": "base",
          "signature": "Weak v -\u003e IO (Maybe v)",
          "source": "src/GHC-Weak.html#deRefWeak",
          "type": "function"
        },
        "index": {
          "description": "Dereferences weak pointer If the key is still alive then Just is returned where is the value in the weak pointer otherwise Nothing is returned The return value of deRefWeak depends on when the garbage collector runs hence it is in the IO monad",
          "hierarchy": "System Mem Weak",
          "module": "System.Mem.Weak",
          "name": "deRefWeak",
          "normalized": "Weak a-\u003eIO(Maybe a)",
          "package": "base",
          "partial": "Ref Weak",
          "signature": "Weak v-\u003eIO(Maybe v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Mem-Weak.html#v:deRefWeak"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCauses a the finalizer associated with a weak pointer to be run\n immediately.\n\u003c/p\u003e",
          "module": "System.Mem.Weak",
          "name": "finalize",
          "package": "base",
          "signature": "Weak v -\u003e IO ()",
          "source": "src/GHC-Weak.html#finalize",
          "type": "function"
        },
        "index": {
          "description": "Causes the finalizer associated with weak pointer to be run immediately",
          "hierarchy": "System Mem Weak",
          "module": "System.Mem.Weak",
          "name": "finalize",
          "normalized": "Weak a-\u003eIO()",
          "package": "base",
          "signature": "Weak v-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Mem-Weak.html#v:finalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEstablishes a weak pointer to \u003ccode\u003ek\u003c/code\u003e, with value \u003ccode\u003ev\u003c/code\u003e and a finalizer.\n\u003c/p\u003e\u003cp\u003eThis is the most general interface for building a weak pointer.\n\u003c/p\u003e",
          "module": "System.Mem.Weak",
          "name": "mkWeak",
          "package": "base",
          "signature": "k-\u003e v-\u003e Maybe (IO ())-\u003e IO (Weak v)",
          "type": "function"
        },
        "index": {
          "description": "Establishes weak pointer to with value and finalizer This is the most general interface for building weak pointer",
          "hierarchy": "System Mem Weak",
          "module": "System.Mem.Weak",
          "name": "mkWeak",
          "normalized": "a-\u003eb-\u003eMaybe(IO())-\u003eIO(Weak b)",
          "package": "base",
          "partial": "Weak",
          "signature": "k-\u003ev-\u003eMaybe(IO())-\u003eIO(Weak v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Mem-Weak.html#v:mkWeak"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA specialised version of \u003ccode\u003e\u003ca\u003emkWeak\u003c/a\u003e\u003c/code\u003e where the value is actually a pair\n of the key and value passed to \u003ccode\u003e\u003ca\u003emkWeakPair\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e mkWeakPair key val finalizer = mkWeak key (key,val) finalizer\n\u003c/pre\u003e\u003cp\u003eThe advantage of this is that the key can be retrieved by \u003ccode\u003e\u003ca\u003edeRefWeak\u003c/a\u003e\u003c/code\u003e\n in addition to the value.\n\u003c/p\u003e",
          "module": "System.Mem.Weak",
          "name": "mkWeakPair",
          "package": "base",
          "signature": "k -\u003e v -\u003e Maybe (IO ()) -\u003e IO (Weak (k, v))",
          "source": "src/System-Mem-Weak.html#mkWeakPair",
          "type": "function"
        },
        "index": {
          "description": "specialised version of mkWeak where the value is actually pair of the key and value passed to mkWeakPair mkWeakPair key val finalizer mkWeak key key val finalizer The advantage of this is that the key can be retrieved by deRefWeak in addition to the value",
          "hierarchy": "System Mem Weak",
          "module": "System.Mem.Weak",
          "name": "mkWeakPair",
          "normalized": "a-\u003eb-\u003eMaybe(IO())-\u003eIO(Weak(a,b))",
          "package": "base",
          "partial": "Weak Pair",
          "signature": "k-\u003ev-\u003eMaybe(IO())-\u003eIO(Weak(k,v))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Mem-Weak.html#v:mkWeakPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA specialised version of \u003ccode\u003e\u003ca\u003emkWeak\u003c/a\u003e\u003c/code\u003e, where the key and the value are\n the same object:\n\u003c/p\u003e\u003cpre\u003e mkWeakPtr key finalizer = mkWeak key key finalizer\n\u003c/pre\u003e",
          "module": "System.Mem.Weak",
          "name": "mkWeakPtr",
          "package": "base",
          "signature": "k -\u003e Maybe (IO ()) -\u003e IO (Weak k)",
          "source": "src/System-Mem-Weak.html#mkWeakPtr",
          "type": "function"
        },
        "index": {
          "description": "specialised version of mkWeak where the key and the value are the same object mkWeakPtr key finalizer mkWeak key key finalizer",
          "hierarchy": "System Mem Weak",
          "module": "System.Mem.Weak",
          "name": "mkWeakPtr",
          "normalized": "a-\u003eMaybe(IO())-\u003eIO(Weak a)",
          "package": "base",
          "partial": "Weak Ptr",
          "signature": "k-\u003eMaybe(IO())-\u003eIO(Weak k)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Mem-Weak.html#v:mkWeakPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMemory-related system things.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.Mem",
          "name": "Mem",
          "package": "base",
          "source": "src/System-Mem.html",
          "type": "module"
        },
        "index": {
          "description": "Memory-related system things",
          "hierarchy": "System Mem",
          "module": "System.Mem",
          "name": "Mem",
          "package": "base",
          "partial": "Mem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Mem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTriggers an immediate garbage collection\n\u003c/p\u003e",
          "module": "System.Mem",
          "name": "performGC",
          "package": "base",
          "signature": "IO ()",
          "source": "src/System-Mem.html#performGC",
          "type": "function"
        },
        "index": {
          "description": "Triggers an immediate garbage collection",
          "hierarchy": "System Mem",
          "module": "System.Mem",
          "name": "performGC",
          "normalized": "IO()",
          "package": "base",
          "partial": "GC",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Mem.html#v:performGC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePOSIX data types: Haskell equivalents of the types defined by the\n \u003ccode\u003e\u003csys/types.h\u003e\u003c/code\u003e C header on a POSIX system.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.Posix.Types",
          "name": "Types",
          "package": "base",
          "source": "src/System-Posix-Types.html",
          "type": "module"
        },
        "index": {
          "description": "POSIX data types Haskell equivalents of the types defined by the sys types.h header on POSIX system",
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "Types",
          "package": "base",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "ByteCount",
          "package": "base",
          "source": "src/System-Posix-Types.html#ByteCount",
          "type": "type"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "ByteCount",
          "package": "base",
          "partial": "Byte Count",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:ByteCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CCc",
          "package": "base",
          "source": "src/System-Posix-Types.html#CCc",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CCc",
          "package": "base",
          "partial": "CCc",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:CCc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CDev",
          "package": "base",
          "source": "src/System-Posix-Types.html#CDev",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CDev",
          "package": "base",
          "partial": "CDev",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:CDev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CGid",
          "package": "base",
          "source": "src/System-Posix-Types.html#CGid",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CGid",
          "package": "base",
          "partial": "CGid",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:CGid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CIno",
          "package": "base",
          "source": "src/System-Posix-Types.html#CIno",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CIno",
          "package": "base",
          "partial": "CIno",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:CIno"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CMode",
          "package": "base",
          "source": "src/System-Posix-Types.html#CMode",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CMode",
          "package": "base",
          "partial": "CMode",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:CMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CNlink",
          "package": "base",
          "source": "src/System-Posix-Types.html#CNlink",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CNlink",
          "package": "base",
          "partial": "CNlink",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:CNlink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "COff",
          "package": "base",
          "source": "src/System-Posix-Types.html#COff",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "COff",
          "package": "base",
          "partial": "COff",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:COff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CPid",
          "package": "base",
          "source": "src/System-Posix-Types.html#CPid",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CPid",
          "package": "base",
          "partial": "CPid",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:CPid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CRLim",
          "package": "base",
          "source": "src/System-Posix-Types.html#CRLim",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CRLim",
          "package": "base",
          "partial": "CRLim",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:CRLim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CSpeed",
          "package": "base",
          "source": "src/System-Posix-Types.html#CSpeed",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CSpeed",
          "package": "base",
          "partial": "CSpeed",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:CSpeed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CSsize",
          "package": "base",
          "source": "src/System-Posix-Types.html#CSsize",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CSsize",
          "package": "base",
          "partial": "CSsize",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:CSsize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CTcflag",
          "package": "base",
          "source": "src/System-Posix-Types.html#CTcflag",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CTcflag",
          "package": "base",
          "partial": "CTcflag",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:CTcflag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CUid",
          "package": "base",
          "source": "src/System-Posix-Types.html#CUid",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CUid",
          "package": "base",
          "partial": "CUid",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:CUid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "ClockTick",
          "package": "base",
          "source": "src/System-Posix-Types.html#ClockTick",
          "type": "type"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "ClockTick",
          "package": "base",
          "partial": "Clock Tick",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:ClockTick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "DeviceID",
          "package": "base",
          "source": "src/System-Posix-Types.html#DeviceID",
          "type": "type"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "DeviceID",
          "package": "base",
          "partial": "Device ID",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:DeviceID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "EpochTime",
          "package": "base",
          "source": "src/System-Posix-Types.html#EpochTime",
          "type": "type"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "EpochTime",
          "package": "base",
          "partial": "Epoch Time",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:EpochTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "Fd",
          "package": "base",
          "source": "src/System-Posix-Types.html#Fd",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "Fd",
          "package": "base",
          "partial": "Fd",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:Fd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "FileID",
          "package": "base",
          "source": "src/System-Posix-Types.html#FileID",
          "type": "type"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "FileID",
          "package": "base",
          "partial": "File ID",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:FileID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "FileMode",
          "package": "base",
          "source": "src/System-Posix-Types.html#FileMode",
          "type": "type"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "FileMode",
          "package": "base",
          "partial": "File Mode",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:FileMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "FileOffset",
          "package": "base",
          "source": "src/System-Posix-Types.html#FileOffset",
          "type": "type"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "FileOffset",
          "package": "base",
          "partial": "File Offset",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:FileOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "GroupID",
          "package": "base",
          "source": "src/System-Posix-Types.html#GroupID",
          "type": "type"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "GroupID",
          "package": "base",
          "partial": "Group ID",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:GroupID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "Limit",
          "package": "base",
          "source": "src/System-Posix-Types.html#Limit",
          "type": "type"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "Limit",
          "package": "base",
          "partial": "Limit",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:Limit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "LinkCount",
          "package": "base",
          "source": "src/System-Posix-Types.html#LinkCount",
          "type": "type"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "LinkCount",
          "package": "base",
          "partial": "Link Count",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:LinkCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "ProcessGroupID",
          "package": "base",
          "source": "src/System-Posix-Types.html#ProcessGroupID",
          "type": "type"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "ProcessGroupID",
          "package": "base",
          "partial": "Process Group ID",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:ProcessGroupID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "ProcessID",
          "package": "base",
          "source": "src/System-Posix-Types.html#ProcessID",
          "type": "type"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "ProcessID",
          "package": "base",
          "partial": "Process ID",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:ProcessID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "UserID",
          "package": "base",
          "source": "src/System-Posix-Types.html#UserID",
          "type": "type"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "UserID",
          "package": "base",
          "partial": "User ID",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#t:UserID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CCc",
          "package": "base",
          "signature": "CCc Word8",
          "source": "src/System-Posix-Types.html#CCc",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CCc",
          "package": "base",
          "partial": "CCc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#v:CCc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CDev",
          "package": "base",
          "signature": "CDev Word64",
          "source": "src/System-Posix-Types.html#CDev",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CDev",
          "package": "base",
          "partial": "CDev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#v:CDev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CGid",
          "package": "base",
          "signature": "CGid Word32",
          "source": "src/System-Posix-Types.html#CGid",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CGid",
          "package": "base",
          "partial": "CGid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#v:CGid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CIno",
          "package": "base",
          "signature": "CIno Word64",
          "source": "src/System-Posix-Types.html#CIno",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CIno",
          "package": "base",
          "partial": "CIno",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#v:CIno"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CMode",
          "package": "base",
          "signature": "CMode Word32",
          "source": "src/System-Posix-Types.html#CMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CMode",
          "package": "base",
          "partial": "CMode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#v:CMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CNlink",
          "package": "base",
          "signature": "CNlink Word64",
          "source": "src/System-Posix-Types.html#CNlink",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CNlink",
          "package": "base",
          "partial": "CNlink",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#v:CNlink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "COff",
          "package": "base",
          "signature": "COff Int64",
          "source": "src/System-Posix-Types.html#COff",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "COff",
          "package": "base",
          "partial": "COff",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#v:COff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CPid",
          "package": "base",
          "signature": "CPid Int32",
          "source": "src/System-Posix-Types.html#CPid",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CPid",
          "package": "base",
          "partial": "CPid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#v:CPid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CRLim",
          "package": "base",
          "signature": "CRLim Word64",
          "source": "src/System-Posix-Types.html#CRLim",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CRLim",
          "package": "base",
          "partial": "CRLim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#v:CRLim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CSpeed",
          "package": "base",
          "signature": "CSpeed Word32",
          "source": "src/System-Posix-Types.html#CSpeed",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CSpeed",
          "package": "base",
          "partial": "CSpeed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#v:CSpeed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CSsize",
          "package": "base",
          "signature": "CSsize Int64",
          "source": "src/System-Posix-Types.html#CSsize",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CSsize",
          "package": "base",
          "partial": "CSsize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#v:CSsize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CTcflag",
          "package": "base",
          "signature": "CTcflag Word32",
          "source": "src/System-Posix-Types.html#CTcflag",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CTcflag",
          "package": "base",
          "partial": "CTcflag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#v:CTcflag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "CUid",
          "package": "base",
          "signature": "CUid Word32",
          "source": "src/System-Posix-Types.html#CUid",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "CUid",
          "package": "base",
          "partial": "CUid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#v:CUid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.Posix.Types",
          "name": "Fd",
          "package": "base",
          "signature": "Fd CInt",
          "source": "src/System-Posix-Types.html#Fd",
          "type": "function"
        },
        "index": {
          "hierarchy": "System Posix Types",
          "module": "System.Posix.Types",
          "name": "Fd",
          "package": "base",
          "partial": "Fd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Posix-Types.html#v:Fd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAttach a timeout event to arbitrary \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e computations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.Timeout",
          "name": "Timeout",
          "package": "base",
          "source": "src/System-Timeout.html",
          "type": "module"
        },
        "index": {
          "description": "Attach timeout event to arbitrary IO computations",
          "hierarchy": "System Timeout",
          "module": "System.Timeout",
          "name": "Timeout",
          "package": "base",
          "partial": "Timeout",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Timeout.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap an \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e computation to time out and return \u003ccode\u003eNothing\u003c/code\u003e in case no result\n is available within \u003ccode\u003en\u003c/code\u003e microseconds (\u003ccode\u003e1/10^6\u003c/code\u003e seconds). In case a result\n is available before the timeout expires, \u003ccode\u003eJust a\u003c/code\u003e is returned. A negative\n timeout interval means \"wait indefinitely\". When specifying long timeouts,\n be careful not to exceed \u003ccode\u003emaxBound :: Int\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe design of this combinator was guided by the objective that \u003ccode\u003etimeout n f\u003c/code\u003e\n should behave exactly the same as \u003ccode\u003ef\u003c/code\u003e as long as \u003ccode\u003ef\u003c/code\u003e doesn't time out. This\n means that \u003ccode\u003ef\u003c/code\u003e has the same \u003ccode\u003e\u003ca\u003emyThreadId\u003c/a\u003e\u003c/code\u003e it would have without the timeout\n wrapper. Any exceptions \u003ccode\u003ef\u003c/code\u003e might throw cancel the timeout and propagate\n further up. It also possible for \u003ccode\u003ef\u003c/code\u003e to receive exceptions thrown to it by\n another thread.\n\u003c/p\u003e\u003cp\u003eA tricky implementation detail is the question of how to abort an \u003ccode\u003eIO\u003c/code\u003e\n computation. This combinator relies on asynchronous exceptions internally.\n The technique works very well for computations executing inside of the\n Haskell runtime system, but it doesn't work at all for non-Haskell code.\n Foreign function calls, for example, cannot be timed out with this\n combinator simply because an arbitrary C function cannot receive\n asynchronous exceptions. When \u003ccode\u003etimeout\u003c/code\u003e is used to wrap an FFI call that\n blocks, no timeout event can be delivered until the FFI call returns, which\n pretty much negates the purpose of the combinator. In practice, however,\n this limitation is less severe than it may sound. Standard I/O functions\n like \u003ccode\u003e\u003ca\u003ehGetBuf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ehPutBuf\u003c/a\u003e\u003c/code\u003e, Network.Socket.accept, or\n \u003ccode\u003e\u003ca\u003ehWaitForInput\u003c/a\u003e\u003c/code\u003e appear to be blocking, but they really don't\n because the runtime system uses scheduling mechanisms like \u003ccode\u003eselect(2)\u003c/code\u003e to\n perform asynchronous I/O, so it is possible to interrupt standard socket\n I/O or file I/O using this combinator.\n\u003c/p\u003e",
          "module": "System.Timeout",
          "name": "timeout",
          "package": "base",
          "signature": "Int -\u003e IO a -\u003e IO (Maybe a)",
          "source": "src/System-Timeout.html#timeout",
          "type": "function"
        },
        "index": {
          "description": "Wrap an IO computation to time out and return Nothing in case no result is available within microseconds seconds In case result is available before the timeout expires Just is returned negative timeout interval means wait indefinitely When specifying long timeouts be careful not to exceed maxBound Int The design of this combinator was guided by the objective that timeout should behave exactly the same as as long as doesn time out This means that has the same myThreadId it would have without the timeout wrapper Any exceptions might throw cancel the timeout and propagate further up It also possible for to receive exceptions thrown to it by another thread tricky implementation detail is the question of how to abort an IO computation This combinator relies on asynchronous exceptions internally The technique works very well for computations executing inside of the Haskell runtime system but it doesn work at all for non-Haskell code Foreign function calls for example cannot be timed out with this combinator simply because an arbitrary function cannot receive asynchronous exceptions When timeout is used to wrap an FFI call that blocks no timeout event can be delivered until the FFI call returns which pretty much negates the purpose of the combinator In practice however this limitation is less severe than it may sound Standard functions like hGetBuf hPutBuf Network.Socket.accept or hWaitForInput appear to be blocking but they really don because the runtime system uses scheduling mechanisms like select to perform asynchronous so it is possible to interrupt standard socket or file using this combinator",
          "hierarchy": "System Timeout",
          "module": "System.Timeout",
          "name": "timeout",
          "normalized": "Int-\u003eIO a-\u003eIO(Maybe a)",
          "package": "base",
          "signature": "Int-\u003eIO a-\u003eIO(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/System-Timeout.html#v:timeout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is a library of parser combinators, originally written by Koen Claessen.\n It parses all alternatives in parallel, so it never keeps hold of \n the beginning of the input string, a common source of space leaks with\n other parsers.  The '(+++)' choice combinator is genuinely commutative;\n it makes no difference which branch is \"shorter\".\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "ReadP",
          "package": "base",
          "source": "src/Text-ParserCombinators-ReadP.html",
          "type": "module"
        },
        "index": {
          "description": "This is library of parser combinators originally written by Koen Claessen It parses all alternatives in parallel so it never keeps hold of the beginning of the input string common source of space leaks with other parsers The choice combinator is genuinely commutative it makes no difference which branch is shorter",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "ReadP",
          "package": "base",
          "partial": "Read",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.ReadP",
          "name": "ReadP",
          "package": "base",
          "source": "src/Text-ParserCombinators-ReadP.html#ReadP",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "ReadP",
          "package": "base",
          "partial": "Read",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#t:ReadP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA parser for a type \u003ccode\u003ea\u003c/code\u003e, represented as a function that takes a\n \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e and returns a list of possible parses as \u003ccode\u003e(a,\u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e pairs.\n\u003c/p\u003e\u003cp\u003eNote that this kind of backtracking parser is very inefficient;\n reading a large structure may be quite slow (cf \u003ccode\u003e\u003ca\u003eReadP\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "ReadS",
          "package": "base",
          "source": "src/Text-ParserCombinators-ReadP.html#ReadS",
          "type": "type"
        },
        "index": {
          "description": "parser for type represented as function that takes String and returns list of possible parses as String pairs Note that this kind of backtracking parser is very inefficient reading large structure may be quite slow cf ReadP",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "ReadS",
          "package": "base",
          "partial": "Read",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#t:ReadS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSymmetric choice.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "(+++)",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP a -\u003e ReadP a",
          "source": "src/Text-ParserCombinators-ReadP.html#%2B%2B%2B",
          "type": "function"
        },
        "index": {
          "description": "Symmetric choice",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "(+++) +++",
          "normalized": "ReadP a-\u003eReadP a-\u003eReadP a",
          "package": "base",
          "signature": "ReadP a-\u003eReadP a-\u003eReadP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:-43--43--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLocal, exclusive, left-biased choice: If left parser\n   locally produces any result at all, then right parser is\n   not used.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "(\u003c++)",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP a -\u003e ReadP a",
          "source": "src/Text-ParserCombinators-ReadP.html#%3C%2B%2B",
          "type": "function"
        },
        "index": {
          "description": "Local exclusive left-biased choice If left parser locally produces any result at all then right parser is not used",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "(\u003c++) \u003c++",
          "normalized": "ReadP a-\u003eReadP a-\u003eReadP a",
          "package": "base",
          "signature": "ReadP a-\u003eReadP a-\u003eReadP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:-60--43--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ebetween open close p\u003c/code\u003e parses \u003ccode\u003eopen\u003c/code\u003e, followed by \u003ccode\u003ep\u003c/code\u003e and finally\n   \u003ccode\u003eclose\u003c/code\u003e. Only the value of \u003ccode\u003ep\u003c/code\u003e is returned.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "between",
          "package": "base",
          "signature": "ReadP open -\u003e ReadP close -\u003e ReadP a -\u003e ReadP a",
          "source": "src/Text-ParserCombinators-ReadP.html#between",
          "type": "function"
        },
        "index": {
          "description": "between open close parses open followed by and finally close Only the value of is returned",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "between",
          "normalized": "ReadP a-\u003eReadP b-\u003eReadP c-\u003eReadP c",
          "package": "base",
          "signature": "ReadP open-\u003eReadP close-\u003eReadP a-\u003eReadP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:between"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003echainl p op x\u003c/code\u003e parses zero or more occurrences of \u003ccode\u003ep\u003c/code\u003e, separated by \u003ccode\u003eop\u003c/code\u003e.\n   Returns a value produced by a \u003cem\u003eleft\u003c/em\u003e associative application of all\n   functions returned by \u003ccode\u003eop\u003c/code\u003e. If there are no occurrences of \u003ccode\u003ep\u003c/code\u003e, \u003ccode\u003ex\u003c/code\u003e is\n   returned.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "chainl",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP (a -\u003e a -\u003e a) -\u003e a -\u003e ReadP a",
          "source": "src/Text-ParserCombinators-ReadP.html#chainl",
          "type": "function"
        },
        "index": {
          "description": "chainl op parses zero or more occurrences of separated by op Returns value produced by left associative application of all functions returned by op If there are no occurrences of is returned",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "chainl",
          "normalized": "ReadP a-\u003eReadP(a-\u003ea-\u003ea)-\u003ea-\u003eReadP a",
          "package": "base",
          "signature": "ReadP a-\u003eReadP(a-\u003ea-\u003ea)-\u003ea-\u003eReadP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:chainl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003echainl\u003c/a\u003e\u003c/code\u003e, but parses one or more occurrences of \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "chainl1",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP (a -\u003e a -\u003e a) -\u003e ReadP a",
          "source": "src/Text-ParserCombinators-ReadP.html#chainl1",
          "type": "function"
        },
        "index": {
          "description": "Like chainl but parses one or more occurrences of",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "chainl1",
          "normalized": "ReadP a-\u003eReadP(a-\u003ea-\u003ea)-\u003eReadP a",
          "package": "base",
          "signature": "ReadP a-\u003eReadP(a-\u003ea-\u003ea)-\u003eReadP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:chainl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003echainr p op x\u003c/code\u003e parses zero or more occurrences of \u003ccode\u003ep\u003c/code\u003e, separated by \u003ccode\u003eop\u003c/code\u003e.\n   Returns a value produced by a \u003cem\u003eright\u003c/em\u003e associative application of all\n   functions returned by \u003ccode\u003eop\u003c/code\u003e. If there are no occurrences of \u003ccode\u003ep\u003c/code\u003e, \u003ccode\u003ex\u003c/code\u003e is\n   returned.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "chainr",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP (a -\u003e a -\u003e a) -\u003e a -\u003e ReadP a",
          "source": "src/Text-ParserCombinators-ReadP.html#chainr",
          "type": "function"
        },
        "index": {
          "description": "chainr op parses zero or more occurrences of separated by op Returns value produced by right associative application of all functions returned by op If there are no occurrences of is returned",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "chainr",
          "normalized": "ReadP a-\u003eReadP(a-\u003ea-\u003ea)-\u003ea-\u003eReadP a",
          "package": "base",
          "signature": "ReadP a-\u003eReadP(a-\u003ea-\u003ea)-\u003ea-\u003eReadP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:chainr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003echainr\u003c/a\u003e\u003c/code\u003e, but parses one or more occurrences of \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "chainr1",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP (a -\u003e a -\u003e a) -\u003e ReadP a",
          "source": "src/Text-ParserCombinators-ReadP.html#chainr1",
          "type": "function"
        },
        "index": {
          "description": "Like chainr but parses one or more occurrences of",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "chainr1",
          "normalized": "ReadP a-\u003eReadP(a-\u003ea-\u003ea)-\u003eReadP a",
          "package": "base",
          "signature": "ReadP a-\u003eReadP(a-\u003ea-\u003ea)-\u003eReadP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:chainr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses and returns the specified character.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "char",
          "package": "base",
          "signature": "Char -\u003e ReadP Char",
          "source": "src/Text-ParserCombinators-ReadP.html#char",
          "type": "function"
        },
        "index": {
          "description": "Parses and returns the specified character",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "char",
          "normalized": "Char-\u003eReadP Char",
          "package": "base",
          "signature": "Char-\u003eReadP Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombines all parsers in the specified list.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "choice",
          "package": "base",
          "signature": "[ReadP a] -\u003e ReadP a",
          "source": "src/Text-ParserCombinators-ReadP.html#choice",
          "type": "function"
        },
        "index": {
          "description": "Combines all parsers in the specified list",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "choice",
          "normalized": "[ReadP a]-\u003eReadP a",
          "package": "base",
          "signature": "[ReadP a]-\u003eReadP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:choice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecount n p\u003c/code\u003e parses \u003ccode\u003en\u003c/code\u003e occurrences of \u003ccode\u003ep\u003c/code\u003e in sequence. A list of\n   results is returned.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "count",
          "package": "base",
          "signature": "Int -\u003e ReadP a -\u003e ReadP [a]",
          "source": "src/Text-ParserCombinators-ReadP.html#count",
          "type": "function"
        },
        "index": {
          "description": "count parses occurrences of in sequence list of results is returned",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "count",
          "normalized": "Int-\u003eReadP a-\u003eReadP[a]",
          "package": "base",
          "signature": "Int-\u003eReadP a-\u003eReadP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:count"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eendBy p sep\u003c/code\u003e parses zero or more occurrences of \u003ccode\u003ep\u003c/code\u003e, separated and ended\n   by \u003ccode\u003esep\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "endBy",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP sep -\u003e ReadP [a]",
          "source": "src/Text-ParserCombinators-ReadP.html#endBy",
          "type": "function"
        },
        "index": {
          "description": "endBy sep parses zero or more occurrences of separated and ended by sep",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "endBy",
          "normalized": "ReadP a-\u003eReadP b-\u003eReadP[a]",
          "package": "base",
          "partial": "By",
          "signature": "ReadP a-\u003eReadP sep-\u003eReadP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:endBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eendBy p sep\u003c/code\u003e parses one or more occurrences of \u003ccode\u003ep\u003c/code\u003e, separated and ended\n   by \u003ccode\u003esep\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "endBy1",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP sep -\u003e ReadP [a]",
          "source": "src/Text-ParserCombinators-ReadP.html#endBy1",
          "type": "function"
        },
        "index": {
          "description": "endBy sep parses one or more occurrences of separated and ended by sep",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "endBy1",
          "normalized": "ReadP a-\u003eReadP b-\u003eReadP[a]",
          "package": "base",
          "partial": "By",
          "signature": "ReadP a-\u003eReadP sep-\u003eReadP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:endBy1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSucceeds iff we are at the end of input\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "eof",
          "package": "base",
          "signature": "ReadP ()",
          "source": "src/Text-ParserCombinators-ReadP.html#eof",
          "type": "function"
        },
        "index": {
          "description": "Succeeds iff we are at the end of input",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "eof",
          "normalized": "ReadP()",
          "package": "base",
          "signature": "ReadP()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:eof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransforms a parser into one that does the same, but\n   in addition returns the exact characters read.\n   IMPORTANT NOTE: \u003ccode\u003e\u003ca\u003egather\u003c/a\u003e\u003c/code\u003e gives a runtime error if its first argument\n   is built using any occurrences of readS_to_P. \n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "gather",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP (String, a)",
          "source": "src/Text-ParserCombinators-ReadP.html#gather",
          "type": "function"
        },
        "index": {
          "description": "Transforms parser into one that does the same but in addition returns the exact characters read IMPORTANT NOTE gather gives runtime error if its first argument is built using any occurrences of readS to",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "gather",
          "normalized": "ReadP a-\u003eReadP(String,a)",
          "package": "base",
          "signature": "ReadP a-\u003eReadP(String,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:gather"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConsumes and returns the next character.\n   Fails if there is no input left.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "get",
          "package": "base",
          "signature": "ReadP Char",
          "source": "src/Text-ParserCombinators-ReadP.html#get",
          "type": "function"
        },
        "index": {
          "description": "Consumes and returns the next character Fails if there is no input left",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "get",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:get"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLook-ahead: returns the part of the input that is left, without\n   consuming it.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "look",
          "package": "base",
          "signature": "ReadP String",
          "source": "src/Text-ParserCombinators-ReadP.html#look",
          "type": "function"
        },
        "index": {
          "description": "Look-ahead returns the part of the input that is left without consuming it",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "look",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:look"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses zero or more occurrences of the given parser.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "many",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP [a]",
          "source": "src/Text-ParserCombinators-ReadP.html#many",
          "type": "function"
        },
        "index": {
          "description": "Parses zero or more occurrences of the given parser",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "many",
          "normalized": "ReadP a-\u003eReadP[a]",
          "package": "base",
          "signature": "ReadP a-\u003eReadP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:many"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses one or more occurrences of the given parser.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "many1",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP [a]",
          "source": "src/Text-ParserCombinators-ReadP.html#many1",
          "type": "function"
        },
        "index": {
          "description": "Parses one or more occurrences of the given parser",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "many1",
          "normalized": "ReadP a-\u003eReadP[a]",
          "package": "base",
          "signature": "ReadP a-\u003eReadP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:many1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emanyTill p end\u003c/code\u003e parses zero or more occurrences of \u003ccode\u003ep\u003c/code\u003e, until \u003ccode\u003eend\u003c/code\u003e\n   succeeds. Returns a list of values returned by \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "manyTill",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP end -\u003e ReadP [a]",
          "source": "src/Text-ParserCombinators-ReadP.html#manyTill",
          "type": "function"
        },
        "index": {
          "description": "manyTill end parses zero or more occurrences of until end succeeds Returns list of values returned by",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "manyTill",
          "normalized": "ReadP a-\u003eReadP b-\u003eReadP[a]",
          "package": "base",
          "partial": "Till",
          "signature": "ReadP a-\u003eReadP end-\u003eReadP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:manyTill"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses the first zero or more characters satisfying the predicate.\n   Always succeds, exactly once having consumed all the characters\n   Hence NOT the same as (many (satisfy p))\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "munch",
          "package": "base",
          "signature": "(Char -\u003e Bool) -\u003e ReadP String",
          "source": "src/Text-ParserCombinators-ReadP.html#munch",
          "type": "function"
        },
        "index": {
          "description": "Parses the first zero or more characters satisfying the predicate Always succeds exactly once having consumed all the characters Hence NOT the same as many satisfy",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "munch",
          "normalized": "(Char-\u003eBool)-\u003eReadP String",
          "package": "base",
          "signature": "(Char-\u003eBool)-\u003eReadP String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:munch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses the first one or more characters satisfying the predicate.\n   Fails if none, else succeeds exactly once having consumed all the characters\n   Hence NOT the same as (many1 (satisfy p))\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "munch1",
          "package": "base",
          "signature": "(Char -\u003e Bool) -\u003e ReadP String",
          "source": "src/Text-ParserCombinators-ReadP.html#munch1",
          "type": "function"
        },
        "index": {
          "description": "Parses the first one or more characters satisfying the predicate Fails if none else succeeds exactly once having consumed all the characters Hence NOT the same as many1 satisfy",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "munch1",
          "normalized": "(Char-\u003eBool)-\u003eReadP String",
          "package": "base",
          "signature": "(Char-\u003eBool)-\u003eReadP String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:munch1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eoption x p\u003c/code\u003e will either parse \u003ccode\u003ep\u003c/code\u003e or return \u003ccode\u003ex\u003c/code\u003e without consuming\n   any input.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "option",
          "package": "base",
          "signature": "a -\u003e ReadP a -\u003e ReadP a",
          "source": "src/Text-ParserCombinators-ReadP.html#option",
          "type": "function"
        },
        "index": {
          "description": "option will either parse or return without consuming any input",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "option",
          "normalized": "a-\u003eReadP a-\u003eReadP a",
          "package": "base",
          "signature": "a-\u003eReadP a-\u003eReadP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:option"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eoptional p\u003c/code\u003e optionally parses \u003ccode\u003ep\u003c/code\u003e and always returns \u003ccode\u003e()\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "optional",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP ()",
          "source": "src/Text-ParserCombinators-ReadP.html#optional",
          "type": "function"
        },
        "index": {
          "description": "optional optionally parses and always returns",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "optional",
          "normalized": "ReadP a-\u003eReadP()",
          "package": "base",
          "signature": "ReadP a-\u003eReadP()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:optional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlways fails.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "pfail",
          "package": "base",
          "signature": "ReadP a",
          "source": "src/Text-ParserCombinators-ReadP.html#pfail",
          "type": "function"
        },
        "index": {
          "description": "Always fails",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "pfail",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:pfail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a parser into a Haskell ReadS-style function.\n   This is the main way in which you can \"run\" a \u003ccode\u003e\u003ca\u003eReadP\u003c/a\u003e\u003c/code\u003e parser:\n   the expanded type is\n \u003ccode\u003e readP_to_S :: ReadP a -\u003e String -\u003e [(a,String)] \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "readP_to_S",
          "package": "base",
          "signature": "ReadP a -\u003e ReadS a",
          "source": "src/Text-ParserCombinators-ReadP.html#readP_to_S",
          "type": "function"
        },
        "index": {
          "description": "Converts parser into Haskell ReadS-style function This is the main way in which you can run ReadP parser the expanded type is readP to ReadP String String",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "readP_to_S",
          "normalized": "ReadP a-\u003eReadS a",
          "package": "base",
          "signature": "ReadP a-\u003eReadS a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:readP_to_S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a Haskell ReadS-style function into a parser.\n   Warning: This introduces local backtracking in the resulting\n   parser, and therefore a possible inefficiency.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "readS_to_P",
          "package": "base",
          "signature": "ReadS a -\u003e ReadP a",
          "source": "src/Text-ParserCombinators-ReadP.html#readS_to_P",
          "type": "function"
        },
        "index": {
          "description": "Converts Haskell ReadS-style function into parser Warning This introduces local backtracking in the resulting parser and therefore possible inefficiency",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "readS_to_P",
          "normalized": "ReadS a-\u003eReadP a",
          "package": "base",
          "signature": "ReadS a-\u003eReadP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:readS_to_P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConsumes and returns the next character, if it satisfies the\n   specified predicate.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "satisfy",
          "package": "base",
          "signature": "(Char -\u003e Bool) -\u003e ReadP Char",
          "source": "src/Text-ParserCombinators-ReadP.html#satisfy",
          "type": "function"
        },
        "index": {
          "description": "Consumes and returns the next character if it satisfies the specified predicate",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "satisfy",
          "normalized": "(Char-\u003eBool)-\u003eReadP Char",
          "package": "base",
          "signature": "(Char-\u003eBool)-\u003eReadP Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:satisfy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esepBy p sep\u003c/code\u003e parses zero or more occurrences of \u003ccode\u003ep\u003c/code\u003e, separated by \u003ccode\u003esep\u003c/code\u003e.\n   Returns a list of values returned by \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "sepBy",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP sep -\u003e ReadP [a]",
          "source": "src/Text-ParserCombinators-ReadP.html#sepBy",
          "type": "function"
        },
        "index": {
          "description": "sepBy sep parses zero or more occurrences of separated by sep Returns list of values returned by",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "sepBy",
          "normalized": "ReadP a-\u003eReadP b-\u003eReadP[a]",
          "package": "base",
          "partial": "By",
          "signature": "ReadP a-\u003eReadP sep-\u003eReadP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:sepBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esepBy1 p sep\u003c/code\u003e parses one or more occurrences of \u003ccode\u003ep\u003c/code\u003e, separated by \u003ccode\u003esep\u003c/code\u003e.\n   Returns a list of values returned by \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "sepBy1",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP sep -\u003e ReadP [a]",
          "source": "src/Text-ParserCombinators-ReadP.html#sepBy1",
          "type": "function"
        },
        "index": {
          "description": "sepBy1 sep parses one or more occurrences of separated by sep Returns list of values returned by",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "sepBy1",
          "normalized": "ReadP a-\u003eReadP b-\u003eReadP[a]",
          "package": "base",
          "partial": "By",
          "signature": "ReadP a-\u003eReadP sep-\u003eReadP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:sepBy1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003emany\u003c/a\u003e\u003c/code\u003e, but discards the result.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "skipMany",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP ()",
          "source": "src/Text-ParserCombinators-ReadP.html#skipMany",
          "type": "function"
        },
        "index": {
          "description": "Like many but discards the result",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "skipMany",
          "normalized": "ReadP a-\u003eReadP()",
          "package": "base",
          "partial": "Many",
          "signature": "ReadP a-\u003eReadP()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:skipMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003emany1\u003c/a\u003e\u003c/code\u003e, but discards the result.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "skipMany1",
          "package": "base",
          "signature": "ReadP a -\u003e ReadP ()",
          "source": "src/Text-ParserCombinators-ReadP.html#skipMany1",
          "type": "function"
        },
        "index": {
          "description": "Like many1 but discards the result",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "skipMany1",
          "normalized": "ReadP a-\u003eReadP()",
          "package": "base",
          "partial": "Many",
          "signature": "ReadP a-\u003eReadP()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:skipMany1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSkips all whitespace.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "skipSpaces",
          "package": "base",
          "signature": "ReadP ()",
          "source": "src/Text-ParserCombinators-ReadP.html#skipSpaces",
          "type": "function"
        },
        "index": {
          "description": "Skips all whitespace",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "skipSpaces",
          "normalized": "ReadP()",
          "package": "base",
          "partial": "Spaces",
          "signature": "ReadP()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:skipSpaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses and returns the specified string.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadP",
          "name": "string",
          "package": "base",
          "signature": "String -\u003e ReadP String",
          "source": "src/Text-ParserCombinators-ReadP.html#string",
          "type": "function"
        },
        "index": {
          "description": "Parses and returns the specified string",
          "hierarchy": "Text ParserCombinators ReadP",
          "module": "Text.ParserCombinators.ReadP",
          "name": "string",
          "normalized": "String-\u003eReadP String",
          "package": "base",
          "signature": "String-\u003eReadP String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html#v:string"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis library defines parser combinators for precedence parsing.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "ReadPrec",
          "package": "base",
          "source": "src/Text-ParserCombinators-ReadPrec.html",
          "type": "module"
        },
        "index": {
          "description": "This library defines parser combinators for precedence parsing",
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "ReadPrec",
          "package": "base",
          "partial": "Read Prec",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "Prec",
          "package": "base",
          "source": "src/Text-ParserCombinators-ReadPrec.html#Prec",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "Prec",
          "package": "base",
          "partial": "Prec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#t:Prec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "ReadPrec",
          "package": "base",
          "source": "src/Text-ParserCombinators-ReadPrec.html#ReadPrec",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "ReadPrec",
          "package": "base",
          "partial": "Read Prec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#t:ReadPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSymmetric choice.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "(+++)",
          "package": "base",
          "signature": "ReadPrec a -\u003e ReadPrec a -\u003e ReadPrec a",
          "source": "src/Text-ParserCombinators-ReadPrec.html#%2B%2B%2B",
          "type": "function"
        },
        "index": {
          "description": "Symmetric choice",
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "(+++) +++",
          "normalized": "ReadPrec a-\u003eReadPrec a-\u003eReadPrec a",
          "package": "base",
          "signature": "ReadPrec a-\u003eReadPrec a-\u003eReadPrec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:-43--43--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLocal, exclusive, left-biased choice: If left parser\n   locally produces any result at all, then right parser is\n   not used.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "(\u003c++)",
          "package": "base",
          "signature": "ReadPrec a -\u003e ReadPrec a -\u003e ReadPrec a",
          "source": "src/Text-ParserCombinators-ReadPrec.html#%3C%2B%2B",
          "type": "function"
        },
        "index": {
          "description": "Local exclusive left-biased choice If left parser locally produces any result at all then right parser is not used",
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "(\u003c++) \u003c++",
          "normalized": "ReadPrec a-\u003eReadPrec a-\u003eReadPrec a",
          "package": "base",
          "signature": "ReadPrec a-\u003eReadPrec a-\u003eReadPrec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:-60--43--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombines all parsers in the specified list.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "choice",
          "package": "base",
          "signature": "[ReadPrec a] -\u003e ReadPrec a",
          "source": "src/Text-ParserCombinators-ReadPrec.html#choice",
          "type": "function"
        },
        "index": {
          "description": "Combines all parsers in the specified list",
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "choice",
          "normalized": "[ReadPrec a]-\u003eReadPrec a",
          "package": "base",
          "signature": "[ReadPrec a]-\u003eReadPrec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:choice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConsumes and returns the next character.\n   Fails if there is no input left.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "get",
          "package": "base",
          "signature": "ReadPrec Char",
          "source": "src/Text-ParserCombinators-ReadPrec.html#get",
          "type": "function"
        },
        "index": {
          "description": "Consumes and returns the next character Fails if there is no input left",
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "get",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:get"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a precedence-insensitive \u003ccode\u003e\u003ca\u003eReadP\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eReadPrec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "lift",
          "package": "base",
          "signature": "ReadP a -\u003e ReadPrec a",
          "source": "src/Text-ParserCombinators-ReadPrec.html#lift",
          "type": "function"
        },
        "index": {
          "description": "Lift precedence-insensitive ReadP to ReadPrec",
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "lift",
          "normalized": "ReadP a-\u003eReadPrec a",
          "package": "base",
          "signature": "ReadP a-\u003eReadPrec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:lift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLook-ahead: returns the part of the input that is left, without\n   consuming it.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "look",
          "package": "base",
          "signature": "ReadPrec String",
          "source": "src/Text-ParserCombinators-ReadPrec.html#look",
          "type": "function"
        },
        "index": {
          "description": "Look-ahead returns the part of the input that is left without consuming it",
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "look",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:look"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "minPrec",
          "package": "base",
          "signature": "Prec",
          "source": "src/Text-ParserCombinators-ReadPrec.html#minPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "minPrec",
          "package": "base",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:minPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlways fails.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "pfail",
          "package": "base",
          "signature": "ReadPrec a",
          "source": "src/Text-ParserCombinators-ReadPrec.html#pfail",
          "type": "function"
        },
        "index": {
          "description": "Always fails",
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "pfail",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:pfail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e(prec n p)\u003c/code\u003e checks whether the precedence context is \n   less than or equal to \u003ccode\u003en\u003c/code\u003e, and\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e if not, fails\n\u003c/li\u003e\u003cli\u003e if so, parses \u003ccode\u003ep\u003c/code\u003e in context \u003ccode\u003en\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "prec",
          "package": "base",
          "signature": "Prec -\u003e ReadPrec a -\u003e ReadPrec a",
          "source": "src/Text-ParserCombinators-ReadPrec.html#prec",
          "type": "function"
        },
        "index": {
          "description": "prec checks whether the precedence context is less than or equal to and if not fails if so parses in context",
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "prec",
          "normalized": "Prec-\u003eReadPrec a-\u003eReadPrec a",
          "package": "base",
          "signature": "Prec-\u003eReadPrec a-\u003eReadPrec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:prec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "readP_to_Prec",
          "package": "base",
          "signature": "(Int -\u003e ReadP a) -\u003e ReadPrec a",
          "source": "src/Text-ParserCombinators-ReadPrec.html#readP_to_Prec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "readP_to_Prec",
          "normalized": "(Int-\u003eReadP a)-\u003eReadPrec a",
          "package": "base",
          "partial": "Prec",
          "signature": "(Int-\u003eReadP a)-\u003eReadPrec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:readP_to_Prec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "readPrec_to_P",
          "package": "base",
          "signature": "ReadPrec a -\u003e Int -\u003e ReadP a",
          "source": "src/Text-ParserCombinators-ReadPrec.html#readPrec_to_P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "readPrec_to_P",
          "normalized": "ReadPrec a-\u003eInt-\u003eReadP a",
          "package": "base",
          "partial": "Prec",
          "signature": "ReadPrec a-\u003eInt-\u003eReadP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:readPrec_to_P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "readPrec_to_S",
          "package": "base",
          "signature": "ReadPrec a -\u003e Int -\u003e ReadS a",
          "source": "src/Text-ParserCombinators-ReadPrec.html#readPrec_to_S",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "readPrec_to_S",
          "normalized": "ReadPrec a-\u003eInt-\u003eReadS a",
          "package": "base",
          "partial": "Prec",
          "signature": "ReadPrec a-\u003eInt-\u003eReadS a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:readPrec_to_S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "readS_to_Prec",
          "package": "base",
          "signature": "(Int -\u003e ReadS a) -\u003e ReadPrec a",
          "source": "src/Text-ParserCombinators-ReadPrec.html#readS_to_Prec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "readS_to_Prec",
          "normalized": "(Int-\u003eReadS a)-\u003eReadPrec a",
          "package": "base",
          "partial": "Prec",
          "signature": "(Int-\u003eReadS a)-\u003eReadPrec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:readS_to_Prec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResets the precedence context to zero.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "reset",
          "package": "base",
          "signature": "ReadPrec a -\u003e ReadPrec a",
          "source": "src/Text-ParserCombinators-ReadPrec.html#reset",
          "type": "function"
        },
        "index": {
          "description": "Resets the precedence context to zero",
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "reset",
          "normalized": "ReadPrec a-\u003eReadPrec a",
          "package": "base",
          "signature": "ReadPrec a-\u003eReadPrec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:reset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncreases the precedence context by one.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "step",
          "package": "base",
          "signature": "ReadPrec a -\u003e ReadPrec a",
          "source": "src/Text-ParserCombinators-ReadPrec.html#step",
          "type": "function"
        },
        "index": {
          "description": "Increases the precedence context by one",
          "hierarchy": "Text ParserCombinators ReadPrec",
          "module": "Text.ParserCombinators.ReadPrec",
          "name": "step",
          "normalized": "ReadPrec a-\u003eReadPrec a",
          "package": "base",
          "signature": "ReadPrec a-\u003eReadPrec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadPrec.html#v:step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA C printf like formatter.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Printf",
          "name": "Printf",
          "package": "base",
          "source": "src/Text-Printf.html",
          "type": "module"
        },
        "index": {
          "description": "printf like formatter",
          "hierarchy": "Text Printf",
          "module": "Text.Printf",
          "name": "Printf",
          "package": "base",
          "partial": "Printf",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Printf.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eHPrintfType\u003c/a\u003e\u003c/code\u003e class provides the variable argument magic for\n \u003ccode\u003e\u003ca\u003ehPrintf\u003c/a\u003e\u003c/code\u003e.  Its implementation is intentionally not visible from\n this module.\n\u003c/p\u003e",
          "module": "Text.Printf",
          "name": "HPrintfType",
          "package": "base",
          "source": "src/Text-Printf.html#HPrintfType",
          "type": "class"
        },
        "index": {
          "description": "The HPrintfType class provides the variable argument magic for hPrintf Its implementation is intentionally not visible from this module",
          "hierarchy": "Text Printf",
          "module": "Text.Printf",
          "name": "HPrintfType",
          "package": "base",
          "partial": "HPrintf Type",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Printf.html#t:HPrintfType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Printf",
          "name": "IsChar",
          "package": "base",
          "source": "src/Text-Printf.html#IsChar",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text Printf",
          "module": "Text.Printf",
          "name": "IsChar",
          "package": "base",
          "partial": "Is Char",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Printf.html#t:IsChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Printf",
          "name": "PrintfArg",
          "package": "base",
          "source": "src/Text-Printf.html#PrintfArg",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text Printf",
          "module": "Text.Printf",
          "name": "PrintfArg",
          "package": "base",
          "partial": "Printf Arg",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Printf.html#t:PrintfArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ePrintfType\u003c/a\u003e\u003c/code\u003e class provides the variable argument magic for\n \u003ccode\u003e\u003ca\u003eprintf\u003c/a\u003e\u003c/code\u003e.  Its implementation is intentionally not visible from\n this module. If you attempt to pass an argument of a type which\n is not an instance of this class to \u003ccode\u003e\u003ca\u003eprintf\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ehPrintf\u003c/a\u003e\u003c/code\u003e, then\n the compiler will report it as a missing instance of \u003ccode\u003e\u003ca\u003ePrintfArg\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.Printf",
          "name": "PrintfType",
          "package": "base",
          "source": "src/Text-Printf.html#PrintfType",
          "type": "class"
        },
        "index": {
          "description": "The PrintfType class provides the variable argument magic for printf Its implementation is intentionally not visible from this module If you attempt to pass an argument of type which is not an instance of this class to printf or hPrintf then the compiler will report it as missing instance of PrintfArg",
          "hierarchy": "Text Printf",
          "module": "Text.Printf",
          "name": "PrintfType",
          "package": "base",
          "partial": "Printf Type",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Printf.html#t:PrintfType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003eprintf\u003c/a\u003e\u003c/code\u003e, except that output is via the specified\n \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.  The return type is restricted to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e a)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.Printf",
          "name": "hPrintf",
          "package": "base",
          "signature": "Handle -\u003e String -\u003e r",
          "source": "src/Text-Printf.html#hPrintf",
          "type": "function"
        },
        "index": {
          "description": "Similar to printf except that output is via the specified Handle The return type is restricted to IO",
          "hierarchy": "Text Printf",
          "module": "Text.Printf",
          "name": "hPrintf",
          "normalized": "Handle-\u003eString-\u003ea",
          "package": "base",
          "partial": "Printf",
          "signature": "Handle-\u003eString-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Printf.html#v:hPrintf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormat a variable number of arguments with the C-style formatting string.\n The return value is either \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e a)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe format string consists of ordinary characters and /conversion\n specifications/, which specify how to format one of the arguments\n to printf in the output string.  A conversion specification begins with the\n character \u003ccode\u003e%\u003c/code\u003e, followed by one or more of the following flags:\n\u003c/p\u003e\u003cpre\u003e    -      left adjust (default is right adjust)\n    +      always use a sign (+ or -) for signed conversions\n    0      pad with zeroes rather than spaces\n\u003c/pre\u003e\u003cp\u003efollowed optionally by a field width:\n\u003c/p\u003e\u003cpre\u003e    num    field width\n    *      as num, but taken from argument list\n\u003c/pre\u003e\u003cp\u003efollowed optionally by a precision:\n\u003c/p\u003e\u003cpre\u003e    .num   precision (number of decimal places)\n\u003c/pre\u003e\u003cp\u003eand finally, a format character:\n\u003c/p\u003e\u003cpre\u003e    c      character               Char, Int, Integer, ...\n    d      decimal                 Char, Int, Integer, ...\n    o      octal                   Char, Int, Integer, ...\n    x      hexadecimal             Char, Int, Integer, ...\n    X      hexadecimal             Char, Int, Integer, ...\n    u      unsigned decimal        Char, Int, Integer, ...\n    f      floating point          Float, Double\n    g      general format float    Float, Double\n    G      general format float    Float, Double\n    e      exponent format float   Float, Double\n    E      exponent format float   Float, Double\n    s      string                  String\n\u003c/pre\u003e\u003cp\u003eMismatch between the argument types and the format string will cause\n an exception to be thrown at runtime.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003e   \u003e printf \"%d\\n\" (23::Int)\n   23\n   \u003e printf \"%s %s\\n\" \"Hello\" \"World\"\n   Hello World\n   \u003e printf \"%.2f\\n\" pi\n   3.14\n\u003c/pre\u003e",
          "module": "Text.Printf",
          "name": "printf",
          "package": "base",
          "signature": "String -\u003e r",
          "source": "src/Text-Printf.html#printf",
          "type": "function"
        },
        "index": {
          "description": "Format variable number of arguments with the C-style formatting string The return value is either String or IO The format string consists of ordinary characters and conversion specifications which specify how to format one of the arguments to printf in the output string conversion specification begins with the character followed by one or more of the following flags left adjust default is right adjust always use sign or for signed conversions pad with zeroes rather than spaces followed optionally by field width num field width as num but taken from argument list followed optionally by precision num precision number of decimal places and finally format character character Char Int Integer decimal Char Int Integer octal Char Int Integer hexadecimal Char Int Integer hexadecimal Char Int Integer unsigned decimal Char Int Integer floating point Float Double general format float Float Double general format float Float Double exponent format float Float Double exponent format float Float Double string String Mismatch between the argument types and the format string will cause an exception to be thrown at runtime Examples printf Int printf Hello World Hello World printf pi",
          "hierarchy": "Text Printf",
          "module": "Text.Printf",
          "name": "printf",
          "normalized": "String-\u003ea",
          "package": "base",
          "signature": "String-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Printf.html#v:printf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe cut-down Haskell lexer, used by Text.Read\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Read.Lex",
          "name": "Lex",
          "package": "base",
          "source": "src/Text-Read-Lex.html",
          "type": "module"
        },
        "index": {
          "description": "The cut-down Haskell lexer used by Text.Read",
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "Lex",
          "package": "base",
          "partial": "Lex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell lexemes.\n\u003c/p\u003e",
          "module": "Text.Read.Lex",
          "name": "Lexeme",
          "package": "base",
          "source": "src/Text-Read-Lex.html#Lexeme",
          "type": "data"
        },
        "index": {
          "description": "Haskell lexemes",
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "Lexeme",
          "package": "base",
          "partial": "Lexeme",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#t:Lexeme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCharacter literal\n\u003c/p\u003e",
          "module": "[\"Text.Read.Lex\",\"Text.Read\"]",
          "name": "Char",
          "package": "base",
          "signature": "Char Char",
          "source": "src/Text-Read-Lex.html#Lexeme",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:Char\",\"http://hackage.haskell.org/package/base/docs/Text-Read.html#v:Char\"]"
        },
        "index": {
          "description": "Character literal",
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "Char",
          "package": "base",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:Char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Read.Lex\",\"Text.Read\"]",
          "name": "EOF",
          "package": "base",
          "signature": "EOF",
          "source": "src/Text-Read-Lex.html#Lexeme",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:EOF\",\"http://hackage.haskell.org/package/base/docs/Text-Read.html#v:EOF\"]"
        },
        "index": {
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "EOF",
          "package": "base",
          "partial": "EOF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:EOF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell identifier, e.g. \u003ccode\u003efoo\u003c/code\u003e, \u003ccode\u003eBaz\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.Read.Lex\",\"Text.Read\"]",
          "name": "Ident",
          "package": "base",
          "signature": "Ident String",
          "source": "src/Text-Read-Lex.html#Lexeme",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:Ident\",\"http://hackage.haskell.org/package/base/docs/Text-Read.html#v:Ident\"]"
        },
        "index": {
          "description": "Haskell identifier e.g foo Baz",
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "Ident",
          "package": "base",
          "partial": "Ident",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:Ident"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Read.Lex\",\"Text.Read\"]",
          "name": "Number",
          "package": "base",
          "signature": "Number Number",
          "source": "src/Text-Read-Lex.html#Lexeme",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:Number\",\"http://hackage.haskell.org/package/base/docs/Text-Read.html#v:Number\"]"
        },
        "index": {
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "Number",
          "package": "base",
          "partial": "Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:Number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePunctuation or reserved symbol, e.g. \u003ccode\u003e(\u003c/code\u003e, \u003ccode\u003e::\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.Read.Lex\",\"Text.Read\"]",
          "name": "Punc",
          "package": "base",
          "signature": "Punc String",
          "source": "src/Text-Read-Lex.html#Lexeme",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:Punc\",\"http://hackage.haskell.org/package/base/docs/Text-Read.html#v:Punc\"]"
        },
        "index": {
          "description": "Punctuation or reserved symbol e.g",
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "Punc",
          "package": "base",
          "partial": "Punc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:Punc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eString literal, with escapes interpreted\n\u003c/p\u003e",
          "module": "[\"Text.Read.Lex\",\"Text.Read\"]",
          "name": "String",
          "package": "base",
          "signature": "String String",
          "source": "src/Text-Read-Lex.html#Lexeme",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:String\",\"http://hackage.haskell.org/package/base/docs/Text-Read.html#v:String\"]"
        },
        "index": {
          "description": "String literal with escapes interpreted",
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "String",
          "package": "base",
          "partial": "String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:String"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell symbol, e.g. \u003ccode\u003e\u003e\u003e\u003c/code\u003e, \u003ccode\u003e:%\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.Read.Lex\",\"Text.Read\"]",
          "name": "Symbol",
          "package": "base",
          "signature": "Symbol String",
          "source": "src/Text-Read-Lex.html#Lexeme",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:Symbol\",\"http://hackage.haskell.org/package/base/docs/Text-Read.html#v:Symbol\"]"
        },
        "index": {
          "description": "Haskell symbol e.g",
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "Symbol",
          "package": "base",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:Symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell lexer: returns the lexed string, rather than the lexeme\n\u003c/p\u003e",
          "module": "Text.Read.Lex",
          "name": "hsLex",
          "package": "base",
          "signature": "ReadP String",
          "source": "src/Text-Read-Lex.html#hsLex",
          "type": "function"
        },
        "index": {
          "description": "Haskell lexer returns the lexed string rather than the lexeme",
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "hsLex",
          "package": "base",
          "partial": "Lex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:hsLex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Read.Lex",
          "name": "lex",
          "package": "base",
          "signature": "ReadP Lexeme",
          "source": "src/Text-Read-Lex.html#lex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "lex",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:lex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Read.Lex",
          "name": "lexChar",
          "package": "base",
          "signature": "ReadP Char",
          "source": "src/Text-Read-Lex.html#lexChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "lexChar",
          "package": "base",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:lexChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Read.Lex",
          "name": "numberToInteger",
          "package": "base",
          "signature": "Number -\u003e Maybe Integer",
          "source": "src/Text-Read-Lex.html#numberToInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "numberToInteger",
          "normalized": "Number-\u003eMaybe Integer",
          "package": "base",
          "partial": "To Integer",
          "signature": "Number-\u003eMaybe Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:numberToInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Read.Lex",
          "name": "numberToRangedRational",
          "package": "base",
          "signature": "(Int, Int) -\u003e Number -\u003e Maybe Rational",
          "source": "src/Text-Read-Lex.html#numberToRangedRational",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "numberToRangedRational",
          "normalized": "(Int,Int)-\u003eNumber-\u003eMaybe Rational",
          "package": "base",
          "partial": "To Ranged Rational",
          "signature": "(Int,Int)-\u003eNumber-\u003eMaybe Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:numberToRangedRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Read.Lex",
          "name": "numberToRational",
          "package": "base",
          "signature": "Number -\u003e Rational",
          "source": "src/Text-Read-Lex.html#numberToRational",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "numberToRational",
          "normalized": "Number-\u003eRational",
          "package": "base",
          "partial": "To Rational",
          "signature": "Number-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:numberToRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Read.Lex",
          "name": "readDecP",
          "package": "base",
          "signature": "ReadP a",
          "source": "src/Text-Read-Lex.html#readDecP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "readDecP",
          "package": "base",
          "partial": "Dec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:readDecP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Read.Lex",
          "name": "readHexP",
          "package": "base",
          "signature": "ReadP a",
          "source": "src/Text-Read-Lex.html#readHexP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "readHexP",
          "package": "base",
          "partial": "Hex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:readHexP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Read.Lex",
          "name": "readIntP",
          "package": "base",
          "signature": "a -\u003e (Char -\u003e Bool) -\u003e (Char -\u003e Int) -\u003e ReadP a",
          "source": "src/Text-Read-Lex.html#readIntP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "readIntP",
          "normalized": "a-\u003e(Char-\u003eBool)-\u003e(Char-\u003eInt)-\u003eReadP a",
          "package": "base",
          "partial": "Int",
          "signature": "a-\u003e(Char-\u003eBool)-\u003e(Char-\u003eInt)-\u003eReadP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:readIntP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Read.Lex",
          "name": "readOctP",
          "package": "base",
          "signature": "ReadP a",
          "source": "src/Text-Read-Lex.html#readOctP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Read Lex",
          "module": "Text.Read.Lex",
          "name": "readOctP",
          "package": "base",
          "partial": "Oct",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read-Lex.html#v:readOctP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConverting strings to values.\n\u003c/p\u003e\u003cp\u003eThe \u003ca\u003eText.Read\u003c/a\u003e library is the canonical library to import for\n \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e-class facilities.  For GHC only, it offers an extended and much\n improved \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e class, which constitutes a proposed alternative to the \n Haskell 98 \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e.  In particular, writing parsers is easier, and\n the parsers are much more efficient.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Read",
          "name": "Read",
          "package": "base",
          "source": "src/Text-Read.html",
          "type": "module"
        },
        "index": {
          "description": "Converting strings to values The Text.Read library is the canonical library to import for Read class facilities For GHC only it offers an extended and much improved Read class which constitutes proposed alternative to the Haskell Read In particular writing parsers is easier and the parsers are much more efficient",
          "hierarchy": "Text Read",
          "module": "Text.Read",
          "name": "Read",
          "package": "base",
          "partial": "Read",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell lexemes.\n\u003c/p\u003e",
          "module": "Text.Read",
          "name": "Lexeme",
          "package": "base",
          "source": "src/Text-Read-Lex.html#Lexeme",
          "type": "data"
        },
        "index": {
          "description": "Haskell lexemes",
          "hierarchy": "Text Read",
          "module": "Text.Read",
          "name": "Lexeme",
          "package": "base",
          "partial": "Lexeme",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read.html#t:Lexeme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParsing of \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003es, producing values.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e (or, for GHC only, \u003ccode\u003e\u003ca\u003ereadPrec\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e\u003cp\u003eDerived instances of \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e make the following assumptions, which\n derived instances of \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e obey:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e If the constructor is defined to be an infix operator, then the\n   derived \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e instance will parse only infix applications of\n   the constructor (not the prefix form).\n\u003c/li\u003e\u003cli\u003e Associativity is not used to reduce the occurrence of parentheses,\n   although precedence may be.\n\u003c/li\u003e\u003cli\u003e If the constructor is defined using record syntax, the derived \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e\n   will parse only the record-syntax form, and furthermore, the fields\n   must be given in the same order as the original declaration.\n\u003c/li\u003e\u003cli\u003e The derived \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e instance allows arbitrary Haskell whitespace\n   between tokens of the input string.  Extra parentheses are also\n   allowed.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eFor example, given the declarations\n\u003c/p\u003e\u003cpre\u003e infixr 5 :^:\n data Tree a =  Leaf a  |  Tree a :^: Tree a\n\u003c/pre\u003e\u003cp\u003ethe derived instance of \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e in Haskell 98 is equivalent to\n\u003c/p\u003e\u003cpre\u003e instance (Read a) =\u003e Read (Tree a) where\n\n         readsPrec d r =  readParen (d \u003e app_prec)\n                          (\\r -\u003e [(Leaf m,t) |\n                                  (\"Leaf\",s) \u003c- lex r,\n                                  (m,t) \u003c- readsPrec (app_prec+1) s]) r\n\n                       ++ readParen (d \u003e up_prec)\n                          (\\r -\u003e [(u:^:v,w) |\n                                  (u,s) \u003c- readsPrec (up_prec+1) r,\n                                  (\":^:\",t) \u003c- lex s,\n                                  (v,w) \u003c- readsPrec (up_prec+1) t]) r\n\n           where app_prec = 10\n                 up_prec = 5\n\u003c/pre\u003e\u003cp\u003eNote that right-associativity of \u003ccode\u003e:^:\u003c/code\u003e is unused.\n\u003c/p\u003e\u003cp\u003eThe derived instance in GHC is equivalent to\n\u003c/p\u003e\u003cpre\u003e instance (Read a) =\u003e Read (Tree a) where\n\n         readPrec = parens $ (prec app_prec $ do\n                                  Ident \"Leaf\" \u003c- lexP\n                                  m \u003c- step readPrec\n                                  return (Leaf m))\n\n                      +++ (prec up_prec $ do\n                                  u \u003c- step readPrec\n                                  Symbol \":^:\" \u003c- lexP\n                                  v \u003c- step readPrec\n                                  return (u :^: v))\n\n           where app_prec = 10\n                 up_prec = 5\n\n         readListPrec = readListPrecDefault\n\u003c/pre\u003e",
          "module": "Text.Read",
          "name": "Read",
          "package": "base",
          "source": "src/GHC-Read.html#Read",
          "type": "class"
        },
        "index": {
          "description": "Parsing of String producing values Minimal complete definition readsPrec or for GHC only readPrec Derived instances of Read make the following assumptions which derived instances of Show obey If the constructor is defined to be an infix operator then the derived Read instance will parse only infix applications of the constructor not the prefix form Associativity is not used to reduce the occurrence of parentheses although precedence may be If the constructor is defined using record syntax the derived Read will parse only the record-syntax form and furthermore the fields must be given in the same order as the original declaration The derived Read instance allows arbitrary Haskell whitespace between tokens of the input string Extra parentheses are also allowed For example given the declarations infixr data Tree Leaf Tree Tree the derived instance of Read in Haskell is equivalent to instance Read Read Tree where readsPrec readParen app prec Leaf Leaf lex readsPrec app prec readParen up prec readsPrec up prec lex readsPrec up prec where app prec up prec Note that right-associativity of is unused The derived instance in GHC is equivalent to instance Read Read Tree where readPrec parens prec app prec do Ident Leaf lexP step readPrec return Leaf prec up prec do step readPrec Symbol lexP step readPrec return where app prec up prec readListPrec readListPrecDefault",
          "hierarchy": "Text Read",
          "module": "Text.Read",
          "name": "Read",
          "package": "base",
          "partial": "Read",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read.html#t:Read"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA parser for a type \u003ccode\u003ea\u003c/code\u003e, represented as a function that takes a\n \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e and returns a list of possible parses as \u003ccode\u003e(a,\u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e pairs.\n\u003c/p\u003e\u003cp\u003eNote that this kind of backtracking parser is very inefficient;\n reading a large structure may be quite slow (cf \u003ccode\u003e\u003ca\u003eReadP\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Text.Read",
          "name": "ReadS",
          "package": "base",
          "source": "src/Text-ParserCombinators-ReadP.html#ReadS",
          "type": "type"
        },
        "index": {
          "description": "parser for type represented as function that takes String and returns list of possible parses as String pairs Note that this kind of backtracking parser is very inefficient reading large structure may be quite slow cf ReadP",
          "hierarchy": "Text Read",
          "module": "Text.Read",
          "name": "ReadS",
          "package": "base",
          "partial": "Read",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read.html#t:ReadS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a single lexeme\n\u003c/p\u003e",
          "module": "Text.Read",
          "name": "lexP",
          "package": "base",
          "signature": "ReadPrec Lexeme",
          "source": "src/GHC-Read.html#lexP",
          "type": "function"
        },
        "index": {
          "description": "Parse single lexeme",
          "hierarchy": "Text Read",
          "module": "Text.Read",
          "name": "lexP",
          "package": "base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read.html#v:lexP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e(parens p)\u003c/code\u003e parses \"P\", \"(P0)\", \"((P0))\", etc, \n      where \u003ccode\u003ep\u003c/code\u003e parses \"P\"  in the current precedence context\n          and parses \"P0\" in precedence context zero\n\u003c/p\u003e",
          "module": "Text.Read",
          "name": "parens",
          "package": "base",
          "signature": "ReadPrec a -\u003e ReadPrec a",
          "source": "src/GHC-Read.html#parens",
          "type": "function"
        },
        "index": {
          "description": "parens parses P0 P0 etc where parses in the current precedence context and parses P0 in precedence context zero",
          "hierarchy": "Text Read",
          "module": "Text.Read",
          "name": "parens",
          "normalized": "ReadPrec a-\u003eReadPrec a",
          "package": "base",
          "signature": "ReadPrec a-\u003eReadPrec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read.html#v:parens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string using the \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e instance.\n Succeeds if there is exactly one valid result.\n A \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e value indicates a parse error.\n\u003c/p\u003e",
          "module": "Text.Read",
          "name": "readEither",
          "package": "base",
          "signature": "String -\u003e Either String a",
          "source": "src/Text-Read.html#readEither",
          "type": "function"
        },
        "index": {
          "description": "Parse string using the Read instance Succeeds if there is exactly one valid result Left value indicates parse error",
          "hierarchy": "Text Read",
          "module": "Text.Read",
          "name": "readEither",
          "normalized": "String-\u003eEither String a",
          "package": "base",
          "partial": "Either",
          "signature": "String-\u003eEither String a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read.html#v:readEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe method \u003ccode\u003e\u003ca\u003ereadList\u003c/a\u003e\u003c/code\u003e is provided to allow the programmer to\n give a specialised way of parsing lists of values.\n For example, this is used by the predefined \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e instance of\n the \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e type, where values of type \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e should be are\n expected to use double quotes, rather than square brackets.\n\u003c/p\u003e",
          "module": "Text.Read",
          "name": "readList",
          "package": "base",
          "signature": "ReadS [a]",
          "source": "src/GHC-Read.html#readList",
          "type": "method"
        },
        "index": {
          "description": "The method readList is provided to allow the programmer to give specialised way of parsing lists of values For example this is used by the predefined Read instance of the Char type where values of type String should be are expected to use double quotes rather than square brackets",
          "hierarchy": "Text Read",
          "module": "Text.Read",
          "name": "readList",
          "normalized": "ReadS[a]",
          "package": "base",
          "partial": "List",
          "signature": "ReadS[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read.html#v:readList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA possible replacement definition for the \u003ccode\u003e\u003ca\u003ereadList\u003c/a\u003e\u003c/code\u003e method (GHC only).\n   This is only needed for GHC, and even then only for \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e instances\n   where \u003ccode\u003e\u003ca\u003ereadListPrec\u003c/a\u003e\u003c/code\u003e isn't defined as \u003ccode\u003e\u003ca\u003ereadListPrecDefault\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.Read",
          "name": "readListDefault",
          "package": "base",
          "signature": "ReadS [a]",
          "source": "src/GHC-Read.html#readListDefault",
          "type": "function"
        },
        "index": {
          "description": "possible replacement definition for the readList method GHC only This is only needed for GHC and even then only for Read instances where readListPrec isn defined as readListPrecDefault",
          "hierarchy": "Text Read",
          "module": "Text.Read",
          "name": "readListDefault",
          "normalized": "ReadS[a]",
          "package": "base",
          "partial": "List Default",
          "signature": "ReadS[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read.html#v:readListDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProposed replacement for \u003ccode\u003e\u003ca\u003ereadList\u003c/a\u003e\u003c/code\u003e using new-style parsers (GHC only).\n The default definition uses \u003ccode\u003e\u003ca\u003ereadList\u003c/a\u003e\u003c/code\u003e.  Instances that define \u003ccode\u003e\u003ca\u003ereadPrec\u003c/a\u003e\u003c/code\u003e\n should also define \u003ccode\u003e\u003ca\u003ereadListPrec\u003c/a\u003e\u003c/code\u003e as \u003ccode\u003e\u003ca\u003ereadListPrecDefault\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.Read",
          "name": "readListPrec",
          "package": "base",
          "signature": "ReadPrec [a]",
          "source": "src/GHC-Read.html#readListPrec",
          "type": "method"
        },
        "index": {
          "description": "Proposed replacement for readList using new-style parsers GHC only The default definition uses readList Instances that define readPrec should also define readListPrec as readListPrecDefault",
          "hierarchy": "Text Read",
          "module": "Text.Read",
          "name": "readListPrec",
          "normalized": "ReadPrec[a]",
          "package": "base",
          "partial": "List Prec",
          "signature": "ReadPrec[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read.html#v:readListPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA possible replacement definition for the \u003ccode\u003e\u003ca\u003ereadListPrec\u003c/a\u003e\u003c/code\u003e method,\n   defined using \u003ccode\u003e\u003ca\u003ereadPrec\u003c/a\u003e\u003c/code\u003e (GHC only).\n\u003c/p\u003e",
          "module": "Text.Read",
          "name": "readListPrecDefault",
          "package": "base",
          "signature": "ReadPrec [a]",
          "source": "src/GHC-Read.html#readListPrecDefault",
          "type": "function"
        },
        "index": {
          "description": "possible replacement definition for the readListPrec method defined using readPrec GHC only",
          "hierarchy": "Text Read",
          "module": "Text.Read",
          "name": "readListPrecDefault",
          "normalized": "ReadPrec[a]",
          "package": "base",
          "partial": "List Prec Default",
          "signature": "ReadPrec[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read.html#v:readListPrecDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string using the \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e instance.\n Succeeds if there is exactly one valid result.\n\u003c/p\u003e",
          "module": "Text.Read",
          "name": "readMaybe",
          "package": "base",
          "signature": "String -\u003e Maybe a",
          "source": "src/Text-Read.html#readMaybe",
          "type": "function"
        },
        "index": {
          "description": "Parse string using the Read instance Succeeds if there is exactly one valid result",
          "hierarchy": "Text Read",
          "module": "Text.Read",
          "name": "readMaybe",
          "normalized": "String-\u003eMaybe a",
          "package": "base",
          "partial": "Maybe",
          "signature": "String-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read.html#v:readMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProposed replacement for \u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e using new-style parsers (GHC only).\n\u003c/p\u003e",
          "module": "Text.Read",
          "name": "readPrec",
          "package": "base",
          "signature": "ReadPrec a",
          "source": "src/GHC-Read.html#readPrec",
          "type": "method"
        },
        "index": {
          "description": "Proposed replacement for readsPrec using new-style parsers GHC only",
          "hierarchy": "Text Read",
          "module": "Text.Read",
          "name": "readPrec",
          "package": "base",
          "partial": "Prec",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read.html#v:readPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eattempts to parse a value from the front of the string, returning\n a list of (parsed value, remaining string) pairs.  If there is no\n successful parse, the returned list is empty.\n\u003c/p\u003e\u003cp\u003eDerived instances of \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e satisfy the following:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e(x,\"\")\u003c/code\u003e is an element of\n   \u003ccode\u003e(\u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e d (\u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e d x \"\"))\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThat is, \u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e parses the string produced by\n \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e, and delivers the value that\n \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e started with.\n\u003c/p\u003e",
          "module": "Text.Read",
          "name": "readsPrec",
          "package": "base",
          "signature": "readsPrec",
          "source": "src/GHC-Read.html#readsPrec",
          "type": "method"
        },
        "index": {
          "description": "attempts to parse value from the front of the string returning list of parsed value remaining string pairs If there is no successful parse the returned list is empty Derived instances of Read and Show satisfy the following is an element of readsPrec showsPrec That is readsPrec parses the string produced by showsPrec and delivers the value that showsPrec started with",
          "hierarchy": "Text Read",
          "module": "Text.Read",
          "name": "readsPrec",
          "package": "base",
          "partial": "Prec",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Read.html#v:readsPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOptional instance of \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e for functions:\n\u003c/p\u003e\u003cpre\u003e instance Show (a -\u003e b) where\n \tshowsPrec _ _ = showString \\\"\\\u003cfunction\\\u003e\\\"\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Text.Show.Functions",
          "name": "Functions",
          "package": "base",
          "source": "src/Text-Show-Functions.html",
          "type": "module"
        },
        "index": {
          "description": "Optional instance of Show for functions instance Show where showsPrec showString function",
          "hierarchy": "Text Show Functions",
          "module": "Text.Show.Functions",
          "name": "Functions",
          "package": "base",
          "partial": "Functions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Show-Functions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConverting values to readable strings:\n the \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e class and associated functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Show",
          "name": "Show",
          "package": "base",
          "source": "src/Text-Show.html",
          "type": "module"
        },
        "index": {
          "description": "Converting values to readable strings the Show class and associated functions",
          "hierarchy": "Text Show",
          "module": "Text.Show",
          "name": "Show",
          "package": "base",
          "partial": "Show",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Show.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion of values to readable \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eDerived instances of \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e have the following properties, which\n are compatible with derived instances of \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The result of \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e is a syntactically correct Haskell\n   expression containing only constants, given the fixity\n   declarations in force at the point where the type is declared.\n   It contains only the constructor names defined in the data type,\n   parentheses, and spaces.  When labelled constructor fields are\n   used, braces, commas, field names, and equal signs are also used.\n\u003c/li\u003e\u003cli\u003e If the constructor is defined to be an infix operator, then\n   \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e will produce infix applications of the constructor.\n\u003c/li\u003e\u003cli\u003e the representation will be enclosed in parentheses if the\n   precedence of the top-level constructor in \u003ccode\u003ex\u003c/code\u003e is less than \u003ccode\u003ed\u003c/code\u003e\n   (associativity is ignored).  Thus, if \u003ccode\u003ed\u003c/code\u003e is \u003ccode\u003e0\u003c/code\u003e then the result\n   is never surrounded in parentheses; if \u003ccode\u003ed\u003c/code\u003e is \u003ccode\u003e11\u003c/code\u003e it is always\n   surrounded in parentheses, unless it is an atomic expression.\n\u003c/li\u003e\u003cli\u003e If the constructor is defined using record syntax, then \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e\n   will produce the record-syntax form, with the fields given in the\n   same order as the original declaration.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eFor example, given the declarations\n\u003c/p\u003e\u003cpre\u003e infixr 5 :^:\n data Tree a =  Leaf a  |  Tree a :^: Tree a\n\u003c/pre\u003e\u003cp\u003ethe derived instance of \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e is equivalent to\n\u003c/p\u003e\u003cpre\u003e instance (Show a) =\u003e Show (Tree a) where\n\n        showsPrec d (Leaf m) = showParen (d \u003e app_prec) $\n             showString \"Leaf \" . showsPrec (app_prec+1) m\n          where app_prec = 10\n\n        showsPrec d (u :^: v) = showParen (d \u003e up_prec) $\n             showsPrec (up_prec+1) u .\n             showString \" :^: \"      .\n             showsPrec (up_prec+1) v\n          where up_prec = 5\n\u003c/pre\u003e\u003cp\u003eNote that right-associativity of \u003ccode\u003e:^:\u003c/code\u003e is ignored.  For example,\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e (Leaf 1 :^: Leaf 2 :^: Leaf 3)\u003c/code\u003e produces the string\n   \u003ccode\u003e\"Leaf 1 :^: (Leaf 2 :^: Leaf 3)\"\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.Show",
          "name": "Show",
          "package": "base",
          "source": "src/GHC-Show.html#Show",
          "type": "class"
        },
        "index": {
          "description": "Conversion of values to readable String Minimal complete definition showsPrec or show Derived instances of Show have the following properties which are compatible with derived instances of Read The result of show is syntactically correct Haskell expression containing only constants given the fixity declarations in force at the point where the type is declared It contains only the constructor names defined in the data type parentheses and spaces When labelled constructor fields are used braces commas field names and equal signs are also used If the constructor is defined to be an infix operator then showsPrec will produce infix applications of the constructor the representation will be enclosed in parentheses if the precedence of the top-level constructor in is less than associativity is ignored Thus if is then the result is never surrounded in parentheses if is it is always surrounded in parentheses unless it is an atomic expression If the constructor is defined using record syntax then show will produce the record-syntax form with the fields given in the same order as the original declaration For example given the declarations infixr data Tree Leaf Tree Tree the derived instance of Show is equivalent to instance Show Show Tree where showsPrec Leaf showParen app prec showString Leaf showsPrec app prec where app prec showsPrec showParen up prec showsPrec up prec showString showsPrec up prec where up prec Note that right-associativity of is ignored For example show Leaf Leaf Leaf produces the string Leaf Leaf Leaf",
          "hierarchy": "Text Show",
          "module": "Text.Show",
          "name": "Show",
          "package": "base",
          "partial": "Show",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Show.html#t:Show"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003eshows\u003c/code\u003e functions return a function that prepends the\n output \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e to an existing \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.  This allows constant-time\n concatenation of results using function composition.\n\u003c/p\u003e",
          "module": "Text.Show",
          "name": "ShowS",
          "package": "base",
          "source": "src/GHC-Show.html#ShowS",
          "type": "type"
        },
        "index": {
          "description": "The shows functions return function that prepends the output String to an existing String This allows constant-time concatenation of results using function composition",
          "hierarchy": "Text Show",
          "module": "Text.Show",
          "name": "ShowS",
          "package": "base",
          "partial": "Show",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Show.html#t:ShowS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA specialised variant of \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e, using precedence context\n zero, and returning an ordinary \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.Show",
          "name": "show",
          "package": "base",
          "signature": "a -\u003e String",
          "source": "src/GHC-Show.html#show",
          "type": "method"
        },
        "index": {
          "description": "specialised variant of showsPrec using precedence context zero and returning an ordinary String",
          "hierarchy": "Text Show",
          "module": "Text.Show",
          "name": "show",
          "normalized": "a-\u003eString",
          "package": "base",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Show.html#v:show"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe method \u003ccode\u003e\u003ca\u003eshowList\u003c/a\u003e\u003c/code\u003e is provided to allow the programmer to\n give a specialised way of showing lists of values.\n For example, this is used by the predefined \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instance of\n the \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e type, where values of type \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e should be shown\n in double quotes, rather than between square brackets.\n\u003c/p\u003e",
          "module": "Text.Show",
          "name": "showList",
          "package": "base",
          "signature": "[a] -\u003e ShowS",
          "source": "src/GHC-Show.html#showList",
          "type": "method"
        },
        "index": {
          "description": "The method showList is provided to allow the programmer to give specialised way of showing lists of values For example this is used by the predefined Show instance of the Char type where values of type String should be shown in double quotes rather than between square brackets",
          "hierarchy": "Text Show",
          "module": "Text.Show",
          "name": "showList",
          "normalized": "[a]-\u003eShowS",
          "package": "base",
          "partial": "List",
          "signature": "[a]-\u003eShowS",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Show.html#v:showList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a list (using square brackets and commas), given a function\n for showing elements.\n\u003c/p\u003e",
          "module": "Text.Show",
          "name": "showListWith",
          "package": "base",
          "signature": "(a -\u003e ShowS) -\u003e [a] -\u003e ShowS",
          "source": "src/Text-Show.html#showListWith",
          "type": "function"
        },
        "index": {
          "description": "Show list using square brackets and commas given function for showing elements",
          "hierarchy": "Text Show",
          "module": "Text.Show",
          "name": "showListWith",
          "normalized": "(a-\u003eShowS)-\u003e[a]-\u003eShowS",
          "package": "base",
          "partial": "List With",
          "signature": "(a-\u003eShowS)-\u003e[a]-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Show.html#v:showListWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a value to a readable \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e should satisfy the law\n\u003c/p\u003e\u003cpre\u003e showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)\n\u003c/pre\u003e\u003cp\u003eDerived instances of \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e satisfy the following:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e(x,\"\")\u003c/code\u003e is an element of\n   \u003ccode\u003e(\u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e d (\u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e d x \"\"))\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThat is, \u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e parses the string produced by\n \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e, and delivers the value that \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e started with.\n\u003c/p\u003e",
          "module": "Text.Show",
          "name": "showsPrec",
          "package": "base",
          "signature": "showsPrec",
          "source": "src/GHC-Show.html#showsPrec",
          "type": "method"
        },
        "index": {
          "description": "Convert value to readable String showsPrec should satisfy the law showsPrec showsPrec Derived instances of Read and Show satisfy the following is an element of readsPrec showsPrec That is readsPrec parses the string produced by showsPrec and delivers the value that showsPrec started with",
          "hierarchy": "Text Show",
          "module": "Text.Show",
          "name": "showsPrec",
          "package": "base",
          "partial": "Prec",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Text-Show.html#v:showsPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe highly unsafe primitive \u003ccode\u003e\u003ca\u003eunsafeCoerce\u003c/a\u003e\u003c/code\u003e converts a value from any\n type to any other type.  Needless to say, if you use this function,\n it is your responsibility to ensure that the old and new types have\n identical internal representations, in order to prevent runtime corruption.\n\u003c/p\u003e\u003cp\u003eThe types for which \u003ccode\u003e\u003ca\u003eunsafeCoerce\u003c/a\u003e\u003c/code\u003e is representation-safe may differ\n from compiler to compiler (and version to version).\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Documentation for correct usage in GHC will be found under\n     \u003ccode\u003e\u003ca\u003e\"/packages/archive///doc/html/GHC-Prim.html#v:unsafeCoerce-35-\"\u003eunsafeCoerce#\u003c/a\u003e\u003c/code\u003e in GHC.Base (around which \u003ccode\u003e\u003ca\u003eunsafeCoerce\u003c/a\u003e\u003c/code\u003e is just a\n     trivial wrapper).\n\u003c/li\u003e\u003cli\u003e In nhc98, the only representation-safe coercions are between Enum\n     types with the same range (e.g. Int, Int32, Char, Word32),\n     or between a newtype and the type that it wraps.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Unsafe.Coerce",
          "name": "Coerce",
          "package": "base",
          "source": "src/Unsafe-Coerce.html",
          "type": "module"
        },
        "index": {
          "description": "The highly unsafe primitive unsafeCoerce converts value from any type to any other type Needless to say if you use this function it is your responsibility to ensure that the old and new types have identical internal representations in order to prevent runtime corruption The types for which unsafeCoerce is representation-safe may differ from compiler to compiler and version to version Documentation for correct usage in GHC will be found under packages archive doc html GHC-Prim.html unsafeCoerce-35 unsafeCoerce in GHC.Base around which unsafeCoerce is just trivial wrapper In nhc98 the only representation-safe coercions are between Enum types with the same range e.g Int Int32 Char Word32 or between newtype and the type that it wraps",
          "hierarchy": "Unsafe Coerce",
          "module": "Unsafe.Coerce",
          "name": "Coerce",
          "package": "base",
          "partial": "Coerce",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Unsafe-Coerce.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Unsafe.Coerce",
          "name": "unsafeCoerce",
          "package": "base",
          "signature": "a -\u003e b",
          "source": "src/Unsafe-Coerce.html#unsafeCoerce",
          "type": "function"
        },
        "index": {
          "hierarchy": "Unsafe Coerce",
          "module": "Unsafe.Coerce",
          "name": "unsafeCoerce",
          "normalized": "a-\u003eb",
          "package": "base",
          "partial": "Coerce",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/base/docs/Unsafe-Coerce.html#v:unsafeCoerce"
      }
    }
  ]
]