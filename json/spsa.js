[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "spsa"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Optimization.LossFunctions",
          "name": "LossFunctions",
          "package": "spsa",
          "source": "src/Math-Optimization-LossFunctions.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Optimization LossFunctions",
          "module": "Math.Optimization.LossFunctions",
          "name": "LossFunctions",
          "package": "spsa",
          "partial": "Loss Functions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-LossFunctions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Optimization.LossFunctions",
          "name": "absSum",
          "package": "spsa",
          "signature": "LossFn",
          "source": "src/Math-Optimization-LossFunctions.html#absSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Optimization LossFunctions",
          "module": "Math.Optimization.LossFunctions",
          "name": "absSum",
          "package": "spsa",
          "partial": "Sum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-LossFunctions.html#v:absSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Optimization.LossFunctions",
          "name": "rosenbrock",
          "package": "spsa",
          "signature": "LossFn",
          "source": "src/Math-Optimization-LossFunctions.html#rosenbrock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Optimization LossFunctions",
          "module": "Math.Optimization.LossFunctions",
          "name": "rosenbrock",
          "package": "spsa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-LossFunctions.html#v:rosenbrock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Optimization.SPSA",
          "name": "SPSA",
          "package": "spsa",
          "source": "src/Math-Optimization-SPSA.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "SPSA",
          "package": "spsa",
          "partial": "SPSA",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstraint Function\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "ConstraintFn",
          "package": "spsa",
          "source": "src/Math-Optimization-SPSA-Types.html#ConstraintFn",
          "type": "type"
        },
        "index": {
          "description": "Constraint Function",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "ConstraintFn",
          "package": "spsa",
          "partial": "Constraint Fn",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#t:ConstraintFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLoss Function\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "LossFn",
          "package": "spsa",
          "source": "src/Math-Optimization-SPSA-Types.html#LossFn",
          "type": "type"
        },
        "index": {
          "description": "Loss Function",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "LossFn",
          "package": "spsa",
          "partial": "Loss Fn",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#t:LossFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Optimization.SPSA",
          "name": "StateSPSA",
          "package": "spsa",
          "source": "src/Math-Optimization-SPSA-Types.html#StateSPSA",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "StateSPSA",
          "package": "spsa",
          "partial": "State SPSA",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#t:StateSPSA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA stopping criteria is a function of current iteration number, last iteration theta, and current theta\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "StoppingCriteria",
          "package": "spsa",
          "source": "src/Math-Optimization-SPSA-Types.html#StoppingCriteria",
          "type": "data"
        },
        "index": {
          "description": "stopping criteria is function of current iteration number last iteration theta and current theta",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "StoppingCriteria",
          "package": "spsa",
          "partial": "Stopping Criteria",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#t:StoppingCriteria"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Optimization.SPSA",
          "name": "Iterations",
          "package": "spsa",
          "signature": "Iterations Int",
          "source": "src/Math-Optimization-SPSA-Types.html#StoppingCriteria",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "Iterations",
          "package": "spsa",
          "partial": "Iterations",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:Iterations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Optimization.SPSA",
          "name": "NormDiff",
          "package": "spsa",
          "signature": "NormDiff Double",
          "source": "src/Math-Optimization-SPSA-Types.html#StoppingCriteria",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "NormDiff",
          "package": "spsa",
          "partial": "Norm Diff",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:NormDiff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a bernoulli +1 / -1 distributed infinite series of perturbation vectors based on seed and dimension\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "bernoulli",
          "package": "spsa",
          "signature": "Int -\u003e Int -\u003e [Vector Double]",
          "source": "src/Math-Optimization-SPSA-Construction.html#bernoulli",
          "type": "function"
        },
        "index": {
          "description": "Create bernoulli distributed infinite series of perturbation vectors based on seed and dimension",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "bernoulli",
          "normalized": "Int-\u003eInt-\u003e[Vector Double]",
          "package": "spsa",
          "signature": "Int-\u003eInt-\u003e[Vector Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:bernoulli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck to make sure all required fields are filled\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "checkSPSA",
          "package": "spsa",
          "signature": "Vector Double -\u003e StateSPSA ()",
          "source": "src/Math-Optimization-SPSA-Types.html#checkSPSA",
          "type": "function"
        },
        "index": {
          "description": "Check to make sure all required fields are filled",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "checkSPSA",
          "normalized": "Vector Double-\u003eStateSPSA()",
          "package": "spsa",
          "partial": "SPSA",
          "signature": "Vector Double-\u003eStateSPSA()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:checkSPSA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a default SPSA instance\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "defaultSPSA",
          "package": "spsa",
          "signature": "SPSA",
          "source": "src/Math-Optimization-SPSA-Types.html#defaultSPSA",
          "type": "function"
        },
        "index": {
          "description": "Make default SPSA instance",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "defaultSPSA",
          "package": "spsa",
          "partial": "SPSA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:defaultSPSA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the constraint function out of StateSPSA\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "getConstraint",
          "package": "spsa",
          "signature": "StateSPSA ConstraintFn",
          "source": "src/Math-Optimization-SPSA-Types.html#getConstraint",
          "type": "function"
        },
        "index": {
          "description": "Get the constraint function out of StateSPSA",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "getConstraint",
          "package": "spsa",
          "partial": "Constraint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:getConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the iteration count\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "getIterations",
          "package": "spsa",
          "signature": "StateSPSA Int",
          "source": "src/Math-Optimization-SPSA-Types.html#getIterations",
          "type": "function"
        },
        "index": {
          "description": "Get the iteration count",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "getIterations",
          "package": "spsa",
          "partial": "Iterations",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:getIterations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the loss function out of StateSPSA\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "getLoss",
          "package": "spsa",
          "signature": "StateSPSA LossFn",
          "source": "src/Math-Optimization-SPSA-Types.html#getLoss",
          "type": "function"
        },
        "index": {
          "description": "Get the loss function out of StateSPSA",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "getLoss",
          "package": "spsa",
          "partial": "Loss",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:getLoss"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the stopping functions out of StateSPSA\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "getStop",
          "package": "spsa",
          "signature": "StateSPSA [StoppingCriteria]",
          "source": "src/Math-Optimization-SPSA-Types.html#getStop",
          "type": "function"
        },
        "index": {
          "description": "Get the stopping functions out of StateSPSA",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "getStop",
          "normalized": "StateSPSA[StoppingCriteria]",
          "package": "spsa",
          "partial": "Stop",
          "signature": "StateSPSA[StoppingCriteria]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:getStop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrement the iteration count\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "incrementIteration",
          "package": "spsa",
          "signature": "StateSPSA Int",
          "source": "src/Math-Optimization-SPSA-Types.html#incrementIteration",
          "type": "function"
        },
        "index": {
          "description": "Increment the iteration count",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "incrementIteration",
          "package": "spsa",
          "partial": "Iteration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:incrementIteration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePeel the next value from the two gain sequences and the perturbation vectors\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "peelAll",
          "package": "spsa",
          "signature": "StateSPSA (Double, Double, Vector Double)",
          "source": "src/Math-Optimization-SPSA-Types.html#peelAll",
          "type": "function"
        },
        "index": {
          "description": "Peel the next value from the two gain sequences and the perturbation vectors",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "peelAll",
          "normalized": "StateSPSA(Double,Double,Vector Double)",
          "package": "spsa",
          "partial": "All",
          "signature": "StateSPSA(Double,Double,Vector Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:peelAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePush a stopping criteria onto SPSA\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "pushStopCrit",
          "package": "spsa",
          "signature": "StoppingCriteria -\u003e StateSPSA ()",
          "source": "src/Math-Optimization-SPSA-Types.html#pushStopCrit",
          "type": "function"
        },
        "index": {
          "description": "Push stopping criteria onto SPSA",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "pushStopCrit",
          "normalized": "StoppingCriteria-\u003eStateSPSA()",
          "package": "spsa",
          "partial": "Stop Crit",
          "signature": "StoppingCriteria-\u003eStateSPSA()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:pushStopCrit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExported runSPSA function to extract the SPSA type\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "runSPSA",
          "package": "spsa",
          "signature": "StateSPSA a -\u003e Vector Double -\u003e Vector Double",
          "source": "src/Math-Optimization-SPSA-Optimize.html#runSPSA",
          "type": "function"
        },
        "index": {
          "description": "Exported runSPSA function to extract the SPSA type",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "runSPSA",
          "normalized": "StateSPSA a-\u003eVector Double-\u003eVector Double",
          "package": "spsa",
          "partial": "SPSA",
          "signature": "StateSPSA a-\u003eVector Double-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:runSPSA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet semiautomatic tuning for the gain sequences\n | c should be about the standard deviation of a measurement\n | a is set how much you want the first iteration to move\n | A is set to be 10% of expected iterations\n | alpha and gamma are set to the lowest values for best finite iteration performance (not infinitely optimal)\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "semiautomaticTuning",
          "package": "spsa",
          "signature": "Int -\u003e Double -\u003e Double -\u003e StateSPSA ()",
          "source": "src/Math-Optimization-SPSA-Construction.html#semiautomaticTuning",
          "type": "function"
        },
        "index": {
          "description": "Set semiautomatic tuning for the gain sequences should be about the standard deviation of measurement is set how much you want the first iteration to move is set to be of expected iterations alpha and gamma are set to the lowest values for best finite iteration performance not infinitely optimal",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "semiautomaticTuning",
          "normalized": "Int-\u003eDouble-\u003eDouble-\u003eStateSPSA()",
          "package": "spsa",
          "partial": "Tuning",
          "signature": "Int-\u003eDouble-\u003eDouble-\u003eStateSPSA()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:semiautomaticTuning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the constraint function\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "setConstraint",
          "package": "spsa",
          "signature": "ConstraintFn -\u003e StateSPSA ()",
          "source": "src/Math-Optimization-SPSA-Types.html#setConstraint",
          "type": "function"
        },
        "index": {
          "description": "Set the constraint function",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "setConstraint",
          "normalized": "ConstraintFn-\u003eStateSPSA()",
          "package": "spsa",
          "partial": "Constraint",
          "signature": "ConstraintFn-\u003eStateSPSA()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:setConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the gainA sequence\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "setGainA",
          "package": "spsa",
          "signature": "[Double] -\u003e StateSPSA ()",
          "source": "src/Math-Optimization-SPSA-Types.html#setGainA",
          "type": "function"
        },
        "index": {
          "description": "Set the gainA sequence",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "setGainA",
          "normalized": "[Double]-\u003eStateSPSA()",
          "package": "spsa",
          "partial": "Gain",
          "signature": "[Double]-\u003eStateSPSA()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:setGainA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the gainC sequence\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "setGainC",
          "package": "spsa",
          "signature": "[Double] -\u003e StateSPSA ()",
          "source": "src/Math-Optimization-SPSA-Types.html#setGainC",
          "type": "function"
        },
        "index": {
          "description": "Set the gainC sequence",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "setGainC",
          "normalized": "[Double]-\u003eStateSPSA()",
          "package": "spsa",
          "partial": "Gain",
          "signature": "[Double]-\u003eStateSPSA()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:setGainC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the loss function\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "setLoss",
          "package": "spsa",
          "signature": "LossFn -\u003e StateSPSA ()",
          "source": "src/Math-Optimization-SPSA-Types.html#setLoss",
          "type": "function"
        },
        "index": {
          "description": "Set the loss function",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "setLoss",
          "normalized": "LossFn-\u003eStateSPSA()",
          "package": "spsa",
          "partial": "Loss",
          "signature": "LossFn-\u003eStateSPSA()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:setLoss"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the perturbation sequence\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "setPerturbation",
          "package": "spsa",
          "signature": "[Vector Double] -\u003e StateSPSA ()",
          "source": "src/Math-Optimization-SPSA-Types.html#setPerturbation",
          "type": "function"
        },
        "index": {
          "description": "Set the perturbation sequence",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "setPerturbation",
          "normalized": "[Vector Double]-\u003eStateSPSA()",
          "package": "spsa",
          "partial": "Perturbation",
          "signature": "[Vector Double]-\u003eStateSPSA()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:setPerturbation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck to see if we should stop based on the critieria, iteration count, last and current iteration\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "shouldStop",
          "package": "spsa",
          "signature": "StoppingCriteria -\u003e Int -\u003e Vector Double -\u003e Vector Double -\u003e Bool",
          "source": "src/Math-Optimization-SPSA-Types.html#shouldStop",
          "type": "function"
        },
        "index": {
          "description": "Check to see if we should stop based on the critieria iteration count last and current iteration",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "shouldStop",
          "normalized": "StoppingCriteria-\u003eInt-\u003eVector Double-\u003eVector Double-\u003eBool",
          "package": "spsa",
          "partial": "Stop",
          "signature": "StoppingCriteria-\u003eInt-\u003eVector Double-\u003eVector Double-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:shouldStop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard gain sequence for a_k = a / (k + 1 + A) ^ alpha\n | a is the most important and variable tuning parameter. Start with it set to get desired change in first iteration.\n | A is usually set to 10% of expected iterations\n | alpha is usually set to 0.602, but is valid up to 1.0 (the optimal for infinite iterations)\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "standardGainAk",
          "package": "spsa",
          "signature": "Double -\u003e Int -\u003e Double -\u003e [Double]",
          "source": "src/Math-Optimization-SPSA-Construction.html#standardGainAk",
          "type": "function"
        },
        "index": {
          "description": "Standard gain sequence for alpha is the most important and variable tuning parameter Start with it set to get desired change in first iteration is usually set to of expected iterations alpha is usually set to but is valid up to the optimal for infinite iterations",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "standardGainAk",
          "normalized": "Double-\u003eInt-\u003eDouble-\u003e[Double]",
          "package": "spsa",
          "partial": "Gain Ak",
          "signature": "Double-\u003eInt-\u003eDouble-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:standardGainAk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard gain sequence for c_k\n\u003c/p\u003e",
          "module": "Math.Optimization.SPSA",
          "name": "standardGainCk",
          "package": "spsa",
          "signature": "Double -\u003e Double -\u003e [Double]",
          "source": "src/Math-Optimization-SPSA-Construction.html#standardGainCk",
          "type": "function"
        },
        "index": {
          "description": "Standard gain sequence for",
          "hierarchy": "Math Optimization SPSA",
          "module": "Math.Optimization.SPSA",
          "name": "standardGainCk",
          "normalized": "Double-\u003eDouble-\u003e[Double]",
          "package": "spsa",
          "partial": "Gain Ck",
          "signature": "Double-\u003eDouble-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/spsa/docs/Math-Optimization-SPSA.html#v:standardGainCk"
      }
    }
  ]
]