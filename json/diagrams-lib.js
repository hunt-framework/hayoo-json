[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "diagrams-lib"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003cem\u003ealignment\u003c/em\u003e of an object refers to the position of its local\n origin with respect to its envelope.  This module defines the\n \u003ccode\u003e\u003ca\u003eAlignable\u003c/a\u003e\u003c/code\u003e class for things which can be aligned, as well as a\n default implementation in terms of \u003ccode\u003e\u003ca\u003eHasOrigin\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eEnveloped\u003c/a\u003e\u003c/code\u003e,\n along with several utility methods for alignment.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Align",
          "name": "Align",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Align.html",
          "type": "module"
        },
        "index": {
          "description": "The alignment of an object refers to the position of its local origin with respect to its envelope This module defines the Alignable class for things which can be aligned as well as default implementation in terms of HasOrigin and Enveloped along with several utility methods for alignment",
          "hierarchy": "Diagrams Align",
          "module": "Diagrams.Align",
          "name": "Align",
          "package": "diagrams-lib",
          "partial": "Align",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Align.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass of things which can be aligned.\n\u003c/p\u003e",
          "module": "Diagrams.Align",
          "name": "Alignable",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Align.html#Alignable",
          "type": "class"
        },
        "index": {
          "description": "Class of things which can be aligned",
          "hierarchy": "Diagrams Align",
          "module": "Diagrams.Align",
          "name": "Alignable",
          "package": "diagrams-lib",
          "partial": "Alignable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Align.html#t:Alignable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ealign v\u003c/code\u003e aligns an enveloped object along the edge in the\n   direction of \u003ccode\u003ev\u003c/code\u003e.  That is, it moves the local origin in the\n   direction of \u003ccode\u003ev\u003c/code\u003e until it is on the edge of the envelope.  (Note\n   that if the local origin is outside the envelope to begin with,\n   it may have to move \"backwards\".)\n\u003c/p\u003e",
          "module": "Diagrams.Align",
          "name": "align",
          "package": "diagrams-lib",
          "signature": "V a -\u003e a -\u003e a",
          "source": "src/Diagrams-Align.html#align",
          "type": "function"
        },
        "index": {
          "description": "align aligns an enveloped object along the edge in the direction of That is it moves the local origin in the direction of until it is on the edge of the envelope Note that if the local origin is outside the envelope to begin with it may have to move backwards",
          "hierarchy": "Diagrams Align",
          "module": "Diagrams.Align",
          "name": "align",
          "normalized": "V a-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "V a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Align.html#v:align"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Align",
          "name": "alignBy",
          "package": "diagrams-lib",
          "signature": "V a -\u003e Scalar (V a) -\u003e a -\u003e a",
          "source": "src/Diagrams-Align.html#alignBy",
          "type": "method"
        },
        "index": {
          "hierarchy": "Diagrams Align",
          "module": "Diagrams.Align",
          "name": "alignBy",
          "normalized": "V a-\u003eScalar(V a)-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "By",
          "signature": "V a-\u003eScalar(V a)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Align.html#v:alignBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ealignBy v d a\u003c/code\u003e moves the origin of \u003ccode\u003ea\u003c/code\u003e along the vector\n   \u003ccode\u003ev\u003c/code\u003e. If \u003ccode\u003ed = 1\u003c/code\u003e, the origin is moved to the edge of the\n   boundary in the direction of \u003ccode\u003ev\u003c/code\u003e; if \u003ccode\u003ed = -1\u003c/code\u003e, it moves to the\n   edge of the boundary in the direction of the negation of \u003ccode\u003ev\u003c/code\u003e.\n   Other values of \u003ccode\u003ed\u003c/code\u003e interpolate linearly (so for example, \u003ccode\u003ed =\n   0\u003c/code\u003e centers the origin along the direction of \u003ccode\u003ev\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Diagrams.Align",
          "name": "alignBy'",
          "package": "diagrams-lib",
          "signature": "(V a -\u003e a -\u003e Point (V a)) -\u003e V a -\u003e Scalar (V a) -\u003e a -\u003e a",
          "source": "src/Diagrams-Align.html#alignBy%27",
          "type": "method"
        },
        "index": {
          "description": "alignBy moves the origin of along the vector If the origin is moved to the edge of the boundary in the direction of if it moves to the edge of the boundary in the direction of the negation of Other values of interpolate linearly so for example centers the origin along the direction of",
          "hierarchy": "Diagrams Align",
          "module": "Diagrams.Align",
          "name": "alignBy'",
          "normalized": "(V a-\u003ea-\u003ePoint(V a))-\u003eV a-\u003eScalar(V a)-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "By'",
          "signature": "(V a-\u003ea-\u003ePoint(V a))-\u003eV a-\u003eScalar(V a)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Align.html#v:alignBy-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault implementation of \u003ccode\u003e\u003ca\u003ealignBy\u003c/a\u003e\u003c/code\u003e for types with \u003ccode\u003e\u003ca\u003eHasOrigin\u003c/a\u003e\u003c/code\u003e\n   and \u003ccode\u003e\u003ca\u003eAdditiveGroup\u003c/a\u003e\u003c/code\u003e instances.\n\u003c/p\u003e",
          "module": "Diagrams.Align",
          "name": "alignBy'Default",
          "package": "diagrams-lib",
          "signature": "(V a -\u003e a -\u003e Point (V a)) -\u003e V a -\u003e Scalar (V a) -\u003e a -\u003e a",
          "source": "src/Diagrams-Align.html#alignBy%27Default",
          "type": "function"
        },
        "index": {
          "description": "Default implementation of alignBy for types with HasOrigin and AdditiveGroup instances",
          "hierarchy": "Diagrams Align",
          "module": "Diagrams.Align",
          "name": "alignBy'Default",
          "normalized": "(V a-\u003ea-\u003ePoint(V a))-\u003eV a-\u003eScalar(V a)-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "By' Default",
          "signature": "(V a-\u003ea-\u003ePoint(V a))-\u003eV a-\u003eScalar(V a)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Align.html#v:alignBy-39-Default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecenter v\u003c/code\u003e centers an enveloped object along the direction of\n   \u003ccode\u003ev\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Align",
          "name": "center",
          "package": "diagrams-lib",
          "signature": "V a -\u003e a -\u003e a",
          "source": "src/Diagrams-Align.html#center",
          "type": "function"
        },
        "index": {
          "description": "center centers an enveloped object along the direction of",
          "hierarchy": "Diagrams Align",
          "module": "Diagrams.Align",
          "name": "center",
          "normalized": "V a-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "V a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Align.html#v:center"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Align",
          "name": "defaultBoundary",
          "package": "diagrams-lib",
          "signature": "V a -\u003e a -\u003e Point (V a)",
          "source": "src/Diagrams-Align.html#defaultBoundary",
          "type": "method"
        },
        "index": {
          "hierarchy": "Diagrams Align",
          "module": "Diagrams.Align",
          "name": "defaultBoundary",
          "normalized": "V a-\u003ea-\u003ePoint(V a)",
          "package": "diagrams-lib",
          "partial": "Boundary",
          "signature": "V a-\u003ea-\u003ePoint(V a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Align.html#v:defaultBoundary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome standard functions which can be used as the \u003ccode\u003eboundary\u003c/code\u003e argument to\n  \u003ccode\u003e\u003ca\u003ealignBy'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Align",
          "name": "envelopeBoundary",
          "package": "diagrams-lib",
          "signature": "V a -\u003e a -\u003e Point (V a)",
          "source": "src/Diagrams-Align.html#envelopeBoundary",
          "type": "function"
        },
        "index": {
          "description": "Some standard functions which can be used as the boundary argument to alignBy",
          "hierarchy": "Diagrams Align",
          "module": "Diagrams.Align",
          "name": "envelopeBoundary",
          "normalized": "V a-\u003ea-\u003ePoint(V a)",
          "package": "diagrams-lib",
          "partial": "Boundary",
          "signature": "V a-\u003ea-\u003ePoint(V a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Align.html#v:envelopeBoundary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike align but uses trace.\n\u003c/p\u003e",
          "module": "Diagrams.Align",
          "name": "snug",
          "package": "diagrams-lib",
          "signature": "V a -\u003e a -\u003e a",
          "source": "src/Diagrams-Align.html#snug",
          "type": "function"
        },
        "index": {
          "description": "Like align but uses trace",
          "hierarchy": "Diagrams Align",
          "module": "Diagrams.Align",
          "name": "snug",
          "normalized": "V a-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "V a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Align.html#v:snug"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVersion of \u003ccode\u003ealignBy\u003c/code\u003e specialized to use \u003ccode\u003etraceBoundary\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Diagrams.Align",
          "name": "snugBy",
          "package": "diagrams-lib",
          "signature": "V a -\u003e Scalar (V a) -\u003e a -\u003e a",
          "source": "src/Diagrams-Align.html#snugBy",
          "type": "function"
        },
        "index": {
          "description": "Version of alignBy specialized to use traceBoundary",
          "hierarchy": "Diagrams Align",
          "module": "Diagrams.Align",
          "name": "snugBy",
          "normalized": "V a-\u003eScalar(V a)-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "By",
          "signature": "V a-\u003eScalar(V a)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Align.html#v:snugBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003ecenter\u003c/code\u003e using trace.\n\u003c/p\u003e",
          "module": "Diagrams.Align",
          "name": "snugCenter",
          "package": "diagrams-lib",
          "signature": "V a -\u003e a -\u003e a",
          "source": "src/Diagrams-Align.html#snugCenter",
          "type": "function"
        },
        "index": {
          "description": "Like center using trace",
          "hierarchy": "Diagrams Align",
          "module": "Diagrams.Align",
          "name": "snugCenter",
          "normalized": "V a-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Center",
          "signature": "V a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Align.html#v:snugCenter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Align",
          "name": "traceBoundary",
          "package": "diagrams-lib",
          "signature": "V a -\u003e a -\u003e Point (V a)",
          "source": "src/Diagrams-Align.html#traceBoundary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Align",
          "module": "Diagrams.Align",
          "name": "traceBoundary",
          "normalized": "V a-\u003ea-\u003ePoint(V a)",
          "package": "diagrams-lib",
          "partial": "Boundary",
          "signature": "V a-\u003ea-\u003ePoint(V a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Align.html#v:traceBoundary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA few utilities and class instances for \u003ccode\u003e\u003ca\u003eActive\u003c/a\u003e\u003c/code\u003e (from the \u003ccode\u003eactive\u003c/code\u003e\n package).  In particular, this module defines\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e An instance of \u003ccode\u003e\u003ca\u003eV\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eActive\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003e\u003ccode\u003e\u003ca\u003eV\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eActive\u003c/a\u003e\u003c/code\u003e a) = \u003ccode\u003e\u003ca\u003eV\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eHasOrigin\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eTransformable\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eHasStyle\u003c/a\u003e\u003c/code\u003e instances for\n     \u003ccode\u003e\u003ca\u003eActive\u003c/a\u003e\u003c/code\u003e which all work pointwise.\n\u003c/li\u003e\u003cli\u003e A \u003ccode\u003e\u003ca\u003eTrailLike\u003c/a\u003e\u003c/code\u003e instance for \u003ccode\u003e\u003ccode\u003e\u003ca\u003eActive\u003c/a\u003e\u003c/code\u003e p\u003c/code\u003e where \u003ccode\u003ep\u003c/code\u003e is also\n     \u003ccode\u003e\u003ca\u003eTrailLike\u003c/a\u003e\u003c/code\u003e, which simply lifts a pathlike thing to a constant\n     active value.\n\u003c/li\u003e\u003cli\u003e A \u003ccode\u003e\u003ca\u003eJuxtaposable\u003c/a\u003e\u003c/code\u003e instance for \u003ccode\u003e\u003ccode\u003e\u003ca\u003eActive\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e where \u003ccode\u003ea\u003c/code\u003e is also\n     \u003ccode\u003e\u003ca\u003eJuxtaposable\u003c/a\u003e\u003c/code\u003e.  An active value can be juxtaposed against\n     another by doing the juxtaposition pointwise over time.  The\n     era of \u003ccode\u003ejuxtapose v a1 a2\u003c/code\u003e will be the same as the era of \u003ccode\u003ea2\u003c/code\u003e,\n     unless \u003ccode\u003ea2\u003c/code\u003e is constant, in which case it will be the era of\n     \u003ccode\u003ea1\u003c/code\u003e.  (Note that \u003ccode\u003ejuxtapose v a1 a2\u003c/code\u003e and \u003ccode\u003eliftA2 (juxtapose v)\n     a1 a2\u003c/code\u003e therefore have different semantics: the second is an\n     active value whose era is the \u003cem\u003ecombination\u003c/em\u003e of the eras of \u003ccode\u003ea1\u003c/code\u003e\n     and \u003ccode\u003ea2\u003c/code\u003e).\n\u003c/li\u003e\u003cli\u003e An \u003ccode\u003eAlignable\u003c/code\u003e instance for \u003ccode\u003e\u003ccode\u003e\u003ca\u003eActive\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e where \u003ccode\u003ea\u003c/code\u003e is also\n     \u003ccode\u003eAlignable\u003c/code\u003e; the active value is aligned pointwise over time.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Diagrams.Animation.Active",
          "name": "Active",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Animation-Active.html",
          "type": "module"
        },
        "index": {
          "description": "few utilities and class instances for Active from the active package In particular this module defines An instance of for Active Active HasOrigin Transformable and HasStyle instances for Active which all work pointwise TrailLike instance for Active where is also TrailLike which simply lifts pathlike thing to constant active value Juxtaposable instance for Active where is also Juxtaposable An active value can be juxtaposed against another by doing the juxtaposition pointwise over time The era of juxtapose a1 a2 will be the same as the era of a2 unless a2 is constant in which case it will be the era of a1 Note that juxtapose a1 a2 and liftA2 juxtapose a1 a2 therefore have different semantics the second is an active value whose era is the combination of the eras of a1 and a2 An Alignable instance for Active where is also Alignable the active value is aligned pointwise over time",
          "hierarchy": "Diagrams Animation Active",
          "module": "Diagrams.Animation.Active",
          "name": "Active",
          "package": "diagrams-lib",
          "partial": "Active",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Animation-Active.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn animation is a time-varying diagram, together with start and end\n times.  Most of the tools for working with animations can actually\n be found in the \u003ccode\u003eactive\u003c/code\u003e package, which defines the \u003ccode\u003e\u003ca\u003eActive\u003c/a\u003e\u003c/code\u003e type.\n\u003c/p\u003e\u003cp\u003eXXX more documentation and examples should go here\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Animation",
          "name": "Animation",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Animation.html",
          "type": "module"
        },
        "index": {
          "description": "An animation is time-varying diagram together with start and end times Most of the tools for working with animations can actually be found in the active package which defines the Active type XXX more documentation and examples should go here",
          "hierarchy": "Diagrams Animation",
          "module": "Diagrams.Animation",
          "name": "Animation",
          "package": "diagrams-lib",
          "partial": "Animation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Animation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value of type \u003ccode\u003eAnimation b v\u003c/code\u003e is an animation (a time-varying\n   diagram with start and end times) in vector space \u003ccode\u003ev\u003c/code\u003e that can be\n   rendered by backspace \u003ccode\u003eb\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003eAnimation\u003c/code\u003e is actually a synonym for \u003ccode\u003eQAnimation\u003c/code\u003e\n   where the type of the monoidal annotations has been fixed to\n   \u003ccode\u003e\u003ca\u003eAny\u003c/a\u003e\u003c/code\u003e (the default).\n\u003c/p\u003e",
          "module": "Diagrams.Animation",
          "name": "Animation",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Animation.html#Animation",
          "type": "type"
        },
        "index": {
          "description": "value of type Animation is an animation time-varying diagram with start and end times in vector space that can be rendered by backspace Note that Animation is actually synonym for QAnimation where the type of the monoidal annotations has been fixed to Any the default",
          "hierarchy": "Diagrams Animation",
          "module": "Diagrams.Animation",
          "name": "Animation",
          "package": "diagrams-lib",
          "partial": "Animation",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Animation.html#t:Animation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value of type \u003ccode\u003eQAnimation b v m\u003c/code\u003e is an animation (a\n   time-varying diagram with start and end times) that can be\n   rendered by backspace \u003ccode\u003eb\u003c/code\u003e, with vector space \u003ccode\u003ev\u003c/code\u003e and monoidal\n   annotations of type \u003ccode\u003em\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Animation",
          "name": "QAnimation",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Animation.html#QAnimation",
          "type": "type"
        },
        "index": {
          "description": "value of type QAnimation is an animation time-varying diagram with start and end times that can be rendered by backspace with vector space and monoidal annotations of type",
          "hierarchy": "Diagrams Animation",
          "module": "Diagrams.Animation",
          "name": "QAnimation",
          "package": "diagrams-lib",
          "partial": "QAnimation",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Animation.html#t:QAnimation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAutomatically assign fixed a envelope to the entirety of an\n   animation by sampling the envelope at a number of points in time\n   and taking the union of all the sampled envelopes to form the\n   \"hull\".  This hull is then used uniformly throughout the\n   animation.\n\u003c/p\u003e\u003cp\u003eThis is useful when you have an animation that grows and shrinks\n   in size or shape over time, but you want it to take up a fixed\n   amount of space, \u003cem\u003ee.g.\u003c/em\u003e so that the final rendered movie does not\n   zoom in and out, or so that it occupies a fixed location with\n   respect to another animation, when combining animations with\n   something like \u003ccode\u003e|||\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eBy default, 30 samples per time unit are used; to adjust this\n   number see \u003ccode\u003e\u003ca\u003eanimEnvelope'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSee also \u003ccode\u003e\u003ca\u003eanimRect\u003c/a\u003e\u003c/code\u003e for help constructing a background to go\n   behind an animation.\n\u003c/p\u003e",
          "module": "Diagrams.Animation",
          "name": "animEnvelope",
          "package": "diagrams-lib",
          "signature": "QAnimation b v m -\u003e QAnimation b v m",
          "source": "src/Diagrams-Animation.html#animEnvelope",
          "type": "function"
        },
        "index": {
          "description": "Automatically assign fixed envelope to the entirety of an animation by sampling the envelope at number of points in time and taking the union of all the sampled envelopes to form the hull This hull is then used uniformly throughout the animation This is useful when you have an animation that grows and shrinks in size or shape over time but you want it to take up fixed amount of space e.g so that the final rendered movie does not zoom in and out or so that it occupies fixed location with respect to another animation when combining animations with something like By default samples per time unit are used to adjust this number see animEnvelope See also animRect for help constructing background to go behind an animation",
          "hierarchy": "Diagrams Animation",
          "module": "Diagrams.Animation",
          "name": "animEnvelope",
          "normalized": "QAnimation a b c-\u003eQAnimation a b c",
          "package": "diagrams-lib",
          "partial": "Envelope",
          "signature": "QAnimation b v m-\u003eQAnimation b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Animation.html#v:animEnvelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eanimEnvelope\u003c/a\u003e\u003c/code\u003e, but with an adjustible sample rate.  The first\n   parameter is the number of samples per time unit to use.  Lower\n   rates will be faster but less accurate; higher rates are more\n   accurate but slower.\n\u003c/p\u003e",
          "module": "Diagrams.Animation",
          "name": "animEnvelope'",
          "package": "diagrams-lib",
          "signature": "Rational -\u003e QAnimation b v m -\u003e QAnimation b v m",
          "source": "src/Diagrams-Animation.html#animEnvelope%27",
          "type": "function"
        },
        "index": {
          "description": "Like animEnvelope but with an adjustible sample rate The first parameter is the number of samples per time unit to use Lower rates will be faster but less accurate higher rates are more accurate but slower",
          "hierarchy": "Diagrams Animation",
          "module": "Diagrams.Animation",
          "name": "animEnvelope'",
          "normalized": "Rational-\u003eQAnimation a b c-\u003eQAnimation a b c",
          "package": "diagrams-lib",
          "partial": "Envelope'",
          "signature": "Rational-\u003eQAnimation b v m-\u003eQAnimation b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Animation.html#v:animEnvelope-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eanimRect\u003c/code\u003e works similarly to \u003ccode\u003e\u003ca\u003eanimEnvelope\u003c/a\u003e\u003c/code\u003e for 2D diagrams, but\n   instead of adjusting the envelope, simply returns the smallest\n   bounding rectangle which encloses the entire animation.  Useful\n   for \u003cem\u003ee.g.\u003c/em\u003e creating a background to go behind an animation.\n\u003c/p\u003e\u003cp\u003eUses 30 samples per time unit by default; to adjust this number\n   see \u003ccode\u003e\u003ca\u003eanimRect'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Animation",
          "name": "animRect",
          "package": "diagrams-lib",
          "signature": "QAnimation b R2 m -\u003e t",
          "source": "src/Diagrams-Animation.html#animRect",
          "type": "function"
        },
        "index": {
          "description": "animRect works similarly to animEnvelope for diagrams but instead of adjusting the envelope simply returns the smallest bounding rectangle which encloses the entire animation Useful for e.g creating background to go behind an animation Uses samples per time unit by default to adjust this number see animRect",
          "hierarchy": "Diagrams Animation",
          "module": "Diagrams.Animation",
          "name": "animRect",
          "normalized": "QAnimation a R b-\u003ec",
          "package": "diagrams-lib",
          "partial": "Rect",
          "signature": "QAnimation b R m-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Animation.html#v:animRect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eanimRect\u003c/a\u003e\u003c/code\u003e, but with an adjustible sample rate.  The first\n   parameter is the number of samples per time unit to use.  Lower\n   rates will be faster but less accurate; higher rates are more\n   accurate but slower.\n\u003c/p\u003e",
          "module": "Diagrams.Animation",
          "name": "animRect'",
          "package": "diagrams-lib",
          "signature": "Rational -\u003e QAnimation b R2 m -\u003e t",
          "source": "src/Diagrams-Animation.html#animRect%27",
          "type": "function"
        },
        "index": {
          "description": "Like animRect but with an adjustible sample rate The first parameter is the number of samples per time unit to use Lower rates will be faster but less accurate higher rates are more accurate but slower",
          "hierarchy": "Diagrams Animation",
          "module": "Diagrams.Animation",
          "name": "animRect'",
          "normalized": "Rational-\u003eQAnimation a R b-\u003ec",
          "package": "diagrams-lib",
          "partial": "Rect'",
          "signature": "Rational-\u003eQAnimation b R m-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Animation.html#v:animRect-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDiagrams may have \u003cem\u003eattributes\u003c/em\u003e which affect the way they are\n rendered.  This module defines some common attributes; particular\n backends may also define more backend-specific attributes.\n\u003c/p\u003e\u003cp\u003eEvery attribute type must have a \u003cem\u003esemigroup\u003c/em\u003e structure, that is, an\n associative binary operation for combining two attributes into one.\n Unless otherwise noted, all the attributes defined here use the\n \u003ccode\u003e\u003ca\u003eLast\u003c/a\u003e\u003c/code\u003e structure, that is, combining two attributes simply keeps\n the second one and throws away the first.  This means that child\n attributes always override parent attributes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Attributes",
          "name": "Attributes",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Attributes.html",
          "type": "module"
        },
        "index": {
          "description": "Diagrams may have attributes which affect the way they are rendered This module defines some common attributes particular backends may also define more backend-specific attributes Every attribute type must have semigroup structure that is an associative binary operation for combining two attributes into one Unless otherwise noted all the attributes defined here use the Last structure that is combining two attributes simply keeps the second one and throws away the first This means that child attributes always override parent attributes",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "Attributes",
          "package": "diagrams-lib",
          "partial": "Attributes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eColor\u003c/a\u003e\u003c/code\u003e type class encompasses color representations which\n   can be used by the Diagrams library.  Instances are provided for\n   both the \u003ccode\u003e\u003ca\u003eColour\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eAlphaColour\u003c/a\u003e\u003c/code\u003e types\n   from the \u003ca\u003eData.Colour\u003c/a\u003e library.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "Color",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Attributes.html#Color",
          "type": "class"
        },
        "index": {
          "description": "The Color type class encompasses color representations which can be used by the Diagrams library Instances are provided for both the Colour and AlphaColour types from the Data.Colour library",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "Color",
          "package": "diagrams-lib",
          "partial": "Color",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#t:Color"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate lines that are dashing... er, dashed.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "Dashing",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Attributes.html#Dashing",
          "type": "data"
        },
        "index": {
          "description": "Create lines that are dashing er dashed",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "Dashing",
          "package": "diagrams-lib",
          "partial": "Dashing",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#t:Dashing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "DashingA",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Attributes.html#DashingA",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "DashingA",
          "package": "diagrams-lib",
          "partial": "Dashing",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#t:DashingA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe color with which shapes are filled. Note that child\n   colors always override parent colors; that is, \u003ccode\u003e\u003ccode\u003e\u003ca\u003efillColor\u003c/a\u003e\u003c/code\u003e c1\n   . \u003ccode\u003e\u003ca\u003efillColor\u003c/a\u003e\u003c/code\u003e c2 $ d\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003elineColor\u003c/a\u003e\u003c/code\u003e c2 $ d\u003c/code\u003e.\n   More precisely, the semigroup structure on fill color attributes\n   is that of \u003ccode\u003e\u003ca\u003eLast\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "FillColor",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Attributes.html#FillColor",
          "type": "data"
        },
        "index": {
          "description": "The color with which shapes are filled Note that child colors always override parent colors that is fillColor c1 fillColor c2 is equivalent to lineColor c2 More precisely the semigroup structure on fill color attributes is that of Last",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "FillColor",
          "package": "diagrams-lib",
          "partial": "Fill Color",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#t:FillColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhat sort of shape should be placed at the endpoints of lines?\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "LineCap",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Attributes.html#LineCap",
          "type": "data"
        },
        "index": {
          "description": "What sort of shape should be placed at the endpoints of lines",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "LineCap",
          "package": "diagrams-lib",
          "partial": "Line Cap",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#t:LineCap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "LineCapA",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Attributes.html#LineCapA",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "LineCapA",
          "package": "diagrams-lib",
          "partial": "Line Cap",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#t:LineCapA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe color with which lines (strokes) are drawn.  Note that child\n   colors always override parent colors; that is, \u003ccode\u003e\u003ccode\u003e\u003ca\u003elineColor\u003c/a\u003e\u003c/code\u003e c1\n   . \u003ccode\u003e\u003ca\u003elineColor\u003c/a\u003e\u003c/code\u003e c2 $ d\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003elineColor\u003c/a\u003e\u003c/code\u003e c2 $ d\u003c/code\u003e.\n   More precisely, the semigroup structure on line color attributes\n   is that of \u003ccode\u003e\u003ca\u003eLast\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "LineColor",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Attributes.html#LineColor",
          "type": "data"
        },
        "index": {
          "description": "The color with which lines strokes are drawn Note that child colors always override parent colors that is lineColor c1 lineColor c2 is equivalent to lineColor c2 More precisely the semigroup structure on line color attributes is that of Last",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "LineColor",
          "package": "diagrams-lib",
          "partial": "Line Color",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#t:LineColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHow should the join points between line segments be drawn?\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "LineJoin",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Attributes.html#LineJoin",
          "type": "data"
        },
        "index": {
          "description": "How should the join points between line segments be drawn",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "LineJoin",
          "package": "diagrams-lib",
          "partial": "Line Join",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#t:LineJoin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "LineJoinA",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Attributes.html#LineJoinA",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "LineJoinA",
          "package": "diagrams-lib",
          "partial": "Line Join",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#t:LineJoinA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMiter limit attribute affecting the \u003ccode\u003e\u003ca\u003eLineJoinMiter\u003c/a\u003e\u003c/code\u003e joins.\n   For some backends this value may have additional effects.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "LineMiterLimit",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Attributes.html#LineMiterLimit",
          "type": "newtype"
        },
        "index": {
          "description": "Miter limit attribute affecting the LineJoinMiter joins For some backends this value may have additional effects",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "LineMiterLimit",
          "package": "diagrams-lib",
          "partial": "Line Miter Limit",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#t:LineMiterLimit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe width of lines.  By default, the line width is measured with\n   respect to the \u003cem\u003efinal\u003c/em\u003e coordinate system of a rendered diagram,\n   as opposed to the local coordinate systems in effect at the time\n   the line width was set for various subdiagrams.  This is so that\n   it is easy to combine a variety of shapes (some created by\n   scaling) and have them all drawn using a consistent line width.\n   However, sometimes it is desirable for scaling to affect line\n   width; the \u003ccode\u003e\u003ca\u003efreeze\u003c/a\u003e\u003c/code\u003e operation is provided for this purpose.  The\n   line width of frozen diagrams is affected by transformations.\n\u003c/p\u003e\u003cp\u003eLine widths specified on child nodes always override line widths\n   specified at parent nodes.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "LineWidth",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Attributes.html#LineWidth",
          "type": "data"
        },
        "index": {
          "description": "The width of lines By default the line width is measured with respect to the final coordinate system of rendered diagram as opposed to the local coordinate systems in effect at the time the line width was set for various subdiagrams This is so that it is easy to combine variety of shapes some created by scaling and have them all drawn using consistent line width However sometimes it is desirable for scaling to affect line width the freeze operation is provided for this purpose The line width of frozen diagrams is affected by transformations Line widths specified on child nodes always override line widths specified at parent nodes",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "LineWidth",
          "package": "diagrams-lib",
          "partial": "Line Width",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#t:LineWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlthough the individual colors in a diagram can have\n   transparency, the opacity/transparency of a diagram as a whole\n   can be specified with the \u003ccode\u003eOpacity\u003c/code\u003e attribute.  The opacity is a\n   value between 1 (completely opaque, the default) and 0\n   (completely transparent).  Opacity is multiplicative, that is,\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003eopacity\u003c/a\u003e\u003c/code\u003e o1 . \u003ccode\u003e\u003ca\u003eopacity\u003c/a\u003e\u003c/code\u003e o2 === \u003ccode\u003e\u003ca\u003eopacity\u003c/a\u003e\u003c/code\u003e (o1 * o2)\u003c/code\u003e.  In other\n   words, for example, \u003ccode\u003eopacity 0.8\u003c/code\u003e means \"decrease this diagram's\n   opacity to 80% of its previous opacity\".\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "Opacity",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Attributes.html#Opacity",
          "type": "data"
        },
        "index": {
          "description": "Although the individual colors in diagram can have transparency the opacity transparency of diagram as whole can be specified with the Opacity attribute The opacity is value between completely opaque the default and completely transparent Opacity is multiplicative that is opacity o1 opacity o2 opacity o1 o2 In other words for example opacity means decrease this diagram opacity to of its previous opacity",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "Opacity",
          "package": "diagrams-lib",
          "partial": "Opacity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#t:Opacity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn existential wrapper for instances of the \u003ccode\u003e\u003ca\u003eColor\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "SomeColor",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Attributes.html#SomeColor",
          "type": "data"
        },
        "index": {
          "description": "An existential wrapper for instances of the Color class",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "SomeColor",
          "package": "diagrams-lib",
          "partial": "Some Color",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#t:SomeColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "Dashing",
          "package": "diagrams-lib",
          "signature": "Dashing [Double] Double",
          "source": "src/Diagrams-Attributes.html#Dashing",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "Dashing",
          "normalized": "Dashing[Double]Double",
          "package": "diagrams-lib",
          "partial": "Dashing",
          "signature": "Dashing[Double]Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:Dashing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLines end precisely at their endpoints.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "LineCapButt",
          "package": "diagrams-lib",
          "signature": "LineCapButt",
          "source": "src/Diagrams-Attributes.html#LineCap",
          "type": "function"
        },
        "index": {
          "description": "Lines end precisely at their endpoints",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "LineCapButt",
          "package": "diagrams-lib",
          "partial": "Line Cap Butt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:LineCapButt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLines are capped with semicircles\n   centered on endpoints.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "LineCapRound",
          "package": "diagrams-lib",
          "signature": "LineCapRound",
          "source": "src/Diagrams-Attributes.html#LineCap",
          "type": "function"
        },
        "index": {
          "description": "Lines are capped with semicircles centered on endpoints",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "LineCapRound",
          "package": "diagrams-lib",
          "partial": "Line Cap Round",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:LineCapRound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLines are capped with a squares\n   centered on endpoints.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "LineCapSquare",
          "package": "diagrams-lib",
          "signature": "LineCapSquare",
          "source": "src/Diagrams-Attributes.html#LineCap",
          "type": "function"
        },
        "index": {
          "description": "Lines are capped with squares centered on endpoints",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "LineCapSquare",
          "package": "diagrams-lib",
          "partial": "Line Cap Square",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:LineCapSquare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse a \"bevel\" shape (whatever\n   that is).  Are these...\n   carpentry terms?\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "LineJoinBevel",
          "package": "diagrams-lib",
          "signature": "LineJoinBevel",
          "source": "src/Diagrams-Attributes.html#LineJoin",
          "type": "function"
        },
        "index": {
          "description": "Use bevel shape whatever that is Are these carpentry terms",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "LineJoinBevel",
          "package": "diagrams-lib",
          "partial": "Line Join Bevel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:LineJoinBevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse a \"miter\" shape (whatever that is).\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "LineJoinMiter",
          "package": "diagrams-lib",
          "signature": "LineJoinMiter",
          "source": "src/Diagrams-Attributes.html#LineJoin",
          "type": "function"
        },
        "index": {
          "description": "Use miter shape whatever that is",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "LineJoinMiter",
          "package": "diagrams-lib",
          "partial": "Line Join Miter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:LineJoinMiter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse rounded join points.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "LineJoinRound",
          "package": "diagrams-lib",
          "signature": "LineJoinRound",
          "source": "src/Diagrams-Attributes.html#LineJoin",
          "type": "function"
        },
        "index": {
          "description": "Use rounded join points",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "LineJoinRound",
          "package": "diagrams-lib",
          "partial": "Line Join Round",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:LineJoinRound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "LineMiterLimit",
          "package": "diagrams-lib",
          "signature": "LineMiterLimit (Last Double)",
          "source": "src/Diagrams-Attributes.html#LineMiterLimit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "LineMiterLimit",
          "package": "diagrams-lib",
          "partial": "Line Miter Limit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:LineMiterLimit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "SomeColor",
          "package": "diagrams-lib",
          "signature": "SomeColor c",
          "source": "src/Diagrams-Attributes.html#SomeColor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "SomeColor",
          "package": "diagrams-lib",
          "partial": "Some Color",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:SomeColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Renamed to colorToSRGBA.\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eConvert to sRGBA.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "colorToRGBA",
          "package": "diagrams-lib",
          "signature": "c -\u003e (Double, Double, Double, Double)",
          "source": "src/Diagrams-Attributes.html#colorToRGBA",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Renamed to colorToSRGBA Convert to sRGBA",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "colorToRGBA",
          "normalized": "a-\u003e(Double,Double,Double,Double)",
          "package": "diagrams-lib",
          "partial": "To RGBA",
          "signature": "c-\u003e(Double,Double,Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:colorToRGBA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert to sRGBA.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "colorToSRGBA",
          "package": "diagrams-lib",
          "signature": "c -\u003e (Double, Double, Double, Double)",
          "source": "src/Diagrams-Attributes.html#colorToSRGBA",
          "type": "function"
        },
        "index": {
          "description": "Convert to sRGBA",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "colorToSRGBA",
          "normalized": "a-\u003e(Double,Double,Double,Double)",
          "package": "diagrams-lib",
          "partial": "To SRGBA",
          "signature": "c-\u003e(Double,Double,Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:colorToSRGBA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the line dashing style.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "dashing",
          "package": "diagrams-lib",
          "signature": "[Double]-\u003e Double-\u003e a-\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Set the line dashing style",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "dashing",
          "normalized": "[Double]-\u003eDouble-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "[Double]-\u003eDouble-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:dashing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003efillColor\u003c/a\u003e\u003c/code\u003e, specialized to \u003ccode\u003e\u003ccode\u003e\u003ca\u003eColour\u003c/a\u003e\u003c/code\u003e Double\u003c/code\u003e\n   (i.e. opaque colors).\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "fc",
          "package": "diagrams-lib",
          "signature": "Colour Double -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#fc",
          "type": "function"
        },
        "index": {
          "description": "synonym for fillColor specialized to Colour Double i.e opaque colors",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "fc",
          "normalized": "Colour Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Colour Double-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:fc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003efillColor\u003c/a\u003e\u003c/code\u003e, specialized to \u003ccode\u003e\u003ccode\u003e\u003ca\u003eAlphaColour\u003c/a\u003e\u003c/code\u003e Double\u003c/code\u003e\n   (i.e. colors with transparency).\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "fcA",
          "package": "diagrams-lib",
          "signature": "AlphaColour Double -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#fcA",
          "type": "function"
        },
        "index": {
          "description": "synonym for fillColor specialized to AlphaColour Double i.e colors with transparency",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "fcA",
          "normalized": "AlphaColour Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "AlphaColour Double-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:fcA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the fill color.  This function is polymorphic in the color\n   type (so it can be used with either \u003ccode\u003e\u003ca\u003eColour\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eAlphaColour\u003c/a\u003e\u003c/code\u003e),\n   but this can sometimes create problems for type inference, so the\n   \u003ccode\u003e\u003ca\u003efc\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efcA\u003c/a\u003e\u003c/code\u003e variants are provided with more concrete types.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "fillColor",
          "package": "diagrams-lib",
          "signature": "c -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#fillColor",
          "type": "function"
        },
        "index": {
          "description": "Set the fill color This function is polymorphic in the color type so it can be used with either Colour or AlphaColour but this can sometimes create problems for type inference so the fc and fcA variants are provided with more concrete types",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "fillColor",
          "normalized": "a-\u003eb-\u003eb",
          "package": "diagrams-lib",
          "partial": "Color",
          "signature": "c-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:fillColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from an AlphaColour Double.  Note that this direction\n   may lose some information. For example, the instance for\n   \u003ccode\u003e\u003ca\u003eColour\u003c/a\u003e\u003c/code\u003e drops the alpha channel.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "fromAlphaColour",
          "package": "diagrams-lib",
          "signature": "AlphaColour Double -\u003e c",
          "source": "src/Diagrams-Attributes.html#fromAlphaColour",
          "type": "method"
        },
        "index": {
          "description": "Convert from an AlphaColour Double Note that this direction may lose some information For example the instance for Colour drops the alpha channel",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "fromAlphaColour",
          "normalized": "AlphaColour Double-\u003ea",
          "package": "diagrams-lib",
          "partial": "Alpha Colour",
          "signature": "AlphaColour Double-\u003ec",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:fromAlphaColour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "getDashing",
          "package": "diagrams-lib",
          "signature": "DashingA -\u003e Dashing",
          "source": "src/Diagrams-Attributes.html#getDashing",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "getDashing",
          "normalized": "DashingA-\u003eDashing",
          "package": "diagrams-lib",
          "partial": "Dashing",
          "signature": "DashingA-\u003eDashing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:getDashing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "getFillColor",
          "package": "diagrams-lib",
          "signature": "FillColor -\u003e SomeColor",
          "source": "src/Diagrams-Attributes.html#getFillColor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "getFillColor",
          "normalized": "FillColor-\u003eSomeColor",
          "package": "diagrams-lib",
          "partial": "Fill Color",
          "signature": "FillColor-\u003eSomeColor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:getFillColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "getLineCap",
          "package": "diagrams-lib",
          "signature": "LineCapA -\u003e LineCap",
          "source": "src/Diagrams-Attributes.html#getLineCap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "getLineCap",
          "normalized": "LineCapA-\u003eLineCap",
          "package": "diagrams-lib",
          "partial": "Line Cap",
          "signature": "LineCapA-\u003eLineCap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:getLineCap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "getLineColor",
          "package": "diagrams-lib",
          "signature": "LineColor -\u003e SomeColor",
          "source": "src/Diagrams-Attributes.html#getLineColor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "getLineColor",
          "normalized": "LineColor-\u003eSomeColor",
          "package": "diagrams-lib",
          "partial": "Line Color",
          "signature": "LineColor-\u003eSomeColor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:getLineColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "getLineJoin",
          "package": "diagrams-lib",
          "signature": "LineJoinA -\u003e LineJoin",
          "source": "src/Diagrams-Attributes.html#getLineJoin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "getLineJoin",
          "normalized": "LineJoinA-\u003eLineJoin",
          "package": "diagrams-lib",
          "partial": "Line Join",
          "signature": "LineJoinA-\u003eLineJoin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:getLineJoin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "getLineMiterLimit",
          "package": "diagrams-lib",
          "signature": "LineMiterLimit -\u003e Double",
          "source": "src/Diagrams-Attributes.html#getLineMiterLimit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "getLineMiterLimit",
          "normalized": "LineMiterLimit-\u003eDouble",
          "package": "diagrams-lib",
          "partial": "Line Miter Limit",
          "signature": "LineMiterLimit-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:getLineMiterLimit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "getLineWidth",
          "package": "diagrams-lib",
          "signature": "LineWidth -\u003e Double",
          "source": "src/Diagrams-Attributes.html#getLineWidth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "getLineWidth",
          "normalized": "LineWidth-\u003eDouble",
          "package": "diagrams-lib",
          "partial": "Line Width",
          "signature": "LineWidth-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:getLineWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "getOpacity",
          "package": "diagrams-lib",
          "signature": "Opacity -\u003e Double",
          "source": "src/Diagrams-Attributes.html#getOpacity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "getOpacity",
          "normalized": "Opacity-\u003eDouble",
          "package": "diagrams-lib",
          "partial": "Opacity",
          "signature": "Opacity-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:getOpacity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003elineColor\u003c/a\u003e\u003c/code\u003e, specialized to \u003ccode\u003e\u003ccode\u003e\u003ca\u003eColour\u003c/a\u003e\u003c/code\u003e Double\u003c/code\u003e\n   (i.e. opaque colors).\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "lc",
          "package": "diagrams-lib",
          "signature": "Colour Double -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#lc",
          "type": "function"
        },
        "index": {
          "description": "synonym for lineColor specialized to Colour Double i.e opaque colors",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "lc",
          "normalized": "Colour Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Colour Double-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:lc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003elineColor\u003c/a\u003e\u003c/code\u003e, specialized to \u003ccode\u003e\u003ccode\u003e\u003ca\u003eAlphaColour\u003c/a\u003e\u003c/code\u003e Double\u003c/code\u003e\n   (i.e. colors with transparency).\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "lcA",
          "package": "diagrams-lib",
          "signature": "AlphaColour Double -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#lcA",
          "type": "function"
        },
        "index": {
          "description": "synonym for lineColor specialized to AlphaColour Double i.e colors with transparency",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "lcA",
          "normalized": "AlphaColour Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "AlphaColour Double-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:lcA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the line end cap attribute.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "lineCap",
          "package": "diagrams-lib",
          "signature": "LineCap -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#lineCap",
          "type": "function"
        },
        "index": {
          "description": "Set the line end cap attribute",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "lineCap",
          "normalized": "LineCap-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Cap",
          "signature": "LineCap-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:lineCap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the line (stroke) color.  This function is polymorphic in the\n   color type (so it can be used with either \u003ccode\u003e\u003ca\u003eColour\u003c/a\u003e\u003c/code\u003e or\n   \u003ccode\u003e\u003ca\u003eAlphaColour\u003c/a\u003e\u003c/code\u003e), but this can sometimes create problems for type\n   inference, so the \u003ccode\u003e\u003ca\u003elc\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003elcA\u003c/a\u003e\u003c/code\u003e variants are provided with more\n   concrete types.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "lineColor",
          "package": "diagrams-lib",
          "signature": "c -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#lineColor",
          "type": "function"
        },
        "index": {
          "description": "Set the line stroke color This function is polymorphic in the color type so it can be used with either Colour or AlphaColour but this can sometimes create problems for type inference so the lc and lcA variants are provided with more concrete types",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "lineColor",
          "normalized": "a-\u003eb-\u003eb",
          "package": "diagrams-lib",
          "partial": "Color",
          "signature": "c-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:lineColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a \u003ccode\u003e\u003ca\u003elineColor\u003c/a\u003e\u003c/code\u003e attribute.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "lineColorA",
          "package": "diagrams-lib",
          "signature": "LineColor -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#lineColorA",
          "type": "function"
        },
        "index": {
          "description": "Apply lineColor attribute",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "lineColorA",
          "normalized": "LineColor-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Color",
          "signature": "LineColor-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:lineColorA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the segment join style.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "lineJoin",
          "package": "diagrams-lib",
          "signature": "LineJoin -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#lineJoin",
          "type": "function"
        },
        "index": {
          "description": "Set the segment join style",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "lineJoin",
          "normalized": "LineJoin-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Join",
          "signature": "LineJoin-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:lineJoin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the miter limit for joins with \u003ccode\u003e\u003ca\u003eLineJoinMiter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "lineMiterLimit",
          "package": "diagrams-lib",
          "signature": "Double -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#lineMiterLimit",
          "type": "function"
        },
        "index": {
          "description": "Set the miter limit for joins with LineJoinMiter",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "lineMiterLimit",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Miter Limit",
          "signature": "Double-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:lineMiterLimit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a \u003ccode\u003e\u003ca\u003eLineMiterLimit\u003c/a\u003e\u003c/code\u003e attribute.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "lineMiterLimitA",
          "package": "diagrams-lib",
          "signature": "LineMiterLimit -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#lineMiterLimitA",
          "type": "function"
        },
        "index": {
          "description": "Apply LineMiterLimit attribute",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "lineMiterLimitA",
          "normalized": "LineMiterLimit-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Miter Limit",
          "signature": "LineMiterLimit-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:lineMiterLimitA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the line (stroke) width.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "lineWidth",
          "package": "diagrams-lib",
          "signature": "Double -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#lineWidth",
          "type": "function"
        },
        "index": {
          "description": "Set the line stroke width",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "lineWidth",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Width",
          "signature": "Double-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:lineWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a \u003ccode\u003e\u003ca\u003eLineWidth\u003c/a\u003e\u003c/code\u003e attribute.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "lineWidthA",
          "package": "diagrams-lib",
          "signature": "LineWidth -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#lineWidthA",
          "type": "function"
        },
        "index": {
          "description": "Apply LineWidth attribute",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "lineWidthA",
          "normalized": "LineWidth-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Width",
          "signature": "LineWidth-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:lineWidthA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenient synonym for \u003ccode\u003e\u003ca\u003elineWidth\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "lw",
          "package": "diagrams-lib",
          "signature": "Double -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#lw",
          "type": "function"
        },
        "index": {
          "description": "convenient synonym for lineWidth",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "lw",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:lw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "mkFillColor",
          "package": "diagrams-lib",
          "signature": "c -\u003e FillColor",
          "source": "src/Diagrams-Attributes.html#mkFillColor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "mkFillColor",
          "normalized": "a-\u003eFillColor",
          "package": "diagrams-lib",
          "partial": "Fill Color",
          "signature": "c-\u003eFillColor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:mkFillColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "mkLineColor",
          "package": "diagrams-lib",
          "signature": "c -\u003e LineColor",
          "source": "src/Diagrams-Attributes.html#mkLineColor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "mkLineColor",
          "normalized": "a-\u003eLineColor",
          "package": "diagrams-lib",
          "partial": "Line Color",
          "signature": "c-\u003eLineColor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:mkLineColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiply the opacity (see \u003ccode\u003e\u003ca\u003eOpacity\u003c/a\u003e\u003c/code\u003e) by the given value.  For\n   example, \u003ccode\u003eopacity 0.8\u003c/code\u003e means \"decrease this diagram's opacity to\n   80% of its previous opacity\".\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "opacity",
          "package": "diagrams-lib",
          "signature": "Double -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#opacity",
          "type": "function"
        },
        "index": {
          "description": "Multiply the opacity see Opacity by the given value For example opacity means decrease this diagram opacity to of its previous opacity",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "opacity",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:opacity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet a \"recommended\" fill color, to be used only if no explicit\n   calls to \u003ccode\u003e\u003ca\u003efillColor\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003efc\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003efcA\u003c/a\u003e\u003c/code\u003e) are used.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "recommendFillColor",
          "package": "diagrams-lib",
          "signature": "c -\u003e a -\u003e a",
          "source": "src/Diagrams-Attributes.html#recommendFillColor",
          "type": "function"
        },
        "index": {
          "description": "Set recommended fill color to be used only if no explicit calls to fillColor or fc or fcA are used",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "recommendFillColor",
          "normalized": "a-\u003eb-\u003eb",
          "package": "diagrams-lib",
          "partial": "Fill Color",
          "signature": "c-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:recommendFillColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "someToAlpha",
          "package": "diagrams-lib",
          "signature": "SomeColor -\u003e AlphaColour Double",
          "source": "src/Diagrams-Attributes.html#someToAlpha",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "someToAlpha",
          "normalized": "SomeColor-\u003eAlphaColour Double",
          "package": "diagrams-lib",
          "partial": "To Alpha",
          "signature": "SomeColor-\u003eAlphaColour Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:someToAlpha"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "styleFillColor",
          "package": "diagrams-lib",
          "signature": "Setter (Style v) (Style v) c c'",
          "source": "src/Diagrams-Attributes.html#styleFillColor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "styleFillColor",
          "package": "diagrams-lib",
          "partial": "Fill Color",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:styleFillColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Attributes",
          "name": "styleLineColor",
          "package": "diagrams-lib",
          "signature": "Setter (Style v) (Style v) c c'",
          "source": "src/Diagrams-Attributes.html#styleLineColor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "styleLineColor",
          "package": "diagrams-lib",
          "partial": "Line Color",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:styleLineColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a color to its standard representation, AlphaColour.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "toAlphaColour",
          "package": "diagrams-lib",
          "signature": "c -\u003e AlphaColour Double",
          "source": "src/Diagrams-Attributes.html#toAlphaColour",
          "type": "method"
        },
        "index": {
          "description": "Convert color to its standard representation AlphaColour",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "toAlphaColour",
          "normalized": "a-\u003eAlphaColour Double",
          "package": "diagrams-lib",
          "partial": "Alpha Colour",
          "signature": "c-\u003eAlphaColour Double",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:toAlphaColour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert to an RGB space while preserving the alpha channel.\n\u003c/p\u003e",
          "module": "Diagrams.Attributes",
          "name": "toRGBAUsingSpace",
          "package": "diagrams-lib",
          "signature": "RGBSpace Double -\u003e c -\u003e (Double, Double, Double, Double)",
          "source": "src/Diagrams-Attributes.html#toRGBAUsingSpace",
          "type": "function"
        },
        "index": {
          "description": "Convert to an RGB space while preserving the alpha channel",
          "hierarchy": "Diagrams Attributes",
          "module": "Diagrams.Attributes",
          "name": "toRGBAUsingSpace",
          "normalized": "RGBSpace Double-\u003ea-\u003e(Double,Double,Double,Double)",
          "package": "diagrams-lib",
          "partial": "RGBAUsing Space",
          "signature": "RGBSpace Double-\u003ec-\u003e(Double,Double,Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Attributes.html#v:toRGBAUsingSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConvenient creation of command-line-driven executables for\n rendering diagrams.  This module provides a general framework\n and default behaviors for parsing command-line arguments,\n records for diagram creation options in various forms, and\n classes and instances for a unified entry point to command-line-driven\n diagram creation executables.\n\u003c/p\u003e\u003cp\u003eFor a tutorial on command-line diagram creation see\n \u003ca\u003ehttp://projects.haskell.org/diagrams/doc/cmdline.html\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "CmdLine",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Backend-CmdLine.html",
          "type": "module"
        },
        "index": {
          "description": "Convenient creation of command-line-driven executables for rendering diagrams This module provides general framework and default behaviors for parsing command-line arguments records for diagram creation options in various forms and classes and instances for unified entry point to command-line-driven diagram creation executables For tutorial on command-line diagram creation see http projects.haskell.org diagrams doc cmdline.html",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "CmdLine",
          "package": "diagrams-lib",
          "partial": "Cmd Line",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtra options for animations.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramAnimOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramAnimOpts",
          "type": "data"
        },
        "index": {
          "description": "Extra options for animations",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramAnimOpts",
          "package": "diagrams-lib",
          "partial": "Diagram Anim Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#t:DiagramAnimOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtra options for command-line looping.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramLoopOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramLoopOpts",
          "type": "data"
        },
        "index": {
          "description": "Extra options for command-line looping",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramLoopOpts",
          "package": "diagrams-lib",
          "partial": "Diagram Loop Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#t:DiagramLoopOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtra options for a program that can offer a choice\n   between multiple diagrams.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramMultiOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramMultiOpts",
          "type": "data"
        },
        "index": {
          "description": "Extra options for program that can offer choice between multiple diagrams",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramMultiOpts",
          "package": "diagrams-lib",
          "partial": "Diagram Multi Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#t:DiagramMultiOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard options most diagrams are likely to have.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramOpts",
          "type": "data"
        },
        "index": {
          "description": "Standard options most diagrams are likely to have",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramOpts",
          "package": "diagrams-lib",
          "partial": "Diagram Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#t:DiagramOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class represents the various ways we want to support diagram creation\n   from the command line.  It has the right instances to select between creating\n   single static diagrams, multiple static diagrams, static animations, and\n   functions that produce diagrams as long as the arguments are \u003ccode\u003e\u003ca\u003eParseable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eBackends are expected to create \u003ccode\u003eMainable\u003c/code\u003e instances for the types that are\n   suitable for generating output in the backend's format.  For instance,\n   Postscript can handle single diagrams, pages of diagrams, animations as\n   separate files, and association lists.  This implies instances for\n   \u003ccode\u003eDiagram Postscript R2\u003c/code\u003e, \u003ccode\u003e[Diagram Postscript R2]\u003c/code\u003e, \u003ccode\u003eAnimation Postscript R2\u003c/code\u003e,\n   and \u003ccode\u003e[(String,Diagram Postscript R2)]\u003c/code\u003e.  We can consider these as the base\n   cases for the function instance.\n\u003c/p\u003e\u003cp\u003eThe associated type \u003ccode\u003e\u003ca\u003eMainOpts\u003c/a\u003e\u003c/code\u003e describes the options which need to be parsed\n   from the command-line and passed to \u003ccode\u003emainRender\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "Mainable",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Backend-CmdLine.html#Mainable",
          "type": "class"
        },
        "index": {
          "description": "This class represents the various ways we want to support diagram creation from the command line It has the right instances to select between creating single static diagrams multiple static diagrams static animations and functions that produce diagrams as long as the arguments are Parseable Backends are expected to create Mainable instances for the types that are suitable for generating output in the backend format For instance Postscript can handle single diagrams pages of diagrams animations as separate files and association lists This implies instances for Diagram Postscript R2 Diagram Postscript R2 Animation Postscript R2 and String Diagram Postscript R2 We can consider these as the base cases for the function instance The associated type MainOpts describes the options which need to be parsed from the command-line and passed to mainRender",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "Mainable",
          "package": "diagrams-lib",
          "partial": "Mainable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#t:Mainable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParseable instances give a command line parser for a type.  If a custom\n   parser for a common type is wanted a newtype wrapper could be used to make\n   a new \u003ccode\u003e\u003ca\u003eParseable\u003c/a\u003e\u003c/code\u003e instance.  Notice that we do \u003cem\u003enot\u003c/em\u003e want as many\n   instances as \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e because we want to limit ourselves to things that make\n   sense to parse from the command line.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "Parseable",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Backend-CmdLine.html#Parseable",
          "type": "class"
        },
        "index": {
          "description": "Parseable instances give command line parser for type If custom parser for common type is wanted newtype wrapper could be used to make new Parseable instance Notice that we do not want as many instances as Read because we want to limit ourselves to things that make sense to parse from the command line",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "Parseable",
          "package": "diagrams-lib",
          "partial": "Parseable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#t:Parseable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class allows us to abstract over functions that take some arguments\n   and produce a final value.  When some \u003ccode\u003ed\u003c/code\u003e is an instance of\n   \u003ccode\u003e\u003ca\u003eToResult\u003c/a\u003e\u003c/code\u003e we get a type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eArgs\u003c/a\u003e\u003c/code\u003e d\u003c/code\u003e that is a type of \u003cem\u003eall\u003c/em\u003e the arguments\n   at once, and a type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eResultOf\u003c/a\u003e\u003c/code\u003e d\u003c/code\u003e that is the type of the final result from\n   some base case instance.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "ToResult",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Backend-CmdLine.html#ToResult",
          "type": "class"
        },
        "index": {
          "description": "This class allows us to abstract over functions that take some arguments and produce final value When some is an instance of ToResult we get type Args that is type of all the arguments at once and type ResultOf that is the type of the final result from some base case instance",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "ToResult",
          "package": "diagrams-lib",
          "partial": "To Result",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#t:ToResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramAnimOpts",
          "package": "diagrams-lib",
          "signature": "DiagramAnimOpts",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramAnimOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramAnimOpts",
          "package": "diagrams-lib",
          "partial": "Diagram Anim Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:DiagramAnimOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramLoopOpts",
          "package": "diagrams-lib",
          "signature": "DiagramLoopOpts",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramLoopOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramLoopOpts",
          "package": "diagrams-lib",
          "partial": "Diagram Loop Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:DiagramLoopOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramMultiOpts",
          "package": "diagrams-lib",
          "signature": "DiagramMultiOpts",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramMultiOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramMultiOpts",
          "package": "diagrams-lib",
          "partial": "Diagram Multi Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:DiagramMultiOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramOpts",
          "package": "diagrams-lib",
          "signature": "DiagramOpts",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "DiagramOpts",
          "package": "diagrams-lib",
          "partial": "Diagram Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:DiagramOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of frames per unit time to generate for the animation.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_fpu",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramAnimOpts",
          "type": "function"
        },
        "index": {
          "description": "Number of frames per unit time to generate for the animation",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_fpu",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:_fpu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFinal output height of diagram.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_height",
          "package": "diagrams-lib",
          "signature": "Maybe Int",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramOpts",
          "type": "function"
        },
        "index": {
          "description": "Final output height of diagram",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_height",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:_height"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterval in seconds at which to check for recompilation.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_interval",
          "package": "diagrams-lib",
          "signature": "Int",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramLoopOpts",
          "type": "function"
        },
        "index": {
          "description": "Interval in seconds at which to check for recompilation",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_interval",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:_interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlag to indicate that a list of available diagrams should\n   be printed to standard out.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_list",
          "package": "diagrams-lib",
          "signature": "Bool",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramMultiOpts",
          "type": "function"
        },
        "index": {
          "description": "Flag to indicate that list of available diagrams should be printed to standard out",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_list",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:_list"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlag to indicate that the program should loop creation.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_loop",
          "package": "diagrams-lib",
          "signature": "Bool",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramLoopOpts",
          "type": "function"
        },
        "index": {
          "description": "Flag to indicate that the program should loop creation",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_loop",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:_loop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput file path, format is typically chosen by extension.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_output",
          "package": "diagrams-lib",
          "signature": "FilePath",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramOpts",
          "type": "function"
        },
        "index": {
          "description": "Output file path format is typically chosen by extension",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_output",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:_output"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelected diagram to render.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_selection",
          "package": "diagrams-lib",
          "signature": "Maybe String",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramMultiOpts",
          "type": "function"
        },
        "index": {
          "description": "Selected diagram to render",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_selection",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:_selection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFile path for the source file to recompile.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_src",
          "package": "diagrams-lib",
          "signature": "Maybe FilePath",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramLoopOpts",
          "type": "function"
        },
        "index": {
          "description": "File path for the source file to recompile",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_src",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:_src"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFinal output width of diagram.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_width",
          "package": "diagrams-lib",
          "signature": "Maybe Int",
          "source": "src/Diagrams-Backend-CmdLine.html#DiagramOpts",
          "type": "function"
        },
        "index": {
          "description": "Final output width of diagram",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "_width",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:_width"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edefaultAnimMainRender\u003c/code\u003e is an implementation of \u003ccode\u003e\u003ca\u003emainRender\u003c/a\u003e\u003c/code\u003e which renders\n   an animation as numbered frames, named by extending the given output file\n   name by consecutive integers.  For example if the given output file name is\n   \u003ccode\u003efoo/blah.ext\u003c/code\u003e, the frames will be saved in \u003ccode\u003efoo/blah001.ext\u003c/code\u003e,\n   \u003ccode\u003efoo/blah002.ext\u003c/code\u003e, and so on (the number of padding digits used depends on\n   the total number of frames).  It is up to the user to take these images and\n   stitch them together into an actual animation format (using, \u003cem\u003ee.g.\u003c/em\u003e\n   \u003ccode\u003effmpeg\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eOf course, this is a rather crude method of rendering animations;\n   more sophisticated methods will likely be added in the future.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003efpu\u003c/code\u003e option from \u003ccode\u003e\u003ca\u003eDiagramAnimOpts\u003c/a\u003e\u003c/code\u003e can be used to control how many frames will\n   be output for each second (unit time) of animation.\n\u003c/p\u003e\u003cp\u003eThis function requires a lens into the structure that the particular backend\n   uses for it's diagram base case.  If \u003ccode\u003eMainOpts (Diagram b v) ~ DiagramOpts\u003c/code\u003e\n   then this lens will simply be \u003ccode\u003e\u003ca\u003eoutput\u003c/a\u003e\u003c/code\u003e.  For a backend supporting looping\n   it will most likely be \u003ccode\u003e_1 . output\u003c/code\u003e.  This lens is required because the\n   implementation works by modifying the output field and running the base \u003ccode\u003emainRender\u003c/code\u003e.\n   Typically a backend can write its \u003ccode\u003eAnimation B V\u003c/code\u003e instance as\n\u003c/p\u003e\u003cpre\u003e instance Mainable (Animation B V) where\n     type MainOpts (Animation B V) = (DiagramOpts, DiagramAnimOpts)\n     mainRender = defaultAnimMainRender output\n\u003c/pre\u003e\u003cp\u003eWe do not provide this instance in general so that backends can choose to\n   opt-in to this form or provide a different instance that makes more sense.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "defaultAnimMainRender",
          "package": "diagrams-lib",
          "signature": "Lens' (MainOpts (Diagram b v)) FilePath-\u003e (MainOpts (Diagram b v), DiagramAnimOpts)-\u003e Animation b v-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "defaultAnimMainRender is an implementation of mainRender which renders an animation as numbered frames named by extending the given output file name by consecutive integers For example if the given output file name is foo blah.ext the frames will be saved in foo blah001.ext foo blah002.ext and so on the number of padding digits used depends on the total number of frames It is up to the user to take these images and stitch them together into an actual animation format using e.g ffmpeg Of course this is rather crude method of rendering animations more sophisticated methods will likely be added in the future The fpu option from DiagramAnimOpts can be used to control how many frames will be output for each second unit time of animation This function requires lens into the structure that the particular backend uses for it diagram base case If MainOpts Diagram DiagramOpts then this lens will simply be output For backend supporting looping it will most likely be output This lens is required because the implementation works by modifying the output field and running the base mainRender Typically backend can write its Animation instance as instance Mainable Animation where type MainOpts Animation DiagramOpts DiagramAnimOpts mainRender defaultAnimMainRender output We do not provide this instance in general so that backends can choose to opt-in to this form or provide different instance that makes more sense",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "defaultAnimMainRender",
          "normalized": "Lens'(MainOpts(Diagram a b))FilePath-\u003e(MainOpts(Diagram a b),DiagramAnimOpts)-\u003eAnimation a b-\u003eIO()",
          "package": "diagrams-lib",
          "partial": "Anim Main Render",
          "signature": "Lens'(MainOpts(Diagram b v))FilePath-\u003e(MainOpts(Diagram b v),DiagramAnimOpts)-\u003eAnimation b v-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:defaultAnimMainRender"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edefaultMultiMainRender\u003c/code\u003e is an implementation of \u003ccode\u003e\u003ca\u003emainRender\u003c/a\u003e\u003c/code\u003e where\n   instead of a single diagram it takes a list of diagrams paired with names\n   as input.  The generated executable then takes a \u003ccode\u003e--selection\u003c/code\u003e option\n   specifying the name of the diagram that should be rendered.  The list of\n   available diagrams may also be printed by passing the option \u003ccode\u003e--list\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eTypically a backend can write its \u003ccode\u003e[(String,Diagram B V)]\u003c/code\u003e instance as\n\u003c/p\u003e\u003cpre\u003e instance Mainable [(String,Diagram B V)] where\n     type MainOpts [(String,Diagram B V)] = (DiagramOpts, DiagramMultiOpts)\n     mainRender = defaultMultiMainRender\n\u003c/pre\u003e\u003cp\u003eWe do not provide this instance in general so that backends can choose to\n   opt-in to this form or provide a different instance that makes more sense.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "defaultMultiMainRender",
          "package": "diagrams-lib",
          "signature": "(MainOpts d, DiagramMultiOpts) -\u003e [(String, d)] -\u003e IO ()",
          "source": "src/Diagrams-Backend-CmdLine.html#defaultMultiMainRender",
          "type": "function"
        },
        "index": {
          "description": "defaultMultiMainRender is an implementation of mainRender where instead of single diagram it takes list of diagrams paired with names as input The generated executable then takes selection option specifying the name of the diagram that should be rendered The list of available diagrams may also be printed by passing the option list Typically backend can write its String Diagram instance as instance Mainable String Diagram where type MainOpts String Diagram DiagramOpts DiagramMultiOpts mainRender defaultMultiMainRender We do not provide this instance in general so that backends can choose to opt-in to this form or provide different instance that makes more sense",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "defaultMultiMainRender",
          "normalized": "(MainOpts a,DiagramMultiOpts)-\u003e[(String,a)]-\u003eIO()",
          "package": "diagrams-lib",
          "partial": "Multi Main Render",
          "signature": "(MainOpts d,DiagramMultiOpts)-\u003e[(String,d)]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:defaultMultiMainRender"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommand line parser for \u003ccode\u003e\u003ca\u003eDiagramAnimOpts\u003c/a\u003e\u003c/code\u003e\n   Frames per unit is \u003ccode\u003e--fpu\u003c/code\u003e or \u003ccode\u003e-f\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "diagramAnimOpts",
          "package": "diagrams-lib",
          "signature": "Parser DiagramAnimOpts",
          "source": "src/Diagrams-Backend-CmdLine.html#diagramAnimOpts",
          "type": "function"
        },
        "index": {
          "description": "Command line parser for DiagramAnimOpts Frames per unit is fpu or",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "diagramAnimOpts",
          "package": "diagrams-lib",
          "partial": "Anim Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:diagramAnimOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommandLine parser for \u003ccode\u003e\u003ca\u003eDiagramLoopOpts\u003c/a\u003e\u003c/code\u003e\n   Loop is \u003ccode\u003e--loop\u003c/code\u003e or \u003ccode\u003e-l\u003c/code\u003e.\n   Source is \u003ccode\u003e--src\u003c/code\u003e or \u003ccode\u003e-s\u003c/code\u003e.\n   Interval is \u003ccode\u003e-i\u003c/code\u003e defaulting to one second.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "diagramLoopOpts",
          "package": "diagrams-lib",
          "signature": "Parser DiagramLoopOpts",
          "source": "src/Diagrams-Backend-CmdLine.html#diagramLoopOpts",
          "type": "function"
        },
        "index": {
          "description": "CommandLine parser for DiagramLoopOpts Loop is loop or Source is src or Interval is defaulting to one second",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "diagramLoopOpts",
          "package": "diagrams-lib",
          "partial": "Loop Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:diagramLoopOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommand line parser for \u003ccode\u003e\u003ca\u003eDiagramMultiOpts\u003c/a\u003e\u003c/code\u003e.\n   Selection is option \u003ccode\u003e--selection\u003c/code\u003e or \u003ccode\u003e-s\u003c/code\u003e.\n   List is \u003ccode\u003e--list\u003c/code\u003e or \u003ccode\u003e-l\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "diagramMultiOpts",
          "package": "diagrams-lib",
          "signature": "Parser DiagramMultiOpts",
          "source": "src/Diagrams-Backend-CmdLine.html#diagramMultiOpts",
          "type": "function"
        },
        "index": {
          "description": "Command line parser for DiagramMultiOpts Selection is option selection or List is list or",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "diagramMultiOpts",
          "package": "diagrams-lib",
          "partial": "Multi Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:diagramMultiOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommand line parser for \u003ccode\u003e\u003ca\u003eDiagramOpts\u003c/a\u003e\u003c/code\u003e.\n   Width is option \u003ccode\u003e--width\u003c/code\u003e or \u003ccode\u003e-w\u003c/code\u003e.\n   Height is option \u003ccode\u003e--height\u003c/code\u003e or \u003ccode\u003e-h\u003c/code\u003e (note we change help to be \u003ccode\u003e-?\u003c/code\u003e due to this).\n   Output is option \u003ccode\u003e--output\u003c/code\u003e or \u003ccode\u003e-o\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "diagramOpts",
          "package": "diagrams-lib",
          "signature": "Parser DiagramOpts",
          "source": "src/Diagrams-Backend-CmdLine.html#diagramOpts",
          "type": "function"
        },
        "index": {
          "description": "Command line parser for DiagramOpts Width is option width or Height is option height or note we change help to be due to this Output is option output or",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "diagramOpts",
          "package": "diagrams-lib",
          "partial": "Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:diagramOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "fpu",
          "package": "diagrams-lib",
          "signature": "Iso' DiagramAnimOpts Double",
          "source": "src/Diagrams-Backend-CmdLine.html#fpu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "fpu",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:fpu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "height",
          "package": "diagrams-lib",
          "signature": "Lens' DiagramOpts (Maybe Int)",
          "source": "src/Diagrams-Backend-CmdLine.html#height",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "height",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:height"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "interval",
          "package": "diagrams-lib",
          "signature": "Lens' DiagramLoopOpts Int",
          "source": "src/Diagrams-Backend-CmdLine.html#interval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "interval",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "list",
          "package": "diagrams-lib",
          "signature": "Lens' DiagramMultiOpts Bool",
          "source": "src/Diagrams-Backend-CmdLine.html#list",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "list",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:list"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "loop",
          "package": "diagrams-lib",
          "signature": "Lens' DiagramLoopOpts Bool",
          "source": "src/Diagrams-Backend-CmdLine.html#loop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "loop",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:loop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis method invokes the command-line parser resulting in an options\n value or ending the program with an error or help message.\n Typically the default instance will work.  If a different help message\n or parsing behavior is desired a new implementation is appropriate.\n\u003c/p\u003e\u003cp\u003eNote the \u003ccode\u003ed\u003c/code\u003e argument should only be needed to fix the type \u003ccode\u003ed\u003c/code\u003e.  Its\n value should not be relied on as a parameter.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "mainArgs",
          "package": "diagrams-lib",
          "signature": "d -\u003e IO (MainOpts d)",
          "source": "src/Diagrams-Backend-CmdLine.html#mainArgs",
          "type": "method"
        },
        "index": {
          "description": "This method invokes the command-line parser resulting in an options value or ending the program with an error or help message Typically the default instance will work If different help message or parsing behavior is desired new implementation is appropriate Note the argument should only be needed to fix the type Its value should not be relied on as parameter",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "mainArgs",
          "normalized": "a-\u003eIO(MainOpts a)",
          "package": "diagrams-lib",
          "partial": "Args",
          "signature": "d-\u003eIO(MainOpts d)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:mainArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBackend specific work of rendering with the given options and mainable\n value is done here.  All backend instances should implement this method.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "mainRender",
          "package": "diagrams-lib",
          "signature": "MainOpts d -\u003e d -\u003e IO ()",
          "source": "src/Diagrams-Backend-CmdLine.html#mainRender",
          "type": "method"
        },
        "index": {
          "description": "Backend specific work of rendering with the given options and mainable value is done here All backend instances should implement this method",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "mainRender",
          "normalized": "MainOpts a-\u003ea-\u003eIO()",
          "package": "diagrams-lib",
          "partial": "Render",
          "signature": "MainOpts d-\u003ed-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:mainRender"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMain entry point for command-line diagram creation.  This is the method\n that users will call from their program \u003ccode\u003emain\u003c/code\u003e.  For instance an expected\n user program would take the following form.\n\u003c/p\u003e\u003cpre\u003e import Diagrams.Prelude\n import Diagrams.Backend.TheBestBackend.CmdLine\n\n d :: Diagram B R2\n d = ...\n\n main = mainWith d\n\u003c/pre\u003e\u003cp\u003eMost backends should be able to use the default implementation.  A different\n implementation should be used to handle more complex interactions with the user.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "mainWith",
          "package": "diagrams-lib",
          "signature": "d -\u003e IO ()",
          "source": "src/Diagrams-Backend-CmdLine.html#mainWith",
          "type": "method"
        },
        "index": {
          "description": "Main entry point for command-line diagram creation This is the method that users will call from their program main For instance an expected user program would take the following form import Diagrams.Prelude import Diagrams.Backend.TheBestBackend.CmdLine Diagram R2 main mainWith Most backends should be able to use the default implementation different implementation should be used to handle more complex interactions with the user",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "mainWith",
          "normalized": "a-\u003eIO()",
          "package": "diagrams-lib",
          "partial": "With",
          "signature": "d-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:mainWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "output",
          "package": "diagrams-lib",
          "signature": "Lens' DiagramOpts FilePath",
          "source": "src/Diagrams-Backend-CmdLine.html#output",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "output",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:output"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "parser",
          "package": "diagrams-lib",
          "signature": "Parser a",
          "source": "src/Diagrams-Backend-CmdLine.html#parser",
          "type": "method"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "parser",
          "package": "diagrams-lib",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:parser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses a hexadecimal color.  The string can start with \u003ccode\u003e\"0x\"\u003c/code\u003e or \u003ccode\u003e\"#\"\u003c/code\u003e\n   or just be a string of hexadecimal values.  If four or three digits are\n   given each digit is repeated to form a full 24 or 32 bit color.  For\n   example, \u003ccode\u003e\"0xfc4\"\u003c/code\u003e is the same as \u003ccode\u003e\"0xffcc44\"\u003c/code\u003e.  When eight or six\n   digits are given each pair of digits is a color or alpha channel with the\n   order being red, green, blue, alpha.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.CmdLine",
          "name": "readHexColor",
          "package": "diagrams-lib",
          "signature": "String -\u003e Maybe (AlphaColour Double)",
          "source": "src/Diagrams-Backend-CmdLine.html#readHexColor",
          "type": "function"
        },
        "index": {
          "description": "Parses hexadecimal color The string can start with or or just be string of hexadecimal values If four or three digits are given each digit is repeated to form full or bit color For example xfc4 is the same as xffcc44 When eight or six digits are given each pair of digits is color or alpha channel with the order being red green blue alpha",
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "readHexColor",
          "normalized": "String-\u003eMaybe(AlphaColour Double)",
          "package": "diagrams-lib",
          "partial": "Hex Color",
          "signature": "String-\u003eMaybe(AlphaColour Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:readHexColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "selection",
          "package": "diagrams-lib",
          "signature": "Lens' DiagramMultiOpts (Maybe String)",
          "source": "src/Diagrams-Backend-CmdLine.html#selection",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "selection",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:selection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "src",
          "package": "diagrams-lib",
          "signature": "Lens' DiagramLoopOpts (Maybe FilePath)",
          "source": "src/Diagrams-Backend-CmdLine.html#src",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "src",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:src"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "toResult",
          "package": "diagrams-lib",
          "signature": "d -\u003e Args d -\u003e ResultOf d",
          "source": "src/Diagrams-Backend-CmdLine.html#toResult",
          "type": "method"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "toResult",
          "normalized": "a-\u003eArgs a-\u003eResultOf a",
          "package": "diagrams-lib",
          "partial": "Result",
          "signature": "d-\u003eArgs d-\u003eResultOf d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:toResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.CmdLine",
          "name": "width",
          "package": "diagrams-lib",
          "signature": "Lens' DiagramOpts (Maybe Int)",
          "source": "src/Diagrams-Backend-CmdLine.html#width",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend CmdLine",
          "module": "Diagrams.Backend.CmdLine",
          "name": "width",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-CmdLine.html#v:width"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA simple Show-based diagrams backend, for testing purposes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Backend.Show",
          "name": "Show",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Backend-Show.html",
          "type": "module"
        },
        "index": {
          "description": "simple Show-based diagrams backend for testing purposes",
          "hierarchy": "Diagrams Backend Show",
          "module": "Diagrams.Backend.Show",
          "name": "Show",
          "package": "diagrams-lib",
          "partial": "Show",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-Show.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eToken for identifying this backend.\n\u003c/p\u003e",
          "module": "Diagrams.Backend.Show",
          "name": "ShowBackend",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Backend-Show.html#ShowBackend",
          "type": "data"
        },
        "index": {
          "description": "Token for identifying this backend",
          "hierarchy": "Diagrams Backend Show",
          "module": "Diagrams.Backend.Show",
          "name": "ShowBackend",
          "package": "diagrams-lib",
          "partial": "Show Backend",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-Show.html#t:ShowBackend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.Show",
          "name": "ShowBackend",
          "package": "diagrams-lib",
          "signature": "ShowBackend",
          "source": "src/Diagrams-Backend-Show.html#ShowBackend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend Show",
          "module": "Diagrams.Backend.Show",
          "name": "ShowBackend",
          "package": "diagrams-lib",
          "partial": "Show Backend",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-Show.html#v:ShowBackend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.Show",
          "name": "renderMat",
          "package": "diagrams-lib",
          "signature": "[[a]] -\u003e Doc",
          "source": "src/Diagrams-Backend-Show.html#renderMat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend Show",
          "module": "Diagrams.Backend.Show",
          "name": "renderMat",
          "normalized": "[[a]]-\u003eDoc",
          "package": "diagrams-lib",
          "partial": "Mat",
          "signature": "[[a]]-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-Show.html#v:renderMat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Backend.Show",
          "name": "renderTransf",
          "package": "diagrams-lib",
          "signature": "Transformation v -\u003e Doc",
          "source": "src/Diagrams-Backend-Show.html#renderTransf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Backend Show",
          "module": "Diagrams.Backend.Show",
          "name": "renderTransf",
          "normalized": "Transformation a-\u003eDoc",
          "package": "diagrams-lib",
          "partial": "Transf",
          "signature": "Transformation v-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Backend-Show.html#v:renderTransf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBounding boxes are not very compositional (\u003cem\u003ee.g.\u003c/em\u003e it is not\n possible to do anything sensible with them under rotation), so they\n are not used in the diagrams core.  However, they do have their\n uses; this module provides definitions and functions for working\n with them.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "BoundingBox",
          "package": "diagrams-lib",
          "source": "src/Diagrams-BoundingBox.html",
          "type": "module"
        },
        "index": {
          "description": "Bounding boxes are not very compositional e.g it is not possible to do anything sensible with them under rotation so they are not used in the diagrams core However they do have their uses this module provides definitions and functions for working with them",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "BoundingBox",
          "package": "diagrams-lib",
          "partial": "Bounding Box",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA bounding box is an axis-aligned region determined by two points\n   indicating its \"lower\" and \"upper\" corners.  It can also represent\n   an empty bounding box - the points are wrapped in \u003ccode\u003eMaybe\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "BoundingBox",
          "package": "diagrams-lib",
          "source": "src/Diagrams-BoundingBox.html#BoundingBox",
          "type": "data"
        },
        "index": {
          "description": "bounding box is an axis-aligned region determined by two points indicating its lower and upper corners It can also represent an empty bounding box the points are wrapped in Maybe",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "BoundingBox",
          "package": "diagrams-lib",
          "partial": "Bounding Box",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#t:BoundingBox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a bounding box for any enveloped object (such as a diagram or path).\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "boundingBox",
          "package": "diagrams-lib",
          "signature": "a -\u003e BoundingBox (V a)",
          "source": "src/Diagrams-BoundingBox.html#boundingBox",
          "type": "function"
        },
        "index": {
          "description": "Create bounding box for any enveloped object such as diagram or path",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "boundingBox",
          "normalized": "a-\u003eBoundingBox(V a)",
          "package": "diagrams-lib",
          "partial": "Box",
          "signature": "a-\u003eBoundingBox(V a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:boundingBox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the size of the bounding box - the vector from the (component-wise)\n   lesser point to the greater point.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "boxExtents",
          "package": "diagrams-lib",
          "signature": "BoundingBox v -\u003e v",
          "source": "src/Diagrams-BoundingBox.html#boxExtents",
          "type": "function"
        },
        "index": {
          "description": "Get the size of the bounding box the vector from the component-wise lesser point to the greater point",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "boxExtents",
          "normalized": "BoundingBox a-\u003ea",
          "package": "diagrams-lib",
          "partial": "Extents",
          "signature": "BoundingBox v-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:boxExtents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransforms an enveloped thing to fit within a \u003ccode\u003eBoundingBox\u003c/code\u003e.  If it's\n   empty, then the result is also \u003ccode\u003emempty\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "boxFit",
          "package": "diagrams-lib",
          "signature": "BoundingBox (V a) -\u003e a -\u003e a",
          "source": "src/Diagrams-BoundingBox.html#boxFit",
          "type": "function"
        },
        "index": {
          "description": "Transforms an enveloped thing to fit within BoundingBox If it empty then the result is also mempty",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "boxFit",
          "normalized": "BoundingBox(V a)-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Fit",
          "signature": "BoundingBox(V a)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:boxFit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a transformation mapping points from one bounding box to the other.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "boxTransform",
          "package": "diagrams-lib",
          "signature": "BoundingBox v -\u003e BoundingBox v -\u003e Maybe (Transformation v)",
          "source": "src/Diagrams-BoundingBox.html#boxTransform",
          "type": "function"
        },
        "index": {
          "description": "Create transformation mapping points from one bounding box to the other",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "boxTransform",
          "normalized": "BoundingBox a-\u003eBoundingBox a-\u003eMaybe(Transformation a)",
          "package": "diagrams-lib",
          "partial": "Transform",
          "signature": "BoundingBox v-\u003eBoundingBox v-\u003eMaybe(Transformation v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:boxTransform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a point is contained in a bounding box (including its edges).\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "contains",
          "package": "diagrams-lib",
          "signature": "BoundingBox v -\u003e Point v -\u003e Bool",
          "source": "src/Diagrams-BoundingBox.html#contains",
          "type": "function"
        },
        "index": {
          "description": "Check whether point is contained in bounding box including its edges",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "contains",
          "normalized": "BoundingBox a-\u003ePoint a-\u003eBool",
          "package": "diagrams-lib",
          "signature": "BoundingBox v-\u003ePoint v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:contains"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a point is \u003cem\u003estrictly\u003c/em\u003e contained in a bounding box.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "contains'",
          "package": "diagrams-lib",
          "signature": "BoundingBox v -\u003e Point v -\u003e Bool",
          "source": "src/Diagrams-BoundingBox.html#contains%27",
          "type": "function"
        },
        "index": {
          "description": "Check whether point is strictly contained in bounding box",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "contains'",
          "normalized": "BoundingBox a-\u003ePoint a-\u003eBool",
          "package": "diagrams-lib",
          "signature": "BoundingBox v-\u003ePoint v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:contains-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn empty bounding box.  This is the same thing as \u003ccode\u003emempty\u003c/code\u003e, but it doesn't\n   require the same type constraints that the \u003ccode\u003eMonoid\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "emptyBox",
          "package": "diagrams-lib",
          "signature": "BoundingBox v",
          "source": "src/Diagrams-BoundingBox.html#emptyBox",
          "type": "function"
        },
        "index": {
          "description": "An empty bounding box This is the same thing as mempty but it doesn require the same type constraints that the Monoid",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "emptyBox",
          "package": "diagrams-lib",
          "partial": "Box",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:emptyBox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a bounding box from a point that is component-wise \u003ccode\u003e(\u003c=)\u003c/code\u003e than the\n   other.  If this is not the case, then \u003ccode\u003emempty\u003c/code\u003e is returned.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "fromCorners",
          "package": "diagrams-lib",
          "signature": "Point v -\u003e Point v -\u003e BoundingBox v",
          "source": "src/Diagrams-BoundingBox.html#fromCorners",
          "type": "function"
        },
        "index": {
          "description": "Create bounding box from point that is component-wise than the other If this is not the case then mempty is returned",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "fromCorners",
          "normalized": "Point a-\u003ePoint a-\u003eBoundingBox a",
          "package": "diagrams-lib",
          "partial": "Corners",
          "signature": "Point v-\u003ePoint v-\u003eBoundingBox v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:fromCorners"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a degenerate bounding \"box\" containing only a single point.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "fromPoint",
          "package": "diagrams-lib",
          "signature": "Point v -\u003e BoundingBox v",
          "source": "src/Diagrams-BoundingBox.html#fromPoint",
          "type": "function"
        },
        "index": {
          "description": "Create degenerate bounding box containing only single point",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "fromPoint",
          "normalized": "Point a-\u003eBoundingBox a",
          "package": "diagrams-lib",
          "partial": "Point",
          "signature": "Point v-\u003eBoundingBox v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:fromPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate the smallest bounding box containing all the given points.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "fromPoints",
          "package": "diagrams-lib",
          "signature": "[Point v] -\u003e BoundingBox v",
          "source": "src/Diagrams-BoundingBox.html#fromPoints",
          "type": "function"
        },
        "index": {
          "description": "Create the smallest bounding box containing all the given points",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "fromPoints",
          "normalized": "[Point a]-\u003eBoundingBox a",
          "package": "diagrams-lib",
          "partial": "Points",
          "signature": "[Point v]-\u003eBoundingBox v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:fromPoints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputes all of the corners of the bounding box.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "getAllCorners",
          "package": "diagrams-lib",
          "signature": "BoundingBox v -\u003e [Point v]",
          "source": "src/Diagrams-BoundingBox.html#getAllCorners",
          "type": "function"
        },
        "index": {
          "description": "Computes all of the corners of the bounding box",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "getAllCorners",
          "normalized": "BoundingBox a-\u003e[Point a]",
          "package": "diagrams-lib",
          "partial": "All Corners",
          "signature": "BoundingBox v-\u003e[Point v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:getAllCorners"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the lower and upper corners that define the bounding box.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "getCorners",
          "package": "diagrams-lib",
          "signature": "BoundingBox v -\u003e Maybe (Point v, Point v)",
          "source": "src/Diagrams-BoundingBox.html#getCorners",
          "type": "function"
        },
        "index": {
          "description": "Gets the lower and upper corners that define the bounding box",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "getCorners",
          "normalized": "BoundingBox a-\u003eMaybe(Point a,Point a)",
          "package": "diagrams-lib",
          "partial": "Corners",
          "signature": "BoundingBox v-\u003eMaybe(Point v,Point v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:getCorners"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether the first bounding box is contained inside\n   the second.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "inside",
          "package": "diagrams-lib",
          "signature": "BoundingBox v -\u003e BoundingBox v -\u003e Bool",
          "source": "src/Diagrams-BoundingBox.html#inside",
          "type": "function"
        },
        "index": {
          "description": "Test whether the first bounding box is contained inside the second",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "inside",
          "normalized": "BoundingBox a-\u003eBoundingBox a-\u003eBool",
          "package": "diagrams-lib",
          "signature": "BoundingBox v-\u003eBoundingBox v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:inside"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether the first bounding box is \u003cem\u003estrictly\u003c/em\u003e contained\n   inside the second.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "inside'",
          "package": "diagrams-lib",
          "signature": "BoundingBox v -\u003e BoundingBox v -\u003e Bool",
          "source": "src/Diagrams-BoundingBox.html#inside%27",
          "type": "function"
        },
        "index": {
          "description": "Test whether the first bounding box is strictly contained inside the second",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "inside'",
          "normalized": "BoundingBox a-\u003eBoundingBox a-\u003eBool",
          "package": "diagrams-lib",
          "signature": "BoundingBox v-\u003eBoundingBox v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:inside-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForm the largest bounding box contained within this given two\n   bounding boxes, or \u003ccode\u003eNothing\u003c/code\u003e if the two bounding boxes do not\n   overlap at all.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "intersection",
          "package": "diagrams-lib",
          "signature": "BoundingBox v -\u003e BoundingBox v -\u003e BoundingBox v",
          "source": "src/Diagrams-BoundingBox.html#intersection",
          "type": "function"
        },
        "index": {
          "description": "Form the largest bounding box contained within this given two bounding boxes or Nothing if the two bounding boxes do not overlap at all",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "intersection",
          "normalized": "BoundingBox a-\u003eBoundingBox a-\u003eBoundingBox a",
          "package": "diagrams-lib",
          "signature": "BoundingBox v-\u003eBoundingBox v-\u003eBoundingBox v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQueries whether the BoundingBox is empty.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "isEmptyBox",
          "package": "diagrams-lib",
          "signature": "BoundingBox v -\u003e Bool",
          "source": "src/Diagrams-BoundingBox.html#isEmptyBox",
          "type": "function"
        },
        "index": {
          "description": "Queries whether the BoundingBox is empty",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "isEmptyBox",
          "normalized": "BoundingBox a-\u003eBool",
          "package": "diagrams-lib",
          "partial": "Empty Box",
          "signature": "BoundingBox v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:isEmptyBox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether the first bounding box lies outside the second\n   (although they may intersect in their boundaries).\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "outside",
          "package": "diagrams-lib",
          "signature": "BoundingBox v -\u003e BoundingBox v -\u003e Bool",
          "source": "src/Diagrams-BoundingBox.html#outside",
          "type": "function"
        },
        "index": {
          "description": "Test whether the first bounding box lies outside the second although they may intersect in their boundaries",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "outside",
          "normalized": "BoundingBox a-\u003eBoundingBox a-\u003eBool",
          "package": "diagrams-lib",
          "signature": "BoundingBox v-\u003eBoundingBox v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:outside"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether the first bounding box lies \u003cem\u003estrictly\u003c/em\u003e outside the second\n   (they do not intersect at all).\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "outside'",
          "package": "diagrams-lib",
          "signature": "BoundingBox v -\u003e BoundingBox v -\u003e Bool",
          "source": "src/Diagrams-BoundingBox.html#outside%27",
          "type": "function"
        },
        "index": {
          "description": "Test whether the first bounding box lies strictly outside the second they do not intersect at all",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "outside'",
          "normalized": "BoundingBox a-\u003eBoundingBox a-\u003eBool",
          "package": "diagrams-lib",
          "signature": "BoundingBox v-\u003eBoundingBox v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:outside-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForm the smallest bounding box containing the given two bound union.  This\n   function is just an alias for \u003ccode\u003emappend\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.BoundingBox",
          "name": "union",
          "package": "diagrams-lib",
          "signature": "BoundingBox v -\u003e BoundingBox v -\u003e BoundingBox v",
          "source": "src/Diagrams-BoundingBox.html#union",
          "type": "function"
        },
        "index": {
          "description": "Form the smallest bounding box containing the given two bound union This function is just an alias for mappend",
          "hierarchy": "Diagrams BoundingBox",
          "module": "Diagrams.BoundingBox",
          "name": "union",
          "normalized": "BoundingBox a-\u003eBoundingBox a-\u003eBoundingBox a",
          "package": "diagrams-lib",
          "signature": "BoundingBox v-\u003eBoundingBox v-\u003eBoundingBox v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-BoundingBox.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHigher-level tools for combining diagrams.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Combinators",
          "name": "Combinators",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Combinators.html",
          "type": "module"
        },
        "index": {
          "description": "Higher-level tools for combining diagrams",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "Combinators",
          "package": "diagrams-lib",
          "partial": "Combinators",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMethods for concatenating diagrams.\n\u003c/p\u003e",
          "module": "Diagrams.Combinators",
          "name": "CatMethod",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Combinators.html#CatMethod",
          "type": "data"
        },
        "index": {
          "description": "Methods for concatenating diagrams",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "CatMethod",
          "package": "diagrams-lib",
          "partial": "Cat Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#t:CatMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptions for \u003ccode\u003e\u003ca\u003ecat'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Combinators",
          "name": "CatOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Combinators.html#CatOpts",
          "type": "data"
        },
        "index": {
          "description": "Options for cat",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "CatOpts",
          "package": "diagrams-lib",
          "partial": "Cat Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#t:CatOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormal catenation: simply put diagrams\n   next to one another (possibly with a\n   certain distance in between each). The\n   distance between successive diagram\n   \u003cem\u003eenvelopes\u003c/em\u003e will be consistent; the\n   distance between \u003cem\u003eorigins\u003c/em\u003e may vary if\n   the diagrams are of different sizes.\n\u003c/p\u003e",
          "module": "Diagrams.Combinators",
          "name": "Cat",
          "package": "diagrams-lib",
          "signature": "Cat",
          "source": "src/Diagrams-Combinators.html#CatMethod",
          "type": "function"
        },
        "index": {
          "description": "Normal catenation simply put diagrams next to one another possibly with certain distance in between each The distance between successive diagram envelopes will be consistent the distance between origins may vary if the diagrams are of different sizes",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "Cat",
          "package": "diagrams-lib",
          "partial": "Cat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:Cat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDistribution: place the local origins of\n   diagrams at regular intervals.  With\n   this method, the distance between\n   successive \u003cem\u003eorigins\u003c/em\u003e will be consistent\n   but the distance between envelopes may\n   not be.  Indeed, depending on the amount\n   of separation, diagrams may overlap.\n\u003c/p\u003e",
          "module": "Diagrams.Combinators",
          "name": "Distrib",
          "package": "diagrams-lib",
          "signature": "Distrib",
          "source": "src/Diagrams-Combinators.html#CatMethod",
          "type": "function"
        },
        "index": {
          "description": "Distribution place the local origins of diagrams at regular intervals With this method the distance between successive origins will be consistent but the distance between envelopes may not be Indeed depending on the amount of separation diagrams may overlap",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "Distrib",
          "package": "diagrams-lib",
          "partial": "Distrib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:Distrib"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eappends x ys\u003c/code\u003e appends each of the objects in \u003ccode\u003eys\u003c/code\u003e to the object\n   \u003ccode\u003ex\u003c/code\u003e in the corresponding direction.  Note that each object in\n   \u003ccode\u003eys\u003c/code\u003e is positioned beside \u003ccode\u003ex\u003c/code\u003e \u003cem\u003ewithout\u003c/em\u003e reference to the other\n   objects in \u003ccode\u003eys\u003c/code\u003e, so this is not the same as iterating \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_Combinators_appendsEx.svg#diagram=appendsEx&width=200\"/\u003e\n\u003c/p\u003e\u003cpre\u003e appendsEx = appends c (zip (iterateN 6 (rotateBy (1/6)) unitX) (repeat c))\n             # centerXY # pad 1.1\n   where c = circle 1\n\u003c/pre\u003e",
          "module": "Diagrams.Combinators",
          "name": "appends",
          "package": "diagrams-lib",
          "signature": "a -\u003e [(V a, a)] -\u003e a",
          "source": "src/Diagrams-Combinators.html#appends",
          "type": "function"
        },
        "index": {
          "description": "appends ys appends each of the objects in ys to the object in the corresponding direction Note that each object in ys is positioned beside without reference to the other objects in ys so this is not the same as iterating beside appendsEx appends zip iterateN rotateBy unitX repeat centerXY pad where circle",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "appends",
          "normalized": "a-\u003e[(V a,a)]-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003e[(V a,a)]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:appends"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenient synonym for \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e on diagrams, designed to be\n   used infix (to help remember which diagram goes on top of which\n   when combining them, namely, the first on top of the second).\n\u003c/p\u003e",
          "module": "Diagrams.Combinators",
          "name": "atop",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m -\u003e QDiagram b v m -\u003e QDiagram b v m",
          "type": "function"
        },
        "index": {
          "description": "convenient synonym for mappend on diagrams designed to be used infix to help remember which diagram goes on top of which when combining them namely the first on top of the second",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "atop",
          "normalized": "QDiagram a b c-\u003eQDiagram a b c-\u003eQDiagram a b c",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m-\u003eQDiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:atop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ebeneath\u003c/code\u003e is just a convenient synonym for \u003ccode\u003e\u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eatop\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e; that is,\n   \u003ccode\u003ed1 `beneath` d2\u003c/code\u003e is the diagram with \u003ccode\u003ed2\u003c/code\u003e superimposed on top of\n   \u003ccode\u003ed1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Combinators",
          "name": "beneath",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m -\u003e QDiagram b v m -\u003e QDiagram b v m",
          "source": "src/Diagrams-Combinators.html#beneath",
          "type": "function"
        },
        "index": {
          "description": "beneath is just convenient synonym for flip atop that is d1 beneath d2 is the diagram with d2 superimposed on top of d1",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "beneath",
          "normalized": "QDiagram a b c-\u003eQDiagram a b c-\u003eQDiagram a b c",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m-\u003eQDiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:beneath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePlace two monoidal objects (\u003cem\u003ei.e.\u003c/em\u003e diagrams, paths,\n   animations...) next to each other along the given vector.  In\n   particular, place the second object so that the vector points\n   from the local origin of the first object to the local origin of\n   the second object, at a distance so that their envelopes are just\n   tangent.  The local origin of the new, combined object is the\n   local origin of the first object (unless the first object is the\n   identity element, in which case the second object is returned\n   unchanged).\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_Combinators_besideEx.svg#diagram=besideEx&height=200\"/\u003e\n\u003c/p\u003e\u003cpre\u003e besideEx = beside (r2 (20,30))\n                   (circle 1 # fc orange)\n                   (circle 1.5 # fc purple)\n            # showOrigin\n            # centerXY # pad 1.1\n\u003c/pre\u003e\u003cp\u003eNote that \u003ccode\u003ebeside v\u003c/code\u003e is associative, so objects under \u003ccode\u003ebeside v\u003c/code\u003e\n   form a semigroup for any given vector \u003ccode\u003ev\u003c/code\u003e.  In fact, they also\n   form a monoid: \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e is clearly a right identity (\u003ccode\u003ebeside v d1\n   mempty === d1\u003c/code\u003e), and there should also be a special case to make\n   it a left identity, as described above.\n\u003c/p\u003e\u003cp\u003eIn older versions of diagrams, \u003ccode\u003ebeside\u003c/code\u003e put the local origin of\n   the result at the point of tangency between the two inputs.  That\n   semantics can easily be recovered by performing an alignment on\n   the first input before combining.  That is, if \u003ccode\u003ebeside'\u003c/code\u003e denotes\n   the old semantics,\n\u003c/p\u003e\u003cpre\u003e beside' v x1 x2 = beside v (x1 # align v) x2\n\u003c/pre\u003e\u003cp\u003eTo get something like \u003ccode\u003ebeside v x1 x2\u003c/code\u003e whose local origin is\n   identified with that of \u003ccode\u003ex2\u003c/code\u003e instead of \u003ccode\u003ex1\u003c/code\u003e, use \u003ccode\u003ebeside\n   (negateV v) x2 x1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Combinators",
          "name": "beside",
          "package": "diagrams-lib",
          "signature": "V a -\u003e a -\u003e a -\u003e a",
          "source": "src/Diagrams-Combinators.html#beside",
          "type": "function"
        },
        "index": {
          "description": "Place two monoidal objects i.e diagrams paths animations next to each other along the given vector In particular place the second object so that the vector points from the local origin of the first object to the local origin of the second object at distance so that their envelopes are just tangent The local origin of the new combined object is the local origin of the first object unless the first object is the identity element in which case the second object is returned unchanged besideEx beside r2 circle fc orange circle fc purple showOrigin centerXY pad Note that beside is associative so objects under beside form semigroup for any given vector In fact they also form monoid mempty is clearly right identity beside d1 mempty d1 and there should also be special case to make it left identity as described above In older versions of diagrams beside put the local origin of the result at the point of tangency between the two inputs That semantics can easily be recovered by performing an alignment on the first input before combining That is if beside denotes the old semantics beside x1 x2 beside x1 align x2 To get something like beside x1 x2 whose local origin is identified with that of x2 instead of x1 use beside negateV x2 x1",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "beside",
          "normalized": "V a-\u003ea-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "V a-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:beside"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecat v\u003c/code\u003e positions a list of objects so that their local origins\n   lie along a line in the direction of \u003ccode\u003ev\u003c/code\u003e.  Successive objects\n   will have their envelopes just touching.  The local origin\n   of the result will be the same as the local origin of the first\n   object.\n\u003c/p\u003e\u003cp\u003eSee also \u003ccode\u003e\u003ca\u003ecat'\u003c/a\u003e\u003c/code\u003e, which takes an extra options record allowing\n   certain aspects of the operation to be tweaked.\n\u003c/p\u003e",
          "module": "Diagrams.Combinators",
          "name": "cat",
          "package": "diagrams-lib",
          "signature": "V a -\u003e [a] -\u003e a",
          "source": "src/Diagrams-Combinators.html#cat",
          "type": "function"
        },
        "index": {
          "description": "cat positions list of objects so that their local origins lie along line in the direction of Successive objects will have their envelopes just touching The local origin of the result will be the same as the local origin of the first object See also cat which takes an extra options record allowing certain aspects of the operation to be tweaked",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "cat",
          "normalized": "V a-\u003e[a]-\u003ea",
          "package": "diagrams-lib",
          "signature": "V a-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:cat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ecat\u003c/a\u003e\u003c/code\u003e, but taking an extra \u003ccode\u003e\u003ca\u003eCatOpts\u003c/a\u003e\u003c/code\u003e arguments allowing the\n   user to specify\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The spacing method: catenation (uniform spacing between\n     envelopes) or distribution (uniform spacing between local\n     origins).  The default is catenation.\n\u003c/li\u003e\u003cli\u003e The amount of separation between successive diagram\n     envelopes/origins (depending on the spacing method).  The\n     default is 0.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eCatOpts\u003c/a\u003e\u003c/code\u003e is an instance of \u003ccode\u003e\u003ca\u003eDefault\u003c/a\u003e\u003c/code\u003e, so \u003ccode\u003e\u003ca\u003ewith\u003c/a\u003e\u003c/code\u003e may be used for\n   the second argument, as in \u003ccode\u003ecat' (1,2) with {sep = 2}\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003ecat' v with {catMethod = Distrib} === mconcat\u003c/code\u003e\n   (distributing with a separation of 0 is the same as\n   superimposing).\n\u003c/p\u003e",
          "module": "Diagrams.Combinators",
          "name": "cat'",
          "package": "diagrams-lib",
          "signature": "V a -\u003e CatOpts (V a) -\u003e [a] -\u003e a",
          "source": "src/Diagrams-Combinators.html#cat%27",
          "type": "function"
        },
        "index": {
          "description": "Like cat but taking an extra CatOpts arguments allowing the user to specify The spacing method catenation uniform spacing between envelopes or distribution uniform spacing between local origins The default is catenation The amount of separation between successive diagram envelopes origins depending on the spacing method The default is CatOpts is an instance of Default so with may be used for the second argument as in cat with sep Note that cat with catMethod Distrib mconcat distributing with separation of is the same as superimposing",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "cat'",
          "normalized": "V a-\u003eCatOpts(V a)-\u003e[a]-\u003ea",
          "package": "diagrams-lib",
          "signature": "V a-\u003eCatOpts(V a)-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:cat-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhich \u003ccode\u003e\u003ca\u003eCatMethod\u003c/a\u003e\u003c/code\u003e should be used:\n   normal catenation (default), or distribution?\n\u003c/p\u003e",
          "module": "Diagrams.Combinators",
          "name": "catMethod",
          "package": "diagrams-lib",
          "signature": "forall v.  Lens' (CatOpts v) CatMethod",
          "source": "src/Diagrams-Combinators.html#catMethod",
          "type": "function"
        },
        "index": {
          "description": "Which CatMethod should be used normal catenation default or distribution",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "catMethod",
          "package": "diagrams-lib",
          "partial": "Method",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:catMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine a list of diagrams (or paths) by using them to\n   \"decorate\" a concretely located trail, placing the local origin\n   of one object at each successive vertex of the trail. If the\n   trail and list of objects have different lengths, the extra tail\n   of the longer one is ignored.\n\u003c/p\u003e",
          "module": "Diagrams.Combinators",
          "name": "decorateLocatedTrail",
          "package": "diagrams-lib",
          "signature": "Located (Trail (V a)) -\u003e [a] -\u003e a",
          "source": "src/Diagrams-Combinators.html#decorateLocatedTrail",
          "type": "function"
        },
        "index": {
          "description": "Combine list of diagrams or paths by using them to decorate concretely located trail placing the local origin of one object at each successive vertex of the trail If the trail and list of objects have different lengths the extra tail of the longer one is ignored",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "decorateLocatedTrail",
          "normalized": "Located(Trail(V a))-\u003e[a]-\u003ea",
          "package": "diagrams-lib",
          "partial": "Located Trail",
          "signature": "Located(Trail(V a))-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:decorateLocatedTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine a list of diagrams (or paths) by using them to\n   \"decorate\" a path, placing the local origin of one object at\n   each successive vertex of the path.  If the path and list of objects\n   have different lengths, the extra tail of the longer one is\n   ignored.\n\u003c/p\u003e",
          "module": "Diagrams.Combinators",
          "name": "decoratePath",
          "package": "diagrams-lib",
          "signature": "Path (V a) -\u003e [a] -\u003e a",
          "source": "src/Diagrams-Combinators.html#decoratePath",
          "type": "function"
        },
        "index": {
          "description": "Combine list of diagrams or paths by using them to decorate path placing the local origin of one object at each successive vertex of the path If the path and list of objects have different lengths the extra tail of the longer one is ignored",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "decoratePath",
          "normalized": "Path(V a)-\u003e[a]-\u003ea",
          "package": "diagrams-lib",
          "partial": "Path",
          "signature": "Path(V a)-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:decoratePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine a list of diagrams (or paths) by using them to\n   \"decorate\" a trail, placing the local origin of one object at\n   each successive vertex of the trail.  The first vertex of the\n   trail is placed at the origin.  If the trail and list of objects\n   have different lengths, the extra tail of the longer one is\n   ignored.\n\u003c/p\u003e",
          "module": "Diagrams.Combinators",
          "name": "decorateTrail",
          "package": "diagrams-lib",
          "signature": "Trail (V a) -\u003e [a] -\u003e a",
          "source": "src/Diagrams-Combinators.html#decorateTrail",
          "type": "function"
        },
        "index": {
          "description": "Combine list of diagrams or paths by using them to decorate trail placing the local origin of one object at each successive vertex of the trail The first vertex of the trail is placed at the origin If the trail and list of objects have different lengths the extra tail of the longer one is ignored",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "decorateTrail",
          "normalized": "Trail(V a)-\u003e[a]-\u003ea",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "Trail(V a)-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:decorateTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eextrudeEnvelope v d\u003c/code\u003e asymmetrically \"extrudes\" the envelope of\n   a diagram in the given direction.  All parts of the envelope\n   within 90 degrees of this direction are modified, offset outwards\n   by the magnitude of the vector.\n\u003c/p\u003e\u003cp\u003eThis works by offsetting the envelope distance proportionally to\n   the cosine of the difference in angle, and leaving it unchanged\n   when this factor is negative.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Combinators\",\"Diagrams.Envelope\"]",
          "name": "extrudeEnvelope",
          "package": "diagrams-lib",
          "signature": "v -\u003e QDiagram b v m -\u003e QDiagram b v m",
          "source": "src/Diagrams-Combinators.html#extrudeEnvelope",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:extrudeEnvelope\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#v:extrudeEnvelope\"]"
        },
        "index": {
          "description": "extrudeEnvelope asymmetrically extrudes the envelope of diagram in the given direction All parts of the envelope within degrees of this direction are modified offset outwards by the magnitude of the vector This works by offsetting the envelope distance proportionally to the cosine of the difference in angle and leaving it unchanged when this factor is negative",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "extrudeEnvelope",
          "normalized": "a-\u003eQDiagram b a c-\u003eQDiagram b a c",
          "package": "diagrams-lib",
          "partial": "Envelope",
          "signature": "v-\u003eQDiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:extrudeEnvelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eintrudeEnvelope v d\u003c/code\u003e asymmetrically \"intrudes\" the envelope of\n   a diagram away from the given direction.  All parts of the envelope\n   within 90 degrees of this direction are modified, offset inwards\n   by the magnitude of the vector.\n\u003c/p\u003e\u003cp\u003eNote that this could create strange inverted envelopes, where\n   \u003ccode\u003e diameter v d \u003c 0 \u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Combinators\",\"Diagrams.Envelope\"]",
          "name": "intrudeEnvelope",
          "package": "diagrams-lib",
          "signature": "v -\u003e QDiagram b v m -\u003e QDiagram b v m",
          "source": "src/Diagrams-Combinators.html#intrudeEnvelope",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:intrudeEnvelope\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#v:intrudeEnvelope\"]"
        },
        "index": {
          "description": "intrudeEnvelope asymmetrically intrudes the envelope of diagram away from the given direction All parts of the envelope within degrees of this direction are modified offset inwards by the magnitude of the vector Note that this could create strange inverted envelopes where diameter",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "intrudeEnvelope",
          "normalized": "a-\u003eQDiagram b a c-\u003eQDiagram b a c",
          "package": "diagrams-lib",
          "partial": "Envelope",
          "signature": "v-\u003eQDiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:intrudeEnvelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003epad s\u003c/code\u003e \"pads\" a diagram, expanding its envelope by a factor of\n   \u003ccode\u003es\u003c/code\u003e (factors between 0 and 1 can be used to shrink the envelope).\n   Note that the envelope will expand with respect to the local\n   origin, so if the origin is not centered the padding may appear\n   \"uneven\".  If this is not desired, the origin can be centered\n   (using, e.g., \u003ccode\u003ecenterXY\u003c/code\u003e for 2D diagrams) before applying \u003ccode\u003epad\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Combinators\",\"Diagrams.Envelope\"]",
          "name": "pad",
          "package": "diagrams-lib",
          "signature": "Scalar v -\u003e QDiagram b v m -\u003e QDiagram b v m",
          "source": "src/Diagrams-Combinators.html#pad",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:pad\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#v:pad\"]"
        },
        "index": {
          "description": "pad pads diagram expanding its envelope by factor of factors between and can be used to shrink the envelope Note that the envelope will expand with respect to the local origin so if the origin is not centered the padding may appear uneven If this is not desired the origin can be centered using e.g centerXY for diagrams before applying pad",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "pad",
          "normalized": "Scalar a-\u003eQDiagram b a c-\u003eQDiagram b a c",
          "package": "diagrams-lib",
          "signature": "Scalar v-\u003eQDiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:pad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ephantom x\u003c/code\u003e produces a \"phantom\" diagram, which has the same\n   envelope and trace as \u003ccode\u003ex\u003c/code\u003e but produces no output.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Combinators\",\"Diagrams.Envelope\"]",
          "name": "phantom",
          "package": "diagrams-lib",
          "signature": "a -\u003e QDiagram b (V a) m",
          "source": "src/Diagrams-Combinators.html#phantom",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:phantom\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#v:phantom\"]"
        },
        "index": {
          "description": "phantom produces phantom diagram which has the same envelope and trace as but produces no output",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "phantom",
          "normalized": "a-\u003eQDiagram b(V a)c",
          "package": "diagrams-lib",
          "signature": "a-\u003eQDiagram b(V a)m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:phantom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePosition things absolutely: combine a list of objects\n   (e.g. diagrams or paths) by assigning them absolute positions in\n   the vector space of the combined object.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_Combinators_positionEx.svg#diagram=positionEx&height=300\"/\u003e\n\u003c/p\u003e\u003cpre\u003e positionEx = position (zip (map mkPoint [-3, -2.8 .. 3]) (repeat dot))\n   where dot       = circle 0.2 # fc black\n         mkPoint x = p2 (x,x^2)\n\u003c/pre\u003e",
          "module": "Diagrams.Combinators",
          "name": "position",
          "package": "diagrams-lib",
          "signature": "[(Point (V a), a)] -\u003e a",
          "source": "src/Diagrams-Combinators.html#position",
          "type": "function"
        },
        "index": {
          "description": "Position things absolutely combine list of objects e.g diagrams or paths by assigning them absolute positions in the vector space of the combined object positionEx position zip map mkPoint repeat dot where dot circle fc black mkPoint p2",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "position",
          "normalized": "[(Point(V a),a)]-\u003ea",
          "package": "diagrams-lib",
          "signature": "[(Point(V a),a)]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:position"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHow much separation should be used between successive diagrams\n   (default: 0)?  When \u003ccode\u003ecatMethod = Cat\u003c/code\u003e, this is the distance between\n   \u003cem\u003eenvelopes\u003c/em\u003e; when \u003ccode\u003ecatMethod = Distrib\u003c/code\u003e, this is the distance\n   between \u003cem\u003eorigins\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Combinators",
          "name": "sep",
          "package": "diagrams-lib",
          "signature": "forall v.  Lens' (CatOpts v) (Scalar v)",
          "source": "src/Diagrams-Combinators.html#sep",
          "type": "function"
        },
        "index": {
          "description": "How much separation should be used between successive diagrams default When catMethod Cat this is the distance between envelopes when catMethod Distrib this is the distance between origins",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "sep",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:sep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003estrut v\u003c/code\u003e is a diagram which produces no output, but with respect\n   to alignment and envelope acts like a 1-dimensional segment\n   oriented along the vector \u003ccode\u003ev\u003c/code\u003e, with local origin at its\n   center. (Note, however, that it has an empty trace; for 2D struts\n   with a nonempty trace see \u003ccode\u003estrutR2\u003c/code\u003e, \u003ccode\u003estrutX\u003c/code\u003e, and \u003ccode\u003estrutY\u003c/code\u003e from\n   \u003ca\u003eDiagrams.TwoD.Combinators\u003c/a\u003e.) Useful for manually creating\n   separation between two diagrams.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_Combinators_strutEx.svg#diagram=strutEx&width=300\"/\u003e\n\u003c/p\u003e\u003cpre\u003e strutEx = (circle 1 ||| strut unitX ||| circle 1) # centerXY # pad 1.1\n\u003c/pre\u003e",
          "module": "Diagrams.Combinators",
          "name": "strut",
          "package": "diagrams-lib",
          "signature": "v -\u003e QDiagram b v m",
          "source": "src/Diagrams-Combinators.html#strut",
          "type": "function"
        },
        "index": {
          "description": "strut is diagram which produces no output but with respect to alignment and envelope acts like dimensional segment oriented along the vector with local origin at its center Note however that it has an empty trace for struts with nonempty trace see strutR2 strutX and strutY from Diagrams.TwoD.Combinators Useful for manually creating separation between two diagrams strutEx circle strut unitX circle centerXY pad",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "strut",
          "normalized": "a-\u003eQDiagram b a c",
          "package": "diagrams-lib",
          "signature": "v-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:strut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the envelope from some object as the envelope for a\n   diagram, in place of the diagram's default envelope.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_Combinators_withEnvelopeEx.svg#diagram=withEnvelopeEx&width=300\"/\u003e\n\u003c/p\u003e\u003cpre\u003e sqNewEnv =\n     circle 1 # fc green\n     |||\n     (    c # dashing [0.1,0.1] 0 # lc white\n       \u003c\u003e square 2 # withEnvelope (c :: D R2) # fc blue\n     )\n c = circle 0.8\n withEnvelopeEx = sqNewEnv # centerXY # pad 1.5\n\u003c/pre\u003e",
          "module": "[\"Diagrams.Combinators\",\"Diagrams.Envelope\"]",
          "name": "withEnvelope",
          "package": "diagrams-lib",
          "signature": "a -\u003e QDiagram b (V a) m -\u003e QDiagram b (V a) m",
          "source": "src/Diagrams-Combinators.html#withEnvelope",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:withEnvelope\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#v:withEnvelope\"]"
        },
        "index": {
          "description": "Use the envelope from some object as the envelope for diagram in place of the diagram default envelope sqNewEnv circle fc green dashing lc white square withEnvelope R2 fc blue circle withEnvelopeEx sqNewEnv centerXY pad",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "withEnvelope",
          "normalized": "a-\u003eQDiagram b(V a)c-\u003eQDiagram b(V a)c",
          "package": "diagrams-lib",
          "partial": "Envelope",
          "signature": "a-\u003eQDiagram b(V a)m-\u003eQDiagram b(V a)m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:withEnvelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the trace from some object as the trace for a diagram, in\n   place of the diagram's default trace.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Combinators\",\"Diagrams.Trace\"]",
          "name": "withTrace",
          "package": "diagrams-lib",
          "signature": "a -\u003e QDiagram b (V a) m -\u003e QDiagram b (V a) m",
          "source": "src/Diagrams-Combinators.html#withTrace",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:withTrace\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trace.html#v:withTrace\"]"
        },
        "index": {
          "description": "Use the trace from some object as the trace for diagram in place of the diagram default trace",
          "hierarchy": "Diagrams Combinators",
          "module": "Diagrams.Combinators",
          "name": "withTrace",
          "normalized": "a-\u003eQDiagram b(V a)c-\u003eQDiagram b(V a)c",
          "package": "diagrams-lib",
          "partial": "Trace",
          "signature": "a-\u003eQDiagram b(V a)m-\u003eQDiagram b(V a)m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Combinators.html#v:withTrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNice syntax for constructing and pattern-matching on literal\n points and vectors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Coordinates",
          "name": "Coordinates",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Coordinates.html",
          "type": "module"
        },
        "index": {
          "description": "Nice syntax for constructing and pattern-matching on literal points and vectors",
          "hierarchy": "Diagrams Coordinates",
          "module": "Diagrams.Coordinates",
          "name": "Coordinates",
          "package": "diagrams-lib",
          "partial": "Coordinates",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Coordinates.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pair of values, with a convenient infix (left-associative)\n   data constructor.\n\u003c/p\u003e",
          "module": "Diagrams.Coordinates",
          "name": ":&",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Coordinates.html#%3A%26",
          "type": "data"
        },
        "index": {
          "description": "pair of values with convenient infix left-associative data constructor",
          "hierarchy": "Diagrams Coordinates",
          "module": "Diagrams.Coordinates",
          "name": ":&",
          "package": "diagrams-lib",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Coordinates.html#t::-38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTypes which are instances of the \u003ccode\u003eCoordinates\u003c/code\u003e class can be\n   constructed using \u003ccode\u003e\u003ca\u003e^&\u003c/a\u003e\u003c/code\u003e (for example, a three-dimensional vector\n   could be constructed by \u003ccode\u003e1 ^& 6 ^& 3\u003c/code\u003e), and deconstructed using\n   \u003ccode\u003e\u003ca\u003ecoords\u003c/a\u003e\u003c/code\u003e.  A common pattern is to use \u003ccode\u003e\u003ca\u003ecoords\u003c/a\u003e\u003c/code\u003e in conjunction\n   with the \u003ccode\u003eViewPatterns\u003c/code\u003e extension, like so:\n\u003c/p\u003e\u003cpre\u003e\n foo :: Vector3 -\u003e ...\n foo (coords -\u003e x :& y :& z) = ...\n\u003c/pre\u003e",
          "module": "Diagrams.Coordinates",
          "name": "Coordinates",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Coordinates.html#Coordinates",
          "type": "class"
        },
        "index": {
          "description": "Types which are instances of the Coordinates class can be constructed using for example three-dimensional vector could be constructed by and deconstructed using coords common pattern is to use coords in conjunction with the ViewPatterns extension like so foo Vector3 foo coords",
          "hierarchy": "Diagrams Coordinates",
          "module": "Diagrams.Coordinates",
          "name": "Coordinates",
          "package": "diagrams-lib",
          "partial": "Coordinates",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Coordinates.html#t:Coordinates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class of types with at least one coordinate, called _x.\n\u003c/p\u003e",
          "module": "Diagrams.Coordinates",
          "name": "HasX",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Coordinates.html#HasX",
          "type": "class"
        },
        "index": {
          "description": "The class of types with at least one coordinate called",
          "hierarchy": "Diagrams Coordinates",
          "module": "Diagrams.Coordinates",
          "name": "HasX",
          "package": "diagrams-lib",
          "partial": "Has",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Coordinates.html#t:HasX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class of types with at least two coordinates, the second called _y.\n\u003c/p\u003e",
          "module": "Diagrams.Coordinates",
          "name": "HasY",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Coordinates.html#HasY",
          "type": "class"
        },
        "index": {
          "description": "The class of types with at least two coordinates the second called",
          "hierarchy": "Diagrams Coordinates",
          "module": "Diagrams.Coordinates",
          "name": "HasY",
          "package": "diagrams-lib",
          "partial": "Has",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Coordinates.html#t:HasY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class of types with at least three coordinates, the third called _z.\n\u003c/p\u003e",
          "module": "Diagrams.Coordinates",
          "name": "HasZ",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Coordinates.html#HasZ",
          "type": "class"
        },
        "index": {
          "description": "The class of types with at least three coordinates the third called",
          "hierarchy": "Diagrams Coordinates",
          "module": "Diagrams.Coordinates",
          "name": "HasZ",
          "package": "diagrams-lib",
          "partial": "Has",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Coordinates.html#t:HasZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a value of type \u003ccode\u003ec\u003c/code\u003e by providing something of one\n   less dimension (which is perhaps itself recursively constructed\n   using \u003ccode\u003e(^&)\u003c/code\u003e) and a final coordinate.  For example,\n\u003c/p\u003e\u003cpre\u003e\n 2 ^& 3 :: P2\n 3 ^& 5 ^& 6 :: R3\n\u003c/pre\u003e\u003cp\u003eNote that \u003ccode\u003e^&\u003c/code\u003e is left-associative.\n\u003c/p\u003e",
          "module": "Diagrams.Coordinates",
          "name": "(^&)",
          "package": "diagrams-lib",
          "signature": "PrevDim c -\u003e FinalCoord c -\u003e c",
          "source": "src/Diagrams-Coordinates.html#%5E%26",
          "type": "method"
        },
        "index": {
          "description": "Construct value of type by providing something of one less dimension which is perhaps itself recursively constructed using and final coordinate For example P2 R3 Note that is left-associative",
          "hierarchy": "Diagrams Coordinates",
          "module": "Diagrams.Coordinates",
          "name": "(^&) ^&",
          "normalized": "PrevDim a-\u003eFinalCoord a-\u003ea",
          "package": "diagrams-lib",
          "signature": "PrevDim c-\u003eFinalCoord c-\u003ec",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Coordinates.html#v:-94--38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Coordinates",
          "name": ":&",
          "package": "diagrams-lib",
          "signature": "a :& b",
          "source": "src/Diagrams-Coordinates.html#%3A%26",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Coordinates",
          "module": "Diagrams.Coordinates",
          "name": ":&",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Coordinates.html#v::-38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Coordinates",
          "name": "_x",
          "package": "diagrams-lib",
          "signature": "Lens' t Double",
          "source": "src/Diagrams-Coordinates.html#_x",
          "type": "method"
        },
        "index": {
          "hierarchy": "Diagrams Coordinates",
          "module": "Diagrams.Coordinates",
          "name": "_x",
          "package": "diagrams-lib",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Coordinates.html#v:_x"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Coordinates",
          "name": "_y",
          "package": "diagrams-lib",
          "signature": "Lens' t Double",
          "source": "src/Diagrams-Coordinates.html#_y",
          "type": "method"
        },
        "index": {
          "hierarchy": "Diagrams Coordinates",
          "module": "Diagrams.Coordinates",
          "name": "_y",
          "package": "diagrams-lib",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Coordinates.html#v:_y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Coordinates",
          "name": "_z",
          "package": "diagrams-lib",
          "signature": "Lens' t Double",
          "source": "src/Diagrams-Coordinates.html#_z",
          "type": "method"
        },
        "index": {
          "hierarchy": "Diagrams Coordinates",
          "module": "Diagrams.Coordinates",
          "name": "_z",
          "package": "diagrams-lib",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Coordinates.html#v:_z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecompose a value of type \u003ccode\u003ec\u003c/code\u003e into its constituent coordinates,\n   stored in a nested \u003ccode\u003e(:&)\u003c/code\u003e structure.\n\u003c/p\u003e",
          "module": "Diagrams.Coordinates",
          "name": "coords",
          "package": "diagrams-lib",
          "signature": "c -\u003e Decomposition c",
          "source": "src/Diagrams-Coordinates.html#coords",
          "type": "method"
        },
        "index": {
          "description": "Decompose value of type into its constituent coordinates stored in nested structure",
          "hierarchy": "Diagrams Coordinates",
          "module": "Diagrams.Coordinates",
          "name": "coords",
          "normalized": "a-\u003eDecomposition a",
          "package": "diagrams-lib",
          "signature": "c-\u003eDecomposition c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Coordinates.html#v:coords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrefix synonym for \u003ccode\u003e^&\u003c/code\u003e. pr stands for pair of \u003ccode\u003ePrevDim\u003c/code\u003e, \u003ccode\u003eFinalCoord\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Diagrams.Coordinates",
          "name": "pr",
          "package": "diagrams-lib",
          "signature": "PrevDim c -\u003e FinalCoord c -\u003e c",
          "source": "src/Diagrams-Coordinates.html#pr",
          "type": "method"
        },
        "index": {
          "description": "Prefix synonym for pr stands for pair of PrevDim FinalCoord",
          "hierarchy": "Diagrams Coordinates",
          "module": "Diagrams.Coordinates",
          "name": "pr",
          "normalized": "PrevDim a-\u003eFinalCoord a-\u003ea",
          "package": "diagrams-lib",
          "signature": "PrevDim c-\u003eFinalCoord c-\u003ec",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Coordinates.html#v:pr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA \u003cem\u003ecubic spline\u003c/em\u003e is a smooth, connected sequence of cubic curves\n passing through a given sequence of points.  This module implements\n a straightforward spline generation algorithm based on solving\n tridiagonal systems of linear equations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.CubicSpline.Internal",
          "name": "Internal",
          "package": "diagrams-lib",
          "source": "src/Diagrams-CubicSpline-Internal.html",
          "type": "module"
        },
        "index": {
          "description": "cubic spline is smooth connected sequence of cubic curves passing through given sequence of points This module implements straightforward spline generation algorithm based on solving tridiagonal systems of linear equations",
          "hierarchy": "Diagrams CubicSpline Internal",
          "module": "Diagrams.CubicSpline.Internal",
          "name": "Internal",
          "package": "diagrams-lib",
          "partial": "Internal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-CubicSpline-Internal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the cyclic-tri-diagonal solver with the appropriate parameters for a closed cubic spline.\n\u003c/p\u003e",
          "module": "Diagrams.CubicSpline.Internal",
          "name": "solveCubicSplineCoefficients",
          "package": "diagrams-lib",
          "signature": "Bool -\u003e [a] -\u003e [[a]]",
          "source": "src/Diagrams-CubicSpline-Internal.html#solveCubicSplineCoefficients",
          "type": "function"
        },
        "index": {
          "description": "Use the cyclic-tri-diagonal solver with the appropriate parameters for closed cubic spline",
          "hierarchy": "Diagrams CubicSpline Internal",
          "module": "Diagrams.CubicSpline.Internal",
          "name": "solveCubicSplineCoefficients",
          "normalized": "Bool-\u003e[a]-\u003e[[a]]",
          "package": "diagrams-lib",
          "partial": "Cubic Spline Coefficients",
          "signature": "Bool-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-CubicSpline-Internal.html#v:solveCubicSplineCoefficients"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the tri-diagonal solver with the appropriate parameters for an open cubic spline.\n\u003c/p\u003e",
          "module": "Diagrams.CubicSpline.Internal",
          "name": "solveCubicSplineDerivatives",
          "package": "diagrams-lib",
          "signature": "[a] -\u003e [a]",
          "source": "src/Diagrams-CubicSpline-Internal.html#solveCubicSplineDerivatives",
          "type": "function"
        },
        "index": {
          "description": "Use the tri-diagonal solver with the appropriate parameters for an open cubic spline",
          "hierarchy": "Diagrams CubicSpline Internal",
          "module": "Diagrams.CubicSpline.Internal",
          "name": "solveCubicSplineDerivatives",
          "normalized": "[a]-\u003e[a]",
          "package": "diagrams-lib",
          "partial": "Cubic Spline Derivatives",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-CubicSpline-Internal.html#v:solveCubicSplineDerivatives"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the cyclic-tri-diagonal solver with the appropriate parameters for a closed cubic spline.\n\u003c/p\u003e",
          "module": "Diagrams.CubicSpline.Internal",
          "name": "solveCubicSplineDerivativesClosed",
          "package": "diagrams-lib",
          "signature": "[a] -\u003e [a]",
          "source": "src/Diagrams-CubicSpline-Internal.html#solveCubicSplineDerivativesClosed",
          "type": "function"
        },
        "index": {
          "description": "Use the cyclic-tri-diagonal solver with the appropriate parameters for closed cubic spline",
          "hierarchy": "Diagrams CubicSpline Internal",
          "module": "Diagrams.CubicSpline.Internal",
          "name": "solveCubicSplineDerivativesClosed",
          "normalized": "[a]-\u003e[a]",
          "package": "diagrams-lib",
          "partial": "Cubic Spline Derivatives Closed",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-CubicSpline-Internal.html#v:solveCubicSplineDerivativesClosed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolves a system similar to the tri-diagonal system using a special case\n   of the Sherman-Morrison formula \u003ca\u003ehttp://en.wikipedia.org/wiki/Sherman-Morrison_formula\u003c/a\u003e.\n   This code is based on \u003cem\u003eNumerical Recpies in C\u003c/em\u003e's \u003ccode\u003ecyclic\u003c/code\u003e function in section 2.7.\n\u003c/p\u003e",
          "module": "Diagrams.CubicSpline.Internal",
          "name": "solveCyclicTriDiagonal",
          "package": "diagrams-lib",
          "signature": "[a] -\u003e [a] -\u003e [a] -\u003e [a] -\u003e a -\u003e a -\u003e [a]",
          "source": "src/Diagrams-CubicSpline-Internal.html#solveCyclicTriDiagonal",
          "type": "function"
        },
        "index": {
          "description": "Solves system similar to the tri-diagonal system using special case of the Sherman-Morrison formula http en.wikipedia.org wiki Sherman-Morrison formula This code is based on Numerical Recpies in cyclic function in section",
          "hierarchy": "Diagrams CubicSpline Internal",
          "module": "Diagrams.CubicSpline.Internal",
          "name": "solveCyclicTriDiagonal",
          "normalized": "[a]-\u003e[a]-\u003e[a]-\u003e[a]-\u003ea-\u003ea-\u003e[a]",
          "package": "diagrams-lib",
          "partial": "Cyclic Tri Diagonal",
          "signature": "[a]-\u003e[a]-\u003e[a]-\u003e[a]-\u003ea-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-CubicSpline-Internal.html#v:solveCyclicTriDiagonal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolves a system of the form 'A*X=D' for \u003ccode\u003ex\u003c/code\u003e where \u003ccode\u003eA\u003c/code\u003e is an \n   \u003ccode\u003en\u003c/code\u003e by \u003ccode\u003en\u003c/code\u003e matrix with \u003ccode\u003ebs\u003c/code\u003e as the main diagonal and \n   \u003ccode\u003eas\u003c/code\u003e the diagonal below and \u003ccode\u003ecs\u003c/code\u003e the diagonal above.\n   See: \u003ca\u003ehttp://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Diagrams.CubicSpline.Internal",
          "name": "solveTriDiagonal",
          "package": "diagrams-lib",
          "signature": "[a] -\u003e [a] -\u003e [a] -\u003e [a] -\u003e [a]",
          "source": "src/Diagrams-CubicSpline-Internal.html#solveTriDiagonal",
          "type": "function"
        },
        "index": {
          "description": "Solves system of the form for where is an by matrix with bs as the main diagonal and as the diagonal below and cs the diagonal above See http en.wikipedia.org wiki Tridiagonal matrix algorithm",
          "hierarchy": "Diagrams CubicSpline Internal",
          "module": "Diagrams.CubicSpline.Internal",
          "name": "solveTriDiagonal",
          "normalized": "[a]-\u003e[a]-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "diagrams-lib",
          "partial": "Tri Diagonal",
          "signature": "[a]-\u003e[a]-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-CubicSpline-Internal.html#v:solveTriDiagonal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA \u003cem\u003ecubic spline\u003c/em\u003e is a smooth, connected sequence of cubic curves\n passing through a given sequence of points.  This module provides\n the \u003ccode\u003e\u003ca\u003ecubicSpline\u003c/a\u003e\u003c/code\u003e method, which can be used to create closed or\n open cubic splines from a list of points.  For access to the\n internals of the spline generation algorithm (including in\n particular a solver for cyclic tridiagonal systems of linear\n equations), see \u003ca\u003eDiagrams.CubicSpline.Internal\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.CubicSpline",
          "name": "CubicSpline",
          "package": "diagrams-lib",
          "source": "src/Diagrams-CubicSpline.html",
          "type": "module"
        },
        "index": {
          "description": "cubic spline is smooth connected sequence of cubic curves passing through given sequence of points This module provides the cubicSpline method which can be used to create closed or open cubic splines from list of points For access to the internals of the spline generation algorithm including in particular solver for cyclic tridiagonal systems of linear equations see Diagrams.CubicSpline.Internal",
          "hierarchy": "Diagrams CubicSpline",
          "module": "Diagrams.CubicSpline",
          "name": "CubicSpline",
          "package": "diagrams-lib",
          "partial": "Cubic Spline",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-CubicSpline.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a spline path-like thing of cubic segments from a list of\n   vertices, with the first vertex as the starting point.  The first\n   argument specifies whether the path should be closed.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_CubicSpline_cubicSplineEx.svg#diagram=cubicSplineEx&width=600\"/\u003e\n\u003c/p\u003e\u003cpre\u003e pts = map p2 [(0,0), (2,3), (5,-2), (-4,1), (0,3)]\n dot = circle 0.2 # fc blue # lw 0\n mkPath closed = position (zip pts (repeat dot))\n              \u003c\u003e cubicSpline closed pts # lw 0.05\n cubicSplineEx = (mkPath False ||| strutX 2 ||| mkPath True)\n               # centerXY # pad 1.1\n\u003c/pre\u003e\u003cp\u003eFor more information, see \u003ca\u003ehttp://mathworld.wolfram.com/CubicSpline.html\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.CubicSpline",
          "name": "cubicSpline",
          "package": "diagrams-lib",
          "signature": "Bool -\u003e [Point (V t)] -\u003e t",
          "source": "src/Diagrams-CubicSpline.html#cubicSpline",
          "type": "function"
        },
        "index": {
          "description": "Construct spline path-like thing of cubic segments from list of vertices with the first vertex as the starting point The first argument specifies whether the path should be closed pts map p2 dot circle fc blue lw mkPath closed position zip pts repeat dot cubicSpline closed pts lw cubicSplineEx mkPath False strutX mkPath True centerXY pad For more information see http mathworld.wolfram.com CubicSpline.html",
          "hierarchy": "Diagrams CubicSpline",
          "module": "Diagrams.CubicSpline",
          "name": "cubicSpline",
          "normalized": "Bool-\u003e[Point(V a)]-\u003ea",
          "package": "diagrams-lib",
          "partial": "Spline",
          "signature": "Bool-\u003e[Point(V t)]-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-CubicSpline.html#v:cubicSpline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\"Envelopes\", aka functional bounding regions.  See\n \u003ca\u003eDiagrams.Core.Envelope\u003c/a\u003e for internal implementation details.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Envelope",
          "name": "Envelope",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Envelope.html",
          "type": "module"
        },
        "index": {
          "description": "Envelopes aka functional bounding regions See Diagrams.Core.Envelope for internal implementation details",
          "hierarchy": "Diagrams Envelope",
          "module": "Diagrams.Envelope",
          "name": "Envelope",
          "package": "diagrams-lib",
          "partial": "Envelope",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery diagram comes equipped with an \u003cem\u003eenvelope\u003c/em\u003e.  What is an envelope?\n\u003c/p\u003e\u003cp\u003eConsider first the idea of a \u003cem\u003ebounding box\u003c/em\u003e. A bounding box\n   expresses the distance to a bounding plane in every direction\n   parallel to an axis.  That is, a bounding box can be thought of\n   as the intersection of a collection of half-planes, two\n   perpendicular to each axis.\n\u003c/p\u003e\u003cp\u003eMore generally, the intersection of half-planes in \u003cem\u003eevery\u003c/em\u003e\n   direction would give a tight \"bounding region\", or convex hull.\n   However, representing such a thing intensionally would be\n   impossible; hence bounding boxes are often used as an\n   approximation.\n\u003c/p\u003e\u003cp\u003eAn envelope is an \u003cem\u003eextensional\u003c/em\u003e representation of such a\n   \"bounding region\".  Instead of storing some sort of direct\n   representation, we store a \u003cem\u003efunction\u003c/em\u003e which takes a direction as\n   input and gives a distance to a bounding half-plane as output.\n   The important point is that envelopes can be composed, and\n   transformed by any affine transformation.\n\u003c/p\u003e\u003cp\u003eFormally, given a vector \u003ccode\u003ev\u003c/code\u003e, the envelope computes a scalar \u003ccode\u003es\u003c/code\u003e such\n   that\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e for every point \u003ccode\u003eu\u003c/code\u003e inside the diagram,\n       if the projection of \u003ccode\u003e(u - origin)\u003c/code\u003e onto \u003ccode\u003ev\u003c/code\u003e is \u003ccode\u003es' *^ v\u003c/code\u003e, then \u003ccode\u003es' \u003c= s\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003es\u003c/code\u003e is the smallest such scalar.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThere is also a special \"empty envelope\".\n\u003c/p\u003e\u003cp\u003eThe idea for envelopes came from\n   Sebastian Setzer; see\n   \u003ca\u003ehttp://byorgey.wordpress.com/2009/10/28/collecting-attributes/#comment-2030\u003c/a\u003e.  See also Brent Yorgey, \u003cem\u003eMonoids: Theme and Variations\u003c/em\u003e, published in the 2012 Haskell Symposium: \u003ca\u003ehttp://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf\u003c/a\u003e; video: \u003ca\u003ehttp://www.youtube.com/watch?v=X-8NCkD2vOw\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Envelope",
          "name": "Envelope",
          "package": "diagrams-lib",
          "type": "data"
        },
        "index": {
          "description": "Every diagram comes equipped with an envelope What is an envelope Consider first the idea of bounding box bounding box expresses the distance to bounding plane in every direction parallel to an axis That is bounding box can be thought of as the intersection of collection of half-planes two perpendicular to each axis More generally the intersection of half-planes in every direction would give tight bounding region or convex hull However representing such thing intensionally would be impossible hence bounding boxes are often used as an approximation An envelope is an extensional representation of such bounding region Instead of storing some sort of direct representation we store function which takes direction as input and gives distance to bounding half-plane as output The important point is that envelopes can be composed and transformed by any affine transformation Formally given vector the envelope computes scalar such that for every point inside the diagram if the projection of origin onto is then is the smallest such scalar There is also special empty envelope The idea for envelopes came from Sebastian Setzer see http byorgey.wordpress.com collecting-attributes comment-2030 See also Brent Yorgey Monoids Theme and Variations published in the Haskell Symposium http www.cis.upenn.edu byorgey pub monoid-pearl.pdf video http www.youtube.com watch X-8NCkD2vOw",
          "hierarchy": "Diagrams Envelope",
          "module": "Diagrams.Envelope",
          "name": "Envelope",
          "package": "diagrams-lib",
          "partial": "Envelope",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#t:Envelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eEnveloped\u003c/code\u003e abstracts over things which have an envelope.\n\u003c/p\u003e",
          "module": "Diagrams.Envelope",
          "name": "Enveloped",
          "package": "diagrams-lib",
          "type": "class"
        },
        "index": {
          "description": "Enveloped abstracts over things which have an envelope",
          "hierarchy": "Diagrams Envelope",
          "module": "Diagrams.Envelope",
          "name": "Enveloped",
          "package": "diagrams-lib",
          "partial": "Enveloped",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#t:Enveloped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the diameter of a enveloped object along a particular\n   vector.  Returns zero for the empty envelope.\n\u003c/p\u003e",
          "module": "Diagrams.Envelope",
          "name": "diameter",
          "package": "diagrams-lib",
          "signature": "V a -\u003e a -\u003e Scalar (V a)",
          "type": "function"
        },
        "index": {
          "description": "Compute the diameter of enveloped object along particular vector Returns zero for the empty envelope",
          "hierarchy": "Diagrams Envelope",
          "module": "Diagrams.Envelope",
          "name": "diameter",
          "normalized": "V a-\u003ea-\u003eScalar(V a)",
          "package": "diagrams-lib",
          "signature": "V a-\u003ea-\u003eScalar(V a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#v:diameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the envelope of a diagram.\n\u003c/p\u003e",
          "module": "Diagrams.Envelope",
          "name": "envelope",
          "package": "diagrams-lib",
          "signature": "Lens' (QDiagram b v m) (Envelope v)",
          "type": "function"
        },
        "index": {
          "description": "Get the envelope of diagram",
          "hierarchy": "Diagrams Envelope",
          "module": "Diagrams.Envelope",
          "name": "envelope",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#v:envelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the point on a separating hyperplane in the given\n   direction.  Returns the origin for the empty envelope.\n\u003c/p\u003e",
          "module": "Diagrams.Envelope",
          "name": "envelopeP",
          "package": "diagrams-lib",
          "signature": "V a -\u003e a -\u003e Point (V a)",
          "type": "function"
        },
        "index": {
          "description": "Compute the point on separating hyperplane in the given direction Returns the origin for the empty envelope",
          "hierarchy": "Diagrams Envelope",
          "module": "Diagrams.Envelope",
          "name": "envelopeP",
          "normalized": "V a-\u003ea-\u003ePoint(V a)",
          "package": "diagrams-lib",
          "signature": "V a-\u003ea-\u003ePoint(V a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#v:envelopeP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the point on a separating hyperplane in the given\n   direction, or \u003ccode\u003eNothing\u003c/code\u003e for the empty envelope.\n\u003c/p\u003e",
          "module": "Diagrams.Envelope",
          "name": "envelopePMay",
          "package": "diagrams-lib",
          "signature": "V a -\u003e a -\u003e Maybe (Point (V a))",
          "type": "function"
        },
        "index": {
          "description": "Compute the point on separating hyperplane in the given direction or Nothing for the empty envelope",
          "hierarchy": "Diagrams Envelope",
          "module": "Diagrams.Envelope",
          "name": "envelopePMay",
          "normalized": "V a-\u003ea-\u003eMaybe(Point(V a))",
          "package": "diagrams-lib",
          "partial": "PMay",
          "signature": "V a-\u003ea-\u003eMaybe(Point(V a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#v:envelopePMay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the vector from the local origin to a separating\n   hyperplane in the given direction.  Returns the zero vector for\n   the empty envelope.\n\u003c/p\u003e",
          "module": "Diagrams.Envelope",
          "name": "envelopeV",
          "package": "diagrams-lib",
          "signature": "V a -\u003e a -\u003e V a",
          "type": "function"
        },
        "index": {
          "description": "Compute the vector from the local origin to separating hyperplane in the given direction Returns the zero vector for the empty envelope",
          "hierarchy": "Diagrams Envelope",
          "module": "Diagrams.Envelope",
          "name": "envelopeV",
          "normalized": "V a-\u003ea-\u003eV a",
          "package": "diagrams-lib",
          "signature": "V a-\u003ea-\u003eV a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#v:envelopeV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the vector from the local origin to a separating\n   hyperplane in the given direction, or \u003ccode\u003eNothing\u003c/code\u003e for the empty\n   envelope.\n\u003c/p\u003e",
          "module": "Diagrams.Envelope",
          "name": "envelopeVMay",
          "package": "diagrams-lib",
          "signature": "V a -\u003e a -\u003e Maybe (V a)",
          "type": "function"
        },
        "index": {
          "description": "Compute the vector from the local origin to separating hyperplane in the given direction or Nothing for the empty envelope",
          "hierarchy": "Diagrams Envelope",
          "module": "Diagrams.Envelope",
          "name": "envelopeVMay",
          "normalized": "V a-\u003ea-\u003eMaybe(V a)",
          "package": "diagrams-lib",
          "partial": "VMay",
          "signature": "V a-\u003ea-\u003eMaybe(V a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#v:envelopeVMay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the \"radius\" (1/2 the diameter) of an enveloped object\n   along a particular vector.\n\u003c/p\u003e",
          "module": "Diagrams.Envelope",
          "name": "radius",
          "package": "diagrams-lib",
          "signature": "V a -\u003e a -\u003e Scalar (V a)",
          "type": "function"
        },
        "index": {
          "description": "Compute the radius the diameter of an enveloped object along particular vector",
          "hierarchy": "Diagrams Envelope",
          "module": "Diagrams.Envelope",
          "name": "radius",
          "normalized": "V a-\u003ea-\u003eScalar(V a)",
          "package": "diagrams-lib",
          "signature": "V a-\u003ea-\u003eScalar(V a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#v:radius"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the envelope of a diagram.\n\u003c/p\u003e",
          "module": "Diagrams.Envelope",
          "name": "setEnvelope",
          "package": "diagrams-lib",
          "signature": "Envelope v -\u003e QDiagram b v m -\u003e QDiagram b v m",
          "type": "function"
        },
        "index": {
          "description": "Replace the envelope of diagram",
          "hierarchy": "Diagrams Envelope",
          "module": "Diagrams.Envelope",
          "name": "setEnvelope",
          "normalized": "Envelope a-\u003eQDiagram b a c-\u003eQDiagram b a c",
          "package": "diagrams-lib",
          "partial": "Envelope",
          "signature": "Envelope v-\u003eQDiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Envelope.html#v:setEnvelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\"Located\" things, \u003cem\u003ei.e.\u003c/em\u003e things with a concrete location:\n intuitively, \u003ccode\u003eLocated a ~ (a, Point)\u003c/code\u003e.  Wrapping a translationally\n invariant thing (\u003cem\u003ee.g.\u003c/em\u003e a \u003ccode\u003eSegment\u003c/code\u003e or \u003ccode\u003eTrail\u003c/code\u003e) in \u003ccode\u003eLocated\u003c/code\u003e pins\n it down to a particular location and makes it no longer\n translationally invariant.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Located",
          "name": "Located",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Located.html",
          "type": "module"
        },
        "index": {
          "description": "Located things i.e things with concrete location intuitively Located Point Wrapping translationally invariant thing e.g Segment or Trail in Located pins it down to particular location and makes it no longer translationally invariant",
          "hierarchy": "Diagrams Located",
          "module": "Diagrams.Located",
          "name": "Located",
          "package": "diagrams-lib",
          "partial": "Located",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Located.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Located\" things, \u003cem\u003ei.e.\u003c/em\u003e things with a concrete location:\n   intuitively, \u003ccode\u003eLocated a ~ (Point, a)\u003c/code\u003e.  Wrapping a translationally\n   invariant thing (\u003cem\u003ee.g.\u003c/em\u003e a \u003ccode\u003eSegment\u003c/code\u003e or \u003ccode\u003eTrail\u003c/code\u003e) in \u003ccode\u003e\u003ca\u003eLocated\u003c/a\u003e\u003c/code\u003e pins\n   it down to a particular location and makes it no longer\n   translationally invariant.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eLocated\u003c/code\u003e is intentionally abstract.  To construct \u003ccode\u003eLocated\u003c/code\u003e\n   values, use \u003ccode\u003e\u003ca\u003eat\u003c/a\u003e\u003c/code\u003e.  To destruct, use \u003ccode\u003e\u003ca\u003eviewLoc\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eunLoc\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eloc\u003c/a\u003e\u003c/code\u003e.\n   To map, use \u003ccode\u003e\u003ca\u003emapLoc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMuch of the utility of having a concrete type for the \u003ccode\u003eLocated\u003c/code\u003e\n   concept lies in the type class instances we can give it.  The\n   \u003ccode\u003e\u003ca\u003eHasOrigin\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eTransformable\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eEnveloped\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eTraced\u003c/a\u003e\u003c/code\u003e, and\n   \u003ccode\u003eTrailLike\u003c/code\u003e instances are particularly useful; see the documented\n   instances below for more information.\n\u003c/p\u003e",
          "module": "Diagrams.Located",
          "name": "Located",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Located.html#Located",
          "type": "data"
        },
        "index": {
          "description": "Located things i.e things with concrete location intuitively Located Point Wrapping translationally invariant thing e.g Segment or Trail in Located pins it down to particular location and makes it no longer translationally invariant Located is intentionally abstract To construct Located values use at To destruct use viewLoc unLoc or loc To map use mapLoc Much of the utility of having concrete type for the Located concept lies in the type class instances we can give it The HasOrigin Transformable Enveloped Traced and TrailLike instances are particularly useful see the documented instances below for more information",
          "hierarchy": "Diagrams Located",
          "module": "Diagrams.Located",
          "name": "Located",
          "package": "diagrams-lib",
          "partial": "Located",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Located.html#t:Located"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a \u003ccode\u003eLocated a\u003c/code\u003e from a value of type \u003ccode\u003ea\u003c/code\u003e and a location.\n   \u003ccode\u003eat\u003c/code\u003e is intended to be used infix, like \u003ccode\u003ex `at` origin\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Located",
          "name": "at",
          "package": "diagrams-lib",
          "signature": "a -\u003e Point (V a) -\u003e Located a",
          "source": "src/Diagrams-Located.html#at",
          "type": "function"
        },
        "index": {
          "description": "Construct Located from value of type and location at is intended to be used infix like at origin",
          "hierarchy": "Diagrams Located",
          "module": "Diagrams.Located",
          "name": "at",
          "normalized": "a-\u003ePoint(V a)-\u003eLocated a",
          "package": "diagrams-lib",
          "signature": "a-\u003ePoint(V a)-\u003eLocated a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Located.html#v:at"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject out the\n   location of a \u003ccode\u003eLocated\u003c/code\u003e\n   value.\n\u003c/p\u003e",
          "module": "Diagrams.Located",
          "name": "loc",
          "package": "diagrams-lib",
          "signature": "Located a -\u003e Point (V a)",
          "source": "src/Diagrams-Located.html#loc",
          "type": "function"
        },
        "index": {
          "description": "Project out the location of Located value",
          "hierarchy": "Diagrams Located",
          "module": "Diagrams.Located",
          "name": "loc",
          "normalized": "Located a-\u003ePoint(V a)",
          "package": "diagrams-lib",
          "signature": "Located a-\u003ePoint(V a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Located.html#v:loc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA lens giving access to the object within a \u003ccode\u003e\u003ca\u003eLocated\u003c/a\u003e\u003c/code\u003e wrapper.\n\u003c/p\u003e",
          "module": "Diagrams.Located",
          "name": "located",
          "package": "diagrams-lib",
          "signature": "Lens (Located a) (Located a') a a'",
          "source": "src/Diagrams-Located.html#located",
          "type": "function"
        },
        "index": {
          "description": "lens giving access to the object within Located wrapper",
          "hierarchy": "Diagrams Located",
          "module": "Diagrams.Located",
          "name": "located",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Located.html#v:located"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eLocated\u003c/a\u003e\u003c/code\u003e is not a \u003ccode\u003eFunctor\u003c/code\u003e, since changing the type could\n   change the type of the associated vector space, in which case the\n   associated location would no longer have the right type. \u003ccode\u003e\u003ca\u003emapLoc\u003c/a\u003e\u003c/code\u003e\n   has an extra constraint specifying that the vector space must\n   stay the same.\n\u003c/p\u003e\u003cp\u003e(Technically, one can say that for every vector space \u003ccode\u003ev\u003c/code\u003e,\n   \u003ccode\u003eLocated\u003c/code\u003e is a little-f (endo)functor on the category of types\n   with associated vector space \u003ccode\u003ev\u003c/code\u003e; but that is not covered by the\n   standard \u003ccode\u003eFunctor\u003c/code\u003e class.)\n\u003c/p\u003e",
          "module": "Diagrams.Located",
          "name": "mapLoc",
          "package": "diagrams-lib",
          "signature": "(a -\u003e b) -\u003e Located a -\u003e Located b",
          "source": "src/Diagrams-Located.html#mapLoc",
          "type": "function"
        },
        "index": {
          "description": "Located is not Functor since changing the type could change the type of the associated vector space in which case the associated location would no longer have the right type mapLoc has an extra constraint specifying that the vector space must stay the same Technically one can say that for every vector space Located is little-f endo functor on the category of types with associated vector space but that is not covered by the standard Functor class",
          "hierarchy": "Diagrams Located",
          "module": "Diagrams.Located",
          "name": "mapLoc",
          "normalized": "(a-\u003eb)-\u003eLocated a-\u003eLocated b",
          "package": "diagrams-lib",
          "partial": "Loc",
          "signature": "(a-\u003eb)-\u003eLocated a-\u003eLocated b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Located.html#v:mapLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject the value\n   of type \u003ccode\u003ea\u003c/code\u003e out of\n   a \u003ccode\u003eLocated a\u003c/code\u003e,\n   discarding the\n   location.\n\u003c/p\u003e",
          "module": "Diagrams.Located",
          "name": "unLoc",
          "package": "diagrams-lib",
          "signature": "Located a -\u003e a",
          "source": "src/Diagrams-Located.html#unLoc",
          "type": "function"
        },
        "index": {
          "description": "Project the value of type out of Located discarding the location",
          "hierarchy": "Diagrams Located",
          "module": "Diagrams.Located",
          "name": "unLoc",
          "normalized": "Located a-\u003ea",
          "package": "diagrams-lib",
          "partial": "Loc",
          "signature": "Located a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Located.html#v:unLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeconstruct a \u003ccode\u003eLocated a\u003c/code\u003e into a location and a value of type\n   \u003ccode\u003ea\u003c/code\u003e.  \u003ccode\u003eviewLoc\u003c/code\u003e can be especially useful in conjunction with the\n   \u003ccode\u003eViewPatterns\u003c/code\u003e extension.\n\u003c/p\u003e",
          "module": "Diagrams.Located",
          "name": "viewLoc",
          "package": "diagrams-lib",
          "signature": "Located a -\u003e (Point (V a), a)",
          "source": "src/Diagrams-Located.html#viewLoc",
          "type": "function"
        },
        "index": {
          "description": "Deconstruct Located into location and value of type viewLoc can be especially useful in conjunction with the ViewPatterns extension",
          "hierarchy": "Diagrams Located",
          "module": "Diagrams.Located",
          "name": "viewLoc",
          "normalized": "Located a-\u003e(Point(V a),a)",
          "package": "diagrams-lib",
          "partial": "Loc",
          "signature": "Located a-\u003e(Point(V a),a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Located.html#v:viewLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNames can be given to subdiagrams, and subdiagrams can later be\n queried by name.  This module exports types for representing names\n and subdiagrams, and various functions for working with them.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Names",
          "name": "Names",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Names.html",
          "type": "module"
        },
        "index": {
          "description": "Names can be given to subdiagrams and subdiagrams can later be queried by name This module exports types for representing names and subdiagrams and various functions for working with them",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "Names",
          "package": "diagrams-lib",
          "partial": "Names",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAtomic names.  \u003ccode\u003eAName\u003c/code\u003e is just an existential wrapper around\n   things which are \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "AName",
          "package": "diagrams-lib",
          "type": "data"
        },
        "index": {
          "description": "Atomic names AName is just an existential wrapper around things which are Typeable Ord and Show",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "AName",
          "package": "diagrams-lib",
          "partial": "AName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#t:AName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass for those types which can be used as names.  They must\n   support \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e (to facilitate extracting them from\n   existential wrappers), \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e (for comparison and efficient\n   storage) and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "IsName",
          "package": "diagrams-lib",
          "type": "class"
        },
        "index": {
          "description": "Class for those types which can be used as names They must support Typeable to facilitate extracting them from existential wrappers Ord for comparison and efficient storage and Show",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "IsName",
          "package": "diagrams-lib",
          "partial": "Is Name",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#t:IsName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA (qualified) name is a (possibly empty) sequence of atomic names.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "Name",
          "package": "diagrams-lib",
          "type": "data"
        },
        "index": {
          "description": "qualified name is possibly empty sequence of atomic names",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "Name",
          "package": "diagrams-lib",
          "partial": "Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#t:Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInstances of \u003ccode\u003e\u003ca\u003eQualifiable\u003c/a\u003e\u003c/code\u003e are things which can be qualified by\n   prefixing them with a name.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "Qualifiable",
          "package": "diagrams-lib",
          "type": "class"
        },
        "index": {
          "description": "Instances of Qualifiable are things which can be qualified by prefixing them with name",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "Qualifiable",
          "package": "diagrams-lib",
          "partial": "Qualifiable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#t:Qualifiable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eSubMap\u003c/a\u003e\u003c/code\u003e is a map associating names to subdiagrams. There can\n   be multiple associations for any given name.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "SubMap",
          "package": "diagrams-lib",
          "type": "data"
        },
        "index": {
          "description": "SubMap is map associating names to subdiagrams There can be multiple associations for any given name",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "SubMap",
          "package": "diagrams-lib",
          "partial": "Sub Map",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#t:SubMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003eSubdiagram\u003c/code\u003e represents a diagram embedded within the context\n   of a larger diagram.  Essentially, it consists of a diagram\n   paired with any accumulated information from the larger context\n   (transformations, attributes, etc.).\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "Subdiagram",
          "package": "diagrams-lib",
          "type": "data"
        },
        "index": {
          "description": "Subdiagram represents diagram embedded within the context of larger diagram Essentially it consists of diagram paired with any accumulated information from the larger context transformations attributes etc",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "Subdiagram",
          "package": "diagrams-lib",
          "partial": "Subdiagram",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#t:Subdiagram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQualify with the given name.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "(|\u003e)",
          "package": "diagrams-lib",
          "signature": "a -\u003e q -\u003e q",
          "type": "method"
        },
        "index": {
          "description": "Qualify with the given name",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "(|\u003e) |\u003e",
          "normalized": "a-\u003eb-\u003eb",
          "package": "diagrams-lib",
          "signature": "a-\u003eq-\u003eq",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:-124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvenient operator for writing qualified names with atomic\n   components of different types.  Instead of writing \u003ccode\u003etoName a1 \u003c\u003e\n   toName a2 \u003c\u003e toName a3\u003c/code\u003e you can just write \u003ccode\u003ea1 .\u003e a2 .\u003e a3\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "(.\u003e)",
          "package": "diagrams-lib",
          "signature": "a1 -\u003e a2 -\u003e Name",
          "type": "function"
        },
        "index": {
          "description": "Convenient operator for writing qualified names with atomic components of different types Instead of writing toName a1 toName a2 toName a3 you can just write a1 a2 a3",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "(.\u003e) .\u003e",
          "normalized": "a-\u003ea-\u003eName",
          "package": "diagrams-lib",
          "signature": "a-\u003ea-\u003eName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:.-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a \u003ccode\u003e\u003ca\u003eSubMap\u003c/a\u003e\u003c/code\u003e from a list of associations between names\n   and subdiagrams.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "fromNames",
          "package": "diagrams-lib",
          "signature": "[(a, Subdiagram b v m)] -\u003e SubMap b v m",
          "type": "function"
        },
        "index": {
          "description": "Construct SubMap from list of associations between names and subdiagrams",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "fromNames",
          "normalized": "[(a,Subdiagram b c d)]-\u003eSubMap b c d",
          "package": "diagrams-lib",
          "partial": "Names",
          "signature": "[(a,Subdiagram b v m)]-\u003eSubMap b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:fromNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn a subdiagram into a normal diagram, including the enclosing\n   context.  Concretely, a subdiagram is a pair of (1) a diagram and\n   (2) a \"context\" consisting of an extra transformation and\n   attributes.  \u003ccode\u003egetSub\u003c/code\u003e simply applies the transformation and\n   attributes to the diagram to get the corresponding \"top-level\"\n   diagram.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "getSub",
          "package": "diagrams-lib",
          "signature": "Subdiagram b v m -\u003e QDiagram b v m",
          "type": "function"
        },
        "index": {
          "description": "Turn subdiagram into normal diagram including the enclosing context Concretely subdiagram is pair of diagram and context consisting of an extra transformation and attributes getSub simply applies the transformation and attributes to the diagram to get the corresponding top-level diagram",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "getSub",
          "normalized": "Subdiagram a b c-\u003eQDiagram a b c",
          "package": "diagrams-lib",
          "partial": "Sub",
          "signature": "Subdiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:getSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Localize\" a diagram by hiding all the names, so they are no\n   longer visible to the outside.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "localize",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m -\u003e QDiagram b v m",
          "type": "function"
        },
        "index": {
          "description": "Localize diagram by hiding all the names so they are no longer visible to the outside",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "localize",
          "normalized": "QDiagram a b c-\u003eQDiagram a b c",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:localize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the location of a subdiagram; that is, the location of its\n   local origin \u003cem\u003ewith respect to\u003c/em\u003e the vector space of its parent\n   diagram.  In other words, the point where its local origin\n   \"ended up\".\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "location",
          "package": "diagrams-lib",
          "signature": "Subdiagram b v m -\u003e Point v",
          "type": "function"
        },
        "index": {
          "description": "Get the location of subdiagram that is the location of its local origin with respect to the vector space of its parent diagram In other words the point where its local origin ended up",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "location",
          "normalized": "Subdiagram a b c-\u003ePoint b",
          "package": "diagrams-lib",
          "signature": "Subdiagram b v m-\u003ePoint v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:location"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup the most recent diagram associated with (some\n   qualification of) the given name.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "lookupName",
          "package": "diagrams-lib",
          "signature": "n -\u003e QDiagram b v m -\u003e Maybe (Subdiagram b v m)",
          "type": "function"
        },
        "index": {
          "description": "Lookup the most recent diagram associated with some qualification of the given name",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "lookupName",
          "normalized": "a-\u003eQDiagram b c d-\u003eMaybe(Subdiagram b c d)",
          "package": "diagrams-lib",
          "partial": "Name",
          "signature": "n-\u003eQDiagram b v m-\u003eMaybe(Subdiagram b v m)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:lookupName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLook for the given name in a name map, returning a list of\n   subdiagrams associated with that name.  If no names match the\n   given name exactly, return all the subdiagrams associated with\n   names of which the given name is a suffix.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "lookupSub",
          "package": "diagrams-lib",
          "signature": "n -\u003e SubMap b v m -\u003e Maybe [Subdiagram b v m]",
          "type": "function"
        },
        "index": {
          "description": "Look for the given name in name map returning list of subdiagrams associated with that name If no names match the given name exactly return all the subdiagrams associated with names of which the given name is suffix",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "lookupSub",
          "normalized": "a-\u003eSubMap b c d-\u003eMaybe[Subdiagram b c d]",
          "package": "diagrams-lib",
          "partial": "Sub",
          "signature": "n-\u003eSubMap b v m-\u003eMaybe[Subdiagram b v m]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:lookupSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn a diagram into a subdiagram with no accumulated context.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "mkSubdiagram",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m -\u003e Subdiagram b v m",
          "type": "function"
        },
        "index": {
          "description": "Turn diagram into subdiagram with no accumulated context",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "mkSubdiagram",
          "normalized": "QDiagram a b c-\u003eSubdiagram a b c",
          "package": "diagrams-lib",
          "partial": "Subdiagram",
          "signature": "QDiagram b v m-\u003eSubdiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:mkSubdiagram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttach an atomic name to a certain point (which may be computed\n   from the given diagram), treated as a subdiagram with no content\n   and a point envelope.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "namePoint",
          "package": "diagrams-lib",
          "signature": "(QDiagram b v m -\u003e Point v) -\u003e n -\u003e QDiagram b v m -\u003e QDiagram b v m",
          "source": "src/Diagrams-Names.html#namePoint",
          "type": "function"
        },
        "index": {
          "description": "Attach an atomic name to certain point which may be computed from the given diagram treated as subdiagram with no content and point envelope",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "namePoint",
          "normalized": "(QDiagram a b c-\u003ePoint b)-\u003ed-\u003eQDiagram a b c-\u003eQDiagram a b c",
          "package": "diagrams-lib",
          "partial": "Point",
          "signature": "(QDiagram b v m-\u003ePoint v)-\u003en-\u003eQDiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:namePoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttach an atomic name to a certain subdiagram, computed from the\n   given diagram.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "nameSub",
          "package": "diagrams-lib",
          "signature": "(QDiagram b v m -\u003e Subdiagram b v m) -\u003e n -\u003e QDiagram b v m -\u003e QDiagram b v m",
          "type": "function"
        },
        "index": {
          "description": "Attach an atomic name to certain subdiagram computed from the given diagram",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "nameSub",
          "normalized": "(QDiagram a b c-\u003eSubdiagram a b c)-\u003ed-\u003eQDiagram a b c-\u003eQDiagram a b c",
          "package": "diagrams-lib",
          "partial": "Sub",
          "signature": "(QDiagram b v m-\u003eSubdiagram b v m)-\u003en-\u003eQDiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:nameSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttach an atomic name to a diagram.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "named",
          "package": "diagrams-lib",
          "signature": "n -\u003e QDiagram b v m -\u003e QDiagram b v m",
          "source": "src/Diagrams-Names.html#named",
          "type": "function"
        },
        "index": {
          "description": "Attach an atomic name to diagram",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "named",
          "normalized": "a-\u003eQDiagram b c d-\u003eQDiagram b c d",
          "package": "diagrams-lib",
          "signature": "n-\u003eQDiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:named"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet a list of names of subdiagrams and their locations.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "names",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m -\u003e [(Name, [Point v])]",
          "type": "function"
        },
        "index": {
          "description": "Get list of names of subdiagrams and their locations",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "names",
          "normalized": "QDiagram a b c-\u003e[(Name,[Point b])]",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m-\u003e[(Name,[Point v])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:names"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the \"raw\" content of a subdiagram, by throwing away the\n   context.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "rawSub",
          "package": "diagrams-lib",
          "signature": "Subdiagram b v m -\u003e QDiagram b v m",
          "type": "function"
        },
        "index": {
          "description": "Extract the raw content of subdiagram by throwing away the context",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "rawSub",
          "normalized": "Subdiagram a b c-\u003eQDiagram a b c",
          "package": "diagrams-lib",
          "partial": "Sub",
          "signature": "Subdiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:rawSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a name/diagram association to a submap.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "rememberAs",
          "package": "diagrams-lib",
          "signature": "a -\u003e QDiagram b v m -\u003e SubMap b v m -\u003e SubMap b v m",
          "type": "function"
        },
        "index": {
          "description": "Add name diagram association to submap",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "rememberAs",
          "normalized": "a-\u003eQDiagram b c d-\u003eSubMap b c d-\u003eSubMap b c d",
          "package": "diagrams-lib",
          "partial": "As",
          "signature": "a-\u003eQDiagram b v m-\u003eSubMap b v m-\u003eSubMap b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:rememberAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a \"point subdiagram\", that is, a \u003ccode\u003e\u003ca\u003epointDiagram\u003c/a\u003e\u003c/code\u003e (with no\n   content and a point envelope) treated as a subdiagram with local\n   origin at the given point.  Note this is not the same as\n   \u003ccode\u003emkSubdiagram . pointDiagram\u003c/code\u003e, which would result in a subdiagram\n   with local origin at the parent origin, rather than at the given\n   point.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "subPoint",
          "package": "diagrams-lib",
          "signature": "Point v -\u003e Subdiagram b v m",
          "type": "function"
        },
        "index": {
          "description": "Create point subdiagram that is pointDiagram with no content and point envelope treated as subdiagram with local origin at the given point Note this is not the same as mkSubdiagram pointDiagram which would result in subdiagram with local origin at the parent origin rather than at the given point",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "subPoint",
          "normalized": "Point a-\u003eSubdiagram b a c",
          "package": "diagrams-lib",
          "partial": "Point",
          "signature": "Point v-\u003eSubdiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:subPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Names",
          "name": "toName",
          "package": "diagrams-lib",
          "signature": "a -\u003e Name",
          "type": "method"
        },
        "index": {
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "toName",
          "normalized": "a-\u003eName",
          "package": "diagrams-lib",
          "partial": "Name",
          "signature": "a-\u003eName",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:toName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a name and a diagram transformation indexed by a\n   subdiagram, perform the transformation using the most recent\n   subdiagram associated with (some qualification of) the name,\n   or perform the identity transformation if the name does not exist.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "withName",
          "package": "diagrams-lib",
          "signature": "n -\u003e (Subdiagram b v m -\u003e QDiagram b v m -\u003e QDiagram b v m) -\u003e QDiagram b v m -\u003e QDiagram b v m",
          "type": "function"
        },
        "index": {
          "description": "Given name and diagram transformation indexed by subdiagram perform the transformation using the most recent subdiagram associated with some qualification of the name or perform the identity transformation if the name does not exist",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "withName",
          "normalized": "a-\u003e(Subdiagram b c d-\u003eQDiagram b c d-\u003eQDiagram b c d)-\u003eQDiagram b c d-\u003eQDiagram b c d",
          "package": "diagrams-lib",
          "partial": "Name",
          "signature": "n-\u003e(Subdiagram b v m-\u003eQDiagram b v m-\u003eQDiagram b v m)-\u003eQDiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:withName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a name and a diagram transformation indexed by a list of\n   subdiagrams, perform the transformation using the\n   collection of all such subdiagrams associated with (some\n   qualification of) the given name.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "withNameAll",
          "package": "diagrams-lib",
          "signature": "n -\u003e ([Subdiagram b v m] -\u003e QDiagram b v m -\u003e QDiagram b v m) -\u003e QDiagram b v m -\u003e QDiagram b v m",
          "type": "function"
        },
        "index": {
          "description": "Given name and diagram transformation indexed by list of subdiagrams perform the transformation using the collection of all such subdiagrams associated with some qualification of the given name",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "withNameAll",
          "normalized": "a-\u003e([Subdiagram b c d]-\u003eQDiagram b c d-\u003eQDiagram b c d)-\u003eQDiagram b c d-\u003eQDiagram b c d",
          "package": "diagrams-lib",
          "partial": "Name All",
          "signature": "n-\u003e([Subdiagram b v m]-\u003eQDiagram b v m-\u003eQDiagram b v m)-\u003eQDiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:withNameAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list of names and a diagram transformation indexed by a\n   list of subdiagrams, perform the transformation using the\n   list of most recent subdiagrams associated with (some qualification\n   of) each name.  Do nothing (the identity transformation) if any\n   of the names do not exist.\n\u003c/p\u003e",
          "module": "Diagrams.Names",
          "name": "withNames",
          "package": "diagrams-lib",
          "signature": "[n] -\u003e ([Subdiagram b v m] -\u003e QDiagram b v m -\u003e QDiagram b v m) -\u003e QDiagram b v m -\u003e QDiagram b v m",
          "type": "function"
        },
        "index": {
          "description": "Given list of names and diagram transformation indexed by list of subdiagrams perform the transformation using the list of most recent subdiagrams associated with some qualification of each name Do nothing the identity transformation if any of the names do not exist",
          "hierarchy": "Diagrams Names",
          "module": "Diagrams.Names",
          "name": "withNames",
          "normalized": "[a]-\u003e([Subdiagram b c d]-\u003eQDiagram b c d-\u003eQDiagram b c d)-\u003eQDiagram b c d-\u003eQDiagram b c d",
          "package": "diagrams-lib",
          "partial": "Names",
          "signature": "[n]-\u003e([Subdiagram b v m]-\u003eQDiagram b v m-\u003eQDiagram b v m)-\u003eQDiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Names.html#v:withNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTools for adjusting the length of parametric objects such as\n segments and trails.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Parametric.Adjust",
          "name": "Adjust",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Parametric-Adjust.html",
          "type": "module"
        },
        "index": {
          "description": "Tools for adjusting the length of parametric objects such as segments and trails",
          "hierarchy": "Diagrams Parametric Adjust",
          "module": "Diagrams.Parametric.Adjust",
          "name": "Adjust",
          "package": "diagrams-lib",
          "partial": "Adjust",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric-Adjust.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhat method should be used for adjusting a segment, trail, or\n   path?\n\u003c/p\u003e",
          "module": "Diagrams.Parametric.Adjust",
          "name": "AdjustMethod",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Parametric-Adjust.html#AdjustMethod",
          "type": "data"
        },
        "index": {
          "description": "What method should be used for adjusting segment trail or path",
          "hierarchy": "Diagrams Parametric Adjust",
          "module": "Diagrams.Parametric.Adjust",
          "name": "AdjustMethod",
          "package": "diagrams-lib",
          "partial": "Adjust Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric-Adjust.html#t:AdjustMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHow should a segment, trail, or path be adjusted?\n\u003c/p\u003e",
          "module": "Diagrams.Parametric.Adjust",
          "name": "AdjustOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Parametric-Adjust.html#AdjustOpts",
          "type": "data"
        },
        "index": {
          "description": "How should segment trail or path be adjusted",
          "hierarchy": "Diagrams Parametric Adjust",
          "module": "Diagrams.Parametric.Adjust",
          "name": "AdjustOpts",
          "package": "diagrams-lib",
          "partial": "Adjust Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric-Adjust.html#t:AdjustOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhich side of a segment, trail, or path should be adjusted?\n\u003c/p\u003e",
          "module": "Diagrams.Parametric.Adjust",
          "name": "AdjustSide",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Parametric-Adjust.html#AdjustSide",
          "type": "data"
        },
        "index": {
          "description": "Which side of segment trail or path should be adjusted",
          "hierarchy": "Diagrams Parametric Adjust",
          "module": "Diagrams.Parametric.Adjust",
          "name": "AdjustSide",
          "package": "diagrams-lib",
          "partial": "Adjust Side",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric-Adjust.html#t:AdjustSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust both sides equally\n\u003c/p\u003e",
          "module": "Diagrams.Parametric.Adjust",
          "name": "Both",
          "package": "diagrams-lib",
          "signature": "Both",
          "source": "src/Diagrams-Parametric-Adjust.html#AdjustSide",
          "type": "function"
        },
        "index": {
          "description": "Adjust both sides equally",
          "hierarchy": "Diagrams Parametric Adjust",
          "module": "Diagrams.Parametric.Adjust",
          "name": "Both",
          "package": "diagrams-lib",
          "partial": "Both",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric-Adjust.html#v:Both"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtend by the given arc length\n   (use a negative length to shrink)\n\u003c/p\u003e",
          "module": "Diagrams.Parametric.Adjust",
          "name": "ByAbsolute",
          "package": "diagrams-lib",
          "signature": "ByAbsolute (Scalar v)",
          "source": "src/Diagrams-Parametric-Adjust.html#AdjustMethod",
          "type": "function"
        },
        "index": {
          "description": "Extend by the given arc length use negative length to shrink",
          "hierarchy": "Diagrams Parametric Adjust",
          "module": "Diagrams.Parametric.Adjust",
          "name": "ByAbsolute",
          "package": "diagrams-lib",
          "partial": "By Absolute",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric-Adjust.html#v:ByAbsolute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtend by the given parameter value\n   (use a negative parameter to shrink)\n\u003c/p\u003e",
          "module": "Diagrams.Parametric.Adjust",
          "name": "ByParam",
          "package": "diagrams-lib",
          "signature": "ByParam (Scalar v)",
          "source": "src/Diagrams-Parametric-Adjust.html#AdjustMethod",
          "type": "function"
        },
        "index": {
          "description": "Extend by the given parameter value use negative parameter to shrink",
          "hierarchy": "Diagrams Parametric Adjust",
          "module": "Diagrams.Parametric.Adjust",
          "name": "ByParam",
          "package": "diagrams-lib",
          "partial": "By Param",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric-Adjust.html#v:ByParam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust only the end\n\u003c/p\u003e",
          "module": "Diagrams.Parametric.Adjust",
          "name": "End",
          "package": "diagrams-lib",
          "signature": "End",
          "source": "src/Diagrams-Parametric-Adjust.html#AdjustSide",
          "type": "function"
        },
        "index": {
          "description": "Adjust only the end",
          "hierarchy": "Diagrams Parametric Adjust",
          "module": "Diagrams.Parametric.Adjust",
          "name": "End",
          "package": "diagrams-lib",
          "partial": "End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric-Adjust.html#v:End"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust only the beginning\n\u003c/p\u003e",
          "module": "Diagrams.Parametric.Adjust",
          "name": "Start",
          "package": "diagrams-lib",
          "signature": "Start",
          "source": "src/Diagrams-Parametric-Adjust.html#AdjustSide",
          "type": "function"
        },
        "index": {
          "description": "Adjust only the beginning",
          "hierarchy": "Diagrams Parametric Adjust",
          "module": "Diagrams.Parametric.Adjust",
          "name": "Start",
          "package": "diagrams-lib",
          "partial": "Start",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric-Adjust.html#v:Start"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtend or shrink to the given\n   arc length\n\u003c/p\u003e",
          "module": "Diagrams.Parametric.Adjust",
          "name": "ToAbsolute",
          "package": "diagrams-lib",
          "signature": "ToAbsolute (Scalar v)",
          "source": "src/Diagrams-Parametric-Adjust.html#AdjustMethod",
          "type": "function"
        },
        "index": {
          "description": "Extend or shrink to the given arc length",
          "hierarchy": "Diagrams Parametric Adjust",
          "module": "Diagrams.Parametric.Adjust",
          "name": "ToAbsolute",
          "package": "diagrams-lib",
          "partial": "To Absolute",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric-Adjust.html#v:ToAbsolute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTolerance to use when doing adjustment.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric.Adjust",
          "name": "adjEps",
          "package": "diagrams-lib",
          "signature": "Lens' (AdjustOpts v) (Scalar v)",
          "source": "src/Diagrams-Parametric-Adjust.html#adjEps",
          "type": "function"
        },
        "index": {
          "description": "Tolerance to use when doing adjustment",
          "hierarchy": "Diagrams Parametric Adjust",
          "module": "Diagrams.Parametric.Adjust",
          "name": "adjEps",
          "package": "diagrams-lib",
          "partial": "Eps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric-Adjust.html#v:adjEps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhich method should be used for adjusting?\n\u003c/p\u003e",
          "module": "Diagrams.Parametric.Adjust",
          "name": "adjMethod",
          "package": "diagrams-lib",
          "signature": "Lens' (AdjustOpts v) (AdjustMethod v)",
          "source": "src/Diagrams-Parametric-Adjust.html#adjMethod",
          "type": "function"
        },
        "index": {
          "description": "Which method should be used for adjusting",
          "hierarchy": "Diagrams Parametric Adjust",
          "module": "Diagrams.Parametric.Adjust",
          "name": "adjMethod",
          "package": "diagrams-lib",
          "partial": "Method",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric-Adjust.html#v:adjMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhich end(s) of the object should be adjusted?\n\u003c/p\u003e",
          "module": "Diagrams.Parametric.Adjust",
          "name": "adjSide",
          "package": "diagrams-lib",
          "signature": "Lens' (AdjustOpts v) AdjustSide",
          "source": "src/Diagrams-Parametric-Adjust.html#adjSide",
          "type": "function"
        },
        "index": {
          "description": "Which end of the object should be adjusted",
          "hierarchy": "Diagrams Parametric Adjust",
          "module": "Diagrams.Parametric.Adjust",
          "name": "adjSide",
          "package": "diagrams-lib",
          "partial": "Side",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric-Adjust.html#v:adjSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the length of a parametric object such as a segment or\n   trail.  The second parameter is an option record which controls how\n   the adjustment should be performed; see \u003ccode\u003e\u003ca\u003eAdjustOpts\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric.Adjust",
          "name": "adjust",
          "package": "diagrams-lib",
          "signature": "a -\u003e AdjustOpts (V a) -\u003e a",
          "source": "src/Diagrams-Parametric-Adjust.html#adjust",
          "type": "function"
        },
        "index": {
          "description": "Adjust the length of parametric object such as segment or trail The second parameter is an option record which controls how the adjustment should be performed see AdjustOpts",
          "hierarchy": "Diagrams Parametric Adjust",
          "module": "Diagrams.Parametric.Adjust",
          "name": "adjust",
          "normalized": "a-\u003eAdjustOpts(V a)-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003eAdjustOpts(V a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric-Adjust.html#v:adjust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType classes for things which are parameterized in some way, \u003cem\u003ee.g.\u003c/em\u003e\n segments and trails.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Parametric",
          "name": "Parametric",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Parametric.html",
          "type": "module"
        },
        "index": {
          "description": "Type classes for things which are parameterized in some way e.g segments and trails",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "Parametric",
          "package": "diagrams-lib",
          "partial": "Parametric",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCodomain of parametric classes.  This is usually either \u003ccode\u003e(V p)\u003c/code\u003e, for relative\n   vector results, or \u003ccode\u003e(Point (V p))\u003c/code\u003e, for functions with absolute coordinates.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "Codomain",
          "package": "diagrams-lib",
          "signature": "Codomain",
          "type": "function"
        },
        "index": {
          "description": "Codomain of parametric classes This is usually either for relative vector results or Point for functions with absolute coordinates",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "Codomain",
          "package": "diagrams-lib",
          "partial": "Codomain",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#t:Codomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class for parametric functions with a bounded domain.  The\n   default bounds are \u003ccode\u003e[0,1]\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that this domain indicates the main \"interesting\" portion of the\n   function.  It must be defined within this range, but for some instances may\n   still have sensible values outside.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "DomainBounds",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Parametric.html#DomainBounds",
          "type": "class"
        },
        "index": {
          "description": "Type class for parametric functions with bounded domain The default bounds are Note that this domain indicates the main interesting portion of the function It must be defined within this range but for some instances may still have sensible values outside",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "DomainBounds",
          "package": "diagrams-lib",
          "partial": "Domain Bounds",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#t:DomainBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class for querying the values of a parametric object at the\n   ends of its domain.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "EndValues",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Parametric.html#EndValues",
          "type": "class"
        },
        "index": {
          "description": "Type class for querying the values of parametric object at the ends of its domain",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "EndValues",
          "package": "diagrams-lib",
          "partial": "End Values",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#t:EndValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class for parametric things with a notion of arc length.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "HasArcLength",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Parametric.html#HasArcLength",
          "type": "class"
        },
        "index": {
          "description": "Type class for parametric things with notion of arc length",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "HasArcLength",
          "package": "diagrams-lib",
          "partial": "Has Arc Length",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#t:HasArcLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class for parametric functions.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "Parametric",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Parametric.html#Parametric",
          "type": "class"
        },
        "index": {
          "description": "Type class for parametric functions",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "Parametric",
          "package": "diagrams-lib",
          "partial": "Parametric",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#t:Parametric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class for parametric objects which can be split into\n   subobjects.\n\u003c/p\u003e\u003cp\u003eMinimal definition: Either \u003ccode\u003e\u003ca\u003esplitAtParam\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003esection\u003c/a\u003e\u003c/code\u003e,\n   plus \u003ccode\u003e\u003ca\u003ereverseDomain\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "Sectionable",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Parametric.html#Sectionable",
          "type": "class"
        },
        "index": {
          "description": "Type class for parametric objects which can be split into subobjects Minimal definition Either splitAtParam or section plus reverseDomain",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "Sectionable",
          "package": "diagrams-lib",
          "partial": "Sectionable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#t:Sectionable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003earcLength eps s\u003c/code\u003e approximates the arc length of \u003ccode\u003ex\u003c/code\u003e up to the\n   accuracy \u003ccode\u003eeps\u003c/code\u003e (plus or minus).\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "arcLength",
          "package": "diagrams-lib",
          "signature": "Scalar (V p) -\u003e p -\u003e Scalar (V p)",
          "source": "src/Diagrams-Parametric.html#arcLength",
          "type": "method"
        },
        "index": {
          "description": "arcLength eps approximates the arc length of up to the accuracy eps plus or minus",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "arcLength",
          "normalized": "Scalar(V a)-\u003ea-\u003eScalar(V a)",
          "package": "diagrams-lib",
          "partial": "Length",
          "signature": "Scalar(V p)-\u003ep-\u003eScalar(V p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:arcLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003earcLengthBounded eps x\u003c/code\u003e approximates the arc length of \u003ccode\u003ex\u003c/code\u003e.\n   The true arc length is guaranteed to lie within the interval\n   returned, which will have a size of at most \u003ccode\u003eeps\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "arcLengthBounded",
          "package": "diagrams-lib",
          "signature": "Scalar (V p) -\u003e p -\u003e Interval (Scalar (V p))",
          "source": "src/Diagrams-Parametric.html#arcLengthBounded",
          "type": "method"
        },
        "index": {
          "description": "arcLengthBounded eps approximates the arc length of The true arc length is guaranteed to lie within the interval returned which will have size of at most eps",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "arcLengthBounded",
          "normalized": "Scalar(V a)-\u003ea-\u003eInterval(Scalar(V a))",
          "package": "diagrams-lib",
          "partial": "Length Bounded",
          "signature": "Scalar(V p)-\u003ep-\u003eInterval(Scalar(V p))",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:arcLengthBounded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003earcLengthToParam\u003c/a\u003e\u003c/code\u003e eps s l\u003c/code\u003e converts the absolute arc length\n   \u003ccode\u003el\u003c/code\u003e, measured from the start of the domain, to a parameter on\n   the object \u003ccode\u003es\u003c/code\u003e.  The true arc length at the parameter returned\n   is guaranteed to be within \u003ccode\u003eeps\u003c/code\u003e of the requested arc length.\n\u003c/p\u003e\u003cp\u003eThis should work for \u003cem\u003eany\u003c/em\u003e arc length, and may return any\n   parameter value (not just parameters in the domain).\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "arcLengthToParam",
          "package": "diagrams-lib",
          "signature": "Scalar (V p) -\u003e p -\u003e Scalar (V p) -\u003e Scalar (V p)",
          "source": "src/Diagrams-Parametric.html#arcLengthToParam",
          "type": "method"
        },
        "index": {
          "description": "arcLengthToParam eps converts the absolute arc length measured from the start of the domain to parameter on the object The true arc length at the parameter returned is guaranteed to be within eps of the requested arc length This should work for any arc length and may return any parameter value not just parameters in the domain",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "arcLengthToParam",
          "normalized": "Scalar(V a)-\u003ea-\u003eScalar(V a)-\u003eScalar(V a)",
          "package": "diagrams-lib",
          "partial": "Length To Param",
          "signature": "Scalar(V p)-\u003ep-\u003eScalar(V p)-\u003eScalar(V p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:arcLengthToParam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eatEnd\u003c/a\u003e\u003c/code\u003e is the value at the end of the domain. That is,\n\u003c/p\u003e\u003cpre\u003e atEnd x = x `atParam` domainUpper x\n\u003c/pre\u003e\u003cp\u003eThis is the default implementation, but some representations will\n   have a more efficient and/or precise implementation.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "atEnd",
          "package": "diagrams-lib",
          "signature": "p -\u003e Codomain p",
          "source": "src/Diagrams-Parametric.html#atEnd",
          "type": "method"
        },
        "index": {
          "description": "atEnd is the value at the end of the domain That is atEnd atParam domainUpper This is the default implementation but some representations will have more efficient and or precise implementation",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "atEnd",
          "normalized": "a-\u003eCodomain a",
          "package": "diagrams-lib",
          "partial": "End",
          "signature": "p-\u003eCodomain p",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:atEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eatParam\u003c/a\u003e\u003c/code\u003e yields a parameterized view of an object as a\n   continuous function. It is designed to be used infix, like \u003ccode\u003epath\n   `\u003ccode\u003e\u003ca\u003eatParam\u003c/a\u003e\u003c/code\u003e` 0.5\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "atParam",
          "package": "diagrams-lib",
          "signature": "p -\u003e Scalar (V p) -\u003e Codomain p",
          "source": "src/Diagrams-Parametric.html#atParam",
          "type": "method"
        },
        "index": {
          "description": "atParam yields parameterized view of an object as continuous function It is designed to be used infix like path atParam",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "atParam",
          "normalized": "a-\u003eScalar(V a)-\u003eCodomain a",
          "package": "diagrams-lib",
          "partial": "Param",
          "signature": "p-\u003eScalar(V p)-\u003eCodomain p",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:atParam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eatStart\u003c/a\u003e\u003c/code\u003e is the value at the start of the domain.  That is,\n\u003c/p\u003e\u003cpre\u003e atStart x = x `atParam` domainLower x\n\u003c/pre\u003e\u003cp\u003eThis is the default implementation, but some representations will\n   have a more efficient and/or precise implementation.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "atStart",
          "package": "diagrams-lib",
          "signature": "p -\u003e Codomain p",
          "source": "src/Diagrams-Parametric.html#atStart",
          "type": "method"
        },
        "index": {
          "description": "atStart is the value at the start of the domain That is atStart atParam domainLower This is the default implementation but some representations will have more efficient and or precise implementation",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "atStart",
          "normalized": "a-\u003eCodomain a",
          "package": "diagrams-lib",
          "partial": "Start",
          "signature": "p-\u003eCodomain p",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:atStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the lower and upper bounds of a parametric domain together\n   as a pair.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "domainBounds",
          "package": "diagrams-lib",
          "signature": "p -\u003e (Scalar (V p), Scalar (V p))",
          "source": "src/Diagrams-Parametric.html#domainBounds",
          "type": "function"
        },
        "index": {
          "description": "Return the lower and upper bounds of parametric domain together as pair",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "domainBounds",
          "normalized": "a-\u003e(Scalar(V a),Scalar(V a))",
          "package": "diagrams-lib",
          "partial": "Bounds",
          "signature": "p-\u003e(Scalar(V p),Scalar(V p))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:domainBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edomainLower\u003c/a\u003e\u003c/code\u003e defaults to being constantly 0 (for vector spaces with\n   numeric scalars).\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "domainLower",
          "package": "diagrams-lib",
          "signature": "p -\u003e Scalar (V p)",
          "source": "src/Diagrams-Parametric.html#domainLower",
          "type": "method"
        },
        "index": {
          "description": "domainLower defaults to being constantly for vector spaces with numeric scalars",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "domainLower",
          "normalized": "a-\u003eScalar(V a)",
          "package": "diagrams-lib",
          "partial": "Lower",
          "signature": "p-\u003eScalar(V p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:domainLower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edomainUpper\u003c/a\u003e\u003c/code\u003e defaults to being constantly 1 (for vector spaces\n   with numeric scalars).\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "domainUpper",
          "package": "diagrams-lib",
          "signature": "p -\u003e Scalar (V p)",
          "source": "src/Diagrams-Parametric.html#domainUpper",
          "type": "method"
        },
        "index": {
          "description": "domainUpper defaults to being constantly for vector spaces with numeric scalars",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "domainUpper",
          "normalized": "a-\u003eScalar(V a)",
          "package": "diagrams-lib",
          "partial": "Upper",
          "signature": "p-\u003eScalar(V p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:domainUpper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlip the parameterization on the domain.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "reverseDomain",
          "package": "diagrams-lib",
          "signature": "p -\u003e p",
          "source": "src/Diagrams-Parametric.html#reverseDomain",
          "type": "method"
        },
        "index": {
          "description": "Flip the parameterization on the domain",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "reverseDomain",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "partial": "Domain",
          "signature": "p-\u003ep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:reverseDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract a particular section of the domain, linearly\n   reparameterized to the same domain as the original.  Should\n   satisfy the property:\n\u003c/p\u003e\u003cpre\u003e prop_section x l u t =\n   let s = section x l u\n   in     domainBounds x == domainBounds x\n       && (x `atParam` lerp l u t) == (s `atParam` t)\n\u003c/pre\u003e\u003cp\u003eThat is, the section should have the same domain as the\n   original, and the reparameterization should be linear.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "section",
          "package": "diagrams-lib",
          "signature": "p -\u003e Scalar (V p) -\u003e Scalar (V p) -\u003e p",
          "source": "src/Diagrams-Parametric.html#section",
          "type": "method"
        },
        "index": {
          "description": "Extract particular section of the domain linearly reparameterized to the same domain as the original Should satisfy the property prop section let section in domainBounds domainBounds atParam lerp atParam That is the section should have the same domain as the original and the reparameterization should be linear",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "section",
          "normalized": "a-\u003eScalar(V a)-\u003eScalar(V a)-\u003ea",
          "package": "diagrams-lib",
          "signature": "p-\u003eScalar(V p)-\u003eScalar(V p)-\u003ep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:section"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esplitAtParam\u003c/a\u003e\u003c/code\u003e splits an object \u003ccode\u003ep\u003c/code\u003e into two new objects\n   \u003ccode\u003e(l,r)\u003c/code\u003e at the parameter \u003ccode\u003et\u003c/code\u003e, where \u003ccode\u003el\u003c/code\u003e corresponds to the\n   portion of \u003ccode\u003ep\u003c/code\u003e for parameter values from \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003et\u003c/code\u003e and \u003ccode\u003er\u003c/code\u003e for\n   to that from \u003ccode\u003et\u003c/code\u003e to \u003ccode\u003e1\u003c/code\u003e.  The following property should hold:\n\u003c/p\u003e\u003cpre\u003e prop_splitAtParam f t u =\n   | u \u003c t     = atParam f u == atParam l (u / t)\n   | otherwise = atParam f u == atParam f t ??? atParam l ((u - t) / (domainUpper f - t))\n   where (l,r) = splitAtParam f t\n\u003c/pre\u003e\u003cp\u003ewhere \u003ccode\u003e(???) = (^+^)\u003c/code\u003e if the codomain is a vector type, or\n   \u003ccode\u003econst flip\u003c/code\u003e if the codomain is a point type.  Stated more\n   intuitively, all this is to say that the parameterization\n   scales linearly with splitting.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003esplitAtParam\u003c/a\u003e\u003c/code\u003e can also be used with parameters outside the\n   range of the domain.  For example, using the parameter \u003ccode\u003e2\u003c/code\u003e with\n   a path (where the domain is the default \u003ccode\u003e[0,1]\u003c/code\u003e) gives two\n   result paths where the first is the original path extended to\n   the parameter 2, and the second result path travels \u003cem\u003ebackwards\u003c/em\u003e\n   from the end of the first to the end of the original path.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "splitAtParam",
          "package": "diagrams-lib",
          "signature": "p -\u003e Scalar (V p) -\u003e (p, p)",
          "source": "src/Diagrams-Parametric.html#splitAtParam",
          "type": "method"
        },
        "index": {
          "description": "splitAtParam splits an object into two new objects at the parameter where corresponds to the portion of for parameter values from to and for to that from to The following property should hold prop splitAtParam atParam atParam otherwise atParam atParam atParam domainUpper where splitAtParam where if the codomain is vector type or const flip if the codomain is point type Stated more intuitively all this is to say that the parameterization scales linearly with splitting splitAtParam can also be used with parameters outside the range of the domain For example using the parameter with path where the domain is the default gives two result paths where the first is the original path extended to the parameter and the second result path travels backwards from the end of the first to the end of the original path",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "splitAtParam",
          "normalized": "a-\u003eScalar(V a)-\u003e(a,a)",
          "package": "diagrams-lib",
          "partial": "At Param",
          "signature": "p-\u003eScalar(V p)-\u003e(p,p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:splitAtParam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApproximate the arc length up to a standard accuracy of\n   \u003ccode\u003e\u003ca\u003estdTolerance\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e1e-6\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "stdArcLength",
          "package": "diagrams-lib",
          "signature": "p -\u003e Scalar (V p)",
          "source": "src/Diagrams-Parametric.html#stdArcLength",
          "type": "method"
        },
        "index": {
          "description": "Approximate the arc length up to standard accuracy of stdTolerance e-6",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "stdArcLength",
          "normalized": "a-\u003eScalar(V a)",
          "package": "diagrams-lib",
          "partial": "Arc Length",
          "signature": "p-\u003eScalar(V p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:stdArcLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA simple interface to convert arc length to a parameter,\n   guaranteed to be accurate within \u003ccode\u003e\u003ca\u003estdTolerance\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e1e-6\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "stdArcLengthToParam",
          "package": "diagrams-lib",
          "signature": "p -\u003e Scalar (V p) -\u003e Scalar (V p)",
          "source": "src/Diagrams-Parametric.html#stdArcLengthToParam",
          "type": "method"
        },
        "index": {
          "description": "simple interface to convert arc length to parameter guaranteed to be accurate within stdTolerance or e-6",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "stdArcLengthToParam",
          "normalized": "a-\u003eScalar(V a)-\u003eScalar(V a)",
          "package": "diagrams-lib",
          "partial": "Arc Length To Param",
          "signature": "p-\u003eScalar(V p)-\u003eScalar(V p)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:stdArcLengthToParam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe standard tolerance used by \u003ccode\u003estd...\u003c/code\u003e functions (like\n   \u003ccode\u003e\u003ca\u003estdArcLength\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003estdArcLengthToParam\u003c/a\u003e\u003c/code\u003e, currently set at\n   \u003ccode\u003e1e-6\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Parametric",
          "name": "stdTolerance",
          "package": "diagrams-lib",
          "signature": "a",
          "source": "src/Diagrams-Parametric.html#stdTolerance",
          "type": "function"
        },
        "index": {
          "description": "The standard tolerance used by std functions like stdArcLength and stdArcLengthToParam currently set at e-6",
          "hierarchy": "Diagrams Parametric",
          "module": "Diagrams.Parametric",
          "name": "stdTolerance",
          "package": "diagrams-lib",
          "partial": "Tolerance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Parametric.html#v:stdTolerance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines \u003cem\u003epaths\u003c/em\u003e, which are collections of concretely\n located \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003es.  Many drawing systems (cairo, svg, ...) have a\n similar notion of \"path\".  Note that paths with multiple trails\n are necessary for being able to draw \u003cem\u003ee.g.\u003c/em\u003e filled objects with\n holes in them.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Path",
          "name": "Path",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Path.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines paths which are collections of concretely located Trail Many drawing systems cairo svg have similar notion of path Note that paths with multiple trails are necessary for being able to draw e.g filled objects with holes in them",
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "Path",
          "package": "diagrams-lib",
          "partial": "Path",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003cem\u003epath\u003c/em\u003e is a (possibly empty) list of \u003ccode\u003e\u003ca\u003eLocated\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003es.\n   Hence, unlike trails, paths are not translationally invariant,\n   and they form a monoid under \u003cem\u003esuperposition\u003c/em\u003e (placing one path on\n   top of another) rather than concatenation.\n\u003c/p\u003e",
          "module": "Diagrams.Path",
          "name": "Path",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Path.html#Path",
          "type": "newtype"
        },
        "index": {
          "description": "path is possibly empty list of Located Trail Hence unlike trails paths are not translationally invariant and they form monoid under superposition placing one path on top of another rather than concatenation",
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "Path",
          "package": "diagrams-lib",
          "partial": "Path",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#t:Path"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Path",
          "name": "Path",
          "package": "diagrams-lib",
          "signature": "Path [Located (Trail v)]",
          "source": "src/Diagrams-Path.html#Path",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "Path",
          "normalized": "Path[Located(Trail a)]",
          "package": "diagrams-lib",
          "partial": "Path",
          "signature": "Path[Located(Trail v)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#v:Path"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Explode\" a path by exploding every component trail (see\n   \u003ccode\u003e\u003ca\u003eexplodeTrail\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Diagrams.Path",
          "name": "explodePath",
          "package": "diagrams-lib",
          "signature": "Path (V t) -\u003e [[t]]",
          "source": "src/Diagrams-Path.html#explodePath",
          "type": "function"
        },
        "index": {
          "description": "Explode path by exploding every component trail see explodeTrail",
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "explodePath",
          "normalized": "Path(V a)-\u003e[[a]]",
          "package": "diagrams-lib",
          "partial": "Path",
          "signature": "Path(V t)-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#v:explodePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a path into a list of lists of \u003ccode\u003e\u003ca\u003eFixedSegment\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Diagrams.Path",
          "name": "fixPath",
          "package": "diagrams-lib",
          "signature": "Path v -\u003e [[FixedSegment v]]",
          "source": "src/Diagrams-Path.html#fixPath",
          "type": "function"
        },
        "index": {
          "description": "Convert path into list of lists of FixedSegment",
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "fixPath",
          "normalized": "Path a-\u003e[[FixedSegment a]]",
          "package": "diagrams-lib",
          "partial": "Path",
          "signature": "Path v-\u003e[[FixedSegment v]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#v:fixPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartition a path into two paths based on a predicate on trails:\n   the first containing all the trails for which the predicate returns\n   \u003ccode\u003eTrue\u003c/code\u003e, and the second containing the remaining trails.\n\u003c/p\u003e",
          "module": "Diagrams.Path",
          "name": "partitionPath",
          "package": "diagrams-lib",
          "signature": "(Located (Trail v) -\u003e Bool) -\u003e Path v -\u003e (Path v, Path v)",
          "source": "src/Diagrams-Path.html#partitionPath",
          "type": "function"
        },
        "index": {
          "description": "Partition path into two paths based on predicate on trails the first containing all the trails for which the predicate returns True and the second containing the remaining trails",
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "partitionPath",
          "normalized": "(Located(Trail a)-\u003eBool)-\u003ePath a-\u003e(Path a,Path a)",
          "package": "diagrams-lib",
          "partial": "Path",
          "signature": "(Located(Trail v)-\u003eBool)-\u003ePath v-\u003e(Path v,Path v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#v:partitionPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the \u003cem\u003ecentroid\u003c/em\u003e of a path (\u003cem\u003ei.e.\u003c/em\u003e the average location of\n   its vertices).\n\u003c/p\u003e",
          "module": "Diagrams.Path",
          "name": "pathCentroid",
          "package": "diagrams-lib",
          "signature": "Path v -\u003e Point v",
          "source": "src/Diagrams-Path.html#pathCentroid",
          "type": "function"
        },
        "index": {
          "description": "Compute the centroid of path i.e the average location of its vertices",
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "pathCentroid",
          "normalized": "Path a-\u003ePoint a",
          "package": "diagrams-lib",
          "partial": "Centroid",
          "signature": "Path v-\u003ePoint v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#v:pathCentroid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a located trail to a singleton path.  This is equivalent\n   to \u003ccode\u003e\u003ca\u003etrailLike\u003c/a\u003e\u003c/code\u003e, but provided with a more specific name and type\n   for convenience.\n\u003c/p\u003e",
          "module": "Diagrams.Path",
          "name": "pathFromLocTrail",
          "package": "diagrams-lib",
          "signature": "Located (Trail v) -\u003e Path v",
          "source": "src/Diagrams-Path.html#pathFromLocTrail",
          "type": "function"
        },
        "index": {
          "description": "Convert located trail to singleton path This is equivalent to trailLike but provided with more specific name and type for convenience",
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "pathFromLocTrail",
          "normalized": "Located(Trail a)-\u003ePath a",
          "package": "diagrams-lib",
          "partial": "From Loc Trail",
          "signature": "Located(Trail v)-\u003ePath v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#v:pathFromLocTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a trail to a path beginning at the origin.\n\u003c/p\u003e",
          "module": "Diagrams.Path",
          "name": "pathFromTrail",
          "package": "diagrams-lib",
          "signature": "Trail v -\u003e Path v",
          "source": "src/Diagrams-Path.html#pathFromTrail",
          "type": "function"
        },
        "index": {
          "description": "Convert trail to path beginning at the origin",
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "pathFromTrail",
          "normalized": "Trail a-\u003ePath a",
          "package": "diagrams-lib",
          "partial": "From Trail",
          "signature": "Trail v-\u003ePath v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#v:pathFromTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a trail to a path with a particular starting point.\n\u003c/p\u003e",
          "module": "Diagrams.Path",
          "name": "pathFromTrailAt",
          "package": "diagrams-lib",
          "signature": "Trail v -\u003e Point v -\u003e Path v",
          "source": "src/Diagrams-Path.html#pathFromTrailAt",
          "type": "function"
        },
        "index": {
          "description": "Convert trail to path with particular starting point",
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "pathFromTrailAt",
          "normalized": "Trail a-\u003ePoint a-\u003ePath a",
          "package": "diagrams-lib",
          "partial": "From Trail At",
          "signature": "Trail v-\u003ePoint v-\u003ePath v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#v:pathFromTrailAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the total offset of each trail comprising a path (see \u003ccode\u003e\u003ca\u003etrailOffset\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Diagrams.Path",
          "name": "pathOffsets",
          "package": "diagrams-lib",
          "signature": "Path v -\u003e [v]",
          "source": "src/Diagrams-Path.html#pathOffsets",
          "type": "function"
        },
        "index": {
          "description": "Compute the total offset of each trail comprising path see trailOffset",
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "pathOffsets",
          "normalized": "Path a-\u003e[a]",
          "package": "diagrams-lib",
          "partial": "Offsets",
          "signature": "Path v-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#v:pathOffsets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the located trails making up a \u003ccode\u003e\u003ca\u003ePath\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Path",
          "name": "pathTrails",
          "package": "diagrams-lib",
          "signature": "Path v -\u003e [Located (Trail v)]",
          "source": "src/Diagrams-Path.html#pathTrails",
          "type": "function"
        },
        "index": {
          "description": "Extract the located trails making up Path",
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "pathTrails",
          "normalized": "Path a-\u003e[Located(Trail a)]",
          "package": "diagrams-lib",
          "partial": "Trails",
          "signature": "Path v-\u003e[Located(Trail v)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#v:pathTrails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the vertices of a path, resulting in a separate list of\n   vertices for each component trail (see \u003ccode\u003e\u003ca\u003etrailVertices\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Diagrams.Path",
          "name": "pathVertices",
          "package": "diagrams-lib",
          "signature": "Path v -\u003e [[Point v]]",
          "source": "src/Diagrams-Path.html#pathVertices",
          "type": "function"
        },
        "index": {
          "description": "Extract the vertices of path resulting in separate list of vertices for each component trail see trailVertices",
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "pathVertices",
          "normalized": "Path a-\u003e[[Point a]]",
          "package": "diagrams-lib",
          "partial": "Vertices",
          "signature": "Path v-\u003e[[Point v]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#v:pathVertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse all the component trails of a path.\n\u003c/p\u003e",
          "module": "Diagrams.Path",
          "name": "reversePath",
          "package": "diagrams-lib",
          "signature": "Path v -\u003e Path v",
          "source": "src/Diagrams-Path.html#reversePath",
          "type": "function"
        },
        "index": {
          "description": "Reverse all the component trails of path",
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "reversePath",
          "normalized": "Path a-\u003ePath a",
          "package": "diagrams-lib",
          "partial": "Path",
          "signature": "Path v-\u003ePath v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#v:reversePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale a path using its centroid (see \u003ccode\u003e\u003ca\u003epathCentroid\u003c/a\u003e\u003c/code\u003e) as the base\n   point for the scale.\n\u003c/p\u003e",
          "module": "Diagrams.Path",
          "name": "scalePath",
          "package": "diagrams-lib",
          "signature": "Scalar v -\u003e Path v -\u003e Path v",
          "source": "src/Diagrams-Path.html#scalePath",
          "type": "function"
        },
        "index": {
          "description": "Scale path using its centroid see pathCentroid as the base point for the scale",
          "hierarchy": "Diagrams Path",
          "module": "Diagrams.Path",
          "name": "scalePath",
          "normalized": "Scalar a-\u003ePath a-\u003ePath a",
          "package": "diagrams-lib",
          "partial": "Path",
          "signature": "Scalar v-\u003ePath v-\u003ePath v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Path.html#v:scalePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePoints in space.  For more tools for working with points and\n vectors, see \u003ca\u003eData.AffineSpace\u003c/a\u003e and \u003ca\u003eDiagrams.Coordinates\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Points",
          "name": "Points",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Points.html",
          "type": "module"
        },
        "index": {
          "description": "Points in space For more tools for working with points and vectors see Data.AffineSpace and Diagrams.Coordinates",
          "hierarchy": "Diagrams Points",
          "module": "Diagrams.Points",
          "name": "Points",
          "package": "diagrams-lib",
          "partial": "Points",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Points.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ePoint\u003c/code\u003e is a newtype wrapper around vectors used to represent\n   points, so we don't get them mixed up. The distinction between\n   vectors and points is important: translations affect points, but\n   leave vectors unchanged.  Points are instances of the\n   \u003ccode\u003e\u003ca\u003eAffineSpace\u003c/a\u003e\u003c/code\u003e class from \u003ca\u003eData.AffineSpace\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Points",
          "name": "Point",
          "package": "diagrams-lib",
          "type": "data"
        },
        "index": {
          "description": "Point is newtype wrapper around vectors used to represent points so we don get them mixed up The distinction between vectors and points is important translations affect points but leave vectors unchanged Points are instances of the AffineSpace class from Data.AffineSpace",
          "hierarchy": "Diagrams Points",
          "module": "Diagrams.Points",
          "name": "Point",
          "package": "diagrams-lib",
          "partial": "Point",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Points.html#t:Point"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale a point by a scalar.\n\u003c/p\u003e",
          "module": "Diagrams.Points",
          "name": "(*.)",
          "package": "diagrams-lib",
          "signature": "Scalar v -\u003e Point v -\u003e Point v",
          "type": "function"
        },
        "index": {
          "description": "Scale point by scalar",
          "hierarchy": "Diagrams Points",
          "module": "Diagrams.Points",
          "name": "(*.) *.",
          "normalized": "Scalar a-\u003ePoint a-\u003ePoint a",
          "package": "diagrams-lib",
          "signature": "Scalar v-\u003ePoint v-\u003ePoint v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Points.html#v:-42-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe centroid of a set of \u003cem\u003en\u003c/em\u003e points is their sum divided by \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Points",
          "name": "centroid",
          "package": "diagrams-lib",
          "signature": "[Point v] -\u003e Point v",
          "source": "src/Diagrams-Points.html#centroid",
          "type": "function"
        },
        "index": {
          "description": "The centroid of set of points is their sum divided by",
          "hierarchy": "Diagrams Points",
          "module": "Diagrams.Points",
          "name": "centroid",
          "normalized": "[Point a]-\u003ePoint a",
          "package": "diagrams-lib",
          "signature": "[Point v]-\u003ePoint v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Points.html#v:centroid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe origin of the vector space \u003ccode\u003ev\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Points",
          "name": "origin",
          "package": "diagrams-lib",
          "signature": "Point v",
          "type": "function"
        },
        "index": {
          "description": "The origin of the vector space",
          "hierarchy": "Diagrams Points",
          "module": "Diagrams.Points",
          "name": "origin",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Points.html#v:origin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a \"point diagram\", which has no content, no trace, an\n   empty query, and a point envelope.\n\u003c/p\u003e",
          "module": "Diagrams.Points",
          "name": "pointDiagram",
          "package": "diagrams-lib",
          "signature": "Point v -\u003e QDiagram b v m",
          "type": "function"
        },
        "index": {
          "description": "Create point diagram which has no content no trace an empty query and point envelope",
          "hierarchy": "Diagrams Points",
          "module": "Diagrams.Points",
          "name": "pointDiagram",
          "normalized": "Point a-\u003eQDiagram b a c",
          "package": "diagrams-lib",
          "partial": "Diagram",
          "signature": "Point v-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Points.html#v:pointDiagram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module to re-export most of the functionality of the diagrams\n core and standard library.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Prelude",
          "name": "Prelude",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Prelude.html",
          "type": "module"
        },
        "index": {
          "description": "module to re-export most of the functionality of the diagrams core and standard library",
          "hierarchy": "Diagrams Prelude",
          "module": "Diagrams.Prelude",
          "name": "Prelude",
          "package": "diagrams-lib",
          "partial": "Prelude",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA functor with application, providing operations to\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e embed pure expressions (\u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e), and\n\u003c/li\u003e\u003cli\u003e sequence computations and combine their results (\u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eA minimal complete definition must include implementations of these\n functions satisfying the following laws:\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003cem\u003eidentity\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e v = v\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003ecomposition\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e (.) \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e u \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e v \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e w = u \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e (v \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e w)\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003ehomomorphism\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e x = \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e (f x)\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003einterchange\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003eu \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e y = \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e y) \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e u\u003c/code\u003e\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eThe other methods have the following default definitions, which may\n be overridden with equivalent specialized implementations:\n\u003c/p\u003e\u003cpre\u003e\n      u \u003ccode\u003e\u003ca\u003e*\u003e\u003c/a\u003e\u003c/code\u003e v = \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e) \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e u \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e v\n      u \u003ccode\u003e\u003ca\u003e\u003c*\u003c/a\u003e\u003c/code\u003e v = \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e u \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e v\n\u003c/pre\u003e\u003cp\u003eAs a consequence of these laws, the \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e instance for \u003ccode\u003ef\u003c/code\u003e will satisfy\n\u003c/p\u003e\u003cpre\u003e\n      \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e f x = \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e x\n\u003c/pre\u003e\u003cp\u003eIf \u003ccode\u003ef\u003c/code\u003e is also a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e, it should satisfy \u003ccode\u003e\u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and\n \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e) = \u003ccode\u003e\u003ca\u003eap\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e (which implies that \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e satisfy the\n applicative functor laws).\n\u003c/p\u003e",
          "module": "Diagrams.Prelude",
          "name": "Applicative",
          "package": "diagrams-lib",
          "type": "class"
        },
        "index": {
          "description": "functor with application providing operations to embed pure expressions pure and sequence computations and combine their results minimal complete definition must include implementations of these functions satisfying the following laws identity pure id composition pure homomorphism pure pure pure interchange pure pure The other methods have the following default definitions which may be overridden with equivalent specialized implementations pure const id pure const As consequence of these laws the Functor instance for will satisfy fmap pure If is also Monad it should satisfy pure return and ap which implies that pure and satisfy the applicative functor laws",
          "hierarchy": "Diagrams Prelude",
          "module": "Diagrams.Prelude",
          "name": "Applicative",
          "package": "diagrams-lib",
          "partial": "Applicative",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#t:Applicative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModifies the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or all of the targets of a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e with a user supplied function.\n\u003c/p\u003e\u003cp\u003eThis is an infix version of \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e f &#8801; \u003ccode\u003e\u003ca\u003emapped\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e f\n \u003ccode\u003e\u003ca\u003efmapDefault\u003c/a\u003e\u003c/code\u003e f &#8801; \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e f\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b,c) & _3 %~ f\n\u003c/code\u003e\u003c/strong\u003e(a,b,f c)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & both %~ f\n\u003c/code\u003e\u003c/strong\u003e(f a,f b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_2 %~ length $ (1,\"hello\")\n\u003c/code\u003e\u003c/strong\u003e(1,5)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etraverse %~ f $ [a,b,c]\n\u003c/code\u003e\u003c/strong\u003e[f a,f b,f c]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etraverse %~ even $ [1,2,3]\n\u003c/code\u003e\u003c/strong\u003e[False,True,False]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etraverse.traverse %~ length $ [[\"hello\",\"world\"],[\"!!!\"]]\n\u003c/code\u003e\u003c/strong\u003e[[5,5],[3]]\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a b    -\u003e (a -\u003e b) -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e (a -\u003e b) -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e (a -\u003e b) -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e (a -\u003e b) -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "Diagrams.Prelude",
          "name": "(%~)",
          "package": "diagrams-lib",
          "signature": "Setting p s t a b -\u003e p a b -\u003e s -\u003e t",
          "type": "function"
        },
        "index": {
          "description": "Modifies the target of Lens or all of the targets of Setter or Traversal with user supplied function This is an infix version of over fmap mapped fmapDefault traverse both length hello traverse traverse even False True False traverse.traverse length hello world Setter Iso Lens Traversal",
          "hierarchy": "Diagrams Prelude",
          "module": "Diagrams.Prelude",
          "name": "(%~) %~",
          "normalized": "Setting a b c d e-\u003ea d e-\u003eb-\u003ec",
          "package": "diagrams-lib",
          "signature": "Setting p s t a b-\u003ep a b-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#v:-37--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePasses the result of the left side to the function on the right side (forward pipe operator).\n\u003c/p\u003e\u003cp\u003eThis is the flipped version of (\u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e), which is more common in languages like F# as (\u003ccode\u003e|\u003e\u003c/code\u003e) where it is needed\n for inference. Here it is supplied for notational convenience and given a precedence that allows it\n to be nested inside uses of (\u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ea & f\n\u003c/code\u003e\u003c/strong\u003ef a\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\" & length & succ\n\u003c/code\u003e\u003c/strong\u003e6\n\u003c/pre\u003e\u003cp\u003eThis combinator is commonly used when applying multiple \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e operations in sequence.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"world\") & _1.element 0 .~ 'j' & _1.element 4 .~ 'y'\n\u003c/code\u003e\u003c/strong\u003e(\"jelly\",\"world\")\n\u003c/pre\u003e\u003cp\u003eThis reads somewhat similar to:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eflip execState (\"hello\",\"world\") $ do _1.element 0 .= 'j'; _1.element 4 .= 'y'\n\u003c/code\u003e\u003c/strong\u003e(\"jelly\",\"world\")\n\u003c/pre\u003e",
          "module": "Diagrams.Prelude",
          "name": "(&)",
          "package": "diagrams-lib",
          "signature": "a -\u003e (a -\u003e b) -\u003e b",
          "type": "function"
        },
        "index": {
          "description": "Passes the result of the left side to the function on the right side forward pipe operator This is the flipped version of which is more common in languages like as where it is needed for inference Here it is supplied for notational convenience and given precedence that allows it to be nested inside uses of hello length succ This combinator is commonly used when applying multiple Lens operations in sequence hello world element element jelly world This reads somewhat similar to flip execState hello world do element element jelly world",
          "hierarchy": "Diagrams Prelude",
          "module": "Diagrams.Prelude",
          "name": "(&) &",
          "normalized": "a-\u003e(a-\u003eb)-\u003eb",
          "package": "diagrams-lib",
          "signature": "a-\u003e(a-\u003eb)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#v:-38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequence actions, discarding the value of the first argument.\n\u003c/p\u003e",
          "module": "Diagrams.Prelude",
          "name": "(*\u003e)",
          "package": "diagrams-lib",
          "signature": "forall a b.  f a -\u003e f b -\u003e f b",
          "type": "function"
        },
        "index": {
          "description": "Sequence actions discarding the value of the first argument",
          "hierarchy": "Diagrams Prelude",
          "module": "Diagrams.Prelude",
          "name": "(*\u003e) *\u003e",
          "normalized": "a b c d b-\u003ed e-\u003ed e",
          "package": "diagrams-lib",
          "signature": "forall a b. f a-\u003ef b-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#v:-42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace all locations in the input with the same value.\n The default definition is \u003ccode\u003e\u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, but this may be\n overridden with a more efficient version.\n\u003c/p\u003e",
          "module": "Diagrams.Prelude",
          "name": "(\u003c$)",
          "package": "diagrams-lib",
          "signature": "forall a b.  a -\u003e f b -\u003e f a",
          "type": "function"
        },
        "index": {
          "description": "Replace all locations in the input with the same value The default definition is fmap const but this may be overridden with more efficient version",
          "hierarchy": "Diagrams Prelude",
          "module": "Diagrams.Prelude",
          "name": "(\u003c$) \u003c$",
          "normalized": "a b c b-\u003ed e-\u003ed b",
          "package": "diagrams-lib",
          "signature": "forall a b. a-\u003ef b-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#v:-60--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn infix synonym for \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Prelude",
          "name": "(\u003c$\u003e)",
          "package": "diagrams-lib",
          "signature": "(a -\u003e b) -\u003e f a -\u003e f b",
          "type": "function"
        },
        "index": {
          "description": "An infix synonym for fmap",
          "hierarchy": "Diagrams Prelude",
          "module": "Diagrams.Prelude",
          "name": "(\u003c$\u003e) \u003c$\u003e",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "diagrams-lib",
          "signature": "(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#v:-60--36--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequence actions, discarding the value of the second argument.\n\u003c/p\u003e",
          "module": "Diagrams.Prelude",
          "name": "(\u003c*)",
          "package": "diagrams-lib",
          "signature": "forall a b.  f a -\u003e f b -\u003e f a",
          "type": "function"
        },
        "index": {
          "description": "Sequence actions discarding the value of the second argument",
          "hierarchy": "Diagrams Prelude",
          "module": "Diagrams.Prelude",
          "name": "(\u003c*) \u003c*",
          "normalized": "a b c d b-\u003ed e-\u003ed b",
          "package": "diagrams-lib",
          "signature": "forall a b. f a-\u003ef b-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#v:-60--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequential application.\n\u003c/p\u003e",
          "module": "Diagrams.Prelude",
          "name": "(\u003c*\u003e)",
          "package": "diagrams-lib",
          "signature": "f (a -\u003e b) -\u003e f a -\u003e f b",
          "type": "method"
        },
        "index": {
          "description": "Sequential application",
          "hierarchy": "Diagrams Prelude",
          "module": "Diagrams.Prelude",
          "name": "(\u003c*\u003e) \u003c*\u003e",
          "normalized": "a(b-\u003ec)-\u003ea b-\u003ea c",
          "package": "diagrams-lib",
          "signature": "f(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#v:-60--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or all of the targets of a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e\n or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e with a constant value.\n\u003c/p\u003e\u003cp\u003eThis is an infix version of \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e, provided for consistency with (\u003ccode\u003e\u003ca\u003e.=\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e\n f \u003ccode\u003e\u003ca\u003e\u003c$\u003c/a\u003e\u003c/code\u003e a &#8801; \u003ccode\u003e\u003ca\u003emapped\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b,c,d) & _4 .~ e\n\u003c/code\u003e\u003c/strong\u003e(a,b,c,e)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(42,\"world\") & _1 .~ \"hello\"\n\u003c/code\u003e\u003c/strong\u003e(\"hello\",\"world\")\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & both .~ c\n\u003c/code\u003e\u003c/strong\u003e(c,c)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a b    -\u003e b -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e b -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e b -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e b -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "Diagrams.Prelude",
          "name": "(.~)",
          "package": "diagrams-lib",
          "signature": "ASetter s t a b -\u003e b -\u003e s -\u003e t",
          "type": "function"
        },
        "index": {
          "description": "Replace the target of Lens or all of the targets of Setter or Traversal with constant value This is an infix version of set provided for consistency with mapped world hello hello world both Setter Iso Lens Traversal",
          "hierarchy": "Diagrams Prelude",
          "module": "Diagrams.Prelude",
          "name": "(.~) .~",
          "normalized": "ASetter a b c d-\u003ed-\u003ea-\u003eb",
          "package": "diagrams-lib",
          "signature": "ASetter s t a b-\u003eb-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#v:.-126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a function to actions.\n This function may be used as a value for \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e in a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "Diagrams.Prelude",
          "name": "liftA",
          "package": "diagrams-lib",
          "signature": "(a -\u003e b) -\u003e f a -\u003e f b",
          "type": "function"
        },
        "index": {
          "description": "Lift function to actions This function may be used as value for fmap in Functor instance",
          "hierarchy": "Diagrams Prelude",
          "module": "Diagrams.Prelude",
          "name": "liftA",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "diagrams-lib",
          "signature": "(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#v:liftA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a binary function to actions.\n\u003c/p\u003e",
          "module": "Diagrams.Prelude",
          "name": "liftA2",
          "package": "diagrams-lib",
          "signature": "(a -\u003e b -\u003e c) -\u003e f a -\u003e f b -\u003e f c",
          "type": "function"
        },
        "index": {
          "description": "Lift binary function to actions",
          "hierarchy": "Diagrams Prelude",
          "module": "Diagrams.Prelude",
          "name": "liftA2",
          "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
          "package": "diagrams-lib",
          "signature": "(a-\u003eb-\u003ec)-\u003ef a-\u003ef b-\u003ef c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#v:liftA2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a ternary function to actions.\n\u003c/p\u003e",
          "module": "Diagrams.Prelude",
          "name": "liftA3",
          "package": "diagrams-lib",
          "signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e f a -\u003e f b -\u003e f c -\u003e f d",
          "type": "function"
        },
        "index": {
          "description": "Lift ternary function to actions",
          "hierarchy": "Diagrams Prelude",
          "module": "Diagrams.Prelude",
          "name": "liftA3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003ee a-\u003ee b-\u003ee c-\u003ee d",
          "package": "diagrams-lib",
          "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003ef a-\u003ef b-\u003ef c-\u003ef d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#v:liftA3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a value.\n\u003c/p\u003e",
          "module": "Diagrams.Prelude",
          "name": "pure",
          "package": "diagrams-lib",
          "signature": "a -\u003e f a",
          "type": "method"
        },
        "index": {
          "description": "Lift value",
          "hierarchy": "Diagrams Prelude",
          "module": "Diagrams.Prelude",
          "name": "pure",
          "normalized": "a-\u003eb a",
          "package": "diagrams-lib",
          "signature": "a-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#v:pure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA query is a function that maps points in a vector space to values\n in some monoid. Queries naturally form a monoid, with two queries\n being combined pointwise.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Query",
          "name": "Query",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Query.html",
          "type": "module"
        },
        "index": {
          "description": "query is function that maps points in vector space to values in some monoid Queries naturally form monoid with two queries being combined pointwise",
          "hierarchy": "Diagrams Query",
          "module": "Diagrams.Query",
          "name": "Query",
          "package": "diagrams-lib",
          "partial": "Query",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Query.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA query is a function that maps points in a vector space to\n   values in some monoid. Queries naturally form a monoid, with\n   two queries being combined pointwise.\n\u003c/p\u003e\u003cp\u003eThe idea for annotating diagrams with monoidal queries came from\n   the graphics-drawingcombinators package, \u003ca\u003ehttp://hackage.haskell.org/package/graphics-drawingcombinators\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Query",
          "name": "Query",
          "package": "diagrams-lib",
          "type": "newtype"
        },
        "index": {
          "description": "query is function that maps points in vector space to values in some monoid Queries naturally form monoid with two queries being combined pointwise The idea for annotating diagrams with monoidal queries came from the graphics-drawingcombinators package http hackage.haskell.org package graphics-drawingcombinators",
          "hierarchy": "Diagrams Query",
          "module": "Diagrams.Query",
          "name": "Query",
          "package": "diagrams-lib",
          "partial": "Query",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Query.html#t:Query"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Query",
          "name": "Query",
          "package": "diagrams-lib",
          "signature": "Query",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Query",
          "module": "Diagrams.Query",
          "name": "Query",
          "package": "diagrams-lib",
          "partial": "Query",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Query.html#v:Query"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet all the query values of a diagram to \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Query",
          "name": "clearValue",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m -\u003e QDiagram b v Any",
          "type": "function"
        },
        "index": {
          "description": "Set all the query values of diagram to False",
          "hierarchy": "Diagrams Query",
          "module": "Diagrams.Query",
          "name": "clearValue",
          "normalized": "QDiagram a b c-\u003eQDiagram a b Any",
          "package": "diagrams-lib",
          "partial": "Value",
          "signature": "QDiagram b v m-\u003eQDiagram b v Any",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Query.html#v:clearValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the query function associated with a diagram.\n\u003c/p\u003e",
          "module": "Diagrams.Query",
          "name": "query",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m -\u003e Query v m",
          "type": "function"
        },
        "index": {
          "description": "Get the query function associated with diagram",
          "hierarchy": "Diagrams Query",
          "module": "Diagrams.Query",
          "name": "query",
          "normalized": "QDiagram a b c-\u003eQuery b c",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m-\u003eQuery v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Query.html#v:query"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReset the query values of a diagram to \u003ccode\u003eTrue\u003c/code\u003e/\u003ccode\u003eFalse\u003c/code\u003e: any values\n   equal to \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e are set to \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e; any other values are set to\n   \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Query",
          "name": "resetValue",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m -\u003e QDiagram b v Any",
          "type": "function"
        },
        "index": {
          "description": "Reset the query values of diagram to True False any values equal to mempty are set to False any other values are set to True",
          "hierarchy": "Diagrams Query",
          "module": "Diagrams.Query",
          "name": "resetValue",
          "normalized": "QDiagram a b c-\u003eQDiagram a b Any",
          "package": "diagrams-lib",
          "partial": "Value",
          "signature": "QDiagram b v m-\u003eQDiagram b v Any",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Query.html#v:resetValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Query",
          "name": "runQuery",
          "package": "diagrams-lib",
          "signature": "Point v -\u003e m",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Query",
          "module": "Diagrams.Query",
          "name": "runQuery",
          "normalized": "Point a-\u003eb",
          "package": "diagrams-lib",
          "partial": "Query",
          "signature": "Point v-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Query.html#v:runQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSample a diagram's query function at a given point.\n\u003c/p\u003e",
          "module": "Diagrams.Query",
          "name": "sample",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m -\u003e Point v -\u003e m",
          "type": "function"
        },
        "index": {
          "description": "Sample diagram query function at given point",
          "hierarchy": "Diagrams Query",
          "module": "Diagrams.Query",
          "name": "sample",
          "normalized": "QDiagram a b c-\u003ePoint b-\u003ec",
          "package": "diagrams-lib",
          "signature": "QDiagram b v m-\u003ePoint v-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Query.html#v:sample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the query value for \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e points in a diagram (\u003cem\u003ei.e.\u003c/em\u003e points\n   \"inside\" the diagram); \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e points will be set to \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Query",
          "name": "value",
          "package": "diagrams-lib",
          "signature": "m -\u003e QDiagram b v Any -\u003e QDiagram b v m",
          "type": "function"
        },
        "index": {
          "description": "Set the query value for True points in diagram i.e points inside the diagram False points will be set to mempty",
          "hierarchy": "Diagrams Query",
          "module": "Diagrams.Query",
          "name": "value",
          "normalized": "a-\u003eQDiagram b c Any-\u003eQDiagram b c a",
          "package": "diagrams-lib",
          "signature": "m-\u003eQDiagram b v Any-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Query.html#v:value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA \u003cem\u003esegment\u003c/em\u003e is a translation-invariant, atomic path.  Currently,\n there are two types: linear (\u003cem\u003ei.e.\u003c/em\u003e just a straight line to the\n endpoint) and cubic B&#233;zier curves (\u003cem\u003ei.e.\u003c/em\u003e a curve to an endpoint\n with two control points).  This module contains tools for creating\n and manipulating segments, as well as a definition of segments with\n a fixed location (useful for backend implementors).\n\u003c/p\u003e\u003cp\u003eGenerally speaking, casual users of diagrams should not need this\n module; the higher-level functionality provided by\n \u003ca\u003eDiagrams.Trail\u003c/a\u003e, \u003ca\u003eDiagrams.TrailLike\u003c/a\u003e, and \u003ca\u003eDiagrams.Path\u003c/a\u003e should\n usually suffice.  However, directly manipulating segments can\n occasionally be useful.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Segment",
          "name": "Segment",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Segment.html",
          "type": "module"
        },
        "index": {
          "description": "segment is translation-invariant atomic path Currently there are two types linear i.e just straight line to the endpoint and cubic zier curves i.e curve to an endpoint with two control points This module contains tools for creating and manipulating segments as well as definition of segments with fixed location useful for backend implementors Generally speaking casual users of diagrams should not need this module the higher-level functionality provided by Diagrams.Trail Diagrams.TrailLike and Diagrams.Path should usually suffice However directly manipulating segments can occasionally be useful",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "Segment",
          "package": "diagrams-lib",
          "partial": "Segment",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type to represent the total arc length of a chain of\n   segments. The first component is a \"standard\" arc length,\n   computed to within a tolerance of \u003ccode\u003e10e-6\u003c/code\u003e.  The second component is\n   a generic arc length function taking the tolerance as an\n   argument.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "ArcLength",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Segment.html#ArcLength",
          "type": "newtype"
        },
        "index": {
          "description": "type to represent the total arc length of chain of segments The first component is standard arc length computed to within tolerance of e-6 The second component is generic arc length function taking the tolerance as an argument",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "ArcLength",
          "package": "diagrams-lib",
          "partial": "Arc Length",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#t:ArcLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType tag for closed segments.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "Closed",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Segment.html#Closed",
          "type": "data"
        },
        "index": {
          "description": "Type tag for closed segments",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "Closed",
          "package": "diagrams-lib",
          "partial": "Closed",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#t:Closed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eFixedSegment\u003c/code\u003es are like \u003ccode\u003e\u003ca\u003eSegment\u003c/a\u003e\u003c/code\u003es except that they have\n   absolute locations.  \u003ccode\u003eFixedSegment v\u003c/code\u003e is isomorphic to \u003ccode\u003eLocated\n   (Segment Closed v)\u003c/code\u003e, as witnessed by \u003ccode\u003e\u003ca\u003emkFixedSeg\u003c/a\u003e\u003c/code\u003e and\n   \u003ccode\u003e\u003ca\u003efromFixedSeg\u003c/a\u003e\u003c/code\u003e, but \u003ccode\u003eFixedSegment\u003c/code\u003e is convenient when one needs\n   the absolute locations of the vertices and control points.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "FixedSegment",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Segment.html#FixedSegment",
          "type": "data"
        },
        "index": {
          "description": "FixedSegment are like Segment except that they have absolute locations FixedSegment is isomorphic to Located Segment Closed as witnessed by mkFixedSeg and fromFixedSeg but FixedSegment is convenient when one needs the absolute locations of the vertices and control points",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "FixedSegment",
          "package": "diagrams-lib",
          "partial": "Fixed Segment",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#t:FixedSegment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003eoffset\u003c/em\u003e of a segment is the vector from its starting point\n   to its end.  The offset for an \u003cem\u003eopen\u003c/em\u003e segment is determined by\n   the context, \u003cem\u003ei.e.\u003c/em\u003e its endpoint is not fixed.  The offset for a\n   \u003cem\u003eclosed\u003c/em\u003e segment is stored explicitly, \u003cem\u003ei.e.\u003c/em\u003e its endpoint is at\n   a fixed offset from its start.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "Offset",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Segment.html#Offset",
          "type": "data"
        },
        "index": {
          "description": "The offset of segment is the vector from its starting point to its end The offset for an open segment is determined by the context i.e its endpoint is not fixed The offset for closed segment is stored explicitly i.e its endpoint is at fixed offset from its start",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "Offset",
          "package": "diagrams-lib",
          "partial": "Offset",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#t:Offset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type to represent the offset and envelope of a chain of\n   segments.  They have to be paired into one data structure, since\n   combining the envelopes of two consecutive chains needs to take\n   the offset of the the offset of the first into account.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "OffsetEnvelope",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Segment.html#OffsetEnvelope",
          "type": "data"
        },
        "index": {
          "description": "type to represent the offset and envelope of chain of segments They have to be paired into one data structure since combining the envelopes of two consecutive chains needs to take the offset of the the offset of the first into account",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "OffsetEnvelope",
          "package": "diagrams-lib",
          "partial": "Offset Envelope",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#t:OffsetEnvelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType tag for open segments.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "Open",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Segment.html#Open",
          "type": "data"
        },
        "index": {
          "description": "Type tag for open segments",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "Open",
          "package": "diagrams-lib",
          "partial": "Open",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#t:Open"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type to track the count of segments in a \u003ccode\u003eTrail\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "SegCount",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Segment.html#SegCount",
          "type": "newtype"
        },
        "index": {
          "description": "type to track the count of segments in Trail",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "SegCount",
          "package": "diagrams-lib",
          "partial": "Seg Count",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#t:SegCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eSegMeasure\u003c/code\u003e collects up all the measurements over a chain of\n   segments.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "SegMeasure",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Segment.html#SegMeasure",
          "type": "type"
        },
        "index": {
          "description": "SegMeasure collects up all the measurements over chain of segments",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "SegMeasure",
          "package": "diagrams-lib",
          "partial": "Seg Measure",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#t:SegMeasure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe atomic constituents of the concrete representation currently\n   used for trails are \u003cem\u003esegments\u003c/em\u003e, currently limited to\n   single straight lines or cubic B&#233;zier curves.  Segments are\n   \u003cem\u003etranslationally invariant\u003c/em\u003e, that is, they have no particular\n   \"location\" and are unaffected by translations.  They are,\n   however, affected by other transformations such as rotations and\n   scales.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "Segment",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Segment.html#Segment",
          "type": "data"
        },
        "index": {
          "description": "The atomic constituents of the concrete representation currently used for trails are segments currently limited to single straight lines or cubic zier curves Segments are translationally invariant that is they have no particular location and are unaffected by translations They are however affected by other transformations such as rotations and scales",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "Segment",
          "package": "diagrams-lib",
          "partial": "Segment",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#t:Segment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type to represent the total cumulative offset of a chain of\n   segments.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "TotalOffset",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Segment.html#TotalOffset",
          "type": "newtype"
        },
        "index": {
          "description": "type to represent the total cumulative offset of chain of segments",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "TotalOffset",
          "package": "diagrams-lib",
          "partial": "Total Offset",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#t:TotalOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Segment",
          "name": "ArcLength",
          "package": "diagrams-lib",
          "signature": "ArcLength (Sum (Interval (Scalar v)), Scalar v -\u003e Sum (Interval (Scalar v)))",
          "source": "src/Diagrams-Segment.html#ArcLength",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "ArcLength",
          "normalized": "ArcLength(Sum(Interval(Scalar a)),Scalar a-\u003eSum(Interval(Scalar a)))",
          "package": "diagrams-lib",
          "partial": "Arc Length",
          "signature": "ArcLength(Sum(Interval(Scalar v)),Scalar v-\u003eSum(Interval(Scalar v)))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:ArcLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA cubic B&#233;zier segment specified by\n   three offsets from the starting\n   point to the first control point,\n   second control point, and ending\n   point, respectively.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "Cubic",
          "package": "diagrams-lib",
          "signature": "Cubic !v !v !(Offset c v)",
          "source": "src/Diagrams-Segment.html#Segment",
          "type": "function"
        },
        "index": {
          "description": "cubic zier segment specified by three offsets from the starting point to the first control point second control point and ending point respectively",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "Cubic",
          "package": "diagrams-lib",
          "partial": "Cubic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:Cubic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Segment",
          "name": "FCubic",
          "package": "diagrams-lib",
          "signature": "FCubic (Point v) (Point v) (Point v) (Point v)",
          "source": "src/Diagrams-Segment.html#FixedSegment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "FCubic",
          "package": "diagrams-lib",
          "partial": "FCubic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:FCubic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Segment",
          "name": "FLinear",
          "package": "diagrams-lib",
          "signature": "FLinear (Point v) (Point v)",
          "source": "src/Diagrams-Segment.html#FixedSegment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "FLinear",
          "package": "diagrams-lib",
          "partial": "FLinear",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:FLinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA linear segment with given offset.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "Linear",
          "package": "diagrams-lib",
          "signature": "Linear !(Offset c v)",
          "source": "src/Diagrams-Segment.html#Segment",
          "type": "function"
        },
        "index": {
          "description": "linear segment with given offset",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "Linear",
          "package": "diagrams-lib",
          "partial": "Linear",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:Linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Segment",
          "name": "OffsetClosed",
          "package": "diagrams-lib",
          "signature": "v -\u003e Offset Closed v",
          "source": "src/Diagrams-Segment.html#Offset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "OffsetClosed",
          "normalized": "a-\u003eOffset Closed a",
          "package": "diagrams-lib",
          "partial": "Offset Closed",
          "signature": "v-\u003eOffset Closed v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:OffsetClosed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Segment",
          "name": "OffsetEnvelope",
          "package": "diagrams-lib",
          "signature": "OffsetEnvelope",
          "source": "src/Diagrams-Segment.html#OffsetEnvelope",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "OffsetEnvelope",
          "package": "diagrams-lib",
          "partial": "Offset Envelope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:OffsetEnvelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Segment",
          "name": "OffsetOpen",
          "package": "diagrams-lib",
          "signature": "Offset Open v",
          "source": "src/Diagrams-Segment.html#Offset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "OffsetOpen",
          "package": "diagrams-lib",
          "partial": "Offset Open",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:OffsetOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Segment",
          "name": "SegCount",
          "package": "diagrams-lib",
          "signature": "SegCount (Sum Int)",
          "source": "src/Diagrams-Segment.html#SegCount",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "SegCount",
          "package": "diagrams-lib",
          "partial": "Seg Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:SegCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Segment",
          "name": "TotalOffset",
          "package": "diagrams-lib",
          "signature": "TotalOffset v",
          "source": "src/Diagrams-Segment.html#TotalOffset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "TotalOffset",
          "package": "diagrams-lib",
          "partial": "Total Offset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:TotalOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Segment",
          "name": "_oeEnvelope",
          "package": "diagrams-lib",
          "signature": "Envelope v",
          "source": "src/Diagrams-Segment.html#OffsetEnvelope",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "_oeEnvelope",
          "package": "diagrams-lib",
          "partial": "Envelope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:_oeEnvelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Segment",
          "name": "_oeOffset",
          "package": "diagrams-lib",
          "signature": "(TotalOffset v)",
          "source": "src/Diagrams-Segment.html#OffsetEnvelope",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "_oeOffset",
          "package": "diagrams-lib",
          "partial": "Offset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:_oeOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eb&#233;zier3\u003c/code\u003e is the same as \u003ccode\u003ebezier3\u003c/code\u003e, but with more snobbery.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "bzier3",
          "package": "diagrams-lib",
          "signature": "v -\u003e v -\u003e v -\u003e Segment Closed v",
          "source": "src/Diagrams-Segment.html#b%E9zier3",
          "type": "function"
        },
        "index": {
          "description": "zier3 is the same as bezier3 but with more snobbery",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "bzier3",
          "normalized": "a-\u003ea-\u003ea-\u003eSegment Closed a",
          "package": "diagrams-lib",
          "signature": "v-\u003ev-\u003ev-\u003eSegment Closed v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:b-233-zier3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ebezier3 c1 c2 x\u003c/code\u003e constructs a translationally invariant cubic\n   B&#233;zier curve where the offsets from the first endpoint to the\n   first and second control point and endpoint are respectively\n   given by \u003ccode\u003ec1\u003c/code\u003e, \u003ccode\u003ec2\u003c/code\u003e, and \u003ccode\u003ex\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "bezier3",
          "package": "diagrams-lib",
          "signature": "v -\u003e v -\u003e v -\u003e Segment Closed v",
          "source": "src/Diagrams-Segment.html#bezier3",
          "type": "function"
        },
        "index": {
          "description": "bezier3 c1 c2 constructs translationally invariant cubic zier curve where the offsets from the first endpoint to the first and second control point and endpoint are respectively given by c1 c2 and",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "bezier3",
          "normalized": "a-\u003ea-\u003ea-\u003eSegment Closed a",
          "package": "diagrams-lib",
          "signature": "v-\u003ev-\u003ev-\u003eSegment Closed v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:bezier3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eFixedSegment\u003c/a\u003e\u003c/code\u003e back into a located \u003ccode\u003e\u003ca\u003eSegment\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "fromFixedSeg",
          "package": "diagrams-lib",
          "signature": "FixedSegment v -\u003e Located (Segment Closed v)",
          "source": "src/Diagrams-Segment.html#fromFixedSeg",
          "type": "function"
        },
        "index": {
          "description": "Convert FixedSegment back into located Segment",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "fromFixedSeg",
          "normalized": "FixedSegment a-\u003eLocated(Segment Closed a)",
          "package": "diagrams-lib",
          "partial": "Fixed Seg",
          "signature": "FixedSegment v-\u003eLocated(Segment Closed v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:fromFixedSeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a specified tolerance, project out the cached arc length if\n   it is accurate enough; otherwise call the generic arc length\n   function with the given tolerance.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "getArcLengthBounded",
          "package": "diagrams-lib",
          "signature": "Scalar v -\u003e ArcLength v -\u003e Interval (Scalar v)",
          "source": "src/Diagrams-Segment.html#getArcLengthBounded",
          "type": "function"
        },
        "index": {
          "description": "Given specified tolerance project out the cached arc length if it is accurate enough otherwise call the generic arc length function with the given tolerance",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "getArcLengthBounded",
          "normalized": "Scalar a-\u003eArcLength a-\u003eInterval(Scalar a)",
          "package": "diagrams-lib",
          "partial": "Arc Length Bounded",
          "signature": "Scalar v-\u003eArcLength v-\u003eInterval(Scalar v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:getArcLengthBounded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject out the cached arc length, stored together with error\n   bounds.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "getArcLengthCached",
          "package": "diagrams-lib",
          "signature": "ArcLength v -\u003e Interval (Scalar v)",
          "source": "src/Diagrams-Segment.html#getArcLengthCached",
          "type": "function"
        },
        "index": {
          "description": "Project out the cached arc length stored together with error bounds",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "getArcLengthCached",
          "normalized": "ArcLength a-\u003eInterval(Scalar a)",
          "package": "diagrams-lib",
          "partial": "Arc Length Cached",
          "signature": "ArcLength v-\u003eInterval(Scalar v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:getArcLengthCached"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject out the generic arc length function taking the tolerance as\n   an argument.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "getArcLengthFun",
          "package": "diagrams-lib",
          "signature": "ArcLength v -\u003e Scalar v -\u003e Interval (Scalar v)",
          "source": "src/Diagrams-Segment.html#getArcLengthFun",
          "type": "function"
        },
        "index": {
          "description": "Project out the generic arc length function taking the tolerance as an argument",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "getArcLengthFun",
          "normalized": "ArcLength a-\u003eScalar a-\u003eInterval(Scalar a)",
          "package": "diagrams-lib",
          "partial": "Arc Length Fun",
          "signature": "ArcLength v-\u003eScalar v-\u003eInterval(Scalar v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:getArcLengthFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a \u003ccode\u003e\u003ca\u003eFixedSegment\u003c/a\u003e\u003c/code\u003e from a located \u003ccode\u003e\u003ca\u003eSegment\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "mkFixedSeg",
          "package": "diagrams-lib",
          "signature": "Located (Segment Closed v) -\u003e FixedSegment v",
          "source": "src/Diagrams-Segment.html#mkFixedSeg",
          "type": "function"
        },
        "index": {
          "description": "Create FixedSegment from located Segment",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "mkFixedSeg",
          "normalized": "Located(Segment Closed a)-\u003eFixedSegment a",
          "package": "diagrams-lib",
          "partial": "Fixed Seg",
          "signature": "Located(Segment Closed v)-\u003eFixedSegment v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:mkFixedSeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Segment",
          "name": "oeEnvelope",
          "package": "diagrams-lib",
          "signature": "forall v.  Lens' (OffsetEnvelope v) (Envelope v)",
          "source": "src/Diagrams-Segment.html#oeEnvelope",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "oeEnvelope",
          "package": "diagrams-lib",
          "partial": "Envelope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:oeEnvelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Segment",
          "name": "oeOffset",
          "package": "diagrams-lib",
          "signature": "forall v.  Lens' (OffsetEnvelope v) (TotalOffset v)",
          "source": "src/Diagrams-Segment.html#oeOffset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "oeOffset",
          "package": "diagrams-lib",
          "partial": "Offset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:oeOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse the direction of a segment.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "reverseSegment",
          "package": "diagrams-lib",
          "signature": "Segment Closed v -\u003e Segment Closed v",
          "source": "src/Diagrams-Segment.html#reverseSegment",
          "type": "function"
        },
        "index": {
          "description": "Reverse the direction of segment",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "reverseSegment",
          "normalized": "Segment Closed a-\u003eSegment Closed a",
          "package": "diagrams-lib",
          "partial": "Segment",
          "signature": "Segment Closed v-\u003eSegment Closed v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:reverseSegment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the offset from the start of a segment to the\n   end.  Note that in the case of a B&#233;zier segment this is \u003cem\u003enot\u003c/em\u003e the\n   same as the length of the curve itself; for that, see \u003ccode\u003e\u003ca\u003earcLength\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "segOffset",
          "package": "diagrams-lib",
          "signature": "Segment Closed v -\u003e v",
          "source": "src/Diagrams-Segment.html#segOffset",
          "type": "function"
        },
        "index": {
          "description": "Compute the offset from the start of segment to the end Note that in the case of zier segment this is not the same as the length of the curve itself for that see arcLength",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "segOffset",
          "normalized": "Segment Closed a-\u003ea",
          "package": "diagrams-lib",
          "partial": "Offset",
          "signature": "Segment Closed v-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:segOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003estraight\u003c/a\u003e\u003c/code\u003e v\u003c/code\u003e constructs a translationally invariant linear\n   segment with direction and length given by the vector \u003ccode\u003ev\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Segment",
          "name": "straight",
          "package": "diagrams-lib",
          "signature": "v -\u003e Segment Closed v",
          "source": "src/Diagrams-Segment.html#straight",
          "type": "function"
        },
        "index": {
          "description": "straight constructs translationally invariant linear segment with direction and length given by the vector",
          "hierarchy": "Diagrams Segment",
          "module": "Diagrams.Segment",
          "name": "straight",
          "normalized": "a-\u003eSegment Closed a",
          "package": "diagrams-lib",
          "signature": "v-\u003eSegment Closed v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Segment.html#v:straight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExact solving of low-degree (n \u003c= 3) polynomials.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Solve",
          "name": "Solve",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Solve.html",
          "type": "module"
        },
        "index": {
          "description": "Exact solving of low-degree polynomials",
          "hierarchy": "Diagrams Solve",
          "module": "Diagrams.Solve",
          "name": "Solve",
          "package": "diagrams-lib",
          "partial": "Solve",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Solve.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve the cubic equation ax^3 + bx^2 + cx + d = 0, returning a\n   list of all real roots.\n\u003c/p\u003e",
          "module": "Diagrams.Solve",
          "name": "cubForm",
          "package": "diagrams-lib",
          "signature": "d -\u003e d -\u003e d -\u003e d -\u003e [d]",
          "source": "src/Diagrams-Solve.html#cubForm",
          "type": "function"
        },
        "index": {
          "description": "Solve the cubic equation ax bx cx returning list of all real roots",
          "hierarchy": "Diagrams Solve",
          "module": "Diagrams.Solve",
          "name": "cubForm",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "package": "diagrams-lib",
          "partial": "Form",
          "signature": "d-\u003ed-\u003ed-\u003ed-\u003e[d]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Solve.html#v:cubForm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe quadratic formula.\n\u003c/p\u003e",
          "module": "Diagrams.Solve",
          "name": "quadForm",
          "package": "diagrams-lib",
          "signature": "d -\u003e d -\u003e d -\u003e [d]",
          "source": "src/Diagrams-Solve.html#quadForm",
          "type": "function"
        },
        "index": {
          "description": "The quadratic formula",
          "hierarchy": "Diagrams Solve",
          "module": "Diagrams.Solve",
          "name": "quadForm",
          "normalized": "a-\u003ea-\u003ea-\u003e[a]",
          "package": "diagrams-lib",
          "partial": "Form",
          "signature": "d-\u003ed-\u003ed-\u003e[d]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Solve.html#v:quadForm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eComputing tangent and normal vectors for segments and trails.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Tangent",
          "name": "Tangent",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Tangent.html",
          "type": "module"
        },
        "index": {
          "description": "Computing tangent and normal vectors for segments and trails",
          "hierarchy": "Diagrams Tangent",
          "module": "Diagrams.Tangent",
          "name": "Tangent",
          "package": "diagrams-lib",
          "partial": "Tangent",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Tangent.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA newtype wrapper used to give different instances of\n   \u003ccode\u003e\u003ca\u003eParametric\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eEndValues\u003c/a\u003e\u003c/code\u003e that compute tangent vectors.\n\u003c/p\u003e",
          "module": "Diagrams.Tangent",
          "name": "Tangent",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Tangent.html#Tangent",
          "type": "newtype"
        },
        "index": {
          "description": "newtype wrapper used to give different instances of Parametric and EndValues that compute tangent vectors",
          "hierarchy": "Diagrams Tangent",
          "module": "Diagrams.Tangent",
          "name": "Tangent",
          "package": "diagrams-lib",
          "partial": "Tangent",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Tangent.html#t:Tangent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Tangent",
          "name": "Tangent",
          "package": "diagrams-lib",
          "signature": "Tangent t",
          "source": "src/Diagrams-Tangent.html#Tangent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Tangent",
          "module": "Diagrams.Tangent",
          "name": "Tangent",
          "package": "diagrams-lib",
          "partial": "Tangent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Tangent.html#v:Tangent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the normal vector at the end of a segment or trail.\n\u003c/p\u003e",
          "module": "Diagrams.Tangent",
          "name": "normalAtEnd",
          "package": "diagrams-lib",
          "signature": "t -\u003e R2",
          "source": "src/Diagrams-Tangent.html#normalAtEnd",
          "type": "function"
        },
        "index": {
          "description": "Compute the normal vector at the end of segment or trail",
          "hierarchy": "Diagrams Tangent",
          "module": "Diagrams.Tangent",
          "name": "normalAtEnd",
          "normalized": "a-\u003eR",
          "package": "diagrams-lib",
          "partial": "At End",
          "signature": "t-\u003eR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Tangent.html#v:normalAtEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the (unit) normal vector to a segment or trail at a\n   particular parameter.\n\u003c/p\u003e\u003cp\u003eExamples of more specific types this function can have include\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003eSegment Closed R2 -\u003e Double -\u003e R2\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003eTrail' Line R2 -\u003e Double -\u003e R2\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003eLocated (Trail R2) -\u003e Double -\u003e P2\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSee the instances listed for the \u003ccode\u003e\u003ca\u003eTangent\u003c/a\u003e\u003c/code\u003e newtype for more.\n\u003c/p\u003e",
          "module": "Diagrams.Tangent",
          "name": "normalAtParam",
          "package": "diagrams-lib",
          "signature": "t -\u003e Scalar (V t) -\u003e R2",
          "source": "src/Diagrams-Tangent.html#normalAtParam",
          "type": "function"
        },
        "index": {
          "description": "Compute the unit normal vector to segment or trail at particular parameter Examples of more specific types this function can have include Segment Closed R2 Double R2 Trail Line R2 Double R2 Located Trail R2 Double P2 See the instances listed for the Tangent newtype for more",
          "hierarchy": "Diagrams Tangent",
          "module": "Diagrams.Tangent",
          "name": "normalAtParam",
          "normalized": "a-\u003eScalar(V a)-\u003eR",
          "package": "diagrams-lib",
          "partial": "At Param",
          "signature": "t-\u003eScalar(V t)-\u003eR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Tangent.html#v:normalAtParam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the normal vector at the start of a segment or trail.\n\u003c/p\u003e",
          "module": "Diagrams.Tangent",
          "name": "normalAtStart",
          "package": "diagrams-lib",
          "signature": "t -\u003e R2",
          "source": "src/Diagrams-Tangent.html#normalAtStart",
          "type": "function"
        },
        "index": {
          "description": "Compute the normal vector at the start of segment or trail",
          "hierarchy": "Diagrams Tangent",
          "module": "Diagrams.Tangent",
          "name": "normalAtStart",
          "normalized": "a-\u003eR",
          "package": "diagrams-lib",
          "partial": "At Start",
          "signature": "t-\u003eR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Tangent.html#v:normalAtStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the tangent vector at the end of a segment or trail.\n\u003c/p\u003e",
          "module": "Diagrams.Tangent",
          "name": "tangentAtEnd",
          "package": "diagrams-lib",
          "signature": "t -\u003e Codomain (Tangent t)",
          "source": "src/Diagrams-Tangent.html#tangentAtEnd",
          "type": "function"
        },
        "index": {
          "description": "Compute the tangent vector at the end of segment or trail",
          "hierarchy": "Diagrams Tangent",
          "module": "Diagrams.Tangent",
          "name": "tangentAtEnd",
          "normalized": "a-\u003eCodomain(Tangent a)",
          "package": "diagrams-lib",
          "partial": "At End",
          "signature": "t-\u003eCodomain(Tangent t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Tangent.html#v:tangentAtEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the tangent vector to a segment or trail at a particular\n   parameter.\n\u003c/p\u003e\u003cp\u003eExamples of more specific types this function can have include\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003eSegment Closed R2 -\u003e Double -\u003e R2\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003eTrail' Line R2 -\u003e Double -\u003e R2\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003eLocated (Trail R2) -\u003e Double -\u003e R2\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSee the instances listed for the \u003ccode\u003e\u003ca\u003eTangent\u003c/a\u003e\u003c/code\u003e newtype for more.\n\u003c/p\u003e",
          "module": "Diagrams.Tangent",
          "name": "tangentAtParam",
          "package": "diagrams-lib",
          "signature": "t -\u003e Scalar (V t) -\u003e Codomain (Tangent t)",
          "source": "src/Diagrams-Tangent.html#tangentAtParam",
          "type": "function"
        },
        "index": {
          "description": "Compute the tangent vector to segment or trail at particular parameter Examples of more specific types this function can have include Segment Closed R2 Double R2 Trail Line R2 Double R2 Located Trail R2 Double R2 See the instances listed for the Tangent newtype for more",
          "hierarchy": "Diagrams Tangent",
          "module": "Diagrams.Tangent",
          "name": "tangentAtParam",
          "normalized": "a-\u003eScalar(V a)-\u003eCodomain(Tangent a)",
          "package": "diagrams-lib",
          "partial": "At Param",
          "signature": "t-\u003eScalar(V t)-\u003eCodomain(Tangent t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Tangent.html#v:tangentAtParam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the tangent vector at the start of a segment or trail.\n\u003c/p\u003e",
          "module": "Diagrams.Tangent",
          "name": "tangentAtStart",
          "package": "diagrams-lib",
          "signature": "t -\u003e Codomain (Tangent t)",
          "source": "src/Diagrams-Tangent.html#tangentAtStart",
          "type": "function"
        },
        "index": {
          "description": "Compute the tangent vector at the start of segment or trail",
          "hierarchy": "Diagrams Tangent",
          "module": "Diagrams.Tangent",
          "name": "tangentAtStart",
          "normalized": "a-\u003eCodomain(Tangent a)",
          "package": "diagrams-lib",
          "partial": "At Start",
          "signature": "t-\u003eCodomain(Tangent t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Tangent.html#v:tangentAtStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTypes to specify viewpoint for 3D rendering.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.ThreeD.Camera",
          "name": "Camera",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Camera.html",
          "type": "module"
        },
        "index": {
          "description": "Types to specify viewpoint for rendering",
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "Camera",
          "package": "diagrams-lib",
          "partial": "Camera",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Camera",
          "name": "Camera",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Camera.html#Camera",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "Camera",
          "package": "diagrams-lib",
          "partial": "Camera",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#t:Camera"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn orthographic projection\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Camera",
          "name": "OrthoLens",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Camera.html#OrthoLens",
          "type": "data"
        },
        "index": {
          "description": "An orthographic projection",
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "OrthoLens",
          "package": "diagrams-lib",
          "partial": "Ortho Lens",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#t:OrthoLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA perspective projection\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Camera",
          "name": "PerspectiveLens",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Camera.html#PerspectiveLens",
          "type": "data"
        },
        "index": {
          "description": "perspective projection",
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "PerspectiveLens",
          "package": "diagrams-lib",
          "partial": "Perspective Lens",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#t:PerspectiveLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Camera",
          "name": "OrthoLens",
          "package": "diagrams-lib",
          "signature": "OrthoLens",
          "source": "src/Diagrams-ThreeD-Camera.html#OrthoLens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "OrthoLens",
          "package": "diagrams-lib",
          "partial": "Ortho Lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:OrthoLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Camera",
          "name": "PerspectiveLens",
          "package": "diagrams-lib",
          "signature": "PerspectiveLens",
          "source": "src/Diagrams-ThreeD-Camera.html#PerspectiveLens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "PerspectiveLens",
          "package": "diagrams-lib",
          "partial": "Perspective Lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:PerspectiveLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHorizontal field of view.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Camera",
          "name": "_horizontalFieldOfView",
          "package": "diagrams-lib",
          "signature": "Deg",
          "source": "src/Diagrams-ThreeD-Camera.html#PerspectiveLens",
          "type": "function"
        },
        "index": {
          "description": "Horizontal field of view",
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "_horizontalFieldOfView",
          "package": "diagrams-lib",
          "partial": "Field Of View",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:_horizontalFieldOfView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHeight\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Camera",
          "name": "_orthoHeight",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-ThreeD-Camera.html#OrthoLens",
          "type": "function"
        },
        "index": {
          "description": "Height",
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "_orthoHeight",
          "package": "diagrams-lib",
          "partial": "Height",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:_orthoHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWidth\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Camera",
          "name": "_orthoWidth",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-ThreeD-Camera.html#OrthoLens",
          "type": "function"
        },
        "index": {
          "description": "Width",
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "_orthoWidth",
          "package": "diagrams-lib",
          "partial": "Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:_orthoWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVertical field of view.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Camera",
          "name": "_verticalFieldOfView",
          "package": "diagrams-lib",
          "signature": "Deg",
          "source": "src/Diagrams-ThreeD-Camera.html#PerspectiveLens",
          "type": "function"
        },
        "index": {
          "description": "Vertical field of view",
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "_verticalFieldOfView",
          "package": "diagrams-lib",
          "partial": "Field Of View",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:_verticalFieldOfView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe natural aspect ratio of the projection.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Camera",
          "name": "aspect",
          "package": "diagrams-lib",
          "signature": "l -\u003e Double",
          "source": "src/Diagrams-ThreeD-Camera.html#aspect",
          "type": "function"
        },
        "index": {
          "description": "The natural aspect ratio of the projection",
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "aspect",
          "normalized": "a-\u003eDouble",
          "package": "diagrams-lib",
          "signature": "l-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:aspect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Camera",
          "name": "camAspect",
          "package": "diagrams-lib",
          "signature": "Camera l -\u003e Double",
          "source": "src/Diagrams-ThreeD-Camera.html#camAspect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "camAspect",
          "normalized": "Camera a-\u003eDouble",
          "package": "diagrams-lib",
          "partial": "Aspect",
          "signature": "Camera l-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:camAspect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Camera",
          "name": "camForward",
          "package": "diagrams-lib",
          "signature": "Camera l -\u003e d",
          "source": "src/Diagrams-ThreeD-Camera.html#camForward",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "camForward",
          "normalized": "Camera a-\u003eb",
          "package": "diagrams-lib",
          "partial": "Forward",
          "signature": "Camera l-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:camForward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Camera",
          "name": "camLens",
          "package": "diagrams-lib",
          "signature": "Camera l -\u003e l",
          "source": "src/Diagrams-ThreeD-Camera.html#camLens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "camLens",
          "normalized": "Camera a-\u003ea",
          "package": "diagrams-lib",
          "partial": "Lens",
          "signature": "Camera l-\u003el",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:camLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Camera",
          "name": "camLoc",
          "package": "diagrams-lib",
          "signature": "Camera l -\u003e P3",
          "source": "src/Diagrams-ThreeD-Camera.html#camLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "camLoc",
          "normalized": "Camera a-\u003eP",
          "package": "diagrams-lib",
          "partial": "Loc",
          "signature": "Camera l-\u003eP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:camLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Camera",
          "name": "camRight",
          "package": "diagrams-lib",
          "signature": "Camera l -\u003e d",
          "source": "src/Diagrams-ThreeD-Camera.html#camRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "camRight",
          "normalized": "Camera a-\u003eb",
          "package": "diagrams-lib",
          "partial": "Right",
          "signature": "Camera l-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:camRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Camera",
          "name": "camUp",
          "package": "diagrams-lib",
          "signature": "Camera l -\u003e d",
          "source": "src/Diagrams-ThreeD-Camera.html#camUp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "camUp",
          "normalized": "Camera a-\u003eb",
          "package": "diagrams-lib",
          "partial": "Up",
          "signature": "Camera l-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:camUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e'facing_ZCamera l' is a camera at the origin facing along the\n negative Z axis, with its up-axis coincident with the positive Y\n axis, with the projection defined by l.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Camera",
          "name": "facing_ZCamera",
          "package": "diagrams-lib",
          "signature": "l -\u003e Diagram b R3",
          "source": "src/Diagrams-ThreeD-Camera.html#facing_ZCamera",
          "type": "function"
        },
        "index": {
          "description": "facing ZCamera is camera at the origin facing along the negative axis with its up-axis coincident with the positive axis with the projection defined by",
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "facing_ZCamera",
          "normalized": "a-\u003eDiagram b R",
          "package": "diagrams-lib",
          "partial": "ZCamera",
          "signature": "l-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:facing_ZCamera"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Camera",
          "name": "horizontalFieldOfView",
          "package": "diagrams-lib",
          "signature": "Lens' PerspectiveLens Deg",
          "source": "src/Diagrams-ThreeD-Camera.html#horizontalFieldOfView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "horizontalFieldOfView",
          "package": "diagrams-lib",
          "partial": "Field Of View",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:horizontalFieldOfView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emm50 has the field of view of a 50mm lens on standard 35mm film,\n hence an aspect ratio of 3:2.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Camera",
          "name": "mm50",
          "package": "diagrams-lib",
          "signature": "PerspectiveLens",
          "source": "src/Diagrams-ThreeD-Camera.html#mm50",
          "type": "function"
        },
        "index": {
          "description": "mm50 has the field of view of mm lens on standard mm film hence an aspect ratio of",
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "mm50",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:mm50"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA camera at the origin facing along the negative Z axis, with its\n up-axis coincident with the positive Y axis.  The field of view is\n chosen to match a 50mm camera on 35mm film. Note that Cameras take\n up no space in the Diagram.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Camera",
          "name": "mm50Camera",
          "package": "diagrams-lib",
          "signature": "Diagram b R3",
          "source": "src/Diagrams-ThreeD-Camera.html#mm50Camera",
          "type": "function"
        },
        "index": {
          "description": "camera at the origin facing along the negative axis with its up-axis coincident with the positive axis The field of view is chosen to match mm camera on mm film Note that Cameras take up no space in the Diagram",
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "mm50Camera",
          "package": "diagrams-lib",
          "partial": "Camera",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:mm50Camera"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emm50Narrow has the same vertical field of view as mm50, but an\n aspect ratio of 4:3, for VGA and similar computer resulotions.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Camera",
          "name": "mm50Narrow",
          "package": "diagrams-lib",
          "signature": "PerspectiveLens",
          "source": "src/Diagrams-ThreeD-Camera.html#mm50Narrow",
          "type": "function"
        },
        "index": {
          "description": "mm50Narrow has the same vertical field of view as mm50 but an aspect ratio of for VGA and similar computer resulotions",
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "mm50Narrow",
          "package": "diagrams-lib",
          "partial": "Narrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:mm50Narrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emm50Wide has the same vertical field of view as mm50, but an\n aspect ratio of 1.6, suitable for wide screen computer monitors.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Camera",
          "name": "mm50Wide",
          "package": "diagrams-lib",
          "signature": "PerspectiveLens",
          "source": "src/Diagrams-ThreeD-Camera.html#mm50Wide",
          "type": "function"
        },
        "index": {
          "description": "mm50Wide has the same vertical field of view as mm50 but an aspect ratio of suitable for wide screen computer monitors",
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "mm50Wide",
          "package": "diagrams-lib",
          "partial": "Wide",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:mm50Wide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Camera",
          "name": "orthoHeight",
          "package": "diagrams-lib",
          "signature": "Lens' OrthoLens Double",
          "source": "src/Diagrams-ThreeD-Camera.html#orthoHeight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "orthoHeight",
          "package": "diagrams-lib",
          "partial": "Height",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:orthoHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Camera",
          "name": "orthoWidth",
          "package": "diagrams-lib",
          "signature": "Lens' OrthoLens Double",
          "source": "src/Diagrams-ThreeD-Camera.html#orthoWidth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "orthoWidth",
          "package": "diagrams-lib",
          "partial": "Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:orthoWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Camera",
          "name": "verticalFieldOfView",
          "package": "diagrams-lib",
          "signature": "Lens' PerspectiveLens Deg",
          "source": "src/Diagrams-ThreeD-Camera.html#verticalFieldOfView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Camera",
          "module": "Diagrams.ThreeD.Camera",
          "name": "verticalFieldOfView",
          "package": "diagrams-lib",
          "partial": "Field Of View",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Camera.html#v:verticalFieldOfView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTypes to specify lighting for 3D rendering.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.ThreeD.Light",
          "name": "Light",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Light.html",
          "type": "module"
        },
        "index": {
          "description": "Types to specify lighting for rendering",
          "hierarchy": "Diagrams ThreeD Light",
          "module": "Diagrams.ThreeD.Light",
          "name": "Light",
          "package": "diagrams-lib",
          "partial": "Light",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Light.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Light",
          "name": "ParallelLight",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Light.html#ParallelLight",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Light",
          "module": "Diagrams.ThreeD.Light",
          "name": "ParallelLight",
          "package": "diagrams-lib",
          "partial": "Parallel Light",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Light.html#t:ParallelLight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Light",
          "name": "PointLight",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Light.html#PointLight",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Light",
          "module": "Diagrams.ThreeD.Light",
          "name": "PointLight",
          "package": "diagrams-lib",
          "partial": "Point Light",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Light.html#t:PointLight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Light",
          "name": "ParallelLight",
          "package": "diagrams-lib",
          "signature": "ParallelLight R3 (Colour Double)",
          "source": "src/Diagrams-ThreeD-Light.html#ParallelLight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Light",
          "module": "Diagrams.ThreeD.Light",
          "name": "ParallelLight",
          "package": "diagrams-lib",
          "partial": "Parallel Light",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Light.html#v:ParallelLight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Light",
          "name": "PointLight",
          "package": "diagrams-lib",
          "signature": "PointLight P3 (Colour Double)",
          "source": "src/Diagrams-ThreeD-Light.html#PointLight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Light",
          "module": "Diagrams.ThreeD.Light",
          "name": "PointLight",
          "package": "diagrams-lib",
          "partial": "Point Light",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Light.html#v:PointLight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a Diagram with a single ParallelLight, which takes up no space.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Light",
          "name": "parallelLight",
          "package": "diagrams-lib",
          "signature": "d-\u003e Colour Double-\u003e Diagram b R3",
          "type": "function"
        },
        "index": {
          "description": "Construct Diagram with single ParallelLight which takes up no space",
          "hierarchy": "Diagrams ThreeD Light",
          "module": "Diagrams.ThreeD.Light",
          "name": "parallelLight",
          "normalized": "a-\u003eColour Double-\u003eDiagram b R",
          "package": "diagrams-lib",
          "partial": "Light",
          "signature": "d-\u003eColour Double-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Light.html#v:parallelLight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a Diagram with a single PointLight at the origin, which\n takes up no space.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Light",
          "name": "pointLight",
          "package": "diagrams-lib",
          "signature": "Colour Double-\u003e Diagram b R3",
          "type": "function"
        },
        "index": {
          "description": "Construct Diagram with single PointLight at the origin which takes up no space",
          "hierarchy": "Diagrams ThreeD Light",
          "module": "Diagrams.ThreeD.Light",
          "name": "pointLight",
          "normalized": "Colour Double-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "Light",
          "signature": "Colour Double-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Light.html#v:pointLight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVarious three-dimensional shapes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.ThreeD.Shapes",
          "name": "Shapes",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Shapes.html",
          "type": "module"
        },
        "index": {
          "description": "Various three-dimensional shapes",
          "hierarchy": "Diagrams ThreeD Shapes",
          "module": "Diagrams.ThreeD.Shapes",
          "name": "Shapes",
          "package": "diagrams-lib",
          "partial": "Shapes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Shapes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Shapes",
          "name": "Ellipsoid",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Shapes.html#Ellipsoid",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Shapes",
          "module": "Diagrams.ThreeD.Shapes",
          "name": "Ellipsoid",
          "package": "diagrams-lib",
          "partial": "Ellipsoid",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Shapes.html#t:Ellipsoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Shapes",
          "name": "Ellipsoid",
          "package": "diagrams-lib",
          "signature": "Ellipsoid T3",
          "source": "src/Diagrams-ThreeD-Shapes.html#Ellipsoid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Shapes",
          "module": "Diagrams.ThreeD.Shapes",
          "name": "Ellipsoid",
          "package": "diagrams-lib",
          "partial": "Ellipsoid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Shapes.html#v:Ellipsoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Shapes",
          "name": "sphere",
          "package": "diagrams-lib",
          "signature": "Diagram b R3",
          "source": "src/Diagrams-ThreeD-Shapes.html#sphere",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Shapes",
          "module": "Diagrams.ThreeD.Shapes",
          "name": "sphere",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Shapes.html#v:sphere"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTransformations specific to three dimensions, with a few generic\n transformations (uniform scaling, translation) also re-exported for\n convenience.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.ThreeD.Transform",
          "name": "Transform",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Transform.html",
          "type": "module"
        },
        "index": {
          "description": "Transformations specific to three dimensions with few generic transformations uniform scaling translation also re-exported for convenience",
          "hierarchy": "Diagrams ThreeD Transform",
          "module": "Diagrams.ThreeD.Transform",
          "name": "Transform",
          "package": "diagrams-lib",
          "partial": "Transform",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Transform.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eaboutZ\u003c/a\u003e\u003c/code\u003e, but rotates about the X axis, bringing positive y-values\n towards the positive z-axis.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Transform",
          "name": "aboutX",
          "package": "diagrams-lib",
          "signature": "a -\u003e T3",
          "source": "src/Diagrams-ThreeD-Transform.html#aboutX",
          "type": "function"
        },
        "index": {
          "description": "Like aboutZ but rotates about the axis bringing positive y-values towards the positive z-axis",
          "hierarchy": "Diagrams ThreeD Transform",
          "module": "Diagrams.ThreeD.Transform",
          "name": "aboutX",
          "normalized": "a-\u003eT",
          "package": "diagrams-lib",
          "signature": "a-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Transform.html#v:aboutX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eaboutZ\u003c/a\u003e\u003c/code\u003e, but rotates about the Y axis, bringing postive\n x-values towards the negative z-axis.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Transform",
          "name": "aboutY",
          "package": "diagrams-lib",
          "signature": "a -\u003e T3",
          "source": "src/Diagrams-ThreeD-Transform.html#aboutY",
          "type": "function"
        },
        "index": {
          "description": "Like aboutZ but rotates about the axis bringing postive x-values towards the negative z-axis",
          "hierarchy": "Diagrams ThreeD Transform",
          "module": "Diagrams.ThreeD.Transform",
          "name": "aboutY",
          "normalized": "a-\u003eT",
          "package": "diagrams-lib",
          "signature": "a-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Transform.html#v:aboutY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a transformation which rotates by the given angle about\n   a line parallel the Z axis passing through the local origin.\n   A positive angle brings positive x-values towards the positive-y axis.\n\u003c/p\u003e\u003cp\u003eThe angle can be expressed using any type which is an\n   instance of \u003ccode\u003e\u003ca\u003eAngle\u003c/a\u003e\u003c/code\u003e.  For example, \u003ccode\u003eaboutZ (1/4 ::\n   \u003ccode\u003e\u003ca\u003eTurn\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e, \u003ccode\u003eaboutZ (tau/4 :: \u003ccode\u003e\u003ca\u003eRad\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e, and \u003ccode\u003eaboutZ (90 ::\n   \u003ccode\u003e\u003ca\u003eDeg\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e all represent the same transformation, namely, a\n   counterclockwise rotation by a right angle.  For more general rotations,\n   see \u003ccode\u003e\u003ca\u003erotationAbout\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that writing \u003ccode\u003eaboutZ (1/4)\u003c/code\u003e, with no type annotation, will\n   yield an error since GHC cannot figure out which sort of angle\n   you want to use.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Transform",
          "name": "aboutZ",
          "package": "diagrams-lib",
          "signature": "a -\u003e T3",
          "source": "src/Diagrams-ThreeD-Transform.html#aboutZ",
          "type": "function"
        },
        "index": {
          "description": "Create transformation which rotates by the given angle about line parallel the axis passing through the local origin positive angle brings positive x-values towards the positive-y axis The angle can be expressed using any type which is an instance of Angle For example aboutZ Turn aboutZ tau Rad and aboutZ Deg all represent the same transformation namely counterclockwise rotation by right angle For more general rotations see rotationAbout Note that writing aboutZ with no type annotation will yield an error since GHC cannot figure out which sort of angle you want to use",
          "hierarchy": "Diagrams ThreeD Transform",
          "module": "Diagrams.ThreeD.Transform",
          "name": "aboutZ",
          "normalized": "a-\u003eT",
          "package": "diagrams-lib",
          "signature": "a-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Transform.html#v:aboutZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the matrix equivalent of an affine transform, as a triple of\n   columns paired with the translation vector.  This is mostly\n   useful for implementing backends.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Transform",
          "name": "onBasis",
          "package": "diagrams-lib",
          "signature": "T3 -\u003e ((R3, R3, R3), R3)",
          "source": "src/Diagrams-ThreeD-Transform.html#onBasis",
          "type": "function"
        },
        "index": {
          "description": "Get the matrix equivalent of an affine transform as triple of columns paired with the translation vector This is mostly useful for implementing backends",
          "hierarchy": "Diagrams ThreeD Transform",
          "module": "Diagrams.ThreeD.Transform",
          "name": "onBasis",
          "normalized": "T-\u003e((R,R,R),R)",
          "package": "diagrams-lib",
          "partial": "Basis",
          "signature": "T-\u003e((R,R,R),R)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Transform.html#v:onBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003epointAt about initial final\u003c/code\u003e produces a rotation which brings\n the direction \u003ccode\u003einitial\u003c/code\u003e to point in the direction \u003ccode\u003efinal\u003c/code\u003e by first\n panning around \u003ccode\u003eabout\u003c/code\u003e, then tilting about the axis perpendicular\n to initial and final.  In particular, if this can be accomplished\n without tilting, it will be, otherwise if only tilting is\n necessary, no panning will occur.  The tilt will always be between\n &#177; /4 turn.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Transform",
          "name": "pointAt",
          "package": "diagrams-lib",
          "signature": "d -\u003e d -\u003e d -\u003e T3",
          "source": "src/Diagrams-ThreeD-Transform.html#pointAt",
          "type": "function"
        },
        "index": {
          "description": "pointAt about initial final produces rotation which brings the direction initial to point in the direction final by first panning around about then tilting about the axis perpendicular to initial and final In particular if this can be accomplished without tilting it will be otherwise if only tilting is necessary no panning will occur The tilt will always be between turn",
          "hierarchy": "Diagrams ThreeD Transform",
          "module": "Diagrams.ThreeD.Transform",
          "name": "pointAt",
          "normalized": "a-\u003ea-\u003ea-\u003eT",
          "package": "diagrams-lib",
          "partial": "At",
          "signature": "d-\u003ed-\u003ed-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Transform.html#v:pointAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epointAt' has the same behavior as \u003ccode\u003e\u003ca\u003epointAt\u003c/a\u003e\u003c/code\u003e, but takes vectors\n instead of directions.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Transform",
          "name": "pointAt'",
          "package": "diagrams-lib",
          "signature": "R3 -\u003e R3 -\u003e R3 -\u003e T3",
          "source": "src/Diagrams-ThreeD-Transform.html#pointAt%27",
          "type": "function"
        },
        "index": {
          "description": "pointAt has the same behavior as pointAt but takes vectors instead of directions",
          "hierarchy": "Diagrams ThreeD Transform",
          "module": "Diagrams.ThreeD.Transform",
          "name": "pointAt'",
          "normalized": "R-\u003eR-\u003eR-\u003eT",
          "package": "diagrams-lib",
          "partial": "At'",
          "signature": "R-\u003eR-\u003eR-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Transform.html#v:pointAt-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erotationAbout p d a\u003c/code\u003e is a rotation about a line parallel to \u003ccode\u003ed\u003c/code\u003e\n   passing through \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Transform",
          "name": "rotationAbout",
          "package": "diagrams-lib",
          "signature": "P3-\u003e d-\u003e a-\u003e T3",
          "type": "function"
        },
        "index": {
          "description": "rotationAbout is rotation about line parallel to passing through",
          "hierarchy": "Diagrams ThreeD Transform",
          "module": "Diagrams.ThreeD.Transform",
          "name": "rotationAbout",
          "normalized": "P-\u003ea-\u003eb-\u003eT",
          "package": "diagrams-lib",
          "partial": "About",
          "signature": "P-\u003ed-\u003ea-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Transform.html#v:rotationAbout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale a diagram by the given factor in the x (horizontal)\n   direction.  To scale uniformly, use \u003ccode\u003e\u003ca\u003escale\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Transform",
          "name": "scaleX",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t -\u003e t",
          "source": "src/Diagrams-ThreeD-Transform.html#scaleX",
          "type": "function"
        },
        "index": {
          "description": "Scale diagram by the given factor in the horizontal direction To scale uniformly use scale",
          "hierarchy": "Diagrams ThreeD Transform",
          "module": "Diagrams.ThreeD.Transform",
          "name": "scaleX",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Transform.html#v:scaleX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale a diagram by the given factor in the y (vertical)\n   direction.  To scale uniformly, use \u003ccode\u003e\u003ca\u003escale\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Transform",
          "name": "scaleY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t -\u003e t",
          "source": "src/Diagrams-ThreeD-Transform.html#scaleY",
          "type": "function"
        },
        "index": {
          "description": "Scale diagram by the given factor in the vertical direction To scale uniformly use scale",
          "hierarchy": "Diagrams ThreeD Transform",
          "module": "Diagrams.ThreeD.Transform",
          "name": "scaleY",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Transform.html#v:scaleY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale a diagram by the given factor in the z direction.  To scale\n uniformly, use \u003ccode\u003e\u003ca\u003escale\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Transform",
          "name": "scaleZ",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t -\u003e t",
          "source": "src/Diagrams-ThreeD-Transform.html#scaleZ",
          "type": "function"
        },
        "index": {
          "description": "Scale diagram by the given factor in the direction To scale uniformly use scale",
          "hierarchy": "Diagrams ThreeD Transform",
          "module": "Diagrams.ThreeD.Transform",
          "name": "scaleZ",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Transform.html#v:scaleZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a transformation which scales by the given factor in\n   the x direction.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Transform",
          "name": "scalingX",
          "package": "diagrams-lib",
          "signature": "Double -\u003e T3",
          "source": "src/Diagrams-ThreeD-Transform.html#scalingX",
          "type": "function"
        },
        "index": {
          "description": "Construct transformation which scales by the given factor in the direction",
          "hierarchy": "Diagrams ThreeD Transform",
          "module": "Diagrams.ThreeD.Transform",
          "name": "scalingX",
          "normalized": "Double-\u003eT",
          "package": "diagrams-lib",
          "signature": "Double-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Transform.html#v:scalingX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a transformation which scales by the given factor in\n   the y direction.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Transform",
          "name": "scalingY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e T3",
          "source": "src/Diagrams-ThreeD-Transform.html#scalingY",
          "type": "function"
        },
        "index": {
          "description": "Construct transformation which scales by the given factor in the direction",
          "hierarchy": "Diagrams ThreeD Transform",
          "module": "Diagrams.ThreeD.Transform",
          "name": "scalingY",
          "normalized": "Double-\u003eT",
          "package": "diagrams-lib",
          "signature": "Double-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Transform.html#v:scalingY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a transformation which scales by the given factor in\n   the z direction.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Transform",
          "name": "scalingZ",
          "package": "diagrams-lib",
          "signature": "Double -\u003e T3",
          "source": "src/Diagrams-ThreeD-Transform.html#scalingZ",
          "type": "function"
        },
        "index": {
          "description": "Construct transformation which scales by the given factor in the direction",
          "hierarchy": "Diagrams ThreeD Transform",
          "module": "Diagrams.ThreeD.Transform",
          "name": "scalingZ",
          "normalized": "Double-\u003eT",
          "package": "diagrams-lib",
          "signature": "Double-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Transform.html#v:scalingZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic types for three-dimensional Euclidean space.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "Types",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Types.html",
          "type": "module"
        },
        "index": {
          "description": "Basic types for three-dimensional Euclidean space",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "Types",
          "package": "diagrams-lib",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class for types that measure angles.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "Angle",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#Angle",
          "type": "class"
        },
        "index": {
          "description": "Type class for types that measure angles",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "Angle",
          "package": "diagrams-lib",
          "partial": "Angle",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#t:Angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated synonym for \u003ccode\u003e\u003ca\u003eTurn\u003c/a\u003e\u003c/code\u003e, retained for backwards compatibility.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "CircleFrac",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#CircleFrac",
          "type": "type"
        },
        "index": {
          "description": "Deprecated synonym for Turn retained for backwards compatibility",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "CircleFrac",
          "package": "diagrams-lib",
          "partial": "Circle Frac",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#t:CircleFrac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNewtype wrapper for representing angles in degrees.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "Deg",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#Deg",
          "type": "newtype"
        },
        "index": {
          "description": "Newtype wrapper for representing angles in degrees",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "Deg",
          "package": "diagrams-lib",
          "partial": "Deg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#t:Deg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDirection is a type class representing directions in R3.  The interface is\n based on that of the Angle class in 2D.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "Direction",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Types.html#Direction",
          "type": "class"
        },
        "index": {
          "description": "Direction is type class representing directions in R3 The interface is based on that of the Angle class in",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "Direction",
          "package": "diagrams-lib",
          "partial": "Direction",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#t:Direction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePoints in R^3.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "P3",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Types.html#P3",
          "type": "type"
        },
        "index": {
          "description": "Points in",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "P3",
          "package": "diagrams-lib",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#t:P3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe three-dimensional Euclidean vector space R^3.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "R3",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Types.html#R3",
          "type": "data"
        },
        "index": {
          "description": "The three-dimensional Euclidean vector space",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "R3",
          "package": "diagrams-lib",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#t:R3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNewtype wrapper for representing angles in radians.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "Rad",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#Rad",
          "type": "newtype"
        },
        "index": {
          "description": "Newtype wrapper for representing angles in radians",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "Rad",
          "package": "diagrams-lib",
          "partial": "Rad",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#t:Rad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA direction expressed as a pair of spherical coordinates.\n `Spherical 0 0` is the direction of \u003ccode\u003eunitX\u003c/code\u003e.  The first coordinate\n represents rotation about the Z axis, the second rotation towards the Z axis.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "Spherical",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Types.html#Spherical",
          "type": "data"
        },
        "index": {
          "description": "direction expressed as pair of spherical coordinates Spherical is the direction of unitX The first coordinate represents rotation about the axis the second rotation towards the axis",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "Spherical",
          "package": "diagrams-lib",
          "partial": "Spherical",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#t:Spherical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransformations in R^3.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "T3",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Types.html#T3",
          "type": "type"
        },
        "index": {
          "description": "Transformations in",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "T3",
          "package": "diagrams-lib",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#t:T3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNewtype wrapper used to represent angles as fractions of a\n   circle.  For example, 1/3 turn = tau/3 radians = 120 degrees.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "Turn",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#Turn",
          "type": "newtype"
        },
        "index": {
          "description": "Newtype wrapper used to represent angles as fractions of circle For example turn tau radians degrees",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "Turn",
          "package": "diagrams-lib",
          "partial": "Turn",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#t:Turn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.ThreeD.Types\",\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "Deg",
          "package": "diagrams-lib",
          "signature": "Deg Double",
          "source": "src/Diagrams-TwoD-Types.html#Deg",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:Deg\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:Deg\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:Deg\"]"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "Deg",
          "package": "diagrams-lib",
          "partial": "Deg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:Deg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.ThreeD.Types\",\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "Rad",
          "package": "diagrams-lib",
          "signature": "Rad Double",
          "source": "src/Diagrams-TwoD-Types.html#Rad",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:Rad\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:Rad\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:Rad\"]"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "Rad",
          "package": "diagrams-lib",
          "partial": "Rad",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:Rad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Types",
          "name": "Spherical",
          "package": "diagrams-lib",
          "signature": "Spherical a a",
          "source": "src/Diagrams-ThreeD-Types.html#Spherical",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "Spherical",
          "package": "diagrams-lib",
          "partial": "Spherical",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:Spherical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.ThreeD.Types\",\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "Turn",
          "package": "diagrams-lib",
          "signature": "Turn Double",
          "source": "src/Diagrams-TwoD-Types.html#Turn",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:Turn\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:Turn\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:Turn\"]"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "Turn",
          "package": "diagrams-lib",
          "partial": "Turn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:Turn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate ratio between two angles\n\u003c/p\u003e",
          "module": "[\"Diagrams.ThreeD.Types\",\"Diagrams.TwoD.Types\"]",
          "name": "angleRatio",
          "package": "diagrams-lib",
          "signature": "a -\u003e a -\u003e Double",
          "source": "src/Diagrams-TwoD-Types.html#angleRatio",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:angleRatio\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:angleRatio\"]"
        },
        "index": {
          "description": "Calculate ratio between two angles",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "angleRatio",
          "normalized": "a-\u003ea-\u003eDouble",
          "package": "diagrams-lib",
          "partial": "Ratio",
          "signature": "a-\u003ea-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:angleRatio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity function with a restricted type, for conveniently\n declaring that some value should have type \u003ccode\u003e\u003ca\u003eDeg\u003c/a\u003e\u003c/code\u003e.  For example,\n \u003ccode\u003erotation . asDeg . fromIntegral\u003c/code\u003e constructs a rotation from an\n integral value considered as a value in degrees.  Without \u003ccode\u003easDeg\u003c/code\u003e,\n the angle type would be ambiguous.\n\u003c/p\u003e",
          "module": "[\"Diagrams.ThreeD.Types\",\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "asDeg",
          "package": "diagrams-lib",
          "signature": "Deg -\u003e Deg",
          "source": "src/Diagrams-TwoD-Types.html#asDeg",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:asDeg\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:asDeg\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:asDeg\"]"
        },
        "index": {
          "description": "The identity function with restricted type for conveniently declaring that some value should have type Deg For example rotation asDeg fromIntegral constructs rotation from an integral value considered as value in degrees Without asDeg the angle type would be ambiguous",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "asDeg",
          "normalized": "Deg-\u003eDeg",
          "package": "diagrams-lib",
          "partial": "Deg",
          "signature": "Deg-\u003eDeg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:asDeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity function with a restricted type, for conveniently\n declaring that some value should have type \u003ccode\u003e\u003ca\u003eRad\u003c/a\u003e\u003c/code\u003e.  For example,\n \u003ccode\u003erotation . asRad . fromRational\u003c/code\u003e constructs a rotation from a\n rational value considered as a value in radians.  Without \u003ccode\u003easRad\u003c/code\u003e,\n the angle type would be ambiguous.\n\u003c/p\u003e",
          "module": "[\"Diagrams.ThreeD.Types\",\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "asRad",
          "package": "diagrams-lib",
          "signature": "Rad -\u003e Rad",
          "source": "src/Diagrams-TwoD-Types.html#asRad",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:asRad\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:asRad\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:asRad\"]"
        },
        "index": {
          "description": "The identity function with restricted type for conveniently declaring that some value should have type Rad For example rotation asRad fromRational constructs rotation from rational value considered as value in radians Without asRad the angle type would be ambiguous",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "asRad",
          "normalized": "Rad-\u003eRad",
          "package": "diagrams-lib",
          "partial": "Rad",
          "signature": "Rad-\u003eRad",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:asRad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity function with a restricted type, for conveniently\n restricting unwanted polymorphism.  For example, \u003ccode\u003efromDirection\n . asSpherical . camForward\u003c/code\u003e gives a unit vector pointing in the\n direction of the camera view.  Without \u003ccode\u003easSpherical\u003c/code\u003e, the\n intermediate type would be ambiguous.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "asSpherical",
          "package": "diagrams-lib",
          "signature": "Spherical Turn -\u003e Spherical Turn",
          "source": "src/Diagrams-ThreeD-Types.html#asSpherical",
          "type": "function"
        },
        "index": {
          "description": "The identity function with restricted type for conveniently restricting unwanted polymorphism For example fromDirection asSpherical camForward gives unit vector pointing in the direction of the camera view Without asSpherical the intermediate type would be ambiguous",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "asSpherical",
          "normalized": "Spherical Turn-\u003eSpherical Turn",
          "package": "diagrams-lib",
          "partial": "Spherical",
          "signature": "Spherical Turn-\u003eSpherical Turn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:asSpherical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity function with a restricted type, for conveniently\n declaring that some value should have type \u003ccode\u003e\u003ca\u003eTurn\u003c/a\u003e\u003c/code\u003e.  For example,\n \u003ccode\u003erotation . asTurn . fromRational\u003c/code\u003e constructs a rotation from a\n rational value considered as a \u003ccode\u003eTurn\u003c/code\u003e.  Without \u003ccode\u003easTurn\u003c/code\u003e, the angle\n type would be ambiguous.\n\u003c/p\u003e",
          "module": "[\"Diagrams.ThreeD.Types\",\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "asTurn",
          "package": "diagrams-lib",
          "signature": "Turn -\u003e Turn",
          "source": "src/Diagrams-TwoD-Types.html#asTurn",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:asTurn\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:asTurn\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:asTurn\"]"
        },
        "index": {
          "description": "The identity function with restricted type for conveniently declaring that some value should have type Turn For example rotation asTurn fromRational constructs rotation from rational value considered as Turn Without asTurn the angle type would be ambiguous",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "asTurn",
          "normalized": "Turn-\u003eTurn",
          "package": "diagrams-lib",
          "partial": "Turn",
          "signature": "Turn-\u003eTurn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:asTurn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert between two angle representations.\n\u003c/p\u003e",
          "module": "[\"Diagrams.ThreeD.Types\",\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "convertAngle",
          "package": "diagrams-lib",
          "signature": "a -\u003e b",
          "source": "src/Diagrams-TwoD-Types.html#convertAngle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:convertAngle\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:convertAngle\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:convertAngle\"]"
        },
        "index": {
          "description": "Convert between two angle representations",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "convertAngle",
          "normalized": "a-\u003eb",
          "package": "diagrams-lib",
          "partial": "Angle",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:convertAngle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from polar angles\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "fromSpherical",
          "package": "diagrams-lib",
          "signature": "Spherical a -\u003e d",
          "source": "src/Diagrams-ThreeD-Types.html#fromSpherical",
          "type": "method"
        },
        "index": {
          "description": "Convert from polar angles",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "fromSpherical",
          "normalized": "Spherical a-\u003eb",
          "package": "diagrams-lib",
          "partial": "Spherical",
          "signature": "Spherical a-\u003ed",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:fromSpherical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from a turn, \u003cem\u003ei.e.\u003c/em\u003e a fraction of a circle.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "fromTurn",
          "package": "diagrams-lib",
          "signature": "Turn -\u003e a",
          "source": "src/Diagrams-TwoD-Types.html#fromTurn",
          "type": "method"
        },
        "index": {
          "description": "Convert from turn i.e fraction of circle",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "fromTurn",
          "normalized": "Turn-\u003ea",
          "package": "diagrams-lib",
          "partial": "Turn",
          "signature": "Turn-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:fromTurn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn angle representing one full turn.\n\u003c/p\u003e",
          "module": "[\"Diagrams.ThreeD.Types\",\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "fullTurn",
          "package": "diagrams-lib",
          "signature": "a",
          "source": "src/Diagrams-TwoD-Types.html#fullTurn",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:fullTurn\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:fullTurn\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:fullTurn\"]"
        },
        "index": {
          "description": "An angle representing one full turn",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "fullTurn",
          "package": "diagrams-lib",
          "partial": "Turn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:fullTurn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurried version of \u003ccode\u003e\u003ca\u003er3\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "mkP3",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Double -\u003e Double -\u003e P3",
          "source": "src/Diagrams-ThreeD-Types.html#mkP3",
          "type": "function"
        },
        "index": {
          "description": "Curried version of r3",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "mkP3",
          "normalized": "Double-\u003eDouble-\u003eDouble-\u003eP",
          "package": "diagrams-lib",
          "signature": "Double-\u003eDouble-\u003eDouble-\u003eP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:mkP3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurried version of \u003ccode\u003e\u003ca\u003er3\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "mkR3",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Double -\u003e Double -\u003e R3",
          "source": "src/Diagrams-ThreeD-Types.html#mkR3",
          "type": "function"
        },
        "index": {
          "description": "Curried version of r3",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "mkR3",
          "normalized": "Double-\u003eDouble-\u003eDouble-\u003eR",
          "package": "diagrams-lib",
          "signature": "Double-\u003eDouble-\u003eDouble-\u003eR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:mkR3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a 3D point from a triple of coordinates.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "p3",
          "package": "diagrams-lib",
          "signature": "(Double, Double, Double) -\u003e P3",
          "source": "src/Diagrams-ThreeD-Types.html#p3",
          "type": "function"
        },
        "index": {
          "description": "Construct point from triple of coordinates",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "p3",
          "normalized": "(Double,Double,Double)-\u003eP",
          "package": "diagrams-lib",
          "signature": "(Double,Double,Double)-\u003eP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:p3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Types",
          "name": "p3Iso",
          "package": "diagrams-lib",
          "signature": "Iso' P3 (Double, Double, Double)",
          "source": "src/Diagrams-ThreeD-Types.html#p3Iso",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "p3Iso",
          "normalized": "Iso' P(Double,Double,Double)",
          "package": "diagrams-lib",
          "partial": "Iso",
          "signature": "Iso' P(Double,Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:p3Iso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a 3D vector from a triple of components.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "r3",
          "package": "diagrams-lib",
          "signature": "(Double, Double, Double) -\u003e R3",
          "source": "src/Diagrams-ThreeD-Types.html#r3",
          "type": "function"
        },
        "index": {
          "description": "Construct vector from triple of components",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "r3",
          "normalized": "(Double,Double,Double)-\u003eR",
          "package": "diagrams-lib",
          "signature": "(Double,Double,Double)-\u003eR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:r3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.ThreeD.Types",
          "name": "r3Iso",
          "package": "diagrams-lib",
          "signature": "Iso' R3 (Double, Double, Double)",
          "source": "src/Diagrams-ThreeD-Types.html#r3Iso",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "r3Iso",
          "normalized": "Iso' R(Double,Double,Double)",
          "package": "diagrams-lib",
          "partial": "Iso",
          "signature": "Iso' R(Double,Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:r3Iso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert to polar angles\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "toSpherical",
          "package": "diagrams-lib",
          "signature": "d -\u003e Spherical a",
          "source": "src/Diagrams-ThreeD-Types.html#toSpherical",
          "type": "method"
        },
        "index": {
          "description": "Convert to polar angles",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "toSpherical",
          "normalized": "a-\u003eSpherical b",
          "package": "diagrams-lib",
          "partial": "Spherical",
          "signature": "d-\u003eSpherical a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:toSpherical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert to a turn, \u003cem\u003ei.e.\u003c/em\u003e a fraction of a circle.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "toTurn",
          "package": "diagrams-lib",
          "signature": "a -\u003e Turn",
          "source": "src/Diagrams-TwoD-Types.html#toTurn",
          "type": "method"
        },
        "index": {
          "description": "Convert to turn i.e fraction of circle",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "toTurn",
          "normalized": "a-\u003eTurn",
          "package": "diagrams-lib",
          "partial": "Turn",
          "signature": "a-\u003eTurn",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:toTurn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a 3D point back into a triple of coordinates.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "unp3",
          "package": "diagrams-lib",
          "signature": "P3 -\u003e (Double, Double, Double)",
          "source": "src/Diagrams-ThreeD-Types.html#unp3",
          "type": "function"
        },
        "index": {
          "description": "Convert point back into triple of coordinates",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "unp3",
          "normalized": "P-\u003e(Double,Double,Double)",
          "package": "diagrams-lib",
          "signature": "P-\u003e(Double,Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:unp3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a 3D vector back into a triple of components.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Types",
          "name": "unr3",
          "package": "diagrams-lib",
          "signature": "R3 -\u003e (Double, Double, Double)",
          "source": "src/Diagrams-ThreeD-Types.html#unr3",
          "type": "function"
        },
        "index": {
          "description": "Convert vector back into triple of components",
          "hierarchy": "Diagrams ThreeD Types",
          "module": "Diagrams.ThreeD.Types",
          "name": "unr3",
          "normalized": "R-\u003e(Double,Double,Double)",
          "package": "diagrams-lib",
          "signature": "R-\u003e(Double,Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Types.html#v:unr3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThree-dimensional vectors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.ThreeD.Vector",
          "name": "Vector",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD-Vector.html",
          "type": "module"
        },
        "index": {
          "description": "Three-dimensional vectors",
          "hierarchy": "Diagrams ThreeD Vector",
          "module": "Diagrams.ThreeD.Vector",
          "name": "Vector",
          "package": "diagrams-lib",
          "partial": "Vector",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Vector.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecompute the positive angle between the two vectors in their common plane\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Vector",
          "name": "angleBetween",
          "package": "diagrams-lib",
          "signature": "R3 -\u003e R3 -\u003e a",
          "source": "src/Diagrams-ThreeD-Vector.html#angleBetween",
          "type": "function"
        },
        "index": {
          "description": "compute the positive angle between the two vectors in their common plane",
          "hierarchy": "Diagrams ThreeD Vector",
          "module": "Diagrams.ThreeD.Vector",
          "name": "angleBetween",
          "normalized": "R-\u003eR-\u003ea",
          "package": "diagrams-lib",
          "partial": "Between",
          "signature": "R-\u003eR-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Vector.html#v:angleBetween"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecompute the positive angle between the two vectors in their common plane\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Vector",
          "name": "angleBetweenDirs",
          "package": "diagrams-lib",
          "signature": "d -\u003e d -\u003e a",
          "source": "src/Diagrams-ThreeD-Vector.html#angleBetweenDirs",
          "type": "function"
        },
        "index": {
          "description": "compute the positive angle between the two vectors in their common plane",
          "hierarchy": "Diagrams ThreeD Vector",
          "module": "Diagrams.ThreeD.Vector",
          "name": "angleBetweenDirs",
          "normalized": "a-\u003ea-\u003eb",
          "package": "diagrams-lib",
          "partial": "Between Dirs",
          "signature": "d-\u003ed-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Vector.html#v:angleBetweenDirs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edirection v\u003c/code\u003e is the direction in which \u003ccode\u003ev\u003c/code\u003e points.  Returns an\n   unspecified value when given the zero vector as input.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Vector",
          "name": "direction",
          "package": "diagrams-lib",
          "signature": "R3 -\u003e d",
          "source": "src/Diagrams-ThreeD-Vector.html#direction",
          "type": "function"
        },
        "index": {
          "description": "direction is the direction in which points Returns an unspecified value when given the zero vector as input",
          "hierarchy": "Diagrams ThreeD Vector",
          "module": "Diagrams.ThreeD.Vector",
          "name": "direction",
          "normalized": "R-\u003ea",
          "package": "diagrams-lib",
          "signature": "R-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Vector.html#v:direction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efromDirection d\u003c/code\u003e is the unit vector in the direction \u003ccode\u003ed\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Vector",
          "name": "fromDirection",
          "package": "diagrams-lib",
          "signature": "d -\u003e R3",
          "source": "src/Diagrams-ThreeD-Vector.html#fromDirection",
          "type": "function"
        },
        "index": {
          "description": "fromDirection is the unit vector in the direction",
          "hierarchy": "Diagrams ThreeD Vector",
          "module": "Diagrams.ThreeD.Vector",
          "name": "fromDirection",
          "normalized": "a-\u003eR",
          "package": "diagrams-lib",
          "partial": "Direction",
          "signature": "d-\u003eR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Vector.html#v:fromDirection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit vector in the positive X direction.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Vector",
          "name": "unitX",
          "package": "diagrams-lib",
          "signature": "R3",
          "source": "src/Diagrams-ThreeD-Vector.html#unitX",
          "type": "function"
        },
        "index": {
          "description": "The unit vector in the positive direction",
          "hierarchy": "Diagrams ThreeD Vector",
          "module": "Diagrams.ThreeD.Vector",
          "name": "unitX",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Vector.html#v:unitX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit vector in the positive Y direction.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Vector",
          "name": "unitY",
          "package": "diagrams-lib",
          "signature": "R3",
          "source": "src/Diagrams-ThreeD-Vector.html#unitY",
          "type": "function"
        },
        "index": {
          "description": "The unit vector in the positive direction",
          "hierarchy": "Diagrams ThreeD Vector",
          "module": "Diagrams.ThreeD.Vector",
          "name": "unitY",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Vector.html#v:unitY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit vector in the positive Z direction.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Vector",
          "name": "unitZ",
          "package": "diagrams-lib",
          "signature": "R3",
          "source": "src/Diagrams-ThreeD-Vector.html#unitZ",
          "type": "function"
        },
        "index": {
          "description": "The unit vector in the positive direction",
          "hierarchy": "Diagrams ThreeD Vector",
          "module": "Diagrams.ThreeD.Vector",
          "name": "unitZ",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Vector.html#v:unitZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit vector in the negative X direction.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Vector",
          "name": "unit_X",
          "package": "diagrams-lib",
          "signature": "R3",
          "source": "src/Diagrams-ThreeD-Vector.html#unit_X",
          "type": "function"
        },
        "index": {
          "description": "The unit vector in the negative direction",
          "hierarchy": "Diagrams ThreeD Vector",
          "module": "Diagrams.ThreeD.Vector",
          "name": "unit_X",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Vector.html#v:unit_X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit vector in the negative Y direction.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Vector",
          "name": "unit_Y",
          "package": "diagrams-lib",
          "signature": "R3",
          "source": "src/Diagrams-ThreeD-Vector.html#unit_Y",
          "type": "function"
        },
        "index": {
          "description": "The unit vector in the negative direction",
          "hierarchy": "Diagrams ThreeD Vector",
          "module": "Diagrams.ThreeD.Vector",
          "name": "unit_Y",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Vector.html#v:unit_Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit vector in the negative Z direction.\n\u003c/p\u003e",
          "module": "Diagrams.ThreeD.Vector",
          "name": "unit_Z",
          "package": "diagrams-lib",
          "signature": "R3",
          "source": "src/Diagrams-ThreeD-Vector.html#unit_Z",
          "type": "function"
        },
        "index": {
          "description": "The unit vector in the negative direction",
          "hierarchy": "Diagrams ThreeD Vector",
          "module": "Diagrams.ThreeD.Vector",
          "name": "unit_Z",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD-Vector.html#v:unit_Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the three-dimensional vector space R^3,\n three-dimensional transformations, and various predefined\n three-dimensional shapes.  This module re-exports useful\n functionality from a group of more specific modules:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003eDiagrams.ThreeD.Types\u003c/a\u003e defines basic types for two-dimensional\n     diagrams, including types representing the 3D Euclidean vector\n     space and various systems of representing directions.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.ThreeD.Transform\u003c/a\u003e defines R^3-specific transformations\n     such as rotation by an angle, and scaling, translation, and\n     reflection in the X, Y, and Z directions.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.ThreeD.Shapes\u003c/a\u003e defines three-dimensional solids,\n     e.g. spheres and cubes.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.ThreeD.Vector\u003c/a\u003e defines some special 3D vectors and\n     functions for converting between vectors and directions.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.ThreeD.Light\u003c/a\u003e and \u003ca\u003eDiagrams.ThreeD.Camera\u003c/a\u003e define types needed\n     for rendering 3D geometry to (2D) images.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Diagrams.ThreeD",
          "name": "ThreeD",
          "package": "diagrams-lib",
          "source": "src/Diagrams-ThreeD.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the three-dimensional vector space three-dimensional transformations and various predefined three-dimensional shapes This module re-exports useful functionality from group of more specific modules Diagrams.ThreeD.Types defines basic types for two-dimensional diagrams including types representing the Euclidean vector space and various systems of representing directions Diagrams.ThreeD.Transform defines specific transformations such as rotation by an angle and scaling translation and reflection in the and directions Diagrams.ThreeD.Shapes defines three-dimensional solids e.g spheres and cubes Diagrams.ThreeD.Vector defines some special vectors and functions for converting between vectors and directions Diagrams.ThreeD.Light and Diagrams.ThreeD.Camera define types needed for rendering geometry to images",
          "hierarchy": "Diagrams ThreeD",
          "module": "Diagrams.ThreeD",
          "name": "ThreeD",
          "package": "diagrams-lib",
          "partial": "Three",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-ThreeD.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\"Traces\", aka embedded raytracers, for finding points on the edge\n of a diagram.  See \u003ca\u003eDiagrams.Core.Trace\u003c/a\u003e for internal\n implementation details.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Trace",
          "name": "Trace",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Trace.html",
          "type": "module"
        },
        "index": {
          "description": "Traces aka embedded raytracers for finding points on the edge of diagram See Diagrams.Core.Trace for internal implementation details",
          "hierarchy": "Diagrams Trace",
          "module": "Diagrams.Trace",
          "name": "Trace",
          "package": "diagrams-lib",
          "partial": "Trace",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trace.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery diagram comes equipped with a \u003cem\u003etrace\u003c/em\u003e.  Intuitively, the\n   trace for a diagram is like a raytracer: given a line\n   (represented as a base point and a direction), the trace computes\n   the distance from the base point along the line to the first\n   intersection with the diagram.  The distance can be negative if\n   the intersection is in the opposite direction from the base\n   point, or infinite if the ray never intersects the diagram.\n   Note: to obtain the distance to the \u003cem\u003efurthest\u003c/em\u003e intersection\n   instead of the \u003cem\u003eclosest\u003c/em\u003e, just negate the direction vector and\n   then negate the result.\n\u003c/p\u003e\u003cp\u003eNote that the output should actually be interpreted not as an\n   absolute distance, but as a multiplier relative to the input\n   vector.  That is, if the input vector is \u003ccode\u003ev\u003c/code\u003e and the returned\n   scalar is \u003ccode\u003es\u003c/code\u003e, the distance from the base point to the\n   intersection is given by \u003ccode\u003es * magnitude v\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Trace",
          "name": "Trace",
          "package": "diagrams-lib",
          "type": "data"
        },
        "index": {
          "description": "Every diagram comes equipped with trace Intuitively the trace for diagram is like raytracer given line represented as base point and direction the trace computes the distance from the base point along the line to the first intersection with the diagram The distance can be negative if the intersection is in the opposite direction from the base point or infinite if the ray never intersects the diagram Note to obtain the distance to the furthest intersection instead of the closest just negate the direction vector and then negate the result Note that the output should actually be interpreted not as an absolute distance but as multiplier relative to the input vector That is if the input vector is and the returned scalar is the distance from the base point to the intersection is given by magnitude",
          "hierarchy": "Diagrams Trace",
          "module": "Diagrams.Trace",
          "name": "Trace",
          "package": "diagrams-lib",
          "partial": "Trace",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trace.html#t:Trace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eTraced\u003c/code\u003e abstracts over things which have a trace.\n\u003c/p\u003e",
          "module": "Diagrams.Trace",
          "name": "Traced",
          "package": "diagrams-lib",
          "type": "class"
        },
        "index": {
          "description": "Traced abstracts over things which have trace",
          "hierarchy": "Diagrams Trace",
          "module": "Diagrams.Trace",
          "name": "Traced",
          "package": "diagrams-lib",
          "partial": "Traced",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trace.html#t:Traced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the furthest point on the boundary of a subdiagram,\n   beginning from the location (local origin) of the subdiagram and\n   moving in the direction of the given vector.  If there is no such\n   point, the origin is returned; see also \u003ccode\u003e\u003ca\u003eboundaryFromMay\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Trace",
          "name": "boundaryFrom",
          "package": "diagrams-lib",
          "signature": "Subdiagram b v m -\u003e v -\u003e Point v",
          "source": "src/Diagrams-Trace.html#boundaryFrom",
          "type": "function"
        },
        "index": {
          "description": "Compute the furthest point on the boundary of subdiagram beginning from the location local origin of the subdiagram and moving in the direction of the given vector If there is no such point the origin is returned see also boundaryFromMay",
          "hierarchy": "Diagrams Trace",
          "module": "Diagrams.Trace",
          "name": "boundaryFrom",
          "normalized": "Subdiagram a b c-\u003eb-\u003ePoint b",
          "package": "diagrams-lib",
          "partial": "From",
          "signature": "Subdiagram b v m-\u003ev-\u003ePoint v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trace.html#v:boundaryFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the furthest point on the boundary of a subdiagram,\n   beginning from the location (local origin) of the subdiagram and\n   moving in the direction of the given vector, or \u003ccode\u003eNothing\u003c/code\u003e if\n   there is no such point.\n\u003c/p\u003e",
          "module": "Diagrams.Trace",
          "name": "boundaryFromMay",
          "package": "diagrams-lib",
          "signature": "Subdiagram b v m -\u003e v -\u003e Maybe (Point v)",
          "source": "src/Diagrams-Trace.html#boundaryFromMay",
          "type": "function"
        },
        "index": {
          "description": "Compute the furthest point on the boundary of subdiagram beginning from the location local origin of the subdiagram and moving in the direction of the given vector or Nothing if there is no such point",
          "hierarchy": "Diagrams Trace",
          "module": "Diagrams.Trace",
          "name": "boundaryFromMay",
          "normalized": "Subdiagram a b c-\u003eb-\u003eMaybe(Point b)",
          "package": "diagrams-lib",
          "partial": "From May",
          "signature": "Subdiagram b v m-\u003ev-\u003eMaybe(Point v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trace.html#v:boundaryFromMay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003etraceP\u003c/a\u003e\u003c/code\u003e, but computes the *furthest* point on the boundary\n   instead of the closest.\n\u003c/p\u003e",
          "module": "Diagrams.Trace",
          "name": "maxTraceP",
          "package": "diagrams-lib",
          "signature": "Point (V a) -\u003e V a -\u003e a -\u003e Maybe (Point (V a))",
          "type": "function"
        },
        "index": {
          "description": "Like traceP but computes the furthest point on the boundary instead of the closest",
          "hierarchy": "Diagrams Trace",
          "module": "Diagrams.Trace",
          "name": "maxTraceP",
          "normalized": "Point(V a)-\u003eV a-\u003ea-\u003eMaybe(Point(V a))",
          "package": "diagrams-lib",
          "partial": "Trace",
          "signature": "Point(V a)-\u003eV a-\u003ea-\u003eMaybe(Point(V a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trace.html#v:maxTraceP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003etraceV\u003c/a\u003e\u003c/code\u003e, but computes a vector to the *furthest* point on\n   the boundary instead of the closest.\n\u003c/p\u003e",
          "module": "Diagrams.Trace",
          "name": "maxTraceV",
          "package": "diagrams-lib",
          "signature": "Point (V a) -\u003e V a -\u003e a -\u003e Maybe (V a)",
          "type": "function"
        },
        "index": {
          "description": "Like traceV but computes vector to the furthest point on the boundary instead of the closest",
          "hierarchy": "Diagrams Trace",
          "module": "Diagrams.Trace",
          "name": "maxTraceV",
          "normalized": "Point(V a)-\u003eV a-\u003ea-\u003eMaybe(V a)",
          "package": "diagrams-lib",
          "partial": "Trace",
          "signature": "Point(V a)-\u003eV a-\u003ea-\u003eMaybe(V a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trace.html#v:maxTraceV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the trace of a diagram.\n\u003c/p\u003e",
          "module": "Diagrams.Trace",
          "name": "setTrace",
          "package": "diagrams-lib",
          "signature": "Trace v -\u003e QDiagram b v m -\u003e QDiagram b v m",
          "type": "function"
        },
        "index": {
          "description": "Replace the trace of diagram",
          "hierarchy": "Diagrams Trace",
          "module": "Diagrams.Trace",
          "name": "setTrace",
          "normalized": "Trace a-\u003eQDiagram b a c-\u003eQDiagram b a c",
          "package": "diagrams-lib",
          "partial": "Trace",
          "signature": "Trace v-\u003eQDiagram b v m-\u003eQDiagram b v m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trace.html#v:setTrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the trace of a diagram.\n\u003c/p\u003e",
          "module": "Diagrams.Trace",
          "name": "trace",
          "package": "diagrams-lib",
          "signature": "Lens' (QDiagram b v m) (Trace v)",
          "type": "function"
        },
        "index": {
          "description": "Get the trace of diagram",
          "hierarchy": "Diagrams Trace",
          "module": "Diagrams.Trace",
          "name": "trace",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trace.html#v:trace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a base point and direction, compute the closest point on\n   the boundary of the given object, or \u003ccode\u003eNothing\u003c/code\u003e if there is no\n   intersection in the given direction.\n\u003c/p\u003e",
          "module": "Diagrams.Trace",
          "name": "traceP",
          "package": "diagrams-lib",
          "signature": "Point (V a) -\u003e V a -\u003e a -\u003e Maybe (Point (V a))",
          "type": "function"
        },
        "index": {
          "description": "Given base point and direction compute the closest point on the boundary of the given object or Nothing if there is no intersection in the given direction",
          "hierarchy": "Diagrams Trace",
          "module": "Diagrams.Trace",
          "name": "traceP",
          "normalized": "Point(V a)-\u003eV a-\u003ea-\u003eMaybe(Point(V a))",
          "package": "diagrams-lib",
          "signature": "Point(V a)-\u003eV a-\u003ea-\u003eMaybe(Point(V a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trace.html#v:traceP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the vector from the given point to the boundary of the\n   given object in the given direction, or \u003ccode\u003eNothing\u003c/code\u003e if there is no\n   intersection.\n\u003c/p\u003e",
          "module": "Diagrams.Trace",
          "name": "traceV",
          "package": "diagrams-lib",
          "signature": "Point (V a) -\u003e V a -\u003e a -\u003e Maybe (V a)",
          "type": "function"
        },
        "index": {
          "description": "Compute the vector from the given point to the boundary of the given object in the given direction or Nothing if there is no intersection",
          "hierarchy": "Diagrams Trace",
          "module": "Diagrams.Trace",
          "name": "traceV",
          "normalized": "Point(V a)-\u003eV a-\u003ea-\u003eMaybe(V a)",
          "package": "diagrams-lib",
          "signature": "Point(V a)-\u003eV a-\u003ea-\u003eMaybe(V a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trace.html#v:traceV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines \u003cem\u003etrails\u003c/em\u003e, translationally invariant paths\n through space.  Trails form a central part of the diagrams-lib API,\n so the documentation for this module merits careful study.\n\u003c/p\u003e\u003cp\u003eRelated modules include:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The \u003ccode\u003eTrailLike\u003c/code\u003e class (\u003ca\u003eDiagrams.TrailLike\u003c/a\u003e) exposes a generic\n   API for building a wide range of things out of trails.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ePath\u003c/code\u003es (\u003ca\u003eDiagrams.Path\u003c/a\u003e) are collections of \u003ccode\u003e\u003ca\u003eLocated\u003c/a\u003e\u003c/code\u003e\n   (\u003ca\u003eDiagrams.Located\u003c/a\u003e) trails.\n\u003c/li\u003e\u003cli\u003e Trails are composed of \u003ccode\u003e\u003ca\u003eSegment\u003c/a\u003e\u003c/code\u003es (see \u003ca\u003eDiagrams.Segment\u003c/a\u003e),\n   though most users should not need to work with segments directly.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Diagrams.Trail",
          "name": "Trail",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Trail.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines trails translationally invariant paths through space Trails form central part of the diagrams-lib API so the documentation for this module merits careful study Related modules include The TrailLike class Diagrams.TrailLike exposes generic API for building wide range of things out of trails Path Diagrams.Path are collections of Located Diagrams.Located trails Trails are composed of Segment see Diagrams.Segment though most users should not need to work with segments directly",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "Trail",
          "package": "diagrams-lib",
          "partial": "Trail",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA newtype wrapper around trails which exists solely for its\n   \u003ccode\u003e\u003ca\u003eParametric\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eDomainBounds\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eEndValues\u003c/a\u003e\u003c/code\u003e instances.  The idea\n   is that if \u003ccode\u003etr\u003c/code\u003e is a trail, you can write, \u003cem\u003ee.g.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n   getSegment tr \u003ccode\u003e\u003ca\u003eatParam\u003c/a\u003e\u003c/code\u003e 0.6\n\u003c/pre\u003e\u003cp\u003eor\n\u003c/p\u003e\u003cpre\u003e\n   atStart (getSegment tr)\n\u003c/pre\u003e\u003cp\u003eto get the segment at parameter 0.6 or the first segment in the\n   trail, respectively.\n\u003c/p\u003e\u003cp\u003eThe codomain for \u003ccode\u003e\u003ca\u003eGetSegment\u003c/a\u003e\u003c/code\u003e, \u003cem\u003ei.e.\u003c/em\u003e the result you get from\n   calling \u003ccode\u003e\u003ca\u003eatParam\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eatStart\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eatEnd\u003c/a\u003e\u003c/code\u003e, is \u003ccode\u003eMaybe (v, Segment\n   Closed v, AnIso' (Scalar v) (Scalar v))\u003c/code\u003e.  \u003ccode\u003eNothing\u003c/code\u003e results if\n   the trail is empty; otherwise, you get:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the offset from the start of the trail to the beginning of the\n     segment,\n\u003c/li\u003e\u003cli\u003e the segment itself, and\n\u003c/li\u003e\u003cli\u003e a reparameterization isomorphism: in the forward direction, it\n     translates from parameters on the whole trail to a parameters\n     on the segment.  Note that for technical reasons you have to\n     call \u003ccode\u003ecloneIso\u003c/code\u003e on the \u003ccode\u003eAnIso'\u003c/code\u003e value to get a real isomorphism\n     you can use.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Diagrams.Trail",
          "name": "GetSegment",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Trail.html#GetSegment",
          "type": "newtype"
        },
        "index": {
          "description": "newtype wrapper around trails which exists solely for its Parametric DomainBounds and EndValues instances The idea is that if tr is trail you can write e.g getSegment tr atParam or atStart getSegment tr to get the segment at parameter or the first segment in the trail respectively The codomain for GetSegment i.e the result you get from calling atParam atStart or atEnd is Maybe Segment Closed AnIso Scalar Scalar Nothing results if the trail is empty otherwise you get the offset from the start of the trail to the beginning of the segment the segment itself and reparameterization isomorphism in the forward direction it translates from parameters on the whole trail to parameters on the segment Note that for technical reasons you have to call cloneIso on the AnIso value to get real isomorphism you can use",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "GetSegment",
          "package": "diagrams-lib",
          "partial": "Get Segment",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#t:GetSegment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType tag for trails with distinct endpoints.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "Line",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Trail.html#Line",
          "type": "data"
        },
        "index": {
          "description": "Type tag for trails with distinct endpoints",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "Line",
          "package": "diagrams-lib",
          "partial": "Line",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#t:Line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType tag for \"loopy\" trails which return to their starting\n   point.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "Loop",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Trail.html#Loop",
          "type": "data"
        },
        "index": {
          "description": "Type tag for loopy trails which return to their starting point",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "Loop",
          "package": "diagrams-lib",
          "partial": "Loop",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#t:Loop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003eSegTree\u003c/code\u003e represents a sequence of closed segments, stored in a\n   fingertree so we can easily recover various monoidal measures of\n   the segments (number of segments, arc length, envelope...) and\n   also easily slice and dice them according to the measures\n   (\u003cem\u003ee.g.\u003c/em\u003e, split off the smallest number of segments from the\n   beginning which have a combined arc length of at least 5).\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "SegTree",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Trail.html#SegTree",
          "type": "newtype"
        },
        "index": {
          "description": "SegTree represents sequence of closed segments stored in fingertree so we can easily recover various monoidal measures of the segments number of segments arc length envelope and also easily slice and dice them according to the measures e.g split off the smallest number of segments from the beginning which have combined arc length of at least",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "SegTree",
          "package": "diagrams-lib",
          "partial": "Seg Tree",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#t:SegTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eTrail\u003c/code\u003e is a wrapper around \u003ccode\u003eTrail'\u003c/code\u003e, hiding whether the\n   underlying \u003ccode\u003eTrail'\u003c/code\u003e is a line or loop (though which it is can be\n   recovered; see \u003cem\u003ee.g.\u003c/em\u003e \u003ccode\u003e\u003ca\u003ewithTrail\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "Trail",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Trail.html#Trail",
          "type": "data"
        },
        "index": {
          "description": "Trail is wrapper around Trail hiding whether the underlying Trail is line or loop though which it is can be recovered see e.g withTrail",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "Trail",
          "package": "diagrams-lib",
          "partial": "Trail",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#t:Trail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntuitively, a trail is a single, continuous path through space.\n   However, a trail has no fixed starting point; it merely specifies\n   \u003cem\u003ehow\u003c/em\u003e to move through space, not \u003cem\u003ewhere\u003c/em\u003e.  For example, \"take\n   three steps forward, then turn right twenty degrees and take two\n   more steps\" is an intuitive analog of a trail; these\n   instructions specify a path through space from any given starting\n   location.  To be precise, trails are \u003cem\u003etranslation-invariant\u003c/em\u003e;\n   applying a translation to a trail has no effect.\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ccode\u003e\u003ca\u003eLocated\u003c/a\u003e\u003c/code\u003e Trail\u003c/code\u003e, on the other hand, is a trail paired with\n   some concrete starting location (\"start at the big tree on the\n   corner, then take three steps forward, ...\").  See the\n   \u003ca\u003eDiagrams.Located\u003c/a\u003e module for help working with \u003ccode\u003e\u003ca\u003eLocated\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e\u003cp\u003eFormally, the semantics of a trail is a continuous (though not\n   necessarily differentiable) function from the real interval [0,1]\n   to vectors in some vector space.  (In contrast, a \u003ccode\u003e\u003ca\u003eLocated\u003c/a\u003e\u003c/code\u003e trail\n   is a continuous function from [0,1] to \u003cem\u003epoints\u003c/em\u003e in some \u003cem\u003eaffine\u003c/em\u003e\n   space.)\n\u003c/p\u003e\u003cp\u003eThere are two types of trails:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e A \"line\" (think of the \"train\", \"subway\", or \"bus\"\n     variety, rather than the \"straight\" variety...) is a trail\n     with two distinct endpoints.  Actually, a line can have the\n     same start and end points, but it is still \u003cem\u003edrawn\u003c/em\u003e as if it had\n     distinct endpoints: the two endpoints will have the appropriate\n     end caps, and the trail will not be filled.  Lines have a\n     \u003ccode\u003eMonoid\u003c/code\u003e instance where \u003ccode\u003emappend\u003c/code\u003e corresponds to concatenation,\n     \u003cem\u003ei.e.\u003c/em\u003e chaining one line after the other.\n\u003c/li\u003e\u003cli\u003e A \"loop\" is required to end in the same place it starts (that\n     is, t(0) = t(1)).  Loops are filled and are drawn as one\n     continuous loop, with the appropriate join at the\n     start/endpoint rather than end caps.  Loops do not have a\n     \u003ccode\u003eMonoid\u003c/code\u003e instance.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eTo convert between lines and loops, see \u003ccode\u003e\u003ca\u003eglueLine\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003ecloseLine\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003ecutLoop\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eTo construct trails, see \u003ccode\u003e\u003ca\u003eemptyTrail\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003etrailFromSegments\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003etrailFromVertices\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003etrailFromOffsets\u003c/a\u003e\u003c/code\u003e, and friends.  You can\n   also get any type of trail from any function which returns a\n   \u003ccode\u003eTrailLike\u003c/code\u003e (\u003cem\u003ee.g.\u003c/em\u003e functions in \u003ca\u003eDiagrams.TwoD.Shapes\u003c/a\u003e, and many\n   others; see \u003ca\u003eDiagrams.TrailLike\u003c/a\u003e).\n\u003c/p\u003e\u003cp\u003eTo extract information from trails, see \u003ccode\u003e\u003ca\u003ewithLine\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eisLoop\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003etrailSegments\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003etrailOffsets\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003etrailVertices\u003c/a\u003e\u003c/code\u003e, and friends.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "Trail'",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Trail.html#Trail%27",
          "type": "data"
        },
        "index": {
          "description": "Intuitively trail is single continuous path through space However trail has no fixed starting point it merely specifies how to move through space not where For example take three steps forward then turn right twenty degrees and take two more steps is an intuitive analog of trail these instructions specify path through space from any given starting location To be precise trails are translation-invariant applying translation to trail has no effect Located Trail on the other hand is trail paired with some concrete starting location start at the big tree on the corner then take three steps forward See the Diagrams.Located module for help working with Located values Formally the semantics of trail is continuous though not necessarily differentiable function from the real interval to vectors in some vector space In contrast Located trail is continuous function from to points in some affine space There are two types of trails line think of the train subway or bus variety rather than the straight variety is trail with two distinct endpoints Actually line can have the same start and end points but it is still drawn as if it had distinct endpoints the two endpoints will have the appropriate end caps and the trail will not be filled Lines have Monoid instance where mappend corresponds to concatenation i.e chaining one line after the other loop is required to end in the same place it starts that is Loops are filled and are drawn as one continuous loop with the appropriate join at the start endpoint rather than end caps Loops do not have Monoid instance To convert between lines and loops see glueLine closeLine and cutLoop To construct trails see emptyTrail trailFromSegments trailFromVertices trailFromOffsets and friends You can also get any type of trail from any function which returns TrailLike e.g functions in Diagrams.TwoD.Shapes and many others see Diagrams.TrailLike To extract information from trails see withLine isLoop trailSegments trailOffsets trailVertices and friends",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "Trail'",
          "package": "diagrams-lib",
          "partial": "Trail'",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#t:Trail-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Trail",
          "name": "GetSegment",
          "package": "diagrams-lib",
          "signature": "GetSegment t",
          "source": "src/Diagrams-Trail.html#GetSegment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "GetSegment",
          "package": "diagrams-lib",
          "partial": "Get Segment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:GetSegment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Trail",
          "name": "Line",
          "package": "diagrams-lib",
          "signature": "SegTree v -\u003e Trail' Line v",
          "source": "src/Diagrams-Trail.html#Trail%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "Line",
          "normalized": "SegTree a-\u003eTrail' Line a",
          "package": "diagrams-lib",
          "partial": "Line",
          "signature": "SegTree v-\u003eTrail' Line v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:Line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Trail",
          "name": "Loop",
          "package": "diagrams-lib",
          "signature": "SegTree v -\u003e Segment Open v -\u003e Trail' Loop v",
          "source": "src/Diagrams-Trail.html#Trail%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "Loop",
          "normalized": "SegTree a-\u003eSegment Open a-\u003eTrail' Loop a",
          "package": "diagrams-lib",
          "partial": "Loop",
          "signature": "SegTree v-\u003eSegment Open v-\u003eTrail' Loop v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:Loop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Trail",
          "name": "SegTree",
          "package": "diagrams-lib",
          "signature": "SegTree (FingerTree (SegMeasure v) (Segment Closed v))",
          "source": "src/Diagrams-Trail.html#SegTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "SegTree",
          "package": "diagrams-lib",
          "partial": "Seg Tree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:SegTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Trail",
          "name": "Trail",
          "package": "diagrams-lib",
          "signature": "Trail' l v -\u003e Trail v",
          "source": "src/Diagrams-Trail.html#Trail",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "Trail",
          "normalized": "Trail' a b-\u003eTrail b",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "Trail' l v-\u003eTrail v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:Trail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a line into a loop by adding a new linear segment from the\n   line's end to its start.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ecloseLine\u003c/code\u003e does not have any particularly nice theoretical\n   properties, but can be useful \u003cem\u003ee.g.\u003c/em\u003e when you want to make a\n   closed polygon out of a list of points where the initial point is\n   not repeated at the end.  To use \u003ccode\u003e\u003ca\u003eglueLine\u003c/a\u003e\u003c/code\u003e, one would first have\n   to duplicate the initial vertex, like\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eglueLine\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003elineFromVertices\u003c/a\u003e\u003c/code\u003e $ ps ++ [head ps]\n\u003c/pre\u003e\u003cp\u003eUsing \u003ccode\u003ecloseLine\u003c/code\u003e, however, one can simply\n\u003c/p\u003e\u003cpre\u003e\n closeLine . lineFromVertices $ ps\n\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_Trail_closeLineEx.svg#diagram=closeLineEx&width=500\"/\u003e\n\u003c/p\u003e\u003cpre\u003e closeLineEx = pad 1.1 . centerXY . hcat' (with & sep .~ 1)\n   $ [almostClosed # strokeLine, almostClosed # closeLine # strokeLoop]\n\u003c/pre\u003e",
          "module": "Diagrams.Trail",
          "name": "closeLine",
          "package": "diagrams-lib",
          "signature": "Trail' Line v -\u003e Trail' Loop v",
          "source": "src/Diagrams-Trail.html#closeLine",
          "type": "function"
        },
        "index": {
          "description": "Make line into loop by adding new linear segment from the line end to its start closeLine does not have any particularly nice theoretical properties but can be useful e.g when you want to make closed polygon out of list of points where the initial point is not repeated at the end To use glueLine one would first have to duplicate the initial vertex like glueLine lineFromVertices ps head ps Using closeLine however one can simply closeLine lineFromVertices ps closeLineEx pad centerXY hcat with sep almostClosed strokeLine almostClosed closeLine strokeLoop",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "closeLine",
          "normalized": "Trail' Line a-\u003eTrail' Loop a",
          "package": "diagrams-lib",
          "partial": "Line",
          "signature": "Trail' Line v-\u003eTrail' Loop v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:closeLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecloseTrail\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003ecloseLine\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e, which\n   performs \u003ccode\u003e\u003ca\u003ecloseLine\u003c/a\u003e\u003c/code\u003e on lines and is the identity on loops.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "closeTrail",
          "package": "diagrams-lib",
          "signature": "Trail v -\u003e Trail v",
          "source": "src/Diagrams-Trail.html#closeTrail",
          "type": "function"
        },
        "index": {
          "description": "closeTrail is variant of closeLine for Trail which performs closeLine on lines and is the identity on loops",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "closeTrail",
          "normalized": "Trail a-\u003eTrail a",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "Trail v-\u003eTrail v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:closeTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn a loop into a line by \"cutting\" it at the common start/end\n   point, resulting in a line which just happens to start and end at\n   the same place.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ecutLoop\u003c/code\u003e is right inverse to \u003ccode\u003e\u003ca\u003eglueLine\u003c/a\u003e\u003c/code\u003e, that is,\n\u003c/p\u003e\u003cpre\u003e\n   glueLine . cutLoop === id\n\u003c/pre\u003e",
          "module": "Diagrams.Trail",
          "name": "cutLoop",
          "package": "diagrams-lib",
          "signature": "Trail' Loop v -\u003e Trail' Line v",
          "source": "src/Diagrams-Trail.html#cutLoop",
          "type": "function"
        },
        "index": {
          "description": "Turn loop into line by cutting it at the common start end point resulting in line which just happens to start and end at the same place cutLoop is right inverse to glueLine that is glueLine cutLoop id",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "cutLoop",
          "normalized": "Trail' Loop a-\u003eTrail' Line a",
          "package": "diagrams-lib",
          "partial": "Loop",
          "signature": "Trail' Loop v-\u003eTrail' Line v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:cutLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecutTrail\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003ecutLoop\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e; it is the is\n   the identity on lines and performs \u003ccode\u003e\u003ca\u003ecutLoop\u003c/a\u003e\u003c/code\u003e on loops.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "cutTrail",
          "package": "diagrams-lib",
          "signature": "Trail v -\u003e Trail v",
          "source": "src/Diagrams-Trail.html#cutTrail",
          "type": "function"
        },
        "index": {
          "description": "cutTrail is variant of cutLoop for Trail it is the is the identity on lines and performs cutLoop on loops",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "cutTrail",
          "normalized": "Trail a-\u003eTrail a",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "Trail v-\u003eTrail v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:cutTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty line, which is the identity for concatenation of lines.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "emptyLine",
          "package": "diagrams-lib",
          "signature": "Trail' Line v",
          "source": "src/Diagrams-Trail.html#emptyLine",
          "type": "function"
        },
        "index": {
          "description": "The empty line which is the identity for concatenation of lines",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "emptyLine",
          "package": "diagrams-lib",
          "partial": "Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:emptyLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA wrapped variant of \u003ccode\u003e\u003ca\u003eemptyLine\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "emptyTrail",
          "package": "diagrams-lib",
          "signature": "Trail v",
          "source": "src/Diagrams-Trail.html#emptyTrail",
          "type": "function"
        },
        "index": {
          "description": "wrapped variant of emptyLine",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "emptyTrail",
          "package": "diagrams-lib",
          "partial": "Trail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:emptyTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a concretely located trail into a list of fixed segments.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "fixTrail",
          "package": "diagrams-lib",
          "signature": "Located (Trail v) -\u003e [FixedSegment v]",
          "source": "src/Diagrams-Trail.html#fixTrail",
          "type": "function"
        },
        "index": {
          "description": "Convert concretely located trail into list of fixed segments",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "fixTrail",
          "normalized": "Located(Trail a)-\u003e[FixedSegment a]",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "Located(Trail v)-\u003e[FixedSegment v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:fixTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a \u003ccode\u003e\u003ca\u003eGetSegment\u003c/a\u003e\u003c/code\u003e wrapper around a trail, after which you can\n   call \u003ccode\u003e\u003ca\u003eatParam\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eatStart\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eatEnd\u003c/a\u003e\u003c/code\u003e to extract a segment.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "getSegment",
          "package": "diagrams-lib",
          "signature": "t -\u003e GetSegment t",
          "source": "src/Diagrams-Trail.html#getSegment",
          "type": "function"
        },
        "index": {
          "description": "Create GetSegment wrapper around trail after which you can call atParam atStart or atEnd to extract segment",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "getSegment",
          "normalized": "a-\u003eGetSegment a",
          "package": "diagrams-lib",
          "partial": "Segment",
          "signature": "t-\u003eGetSegment t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:getSegment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a line into a loop by \"gluing\" the endpoint to the\n   starting point.  In particular, the offset of the final segment\n   is modified so that it ends at the starting point of the entire\n   trail.  Typically, you would first construct a line which you\n   know happens to end where it starts, and then call \u003ccode\u003e\u003ca\u003eglueLine\u003c/a\u003e\u003c/code\u003e to\n   turn it into a loop.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_Trail_glueLineEx.svg#diagram=glueLineEx&width=500\"/\u003e\n\u003c/p\u003e\u003cpre\u003e glueLineEx = pad 1.1 . hcat' (with & sep .~ 1)\n   $ [almostClosed # strokeLine, almostClosed # glueLine # strokeLoop]\n\n almostClosed :: Trail' Line R2\n almostClosed = fromOffsets $ map r2 [(2, -1), (-3, -0.5), (-2, 1), (1, 0.5)]\n\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eglueLine\u003c/code\u003e is left inverse to \u003ccode\u003e\u003ca\u003ecutLoop\u003c/a\u003e\u003c/code\u003e, that is,\n\u003c/p\u003e\u003cpre\u003e\n   glueLine . cutLoop === id\n\u003c/pre\u003e",
          "module": "Diagrams.Trail",
          "name": "glueLine",
          "package": "diagrams-lib",
          "signature": "Trail' Line v -\u003e Trail' Loop v",
          "source": "src/Diagrams-Trail.html#glueLine",
          "type": "function"
        },
        "index": {
          "description": "Make line into loop by gluing the endpoint to the starting point In particular the offset of the final segment is modified so that it ends at the starting point of the entire trail Typically you would first construct line which you know happens to end where it starts and then call glueLine to turn it into loop glueLineEx pad hcat with sep almostClosed strokeLine almostClosed glueLine strokeLoop almostClosed Trail Line R2 almostClosed fromOffsets map r2 glueLine is left inverse to cutLoop that is glueLine cutLoop id",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "glueLine",
          "normalized": "Trail' Line a-\u003eTrail' Loop a",
          "package": "diagrams-lib",
          "partial": "Line",
          "signature": "Trail' Line v-\u003eTrail' Loop v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:glueLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eglueTrail\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003eglueLine\u003c/a\u003e\u003c/code\u003e which works on \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003es.\n   It performs \u003ccode\u003e\u003ca\u003eglueLine\u003c/a\u003e\u003c/code\u003e on lines and is the identity on loops.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "glueTrail",
          "package": "diagrams-lib",
          "signature": "Trail v -\u003e Trail v",
          "source": "src/Diagrams-Trail.html#glueTrail",
          "type": "function"
        },
        "index": {
          "description": "glueTrail is variant of glueLine which works on Trail It performs glueLine on lines and is the identity on loops",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "glueTrail",
          "normalized": "Trail a-\u003eTrail a",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "Trail v-\u003eTrail v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:glueTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine whether a trail is a line.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "isLine",
          "package": "diagrams-lib",
          "signature": "Trail v -\u003e Bool",
          "source": "src/Diagrams-Trail.html#isLine",
          "type": "function"
        },
        "index": {
          "description": "Determine whether trail is line",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "isLine",
          "normalized": "Trail a-\u003eBool",
          "package": "diagrams-lib",
          "partial": "Line",
          "signature": "Trail v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:isLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether a line is empty.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "isLineEmpty",
          "package": "diagrams-lib",
          "signature": "Trail' Line v -\u003e Bool",
          "source": "src/Diagrams-Trail.html#isLineEmpty",
          "type": "function"
        },
        "index": {
          "description": "Test whether line is empty",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "isLineEmpty",
          "normalized": "Trail' Line a-\u003eBool",
          "package": "diagrams-lib",
          "partial": "Line Empty",
          "signature": "Trail' Line v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:isLineEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine whether a trail is a loop.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "isLoop",
          "package": "diagrams-lib",
          "signature": "Trail v -\u003e Bool",
          "source": "src/Diagrams-Trail.html#isLoop",
          "type": "function"
        },
        "index": {
          "description": "Determine whether trail is loop",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "isLoop",
          "normalized": "Trail a-\u003eBool",
          "package": "diagrams-lib",
          "partial": "Loop",
          "signature": "Trail v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:isLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether a trail is empty.  Note that loops are never empty.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "isTrailEmpty",
          "package": "diagrams-lib",
          "signature": "Trail v -\u003e Bool",
          "source": "src/Diagrams-Trail.html#isTrailEmpty",
          "type": "function"
        },
        "index": {
          "description": "Test whether trail is empty Note that loops are never empty",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "isTrailEmpty",
          "normalized": "Trail a-\u003eBool",
          "package": "diagrams-lib",
          "partial": "Trail Empty",
          "signature": "Trail v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:isTrailEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a line containing only linear segments from a list of\n   vectors, where each vector represents the offset from one vertex\n   to the next.  See also \u003ccode\u003efromOffsets\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_Trail_lineFromOffsetsEx.svg#diagram=lineFromOffsetsEx&width=300\"/\u003e\n\u003c/p\u003e\u003cpre\u003e import Diagrams.Coordinates\n lineFromOffsetsEx = strokeLine $ lineFromOffsets [ 2 ^& 1, 2 ^& (-1), 2 ^& 0.5 ]\n\u003c/pre\u003e",
          "module": "Diagrams.Trail",
          "name": "lineFromOffsets",
          "package": "diagrams-lib",
          "signature": "[v] -\u003e Trail' Line v",
          "source": "src/Diagrams-Trail.html#lineFromOffsets",
          "type": "function"
        },
        "index": {
          "description": "Construct line containing only linear segments from list of vectors where each vector represents the offset from one vertex to the next See also fromOffsets import Diagrams.Coordinates lineFromOffsetsEx strokeLine lineFromOffsets",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "lineFromOffsets",
          "normalized": "[a]-\u003eTrail' Line a",
          "package": "diagrams-lib",
          "partial": "From Offsets",
          "signature": "[v]-\u003eTrail' Line v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:lineFromOffsets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a line from a list of closed segments.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "lineFromSegments",
          "package": "diagrams-lib",
          "signature": "[Segment Closed v] -\u003e Trail' Line v",
          "source": "src/Diagrams-Trail.html#lineFromSegments",
          "type": "function"
        },
        "index": {
          "description": "Construct line from list of closed segments",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "lineFromSegments",
          "normalized": "[Segment Closed a]-\u003eTrail' Line a",
          "package": "diagrams-lib",
          "partial": "From Segments",
          "signature": "[Segment Closed v]-\u003eTrail' Line v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:lineFromSegments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a line containing only linear segments from a list of\n   vertices.  Note that only the relative offsets between the\n   vertices matters; the information about their absolute position\n   will be discarded.  That is, for all vectors \u003ccode\u003ev\u003c/code\u003e,\n\u003c/p\u003e\u003cpre\u003e\n lineFromVertices === lineFromVertices . \u003ccode\u003e\u003ca\u003etranslate\u003c/a\u003e\u003c/code\u003e v\n\u003c/pre\u003e\u003cp\u003eIf you want to retain the position information, you should\n   instead use the more general \u003ccode\u003efromVertices\u003c/code\u003e function to\n   construct, say, a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eLocated\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eTrail'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLine\u003c/a\u003e\u003c/code\u003e v)\u003c/code\u003e or a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eLocated\u003c/a\u003e\u003c/code\u003e\n   (\u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e v)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_Trail_lineFromVerticesEx.svg#diagram=lineFromVerticesEx&width=300\"/\u003e\n\u003c/p\u003e\u003cpre\u003e import Diagrams.Coordinates\n lineFromVerticesEx = pad 1.1 . centerXY . strokeLine\n   $ lineFromVertices [origin, 0 ^& 1, 1 ^& 2, 5 ^& 1]\n\u003c/pre\u003e",
          "module": "Diagrams.Trail",
          "name": "lineFromVertices",
          "package": "diagrams-lib",
          "signature": "[Point v] -\u003e Trail' Line v",
          "source": "src/Diagrams-Trail.html#lineFromVertices",
          "type": "function"
        },
        "index": {
          "description": "Construct line containing only linear segments from list of vertices Note that only the relative offsets between the vertices matters the information about their absolute position will be discarded That is for all vectors lineFromVertices lineFromVertices translate If you want to retain the position information you should instead use the more general fromVertices function to construct say Located Trail Line or Located Trail import Diagrams.Coordinates lineFromVerticesEx pad centerXY strokeLine lineFromVertices origin",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "lineFromVertices",
          "normalized": "[Point a]-\u003eTrail' Line a",
          "package": "diagrams-lib",
          "partial": "From Vertices",
          "signature": "[Point v]-\u003eTrail' Line v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:lineFromVertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the offset from the start of a line to the end.  (Note,\n   there is no corresponding \u003ccode\u003eloopOffset\u003c/code\u003e function because by\n   definition it would be constantly zero.)\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "lineOffset",
          "package": "diagrams-lib",
          "signature": "Trail' Line v -\u003e v",
          "source": "src/Diagrams-Trail.html#lineOffset",
          "type": "function"
        },
        "index": {
          "description": "Compute the offset from the start of line to the end Note there is no corresponding loopOffset function because by definition it would be constantly zero",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "lineOffset",
          "normalized": "Trail' Line a-\u003ea",
          "package": "diagrams-lib",
          "partial": "Offset",
          "signature": "Trail' Line v-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:lineOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the offsets of the segments of a line.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "lineOffsets",
          "package": "diagrams-lib",
          "signature": "Trail' Line v -\u003e [v]",
          "source": "src/Diagrams-Trail.html#lineOffsets",
          "type": "function"
        },
        "index": {
          "description": "Extract the offsets of the segments of line",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "lineOffsets",
          "normalized": "Trail' Line a-\u003e[a]",
          "package": "diagrams-lib",
          "partial": "Offsets",
          "signature": "Trail' Line v-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:lineOffsets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the segments comprising a line.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "lineSegments",
          "package": "diagrams-lib",
          "signature": "Trail' Line v -\u003e [Segment Closed v]",
          "source": "src/Diagrams-Trail.html#lineSegments",
          "type": "function"
        },
        "index": {
          "description": "Extract the segments comprising line",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "lineSegments",
          "normalized": "Trail' Line a-\u003e[Segment Closed a]",
          "package": "diagrams-lib",
          "partial": "Segments",
          "signature": "Trail' Line v-\u003e[Segment Closed v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:lineSegments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the vertices of a concretely located line.  See\n   \u003ccode\u003e\u003ca\u003etrailVertices\u003c/a\u003e\u003c/code\u003e for more information.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "lineVertices",
          "package": "diagrams-lib",
          "signature": "Located (Trail' Line v) -\u003e [Point v]",
          "source": "src/Diagrams-Trail.html#lineVertices",
          "type": "function"
        },
        "index": {
          "description": "Extract the vertices of concretely located line See trailVertices for more information",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "lineVertices",
          "normalized": "Located(Trail' Line a)-\u003e[Point a]",
          "package": "diagrams-lib",
          "partial": "Vertices",
          "signature": "Located(Trail' Line v)-\u003e[Point v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:lineVertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the offsets of the segments of a loop.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "loopOffsets",
          "package": "diagrams-lib",
          "signature": "Trail' Loop v -\u003e [v]",
          "source": "src/Diagrams-Trail.html#loopOffsets",
          "type": "function"
        },
        "index": {
          "description": "Extract the offsets of the segments of loop",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "loopOffsets",
          "normalized": "Trail' Loop a-\u003e[a]",
          "package": "diagrams-lib",
          "partial": "Offsets",
          "signature": "Trail' Loop v-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:loopOffsets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the segments comprising a loop: a list of closed\n   segments, and one final open segment.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "loopSegments",
          "package": "diagrams-lib",
          "signature": "Trail' Loop v -\u003e ([Segment Closed v], Segment Open v)",
          "source": "src/Diagrams-Trail.html#loopSegments",
          "type": "function"
        },
        "index": {
          "description": "Extract the segments comprising loop list of closed segments and one final open segment",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "loopSegments",
          "normalized": "Trail' Loop a-\u003e([Segment Closed a],Segment Open a)",
          "package": "diagrams-lib",
          "partial": "Segments",
          "signature": "Trail' Loop v-\u003e([Segment Closed v],Segment Open v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:loopSegments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the vertices of a concretely located loop.  Note that the\n   initial vertex is not repeated at the end.  See \u003ccode\u003e\u003ca\u003etrailVertices\u003c/a\u003e\u003c/code\u003e for\n   more information.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "loopVertices",
          "package": "diagrams-lib",
          "signature": "Located (Trail' Loop v) -\u003e [Point v]",
          "source": "src/Diagrams-Trail.html#loopVertices",
          "type": "function"
        },
        "index": {
          "description": "Extract the vertices of concretely located loop Note that the initial vertex is not repeated at the end See trailVertices for more information",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "loopVertices",
          "normalized": "Located(Trail' Loop a)-\u003e[Point a]",
          "package": "diagrams-lib",
          "partial": "Vertices",
          "signature": "Located(Trail' Loop v)-\u003e[Point v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:loopVertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the number of segments of anything measured by\n   \u003ccode\u003e\u003ca\u003eSegMeasure\u003c/a\u003e\u003c/code\u003e (\u003cem\u003ee.g.\u003c/em\u003e \u003ccode\u003eSegMeasure\u003c/code\u003e itself, \u003ccode\u003eSegment\u003c/code\u003e, \u003ccode\u003eSegTree\u003c/code\u003e,\n   \u003ccode\u003eTrail\u003c/code\u003es...)\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "numSegs",
          "package": "diagrams-lib",
          "signature": "a -\u003e c",
          "source": "src/Diagrams-Trail.html#numSegs",
          "type": "function"
        },
        "index": {
          "description": "Compute the number of segments of anything measured by SegMeasure e.g SegMeasure itself Segment SegTree Trail",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "numSegs",
          "normalized": "a-\u003eb",
          "package": "diagrams-lib",
          "partial": "Segs",
          "signature": "a-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:numSegs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the total offset of anything measured by \u003ccode\u003e\u003ca\u003eSegMeasure\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "offset",
          "package": "diagrams-lib",
          "signature": "t -\u003e v",
          "source": "src/Diagrams-Trail.html#offset",
          "type": "function"
        },
        "index": {
          "description": "Compute the total offset of anything measured by SegMeasure",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "offset",
          "normalized": "a-\u003eb",
          "package": "diagrams-lib",
          "signature": "t-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:offset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify a \u003ccode\u003eTrail\u003c/code\u003e by specifying a transformation on lines.  If the\n   trail is a line, the transformation will be applied directly.  If\n   it is a loop, it will first be cut using \u003ccode\u003e\u003ca\u003ecutLoop\u003c/a\u003e\u003c/code\u003e, the\n   transformation applied, and then glued back into a loop with\n   \u003ccode\u003e\u003ca\u003eglueLine\u003c/a\u003e\u003c/code\u003e.  That is,\n\u003c/p\u003e\u003cpre\u003e\n   onLine f === onTrail f (glueLine . f . cutLoop)\n\u003c/pre\u003e\u003cp\u003eNote that there is no corresponding \u003ccode\u003eonLoop\u003c/code\u003e function, because\n   there is no nice way in general to convert a line into a loop,\n   operate on it, and then convert back.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "onLine",
          "package": "diagrams-lib",
          "signature": "(Trail' Line v -\u003e Trail' Line v) -\u003e Trail v -\u003e Trail v",
          "source": "src/Diagrams-Trail.html#onLine",
          "type": "function"
        },
        "index": {
          "description": "Modify Trail by specifying transformation on lines If the trail is line the transformation will be applied directly If it is loop it will first be cut using cutLoop the transformation applied and then glued back into loop with glueLine That is onLine onTrail glueLine cutLoop Note that there is no corresponding onLoop function because there is no nice way in general to convert line into loop operate on it and then convert back",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "onLine",
          "normalized": "(Trail' Line a-\u003eTrail' Line a)-\u003eTrail a-\u003eTrail a",
          "package": "diagrams-lib",
          "partial": "Line",
          "signature": "(Trail' Line v-\u003eTrail' Line v)-\u003eTrail v-\u003eTrail v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:onLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify a line by applying a function to its list of segments.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "onLineSegments",
          "package": "diagrams-lib",
          "signature": "([Segment Closed v] -\u003e [Segment Closed v]) -\u003e Trail' Line v -\u003e Trail' Line v",
          "source": "src/Diagrams-Trail.html#onLineSegments",
          "type": "function"
        },
        "index": {
          "description": "Modify line by applying function to its list of segments",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "onLineSegments",
          "normalized": "([Segment Closed a]-\u003e[Segment Closed a])-\u003eTrail' Line a-\u003eTrail' Line a",
          "package": "diagrams-lib",
          "partial": "Line Segments",
          "signature": "([Segment Closed v]-\u003e[Segment Closed v])-\u003eTrail' Line v-\u003eTrail' Line v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:onLineSegments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify a \u003ccode\u003eTrail\u003c/code\u003e, specifying two separate transformations for the\n   cases of a line or a loop.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "onTrail",
          "package": "diagrams-lib",
          "signature": "(Trail' Line v -\u003e Trail' l1 v) -\u003e (Trail' Loop v -\u003e Trail' l2 v) -\u003e Trail v -\u003e Trail v",
          "source": "src/Diagrams-Trail.html#onTrail",
          "type": "function"
        },
        "index": {
          "description": "Modify Trail specifying two separate transformations for the cases of line or loop",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "onTrail",
          "normalized": "(Trail' Line a-\u003eTrail' b a)-\u003e(Trail' Loop a-\u003eTrail' b a)-\u003eTrail a-\u003eTrail a",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "(Trail' Line v-\u003eTrail' l v)-\u003e(Trail' Loop v-\u003eTrail' l v)-\u003eTrail v-\u003eTrail v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:onTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse a line.  See \u003ccode\u003e\u003ca\u003ereverseTrail\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "reverseLine",
          "package": "diagrams-lib",
          "signature": "Trail' Line v -\u003e Trail' Line v",
          "source": "src/Diagrams-Trail.html#reverseLine",
          "type": "function"
        },
        "index": {
          "description": "Reverse line See reverseTrail",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "reverseLine",
          "normalized": "Trail' Line a-\u003eTrail' Line a",
          "package": "diagrams-lib",
          "partial": "Line",
          "signature": "Trail' Line v-\u003eTrail' Line v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:reverseLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse a concretely located line.  See \u003ccode\u003e\u003ca\u003ereverseLocTrail\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "reverseLocLine",
          "package": "diagrams-lib",
          "signature": "Located (Trail' Line v) -\u003e Located (Trail' Line v)",
          "source": "src/Diagrams-Trail.html#reverseLocLine",
          "type": "function"
        },
        "index": {
          "description": "Reverse concretely located line See reverseLocTrail",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "reverseLocLine",
          "normalized": "Located(Trail' Line a)-\u003eLocated(Trail' Line a)",
          "package": "diagrams-lib",
          "partial": "Loc Line",
          "signature": "Located(Trail' Line v)-\u003eLocated(Trail' Line v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:reverseLocLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse a concretely located loop.  See \u003ccode\u003e\u003ca\u003ereverseLocTrail\u003c/a\u003e\u003c/code\u003e.  Note\n   that this is guaranteed to preserve the location.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "reverseLocLoop",
          "package": "diagrams-lib",
          "signature": "Located (Trail' Loop v) -\u003e Located (Trail' Loop v)",
          "source": "src/Diagrams-Trail.html#reverseLocLoop",
          "type": "function"
        },
        "index": {
          "description": "Reverse concretely located loop See reverseLocTrail Note that this is guaranteed to preserve the location",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "reverseLocLoop",
          "normalized": "Located(Trail' Loop a)-\u003eLocated(Trail' Loop a)",
          "package": "diagrams-lib",
          "partial": "Loc Loop",
          "signature": "Located(Trail' Loop v)-\u003eLocated(Trail' Loop v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:reverseLocLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse a concretely located trail.  The endpoint of the original\n   trail becomes the starting point of the reversed trail, so the\n   original and reversed trails comprise exactly the same set of\n   points.  \u003ccode\u003ereverseLocTrail\u003c/code\u003e is an involution, \u003cem\u003ei.e.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n   reverseLocTrail . reverseLocTrail === id\n\u003c/pre\u003e",
          "module": "Diagrams.Trail",
          "name": "reverseLocTrail",
          "package": "diagrams-lib",
          "signature": "Located (Trail v) -\u003e Located (Trail v)",
          "source": "src/Diagrams-Trail.html#reverseLocTrail",
          "type": "function"
        },
        "index": {
          "description": "Reverse concretely located trail The endpoint of the original trail becomes the starting point of the reversed trail so the original and reversed trails comprise exactly the same set of points reverseLocTrail is an involution i.e reverseLocTrail reverseLocTrail id",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "reverseLocTrail",
          "normalized": "Located(Trail a)-\u003eLocated(Trail a)",
          "package": "diagrams-lib",
          "partial": "Loc Trail",
          "signature": "Located(Trail v)-\u003eLocated(Trail v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:reverseLocTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse a loop.  See \u003ccode\u003e\u003ca\u003ereverseTrail\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "reverseLoop",
          "package": "diagrams-lib",
          "signature": "Trail' Loop v -\u003e Trail' Loop v",
          "source": "src/Diagrams-Trail.html#reverseLoop",
          "type": "function"
        },
        "index": {
          "description": "Reverse loop See reverseTrail",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "reverseLoop",
          "normalized": "Trail' Loop a-\u003eTrail' Loop a",
          "package": "diagrams-lib",
          "partial": "Loop",
          "signature": "Trail' Loop v-\u003eTrail' Loop v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:reverseLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse a trail.  Semantically, if a trail given by a function t\n   from [0,1] to vectors, then the reverse of t is given by t'(s) =\n   t(1-s).  \u003ccode\u003ereverseTrail\u003c/code\u003e is an involution, that is,\n\u003c/p\u003e\u003cpre\u003e\n   reverseTrail . reverseTrail === id\n\u003c/pre\u003e",
          "module": "Diagrams.Trail",
          "name": "reverseTrail",
          "package": "diagrams-lib",
          "signature": "Trail v -\u003e Trail v",
          "source": "src/Diagrams-Trail.html#reverseTrail",
          "type": "function"
        },
        "index": {
          "description": "Reverse trail Semantically if trail given by function from to vectors then the reverse of is given by reverseTrail is an involution that is reverseTrail reverseTrail id",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "reverseTrail",
          "normalized": "Trail a-\u003eTrail a",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "Trail v-\u003eTrail v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:reverseTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003etrailFromOffsets === \u003ccode\u003e\u003ca\u003ewrapTrail\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003elineFromOffsets\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, for\n   conveniently constructing a \u003ccode\u003eTrail\u003c/code\u003e instead of a \u003ccode\u003eTrail' Line\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "trailFromOffsets",
          "package": "diagrams-lib",
          "signature": "[v] -\u003e Trail v",
          "source": "src/Diagrams-Trail.html#trailFromOffsets",
          "type": "function"
        },
        "index": {
          "description": "trailFromOffsets wrapTrail lineFromOffsets for conveniently constructing Trail instead of Trail Line",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "trailFromOffsets",
          "normalized": "[a]-\u003eTrail a",
          "package": "diagrams-lib",
          "partial": "From Offsets",
          "signature": "[v]-\u003eTrail v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:trailFromOffsets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003etrailFromSegments === \u003ccode\u003e\u003ca\u003ewrapTrail\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003elineFromSegments\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, for\n   conveniently constructing a \u003ccode\u003eTrail\u003c/code\u003e instead of a \u003ccode\u003eTrail'\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "trailFromSegments",
          "package": "diagrams-lib",
          "signature": "[Segment Closed v] -\u003e Trail v",
          "source": "src/Diagrams-Trail.html#trailFromSegments",
          "type": "function"
        },
        "index": {
          "description": "trailFromSegments wrapTrail lineFromSegments for conveniently constructing Trail instead of Trail",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "trailFromSegments",
          "normalized": "[Segment Closed a]-\u003eTrail a",
          "package": "diagrams-lib",
          "partial": "From Segments",
          "signature": "[Segment Closed v]-\u003eTrail v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:trailFromSegments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003etrailFromVertices === \u003ccode\u003e\u003ca\u003ewrapTrail\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003elineFromVertices\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, for\n   conveniently constructing a \u003ccode\u003eTrail\u003c/code\u003e instead of a \u003ccode\u003eTrail' Line\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "trailFromVertices",
          "package": "diagrams-lib",
          "signature": "[Point v] -\u003e Trail v",
          "source": "src/Diagrams-Trail.html#trailFromVertices",
          "type": "function"
        },
        "index": {
          "description": "trailFromVertices wrapTrail lineFromVertices for conveniently constructing Trail instead of Trail Line",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "trailFromVertices",
          "normalized": "[Point a]-\u003eTrail a",
          "package": "diagrams-lib",
          "partial": "From Vertices",
          "signature": "[Point v]-\u003eTrail v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:trailFromVertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a default result (to be used in the case of an empty\n   trail), and a function to map a single measure to a result,\n   extract the given measure for a trail and use it to compute a\n   result.  Put another way, lift a function on a single measure\n   (along with a default value) to a function on an entire trail.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "trailMeasure",
          "package": "diagrams-lib",
          "signature": "a -\u003e (m -\u003e a) -\u003e t -\u003e a",
          "source": "src/Diagrams-Trail.html#trailMeasure",
          "type": "function"
        },
        "index": {
          "description": "Given default result to be used in the case of an empty trail and function to map single measure to result extract the given measure for trail and use it to compute result Put another way lift function on single measure along with default value to function on an entire trail",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "trailMeasure",
          "normalized": "a-\u003e(b-\u003ea)-\u003ec-\u003ea",
          "package": "diagrams-lib",
          "partial": "Measure",
          "signature": "a-\u003e(m-\u003ea)-\u003et-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:trailMeasure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the offset from the start of a trail to the end.  Satisfies\n\u003c/p\u003e\u003cpre\u003e\n   trailOffset === sumV . trailOffsets\n\u003c/pre\u003e\u003cp\u003ebut is more efficient.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_Trail_trailOffsetEx.svg#diagram=trailOffsetEx&width=300\"/\u003e\n\u003c/p\u003e\u003cpre\u003e trailOffsetEx = (strokeLine almostClosed \u003c\u003e showOffset) # centerXY # pad 1.1\n   where showOffset = fromOffsets [trailOffset (wrapLine almostClosed)]\n                    # stroke # lc red # lw 0.05\n\u003c/pre\u003e",
          "module": "Diagrams.Trail",
          "name": "trailOffset",
          "package": "diagrams-lib",
          "signature": "Trail v -\u003e v",
          "source": "src/Diagrams-Trail.html#trailOffset",
          "type": "function"
        },
        "index": {
          "description": "Compute the offset from the start of trail to the end Satisfies trailOffset sumV trailOffsets but is more efficient trailOffsetEx strokeLine almostClosed showOffset centerXY pad where showOffset fromOffsets trailOffset wrapLine almostClosed stroke lc red lw",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "trailOffset",
          "normalized": "Trail a-\u003ea",
          "package": "diagrams-lib",
          "partial": "Offset",
          "signature": "Trail v-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:trailOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the offsets of the segments of a trail.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "trailOffsets",
          "package": "diagrams-lib",
          "signature": "Trail v -\u003e [v]",
          "source": "src/Diagrams-Trail.html#trailOffsets",
          "type": "function"
        },
        "index": {
          "description": "Extract the offsets of the segments of trail",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "trailOffsets",
          "normalized": "Trail a-\u003e[a]",
          "package": "diagrams-lib",
          "partial": "Offsets",
          "signature": "Trail v-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:trailOffsets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the segments of a trail.  If the trail is a loop it will\n   first have \u003ccode\u003e\u003ca\u003ecutLoop\u003c/a\u003e\u003c/code\u003e applied.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "trailSegments",
          "package": "diagrams-lib",
          "signature": "Trail v -\u003e [Segment Closed v]",
          "source": "src/Diagrams-Trail.html#trailSegments",
          "type": "function"
        },
        "index": {
          "description": "Extract the segments of trail If the trail is loop it will first have cutLoop applied",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "trailSegments",
          "normalized": "Trail a-\u003e[Segment Closed a]",
          "package": "diagrams-lib",
          "partial": "Segments",
          "signature": "Trail v-\u003e[Segment Closed v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:trailSegments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the vertices of a concretely located trail.  Note that\n   for loops, the starting vertex will \u003cem\u003enot\u003c/em\u003e be repeated at the end.\n   If you want this behavior, you can use \u003ccode\u003e\u003ca\u003ecutTrail\u003c/a\u003e\u003c/code\u003e to make the\n   loop into a line first, which happens to repeat the same vertex\n   at the start and end, \u003cem\u003ee.g.\u003c/em\u003e with \u003ccode\u003etrailVertices . mapLoc\n   cutTrail\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that it does not make sense to ask for the vertices of a\n   \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e by itself; if you want the vertices of a trail\n   with the first vertex at, say, the origin, you can use\n   \u003ccode\u003etrailVertices . (`at` origin)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "trailVertices",
          "package": "diagrams-lib",
          "signature": "Located (Trail v) -\u003e [Point v]",
          "source": "src/Diagrams-Trail.html#trailVertices",
          "type": "function"
        },
        "index": {
          "description": "Extract the vertices of concretely located trail Note that for loops the starting vertex will not be repeated at the end If you want this behavior you can use cutTrail to make the loop into line first which happens to repeat the same vertex at the start and end e.g with trailVertices mapLoc cutTrail Note that it does not make sense to ask for the vertices of Trail by itself if you want the vertices of trail with the first vertex at say the origin you can use trailVertices at origin",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "trailVertices",
          "normalized": "Located(Trail a)-\u003e[Point a]",
          "package": "diagrams-lib",
          "partial": "Vertices",
          "signature": "Located(Trail v)-\u003e[Point v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:trailVertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn eliminator for \u003ccode\u003eTrail\u003c/code\u003e based on eliminating lines: if the\n   trail is a line, the given function is applied; if it is a loop, it\n   is first converted to a line with \u003ccode\u003e\u003ca\u003ecutLoop\u003c/a\u003e\u003c/code\u003e.  That is,\n\u003c/p\u003e\u003cpre\u003e\n withLine f === \u003ccode\u003e\u003ca\u003ewithTrail\u003c/a\u003e\u003c/code\u003e f (f . \u003ccode\u003e\u003ca\u003ecutLoop\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e",
          "module": "Diagrams.Trail",
          "name": "withLine",
          "package": "diagrams-lib",
          "signature": "(Trail' Line v -\u003e r) -\u003e Trail v -\u003e r",
          "source": "src/Diagrams-Trail.html#withLine",
          "type": "function"
        },
        "index": {
          "description": "An eliminator for Trail based on eliminating lines if the trail is line the given function is applied if it is loop it is first converted to line with cutLoop That is withLine withTrail cutLoop",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "withLine",
          "normalized": "(Trail' Line a-\u003eb)-\u003eTrail a-\u003eb",
          "package": "diagrams-lib",
          "partial": "Line",
          "signature": "(Trail' Line v-\u003er)-\u003eTrail v-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:withLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generic eliminator for \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e, taking functions specifying\n   what to do in the case of a line or a loop.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "withTrail",
          "package": "diagrams-lib",
          "signature": "(Trail' Line v -\u003e r) -\u003e (Trail' Loop v -\u003e r) -\u003e Trail v -\u003e r",
          "source": "src/Diagrams-Trail.html#withTrail",
          "type": "function"
        },
        "index": {
          "description": "generic eliminator for Trail taking functions specifying what to do in the case of line or loop",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "withTrail",
          "normalized": "(Trail' Line a-\u003eb)-\u003e(Trail' Loop a-\u003eb)-\u003eTrail a-\u003eb",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "(Trail' Line v-\u003er)-\u003e(Trail' Loop v-\u003er)-\u003eTrail v-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:withTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generic eliminator for \u003ccode\u003e\u003ca\u003eTrail'\u003c/a\u003e\u003c/code\u003e, taking functions specifying\n   what to do in the case of a line or a loop.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "withTrail'",
          "package": "diagrams-lib",
          "signature": "(Trail' Line v -\u003e r) -\u003e (Trail' Loop v -\u003e r) -\u003e Trail' l v -\u003e r",
          "source": "src/Diagrams-Trail.html#withTrail%27",
          "type": "function"
        },
        "index": {
          "description": "generic eliminator for Trail taking functions specifying what to do in the case of line or loop",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "withTrail'",
          "normalized": "(Trail' Line a-\u003eb)-\u003e(Trail' Loop a-\u003eb)-\u003eTrail' c a-\u003eb",
          "package": "diagrams-lib",
          "partial": "Trail'",
          "signature": "(Trail' Line v-\u003er)-\u003e(Trail' Loop v-\u003er)-\u003eTrail' l v-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:withTrail-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a line into a \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e.  This is the same as \u003ccode\u003e\u003ca\u003ewrapTrail\u003c/a\u003e\u003c/code\u003e,\n   but with a more specific type, which can occasionally be\n   convenient for fixing the type of a polymorphic expression.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "wrapLine",
          "package": "diagrams-lib",
          "signature": "Trail' Line v -\u003e Trail v",
          "source": "src/Diagrams-Trail.html#wrapLine",
          "type": "function"
        },
        "index": {
          "description": "Convert line into Trail This is the same as wrapTrail but with more specific type which can occasionally be convenient for fixing the type of polymorphic expression",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "wrapLine",
          "normalized": "Trail' Line a-\u003eTrail a",
          "package": "diagrams-lib",
          "partial": "Line",
          "signature": "Trail' Line v-\u003eTrail v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:wrapLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a loop into a \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e.  This is the same as \u003ccode\u003e\u003ca\u003ewrapTrail\u003c/a\u003e\u003c/code\u003e,\n   but with a more specific type, which can occasionally be\n   convenient for fixing the type of a polymorphic expression.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "wrapLoop",
          "package": "diagrams-lib",
          "signature": "Trail' Loop v -\u003e Trail v",
          "source": "src/Diagrams-Trail.html#wrapLoop",
          "type": "function"
        },
        "index": {
          "description": "Convert loop into Trail This is the same as wrapTrail but with more specific type which can occasionally be convenient for fixing the type of polymorphic expression",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "wrapLoop",
          "normalized": "Trail' Loop a-\u003eTrail a",
          "package": "diagrams-lib",
          "partial": "Loop",
          "signature": "Trail' Loop v-\u003eTrail v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:wrapLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eTrail'\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e, hiding the type-level\n   distinction between lines and loops.\n\u003c/p\u003e",
          "module": "Diagrams.Trail",
          "name": "wrapTrail",
          "package": "diagrams-lib",
          "signature": "Trail' l v -\u003e Trail v",
          "source": "src/Diagrams-Trail.html#wrapTrail",
          "type": "function"
        },
        "index": {
          "description": "Convert Trail into Trail hiding the type-level distinction between lines and loops",
          "hierarchy": "Diagrams Trail",
          "module": "Diagrams.Trail",
          "name": "wrapTrail",
          "normalized": "Trail' a b-\u003eTrail b",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "Trail' l v-\u003eTrail v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Trail.html#v:wrapTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eTrailLike\u003c/a\u003e\u003c/code\u003e class abstracts over anything which can be\n constructed from a concretely located \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e, including\n lines, loops, trails, paths, vertex lists, and diagrams.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TrailLike",
          "name": "TrailLike",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TrailLike.html",
          "type": "module"
        },
        "index": {
          "description": "The TrailLike class abstracts over anything which can be constructed from concretely located Trail including lines loops trails paths vertex lists and diagrams",
          "hierarchy": "Diagrams TrailLike",
          "module": "Diagrams.TrailLike",
          "name": "TrailLike",
          "package": "diagrams-lib",
          "partial": "Trail Like",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TrailLike.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for trail-like things, \u003cem\u003ei.e.\u003c/em\u003e things which can be\n   constructed from a concretely located \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e.  Instances include\n   lines, loops, trails, paths, lists of vertices, two-dimensional\n   \u003ccode\u003e\u003ca\u003eDiagram\u003c/a\u003e\u003c/code\u003es, and \u003ccode\u003e\u003ca\u003eLocated\u003c/a\u003e\u003c/code\u003e variants of all the above.\n\u003c/p\u003e\u003cp\u003eUsually, type variables with \u003ccode\u003e\u003ca\u003eTrailLike\u003c/a\u003e\u003c/code\u003e constraints are used as\n   the \u003cem\u003eoutput\u003c/em\u003e types of functions, like\n\u003c/p\u003e\u003cpre\u003e\n   foo :: (TrailLike t) =\u003e ... -\u003e t\n\u003c/pre\u003e\u003cp\u003eFunctions with such a type can be used to construct trails,\n   paths, diagrams, lists of points, and so on, depending on the\n   context.\n\u003c/p\u003e\u003cp\u003eTo write a function with a signature like the above, you can of\n   course call \u003ccode\u003e\u003ca\u003etrailLike\u003c/a\u003e\u003c/code\u003e directly; more typically, one would use\n   one of the provided functions like \u003ccode\u003e\u003ca\u003efromOffsets\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003efromVertices\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003efromSegments\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003e~~\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TrailLike",
          "name": "TrailLike",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TrailLike.html#TrailLike",
          "type": "class"
        },
        "index": {
          "description": "type class for trail-like things i.e things which can be constructed from concretely located Trail Instances include lines loops trails paths lists of vertices two-dimensional Diagram and Located variants of all the above Usually type variables with TrailLike constraints are used as the output types of functions like foo TrailLike Functions with such type can be used to construct trails paths diagrams lists of points and so on depending on the context To write function with signature like the above you can of course call trailLike directly more typically one would use one of the provided functions like fromOffsets fromVertices fromSegments or",
          "hierarchy": "Diagrams TrailLike",
          "module": "Diagrams.TrailLike",
          "name": "TrailLike",
          "package": "diagrams-lib",
          "partial": "Trail Like",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TrailLike.html#t:TrailLike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a linear trail between two given points.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TrailLike_twiddleEx.svg#diagram=twiddleEx&width=300\"/\u003e\n\u003c/p\u003e\u003cpre\u003e twiddleEx\n   = mconcat ((~~) \u003c$\u003e hexagon 1 \u003c*\u003e hexagon 1)\n   # centerXY # pad 1.1\n\u003c/pre\u003e",
          "module": "Diagrams.TrailLike",
          "name": "(~~)",
          "package": "diagrams-lib",
          "signature": "Point (V t) -\u003e Point (V t) -\u003e t",
          "source": "src/Diagrams-TrailLike.html#~~",
          "type": "function"
        },
        "index": {
          "description": "Create linear trail between two given points twiddleEx mconcat hexagon hexagon centerXY pad",
          "hierarchy": "Diagrams TrailLike",
          "module": "Diagrams.TrailLike",
          "name": "(~~) ~~",
          "normalized": "Point(V a)-\u003ePoint(V a)-\u003ea",
          "package": "diagrams-lib",
          "signature": "Point(V t)-\u003ePoint(V t)-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TrailLike.html#v:-126--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a concretely located trail, \"explode\" it by turning each\n   segment into its own separate trail.  Useful for (say) applying a\n   different style to each segment.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TrailLike_explodeTrailEx.svg#diagram=explodeTrailEx&width=300\"/\u003e\n\u003c/p\u003e\u003cpre\u003e explodeTrailEx\n   = pentagon 1\n   # explodeTrail  -- generate a list of diagrams\n   # zipWith lc [orange, green, yellow, red, blue]\n   # mconcat # centerXY # pad 1.1\n\u003c/pre\u003e",
          "module": "Diagrams.TrailLike",
          "name": "explodeTrail",
          "package": "diagrams-lib",
          "signature": "Located (Trail (V t)) -\u003e [t]",
          "source": "src/Diagrams-TrailLike.html#explodeTrail",
          "type": "function"
        },
        "index": {
          "description": "Given concretely located trail explode it by turning each segment into its own separate trail Useful for say applying different style to each segment explodeTrailEx pentagon explodeTrail generate list of diagrams zipWith lc orange green yellow red blue mconcat centerXY pad",
          "hierarchy": "Diagrams TrailLike",
          "module": "Diagrams.TrailLike",
          "name": "explodeTrail",
          "normalized": "Located(Trail(V a))-\u003e[a]",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "Located(Trail(V t))-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TrailLike.html#v:explodeTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a trail-like thing of linear segments from a located\n   list of offsets.\n\u003c/p\u003e",
          "module": "Diagrams.TrailLike",
          "name": "fromLocOffsets",
          "package": "diagrams-lib",
          "signature": "Located [V t] -\u003e t",
          "source": "src/Diagrams-TrailLike.html#fromLocOffsets",
          "type": "function"
        },
        "index": {
          "description": "Construct trail-like thing of linear segments from located list of offsets",
          "hierarchy": "Diagrams TrailLike",
          "module": "Diagrams.TrailLike",
          "name": "fromLocOffsets",
          "normalized": "Located[V a]-\u003ea",
          "package": "diagrams-lib",
          "partial": "Loc Offsets",
          "signature": "Located[V t]-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TrailLike.html#v:fromLocOffsets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a trail-like thing from a located list of segments.\n\u003c/p\u003e",
          "module": "Diagrams.TrailLike",
          "name": "fromLocSegments",
          "package": "diagrams-lib",
          "signature": "Located [Segment Closed (V t)] -\u003e t",
          "source": "src/Diagrams-TrailLike.html#fromLocSegments",
          "type": "function"
        },
        "index": {
          "description": "Construct trail-like thing from located list of segments",
          "hierarchy": "Diagrams TrailLike",
          "module": "Diagrams.TrailLike",
          "name": "fromLocSegments",
          "normalized": "Located[Segment Closed(V a)]-\u003ea",
          "package": "diagrams-lib",
          "partial": "Loc Segments",
          "signature": "Located[Segment Closed(V t)]-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TrailLike.html#v:fromLocSegments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a trail-like thing of linear segments from a list\n   of offsets, with the origin as the location.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TrailLike_fromOffsetsEx.svg#diagram=fromOffsetsEx&width=300\"/\u003e\n\u003c/p\u003e\u003cpre\u003e fromOffsetsEx = fromOffsets\n   [ unitX\n   , unitX # rotateBy (1/6)\n   , unitX # rotateBy (-1/6)\n   , unitX\n   ]\n   # centerXY # pad 1.1\n\u003c/pre\u003e",
          "module": "Diagrams.TrailLike",
          "name": "fromOffsets",
          "package": "diagrams-lib",
          "signature": "[V t] -\u003e t",
          "source": "src/Diagrams-TrailLike.html#fromOffsets",
          "type": "function"
        },
        "index": {
          "description": "Construct trail-like thing of linear segments from list of offsets with the origin as the location fromOffsetsEx fromOffsets unitX unitX rotateBy unitX rotateBy unitX centerXY pad",
          "hierarchy": "Diagrams TrailLike",
          "module": "Diagrams.TrailLike",
          "name": "fromOffsets",
          "normalized": "[V a]-\u003ea",
          "package": "diagrams-lib",
          "partial": "Offsets",
          "signature": "[V t]-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TrailLike.html#v:fromOffsets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a trail-like thing from a list of segments, with the\n   origin as the location.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TrailLike_fromSegmentsEx.svg#diagram=fromSegmentsEx&height=200\"/\u003e\n\u003c/p\u003e\u003cpre\u003e fromSegmentsEx = fromSegments\n   [ straight (r2 (1,1))\n   , b&#233;zier3  (r2 (1,1)) unitX unit_Y\n   , straight unit_X\n   ]\n   # centerXY # pad 1.1\n\u003c/pre\u003e",
          "module": "Diagrams.TrailLike",
          "name": "fromSegments",
          "package": "diagrams-lib",
          "signature": "[Segment Closed (V t)] -\u003e t",
          "source": "src/Diagrams-TrailLike.html#fromSegments",
          "type": "function"
        },
        "index": {
          "description": "Construct trail-like thing from list of segments with the origin as the location fromSegmentsEx fromSegments straight r2 zier3 r2 unitX unit straight unit centerXY pad",
          "hierarchy": "Diagrams TrailLike",
          "module": "Diagrams.TrailLike",
          "name": "fromSegments",
          "normalized": "[Segment Closed(V a)]-\u003ea",
          "package": "diagrams-lib",
          "partial": "Segments",
          "signature": "[Segment Closed(V t)]-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TrailLike.html#v:fromSegments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a trail-like thing connecting the given vertices with\n   linear segments, with the first vertex as the location.  If no\n   vertices are given, the empty trail is used with the origin as\n   the location.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TrailLike_fromVerticesEx.svg#diagram=fromVerticesEx&width=300\"/\u003e\n\u003c/p\u003e\u003cpre\u003e import Data.List (transpose)\n\n fromVerticesEx =\n   ( [ pentagon 1\n     , pentagon 1.3 # rotateBy (1/15)\n     , pentagon 1.5 # rotateBy (2/15)\n     ]\n     # transpose\n     # concat\n   )\n   # fromVertices\n   # closeTrail # strokeTrail\n   # centerXY # pad 1.1\n\u003c/pre\u003e",
          "module": "Diagrams.TrailLike",
          "name": "fromVertices",
          "package": "diagrams-lib",
          "signature": "[Point (V t)] -\u003e t",
          "source": "src/Diagrams-TrailLike.html#fromVertices",
          "type": "function"
        },
        "index": {
          "description": "Construct trail-like thing connecting the given vertices with linear segments with the first vertex as the location If no vertices are given the empty trail is used with the origin as the location import Data.List transpose fromVerticesEx pentagon pentagon rotateBy pentagon rotateBy transpose concat fromVertices closeTrail strokeTrail centerXY pad",
          "hierarchy": "Diagrams TrailLike",
          "module": "Diagrams.TrailLike",
          "name": "fromVertices",
          "normalized": "[Point(V a)]-\u003ea",
          "package": "diagrams-lib",
          "partial": "Vertices",
          "signature": "[Point(V t)]-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TrailLike.html#v:fromVertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TrailLike",
          "name": "trailLike",
          "package": "diagrams-lib",
          "signature": "trailLike",
          "source": "src/Diagrams-TrailLike.html#trailLike",
          "type": "method"
        },
        "index": {
          "hierarchy": "Diagrams TrailLike",
          "module": "Diagrams.TrailLike",
          "name": "trailLike",
          "package": "diagrams-lib",
          "partial": "Like",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TrailLike.html#v:trailLike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAffine transformations, parameterized by any vector space.  For\n transformations on particular vector spaces, see \u003cem\u003ee.g.\u003c/em\u003e\n \u003ca\u003eDiagrams.TwoD.Transform\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Transform",
          "name": "Transform",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Transform.html",
          "type": "module"
        },
        "index": {
          "description": "Affine transformations parameterized by any vector space For transformations on particular vector spaces see e.g Diagrams.TwoD.Transform",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "Transform",
          "package": "diagrams-lib",
          "partial": "Transform",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass of types which have an intrinsic notion of a \"local\n   origin\", i.e. things which are not invariant under translation,\n   and which allow the origin to be moved.\n\u003c/p\u003e\u003cp\u003eOne might wonder why not just use \u003ccode\u003eTransformable\u003c/code\u003e instead of\n   having a separate class for \u003ccode\u003e\u003ca\u003eHasOrigin\u003c/a\u003e\u003c/code\u003e; indeed, for types which\n   are instances of both we should have the identity\n\u003c/p\u003e\u003cpre\u003e moveOriginTo (origin .^+ v) === translate (negateV v)\n\u003c/pre\u003e\u003cp\u003eThe reason is that some things (e.g. vectors, \u003ccode\u003eTrail\u003c/code\u003es) are\n   transformable but are translationally invariant, i.e. have no\n   origin.\n\u003c/p\u003e",
          "module": "Diagrams.Transform",
          "name": "HasOrigin",
          "package": "diagrams-lib",
          "type": "class"
        },
        "index": {
          "description": "Class of types which have an intrinsic notion of local origin i.e things which are not invariant under translation and which allow the origin to be moved One might wonder why not just use Transformable instead of having separate class for HasOrigin indeed for types which are instances of both we should have the identity moveOriginTo origin translate negateV The reason is that some things e.g vectors Trail are transformable but are translationally invariant i.e have no origin",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "HasOrigin",
          "package": "diagrams-lib",
          "partial": "Has Origin",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#t:HasOrigin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class for things \u003ccode\u003et\u003c/code\u003e which can be transformed.\n\u003c/p\u003e",
          "module": "Diagrams.Transform",
          "name": "Transformable",
          "package": "diagrams-lib",
          "type": "class"
        },
        "index": {
          "description": "Type class for things which can be transformed",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "Transformable",
          "package": "diagrams-lib",
          "partial": "Transformable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#t:Transformable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneral (affine) transformations, represented by an invertible\n   linear map, its \u003cem\u003etranspose\u003c/em\u003e, and a vector representing a\n   translation component.\n\u003c/p\u003e\u003cp\u003eBy the \u003cem\u003etranspose\u003c/em\u003e of a linear map we mean simply the linear map\n   corresponding to the transpose of the map's matrix\n   representation.  For example, any scale is its own transpose,\n   since scales are represented by matrices with zeros everywhere\n   except the diagonal.  The transpose of a rotation is the same as\n   its inverse.\n\u003c/p\u003e\u003cp\u003eThe reason we need to keep track of transposes is because it\n   turns out that when transforming a shape according to some linear\n   map L, the shape's \u003cem\u003enormal vectors\u003c/em\u003e transform according to L's\n   inverse transpose.  This is exactly what we need when\n   transforming bounding functions, which are defined in terms of\n   \u003cem\u003eperpendicular\u003c/em\u003e (i.e. normal) hyperplanes.\n\u003c/p\u003e",
          "module": "Diagrams.Transform",
          "name": "Transformation",
          "package": "diagrams-lib",
          "type": "data"
        },
        "index": {
          "description": "General affine transformations represented by an invertible linear map its transpose and vector representing translation component By the transpose of linear map we mean simply the linear map corresponding to the transpose of the map matrix representation For example any scale is its own transpose since scales are represented by matrices with zeros everywhere except the diagonal The transpose of rotation is the same as its inverse The reason we need to keep track of transposes is because it turns out that when transforming shape according to some linear map the shape normal vectors transform according to inverse transpose This is exactly what we need when transforming bounding functions which are defined in terms of perpendicular i.e normal hyperplanes",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "Transformation",
          "package": "diagrams-lib",
          "partial": "Transformation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#t:Transformation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a transformation to a vector.  Note that any translational\n   component of the transformation will not affect the vector, since\n   vectors are invariant under translation.\n\u003c/p\u003e",
          "module": "Diagrams.Transform",
          "name": "apply",
          "package": "diagrams-lib",
          "signature": "Transformation v -\u003e v -\u003e v",
          "type": "function"
        },
        "index": {
          "description": "Apply transformation to vector Note that any translational component of the transformation will not affect the vector since vectors are invariant under translation",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "apply",
          "normalized": "Transformation a-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Transformation v-\u003ev-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConjugate one transformation by another. \u003ccode\u003econjugate t1 t2\u003c/code\u003e is the\n   transformation which performs first \u003ccode\u003et1\u003c/code\u003e, then \u003ccode\u003et2\u003c/code\u003e, then the\n   inverse of \u003ccode\u003et1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Transform",
          "name": "conjugate",
          "package": "diagrams-lib",
          "signature": "Transformation v -\u003e Transformation v -\u003e Transformation v",
          "source": "src/Diagrams-Transform.html#conjugate",
          "type": "function"
        },
        "index": {
          "description": "Conjugate one transformation by another conjugate t1 t2 is the transformation which performs first t1 then t2 then the inverse of t1",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "conjugate",
          "normalized": "Transformation a-\u003eTransformation a-\u003eTransformation a",
          "package": "diagrams-lib",
          "signature": "Transformation v-\u003eTransformation v-\u003eTransformation v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:conjugate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvert a transformation.\n\u003c/p\u003e",
          "module": "Diagrams.Transform",
          "name": "inv",
          "package": "diagrams-lib",
          "signature": "Transformation v -\u003e Transformation v",
          "type": "function"
        },
        "index": {
          "description": "Invert transformation",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "inv",
          "normalized": "Transformation a-\u003eTransformation a",
          "package": "diagrams-lib",
          "signature": "Transformation v-\u003eTransformation v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:inv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove the local origin by a relative vector.\n\u003c/p\u003e",
          "module": "Diagrams.Transform",
          "name": "moveOriginBy",
          "package": "diagrams-lib",
          "signature": "V t -\u003e t -\u003e t",
          "type": "function"
        },
        "index": {
          "description": "Move the local origin by relative vector",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "moveOriginBy",
          "normalized": "V a-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Origin By",
          "signature": "V t-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:moveOriginBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove the local origin to another point.\n\u003c/p\u003e\u003cp\u003eNote that this function is in some sense dual to \u003ccode\u003etranslate\u003c/code\u003e\n   (for types which are also \u003ccode\u003eTransformable\u003c/code\u003e); moving the origin\n   itself while leaving the object \"fixed\" is dual to fixing the\n   origin and translating the diagram.\n\u003c/p\u003e",
          "module": "Diagrams.Transform",
          "name": "moveOriginTo",
          "package": "diagrams-lib",
          "signature": "Point (V t) -\u003e t -\u003e t",
          "type": "method"
        },
        "index": {
          "description": "Move the local origin to another point Note that this function is in some sense dual to translate for types which are also Transformable moving the origin itself while leaving the object fixed is dual to fixing the origin and translating the diagram",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "moveOriginTo",
          "normalized": "Point(V a)-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Origin To",
          "signature": "Point(V t)-\u003et-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:moveOriginTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslate the object by the translation that sends the origin to\n   the given point. Note that this is dual to \u003ccode\u003e\u003ca\u003emoveOriginTo\u003c/a\u003e\u003c/code\u003e, i.e. we\n   should have\n\u003c/p\u003e\u003cpre\u003e moveTo (origin .^+ v) === moveOriginTo (origin .^- v)\n\u003c/pre\u003e\u003cp\u003eFor types which are also \u003ccode\u003eTransformable\u003c/code\u003e, this is essentially the\n   same as \u003ccode\u003etranslate\u003c/code\u003e, i.e.\n\u003c/p\u003e\u003cpre\u003e moveTo (origin .^+ v) === translate v\n\u003c/pre\u003e",
          "module": "Diagrams.Transform",
          "name": "moveTo",
          "package": "diagrams-lib",
          "signature": "Point (V t) -\u003e t -\u003e t",
          "type": "function"
        },
        "index": {
          "description": "Translate the object by the translation that sends the origin to the given point Note that this is dual to moveOriginTo i.e we should have moveTo origin moveOriginTo origin For types which are also Transformable this is essentially the same as translate i.e moveTo origin translate",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "moveTo",
          "normalized": "Point(V a)-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "To",
          "signature": "Point(V t)-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:moveTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a transformation to a point.\n\u003c/p\u003e",
          "module": "Diagrams.Transform",
          "name": "papply",
          "package": "diagrams-lib",
          "signature": "Transformation v -\u003e Point v -\u003e Point v",
          "type": "function"
        },
        "index": {
          "description": "Apply transformation to point",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "papply",
          "normalized": "Transformation a-\u003ePoint a-\u003ePoint a",
          "package": "diagrams-lib",
          "signature": "Transformation v-\u003ePoint v-\u003ePoint v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:papply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA flipped variant of \u003ccode\u003e\u003ca\u003emoveTo\u003c/a\u003e\u003c/code\u003e, provided for convenience.  Useful\n   when writing a function which takes a point as an argument, such\n   as when using \u003ccode\u003ewithName\u003c/code\u003e and friends.\n\u003c/p\u003e",
          "module": "Diagrams.Transform",
          "name": "place",
          "package": "diagrams-lib",
          "signature": "t -\u003e Point (V t) -\u003e t",
          "type": "function"
        },
        "index": {
          "description": "flipped variant of moveTo provided for convenience Useful when writing function which takes point as an argument such as when using withName and friends",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "place",
          "normalized": "a-\u003ePoint(V a)-\u003ea",
          "package": "diagrams-lib",
          "signature": "t-\u003ePoint(V t)-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:place"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale uniformly in every dimension by the given scalar.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Transform\",\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "scale",
          "package": "diagrams-lib",
          "signature": "Scalar (V t) -\u003e t -\u003e t",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:scale\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scale\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:scale\"]"
        },
        "index": {
          "description": "Scale uniformly in every dimension by the given scalar",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "scale",
          "normalized": "Scalar(V a)-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Scalar(V t)-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a uniform scaling transformation.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Transform\",\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "scaling",
          "package": "diagrams-lib",
          "signature": "Scalar v -\u003e Transformation v",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:scaling\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scaling\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:scaling\"]"
        },
        "index": {
          "description": "Create uniform scaling transformation",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "scaling",
          "normalized": "Scalar a-\u003eTransformation a",
          "package": "diagrams-lib",
          "signature": "Scalar v-\u003eTransformation v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:scaling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a transformation to an object.\n\u003c/p\u003e",
          "module": "Diagrams.Transform",
          "name": "transform",
          "package": "diagrams-lib",
          "signature": "Transformation (V t) -\u003e t -\u003e t",
          "type": "method"
        },
        "index": {
          "description": "Apply transformation to an object",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "transform",
          "normalized": "Transformation(V a)-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Transformation(V t)-\u003et-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:transform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the translational component of a transformation.\n\u003c/p\u003e",
          "module": "Diagrams.Transform",
          "name": "transl",
          "package": "diagrams-lib",
          "signature": "Transformation v -\u003e v",
          "type": "function"
        },
        "index": {
          "description": "Get the translational component of transformation",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "transl",
          "normalized": "Transformation a-\u003ea",
          "package": "diagrams-lib",
          "signature": "Transformation v-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:transl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslate by a vector.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Transform\",\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "translate",
          "package": "diagrams-lib",
          "signature": "V t -\u003e t -\u003e t",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:translate\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:translate\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:translate\"]"
        },
        "index": {
          "description": "Translate by vector",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "translate",
          "normalized": "V a-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "V t-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:translate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a translation.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Transform\",\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "translation",
          "package": "diagrams-lib",
          "signature": "v -\u003e Transformation v",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:translation\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:translation\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:translation\"]"
        },
        "index": {
          "description": "Create translation",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "translation",
          "normalized": "a-\u003eTransformation a",
          "package": "diagrams-lib",
          "signature": "v-\u003eTransformation v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:translation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCarry out some transformation \"under\" another one: \u003ccode\u003ef `\u003ccode\u003e\u003ca\u003eunder\u003c/a\u003e\u003c/code\u003e`\n   t\u003c/code\u003e first applies \u003ccode\u003et\u003c/code\u003e, then \u003ccode\u003ef\u003c/code\u003e, then the inverse of \u003ccode\u003et\u003c/code\u003e.  For\n   example, \u003ccode\u003e\u003ccode\u003escaleX\u003c/code\u003e 2 `\u003ccode\u003e\u003ca\u003eunder\u003c/a\u003e\u003c/code\u003e` \u003ccode\u003erotationBy\u003c/code\u003e (-1/8 :: Turn)\u003c/code\u003e\n   is the transformation which scales by a factor of 2 along the\n   diagonal line y = x.\n\u003c/p\u003e\u003cp\u003eNote that\n\u003c/p\u003e\u003cpre\u003e\n   (transform t2) \u003ccode\u003e\u003ca\u003eunder\u003c/a\u003e\u003c/code\u003e t1 == transform (conjugate t1 t2)\n\u003c/pre\u003e\u003cp\u003efor all transformations \u003ccode\u003et1\u003c/code\u003e and \u003ccode\u003et2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Transform",
          "name": "under",
          "package": "diagrams-lib",
          "signature": "(a -\u003e a) -\u003e Transformation (V a) -\u003e a -\u003e a",
          "source": "src/Diagrams-Transform.html#under",
          "type": "function"
        },
        "index": {
          "description": "Carry out some transformation under another one under first applies then then the inverse of For example scaleX under rotationBy Turn is the transformation which scales by factor of along the diagonal line Note that transform t2 under t1 transform conjugate t1 t2 for all transformations t1 and t2",
          "hierarchy": "Diagrams Transform",
          "module": "Diagrams.Transform",
          "name": "under",
          "normalized": "(a-\u003ea)-\u003eTransformation(V a)-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "(a-\u003ea)-\u003eTransformation(V a)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Transform.html#v:under"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA default diagram-adjustment implementation for two-dimensional\n diagrams, useful for backend implementors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Adjust",
          "name": "Adjust",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Adjust.html",
          "type": "module"
        },
        "index": {
          "description": "default diagram-adjustment implementation for two-dimensional diagrams useful for backend implementors",
          "hierarchy": "Diagrams TwoD Adjust",
          "module": "Diagrams.TwoD.Adjust",
          "name": "Adjust",
          "package": "diagrams-lib",
          "partial": "Adjust",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Adjust.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eadjustDia2D\u003c/code\u003e provides a useful default implementation of\n   the \u003ccode\u003e\u003ca\u003eadjustDia\u003c/a\u003e\u003c/code\u003e method from the \u003ccode\u003e\u003ca\u003eBackend\u003c/a\u003e\u003c/code\u003e type class.\n\u003c/p\u003e\u003cp\u003eAs its first two arguments it requires a method for extracting\n   the requested output size from the rendering options, and a way\n   of updating the rendering options with a new (more specific) size.\n\u003c/p\u003e\u003cp\u003eIt then performs the following adjustments:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Set default attributes (see \u003ccode\u003e\u003ca\u003esetDefault2DAttributes\u003c/a\u003e\u003c/code\u003e)\n\u003c/li\u003e\u003cli\u003e Freeze the diagram in its final form\n\u003c/li\u003e\u003cli\u003e Scale and translate the diagram to fit within the requested\n     size (see \u003ccode\u003e\u003ca\u003eadjustDiaSize2D\u003c/a\u003e\u003c/code\u003e)\n\u003c/li\u003e\u003cli\u003e Also return the actual adjusted size of the diagram.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Diagrams.TwoD.Adjust",
          "name": "adjustDia2D",
          "package": "diagrams-lib",
          "signature": "(Options b R2 -\u003e SizeSpec2D) -\u003e (SizeSpec2D -\u003e Options b R2 -\u003e Options b R2) -\u003e b -\u003e Options b R2 -\u003e QDiagram b R2 m -\u003e (Options b R2, QDiagram b R2 m)",
          "source": "src/Diagrams-TwoD-Adjust.html#adjustDia2D",
          "type": "function"
        },
        "index": {
          "description": "adjustDia2D provides useful default implementation of the adjustDia method from the Backend type class As its first two arguments it requires method for extracting the requested output size from the rendering options and way of updating the rendering options with new more specific size It then performs the following adjustments Set default attributes see setDefault2DAttributes Freeze the diagram in its final form Scale and translate the diagram to fit within the requested size see adjustDiaSize2D Also return the actual adjusted size of the diagram",
          "hierarchy": "Diagrams TwoD Adjust",
          "module": "Diagrams.TwoD.Adjust",
          "name": "adjustDia2D",
          "normalized": "(Options a R-\u003eSizeSpec D)-\u003e(SizeSpec D-\u003eOptions a R-\u003eOptions a R)-\u003ea-\u003eOptions a R-\u003eQDiagram a R b-\u003e(Options a R,QDiagram a R b)",
          "package": "diagrams-lib",
          "partial": "Dia",
          "signature": "(Options b R-\u003eSizeSpec D)-\u003e(SizeSpec D-\u003eOptions b R-\u003eOptions b R)-\u003eb-\u003eOptions b R-\u003eQDiagram b R m-\u003e(Options b R,QDiagram b R m)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Adjust.html#v:adjustDia2D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the size and position of a 2D diagram to fit within the\n   requested size. The first two arguments specify a method for\n   extracting the requested output size from the rendering options,\n   and a way of updating the rendering options with a new (more\n   specific) size.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Adjust",
          "name": "adjustDiaSize2D",
          "package": "diagrams-lib",
          "signature": "(Options b R2 -\u003e SizeSpec2D) -\u003e (SizeSpec2D -\u003e Options b R2 -\u003e Options b R2) -\u003e b -\u003e Options b R2 -\u003e QDiagram b R2 m -\u003e (Options b R2, QDiagram b R2 m)",
          "source": "src/Diagrams-TwoD-Adjust.html#adjustDiaSize2D",
          "type": "function"
        },
        "index": {
          "description": "Adjust the size and position of diagram to fit within the requested size The first two arguments specify method for extracting the requested output size from the rendering options and way of updating the rendering options with new more specific size",
          "hierarchy": "Diagrams TwoD Adjust",
          "module": "Diagrams.TwoD.Adjust",
          "name": "adjustDiaSize2D",
          "normalized": "(Options a R-\u003eSizeSpec D)-\u003e(SizeSpec D-\u003eOptions a R-\u003eOptions a R)-\u003ea-\u003eOptions a R-\u003eQDiagram a R b-\u003e(Options a R,QDiagram a R b)",
          "package": "diagrams-lib",
          "partial": "Dia Size",
          "signature": "(Options b R-\u003eSizeSpec D)-\u003e(SizeSpec D-\u003eOptions b R-\u003eOptions b R)-\u003eb-\u003eOptions b R-\u003eQDiagram b R m-\u003e(Options b R,QDiagram b R m)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Adjust.html#v:adjustDiaSize2D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use Diagrams.TwoD.Size.requiredScaleT instead.\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eRe-export \u003ccode\u003e\u003ca\u003erequiredScaleT\u003c/a\u003e\u003c/code\u003e with the name \u003ccode\u003e\u003ca\u003eadjustSize\u003c/a\u003e\u003c/code\u003e for\n   backwards compatibility.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Adjust",
          "name": "adjustSize",
          "package": "diagrams-lib",
          "signature": "SizeSpec2D -\u003e (Double, Double) -\u003e Transformation R2",
          "source": "src/Diagrams-TwoD-Adjust.html#adjustSize",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use Diagrams.TwoD.Size.requiredScaleT instead Re-export requiredScaleT with the name adjustSize for backwards compatibility",
          "hierarchy": "Diagrams TwoD Adjust",
          "module": "Diagrams.TwoD.Adjust",
          "name": "adjustSize",
          "normalized": "SizeSpec D-\u003e(Double,Double)-\u003eTransformation R",
          "package": "diagrams-lib",
          "partial": "Size",
          "signature": "SizeSpec D-\u003e(Double,Double)-\u003eTransformation R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Adjust.html#v:adjustSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erequiredScale spec sz\u003c/code\u003e returns a scaling factor necessary to\n   make something of size \u003ccode\u003esz\u003c/code\u003e fit the requested size \u003ccode\u003espec\u003c/code\u003e,\n   without changing the aspect ratio.  Hence an explicit\n   specification of both dimensions may not be honored if the aspect\n   ratios do not match; in that case the scaling will be as large as\n   possible so that the object still fits within the requested size.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Adjust\",\"Diagrams.TwoD.Size\"]",
          "name": "requiredScale",
          "package": "diagrams-lib",
          "signature": "SizeSpec2D -\u003e (Double, Double) -\u003e Double",
          "source": "src/Diagrams-TwoD-Size.html#requiredScale",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Adjust.html#v:requiredScale\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:requiredScale\"]"
        },
        "index": {
          "description": "requiredScale spec sz returns scaling factor necessary to make something of size sz fit the requested size spec without changing the aspect ratio Hence an explicit specification of both dimensions may not be honored if the aspect ratios do not match in that case the scaling will be as large as possible so that the object still fits within the requested size",
          "hierarchy": "Diagrams TwoD Adjust",
          "module": "Diagrams.TwoD.Adjust",
          "name": "requiredScale",
          "normalized": "SizeSpec D-\u003e(Double,Double)-\u003eDouble",
          "package": "diagrams-lib",
          "partial": "Scale",
          "signature": "SizeSpec D-\u003e(Double,Double)-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Adjust.html#v:requiredScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet default attributes of a 2D diagram (in case they have not\n   been set):\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Line width 0.01\n\u003c/li\u003e\u003cli\u003e Line color black\n\u003c/li\u003e\u003cli\u003e Font size 1\n\u003c/li\u003e\u003cli\u003e Line cap LineCapButt\n\u003c/li\u003e\u003cli\u003e line join miter\n\u003c/li\u003e\u003cli\u003e Miter limit 10\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Diagrams.TwoD.Adjust",
          "name": "setDefault2DAttributes",
          "package": "diagrams-lib",
          "signature": "QDiagram b R2 m -\u003e QDiagram b R2 m",
          "source": "src/Diagrams-TwoD-Adjust.html#setDefault2DAttributes",
          "type": "function"
        },
        "index": {
          "description": "Set default attributes of diagram in case they have not been set Line width Line color black Font size Line cap LineCapButt line join miter Miter limit",
          "hierarchy": "Diagrams TwoD Adjust",
          "module": "Diagrams.TwoD.Adjust",
          "name": "setDefault2DAttributes",
          "normalized": "QDiagram a R b-\u003eQDiagram a R b",
          "package": "diagrams-lib",
          "partial": "Default DAttributes",
          "signature": "QDiagram b R m-\u003eQDiagram b R m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Adjust.html#v:setDefault2DAttributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAlignment combinators specialized for two dimensions.  See\n \u003ca\u003eDiagrams.Align\u003c/a\u003e for more general alignment combinators.\n\u003c/p\u003e\u003cp\u003eThe basic idea is that alignment is achieved by moving diagrams'\n local origins relative to their envelopes or traces (or some other\n sort of boundary).  For example, to align several diagrams along\n their tops, we first move their local origins to the upper edge of\n their boundary (using e.g. \u003ccode\u003emap \u003ccode\u003ealignTop\u003c/code\u003e\u003c/code\u003e), and then put them\n together with their local origins along a horizontal line (using\n e.g. \u003ccode\u003ehcat\u003c/code\u003e from \u003ca\u003eDiagrams.TwoD.Combinators\u003c/a\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Align",
          "name": "Align",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Align.html",
          "type": "module"
        },
        "index": {
          "description": "Alignment combinators specialized for two dimensions See Diagrams.Align for more general alignment combinators The basic idea is that alignment is achieved by moving diagrams local origins relative to their envelopes or traces or some other sort of boundary For example to align several diagrams along their tops we first move their local origins to the upper edge of their boundary using e.g map alignTop and then put them together with their local origins along horizontal line using e.g hcat from Diagrams.TwoD.Combinators",
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "Align",
          "package": "diagrams-lib",
          "partial": "Align",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlign along the bottom edge.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "alignB",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#alignB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignB\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:alignB\"]"
        },
        "index": {
          "description": "Align along the bottom edge",
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "alignB",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "alignBL",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#alignBL",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignBL\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:alignBL\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "alignBL",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "partial": "BL",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignBL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "alignBR",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#alignBR",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignBR\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:alignBR\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "alignBR",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "partial": "BR",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignBR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlign along the left edge, i.e. translate the diagram in a\n   horizontal direction so that the local origin is on the left edge\n   of the envelope.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "alignL",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#alignL",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignL\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:alignL\"]"
        },
        "index": {
          "description": "Align along the left edge i.e translate the diagram in horizontal direction so that the local origin is on the left edge of the envelope",
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "alignL",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlign along the right edge.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "alignR",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#alignR",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignR\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:alignR\"]"
        },
        "index": {
          "description": "Align along the right edge",
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "alignR",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlign along the top edge.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "alignT",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#alignT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignT\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:alignT\"]"
        },
        "index": {
          "description": "Align along the top edge",
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "alignT",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "alignTL",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#alignTL",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignTL\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:alignTL\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "alignTL",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "partial": "TL",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignTL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "alignTR",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#alignTR",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignTR\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:alignTR\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "alignTR",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "partial": "TR",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignTR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ealignX\u003c/code\u003e and \u003ccode\u003esnugX\u003c/code\u003e move the local origin horizontally as follows:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003ealignX (-1)\u003c/code\u003e moves the local origin to the left edge of the boundary;\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ealign 1\u003c/code\u003e moves the local origin to the right edge;\n\u003c/li\u003e\u003cli\u003e any other argument interpolates linearly between these.  For\n     example, \u003ccode\u003ealignX 0\u003c/code\u003e centers, \u003ccode\u003ealignX 2\u003c/code\u003e moves the origin one\n     \"radius\" to the right of the right edge, and so on.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003esnugX\u003c/code\u003e works the same way.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "alignX",
          "package": "diagrams-lib",
          "signature": "Double -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#alignX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:alignX\"]"
        },
        "index": {
          "description": "alignX and snugX move the local origin horizontally as follows alignX moves the local origin to the left edge of the boundary align moves the local origin to the right edge any other argument interpolates linearly between these For example alignX centers alignX moves the origin one radius to the right of the right edge and so on snugX works the same way",
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "alignX",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ealignX\u003c/a\u003e\u003c/code\u003e, but moving the local origin vertically, with an\n   argument of \u003ccode\u003e1\u003c/code\u003e corresponding to the top edge and \u003ccode\u003e(-1)\u003c/code\u003e corresponding\n   to the bottom edge.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "alignY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#alignY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:alignY\"]"
        },
        "index": {
          "description": "Like alignX but moving the local origin vertically with an argument of corresponding to the top edge and corresponding to the bottom edge",
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "alignY",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:alignY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCenter the local origin along the X-axis.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "centerX",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#centerX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:centerX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:centerX\"]"
        },
        "index": {
          "description": "Center the local origin along the X-axis",
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "centerX",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:centerX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCenter along both the X- and Y-axes.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "centerXY",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#centerXY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:centerXY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:centerXY\"]"
        },
        "index": {
          "description": "Center along both the and Y-axes",
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "centerXY",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "partial": "XY",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:centerXY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCenter the local origin along the Y-axis.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "centerY",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#centerY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:centerY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:centerY\"]"
        },
        "index": {
          "description": "Center the local origin along the Y-axis",
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "centerY",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:centerY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "snugB",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#snugB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugB\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:snugB\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "snugB",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "snugBL",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#snugBL",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugBL\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:snugBL\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "snugBL",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "partial": "BL",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugBL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "snugBR",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#snugBR",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugBR\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:snugBR\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "snugBR",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "partial": "BR",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugBR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "snugCenterX",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#snugCenterX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugCenterX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:snugCenterX\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "snugCenterX",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "partial": "Center",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugCenterX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "snugCenterXY",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#snugCenterXY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugCenterXY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:snugCenterXY\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "snugCenterXY",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "partial": "Center XY",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugCenterXY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "snugCenterY",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#snugCenterY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugCenterY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:snugCenterY\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "snugCenterY",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "partial": "Center",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugCenterY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "snugL",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#snugL",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugL\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:snugL\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "snugL",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "snugR",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#snugR",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugR\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:snugR\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "snugR",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "snugT",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#snugT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugT\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:snugT\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "snugT",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "snugTL",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#snugTL",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugTL\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:snugTL\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "snugTL",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "partial": "TL",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugTL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "snugTR",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#snugTR",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugTR\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:snugTR\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "snugTR",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "partial": "TR",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugTR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSee the documentation for \u003ccode\u003e\u003ca\u003ealignX\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "snugX",
          "package": "diagrams-lib",
          "signature": "Double -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#snugX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:snugX\"]"
        },
        "index": {
          "description": "See the documentation for alignX",
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "snugX",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Align\",\"Diagrams.TwoD\"]",
          "name": "snugY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Align.html#snugY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:snugY\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Align",
          "module": "Diagrams.TwoD.Align",
          "name": "snugY",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Align.html#v:snugY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTwo-dimensional arcs, approximated by cubic bezier curves.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Arc",
          "name": "Arc",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Arc.html",
          "type": "module"
        },
        "index": {
          "description": "Two-dimensional arcs approximated by cubic bezier curves",
          "hierarchy": "Diagrams TwoD Arc",
          "module": "Diagrams.TwoD.Arc",
          "name": "Arc",
          "package": "diagrams-lib",
          "partial": "Arc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an annular wedge of the given radii, beginning at the\n   first angle and extending counterclockwise to the second.\n   The radius of the outer circle is given first.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arc_annularWedgeEx.svg#diagram=annularWedgeEx&width=400\"/\u003e\n\u003c/p\u003e\u003cpre\u003e annularWedgeEx = hcat' (with & sep .~ 0.50)\n   [ annularWedge 1 0.5 (0 :: Turn) (1/4)\n   , annularWedge 1 0.3 (7/30 :: Turn) (11/30)\n   , annularWedge 1 0.7 (1/8 :: Turn) (7/8)\n   ]\n   # fc blue\n   # centerXY # pad 1.1\n\u003c/pre\u003e",
          "module": "[\"Diagrams.TwoD.Arc\",\"Diagrams.TwoD\"]",
          "name": "annularWedge",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Double -\u003e a -\u003e a -\u003e p",
          "source": "src/Diagrams-TwoD-Arc.html#annularWedge",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#v:annularWedge\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:annularWedge\"]"
        },
        "index": {
          "description": "Create an annular wedge of the given radii beginning at the first angle and extending counterclockwise to the second The radius of the outer circle is given first annularWedgeEx hcat with sep annularWedge Turn annularWedge Turn annularWedge Turn fc blue centerXY pad",
          "hierarchy": "Diagrams TwoD Arc",
          "module": "Diagrams.TwoD.Arc",
          "name": "annularWedge",
          "normalized": "Double-\u003eDouble-\u003ea-\u003ea-\u003eb",
          "package": "diagrams-lib",
          "partial": "Wedge",
          "signature": "Double-\u003eDouble-\u003ea-\u003ea-\u003ep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#v:annularWedge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a start angle \u003ccode\u003es\u003c/code\u003e and an end angle \u003ccode\u003ee\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003earc\u003c/a\u003e\u003c/code\u003e s e\u003c/code\u003e is the\n   path of a radius one arc counterclockwise between the two angles.\n   The origin of the arc is its center.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arc\",\"Diagrams.TwoD\"]",
          "name": "arc",
          "package": "diagrams-lib",
          "signature": "a -\u003e a -\u003e t",
          "source": "src/Diagrams-TwoD-Arc.html#arc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#v:arc\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:arc\"]"
        },
        "index": {
          "description": "Given start angle and an end angle arc is the path of radius one arc counterclockwise between the two angles The origin of the arc is its center",
          "hierarchy": "Diagrams TwoD Arc",
          "module": "Diagrams.TwoD.Arc",
          "name": "arc",
          "normalized": "a-\u003ea-\u003eb",
          "package": "diagrams-lib",
          "signature": "a-\u003ea-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#v:arc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a radus \u003ccode\u003er\u003c/code\u003e, a start angle \u003ccode\u003es\u003c/code\u003e and an end angle \u003ccode\u003ee\u003c/code\u003e,\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003earc'\u003c/a\u003e\u003c/code\u003e r s e\u003c/code\u003e is the path of a radius \u003ccode\u003e(abs r)\u003c/code\u003e arc between\n   the two angles.  If a negative radius is given, the arc will\n   be clockwise, otherwise it will be counterclockwise. The origin\n   of the arc is its center.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arc_arc'Ex.svg#diagram=arc'Ex&width=300\"/\u003e\n\u003c/p\u003e\u003cpre\u003e arc'Ex = mconcat [ arc' r 0 (1/4 :: Turn) | r \u003c- [0.5,-1,1.5] ]\n        # centerXY # pad 1.1\n\u003c/pre\u003e",
          "module": "[\"Diagrams.TwoD.Arc\",\"Diagrams.TwoD\"]",
          "name": "arc'",
          "package": "diagrams-lib",
          "signature": "Double -\u003e a -\u003e a -\u003e p",
          "source": "src/Diagrams-TwoD-Arc.html#arc%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#v:arc-39-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:arc-39-\"]"
        },
        "index": {
          "description": "Given radus start angle and an end angle arc is the path of radius abs arc between the two angles If negative radius is given the arc will be clockwise otherwise it will be counterclockwise The origin of the arc is its center arc Ex mconcat arc Turn centerXY pad",
          "hierarchy": "Diagrams TwoD Arc",
          "module": "Diagrams.TwoD.Arc",
          "name": "arc'",
          "normalized": "Double-\u003ea-\u003ea-\u003eb",
          "package": "diagrams-lib",
          "signature": "Double-\u003ea-\u003ea-\u003ep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#v:arc-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003earcBetween p q height\u003c/code\u003e creates an arc beginning at \u003ccode\u003ep\u003c/code\u003e and\n   ending at \u003ccode\u003eq\u003c/code\u003e, with its midpoint at a distance of \u003ccode\u003eabs height\u003c/code\u003e\n   away from the straight line from \u003ccode\u003ep\u003c/code\u003e to \u003ccode\u003eq\u003c/code\u003e.  A positive value of\n   \u003ccode\u003eheight\u003c/code\u003e results in an arc to the left of the line from \u003ccode\u003ep\u003c/code\u003e to\n   \u003ccode\u003eq\u003c/code\u003e; a negative value yields one to the right.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arc_arcBetweenEx.svg#diagram=arcBetweenEx&width=300\"/\u003e\n\u003c/p\u003e\u003cpre\u003e arcBetweenEx = mconcat\n   [ arcBetween origin (p2 (2,1)) ht | ht \u003c- [-0.2, -0.1 .. 0.2] ]\n   # centerXY # pad 1.1\n\u003c/pre\u003e",
          "module": "[\"Diagrams.TwoD.Arc\",\"Diagrams.TwoD\"]",
          "name": "arcBetween",
          "package": "diagrams-lib",
          "signature": "P2 -\u003e P2 -\u003e Double -\u003e t",
          "source": "src/Diagrams-TwoD-Arc.html#arcBetween",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#v:arcBetween\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:arcBetween\"]"
        },
        "index": {
          "description": "arcBetween height creates an arc beginning at and ending at with its midpoint at distance of abs height away from the straight line from to positive value of height results in an arc to the left of the line from to negative value yields one to the right arcBetweenEx mconcat arcBetween origin p2 ht ht centerXY pad",
          "hierarchy": "Diagrams TwoD Arc",
          "module": "Diagrams.TwoD.Arc",
          "name": "arcBetween",
          "normalized": "P-\u003eP-\u003eDouble-\u003ea",
          "package": "diagrams-lib",
          "partial": "Between",
          "signature": "P-\u003eP-\u003eDouble-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#v:arcBetween"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003earc\u003c/a\u003e\u003c/code\u003e but clockwise.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arc\",\"Diagrams.TwoD\"]",
          "name": "arcCW",
          "package": "diagrams-lib",
          "signature": "a -\u003e a -\u003e t",
          "source": "src/Diagrams-TwoD-Arc.html#arcCW",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#v:arcCW\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:arcCW\"]"
        },
        "index": {
          "description": "Like arc but clockwise",
          "hierarchy": "Diagrams TwoD Arc",
          "module": "Diagrams.TwoD.Arc",
          "name": "arcCW",
          "normalized": "a-\u003ea-\u003eb",
          "package": "diagrams-lib",
          "partial": "CW",
          "signature": "a-\u003ea-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#v:arcCW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a start angle \u003ccode\u003es\u003c/code\u003e and an end angle \u003ccode\u003ee\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003earcT\u003c/a\u003e\u003c/code\u003e s e\u003c/code\u003e is the\n   \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e of a radius one arc counterclockwise between the two angles.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arc",
          "name": "arcT",
          "package": "diagrams-lib",
          "signature": "a -\u003e a -\u003e Trail R2",
          "source": "src/Diagrams-TwoD-Arc.html#arcT",
          "type": "function"
        },
        "index": {
          "description": "Given start angle and an end angle arcT is the Trail of radius one arc counterclockwise between the two angles",
          "hierarchy": "Diagrams TwoD Arc",
          "module": "Diagrams.TwoD.Arc",
          "name": "arcT",
          "normalized": "a-\u003ea-\u003eTrail R",
          "package": "diagrams-lib",
          "signature": "a-\u003ea-\u003eTrail R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#v:arcT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ebezierFromSweep s\u003c/code\u003e constructs a series of \u003ccode\u003e\u003ca\u003eCubic\u003c/a\u003e\u003c/code\u003e segments that\n   start in the positive y direction and sweep counter clockwise\n   through \u003ccode\u003es\u003c/code\u003e radians.  If \u003ccode\u003es\u003c/code\u003e is negative, it will start in the\n   negative y direction and sweep clockwise.  When \u003ccode\u003es\u003c/code\u003e is less than\n   0.0001 the empty list results.  If the sweep is greater than tau\n   then it is truncated to tau.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arc",
          "name": "bezierFromSweep",
          "package": "diagrams-lib",
          "signature": "Rad -\u003e [Segment Closed R2]",
          "source": "src/Diagrams-TwoD-Arc.html#bezierFromSweep",
          "type": "function"
        },
        "index": {
          "description": "bezierFromSweep constructs series of Cubic segments that start in the positive direction and sweep counter clockwise through radians If is negative it will start in the negative direction and sweep clockwise When is less than the empty list results If the sweep is greater than tau then it is truncated to tau",
          "hierarchy": "Diagrams TwoD Arc",
          "module": "Diagrams.TwoD.Arc",
          "name": "bezierFromSweep",
          "normalized": "Rad-\u003e[Segment Closed R]",
          "package": "diagrams-lib",
          "partial": "From Sweep",
          "signature": "Rad-\u003e[Segment Closed R]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#v:bezierFromSweep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a circular wedge of the given radius, beginning at the\n   first angle and extending counterclockwise to the second.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arc_wedgeEx.svg#diagram=wedgeEx&width=400\"/\u003e\n\u003c/p\u003e\u003cpre\u003e wedgeEx = hcat' (with & sep .~ 0.5)\n   [ wedge 1 (0 :: Turn) (1/4)\n   , wedge 1 (7/30 :: Turn) (11/30)\n   , wedge 1 (1/8 :: Turn) (7/8)\n   ]\n   # fc blue\n   # centerXY # pad 1.1\n\u003c/pre\u003e",
          "module": "[\"Diagrams.TwoD.Arc\",\"Diagrams.TwoD\"]",
          "name": "wedge",
          "package": "diagrams-lib",
          "signature": "Double -\u003e a -\u003e a -\u003e p",
          "source": "src/Diagrams-TwoD-Arc.html#wedge",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#v:wedge\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:wedge\"]"
        },
        "index": {
          "description": "Create circular wedge of the given radius beginning at the first angle and extending counterclockwise to the second wedgeEx hcat with sep wedge Turn wedge Turn wedge Turn fc blue centerXY pad",
          "hierarchy": "Diagrams TwoD Arc",
          "module": "Diagrams.TwoD.Arc",
          "name": "wedge",
          "normalized": "Double-\u003ea-\u003ea-\u003eb",
          "package": "diagrams-lib",
          "signature": "Double-\u003ea-\u003ea-\u003ep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arc.html#v:wedge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDrawing arrows in two dimensions.  For a tutorial on drawing arrows\n using this module, see the diagrams website:\n \u003ca\u003ehttp://projects.haskell.org/diagrams/doc/arrow.html\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Arrow",
          "name": "Arrow",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Arrow.html",
          "type": "module"
        },
        "index": {
          "description": "Drawing arrows in two dimensions For tutorial on drawing arrows using this module see the diagrams website http projects.haskell.org diagrams doc arrow.html",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "Arrow",
          "package": "diagrams-lib",
          "partial": "Arrow",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Arrow",
          "name": "ArrowOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Arrow.html#ArrowOpts",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "ArrowOpts",
          "package": "diagrams-lib",
          "partial": "Arrow Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#t:ArrowOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "ArrowOpts",
          "package": "diagrams-lib",
          "signature": "ArrowOpts",
          "source": "src/Diagrams-TwoD-Arrow.html#ArrowOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:ArrowOpts\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:ArrowOpts\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "ArrowOpts",
          "package": "diagrams-lib",
          "partial": "Arrow Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:ArrowOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "_arrowHead",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrow.html#ArrowOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_arrowHead\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_arrowHead\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "_arrowHead",
          "package": "diagrams-lib",
          "partial": "Head",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_arrowHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "_arrowShaft",
          "package": "diagrams-lib",
          "signature": "Trail R2",
          "source": "src/Diagrams-TwoD-Arrow.html#ArrowOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_arrowShaft\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_arrowShaft\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "_arrowShaft",
          "package": "diagrams-lib",
          "partial": "Shaft",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_arrowShaft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "_arrowTail",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrow.html#ArrowOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_arrowTail\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_arrowTail\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "_arrowTail",
          "package": "diagrams-lib",
          "partial": "Tail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_arrowTail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "_headGap",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-TwoD-Arrow.html#ArrowOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_headGap\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_headGap\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "_headGap",
          "package": "diagrams-lib",
          "partial": "Gap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_headGap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "_headSize",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-TwoD-Arrow.html#ArrowOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_headSize\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_headSize\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "_headSize",
          "package": "diagrams-lib",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_headSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "_headStyle",
          "package": "diagrams-lib",
          "signature": "Style R2",
          "source": "src/Diagrams-TwoD-Arrow.html#ArrowOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_headStyle\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_headStyle\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "_headStyle",
          "package": "diagrams-lib",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_headStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "_shaftStyle",
          "package": "diagrams-lib",
          "signature": "Style R2",
          "source": "src/Diagrams-TwoD-Arrow.html#ArrowOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_shaftStyle\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_shaftStyle\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "_shaftStyle",
          "package": "diagrams-lib",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_shaftStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "_tailGap",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-TwoD-Arrow.html#ArrowOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_tailGap\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_tailGap\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "_tailGap",
          "package": "diagrams-lib",
          "partial": "Gap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_tailGap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "_tailSize",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-TwoD-Arrow.html#ArrowOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_tailSize\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_tailSize\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "_tailSize",
          "package": "diagrams-lib",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_tailSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "_tailStyle",
          "package": "diagrams-lib",
          "signature": "Style R2",
          "source": "src/Diagrams-TwoD-Arrow.html#ArrowOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_tailStyle\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_tailStyle\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "_tailStyle",
          "package": "diagrams-lib",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:_tailStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003earrow len\u003c/code\u003e creates an arrow of length \u003ccode\u003elen\u003c/code\u003e with default\n   parameters, starting at the origin and ending at the point\n   \u003ccode\u003e(len,0)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "arrow",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Arrow.html#arrow",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrow\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:arrow\"]"
        },
        "index": {
          "description": "arrow len creates an arrow of length len with default parameters starting at the origin and ending at the point len",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "arrow",
          "normalized": "Double-\u003eDiagram a R",
          "package": "diagrams-lib",
          "signature": "Double-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003earrow' opts len\u003c/code\u003e creates an arrow of length \u003ccode\u003elen\u003c/code\u003e using the\n   given options, starting at the origin and ending at the point\n   \u003ccode\u003e(len,0)\u003c/code\u003e.  In particular, it scales the given \u003ccode\u003e\u003ca\u003earrowShaft\u003c/a\u003e\u003c/code\u003e so\n   that the entire arrow has length \u003ccode\u003elen\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "arrow'",
          "package": "diagrams-lib",
          "signature": "ArrowOpts -\u003e Double -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Arrow.html#arrow%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrow-39-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:arrow-39-\"]"
        },
        "index": {
          "description": "arrow opts len creates an arrow of length len using the given options starting at the origin and ending at the point len In particular it scales the given arrowShaft so that the entire arrow has length len",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "arrow'",
          "normalized": "ArrowOpts-\u003eDouble-\u003eDiagram a R",
          "package": "diagrams-lib",
          "signature": "ArrowOpts-\u003eDouble-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrow-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an arrow starting at s with length and direction determined by\n   the vectore v.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "arrowAt",
          "package": "diagrams-lib",
          "signature": "P2 -\u003e R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Arrow.html#arrowAt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrowAt\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:arrowAt\"]"
        },
        "index": {
          "description": "Create an arrow starting at with length and direction determined by the vectore",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "arrowAt",
          "normalized": "P-\u003eR-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "At",
          "signature": "P-\u003eR-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrowAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "arrowAt'",
          "package": "diagrams-lib",
          "signature": "ArrowOpts -\u003e P2 -\u003e R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Arrow.html#arrowAt%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrowAt-39-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:arrowAt-39-\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "arrowAt'",
          "normalized": "ArrowOpts-\u003eP-\u003eR-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "At'",
          "signature": "ArrowOpts-\u003eP-\u003eR-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrowAt-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003earrowBetween s e\u003c/code\u003e creates an arrow pointing from \u003ccode\u003es\u003c/code\u003e to \u003ccode\u003ee\u003c/code\u003e\n   with default parameters.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "arrowBetween",
          "package": "diagrams-lib",
          "signature": "P2 -\u003e P2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Arrow.html#arrowBetween",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrowBetween\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:arrowBetween\"]"
        },
        "index": {
          "description": "arrowBetween creates an arrow pointing from to with default parameters",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "arrowBetween",
          "normalized": "P-\u003eP-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "Between",
          "signature": "P-\u003eP-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrowBetween"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003earrowBetween' opts s e\u003c/code\u003e creates an arrow pointing from \u003ccode\u003es\u003c/code\u003e to\n   \u003ccode\u003ee\u003c/code\u003e using the given options.  In particular, it scales and\n   rotates \u003ccode\u003earrowShaft\u003c/code\u003e to go between \u003ccode\u003es\u003c/code\u003e and \u003ccode\u003ee\u003c/code\u003e, taking head,\n   tail, and gaps into account.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "arrowBetween'",
          "package": "diagrams-lib",
          "signature": "ArrowOpts -\u003e P2 -\u003e P2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Arrow.html#arrowBetween%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrowBetween-39-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:arrowBetween-39-\"]"
        },
        "index": {
          "description": "arrowBetween opts creates an arrow pointing from to using the given options In particular it scales and rotates arrowShaft to go between and taking head tail and gaps into account",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "arrowBetween'",
          "normalized": "ArrowOpts-\u003eP-\u003eP-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "Between'",
          "signature": "ArrowOpts-\u003eP-\u003eP-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrowBetween-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA shape to place at the head of the arrow.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "arrowHead",
          "package": "diagrams-lib",
          "signature": "Lens' ArrowOpts ArrowHT",
          "source": "src/Diagrams-TwoD-Arrow.html#arrowHead",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrowHead\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:arrowHead\"]"
        },
        "index": {
          "description": "shape to place at the head of the arrow",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "arrowHead",
          "package": "diagrams-lib",
          "partial": "Head",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrowHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe trail to use for the arrow shaft.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "arrowShaft",
          "package": "diagrams-lib",
          "signature": "Lens' ArrowOpts (Trail R2)",
          "source": "src/Diagrams-TwoD-Arrow.html#arrowShaft",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrowShaft\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:arrowShaft\"]"
        },
        "index": {
          "description": "The trail to use for the arrow shaft",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "arrowShaft",
          "package": "diagrams-lib",
          "partial": "Shaft",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrowShaft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA shape to place at the tail of the arrow.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "arrowTail",
          "package": "diagrams-lib",
          "signature": "Lens' ArrowOpts ArrowHT",
          "source": "src/Diagrams-TwoD-Arrow.html#arrowTail",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrowTail\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:arrowTail\"]"
        },
        "index": {
          "description": "shape to place at the tail of the arrow",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "arrowTail",
          "package": "diagrams-lib",
          "partial": "Tail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:arrowTail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConnect two diagrams with a straight arrow.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "connect",
          "package": "diagrams-lib",
          "signature": "n1 -\u003e n2 -\u003e Diagram b R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Arrow.html#connect",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:connect\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:connect\"]"
        },
        "index": {
          "description": "Connect two diagrams with straight arrow",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "connect",
          "normalized": "a-\u003ea-\u003eDiagram b R-\u003eDiagram b R",
          "package": "diagrams-lib",
          "signature": "n-\u003en-\u003eDiagram b R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:connect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConnect two diagrams with an arbitrary arrow.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "connect'",
          "package": "diagrams-lib",
          "signature": "ArrowOpts -\u003e n1 -\u003e n2 -\u003e Diagram b R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Arrow.html#connect%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:connect-39-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:connect-39-\"]"
        },
        "index": {
          "description": "Connect two diagrams with an arbitrary arrow",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "connect'",
          "normalized": "ArrowOpts-\u003ea-\u003ea-\u003eDiagram b R-\u003eDiagram b R",
          "package": "diagrams-lib",
          "signature": "ArrowOpts-\u003en-\u003en-\u003eDiagram b R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:connect-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDraw an arrow from diagram named \u003ca\u003en1\u003c/a\u003e to diagram named \u003ca\u003en2\u003c/a\u003e.  The\n   arrow lies on the line between the centres of the diagrams, but is\n   drawn so that it stops at the boundaries of the diagrams, using traces\n   to find the intersection points.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "connectOutside",
          "package": "diagrams-lib",
          "signature": "n1 -\u003e n2 -\u003e Diagram b R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Arrow.html#connectOutside",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:connectOutside\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:connectOutside\"]"
        },
        "index": {
          "description": "Draw an arrow from diagram named n1 to diagram named n2 The arrow lies on the line between the centres of the diagrams but is drawn so that it stops at the boundaries of the diagrams using traces to find the intersection points",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "connectOutside",
          "normalized": "a-\u003ea-\u003eDiagram b R-\u003eDiagram b R",
          "package": "diagrams-lib",
          "partial": "Outside",
          "signature": "n-\u003en-\u003eDiagram b R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:connectOutside"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "connectOutside'",
          "package": "diagrams-lib",
          "signature": "ArrowOpts -\u003e n1 -\u003e n2 -\u003e Diagram b R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Arrow.html#connectOutside%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:connectOutside-39-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:connectOutside-39-\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "connectOutside'",
          "normalized": "ArrowOpts-\u003ea-\u003ea-\u003eDiagram b R-\u003eDiagram b R",
          "package": "diagrams-lib",
          "partial": "Outside'",
          "signature": "ArrowOpts-\u003en-\u003en-\u003eDiagram b R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:connectOutside-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConnect two diagrams at point on the perimeter of the diagrams, choosen\n   by angle.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "connectPerim",
          "package": "diagrams-lib",
          "signature": "n1 -\u003e n2 -\u003e a -\u003e a -\u003e Diagram b R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Arrow.html#connectPerim",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:connectPerim\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:connectPerim\"]"
        },
        "index": {
          "description": "Connect two diagrams at point on the perimeter of the diagrams choosen by angle",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "connectPerim",
          "normalized": "a-\u003ea-\u003eb-\u003eb-\u003eDiagram c R-\u003eDiagram c R",
          "package": "diagrams-lib",
          "partial": "Perim",
          "signature": "n-\u003en-\u003ea-\u003ea-\u003eDiagram b R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:connectPerim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "connectPerim'",
          "package": "diagrams-lib",
          "signature": "ArrowOpts -\u003e n1 -\u003e n2 -\u003e a -\u003e a -\u003e Diagram b R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Arrow.html#connectPerim%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:connectPerim-39-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:connectPerim-39-\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "connectPerim'",
          "normalized": "ArrowOpts-\u003ea-\u003ea-\u003eb-\u003eb-\u003eDiagram c R-\u003eDiagram c R",
          "package": "diagrams-lib",
          "partial": "Perim'",
          "signature": "ArrowOpts-\u003en-\u003en-\u003ea-\u003ea-\u003eDiagram b R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:connectPerim-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA lens for setting or modifying the color of an arrowhead. For\n   example, one may write \u003ccode\u003e... (with & headColor .~ blue)\u003c/code\u003e to get an\n   arrow with a blue head, or \u003ccode\u003e... (with & headColor %~ blend 0.5\n   white)\u003c/code\u003e to make an arrow's head a lighter color.  For more general\n   control over the style of arrowheads, see \u003ccode\u003e\u003ca\u003eheadStyle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that the most general type of \u003ccode\u003eheadColor\u003c/code\u003e would be\n\u003c/p\u003e\u003cpre\u003e\n   (Color c, Color c') =\u003e Setter ArrowOpts ArrowOpts c c'\n\u003c/pre\u003e\u003cp\u003ebut that can cause problems for type inference when setting the\n   color.  However, using it at that more general type may\n   occasionally be useful, for example, if you want to apply some\n   opacity to a color, as in \u003ccode\u003e... (with & headColor %~\n   (`withOpacity` 0.5))\u003c/code\u003e.  If you want the more general type, you\n   can use \u003ccode\u003e\u003ccode\u003e\u003ca\u003eheadStyle\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003estyleFillColor\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e in place of \u003ccode\u003eheadColor\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "headColor",
          "package": "diagrams-lib",
          "signature": "Setter' ArrowOpts c",
          "source": "src/Diagrams-TwoD-Arrow.html#headColor",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:headColor\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:headColor\"]"
        },
        "index": {
          "description": "lens for setting or modifying the color of an arrowhead For example one may write with headColor blue to get an arrow with blue head or with headColor blend white to make an arrow head lighter color For more general control over the style of arrowheads see headStyle Note that the most general type of headColor would be Color Color Setter ArrowOpts ArrowOpts but that can cause problems for type inference when setting the color However using it at that more general type may occasionally be useful for example if you want to apply some opacity to color as in with headColor withOpacity If you want the more general type you can use headStyle styleFillColor in place of headColor",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "headColor",
          "package": "diagrams-lib",
          "partial": "Color",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:headColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDistance to leave between the head and the target point.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "headGap",
          "package": "diagrams-lib",
          "signature": "Lens' ArrowOpts Double",
          "source": "src/Diagrams-TwoD-Arrow.html#headGap",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:headGap\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:headGap\"]"
        },
        "index": {
          "description": "Distance to leave between the head and the target point",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "headGap",
          "package": "diagrams-lib",
          "partial": "Gap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:headGap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRadius of a circumcircle around the head.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "headSize",
          "package": "diagrams-lib",
          "signature": "Lens' ArrowOpts Double",
          "source": "src/Diagrams-TwoD-Arrow.html#headSize",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:headSize\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:headSize\"]"
        },
        "index": {
          "description": "Radius of circumcircle around the head",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "headSize",
          "package": "diagrams-lib",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:headSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStyle to apply to the head. \u003ccode\u003eheadStyle\u003c/code\u003e is modified by using the lens\n   combinator \u003ccode\u003e%~\u003c/code\u003e to change the current style. For example, to change\n   an opaque black arrowhead to translucent orange:\n   \u003ccode\u003e(with & headStyle %~ fc orange .  opacity 0.75)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "headStyle",
          "package": "diagrams-lib",
          "signature": "Lens' ArrowOpts (Style R2)",
          "source": "src/Diagrams-TwoD-Arrow.html#headStyle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:headStyle\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:headStyle\"]"
        },
        "index": {
          "description": "Style to apply to the head headStyle is modified by using the lens combinator to change the current style For example to change an opaque black arrowhead to translucent orange with headStyle fc orange opacity",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "headStyle",
          "package": "diagrams-lib",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:headStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA lens for setting or modifying the color of an arrow\n   shaft. See \u003ccode\u003e\u003ca\u003eheadColor\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "shaftColor",
          "package": "diagrams-lib",
          "signature": "Setter' ArrowOpts c",
          "source": "src/Diagrams-TwoD-Arrow.html#shaftColor",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:shaftColor\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:shaftColor\"]"
        },
        "index": {
          "description": "lens for setting or modifying the color of an arrow shaft See headColor",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "shaftColor",
          "package": "diagrams-lib",
          "partial": "Color",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:shaftColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStyle to apply to the shaft. See \u003ccode\u003e\u003ca\u003eheadStyle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "shaftStyle",
          "package": "diagrams-lib",
          "signature": "Lens' ArrowOpts (Style R2)",
          "source": "src/Diagrams-TwoD-Arrow.html#shaftStyle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:shaftStyle\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:shaftStyle\"]"
        },
        "index": {
          "description": "Style to apply to the shaft See headStyle",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "shaftStyle",
          "package": "diagrams-lib",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:shaftStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStraight line arrow shaft.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "straightShaft",
          "package": "diagrams-lib",
          "signature": "Trail R2",
          "source": "src/Diagrams-TwoD-Arrow.html#straightShaft",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:straightShaft\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:straightShaft\"]"
        },
        "index": {
          "description": "Straight line arrow shaft",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "straightShaft",
          "package": "diagrams-lib",
          "partial": "Shaft",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:straightShaft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA lens for setting or modifying the color of an arrow\n   tail. See \u003ccode\u003e\u003ca\u003eheadColor\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "tailColor",
          "package": "diagrams-lib",
          "signature": "Setter' ArrowOpts c",
          "source": "src/Diagrams-TwoD-Arrow.html#tailColor",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:tailColor\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:tailColor\"]"
        },
        "index": {
          "description": "lens for setting or modifying the color of an arrow tail See headColor",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "tailColor",
          "package": "diagrams-lib",
          "partial": "Color",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:tailColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDistance to leave between the starting point and the tail.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "tailGap",
          "package": "diagrams-lib",
          "signature": "Lens' ArrowOpts Double",
          "source": "src/Diagrams-TwoD-Arrow.html#tailGap",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:tailGap\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:tailGap\"]"
        },
        "index": {
          "description": "Distance to leave between the starting point and the tail",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "tailGap",
          "package": "diagrams-lib",
          "partial": "Gap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:tailGap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRadius of a circumcircle around the tail.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "tailSize",
          "package": "diagrams-lib",
          "signature": "Lens' ArrowOpts Double",
          "source": "src/Diagrams-TwoD-Arrow.html#tailSize",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:tailSize\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:tailSize\"]"
        },
        "index": {
          "description": "Radius of circumcircle around the tail",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "tailSize",
          "package": "diagrams-lib",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:tailSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStyle to apply to the tail. See \u003ccode\u003e\u003ca\u003eheadStyle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Arrow\",\"Diagrams.TwoD\"]",
          "name": "tailStyle",
          "package": "diagrams-lib",
          "signature": "Lens' ArrowOpts (Style R2)",
          "source": "src/Diagrams-TwoD-Arrow.html#tailStyle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:tailStyle\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:tailStyle\"]"
        },
        "index": {
          "description": "Style to apply to the tail See headStyle",
          "hierarchy": "Diagrams TwoD Arrow",
          "module": "Diagrams.TwoD.Arrow",
          "name": "tailStyle",
          "package": "diagrams-lib",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrow.html#v:tailStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eStandard arrowheads and tails. Each arrowhead or tail is designed\n to be drawn filled, with a line width of 0, and is normalized to\n fit inside a circle of diameter 1.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "Arrowheads",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Arrowheads.html",
          "type": "module"
        },
        "index": {
          "description": "Standard arrowheads and tails Each arrowhead or tail is designed to be drawn filled with line width of and is normalized to fit inside circle of diameter",
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "Arrowheads",
          "package": "diagrams-lib",
          "partial": "Arrowheads",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "ArrowHT",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Arrowheads.html#ArrowHT",
          "type": "type"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "ArrowHT",
          "package": "diagrams-lib",
          "partial": "Arrow HT",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#t:ArrowHT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIsoceles triangle with linear concave base. Inkscape type 1 - dart like.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "arrowheadDart",
          "package": "diagrams-lib",
          "signature": "a -\u003e ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#arrowheadDart",
          "type": "function"
        },
        "index": {
          "description": "Isoceles triangle with linear concave base Inkscape type dart like",
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "arrowheadDart",
          "normalized": "a-\u003eArrowHT",
          "package": "diagrams-lib",
          "partial": "Dart",
          "signature": "a-\u003eArrowHT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:arrowheadDart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "arrowheadMissile",
          "package": "diagrams-lib",
          "signature": "a -\u003e ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#arrowheadMissile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "arrowheadMissile",
          "normalized": "a-\u003eArrowHT",
          "package": "diagrams-lib",
          "partial": "Missile",
          "signature": "a-\u003eArrowHT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:arrowheadMissile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIsoceles triangle with curved concave base. Inkscape type 2.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "arrowheadSpike",
          "package": "diagrams-lib",
          "signature": "a -\u003e ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#arrowheadSpike",
          "type": "function"
        },
        "index": {
          "description": "Isoceles triangle with curved concave base Inkscape type",
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "arrowheadSpike",
          "normalized": "a-\u003eArrowHT",
          "package": "diagrams-lib",
          "partial": "Spike",
          "signature": "a-\u003eArrowHT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:arrowheadSpike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurved sides, linear concave base. Illustrator CS5 #3\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "arrowheadThorn",
          "package": "diagrams-lib",
          "signature": "a -\u003e Double -\u003e ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#arrowheadThorn",
          "type": "function"
        },
        "index": {
          "description": "Curved sides linear concave base Illustrator CS5",
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "arrowheadThorn",
          "normalized": "a-\u003eDouble-\u003eArrowHT",
          "package": "diagrams-lib",
          "partial": "Thorn",
          "signature": "a-\u003eDouble-\u003eArrowHT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:arrowheadThorn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIsoceles triangle style. The above example specifies an angle of `2/5 Turn`.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arrowheads_tri25Ex.svg#diagram=tri25Ex&width=120\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "arrowheadTriangle",
          "package": "diagrams-lib",
          "signature": "a -\u003e ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#arrowheadTriangle",
          "type": "function"
        },
        "index": {
          "description": "Isoceles triangle style The above example specifies an angle of Turn",
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "arrowheadTriangle",
          "normalized": "a-\u003eArrowHT",
          "package": "diagrams-lib",
          "partial": "Triangle",
          "signature": "a-\u003eArrowHT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:arrowheadTriangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "arrowtailBlock",
          "package": "diagrams-lib",
          "signature": "a -\u003e ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#arrowtailBlock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "arrowtailBlock",
          "normalized": "a-\u003eArrowHT",
          "package": "diagrams-lib",
          "partial": "Block",
          "signature": "a-\u003eArrowHT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:arrowtailBlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe angle is where the top left corner intersects the circle.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "arrowtailQuill",
          "package": "diagrams-lib",
          "signature": "a -\u003e ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#arrowtailQuill",
          "type": "function"
        },
        "index": {
          "description": "The angle is where the top left corner intersects the circle",
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "arrowtailQuill",
          "normalized": "a-\u003eArrowHT",
          "package": "diagrams-lib",
          "partial": "Quill",
          "signature": "a-\u003eArrowHT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:arrowtailQuill"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arrowheads_blockEx.svg#diagram=blockEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "block",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#block",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "block",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:block"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arrowheads_dartEx.svg#diagram=dartEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "dart",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#dart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "dart",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:dart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arrowheads_dart'Ex.svg#diagram=dart'Ex&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "dart'",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#dart%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "dart'",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:dart-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arrowheads_missileEx.svg#diagram=missileEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "missile",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#missile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "missile",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:missile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arrowheads_missile'Ex.svg#diagram=missile'Ex&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "missile'",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#missile%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "missile'",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:missile-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "noHead",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#noHead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "noHead",
          "package": "diagrams-lib",
          "partial": "Head",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:noHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "noTail",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#noTail",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "noTail",
          "package": "diagrams-lib",
          "partial": "Tail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:noTail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arrowheads_quillEx.svg#diagram=quillEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "quill",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#quill",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "quill",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:quill"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arrowheads_spikeEx.svg#diagram=spikeEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "spike",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#spike",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "spike",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:spike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arrowheads_spike'Ex.svg#diagram=spike'Ex&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "spike'",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#spike%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "spike'",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:spike-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arrowheads_thornEx.svg#diagram=thornEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "thorn",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#thorn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "thorn",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:thorn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arrowheads_thorn'Ex.svg#diagram=thorn'Ex&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "thorn'",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#thorn%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "thorn'",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:thorn-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arrowheads_triEx.svg#diagram=triEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "tri",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#tri",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "tri",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:tri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Arrowheads_tri'Ex.svg#diagram=tri'Ex&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "tri'",
          "package": "diagrams-lib",
          "signature": "ArrowHT",
          "source": "src/Diagrams-TwoD-Arrowheads.html#tri%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Arrowheads",
          "module": "Diagrams.TwoD.Arrowheads",
          "name": "tri'",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Arrowheads.html#v:tri-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDiagram combinators specialized to two dimensions. For more general\n combinators, see \u003ca\u003eDiagrams.Combinators\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Combinators",
          "name": "Combinators",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Combinators.html",
          "type": "module"
        },
        "index": {
          "description": "Diagram combinators specialized to two dimensions For more general combinators see Diagrams.Combinators",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "Combinators",
          "package": "diagrams-lib",
          "partial": "Combinators",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePlace two diagrams (or other juxtaposable objects) horizontally\n   adjacent to one another, with the first diagram to the left of\n   the second.  The local origin of the resulting combined diagram\n   is the same as the local origin of the first.  \u003ccode\u003e(===)\u003c/code\u003e is\n   associative and has \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e as an identity.  See the\n   documentation of \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e for more information.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "(|||)",
          "package": "diagrams-lib",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Combinators.html#%7C%7C%7C",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:-124--124--124-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:-124--124--124-\"]"
        },
        "index": {
          "description": "Place two diagrams or other juxtaposable objects horizontally adjacent to one another with the first diagram to the left of the second The local origin of the resulting combined diagram is the same as the local origin of the first is associative and has mempty as an identity See the documentation of beside for more information",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "(|||) |||",
          "normalized": "a-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:-124--124--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePlace two diagrams (or other objects) vertically adjacent to one\n   another, with the first diagram above the second.  Since Haskell\n   ignores whitespace in expressions, one can thus write\n\u003c/p\u003e\u003cpre\u003e\n       c\n      ===\n       d\n\u003c/pre\u003e\u003cp\u003eto place \u003ccode\u003ec\u003c/code\u003e above \u003ccode\u003ed\u003c/code\u003e.  The local origin of the resulting\n   combined diagram is the same as the local origin of the first.\n   \u003ccode\u003e(|||)\u003c/code\u003e is associative and has \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e as an identity.  See the\n   documentation of \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e for more information.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "(===)",
          "package": "diagrams-lib",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Combinators.html#%3D%3D%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:-61--61--61-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:-61--61--61-\"]"
        },
        "index": {
          "description": "Place two diagrams or other objects vertically adjacent to one another with the first diagram above the second Since Haskell ignores whitespace in expressions one can thus write to place above The local origin of the resulting combined diagram is the same as the local origin of the first is associative and has mempty as an identity See the documentation of beside for more information",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "(===) ===",
          "normalized": "a-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:-61--61--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePlace two diagrams (or other juxtaposable objects) adjacent to one\n   another, with the second diagram placed along a line at angle\n   \u003ccode\u003eth\u003c/code\u003e from the first.  The local origin of the resulting combined\n   diagram is the same as the local origin of the first.\n   See the documentation of \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e for more information.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "atAngle",
          "package": "diagrams-lib",
          "signature": "b -\u003e a -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Combinators.html#atAngle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:atAngle\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:atAngle\"]"
        },
        "index": {
          "description": "Place two diagrams or other juxtaposable objects adjacent to one another with the second diagram placed along line at angle th from the first The local origin of the resulting combined diagram is the same as the local origin of the first See the documentation of beside for more information",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "atAngle",
          "normalized": "a-\u003eb-\u003eb-\u003eb",
          "package": "diagrams-lib",
          "partial": "Angle",
          "signature": "b-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:atAngle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Set the background color\" of a diagram.  That is, place a\n   diagram atop a bounding rectangle of the given color.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "bg",
          "package": "diagrams-lib",
          "signature": "Colour Double -\u003e Diagram b R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Combinators.html#bg",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:bg\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:bg\"]"
        },
        "index": {
          "description": "Set the background color of diagram That is place diagram atop bounding rectangle of the given color",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "bg",
          "normalized": "Colour Double-\u003eDiagram a R-\u003eDiagram a R",
          "package": "diagrams-lib",
          "signature": "Colour Double-\u003eDiagram b R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:bg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a bounding rectangle for an enveloped object, that is,\n   the smallest axis-aligned rectangle which encloses the object.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "boundingRect",
          "package": "diagrams-lib",
          "signature": "a -\u003e t",
          "source": "src/Diagrams-TwoD-Combinators.html#boundingRect",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:boundingRect\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:boundingRect\"]"
        },
        "index": {
          "description": "Construct bounding rectangle for an enveloped object that is the smallest axis-aligned rectangle which encloses the object",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "boundingRect",
          "normalized": "a-\u003eb",
          "package": "diagrams-lib",
          "partial": "Rect",
          "signature": "a-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:boundingRect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eextrudeBottom s\u003c/code\u003e \"extrudes\" a diagram in the negative y-direction,\n   offsetting its envelope by the provided distance. When \u003ccode\u003e s \u003c 0 \u003c/code\u003e,\n   the envelope is inset instead.\n\u003c/p\u003e\u003cp\u003eSee the documentation for \u003ccode\u003e\u003ca\u003eextrudeEnvelope\u003c/a\u003e\u003c/code\u003e for more information.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "extrudeBottom",
          "package": "diagrams-lib",
          "signature": "Double -\u003e QDiagram b R2 m -\u003e QDiagram b R2 m",
          "source": "src/Diagrams-TwoD-Combinators.html#extrudeBottom",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:extrudeBottom\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:extrudeBottom\"]"
        },
        "index": {
          "description": "extrudeBottom extrudes diagram in the negative y-direction offsetting its envelope by the provided distance When the envelope is inset instead See the documentation for extrudeEnvelope for more information",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "extrudeBottom",
          "normalized": "Double-\u003eQDiagram a R b-\u003eQDiagram a R b",
          "package": "diagrams-lib",
          "partial": "Bottom",
          "signature": "Double-\u003eQDiagram b R m-\u003eQDiagram b R m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:extrudeBottom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eextrudeLeft s\u003c/code\u003e \"extrudes\" a diagram in the negative x-direction,\n   offsetting its envelope by the provided distance. When \u003ccode\u003e s \u003c 0 \u003c/code\u003e,\n   the envelope is inset instead.\n\u003c/p\u003e\u003cp\u003eSee the documentation for \u003ccode\u003e\u003ca\u003eextrudeEnvelope\u003c/a\u003e\u003c/code\u003e for more information.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "extrudeLeft",
          "package": "diagrams-lib",
          "signature": "Double -\u003e QDiagram b R2 m -\u003e QDiagram b R2 m",
          "source": "src/Diagrams-TwoD-Combinators.html#extrudeLeft",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:extrudeLeft\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:extrudeLeft\"]"
        },
        "index": {
          "description": "extrudeLeft extrudes diagram in the negative x-direction offsetting its envelope by the provided distance When the envelope is inset instead See the documentation for extrudeEnvelope for more information",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "extrudeLeft",
          "normalized": "Double-\u003eQDiagram a R b-\u003eQDiagram a R b",
          "package": "diagrams-lib",
          "partial": "Left",
          "signature": "Double-\u003eQDiagram b R m-\u003eQDiagram b R m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:extrudeLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eextrudeRight s\u003c/code\u003e \"extrudes\" a diagram in the positive x-direction,\n   offsetting its envelope by the provided distance. When \u003ccode\u003e s \u003c 0 \u003c/code\u003e,\n   the envelope is inset instead.\n\u003c/p\u003e\u003cp\u003eSee the documentation for \u003ccode\u003e\u003ca\u003eextrudeEnvelope\u003c/a\u003e\u003c/code\u003e for more information.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "extrudeRight",
          "package": "diagrams-lib",
          "signature": "Double -\u003e QDiagram b R2 m -\u003e QDiagram b R2 m",
          "source": "src/Diagrams-TwoD-Combinators.html#extrudeRight",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:extrudeRight\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:extrudeRight\"]"
        },
        "index": {
          "description": "extrudeRight extrudes diagram in the positive x-direction offsetting its envelope by the provided distance When the envelope is inset instead See the documentation for extrudeEnvelope for more information",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "extrudeRight",
          "normalized": "Double-\u003eQDiagram a R b-\u003eQDiagram a R b",
          "package": "diagrams-lib",
          "partial": "Right",
          "signature": "Double-\u003eQDiagram b R m-\u003eQDiagram b R m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:extrudeRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eextrudeTop s\u003c/code\u003e \"extrudes\" a diagram in the positive y-direction,\n   offsetting its envelope by the provided distance. When \u003ccode\u003e s \u003c 0 \u003c/code\u003e,\n   the envelope is inset instead.\n\u003c/p\u003e\u003cp\u003eSee the documentation for \u003ccode\u003e\u003ca\u003eextrudeEnvelope\u003c/a\u003e\u003c/code\u003e for more information.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "extrudeTop",
          "package": "diagrams-lib",
          "signature": "Double -\u003e QDiagram b R2 m -\u003e QDiagram b R2 m",
          "source": "src/Diagrams-TwoD-Combinators.html#extrudeTop",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:extrudeTop\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:extrudeTop\"]"
        },
        "index": {
          "description": "extrudeTop extrudes diagram in the positive y-direction offsetting its envelope by the provided distance When the envelope is inset instead See the documentation for extrudeEnvelope for more information",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "extrudeTop",
          "normalized": "Double-\u003eQDiagram a R b-\u003eQDiagram a R b",
          "package": "diagrams-lib",
          "partial": "Top",
          "signature": "Double-\u003eQDiagram b R m-\u003eQDiagram b R m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:extrudeTop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLay out a list of juxtaposable objects in a row from left to right,\n   so that their local origins lie along a single horizontal line,\n   with successive envelopes tangent to one another.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e For more control over the spacing, see \u003ccode\u003e\u003ca\u003ehcat'\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e To align the diagrams vertically (or otherwise), use alignment\n     combinators (such as \u003ccode\u003e\u003ca\u003ealignT\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ealignB\u003c/a\u003e\u003c/code\u003e) from\n     \u003ca\u003eDiagrams.TwoD.Align\u003c/a\u003e before applying \u003ccode\u003e\u003ca\u003ehcat\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e For non-axis-aligned layout, see \u003ccode\u003e\u003ca\u003ecat\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "hcat",
          "package": "diagrams-lib",
          "signature": "[a] -\u003e a",
          "source": "src/Diagrams-TwoD-Combinators.html#hcat",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:hcat\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:hcat\"]"
        },
        "index": {
          "description": "Lay out list of juxtaposable objects in row from left to right so that their local origins lie along single horizontal line with successive envelopes tangent to one another For more control over the spacing see hcat To align the diagrams vertically or otherwise use alignment combinators such as alignT or alignB from Diagrams.TwoD.Align before applying hcat For non-axis-aligned layout see cat",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "hcat",
          "normalized": "[a]-\u003ea",
          "package": "diagrams-lib",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:hcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003ehcat\u003c/a\u003e\u003c/code\u003e taking an extra \u003ccode\u003e\u003ca\u003eCatOpts\u003c/a\u003e\u003c/code\u003e record to control\n   the spacing.  See the \u003ccode\u003e\u003ca\u003ecat'\u003c/a\u003e\u003c/code\u003e documentation for a description of\n   the possibilities.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "hcat'",
          "package": "diagrams-lib",
          "signature": "CatOpts R2 -\u003e [a] -\u003e a",
          "source": "src/Diagrams-TwoD-Combinators.html#hcat%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:hcat-39-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:hcat-39-\"]"
        },
        "index": {
          "description": "variant of hcat taking an extra CatOpts record to control the spacing See the cat documentation for description of the possibilities",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "hcat'",
          "normalized": "CatOpts R-\u003e[a]-\u003ea",
          "package": "diagrams-lib",
          "signature": "CatOpts R-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:hcat-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003epadX s\u003c/code\u003e \"pads\" a diagram in the x-direction, expanding its\n   envelope horizontally by a factor of \u003ccode\u003es\u003c/code\u003e (factors between 0 and 1\n   can be used to shrink the envelope).  Note that the envelope will\n   expand with respect to the local origin, so if the origin is not\n   centered horizontally the padding may appear \"uneven\".  If this\n   is not desired, the origin can be centered (using \u003ccode\u003e\u003ca\u003ecenterX\u003c/a\u003e\u003c/code\u003e)\n   before applying \u003ccode\u003epadX\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "padX",
          "package": "diagrams-lib",
          "signature": "Double -\u003e QDiagram b R2 m -\u003e QDiagram b R2 m",
          "source": "src/Diagrams-TwoD-Combinators.html#padX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:padX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:padX\"]"
        },
        "index": {
          "description": "padX pads diagram in the x-direction expanding its envelope horizontally by factor of factors between and can be used to shrink the envelope Note that the envelope will expand with respect to the local origin so if the origin is not centered horizontally the padding may appear uneven If this is not desired the origin can be centered using centerX before applying padX",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "padX",
          "normalized": "Double-\u003eQDiagram a R b-\u003eQDiagram a R b",
          "package": "diagrams-lib",
          "signature": "Double-\u003eQDiagram b R m-\u003eQDiagram b R m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:padX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003epadY s\u003c/code\u003e \"pads\" a diagram in the y-direction, expanding its\n   envelope vertically by a factor of \u003ccode\u003es\u003c/code\u003e (factors between\n   0 and 1 can be used to shrink the envelope).  Note that\n   the envelope will expand with respect to the local origin,\n   so if the origin is not centered vertically the padding may appear\n   \"uneven\".  If this is not desired, the origin can be centered\n   (using \u003ccode\u003e\u003ca\u003ecenterY\u003c/a\u003e\u003c/code\u003e) before applying \u003ccode\u003epadY\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "padY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e QDiagram b R2 m -\u003e QDiagram b R2 m",
          "source": "src/Diagrams-TwoD-Combinators.html#padY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:padY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:padY\"]"
        },
        "index": {
          "description": "padY pads diagram in the y-direction expanding its envelope vertically by factor of factors between and can be used to shrink the envelope Note that the envelope will expand with respect to the local origin so if the origin is not centered vertically the padding may appear uneven If this is not desired the origin can be centered using centerY before applying padY",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "padY",
          "normalized": "Double-\u003eQDiagram a R b-\u003eQDiagram a R b",
          "package": "diagrams-lib",
          "signature": "Double-\u003eQDiagram b R m-\u003eQDiagram b R m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:padY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003estrutR2 v\u003c/code\u003e is a two-dimensional diagram which produces no\n   output, but with respect to alignment, envelope, \u003cem\u003eand trace\u003c/em\u003e acts\n   like a 1-dimensional segment oriented along the vector \u003ccode\u003ev\u003c/code\u003e, with\n   local origin at its center.  If you don't care about the trace\n   then there's no difference between \u003ccode\u003estrutR2\u003c/code\u003e and the more general\n   \u003ccode\u003e\u003ca\u003estrut\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Combinators",
          "name": "strutR2",
          "package": "diagrams-lib",
          "signature": "R2 -\u003e QDiagram b R2 m",
          "source": "src/Diagrams-TwoD-Combinators.html#strutR2",
          "type": "function"
        },
        "index": {
          "description": "strutR2 is two-dimensional diagram which produces no output but with respect to alignment envelope and trace acts like dimensional segment oriented along the vector with local origin at its center If you don care about the trace then there no difference between strutR2 and the more general strut",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "strutR2",
          "normalized": "R-\u003eQDiagram a R b",
          "package": "diagrams-lib",
          "signature": "R-\u003eQDiagram b R m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:strutR2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003estrutX w\u003c/code\u003e is an empty diagram with width \u003ccode\u003ew\u003c/code\u003e, height 0, and a\n   centered local origin.  Note that \u003ccode\u003estrutX (-w)\u003c/code\u003e behaves the same as\n   \u003ccode\u003estrutX w\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "strutX",
          "package": "diagrams-lib",
          "signature": "Double -\u003e QDiagram b R2 m",
          "source": "src/Diagrams-TwoD-Combinators.html#strutX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:strutX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:strutX\"]"
        },
        "index": {
          "description": "strutX is an empty diagram with width height and centered local origin Note that strutX behaves the same as strutX",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "strutX",
          "normalized": "Double-\u003eQDiagram a R b",
          "package": "diagrams-lib",
          "signature": "Double-\u003eQDiagram b R m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:strutX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003estrutY h\u003c/code\u003e is an empty diagram with height \u003ccode\u003eh\u003c/code\u003e, width 0, and a\n   centered local origin. Note that \u003ccode\u003estrutY (-h)\u003c/code\u003e behaves the same as\n   \u003ccode\u003estrutY h\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "strutY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e QDiagram b R2 m",
          "source": "src/Diagrams-TwoD-Combinators.html#strutY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:strutY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:strutY\"]"
        },
        "index": {
          "description": "strutY is an empty diagram with height width and centered local origin Note that strutY behaves the same as strutY",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "strutY",
          "normalized": "Double-\u003eQDiagram a R b",
          "package": "diagrams-lib",
          "signature": "Double-\u003eQDiagram b R m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:strutY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLay out a list of juxtaposable objects in a column from top to\n   bottom, so that their local origins lie along a single vertical\n   line, with successive envelopes tangent to one another.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e For more control over the spacing, see \u003ccode\u003e\u003ca\u003evcat'\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e To align the diagrams horizontally (or otherwise), use alignment\n     combinators (such as \u003ccode\u003e\u003ca\u003ealignL\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ealignR\u003c/a\u003e\u003c/code\u003e) from\n     \u003ca\u003eDiagrams.TwoD.Align\u003c/a\u003e before applying \u003ccode\u003e\u003ca\u003evcat\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e For non-axis-aligned layout, see \u003ccode\u003e\u003ca\u003ecat\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "vcat",
          "package": "diagrams-lib",
          "signature": "[a] -\u003e a",
          "source": "src/Diagrams-TwoD-Combinators.html#vcat",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:vcat\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:vcat\"]"
        },
        "index": {
          "description": "Lay out list of juxtaposable objects in column from top to bottom so that their local origins lie along single vertical line with successive envelopes tangent to one another For more control over the spacing see vcat To align the diagrams horizontally or otherwise use alignment combinators such as alignL or alignR from Diagrams.TwoD.Align before applying vcat For non-axis-aligned layout see cat",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "vcat",
          "normalized": "[a]-\u003ea",
          "package": "diagrams-lib",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:vcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003evcat\u003c/a\u003e\u003c/code\u003e taking an extra \u003ccode\u003e\u003ca\u003eCatOpts\u003c/a\u003e\u003c/code\u003e record to control\n   the spacing.  See the \u003ccode\u003e\u003ca\u003ecat'\u003c/a\u003e\u003c/code\u003e documentation for a description of the\n   possibilities.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "vcat'",
          "package": "diagrams-lib",
          "signature": "CatOpts R2 -\u003e [a] -\u003e a",
          "source": "src/Diagrams-TwoD-Combinators.html#vcat%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:vcat-39-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:vcat-39-\"]"
        },
        "index": {
          "description": "variant of vcat taking an extra CatOpts record to control the spacing See the cat documentation for description of the possibilities",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "vcat'",
          "normalized": "CatOpts R-\u003e[a]-\u003ea",
          "package": "diagrams-lib",
          "signature": "CatOpts R-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:vcat-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eview p v\u003c/code\u003e sets the envelope of a diagram to a rectangle whose\n   lower-left corner is at \u003ccode\u003ep\u003c/code\u003e and whose upper-right corner is at \u003ccode\u003ep\n   .+^ v\u003c/code\u003e.  Useful for selecting the rectangular portion of a\n   diagram which should actually be \"viewed\" in the final render,\n   if you don't want to see the entire diagram.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Combinators\",\"Diagrams.TwoD\"]",
          "name": "view",
          "package": "diagrams-lib",
          "signature": "P2 -\u003e R2 -\u003e QDiagram b R2 m -\u003e QDiagram b R2 m",
          "source": "src/Diagrams-TwoD-Combinators.html#view",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:view\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:view\"]"
        },
        "index": {
          "description": "view sets the envelope of diagram to rectangle whose lower-left corner is at and whose upper-right corner is at Useful for selecting the rectangular portion of diagram which should actually be viewed in the final render if you don want to see the entire diagram",
          "hierarchy": "Diagrams TwoD Combinators",
          "module": "Diagrams.TwoD.Combinators",
          "name": "view",
          "normalized": "P-\u003eR-\u003eQDiagram a R b-\u003eQDiagram a R b",
          "package": "diagrams-lib",
          "signature": "P-\u003eR-\u003eQDiagram b R m-\u003eQDiagram b R m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Combinators.html#v:view"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompute curvature for segments in two dimensions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Curvature",
          "name": "Curvature",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Curvature.html",
          "type": "module"
        },
        "index": {
          "description": "Compute curvature for segments in two dimensions",
          "hierarchy": "Diagrams TwoD Curvature",
          "module": "Diagrams.TwoD.Curvature",
          "name": "Curvature",
          "package": "diagrams-lib",
          "partial": "Curvature",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Curvature.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurvature measures how curved the segment is at a point.  One intuition\n for the concept is how much you would turn the wheel when driving a car\n along the curve.  When the wheel is held straight there is zero curvature.\n When turning a corner to the left we will have positive curvature.  When\n turning to the right we will have negative curvature.\n\u003c/p\u003e\u003cp\u003eAnother way to measure this idea is to find the largest circle that we can\n push up against the curve and have it touch (locally) at exactly the point\n and not cross the curve.  This is a tangent circle.  The radius of that\n circle is the \"Radius of Curvature\" and it is the reciprocal of curvature.\n Note that if the circle is on the \"left\" of the curve, we have a positive\n radius, and if it is to the right we have a negative radius.  Straight\n segments have an infinite radius which leads us to our representation.  We\n result in a pair of numerator and denominator so we can include infinity and\n zero for both the radius and the curvature.\n\u003c/p\u003e\u003cp\u003eLets consider the following curve:\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Curvature_diagramA.svg#diagram=diagramA&height=200&width=400\"/\u003e\n\u003c/p\u003e\u003cp\u003eThe curve starts with positive curvature,\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Curvature_diagramPos.svg#diagram=diagramPos&height=200&width=400\"/\u003e\n\u003c/p\u003e\u003cp\u003eapproaches zero curvature\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Curvature_diagramZero.svg#diagram=diagramZero&height=200&width=400\"/\u003e\n\u003c/p\u003e\u003cp\u003ethen has negative curvature\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Curvature_diagramNeg.svg#diagram=diagramNeg&height=200&width=400\"/\u003e\n\u003c/p\u003e\u003cpre\u003e {-# LANGUAGE GADTs #-}\n\n import Diagrams.TwoD.Curvature\n import Data.Monoid.Inf\n import Diagrams.Coordinates\n\n segmentA = Cubic (12 ^& 0) (8 ^& 10) (OffsetClosed (20 ^& 8))\n\n curveA = lw 0.1 . stroke . fromSegments $ [segmentA]\n\n diagramA = pad 1.1 . centerXY $ curveA\n\n diagramPos = diagramWithRadius 0.2\n\n diagramZero = diagramWithRadius 0.45\n\n diagramNeg = diagramWithRadius 0.8\n\n diagramWithRadius t = pad 1.1 . centerXY\n          $ curveA\n         \u003c\u003e showCurvature segmentA t\n          # withEnvelope (curveA :: D R2)\n          # lw 0.05 # lc red\n\n showCurvature bez@(Cubic b c (OffsetClosed d)) t\n   | v == 0    = mempty\n   | otherwise = go (radiusOfCurvature bez t)\n   where\n     v@(x,y) = unr2 $ firstDerivative b c d t\n     vp = (-y) ^& x\n\n     firstDerivative b c d t = let tt = t*t in (3*(3*tt-4*t+1))*^b + (3*(2-3*t)*t)*^c + (3*tt)*^d\n\n     go Infinity   = mempty\n     go (Finite r) = (circle (abs r) # translate vpr\n                  \u003c\u003e stroke (origin ~~ (origin .+^ vpr)))\n                   # moveTo (origin .+^ atParam bez t)\n       where\n         vpr = r2 (normalized vp ^* r)\n\n\u003c/pre\u003e",
          "module": "Diagrams.TwoD.Curvature",
          "name": "curvature",
          "package": "diagrams-lib",
          "signature": "Segment Closed R2-\u003e Double-\u003e PosInf Double",
          "type": "function"
        },
        "index": {
          "description": "Curvature measures how curved the segment is at point One intuition for the concept is how much you would turn the wheel when driving car along the curve When the wheel is held straight there is zero curvature When turning corner to the left we will have positive curvature When turning to the right we will have negative curvature Another way to measure this idea is to find the largest circle that we can push up against the curve and have it touch locally at exactly the point and not cross the curve This is tangent circle The radius of that circle is the Radius of Curvature and it is the reciprocal of curvature Note that if the circle is on the left of the curve we have positive radius and if it is to the right we have negative radius Straight segments have an infinite radius which leads us to our representation We result in pair of numerator and denominator so we can include infinity and zero for both the radius and the curvature Lets consider the following curve The curve starts with positive curvature approaches zero curvature then has negative curvature LANGUAGE GADTs import Diagrams.TwoD.Curvature import Data.Monoid.Inf import Diagrams.Coordinates segmentA Cubic OffsetClosed curveA lw stroke fromSegments segmentA diagramA pad centerXY curveA diagramPos diagramWithRadius diagramZero diagramWithRadius diagramNeg diagramWithRadius diagramWithRadius pad centerXY curveA showCurvature segmentA withEnvelope curveA R2 lw lc red showCurvature bez Cubic OffsetClosed mempty otherwise go radiusOfCurvature bez where unr2 firstDerivative vp firstDerivative let tt in tt-4 tt go Infinity mempty go Finite circle abs translate vpr stroke origin origin vpr moveTo origin atParam bez where vpr r2 normalized vp",
          "hierarchy": "Diagrams TwoD Curvature",
          "module": "Diagrams.TwoD.Curvature",
          "name": "curvature",
          "normalized": "Segment Closed R-\u003eDouble-\u003ePosInf Double",
          "package": "diagrams-lib",
          "signature": "Segment Closed R-\u003eDouble-\u003ePosInf Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Curvature.html#v:curvature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReciprocal of \u003ccode\u003ecurvature\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Curvature",
          "name": "radiusOfCurvature",
          "package": "diagrams-lib",
          "signature": "Segment Closed R2-\u003e Double-\u003e PosInf Double",
          "type": "function"
        },
        "index": {
          "description": "Reciprocal of curvature",
          "hierarchy": "Diagrams TwoD Curvature",
          "module": "Diagrams.TwoD.Curvature",
          "name": "radiusOfCurvature",
          "normalized": "Segment Closed R-\u003eDouble-\u003ePosInf Double",
          "package": "diagrams-lib",
          "partial": "Of Curvature",
          "signature": "Segment Closed R-\u003eDouble-\u003ePosInf Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Curvature.html#v:radiusOfCurvature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWith \u003ccode\u003esquaredCurvature\u003c/code\u003e we can compute values in spaces that do not support\n \u003ccode\u003e\u003ca\u003esqrt\u003c/a\u003e\u003c/code\u003e and it is just as useful for relative ordering of curvatures or looking\n for zeros.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Curvature",
          "name": "squaredCurvature",
          "package": "diagrams-lib",
          "signature": "Segment Closed R2 -\u003e Double -\u003e PosInf Double",
          "source": "src/Diagrams-TwoD-Curvature.html#squaredCurvature",
          "type": "function"
        },
        "index": {
          "description": "With squaredCurvature we can compute values in spaces that do not support sqrt and it is just as useful for relative ordering of curvatures or looking for zeros",
          "hierarchy": "Diagrams TwoD Curvature",
          "module": "Diagrams.TwoD.Curvature",
          "name": "squaredCurvature",
          "normalized": "Segment Closed R-\u003eDouble-\u003ePosInf Double",
          "package": "diagrams-lib",
          "partial": "Curvature",
          "signature": "Segment Closed R-\u003eDouble-\u003ePosInf Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Curvature.html#v:squaredCurvature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReciprocal of \u003ccode\u003esquaredCurvature\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Curvature",
          "name": "squaredRadiusOfCurvature",
          "package": "diagrams-lib",
          "signature": "Segment Closed R2 -\u003e Double -\u003e PosInf Double",
          "source": "src/Diagrams-TwoD-Curvature.html#squaredRadiusOfCurvature",
          "type": "function"
        },
        "index": {
          "description": "Reciprocal of squaredCurvature",
          "hierarchy": "Diagrams TwoD Curvature",
          "module": "Diagrams.TwoD.Curvature",
          "name": "squaredRadiusOfCurvature",
          "normalized": "Segment Closed R-\u003eDouble-\u003ePosInf Double",
          "package": "diagrams-lib",
          "partial": "Radius Of Curvature",
          "signature": "Segment Closed R-\u003eDouble-\u003ePosInf Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Curvature.html#v:squaredRadiusOfCurvature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTwo-dimensional ellipses (and, as a special case, circles).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Ellipse",
          "name": "Ellipse",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Ellipse.html",
          "type": "module"
        },
        "index": {
          "description": "Two-dimensional ellipses and as special case circles",
          "hierarchy": "Diagrams TwoD Ellipse",
          "module": "Diagrams.TwoD.Ellipse",
          "name": "Ellipse",
          "package": "diagrams-lib",
          "partial": "Ellipse",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Ellipse.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA circle of the given radius, centered at the origin.  As a path,\n   it begins at (r,0).\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Ellipse\",\"Diagrams.TwoD\"]",
          "name": "circle",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Ellipse.html#circle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Ellipse.html#v:circle\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:circle\"]"
        },
        "index": {
          "description": "circle of the given radius centered at the origin As path it begins at",
          "hierarchy": "Diagrams TwoD Ellipse",
          "module": "Diagrams.TwoD.Ellipse",
          "name": "circle",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Ellipse.html#v:circle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eellipse e\u003c/code\u003e constructs an ellipse with eccentricity \u003ccode\u003ee\u003c/code\u003e by\n   scaling the unit circle in the X direction.  The eccentricity must\n   be within the interval [0,1).\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Ellipse\",\"Diagrams.TwoD\"]",
          "name": "ellipse",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Ellipse.html#ellipse",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Ellipse.html#v:ellipse\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:ellipse\"]"
        },
        "index": {
          "description": "ellipse constructs an ellipse with eccentricity by scaling the unit circle in the direction The eccentricity must be within the interval",
          "hierarchy": "Diagrams TwoD Ellipse",
          "module": "Diagrams.TwoD.Ellipse",
          "name": "ellipse",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Ellipse.html#v:ellipse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eellipseXY x y\u003c/code\u003e creates an axis-aligned ellipse, centered at the\n   origin, with radius \u003ccode\u003ex\u003c/code\u003e along the x-axis and radius \u003ccode\u003ey\u003c/code\u003e along the\n   y-axis.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Ellipse\",\"Diagrams.TwoD\"]",
          "name": "ellipseXY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Double -\u003e t",
          "source": "src/Diagrams-TwoD-Ellipse.html#ellipseXY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Ellipse.html#v:ellipseXY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:ellipseXY\"]"
        },
        "index": {
          "description": "ellipseXY creates an axis-aligned ellipse centered at the origin with radius along the x-axis and radius along the y-axis",
          "hierarchy": "Diagrams TwoD Ellipse",
          "module": "Diagrams.TwoD.Ellipse",
          "name": "ellipseXY",
          "normalized": "Double-\u003eDouble-\u003ea",
          "package": "diagrams-lib",
          "partial": "XY",
          "signature": "Double-\u003eDouble-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Ellipse.html#v:ellipseXY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA circle of radius 1, with center at the origin.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Ellipse\",\"Diagrams.TwoD\"]",
          "name": "unitCircle",
          "package": "diagrams-lib",
          "signature": "t",
          "source": "src/Diagrams-TwoD-Ellipse.html#unitCircle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Ellipse.html#v:unitCircle\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:unitCircle\"]"
        },
        "index": {
          "description": "circle of radius with center at the origin",
          "hierarchy": "Diagrams TwoD Ellipse",
          "module": "Diagrams.TwoD.Ellipse",
          "name": "unitCircle",
          "package": "diagrams-lib",
          "partial": "Circle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Ellipse.html#v:unitCircle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImporting external images into diagrams.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Image",
          "name": "Image",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Image.html",
          "type": "module"
        },
        "index": {
          "description": "Importing external images into diagrams",
          "hierarchy": "Diagrams TwoD Image",
          "module": "Diagrams.TwoD.Image",
          "name": "Image",
          "package": "diagrams-lib",
          "partial": "Image",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Image.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn external image primitive, representing an image the backend\n   should import from another file when rendering.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Image",
          "name": "Image",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Image.html#Image",
          "type": "data"
        },
        "index": {
          "description": "An external image primitive representing an image the backend should import from another file when rendering",
          "hierarchy": "Diagrams TwoD Image",
          "module": "Diagrams.TwoD.Image",
          "name": "Image",
          "package": "diagrams-lib",
          "partial": "Image",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Image.html#t:Image"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Image",
          "name": "Image",
          "package": "diagrams-lib",
          "signature": "Image",
          "source": "src/Diagrams-TwoD-Image.html#Image",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Image",
          "module": "Diagrams.TwoD.Image",
          "name": "Image",
          "package": "diagrams-lib",
          "partial": "Image",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Image.html#v:Image"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Image",
          "name": "_imgFile",
          "package": "diagrams-lib",
          "signature": "FilePath",
          "source": "src/Diagrams-TwoD-Image.html#Image",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Image",
          "module": "Diagrams.TwoD.Image",
          "name": "_imgFile",
          "package": "diagrams-lib",
          "partial": "File",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Image.html#v:_imgFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Image",
          "name": "_imgSize",
          "package": "diagrams-lib",
          "signature": "SizeSpec2D",
          "source": "src/Diagrams-TwoD-Image.html#Image",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Image",
          "module": "Diagrams.TwoD.Image",
          "name": "_imgSize",
          "package": "diagrams-lib",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Image.html#v:_imgSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Image",
          "name": "_imgTransf",
          "package": "diagrams-lib",
          "signature": "T2",
          "source": "src/Diagrams-TwoD-Image.html#Image",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Image",
          "module": "Diagrams.TwoD.Image",
          "name": "_imgTransf",
          "package": "diagrams-lib",
          "partial": "Transf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Image.html#v:_imgTransf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake an external image from the specified file and turn it into a\n   diagram with the specified width and height, centered at the\n   origin.  Note that the image's aspect ratio will be preserved; if\n   the specified width and height have a different ratio than the\n   image's aspect ratio, there will be extra space in one dimension.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Image\",\"Diagrams.TwoD\"]",
          "name": "image",
          "package": "diagrams-lib",
          "signature": "FilePath -\u003e Double -\u003e Double -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Image.html#image",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Image.html#v:image\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:image\"]"
        },
        "index": {
          "description": "Take an external image from the specified file and turn it into diagram with the specified width and height centered at the origin Note that the image aspect ratio will be preserved if the specified width and height have different ratio than the image aspect ratio there will be extra space in one dimension",
          "hierarchy": "Diagrams TwoD Image",
          "module": "Diagrams.TwoD.Image",
          "name": "image",
          "normalized": "FilePath-\u003eDouble-\u003eDouble-\u003eDiagram a R",
          "package": "diagrams-lib",
          "signature": "FilePath-\u003eDouble-\u003eDouble-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Image.html#v:image"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Image",
          "name": "imgFile",
          "package": "diagrams-lib",
          "signature": "Lens' Image FilePath",
          "source": "src/Diagrams-TwoD-Image.html#imgFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Image",
          "module": "Diagrams.TwoD.Image",
          "name": "imgFile",
          "package": "diagrams-lib",
          "partial": "File",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Image.html#v:imgFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Image",
          "name": "imgSize",
          "package": "diagrams-lib",
          "signature": "Lens' Image SizeSpec2D",
          "source": "src/Diagrams-TwoD-Image.html#imgSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Image",
          "module": "Diagrams.TwoD.Image",
          "name": "imgSize",
          "package": "diagrams-lib",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Image.html#v:imgSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Image",
          "name": "imgTransf",
          "package": "diagrams-lib",
          "signature": "Lens' Image T2",
          "source": "src/Diagrams-TwoD-Image.html#imgTransf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Image",
          "module": "Diagrams.TwoD.Image",
          "name": "imgTransf",
          "package": "diagrams-lib",
          "partial": "Transf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Image.html#v:imgTransf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTools for visualizing diagrams' internal model: local origins,\n envelopes, \u003cem\u003eetc.\u003c/em\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Model",
          "name": "Model",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Model.html",
          "type": "module"
        },
        "index": {
          "description": "Tools for visualizing diagrams internal model local origins envelopes etc",
          "hierarchy": "Diagrams TwoD Model",
          "module": "Diagrams.TwoD.Model",
          "name": "Model",
          "package": "diagrams-lib",
          "partial": "Model",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Model",
          "name": "OriginOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Model.html#OriginOpts",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Model",
          "module": "Diagrams.TwoD.Model",
          "name": "OriginOpts",
          "package": "diagrams-lib",
          "partial": "Origin Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#t:OriginOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Model\",\"Diagrams.TwoD\"]",
          "name": "OriginOpts",
          "package": "diagrams-lib",
          "signature": "OriginOpts",
          "source": "src/Diagrams-TwoD-Model.html#OriginOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:OriginOpts\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:OriginOpts\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Model",
          "module": "Diagrams.TwoD.Model",
          "name": "OriginOpts",
          "package": "diagrams-lib",
          "partial": "Origin Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:OriginOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Model\",\"Diagrams.TwoD\"]",
          "name": "_oColor",
          "package": "diagrams-lib",
          "signature": "Colour Double",
          "source": "src/Diagrams-TwoD-Model.html#OriginOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:_oColor\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_oColor\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Model",
          "module": "Diagrams.TwoD.Model",
          "name": "_oColor",
          "package": "diagrams-lib",
          "partial": "Color",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:_oColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Model\",\"Diagrams.TwoD\"]",
          "name": "_oMinSize",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-TwoD-Model.html#OriginOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:_oMinSize\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_oMinSize\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Model",
          "module": "Diagrams.TwoD.Model",
          "name": "_oMinSize",
          "package": "diagrams-lib",
          "partial": "Min Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:_oMinSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Model\",\"Diagrams.TwoD\"]",
          "name": "_oScale",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-TwoD-Model.html#OriginOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:_oScale\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_oScale\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Model",
          "module": "Diagrams.TwoD.Model",
          "name": "_oScale",
          "package": "diagrams-lib",
          "partial": "Scale",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:_oScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Model\",\"Diagrams.TwoD\"]",
          "name": "oColor",
          "package": "diagrams-lib",
          "signature": "Lens' OriginOpts (Colour Double)",
          "source": "src/Diagrams-TwoD-Model.html#oColor",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:oColor\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:oColor\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Model",
          "module": "Diagrams.TwoD.Model",
          "name": "oColor",
          "package": "diagrams-lib",
          "partial": "Color",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:oColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Model\",\"Diagrams.TwoD\"]",
          "name": "oMinSize",
          "package": "diagrams-lib",
          "signature": "Lens' OriginOpts Double",
          "source": "src/Diagrams-TwoD-Model.html#oMinSize",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:oMinSize\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:oMinSize\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Model",
          "module": "Diagrams.TwoD.Model",
          "name": "oMinSize",
          "package": "diagrams-lib",
          "partial": "Min Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:oMinSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Model\",\"Diagrams.TwoD\"]",
          "name": "oScale",
          "package": "diagrams-lib",
          "signature": "Lens' OriginOpts Double",
          "source": "src/Diagrams-TwoD-Model.html#oScale",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:oScale\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:oScale\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Model",
          "module": "Diagrams.TwoD.Model",
          "name": "oScale",
          "package": "diagrams-lib",
          "partial": "Scale",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:oScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Model\",\"Diagrams.TwoD\"]",
          "name": "showLabels",
          "package": "diagrams-lib",
          "signature": "QDiagram b R2 m -\u003e QDiagram b R2 Any",
          "source": "src/Diagrams-TwoD-Model.html#showLabels",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:showLabels\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:showLabels\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Model",
          "module": "Diagrams.TwoD.Model",
          "name": "showLabels",
          "normalized": "QDiagram a R b-\u003eQDiagram a R Any",
          "package": "diagrams-lib",
          "partial": "Labels",
          "signature": "QDiagram b R m-\u003eQDiagram b R Any",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:showLabels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMark the origin of a diagram by placing a red dot 1/50th its size.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Model\",\"Diagrams.TwoD\"]",
          "name": "showOrigin",
          "package": "diagrams-lib",
          "signature": "QDiagram b R2 m -\u003e QDiagram b R2 m",
          "source": "src/Diagrams-TwoD-Model.html#showOrigin",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:showOrigin\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:showOrigin\"]"
        },
        "index": {
          "description": "Mark the origin of diagram by placing red dot th its size",
          "hierarchy": "Diagrams TwoD Model",
          "module": "Diagrams.TwoD.Model",
          "name": "showOrigin",
          "normalized": "QDiagram a R b-\u003eQDiagram a R b",
          "package": "diagrams-lib",
          "partial": "Origin",
          "signature": "QDiagram b R m-\u003eQDiagram b R m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:showOrigin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMark the origin of a diagram, with control over colour and scale\n of marker dot.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Model\",\"Diagrams.TwoD\"]",
          "name": "showOrigin'",
          "package": "diagrams-lib",
          "signature": "OriginOpts -\u003e QDiagram b R2 m -\u003e QDiagram b R2 m",
          "source": "src/Diagrams-TwoD-Model.html#showOrigin%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:showOrigin-39-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:showOrigin-39-\"]"
        },
        "index": {
          "description": "Mark the origin of diagram with control over colour and scale of marker dot",
          "hierarchy": "Diagrams TwoD Model",
          "module": "Diagrams.TwoD.Model",
          "name": "showOrigin'",
          "normalized": "OriginOpts-\u003eQDiagram a R b-\u003eQDiagram a R b",
          "package": "diagrams-lib",
          "partial": "Origin'",
          "signature": "OriginOpts-\u003eQDiagram b R m-\u003eQDiagram b R m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Model.html#v:showOrigin-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompute offsets to segments in two dimensions.  More details can be \n found in the manual at \n \u003ca\u003ehttp://projects.haskell.org/diagrams/doc/manual.html#offsets-of-segments-trails-and-paths\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "Offset",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Offset.html",
          "type": "module"
        },
        "index": {
          "description": "Compute offsets to segments in two dimensions More details can be found in the manual at http projects.haskell.org diagrams doc manual.html offsets-of-segments-trails-and-paths",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "Offset",
          "package": "diagrams-lib",
          "partial": "Offset",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptions for specifying how a \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e should be expanded.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "ExpandOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Offset.html#ExpandOpts",
          "type": "data"
        },
        "index": {
          "description": "Options for specifying how Trail should be expanded",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "ExpandOpts",
          "package": "diagrams-lib",
          "partial": "Expand Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#t:ExpandOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the offset of a segment.  Given a segment compute the offset\n   curve that is a fixed distance from the original curve.  For linear\n   segments nothing special happens, the same linear segment is returned\n   with a point that is offset by a perpendicular vector of the given offset\n   length.\n\u003c/p\u003e\u003cp\u003eCubic segments require a search for a subdivision of cubic segments that\n   gives an approximation of the offset within the given epsilon factor\n   (the given epsilon factor is applied to the radius giving a concrete epsilon\n   value).\n   We must do this because the offset of a cubic is not a cubic itself (the\n   degree of the curve increases).  Cubics do, however, approach constant\n   curvature as we subdivide.  In light of this we scale the handles of\n   the offset cubic segment in proportion to the radius of curvature difference\n   between the original subsegment and the offset which will have a radius\n   increased by the offset parameter.\n\u003c/p\u003e\u003cp\u003eIn the following example the blue lines are the original segments and\n   the alternating green and red lines are the resulting offset trail segments.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Offset_cubicOffsetExample.svg#diagram=cubicOffsetExample&width=600\"/\u003e\n\u003c/p\u003e\u003cp\u003eNote that when the original curve has a cusp, the offset curve forms a\n   radius around the cusp, and when there is a loop in the original curve,\n   there can be two cusps in the offset curve.\n\u003c/p\u003e\u003cp\u003eOptions for specifying line join and segment epsilon for an offset\n   involving multiple segments.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "OffsetOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Offset.html#OffsetOpts",
          "type": "data"
        },
        "index": {
          "description": "Compute the offset of segment Given segment compute the offset curve that is fixed distance from the original curve For linear segments nothing special happens the same linear segment is returned with point that is offset by perpendicular vector of the given offset length Cubic segments require search for subdivision of cubic segments that gives an approximation of the offset within the given epsilon factor the given epsilon factor is applied to the radius giving concrete epsilon value We must do this because the offset of cubic is not cubic itself the degree of the curve increases Cubics do however approach constant curvature as we subdivide In light of this we scale the handles of the offset cubic segment in proportion to the radius of curvature difference between the original subsegment and the offset which will have radius increased by the offset parameter In the following example the blue lines are the original segments and the alternating green and red lines are the resulting offset trail segments Note that when the original curve has cusp the offset curve forms radius around the cusp and when there is loop in the original curve there can be two cusps in the offset curve Options for specifying line join and segment epsilon for an offset involving multiple segments",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "OffsetOpts",
          "package": "diagrams-lib",
          "partial": "Offset Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#t:OffsetOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Offset",
          "name": "ExpandOpts",
          "package": "diagrams-lib",
          "signature": "ExpandOpts",
          "source": "src/Diagrams-TwoD-Offset.html#ExpandOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "ExpandOpts",
          "package": "diagrams-lib",
          "partial": "Expand Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:ExpandOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Offset",
          "name": "OffsetOpts",
          "package": "diagrams-lib",
          "signature": "OffsetOpts",
          "source": "src/Diagrams-TwoD-Offset.html#OffsetOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "OffsetOpts",
          "package": "diagrams-lib",
          "partial": "Offset Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:OffsetOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Offset",
          "name": "_expandCap",
          "package": "diagrams-lib",
          "signature": "LineCap",
          "source": "src/Diagrams-TwoD-Offset.html#ExpandOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "_expandCap",
          "package": "diagrams-lib",
          "partial": "Cap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:_expandCap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Offset",
          "name": "_expandEpsilon",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-TwoD-Offset.html#ExpandOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "_expandEpsilon",
          "package": "diagrams-lib",
          "partial": "Epsilon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:_expandEpsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Offset",
          "name": "_expandJoin",
          "package": "diagrams-lib",
          "signature": "LineJoin",
          "source": "src/Diagrams-TwoD-Offset.html#ExpandOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "_expandJoin",
          "package": "diagrams-lib",
          "partial": "Join",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:_expandJoin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Offset",
          "name": "_expandMiterLimit",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-TwoD-Offset.html#ExpandOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "_expandMiterLimit",
          "package": "diagrams-lib",
          "partial": "Miter Limit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:_expandMiterLimit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Offset",
          "name": "_offsetEpsilon",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-TwoD-Offset.html#OffsetOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "_offsetEpsilon",
          "package": "diagrams-lib",
          "partial": "Epsilon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:_offsetEpsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Offset",
          "name": "_offsetJoin",
          "package": "diagrams-lib",
          "signature": "LineJoin",
          "source": "src/Diagrams-TwoD-Offset.html#OffsetOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "_offsetJoin",
          "package": "diagrams-lib",
          "partial": "Join",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:_offsetJoin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Offset",
          "name": "_offsetMiterLimit",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-TwoD-Offset.html#OffsetOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "_offsetMiterLimit",
          "package": "diagrams-lib",
          "partial": "Miter Limit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:_offsetMiterLimit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecifies how the ends are handled.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandCap",
          "package": "diagrams-lib",
          "signature": "Lens' ExpandOpts LineCap",
          "source": "src/Diagrams-TwoD-Offset.html#expandCap",
          "type": "function"
        },
        "index": {
          "description": "Specifies how the ends are handled",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandCap",
          "package": "diagrams-lib",
          "partial": "Cap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:expandCap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEpsilon perimeter for \u003ccode\u003e\u003ca\u003eoffsetSegment\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandEpsilon",
          "package": "diagrams-lib",
          "signature": "Lens' ExpandOpts Double",
          "source": "src/Diagrams-TwoD-Offset.html#expandEpsilon",
          "type": "function"
        },
        "index": {
          "description": "Epsilon perimeter for offsetSegment",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandEpsilon",
          "package": "diagrams-lib",
          "partial": "Epsilon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:expandEpsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecifies the style of join for between adjacent offset segments.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandJoin",
          "package": "diagrams-lib",
          "signature": "Lens' ExpandOpts LineJoin",
          "source": "src/Diagrams-TwoD-Offset.html#expandJoin",
          "type": "function"
        },
        "index": {
          "description": "Specifies the style of join for between adjacent offset segments",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandJoin",
          "package": "diagrams-lib",
          "partial": "Join",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:expandJoin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecifies the miter limit for the join.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandMiterLimit",
          "package": "diagrams-lib",
          "signature": "Lens' ExpandOpts Double",
          "source": "src/Diagrams-TwoD-Offset.html#expandMiterLimit",
          "type": "function"
        },
        "index": {
          "description": "Specifies the miter limit for the join",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandMiterLimit",
          "package": "diagrams-lib",
          "partial": "Miter Limit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:expandMiterLimit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpand a \u003ccode\u003e\u003ca\u003ePath\u003c/a\u003e\u003c/code\u003e with the given radius and default options.  See \u003ccode\u003e\u003ca\u003eexpandPath'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandPath",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Path R2 -\u003e Path R2",
          "source": "src/Diagrams-TwoD-Offset.html#expandPath",
          "type": "function"
        },
        "index": {
          "description": "Expand Path with the given radius and default options See expandPath",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandPath",
          "normalized": "Double-\u003ePath R-\u003ePath R",
          "package": "diagrams-lib",
          "partial": "Path",
          "signature": "Double-\u003ePath R-\u003ePath R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:expandPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpand a \u003ccode\u003e\u003ca\u003ePath\u003c/a\u003e\u003c/code\u003e using \u003ccode\u003e\u003ca\u003eexpandTrail'\u003c/a\u003e\u003c/code\u003e on each trail in the path.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandPath'",
          "package": "diagrams-lib",
          "signature": "ExpandOpts -\u003e Double -\u003e Path R2 -\u003e Path R2",
          "source": "src/Diagrams-TwoD-Offset.html#expandPath%27",
          "type": "function"
        },
        "index": {
          "description": "Expand Path using expandTrail on each trail in the path",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandPath'",
          "normalized": "ExpandOpts-\u003eDouble-\u003ePath R-\u003ePath R",
          "package": "diagrams-lib",
          "partial": "Path'",
          "signature": "ExpandOpts-\u003eDouble-\u003ePath R-\u003ePath R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:expandPath-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpand a \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e with the given radius and default options.  See \u003ccode\u003e\u003ca\u003eexpandTrail'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandTrail",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Located (Trail R2) -\u003e Path R2",
          "source": "src/Diagrams-TwoD-Offset.html#expandTrail",
          "type": "function"
        },
        "index": {
          "description": "Expand Trail with the given radius and default options See expandTrail",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandTrail",
          "normalized": "Double-\u003eLocated(Trail R)-\u003ePath R",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "Double-\u003eLocated(Trail R)-\u003ePath R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:expandTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpand a \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e with the given options and radius \u003ccode\u003er\u003c/code\u003e around a given \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e.\n   Expanding can be thought of as generating the loop that, when filled, represents\n   stroking the trail with a radius \u003ccode\u003er\u003c/code\u003e brush.\n\u003c/p\u003e\u003cp\u003eThe cap styles applied to an outside corner can be seen here (with the original\n   trail in white and the result of \u003ccode\u003e\u003ca\u003eexpandTrail'\u003c/a\u003e\u003c/code\u003e filled in green):\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Offset_expandTrailExample.svg#diagram=expandTrailExample&width=600\"/\u003e\n\u003c/p\u003e\u003cp\u003eLoops result in a path with an inner and outer loop:\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Offset_expandLoopExample.svg#diagram=expandLoopExample&width=300\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandTrail'",
          "package": "diagrams-lib",
          "signature": "ExpandOpts-\u003e Double-\u003e Located (Trail R2)-\u003e Path R2",
          "type": "function"
        },
        "index": {
          "description": "Expand Trail with the given options and radius around given Trail Expanding can be thought of as generating the loop that when filled represents stroking the trail with radius brush The cap styles applied to an outside corner can be seen here with the original trail in white and the result of expandTrail filled in green Loops result in path with an inner and outer loop",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "expandTrail'",
          "normalized": "ExpandOpts-\u003eDouble-\u003eLocated(Trail R)-\u003ePath R",
          "package": "diagrams-lib",
          "partial": "Trail'",
          "signature": "ExpandOpts-\u003eDouble-\u003eLocated(Trail R)-\u003ePath R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:expandTrail-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEpsilon perimeter for \u003ccode\u003e\u003ca\u003eoffsetSegment\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetEpsilon",
          "package": "diagrams-lib",
          "signature": "Lens' OffsetOpts Double",
          "source": "src/Diagrams-TwoD-Offset.html#offsetEpsilon",
          "type": "function"
        },
        "index": {
          "description": "Epsilon perimeter for offsetSegment",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetEpsilon",
          "package": "diagrams-lib",
          "partial": "Epsilon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:offsetEpsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecifies the style of join for between adjacent offset segments.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetJoin",
          "package": "diagrams-lib",
          "signature": "Lens' OffsetOpts LineJoin",
          "source": "src/Diagrams-TwoD-Offset.html#offsetJoin",
          "type": "function"
        },
        "index": {
          "description": "Specifies the style of join for between adjacent offset segments",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetJoin",
          "package": "diagrams-lib",
          "partial": "Join",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:offsetJoin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecifies the miter limit for the join.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetMiterLimit",
          "package": "diagrams-lib",
          "signature": "Lens' OffsetOpts Double",
          "source": "src/Diagrams-TwoD-Offset.html#offsetMiterLimit",
          "type": "function"
        },
        "index": {
          "description": "Specifies the miter limit for the join",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetMiterLimit",
          "package": "diagrams-lib",
          "partial": "Miter Limit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:offsetMiterLimit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOffset a \u003ccode\u003e\u003ca\u003ePath\u003c/a\u003e\u003c/code\u003e with the default options and given radius.  See \u003ccode\u003e\u003ca\u003eoffsetPath'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetPath",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Path R2 -\u003e Path R2",
          "source": "src/Diagrams-TwoD-Offset.html#offsetPath",
          "type": "function"
        },
        "index": {
          "description": "Offset Path with the default options and given radius See offsetPath",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetPath",
          "normalized": "Double-\u003ePath R-\u003ePath R",
          "package": "diagrams-lib",
          "partial": "Path",
          "signature": "Double-\u003ePath R-\u003ePath R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:offsetPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOffset a \u003ccode\u003e\u003ca\u003ePath\u003c/a\u003e\u003c/code\u003e by applying \u003ccode\u003e\u003ca\u003eoffsetTrail'\u003c/a\u003e\u003c/code\u003e to each trail in the path.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetPath'",
          "package": "diagrams-lib",
          "signature": "OffsetOpts -\u003e Double -\u003e Path R2 -\u003e Path R2",
          "source": "src/Diagrams-TwoD-Offset.html#offsetPath%27",
          "type": "function"
        },
        "index": {
          "description": "Offset Path by applying offsetTrail to each trail in the path",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetPath'",
          "normalized": "OffsetOpts-\u003eDouble-\u003ePath R-\u003ePath R",
          "package": "diagrams-lib",
          "partial": "Path'",
          "signature": "OffsetOpts-\u003eDouble-\u003ePath R-\u003ePath R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:offsetPath-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetSegment",
          "package": "diagrams-lib",
          "signature": "Double-\u003e Double-\u003e Segment Closed R2-\u003e Located (Trail R2)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetSegment",
          "normalized": "Double-\u003eDouble-\u003eSegment Closed R-\u003eLocated(Trail R)",
          "package": "diagrams-lib",
          "partial": "Segment",
          "signature": "Double-\u003eDouble-\u003eSegment Closed R-\u003eLocated(Trail R)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:offsetSegment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOffset a \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e with the default options and a given radius.  See \u003ccode\u003e\u003ca\u003eoffsetTrail'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetTrail",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Located (Trail R2) -\u003e Located (Trail R2)",
          "source": "src/Diagrams-TwoD-Offset.html#offsetTrail",
          "type": "function"
        },
        "index": {
          "description": "Offset Trail with the default options and given radius See offsetTrail",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetTrail",
          "normalized": "Double-\u003eLocated(Trail R)-\u003eLocated(Trail R)",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "Double-\u003eLocated(Trail R)-\u003eLocated(Trail R)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:offsetTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOffset a \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e with options and by a given radius.  This generates a new\n   trail that is always radius \u003ccode\u003er\u003c/code\u003e away from the given \u003ccode\u003e\u003ca\u003eTrail\u003c/a\u003e\u003c/code\u003e (depending on\n   the line join option) on the right.\n\u003c/p\u003e\u003cp\u003eThe styles applied to an outside corner can be seen here (with the original\n   trail in blue and the result of \u003ccode\u003e\u003ca\u003eoffsetTrail'\u003c/a\u003e\u003c/code\u003e in green):\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Offset_offsetTrailExample.svg#diagram=offsetTrailExample&width=600\"/\u003e\n\u003c/p\u003e\u003cp\u003eWhen a negative radius is given, the offset trail will be on the left:\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Offset_offsetTrailLeftExample.svg#diagram=offsetTrailLeftExample&width=200\"/\u003e\n\u003c/p\u003e\u003cp\u003eWhen offseting a counter-clockwise loop a positive radius gives an outer loop\n   while a negative radius gives an inner loop (both counter-clockwise).\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Offset_offsetTrailOuterExample.svg#diagram=offsetTrailOuterExample&width=300\"/\u003e\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetTrail'",
          "package": "diagrams-lib",
          "signature": "OffsetOpts-\u003e Double-\u003e Located (Trail R2)-\u003e Located (Trail R2)",
          "type": "function"
        },
        "index": {
          "description": "Offset Trail with options and by given radius This generates new trail that is always radius away from the given Trail depending on the line join option on the right The styles applied to an outside corner can be seen here with the original trail in blue and the result of offsetTrail in green When negative radius is given the offset trail will be on the left When offseting counter-clockwise loop positive radius gives an outer loop while negative radius gives an inner loop both counter-clockwise",
          "hierarchy": "Diagrams TwoD Offset",
          "module": "Diagrams.TwoD.Offset",
          "name": "offsetTrail'",
          "normalized": "OffsetOpts-\u003eDouble-\u003eLocated(Trail R)-\u003eLocated(Trail R)",
          "package": "diagrams-lib",
          "partial": "Trail'",
          "signature": "OffsetOpts-\u003eDouble-\u003eLocated(Trail R)-\u003eLocated(Trail R)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Offset.html#v:offsetTrail-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePaths in two dimensions are special since we may stroke them to\n create a 2D diagram, and (eventually) perform operations such as\n intersection and union.  They also have a trace, whereas paths in\n higher dimensions do not.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Path",
          "name": "Path",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Path.html",
          "type": "module"
        },
        "index": {
          "description": "Paths in two dimensions are special since we may stroke them to create diagram and eventually perform operations such as intersection and union They also have trace whereas paths in higher dimensions do not",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "Path",
          "package": "diagrams-lib",
          "partial": "Path",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eClip\u003c/code\u003e tracks the accumulated clipping paths applied to a\n   diagram.  Note that the semigroup structure on \u003ccode\u003eClip\u003c/code\u003e is list\n   concatenation, so applying multiple clipping paths is sensible.\n   The clipping region is the intersection of all the applied\n   clipping paths.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Path",
          "name": "Clip",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Path.html#Clip",
          "type": "newtype"
        },
        "index": {
          "description": "Clip tracks the accumulated clipping paths applied to diagram Note that the semigroup structure on Clip is list concatenation so applying multiple clipping paths is sensible The clipping region is the intersection of all the applied clipping paths",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "Clip",
          "package": "diagrams-lib",
          "partial": "Clip",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#t:Clip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumeration of algorithms or \"rules\" for determining which\n   points lie in the interior of a (possibly self-intersecting)\n   closed path.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Path",
          "name": "FillRule",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Path.html#FillRule",
          "type": "data"
        },
        "index": {
          "description": "Enumeration of algorithms or rules for determining which points lie in the interior of possibly self-intersecting closed path",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "FillRule",
          "package": "diagrams-lib",
          "partial": "Fill Rule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#t:FillRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Path",
          "name": "FillRuleA",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Path.html#FillRuleA",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "FillRuleA",
          "package": "diagrams-lib",
          "partial": "Fill Rule",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#t:FillRuleA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA record of options that control how a path is stroked.\n   \u003ccode\u003eStrokeOpts\u003c/code\u003e is an instance of \u003ccode\u003e\u003ca\u003eDefault\u003c/a\u003e\u003c/code\u003e, so a \u003ccode\u003eStrokeOpts\u003c/code\u003e\n   records can be created using \u003ccode\u003e\u003ccode\u003ewith\u003c/code\u003e { ... }\u003c/code\u003e notation.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Path",
          "name": "StrokeOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Path.html#StrokeOpts",
          "type": "data"
        },
        "index": {
          "description": "record of options that control how path is stroked StrokeOpts is an instance of Default so StrokeOpts records can be created using with notation",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "StrokeOpts",
          "package": "diagrams-lib",
          "partial": "Stroke Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#t:StrokeOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Path",
          "name": "Clip",
          "package": "diagrams-lib",
          "signature": "Clip [Path R2]",
          "source": "src/Diagrams-TwoD-Path.html#Clip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "Clip",
          "normalized": "Clip[Path R]",
          "package": "diagrams-lib",
          "partial": "Clip",
          "signature": "Clip[Path R]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:Clip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterior points are those where a ray\n   extended infinitely in a particular\n   direction crosses the path an odd number\n   of times. See\n   \u003ca\u003ehttp://en.wikipedia.org/wiki/Even-odd_rule\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "EvenOdd",
          "package": "diagrams-lib",
          "signature": "EvenOdd",
          "source": "src/Diagrams-TwoD-Path.html#FillRule",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:EvenOdd\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:EvenOdd\"]"
        },
        "index": {
          "description": "Interior points are those where ray extended infinitely in particular direction crosses the path an odd number of times See http en.wikipedia.org wiki Even-odd rule",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "EvenOdd",
          "package": "diagrams-lib",
          "partial": "Even Odd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:EvenOdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Path",
          "name": "FillRuleA",
          "package": "diagrams-lib",
          "signature": "FillRuleA (Last FillRule)",
          "source": "src/Diagrams-TwoD-Path.html#FillRuleA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "FillRuleA",
          "package": "diagrams-lib",
          "partial": "Fill Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:FillRuleA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "StrokeOpts",
          "package": "diagrams-lib",
          "signature": "StrokeOpts",
          "source": "src/Diagrams-TwoD-Path.html#StrokeOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:StrokeOpts\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:StrokeOpts\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "StrokeOpts",
          "package": "diagrams-lib",
          "partial": "Stroke Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:StrokeOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterior points are those with a nonzero\n   \u003cem\u003ewinding\u003c/em\u003e \u003cem\u003enumber\u003c/em\u003e.  See\n   \u003ca\u003ehttp://en.wikipedia.org/wiki/Nonzero-rule\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "Winding",
          "package": "diagrams-lib",
          "signature": "Winding",
          "source": "src/Diagrams-TwoD-Path.html#FillRule",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:Winding\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:Winding\"]"
        },
        "index": {
          "description": "Interior points are those with nonzero winding number See http en.wikipedia.org wiki Nonzero-rule",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "Winding",
          "package": "diagrams-lib",
          "partial": "Winding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:Winding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "_queryFillRule",
          "package": "diagrams-lib",
          "signature": "FillRule",
          "source": "src/Diagrams-TwoD-Path.html#StrokeOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:_queryFillRule\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_queryFillRule\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "_queryFillRule",
          "package": "diagrams-lib",
          "partial": "Fill Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:_queryFillRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "_vertexNames",
          "package": "diagrams-lib",
          "signature": "[[a]]",
          "source": "src/Diagrams-TwoD-Path.html#StrokeOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:_vertexNames\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_vertexNames\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "_vertexNames",
          "normalized": "[[a]]",
          "package": "diagrams-lib",
          "partial": "Names",
          "signature": "[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:_vertexNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClip a diagram by the given path:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Only the parts of the diagram which lie in the interior of the\n     path will be drawn.\n\u003c/li\u003e\u003cli\u003e The envelope of the diagram is unaffected.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "clipBy",
          "package": "diagrams-lib",
          "signature": "Path R2 -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Path.html#clipBy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:clipBy\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:clipBy\"]"
        },
        "index": {
          "description": "Clip diagram by the given path Only the parts of the diagram which lie in the interior of the path will be drawn The envelope of the diagram is unaffected",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "clipBy",
          "normalized": "Path R-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "By",
          "signature": "Path R-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:clipBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify the fill rule that should be used for determining which\n   points are inside a path.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "fillRule",
          "package": "diagrams-lib",
          "signature": "FillRule -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Path.html#fillRule",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:fillRule\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:fillRule\"]"
        },
        "index": {
          "description": "Specify the fill rule that should be used for determining which points are inside path",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "fillRule",
          "normalized": "FillRule-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Rule",
          "signature": "FillRule-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:fillRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the fill rule from a \u003ccode\u003e\u003ca\u003eFillRuleA\u003c/a\u003e\u003c/code\u003e attribute.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Path",
          "name": "getFillRule",
          "package": "diagrams-lib",
          "signature": "FillRuleA -\u003e FillRule",
          "source": "src/Diagrams-TwoD-Path.html#getFillRule",
          "type": "function"
        },
        "index": {
          "description": "Extract the fill rule from FillRuleA attribute",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "getFillRule",
          "normalized": "FillRuleA-\u003eFillRule",
          "package": "diagrams-lib",
          "partial": "Fill Rule",
          "signature": "FillRuleA-\u003eFillRule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:getFillRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether the given point is inside the given (closed) path,\n   by testing whether a ray extending from the point in the positive\n   x direction crosses the path an even (outside) or odd (inside)\n   number of times.  Note that \u003ccode\u003eFalse\u003c/code\u003e is \u003cem\u003ealways\u003c/em\u003e returned for\n   \u003cem\u003eopen\u003c/em\u003e paths, regardless of the number of crossings.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Path",
          "name": "isInsideEvenOdd",
          "package": "diagrams-lib",
          "signature": "P2 -\u003e Path R2 -\u003e Bool",
          "source": "src/Diagrams-TwoD-Path.html#isInsideEvenOdd",
          "type": "function"
        },
        "index": {
          "description": "Test whether the given point is inside the given closed path by testing whether ray extending from the point in the positive direction crosses the path an even outside or odd inside number of times Note that False is always returned for open paths regardless of the number of crossings",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "isInsideEvenOdd",
          "normalized": "P-\u003ePath R-\u003eBool",
          "package": "diagrams-lib",
          "partial": "Inside Even Odd",
          "signature": "P-\u003ePath R-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:isInsideEvenOdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether the given point is inside the given (closed) path,\n   by testing whether the point's \u003cem\u003ewinding number\u003c/em\u003e is nonzero. Note\n   that \u003ccode\u003eFalse\u003c/code\u003e is \u003cem\u003ealways\u003c/em\u003e returned for \u003cem\u003eopen\u003c/em\u003e paths, regardless of\n   the winding number.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Path",
          "name": "isInsideWinding",
          "package": "diagrams-lib",
          "signature": "P2 -\u003e Path R2 -\u003e Bool",
          "source": "src/Diagrams-TwoD-Path.html#isInsideWinding",
          "type": "function"
        },
        "index": {
          "description": "Test whether the given point is inside the given closed path by testing whether the point winding number is nonzero Note that False is always returned for open paths regardless of the winding number",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "isInsideWinding",
          "normalized": "P-\u003ePath R-\u003eBool",
          "package": "diagrams-lib",
          "partial": "Inside Winding",
          "signature": "P-\u003ePath R-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:isInsideWinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe fill rule used for determining which points are inside the path.\n   The default is \u003ccode\u003e\u003ca\u003eWinding\u003c/a\u003e\u003c/code\u003e.  NOTE: for now, this only affects the resulting\n   diagram's \u003ccode\u003e\u003ca\u003eQuery\u003c/a\u003e\u003c/code\u003e, \u003cem\u003enot\u003c/em\u003e how it will be drawn!  To set the fill rule\n   determining how it is to be drawn, use the \u003ccode\u003e\u003ca\u003efillRule\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "queryFillRule",
          "package": "diagrams-lib",
          "signature": "forall a.  Lens' (StrokeOpts a) FillRule",
          "source": "src/Diagrams-TwoD-Path.html#queryFillRule",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:queryFillRule\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:queryFillRule\"]"
        },
        "index": {
          "description": "The fill rule used for determining which points are inside the path The default is Winding NOTE for now this only affects the resulting diagram Query not how it will be drawn To set the fill rule determining how it is to be drawn use the fillRule function",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "queryFillRule",
          "package": "diagrams-lib",
          "partial": "Fill Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:queryFillRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a path into a diagram.  The resulting diagram has the\n   names 0, 1, ... assigned to each of the path's vertices.\n\u003c/p\u003e\u003cp\u003eSee also \u003ccode\u003e\u003ca\u003estroke'\u003c/a\u003e\u003c/code\u003e, which takes an extra options record allowing\n   its behavior to be customized.\n\u003c/p\u003e\u003cp\u003eNote that a bug in GHC 7.0.1 causes a context stack overflow when\n   inferring the type of \u003ccode\u003estroke\u003c/code\u003e.  The solution is to give a type\n   signature to expressions involving \u003ccode\u003estroke\u003c/code\u003e, or (recommended)\n   upgrade GHC (the bug is fixed in 7.0.2 onwards).\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "stroke",
          "package": "diagrams-lib",
          "signature": "Path R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Path.html#stroke",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:stroke\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:stroke\"]"
        },
        "index": {
          "description": "Convert path into diagram The resulting diagram has the names assigned to each of the path vertices See also stroke which takes an extra options record allowing its behavior to be customized Note that bug in GHC causes context stack overflow when inferring the type of stroke The solution is to give type signature to expressions involving stroke or recommended upgrade GHC the bug is fixed in onwards",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "stroke",
          "normalized": "Path R-\u003eDiagram a R",
          "package": "diagrams-lib",
          "signature": "Path R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:stroke"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003estroke\u003c/a\u003e\u003c/code\u003e that takes an extra record of options to\n   customize its behavior.  In particular:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Names can be assigned to the path's vertices\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eStrokeOpts\u003c/a\u003e\u003c/code\u003e is an instance of \u003ccode\u003e\u003ca\u003eDefault\u003c/a\u003e\u003c/code\u003e, so \u003ccode\u003estroke' \u003ccode\u003ewith\u003c/code\u003e {\n   ... }\u003c/code\u003e syntax may be used.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "stroke'",
          "package": "diagrams-lib",
          "signature": "StrokeOpts a -\u003e Path R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Path.html#stroke%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:stroke-39-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:stroke-39-\"]"
        },
        "index": {
          "description": "variant of stroke that takes an extra record of options to customize its behavior In particular Names can be assigned to the path vertices StrokeOpts is an instance of Default so stroke with syntax may be used",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "stroke'",
          "normalized": "StrokeOpts a-\u003ePath R-\u003eDiagram b R",
          "package": "diagrams-lib",
          "signature": "StrokeOpts a-\u003ePath R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:stroke-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA composition of \u003ccode\u003e\u003ca\u003estrokeT\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ewrapLine\u003c/a\u003e\u003c/code\u003e for conveniently\n   converting a line directly into a diagram.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "strokeLine",
          "package": "diagrams-lib",
          "signature": "Trail' Line R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Path.html#strokeLine",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeLine\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:strokeLine\"]"
        },
        "index": {
          "description": "composition of strokeT and wrapLine for conveniently converting line directly into diagram",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "strokeLine",
          "normalized": "Trail' Line R-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "Line",
          "signature": "Trail' Line R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience function for converting a \u003ccode\u003eLocated\u003c/code\u003e line directly\n   into a diagram; \u003ccode\u003estrokeLocLine = stroke . trailLike . mapLoc wrapLine\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "strokeLocLine",
          "package": "diagrams-lib",
          "signature": "Located (Trail' Line R2) -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Path.html#strokeLocLine",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeLocLine\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:strokeLocLine\"]"
        },
        "index": {
          "description": "convenience function for converting Located line directly into diagram strokeLocLine stroke trailLike mapLoc wrapLine",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "strokeLocLine",
          "normalized": "Located(Trail' Line R)-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "Loc Line",
          "signature": "Located(Trail' Line R)-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeLocLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience function for converting a \u003ccode\u003eLocated\u003c/code\u003e loop directly\n   into a diagram; \u003ccode\u003estrokeLocLoop = stroke . trailLike . mapLoc wrapLoop\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "strokeLocLoop",
          "package": "diagrams-lib",
          "signature": "Located (Trail' Loop R2) -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Path.html#strokeLocLoop",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeLocLoop\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:strokeLocLoop\"]"
        },
        "index": {
          "description": "convenience function for converting Located loop directly into diagram strokeLocLoop stroke trailLike mapLoc wrapLoop",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "strokeLocLoop",
          "normalized": "Located(Trail' Loop R)-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "Loc Loop",
          "signature": "Located(Trail' Loop R)-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeLocLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated synonym for \u003ccode\u003e\u003ca\u003estrokeLocTrail\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "strokeLocT",
          "package": "diagrams-lib",
          "signature": "Located (Trail R2) -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Path.html#strokeLocT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeLocT\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:strokeLocT\"]"
        },
        "index": {
          "description": "Deprecated synonym for strokeLocTrail",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "strokeLocT",
          "normalized": "Located(Trail R)-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "Loc",
          "signature": "Located(Trail R)-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeLocT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience function for converting a \u003ccode\u003eLocated Trail\u003c/code\u003e directly\n   into a diagram; \u003ccode\u003estrokeLocTrail = stroke . trailLike\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "strokeLocTrail",
          "package": "diagrams-lib",
          "signature": "Located (Trail R2) -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Path.html#strokeLocTrail",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeLocTrail\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:strokeLocTrail\"]"
        },
        "index": {
          "description": "convenience function for converting Located Trail directly into diagram strokeLocTrail stroke trailLike",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "strokeLocTrail",
          "normalized": "Located(Trail R)-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "Loc Trail",
          "signature": "Located(Trail R)-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeLocTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA composition of \u003ccode\u003e\u003ca\u003estrokeT\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ewrapLoop\u003c/a\u003e\u003c/code\u003e for conveniently\n   converting a loop directly into a diagram.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "strokeLoop",
          "package": "diagrams-lib",
          "signature": "Trail' Loop R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Path.html#strokeLoop",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeLoop\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:strokeLoop\"]"
        },
        "index": {
          "description": "composition of strokeT and wrapLoop for conveniently converting loop directly into diagram",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "strokeLoop",
          "normalized": "Trail' Loop R-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "Loop",
          "signature": "Trail' Loop R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated synonym for \u003ccode\u003e\u003ca\u003estrokeTrail\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "strokeT",
          "package": "diagrams-lib",
          "signature": "Trail R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Path.html#strokeT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeT\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:strokeT\"]"
        },
        "index": {
          "description": "Deprecated synonym for strokeTrail",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "strokeT",
          "normalized": "Trail R-\u003eDiagram a R",
          "package": "diagrams-lib",
          "signature": "Trail R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated synonym for \u003ccode\u003e\u003ca\u003estrokeTrail'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "strokeT'",
          "package": "diagrams-lib",
          "signature": "StrokeOpts a -\u003e Trail R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Path.html#strokeT%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeT-39-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:strokeT-39-\"]"
        },
        "index": {
          "description": "Deprecated synonym for strokeTrail",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "strokeT'",
          "normalized": "StrokeOpts a-\u003eTrail R-\u003eDiagram b R",
          "package": "diagrams-lib",
          "partial": "T'",
          "signature": "StrokeOpts a-\u003eTrail R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeT-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA composition of \u003ccode\u003e\u003ca\u003estroke\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003epathFromTrail\u003c/a\u003e\u003c/code\u003e for conveniently\n   converting a trail directly into a diagram.\n\u003c/p\u003e\u003cp\u003eNote that a bug in GHC 7.0.1 causes a context stack overflow when\n   inferring the type of \u003ccode\u003e\u003ca\u003estroke\u003c/a\u003e\u003c/code\u003e and hence of \u003ccode\u003estrokeTrail\u003c/code\u003e as well.\n   The solution is to give a type signature to expressions involving\n   \u003ccode\u003estrokeTrail\u003c/code\u003e, or (recommended) upgrade GHC (the bug is fixed in 7.0.2\n   onwards).\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "strokeTrail",
          "package": "diagrams-lib",
          "signature": "Trail R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Path.html#strokeTrail",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeTrail\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:strokeTrail\"]"
        },
        "index": {
          "description": "composition of stroke and pathFromTrail for conveniently converting trail directly into diagram Note that bug in GHC causes context stack overflow when inferring the type of stroke and hence of strokeTrail as well The solution is to give type signature to expressions involving strokeTrail or recommended upgrade GHC the bug is fixed in onwards",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "strokeTrail",
          "normalized": "Trail R-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "Trail R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA composition of \u003ccode\u003e\u003ca\u003estroke'\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003epathFromTrail\u003c/a\u003e\u003c/code\u003e for conveniently\n   converting a trail directly into a diagram.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "strokeTrail'",
          "package": "diagrams-lib",
          "signature": "StrokeOpts a -\u003e Trail R2 -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Path.html#strokeTrail%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeTrail-39-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:strokeTrail-39-\"]"
        },
        "index": {
          "description": "composition of stroke and pathFromTrail for conveniently converting trail directly into diagram",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "strokeTrail'",
          "normalized": "StrokeOpts a-\u003eTrail R-\u003eDiagram b R",
          "package": "diagrams-lib",
          "partial": "Trail'",
          "signature": "StrokeOpts a-\u003eTrail R-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:strokeTrail-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAtomic names that should be assigned to the vertices of the path so that\n   they can be referenced later.  If there are not enough names, the extra\n   vertices are not assigned names; if there are too many, the extra names\n   are ignored.  Note that this is a \u003cem\u003elist of lists\u003c/em\u003e of names, since paths\n   can consist of multiple trails.  The first list of names are assigned to\n   the vertices of the first trail, the second list to the second trail, and\n   so on.\n\u003c/p\u003e\u003cp\u003eThe default value is the empty list.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Path\",\"Diagrams.TwoD\"]",
          "name": "vertexNames",
          "package": "diagrams-lib",
          "signature": "forall a a'.  Lens (StrokeOpts a) (StrokeOpts a') [[a]] [[a']]",
          "source": "src/Diagrams-TwoD-Path.html#vertexNames",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:vertexNames\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:vertexNames\"]"
        },
        "index": {
          "description": "Atomic names that should be assigned to the vertices of the path so that they can be referenced later If there are not enough names the extra vertices are not assigned names if there are too many the extra names are ignored Note that this is list of lists of names since paths can consist of multiple trails The first list of names are assigned to the vertices of the first trail the second list to the second trail and so on The default value is the empty list",
          "hierarchy": "Diagrams TwoD Path",
          "module": "Diagrams.TwoD.Path",
          "name": "vertexNames",
          "normalized": "a b c Lens(StrokeOpts b)(StrokeOpts d)[[b]][[d]]",
          "package": "diagrams-lib",
          "partial": "Names",
          "signature": "forall a a'. Lens(StrokeOpts a)(StrokeOpts a')[[a]][[a']]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Path.html#v:vertexNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines a general API for creating various types of\n polygons.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Polygons",
          "name": "Polygons",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Polygons.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines general API for creating various types of polygons",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "Polygons",
          "package": "diagrams-lib",
          "partial": "Polygons",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePieces of a function graph can either be cycles or \"hairs\".\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Polygons",
          "name": "GraphPart",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Polygons.html#GraphPart",
          "type": "data"
        },
        "index": {
          "description": "Pieces of function graph can either be cycles or hairs",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "GraphPart",
          "package": "diagrams-lib",
          "partial": "Graph Part",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#t:GraphPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine how a polygon should be oriented.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Polygons",
          "name": "PolyOrientation",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Polygons.html#PolyOrientation",
          "type": "data"
        },
        "index": {
          "description": "Determine how polygon should be oriented",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "PolyOrientation",
          "package": "diagrams-lib",
          "partial": "Poly Orientation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#t:PolyOrientation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMethod used to determine the vertices of a polygon.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Polygons",
          "name": "PolyType",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Polygons.html#PolyType",
          "type": "data"
        },
        "index": {
          "description": "Method used to determine the vertices of polygon",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "PolyType",
          "package": "diagrams-lib",
          "partial": "Poly Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#t:PolyType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptions for specifying a polygon.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Polygons",
          "name": "PolygonOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Polygons.html#PolygonOpts",
          "type": "data"
        },
        "index": {
          "description": "Options for specifying polygon",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "PolygonOpts",
          "package": "diagrams-lib",
          "partial": "Polygon Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#t:PolygonOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptions for creating \"star\" polygons, where the edges connect\n   possibly non-adjacent vertices.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Polygons",
          "name": "StarOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Polygons.html#StarOpts",
          "type": "data"
        },
        "index": {
          "description": "Options for creating star polygons where the edges connect possibly non-adjacent vertices",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "StarOpts",
          "package": "diagrams-lib",
          "partial": "Star Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#t:StarOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Polygons",
          "name": "Cycle",
          "package": "diagrams-lib",
          "signature": "Cycle [a]",
          "source": "src/Diagrams-TwoD-Polygons.html#GraphPart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "Cycle",
          "normalized": "Cycle[a]",
          "package": "diagrams-lib",
          "partial": "Cycle",
          "signature": "Cycle[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:Cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Polygons",
          "name": "Hair",
          "package": "diagrams-lib",
          "signature": "Hair [a]",
          "source": "src/Diagrams-TwoD-Polygons.html#GraphPart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "Hair",
          "normalized": "Hair[a]",
          "package": "diagrams-lib",
          "partial": "Hair",
          "signature": "Hair[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:Hair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo special orientation; the first\n   vertex will be at (1,0).\n   This is the default.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "NoOrient",
          "package": "diagrams-lib",
          "signature": "NoOrient",
          "source": "src/Diagrams-TwoD-Polygons.html#PolyOrientation",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:NoOrient\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:NoOrient\"]"
        },
        "index": {
          "description": "No special orientation the first vertex will be at This is the default",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "NoOrient",
          "package": "diagrams-lib",
          "partial": "No Orient",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:NoOrient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrient \u003cem\u003ehorizontally\u003c/em\u003e, so the\n   bottommost edge is parallel to\n   the x-axis.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "OrientH",
          "package": "diagrams-lib",
          "signature": "OrientH",
          "source": "src/Diagrams-TwoD-Polygons.html#PolyOrientation",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:OrientH\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:OrientH\"]"
        },
        "index": {
          "description": "Orient horizontally so the bottommost edge is parallel to the x-axis",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "OrientH",
          "package": "diagrams-lib",
          "partial": "Orient",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:OrientH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrient so some edge is\n   \u003cem\u003efacing\u003c/em\u003e \u003cem\u003ein\u003c/em\u003e \u003cem\u003ethe\u003c/em\u003e \u003cem\u003edirection\u003c/em\u003e\n   \u003cem\u003eof\u003c/em\u003e, that is, perpendicular\n   to, the given vector.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "OrientTo",
          "package": "diagrams-lib",
          "signature": "OrientTo R2",
          "source": "src/Diagrams-TwoD-Polygons.html#PolyOrientation",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:OrientTo\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:OrientTo\"]"
        },
        "index": {
          "description": "Orient so some edge is facing in the direction of that is perpendicular to the given vector",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "OrientTo",
          "package": "diagrams-lib",
          "partial": "Orient To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:OrientTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrient \u003cem\u003evertically\u003c/em\u003e, so the\n   leftmost edge is parallel to the\n   y-axis.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "OrientV",
          "package": "diagrams-lib",
          "signature": "OrientV",
          "source": "src/Diagrams-TwoD-Polygons.html#PolyOrientation",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:OrientV\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:OrientV\"]"
        },
        "index": {
          "description": "Orient vertically so the leftmost edge is parallel to the y-axis",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "OrientV",
          "package": "diagrams-lib",
          "partial": "Orient",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:OrientV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \"polar\" polygon.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The first argument is a list of \u003cem\u003ecentral\u003c/em\u003e\n     \u003cem\u003eangles\u003c/em\u003e from each vertex to the next.\n\u003c/li\u003e\u003cli\u003e The second argument is a list of \u003cem\u003eradii\u003c/em\u003e from\n     the origin to each successive vertex.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eTo construct an \u003cem\u003en\u003c/em\u003e-gon, use a list of \u003cem\u003en-1\u003c/em\u003e\n   angles and \u003cem\u003en\u003c/em\u003e radii.  Extra angles or radii\n   are ignored.\n\u003c/p\u003e\u003cp\u003eCyclic polygons (with all vertices lying on a\n   circle) can be constructed using a second\n   argument of \u003ccode\u003e(repeat r)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "PolyPolar",
          "package": "diagrams-lib",
          "signature": "PolyPolar [a] [Double]",
          "source": "src/Diagrams-TwoD-Polygons.html#PolyType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:PolyPolar\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:PolyPolar\"]"
        },
        "index": {
          "description": "polar polygon The first argument is list of central angles from each vertex to the next The second argument is list of radii from the origin to each successive vertex To construct an gon use list of n-1 angles and radii Extra angles or radii are ignored Cyclic polygons with all vertices lying on circle can be constructed using second argument of repeat",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "PolyPolar",
          "normalized": "PolyPolar[a][Double]",
          "package": "diagrams-lib",
          "partial": "Poly Polar",
          "signature": "PolyPolar[a][Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:PolyPolar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA regular polygon with the given number of\n   sides (first argument) and the given radius\n   (second argument).\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "PolyRegular",
          "package": "diagrams-lib",
          "signature": "PolyRegular Int Double",
          "source": "src/Diagrams-TwoD-Polygons.html#PolyType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:PolyRegular\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:PolyRegular\"]"
        },
        "index": {
          "description": "regular polygon with the given number of sides first argument and the given radius second argument",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "PolyRegular",
          "package": "diagrams-lib",
          "partial": "Poly Regular",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:PolyRegular"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA polygon determined by the distance between\n   successive vertices and the angles formed by\n   each three successive vertices.  In other\n   words, a polygon specified by \"turtle\n   graphics\": go straight ahead x1 units; turn by\n   angle a1; go straght ahead x2 units; turn by\n   angle a2; etc. The polygon will be centered at\n   the \u003cem\u003ecentroid\u003c/em\u003e of its vertices.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The first argument is a list of \u003cem\u003evertex\u003c/em\u003e\n     \u003cem\u003eangles\u003c/em\u003e, giving the angle at each vertex\n     from the previous vertex to the next.  The\n     first angle in the list is the angle at the\n     \u003cem\u003esecond\u003c/em\u003e vertex; the first edge always starts\n     out heading in the positive y direction from\n     the first vertex.\n\u003c/li\u003e\u003cli\u003e The second argument is a list of distances\n     between successive vertices.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eTo construct an \u003cem\u003en\u003c/em\u003e-gon, use a list of \u003cem\u003en-2\u003c/em\u003e\n   angles and \u003cem\u003en-1\u003c/em\u003e edge lengths.  Extra angles or\n   lengths are ignored.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "PolySides",
          "package": "diagrams-lib",
          "signature": "PolySides [a] [Double]",
          "source": "src/Diagrams-TwoD-Polygons.html#PolyType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:PolySides\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:PolySides\"]"
        },
        "index": {
          "description": "polygon determined by the distance between successive vertices and the angles formed by each three successive vertices In other words polygon specified by turtle graphics go straight ahead x1 units turn by angle a1 go straght ahead x2 units turn by angle a2 etc The polygon will be centered at the centroid of its vertices The first argument is list of vertex angles giving the angle at each vertex from the previous vertex to the next The first angle in the list is the angle at the second vertex the first edge always starts out heading in the positive direction from the first vertex The second argument is list of distances between successive vertices To construct an gon use list of n-2 angles and n-1 edge lengths Extra angles or lengths are ignored",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "PolySides",
          "normalized": "PolySides[a][Double]",
          "package": "diagrams-lib",
          "partial": "Poly Sides",
          "signature": "PolySides[a][Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:PolySides"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "PolygonOpts",
          "package": "diagrams-lib",
          "signature": "PolygonOpts",
          "source": "src/Diagrams-TwoD-Polygons.html#PolygonOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:PolygonOpts\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:PolygonOpts\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "PolygonOpts",
          "package": "diagrams-lib",
          "partial": "Polygon Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:PolygonOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify the order in which the vertices should be\n   connected by a function that maps each vertex\n   index to the index of the vertex that should come\n   next.  Indexing of vertices begins at 0.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "StarFun",
          "package": "diagrams-lib",
          "signature": "StarFun (Int -\u003e Int)",
          "source": "src/Diagrams-TwoD-Polygons.html#StarOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:StarFun\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:StarFun\"]"
        },
        "index": {
          "description": "Specify the order in which the vertices should be connected by function that maps each vertex index to the index of the vertex that should come next Indexing of vertices begins at",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "StarFun",
          "normalized": "StarFun(Int-\u003eInt)",
          "package": "diagrams-lib",
          "partial": "Star Fun",
          "signature": "StarFun(Int-\u003eInt)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:StarFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify a star polygon by a \"skip\".  A skip of\n   1 indicates a normal polygon, where edges go\n   between successive vertices.  A skip of 2 means\n   that edges will connect every second vertex,\n   skipping one in between.  Generally, a skip of\n   \u003cem\u003en\u003c/em\u003e means that edges will connect every \u003cem\u003en\u003c/em\u003eth\n   vertex.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "StarSkip",
          "package": "diagrams-lib",
          "signature": "StarSkip Int",
          "source": "src/Diagrams-TwoD-Polygons.html#StarOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:StarSkip\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:StarSkip\"]"
        },
        "index": {
          "description": "Specify star polygon by skip skip of indicates normal polygon where edges go between successive vertices skip of means that edges will connect every second vertex skipping one in between Generally skip of means that edges will connect every th vertex",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "StarSkip",
          "package": "diagrams-lib",
          "partial": "Star Skip",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:StarSkip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "_polyCenter",
          "package": "diagrams-lib",
          "signature": "P2",
          "source": "src/Diagrams-TwoD-Polygons.html#PolygonOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:_polyCenter\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_polyCenter\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "_polyCenter",
          "package": "diagrams-lib",
          "partial": "Center",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:_polyCenter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "_polyOrient",
          "package": "diagrams-lib",
          "signature": "PolyOrientation",
          "source": "src/Diagrams-TwoD-Polygons.html#PolygonOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:_polyOrient\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_polyOrient\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "_polyOrient",
          "package": "diagrams-lib",
          "partial": "Orient",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:_polyOrient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "_polyType",
          "package": "diagrams-lib",
          "signature": "PolyType",
          "source": "src/Diagrams-TwoD-Polygons.html#PolygonOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:_polyType\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_polyType\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "_polyType",
          "package": "diagrams-lib",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:_polyType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a function graph from the given function and labels.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Polygons",
          "name": "mkGraph",
          "package": "diagrams-lib",
          "signature": "(Int -\u003e Int) -\u003e [a] -\u003e [GraphPart a]",
          "source": "src/Diagrams-TwoD-Polygons.html#mkGraph",
          "type": "function"
        },
        "index": {
          "description": "Generate function graph from the given function and labels",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "mkGraph",
          "normalized": "(Int-\u003eInt)-\u003e[a]-\u003e[GraphPart a]",
          "package": "diagrams-lib",
          "partial": "Graph",
          "signature": "(Int-\u003eInt)-\u003e[a]-\u003e[GraphPart a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:mkGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eorbits f n\u003c/code\u003e computes the graph of \u003ccode\u003ef\u003c/code\u003e on the integers mod \u003ccode\u003en\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Polygons",
          "name": "orbits",
          "package": "diagrams-lib",
          "signature": "(Int -\u003e Int) -\u003e Int -\u003e [GraphPart Int]",
          "source": "src/Diagrams-TwoD-Polygons.html#orbits",
          "type": "function"
        },
        "index": {
          "description": "orbits computes the graph of on the integers mod",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "orbits",
          "normalized": "(Int-\u003eInt)-\u003eInt-\u003e[GraphPart Int]",
          "package": "diagrams-lib",
          "signature": "(Int-\u003eInt)-\u003eInt-\u003e[GraphPart Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:orbits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a transformation to orient a trail.  \u003ccode\u003eorient v t\u003c/code\u003e\n   generates the smallest rotation such that one of the segments\n   adjacent to the vertex furthest in the direction of \u003ccode\u003ev\u003c/code\u003e is\n   perpendicular to \u003ccode\u003ev\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Polygons",
          "name": "orient",
          "package": "diagrams-lib",
          "signature": "R2 -\u003e Located (Trail R2) -\u003e T2",
          "source": "src/Diagrams-TwoD-Polygons.html#orient",
          "type": "function"
        },
        "index": {
          "description": "Generate transformation to orient trail orient generates the smallest rotation such that one of the segments adjacent to the vertex furthest in the direction of is perpendicular to",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "orient",
          "normalized": "R-\u003eLocated(Trail R)-\u003eT",
          "package": "diagrams-lib",
          "signature": "R-\u003eLocated(Trail R)-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:orient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShould a translation be applied to the polygon in order to place the center\n   at a particular location?\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "polyCenter",
          "package": "diagrams-lib",
          "signature": "Lens' PolygonOpts P2",
          "source": "src/Diagrams-TwoD-Polygons.html#polyCenter",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:polyCenter\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:polyCenter\"]"
        },
        "index": {
          "description": "Should translation be applied to the polygon in order to place the center at particular location",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "polyCenter",
          "package": "diagrams-lib",
          "partial": "Center",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:polyCenter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShould a rotation be applied to the polygon in order to orient it in a\n   particular way?\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "polyOrient",
          "package": "diagrams-lib",
          "signature": "Lens' PolygonOpts PolyOrientation",
          "source": "src/Diagrams-TwoD-Polygons.html#polyOrient",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:polyOrient\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:polyOrient\"]"
        },
        "index": {
          "description": "Should rotation be applied to the polygon in order to orient it in particular way",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "polyOrient",
          "package": "diagrams-lib",
          "partial": "Orient",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:polyOrient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate the located trail of a polygon specified by polar data\n   (central angles and radii). See \u003ccode\u003e\u003ca\u003ePolyPolar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Polygons",
          "name": "polyPolarTrail",
          "package": "diagrams-lib",
          "signature": "[a] -\u003e [Double] -\u003e Located (Trail R2)",
          "source": "src/Diagrams-TwoD-Polygons.html#polyPolarTrail",
          "type": "function"
        },
        "index": {
          "description": "Generate the located trail of polygon specified by polar data central angles and radii See PolyPolar",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "polyPolarTrail",
          "normalized": "[a]-\u003e[Double]-\u003eLocated(Trail R)",
          "package": "diagrams-lib",
          "partial": "Polar Trail",
          "signature": "[a]-\u003e[Double]-\u003eLocated(Trail R)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:polyPolarTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate the vertices of a regular polygon.  See \u003ccode\u003e\u003ca\u003ePolyRegular\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Polygons",
          "name": "polyRegularTrail",
          "package": "diagrams-lib",
          "signature": "Int -\u003e Double -\u003e Located (Trail R2)",
          "source": "src/Diagrams-TwoD-Polygons.html#polyRegularTrail",
          "type": "function"
        },
        "index": {
          "description": "Generate the vertices of regular polygon See PolyRegular",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "polyRegularTrail",
          "normalized": "Int-\u003eDouble-\u003eLocated(Trail R)",
          "package": "diagrams-lib",
          "partial": "Regular Trail",
          "signature": "Int-\u003eDouble-\u003eLocated(Trail R)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:polyRegularTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate the vertices of a polygon specified by side length and\n   angles, and a starting point for the trail such that the origin\n   is at the centroid of the vertices.  See \u003ccode\u003e\u003ca\u003ePolySides\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Polygons",
          "name": "polySidesTrail",
          "package": "diagrams-lib",
          "signature": "[a] -\u003e [Double] -\u003e Located (Trail R2)",
          "source": "src/Diagrams-TwoD-Polygons.html#polySidesTrail",
          "type": "function"
        },
        "index": {
          "description": "Generate the vertices of polygon specified by side length and angles and starting point for the trail such that the origin is at the centroid of the vertices See PolySides",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "polySidesTrail",
          "normalized": "[a]-\u003e[Double]-\u003eLocated(Trail R)",
          "package": "diagrams-lib",
          "partial": "Sides Trail",
          "signature": "[a]-\u003e[Double]-\u003eLocated(Trail R)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:polySidesTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a polygon.  See \u003ccode\u003e\u003ca\u003ePolygonOpts\u003c/a\u003e\u003c/code\u003e for more information.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "polyTrail",
          "package": "diagrams-lib",
          "signature": "PolygonOpts -\u003e Located (Trail R2)",
          "source": "src/Diagrams-TwoD-Polygons.html#polyTrail",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:polyTrail\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:polyTrail\"]"
        },
        "index": {
          "description": "Generate polygon See PolygonOpts for more information",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "polyTrail",
          "normalized": "PolygonOpts-\u003eLocated(Trail R)",
          "package": "diagrams-lib",
          "partial": "Trail",
          "signature": "PolygonOpts-\u003eLocated(Trail R)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:polyTrail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecification for the polygon's vertices.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "polyType",
          "package": "diagrams-lib",
          "signature": "Lens' PolygonOpts PolyType",
          "source": "src/Diagrams-TwoD-Polygons.html#polyType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:polyType\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:polyType\"]"
        },
        "index": {
          "description": "Specification for the polygon vertices",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "polyType",
          "package": "diagrams-lib",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:polyType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate the polygon described by the given options.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "polygon",
          "package": "diagrams-lib",
          "signature": "PolygonOpts -\u003e t",
          "source": "src/Diagrams-TwoD-Polygons.html#polygon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:polygon\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:polygon\"]"
        },
        "index": {
          "description": "Generate the polygon described by the given options",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "polygon",
          "normalized": "PolygonOpts-\u003ea",
          "package": "diagrams-lib",
          "signature": "PolygonOpts-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:polygon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a generalized \u003cem\u003estar\u003c/em\u003e \u003cem\u003epolygon\u003c/em\u003e.  The \u003ccode\u003e\u003ca\u003eStarOpts\u003c/a\u003e\u003c/code\u003e are used\n   to determine in which order the given vertices should be\n   connected.  The intention is that the second argument of type\n   \u003ccode\u003e[P2]\u003c/code\u003e could be generated by a call to \u003ccode\u003e\u003ca\u003epolygon\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003eregPoly\u003c/code\u003e, or\n   the like, since a list of vertices is \u003ccode\u003e\u003ca\u003eTrailLike\u003c/a\u003e\u003c/code\u003e.  But of course\n   the list can be generated any way you like.  A \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePath\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eR2\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is\n   returned (instead of any \u003ccode\u003e\u003ca\u003eTrailLike\u003c/a\u003e\u003c/code\u003e) because the resulting path\n   may have more than one component, for example if the vertices are\n   to be connected in several disjoint cycles.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Polygons\",\"Diagrams.TwoD\"]",
          "name": "star",
          "package": "diagrams-lib",
          "signature": "StarOpts -\u003e [P2] -\u003e Path R2",
          "source": "src/Diagrams-TwoD-Polygons.html#star",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:star\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:star\"]"
        },
        "index": {
          "description": "Create generalized star polygon The StarOpts are used to determine in which order the given vertices should be connected The intention is that the second argument of type P2 could be generated by call to polygon regPoly or the like since list of vertices is TrailLike But of course the list can be generated any way you like Path R2 is returned instead of any TrailLike because the resulting path may have more than one component for example if the vertices are to be connected in several disjoint cycles",
          "hierarchy": "Diagrams TwoD Polygons",
          "module": "Diagrams.TwoD.Polygons",
          "name": "star",
          "normalized": "StarOpts-\u003e[P]-\u003ePath R",
          "package": "diagrams-lib",
          "signature": "StarOpts-\u003e[P]-\u003ePath R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Polygons.html#v:star"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSegments in two dimensions are special since we may meaningfully\n compute their point of intersection with a ray.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Segment",
          "name": "Segment",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Segment.html",
          "type": "module"
        },
        "index": {
          "description": "Segments in two dimensions are special since we may meaningfully compute their point of intersection with ray",
          "hierarchy": "Diagrams TwoD Segment",
          "module": "Diagrams.TwoD.Segment",
          "name": "Segment",
          "package": "diagrams-lib",
          "partial": "Segment",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Segment.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVarious two-dimensional shapes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Shapes",
          "name": "Shapes",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Shapes.html",
          "type": "module"
        },
        "index": {
          "description": "Various two-dimensional shapes",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "Shapes",
          "package": "diagrams-lib",
          "partial": "Shapes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Shapes",
          "name": "RoundedRectOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Shapes.html#RoundedRectOpts",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "RoundedRectOpts",
          "package": "diagrams-lib",
          "partial": "Rounded Rect Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#t:RoundedRectOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "RoundedRectOpts",
          "package": "diagrams-lib",
          "signature": "RoundedRectOpts",
          "source": "src/Diagrams-TwoD-Shapes.html#RoundedRectOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:RoundedRectOpts\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:RoundedRectOpts\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "RoundedRectOpts",
          "package": "diagrams-lib",
          "partial": "Rounded Rect Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:RoundedRectOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "_radiusBL",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-TwoD-Shapes.html#RoundedRectOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:_radiusBL\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_radiusBL\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "_radiusBL",
          "package": "diagrams-lib",
          "partial": "BL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:_radiusBL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "_radiusBR",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-TwoD-Shapes.html#RoundedRectOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:_radiusBR\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_radiusBR\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "_radiusBR",
          "package": "diagrams-lib",
          "partial": "BR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:_radiusBR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "_radiusTL",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-TwoD-Shapes.html#RoundedRectOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:_radiusTL\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_radiusTL\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "_radiusTL",
          "package": "diagrams-lib",
          "partial": "TL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:_radiusTL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "_radiusTR",
          "package": "diagrams-lib",
          "signature": "Double",
          "source": "src/Diagrams-TwoD-Shapes.html#RoundedRectOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:_radiusTR\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:_radiusTR\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "_radiusTR",
          "package": "diagrams-lib",
          "partial": "TR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:_radiusTR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA regular decagon, with sides of the given length and base\n   parallel to the x-axis.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_decagonEx.svg#diagram=decagonEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "decagon",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#decagon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:decagon\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:decagon\"]"
        },
        "index": {
          "description": "regular decagon with sides of the given length and base parallel to the x-axis",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "decagon",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:decagon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA regular dodecagon, with sides of the given length and base\n   parallel to the x-axis.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_dodecagonEx.svg#diagram=dodecagonEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "dodecagon",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#dodecagon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:dodecagon\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:dodecagon\"]"
        },
        "index": {
          "description": "regular dodecagon with sides of the given length and base parallel to the x-axis",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "dodecagon",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:dodecagon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003etriangle\u003c/a\u003e\u003c/code\u003e, provided for backwards compatibility.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "eqTriangle",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#eqTriangle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:eqTriangle\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:eqTriangle\"]"
        },
        "index": {
          "description": "synonym for triangle provided for backwards compatibility",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "eqTriangle",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "partial": "Triangle",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:eqTriangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA regular hendecagon, with sides of the given length and base\n   parallel to the x-axis.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_hendecagonEx.svg#diagram=hendecagonEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "hendecagon",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#hendecagon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:hendecagon\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:hendecagon\"]"
        },
        "index": {
          "description": "regular hendecagon with sides of the given length and base parallel to the x-axis",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "hendecagon",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:hendecagon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA regular heptagon, with sides of the given length and base\n   parallel to the x-axis.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_heptagonEx.svg#diagram=heptagonEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "heptagon",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#heptagon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:heptagon\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:heptagon\"]"
        },
        "index": {
          "description": "regular heptagon with sides of the given length and base parallel to the x-axis",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "heptagon",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:heptagon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA regular hexagon, with sides of the given length and base\n   parallel to the x-axis.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_hexagonEx.svg#diagram=hexagonEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "hexagon",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#hexagon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:hexagon\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:hexagon\"]"
        },
        "index": {
          "description": "regular hexagon with sides of the given length and base parallel to the x-axis",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "hexagon",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:hexagon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a centered horizontal (L-R) line of the given length.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_hruleEx.svg#diagram=hruleEx&width=300\"/\u003e\n\u003c/p\u003e\u003cpre\u003e hruleEx = vcat' (with & sep .~ 0.2) (map hrule [1..5])\n         # centerXY # pad 1.1\n\u003c/pre\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "hrule",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#hrule",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:hrule\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:hrule\"]"
        },
        "index": {
          "description": "Create centered horizontal L-R line of the given length hruleEx vcat with sep map hrule centerXY pad",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "hrule",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:hrule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA regular nonagon, with sides of the given length and base\n   parallel to the x-axis.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_nonagonEx.svg#diagram=nonagonEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "nonagon",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#nonagon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:nonagon\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:nonagon\"]"
        },
        "index": {
          "description": "regular nonagon with sides of the given length and base parallel to the x-axis",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "nonagon",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:nonagon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA regular octagon, with sides of the given length and base\n   parallel to the x-axis.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_octagonEx.svg#diagram=octagonEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "octagon",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#octagon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:octagon\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:octagon\"]"
        },
        "index": {
          "description": "regular octagon with sides of the given length and base parallel to the x-axis",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "octagon",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:octagon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA regular pentagon, with sides of the given length and base\n   parallel to the x-axis.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_pentagonEx.svg#diagram=pentagonEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "pentagon",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#pentagon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:pentagon\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:pentagon\"]"
        },
        "index": {
          "description": "regular pentagon with sides of the given length and base parallel to the x-axis",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "pentagon",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:pentagon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "radiusBL",
          "package": "diagrams-lib",
          "signature": "Lens' RoundedRectOpts Double",
          "source": "src/Diagrams-TwoD-Shapes.html#radiusBL",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:radiusBL\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:radiusBL\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "radiusBL",
          "package": "diagrams-lib",
          "partial": "BL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:radiusBL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "radiusBR",
          "package": "diagrams-lib",
          "signature": "Lens' RoundedRectOpts Double",
          "source": "src/Diagrams-TwoD-Shapes.html#radiusBR",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:radiusBR\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:radiusBR\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "radiusBR",
          "package": "diagrams-lib",
          "partial": "BR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:radiusBR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "radiusTL",
          "package": "diagrams-lib",
          "signature": "Lens' RoundedRectOpts Double",
          "source": "src/Diagrams-TwoD-Shapes.html#radiusTL",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:radiusTL\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:radiusTL\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "radiusTL",
          "package": "diagrams-lib",
          "partial": "TL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:radiusTL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "radiusTR",
          "package": "diagrams-lib",
          "signature": "Lens' RoundedRectOpts Double",
          "source": "src/Diagrams-TwoD-Shapes.html#radiusTR",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:radiusTR\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:radiusTR\"]"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "radiusTR",
          "package": "diagrams-lib",
          "partial": "TR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:radiusTR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erect w h\u003c/code\u003e is an axis-aligned rectangle of width \u003ccode\u003ew\u003c/code\u003e and height\n   \u003ccode\u003eh\u003c/code\u003e, centered at the origin.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_rectEx.svg#diagram=rectEx&width=150\"/\u003e\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "rect",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#rect",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:rect\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:rect\"]"
        },
        "index": {
          "description": "rect is an axis-aligned rectangle of width and height centered at the origin",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "rect",
          "normalized": "Double-\u003eDouble-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003eDouble-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:rect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a regular polygon. The first argument is the number of\n   sides, and the second is the \u003cem\u003elength\u003c/em\u003e of the sides. (Compare to the\n   \u003ccode\u003e\u003ca\u003epolygon\u003c/a\u003e\u003c/code\u003e function with a \u003ccode\u003e\u003ca\u003ePolyRegular\u003c/a\u003e\u003c/code\u003e option, which produces\n   polygons of a given \u003cem\u003eradius\u003c/em\u003e).\n\u003c/p\u003e\u003cp\u003eThe polygon will be oriented with one edge parallel to the x-axis.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "regPoly",
          "package": "diagrams-lib",
          "signature": "Int -\u003e Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#regPoly",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:regPoly\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:regPoly\"]"
        },
        "index": {
          "description": "Create regular polygon The first argument is the number of sides and the second is the length of the sides Compare to the polygon function with PolyRegular option which produces polygons of given radius The polygon will be oriented with one edge parallel to the x-axis",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "regPoly",
          "normalized": "Int-\u003eDouble-\u003ea",
          "package": "diagrams-lib",
          "partial": "Poly",
          "signature": "Int-\u003eDouble-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:regPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eroundedRect w h r\u003c/code\u003e generates a closed trail, or closed path\n   centered at the origin, of an axis-aligned rectangle with width\n   \u003ccode\u003ew\u003c/code\u003e, height \u003ccode\u003eh\u003c/code\u003e, and circular rounded corners of radius \u003ccode\u003er\u003c/code\u003e.  If\n   \u003ccode\u003er\u003c/code\u003e is negative the corner will be cut out in a reverse arc. If\n   the size of \u003ccode\u003er\u003c/code\u003e is larger than half the smaller dimension of \u003ccode\u003ew\u003c/code\u003e\n   and \u003ccode\u003eh\u003c/code\u003e, then it will be reduced to fit in that range, to prevent\n   the corners from overlapping.  The trail or path begins with the\n   right edge and proceeds counterclockwise.  If you need to specify\n   a different radius for each corner individually, use\n   \u003ccode\u003e\u003ca\u003eroundedRect'\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_roundedRectEx.svg#diagram=roundedRectEx&width=400\"/\u003e\n\u003c/p\u003e\u003cpre\u003e roundedRectEx = pad 1.1 . centerXY $ hcat' (with & sep .~ 0.2)\n   [ roundedRect  0.5 0.4 0.1\n   , roundedRect  0.5 0.4 (-0.1)\n   , roundedRect' 0.7 0.4 (with & radiusTL .~ 0.2\n                                & radiusTR .~ -0.2\n                                & radiusBR .~ 0.1)\n   ]\n\u003c/pre\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "roundedRect",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Double -\u003e Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#roundedRect",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:roundedRect\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:roundedRect\"]"
        },
        "index": {
          "description": "roundedRect generates closed trail or closed path centered at the origin of an axis-aligned rectangle with width height and circular rounded corners of radius If is negative the corner will be cut out in reverse arc If the size of is larger than half the smaller dimension of and then it will be reduced to fit in that range to prevent the corners from overlapping The trail or path begins with the right edge and proceeds counterclockwise If you need to specify different radius for each corner individually use roundedRect instead roundedRectEx pad centerXY hcat with sep roundedRect roundedRect roundedRect with radiusTL radiusTR radiusBR",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "roundedRect",
          "normalized": "Double-\u003eDouble-\u003eDouble-\u003ea",
          "package": "diagrams-lib",
          "partial": "Rect",
          "signature": "Double-\u003eDouble-\u003eDouble-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:roundedRect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eroundedRect'\u003c/code\u003e works like \u003ccode\u003eroundedRect\u003c/code\u003e but allows you to set the radius of\n   each corner indivually, using \u003ccode\u003eRoundedRectOpts\u003c/code\u003e. The default corner radius is 0.\n   Each radius can also be negative, which results in the curves being reversed\n   to be inward instead of outward.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "roundedRect'",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Double -\u003e RoundedRectOpts -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#roundedRect%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:roundedRect-39-\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:roundedRect-39-\"]"
        },
        "index": {
          "description": "roundedRect works like roundedRect but allows you to set the radius of each corner indivually using RoundedRectOpts The default corner radius is Each radius can also be negative which results in the curves being reversed to be inward instead of outward",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "roundedRect'",
          "normalized": "Double-\u003eDouble-\u003eRoundedRectOpts-\u003ea",
          "package": "diagrams-lib",
          "partial": "Rect'",
          "signature": "Double-\u003eDouble-\u003eRoundedRectOpts-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:roundedRect-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003eheptagon\u003c/a\u003e\u003c/code\u003e.  It is, however, completely inferior,\n   being a base admixture of the Latin \u003cem\u003eseptum\u003c/em\u003e (seven) and the\n   Greek &#947;&#969;&#957;&#943;&#945; (angl\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "septagon",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#septagon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:septagon\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:septagon\"]"
        },
        "index": {
          "description": "synonym for heptagon It is however completely inferior being base admixture of the Latin septum seven and the Greek angl",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "septagon",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:septagon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA square with its center at the origin and sides of the given\n   length, oriented parallel to the axes.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_squareEx.svg#diagram=squareEx&width=200\"/\u003e\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "square",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#square",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:square\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:square\"]"
        },
        "index": {
          "description": "square with its center at the origin and sides of the given length oriented parallel to the axes",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "square",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:square"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn equilateral triangle, with sides of the given length and base\n   parallel to the x-axis.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_triangleEx.svg#diagram=triangleEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "triangle",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#triangle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:triangle\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:triangle\"]"
        },
        "index": {
          "description": "An equilateral triangle with sides of the given length and base parallel to the x-axis",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "triangle",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:triangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA square with its center at the origin and sides of length 1,\n   oriented parallel to the axes.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_unitSquareEx.svg#diagram=unitSquareEx&width=100\"/\u003e\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "unitSquare",
          "package": "diagrams-lib",
          "signature": "t",
          "source": "src/Diagrams-TwoD-Shapes.html#unitSquare",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:unitSquare\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:unitSquare\"]"
        },
        "index": {
          "description": "square with its center at the origin and sides of length oriented parallel to the axes",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "unitSquare",
          "package": "diagrams-lib",
          "partial": "Square",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:unitSquare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a centered vertical (T-B) line of the given length.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"diagrams/src_Diagrams_TwoD_Shapes_vruleEx.svg#diagram=vruleEx&height=100\"/\u003e\n\u003c/p\u003e\u003cpre\u003e vruleEx = hcat' (with & sep .~ 0.2) (map vrule [1, 1.2 .. 2])\n         # centerXY # pad 1.1\n\u003c/pre\u003e",
          "module": "[\"Diagrams.TwoD.Shapes\",\"Diagrams.TwoD\"]",
          "name": "vrule",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t",
          "source": "src/Diagrams-TwoD-Shapes.html#vrule",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:vrule\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:vrule\"]"
        },
        "index": {
          "description": "Create centered vertical T-B line of the given length vruleEx hcat with sep map vrule centerXY pad",
          "hierarchy": "Diagrams TwoD Shapes",
          "module": "Diagrams.TwoD.Shapes",
          "name": "vrule",
          "normalized": "Double-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Shapes.html#v:vrule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUtilities for working with sizes of two-dimensional objects.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Size",
          "name": "Size",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Size.html",
          "type": "module"
        },
        "index": {
          "description": "Utilities for working with sizes of two-dimensional objects",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "Size",
          "package": "diagrams-lib",
          "partial": "Size",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA specification of a (requested) rectangular size.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Size",
          "name": "SizeSpec2D",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Size.html#SizeSpec2D",
          "type": "data"
        },
        "index": {
          "description": "specification of requested rectangular size",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "SizeSpec2D",
          "package": "diagrams-lib",
          "partial": "Size Spec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#t:SizeSpec2D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbsolute size: use whatever\n size an object already has;\n do not rescale.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Size\",\"Diagrams.TwoD\"]",
          "name": "Absolute",
          "package": "diagrams-lib",
          "signature": "Absolute",
          "source": "src/Diagrams-TwoD-Size.html#SizeSpec2D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:Absolute\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:Absolute\"]"
        },
        "index": {
          "description": "Absolute size use whatever size an object already has do not rescale",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "Absolute",
          "package": "diagrams-lib",
          "partial": "Absolute",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:Absolute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn explicit specification\n of a width and height.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Size\",\"Diagrams.TwoD\"]",
          "name": "Dims",
          "package": "diagrams-lib",
          "signature": "Dims !Double !Double",
          "source": "src/Diagrams-TwoD-Size.html#SizeSpec2D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:Dims\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:Dims\"]"
        },
        "index": {
          "description": "An explicit specification of width and height",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "Dims",
          "package": "diagrams-lib",
          "partial": "Dims",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:Dims"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify an explicit\n height. The width should be\n determined automatically (so\n as to preserve aspect ratio).\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Size\",\"Diagrams.TwoD\"]",
          "name": "Height",
          "package": "diagrams-lib",
          "signature": "Height !Double",
          "source": "src/Diagrams-TwoD-Size.html#SizeSpec2D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:Height\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:Height\"]"
        },
        "index": {
          "description": "Specify an explicit height The width should be determined automatically so as to preserve aspect ratio",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "Height",
          "package": "diagrams-lib",
          "partial": "Height",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:Height"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify an explicit\n width. The height should be\n determined automatically (so\n as to preserve aspect ratio).\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Size\",\"Diagrams.TwoD\"]",
          "name": "Width",
          "package": "diagrams-lib",
          "signature": "Width !Double",
          "source": "src/Diagrams-TwoD-Size.html#SizeSpec2D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:Width\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:Width\"]"
        },
        "index": {
          "description": "Specify an explicit width The height should be determined automatically so as to preserve aspect ratio",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "Width",
          "package": "diagrams-lib",
          "partial": "Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:Width"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the point at the center (in the x- and y-directions) of a\n   enveloped object.  Return the origin for objects with an empty\n   envelope.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Size\",\"Diagrams.TwoD\"]",
          "name": "center2D",
          "package": "diagrams-lib",
          "signature": "a -\u003e P2",
          "source": "src/Diagrams-TwoD-Size.html#center2D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:center2D\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:center2D\"]"
        },
        "index": {
          "description": "Compute the point at the center in the and y-directions of enveloped object Return the origin for objects with an empty envelope",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "center2D",
          "normalized": "a-\u003eP",
          "package": "diagrams-lib",
          "signature": "a-\u003eP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:center2D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the absolute  x-coordinate range of an enveloped object in\n   R2, in  the form (lo,hi).   Return \u003ccode\u003eNothing\u003c/code\u003e for objects  with an\n   empty envelope.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Size\",\"Diagrams.TwoD\"]",
          "name": "extentX",
          "package": "diagrams-lib",
          "signature": "a -\u003e Maybe (Double, Double)",
          "source": "src/Diagrams-TwoD-Size.html#extentX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:extentX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:extentX\"]"
        },
        "index": {
          "description": "Compute the absolute x-coordinate range of an enveloped object in R2 in the form lo hi Return Nothing for objects with an empty envelope",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "extentX",
          "normalized": "a-\u003eMaybe(Double,Double)",
          "package": "diagrams-lib",
          "signature": "a-\u003eMaybe(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:extentX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the absolute y-coordinate range of an enveloped object in\n   R2, in the form (lo,hi).\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Size\",\"Diagrams.TwoD\"]",
          "name": "extentY",
          "package": "diagrams-lib",
          "signature": "a -\u003e Maybe (Double, Double)",
          "source": "src/Diagrams-TwoD-Size.html#extentY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:extentY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:extentY\"]"
        },
        "index": {
          "description": "Compute the absolute y-coordinate range of an enveloped object in R2 in the form lo hi",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "extentY",
          "normalized": "a-\u003eMaybe(Double,Double)",
          "package": "diagrams-lib",
          "signature": "a-\u003eMaybe(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:extentY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the height of an enveloped object.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Size\",\"Diagrams.TwoD\"]",
          "name": "height",
          "package": "diagrams-lib",
          "signature": "a -\u003e Double",
          "source": "src/Diagrams-TwoD-Size.html#height",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:height\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:height\"]"
        },
        "index": {
          "description": "Compute the height of an enveloped object",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "height",
          "normalized": "a-\u003eDouble",
          "package": "diagrams-lib",
          "signature": "a-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:height"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a size specification from a possibly-specified width and\n   height.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Size\",\"Diagrams.TwoD\"]",
          "name": "mkSizeSpec",
          "package": "diagrams-lib",
          "signature": "Maybe Double -\u003e Maybe Double -\u003e SizeSpec2D",
          "source": "src/Diagrams-TwoD-Size.html#mkSizeSpec",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:mkSizeSpec\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:mkSizeSpec\"]"
        },
        "index": {
          "description": "Create size specification from possibly-specified width and height",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "mkSizeSpec",
          "normalized": "Maybe Double-\u003eMaybe Double-\u003eSizeSpec D",
          "package": "diagrams-lib",
          "partial": "Size Spec",
          "signature": "Maybe Double-\u003eMaybe Double-\u003eSizeSpec D",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:mkSizeSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erequiredScaleT spec sz\u003c/code\u003e returns a transformation (a uniform scale)\n   which can be applied to something of size \u003ccode\u003esz\u003c/code\u003e to make it fit the\n   requested size \u003ccode\u003espec\u003c/code\u003e, without changing the aspect ratio.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Size",
          "name": "requiredScaleT",
          "package": "diagrams-lib",
          "signature": "SizeSpec2D -\u003e (Double, Double) -\u003e Transformation R2",
          "source": "src/Diagrams-TwoD-Size.html#requiredScaleT",
          "type": "function"
        },
        "index": {
          "description": "requiredScaleT spec sz returns transformation uniform scale which can be applied to something of size sz to make it fit the requested size spec without changing the aspect ratio",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "requiredScaleT",
          "normalized": "SizeSpec D-\u003e(Double,Double)-\u003eTransformation R",
          "package": "diagrams-lib",
          "partial": "Scale",
          "signature": "SizeSpec D-\u003e(Double,Double)-\u003eTransformation R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:requiredScaleT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the width and height of an enveloped object.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Size\",\"Diagrams.TwoD\"]",
          "name": "size2D",
          "package": "diagrams-lib",
          "signature": "a -\u003e (Double, Double)",
          "source": "src/Diagrams-TwoD-Size.html#size2D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:size2D\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:size2D\"]"
        },
        "index": {
          "description": "Compute the width and height of an enveloped object",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "size2D",
          "normalized": "a-\u003e(Double,Double)",
          "package": "diagrams-lib",
          "signature": "a-\u003e(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:size2D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the size of an enveloped object as a \u003ccode\u003e\u003ca\u003eSizeSpec2D\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Size\",\"Diagrams.TwoD\"]",
          "name": "sizeSpec2D",
          "package": "diagrams-lib",
          "signature": "a -\u003e SizeSpec2D",
          "source": "src/Diagrams-TwoD-Size.html#sizeSpec2D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:sizeSpec2D\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:sizeSpec2D\"]"
        },
        "index": {
          "description": "Compute the size of an enveloped object as SizeSpec2D value",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "sizeSpec2D",
          "normalized": "a-\u003eSizeSpec D",
          "package": "diagrams-lib",
          "partial": "Spec",
          "signature": "a-\u003eSizeSpec D",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:sizeSpec2D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUniformly scale any enveloped object so that it fits within the\n   given size.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Size\",\"Diagrams.TwoD\"]",
          "name": "sized",
          "package": "diagrams-lib",
          "signature": "SizeSpec2D -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Size.html#sized",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:sized\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:sized\"]"
        },
        "index": {
          "description": "Uniformly scale any enveloped object so that it fits within the given size",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "sized",
          "normalized": "SizeSpec D-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "SizeSpec D-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:sized"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUniformly scale an enveloped object so that it \"has the same\n   size as\" (fits within the width and height of) some other\n   object.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Size\",\"Diagrams.TwoD\"]",
          "name": "sizedAs",
          "package": "diagrams-lib",
          "signature": "b -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Size.html#sizedAs",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:sizedAs\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:sizedAs\"]"
        },
        "index": {
          "description": "Uniformly scale an enveloped object so that it has the same size as fits within the width and height of some other object",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "sizedAs",
          "normalized": "a-\u003eb-\u003eb",
          "package": "diagrams-lib",
          "partial": "As",
          "signature": "b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:sizedAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the width of an enveloped object.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Size\",\"Diagrams.TwoD\"]",
          "name": "width",
          "package": "diagrams-lib",
          "signature": "a -\u003e Double",
          "source": "src/Diagrams-TwoD-Size.html#width",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:width\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:width\"]"
        },
        "index": {
          "description": "Compute the width of an enveloped object",
          "hierarchy": "Diagrams TwoD Size",
          "module": "Diagrams.TwoD.Size",
          "name": "width",
          "normalized": "a-\u003eDouble",
          "package": "diagrams-lib",
          "signature": "a-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Size.html#v:width"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVery basic text primitives along with associated attributes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Text",
          "name": "Text",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Text.html",
          "type": "module"
        },
        "index": {
          "description": "Very basic text primitives along with associated attributes",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "Text",
          "package": "diagrams-lib",
          "partial": "Text",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003eFont\u003c/code\u003e attribute specifies the name of a font family.  Inner\n   \u003ccode\u003eFont\u003c/code\u003e attributes override outer ones.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Text",
          "name": "Font",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Text.html#Font",
          "type": "newtype"
        },
        "index": {
          "description": "The Font attribute specifies the name of font family Inner Font attributes override outer ones",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "Font",
          "package": "diagrams-lib",
          "partial": "Font",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#t:Font"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003eFontSize\u003c/code\u003e attribute specifies the size of a font's\n   em-square, measured with respect to the current local vector space.\n   Inner \u003ccode\u003eFontSize\u003c/code\u003e attributes override outer ones.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Text",
          "name": "FontSize",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Text.html#FontSize",
          "type": "newtype"
        },
        "index": {
          "description": "The FontSize attribute specifies the size of font em-square measured with respect to the current local vector space Inner FontSize attributes override outer ones",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "FontSize",
          "package": "diagrams-lib",
          "partial": "Font Size",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#t:FontSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Text",
          "name": "FontSlant",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Text.html#FontSlant",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "FontSlant",
          "package": "diagrams-lib",
          "partial": "Font Slant",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#t:FontSlant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003eFontSlantA\u003c/code\u003e attribute specifies the slant (normal, italic,\n   or oblique) that should be used for all text within a diagram.\n   Inner \u003ccode\u003eFontSlantA\u003c/code\u003e attributes override outer ones.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Text",
          "name": "FontSlantA",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Text.html#FontSlantA",
          "type": "data"
        },
        "index": {
          "description": "The FontSlantA attribute specifies the slant normal italic or oblique that should be used for all text within diagram Inner FontSlantA attributes override outer ones",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "FontSlantA",
          "package": "diagrams-lib",
          "partial": "Font Slant",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#t:FontSlantA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Text",
          "name": "FontWeight",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Text.html#FontWeight",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "FontWeight",
          "package": "diagrams-lib",
          "partial": "Font Weight",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#t:FontWeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003eFontWeightA\u003c/code\u003e attribute specifies the weight (normal or bold)\n   that should be used for all text within a diagram.  Inner\n   \u003ccode\u003eFontWeightA\u003c/code\u003e attributes override outer ones.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Text",
          "name": "FontWeightA",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Text.html#FontWeightA",
          "type": "data"
        },
        "index": {
          "description": "The FontWeightA attribute specifies the weight normal or bold that should be used for all text within diagram Inner FontWeightA attributes override outer ones",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "FontWeightA",
          "package": "diagrams-lib",
          "partial": "Font Weight",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#t:FontWeightA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA text primitive consists of the string contents and alignment\n   specification, along with a transformation mapping from the local\n   vector space of the text to the vector space in which it is\n   embedded.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Text",
          "name": "Text",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Text.html#Text",
          "type": "data"
        },
        "index": {
          "description": "text primitive consists of the string contents and alignment specification along with transformation mapping from the local vector space of the text to the vector space in which it is embedded",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "Text",
          "package": "diagrams-lib",
          "partial": "Text",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#t:Text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eTextAlignment\u003c/code\u003e specifies the alignment of the text's origin.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Text",
          "name": "TextAlignment",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Text.html#TextAlignment",
          "type": "data"
        },
        "index": {
          "description": "TextAlignment specifies the alignment of the text origin",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "TextAlignment",
          "package": "diagrams-lib",
          "partial": "Text Alignment",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#t:TextAlignment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Text",
          "name": "BaselineText",
          "package": "diagrams-lib",
          "signature": "BaselineText",
          "source": "src/Diagrams-TwoD-Text.html#TextAlignment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "BaselineText",
          "package": "diagrams-lib",
          "partial": "Baseline Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:BaselineText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Text",
          "name": "BoxAlignedText",
          "package": "diagrams-lib",
          "signature": "BoxAlignedText Double Double",
          "source": "src/Diagrams-TwoD-Text.html#TextAlignment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "BoxAlignedText",
          "package": "diagrams-lib",
          "partial": "Box Aligned Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:BoxAlignedText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Text",
          "name": "Font",
          "package": "diagrams-lib",
          "signature": "Font (Last String)",
          "source": "src/Diagrams-TwoD-Text.html#Font",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "Font",
          "package": "diagrams-lib",
          "partial": "Font",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:Font"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Text",
          "name": "FontSize",
          "package": "diagrams-lib",
          "signature": "FontSize (Last Double)",
          "source": "src/Diagrams-TwoD-Text.html#FontSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "FontSize",
          "package": "diagrams-lib",
          "partial": "Font Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:FontSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Text",
          "name": "FontSlantItalic",
          "package": "diagrams-lib",
          "signature": "FontSlantItalic",
          "source": "src/Diagrams-TwoD-Text.html#FontSlant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "FontSlantItalic",
          "package": "diagrams-lib",
          "partial": "Font Slant Italic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:FontSlantItalic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Text",
          "name": "FontSlantNormal",
          "package": "diagrams-lib",
          "signature": "FontSlantNormal",
          "source": "src/Diagrams-TwoD-Text.html#FontSlant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "FontSlantNormal",
          "package": "diagrams-lib",
          "partial": "Font Slant Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:FontSlantNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Text",
          "name": "FontSlantOblique",
          "package": "diagrams-lib",
          "signature": "FontSlantOblique",
          "source": "src/Diagrams-TwoD-Text.html#FontSlant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "FontSlantOblique",
          "package": "diagrams-lib",
          "partial": "Font Slant Oblique",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:FontSlantOblique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Text",
          "name": "FontWeightBold",
          "package": "diagrams-lib",
          "signature": "FontWeightBold",
          "source": "src/Diagrams-TwoD-Text.html#FontWeight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "FontWeightBold",
          "package": "diagrams-lib",
          "partial": "Font Weight Bold",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:FontWeightBold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Text",
          "name": "FontWeightNormal",
          "package": "diagrams-lib",
          "signature": "FontWeightNormal",
          "source": "src/Diagrams-TwoD-Text.html#FontWeight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "FontWeightNormal",
          "package": "diagrams-lib",
          "partial": "Font Weight Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:FontWeightNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Text",
          "name": "Text",
          "package": "diagrams-lib",
          "signature": "Text T2 TextAlignment String",
          "source": "src/Diagrams-TwoD-Text.html#Text",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "Text",
          "package": "diagrams-lib",
          "partial": "Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:Text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a primitive text diagram from the given string, with the\n   origin set to a point interpolated within the bounding box.  The\n   first parameter varies from 0 (left) to 1 (right), and the second\n   parameter from 0 (bottom) to 1 (top).\n\u003c/p\u003e\u003cp\u003eThe height of this box is determined by the font's potential ascent\n   and descent, rather than the height of the particular string.\n\u003c/p\u003e\u003cp\u003eNote that it \u003cem\u003etakes up no space\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Text\",\"Diagrams.TwoD\"]",
          "name": "alignedText",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Double -\u003e String -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Text.html#alignedText",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:alignedText\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:alignedText\"]"
        },
        "index": {
          "description": "Create primitive text diagram from the given string with the origin set to point interpolated within the bounding box The first parameter varies from left to right and the second parameter from bottom to top The height of this box is determined by the font potential ascent and descent rather than the height of the particular string Note that it takes up no space",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "alignedText",
          "normalized": "Double-\u003eDouble-\u003eString-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "Text",
          "signature": "Double-\u003eDouble-\u003eString-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:alignedText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a primitive text diagram from the given string, with the\n   origin set to be on the baseline, at the beginning (although not\n   bounding).  This is the reference point of showText in the Cairo\n   graphics library.\n\u003c/p\u003e\u003cp\u003eNote that it \u003cem\u003etakes up no space\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Text\",\"Diagrams.TwoD\"]",
          "name": "baselineText",
          "package": "diagrams-lib",
          "signature": "String -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Text.html#baselineText",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:baselineText\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:baselineText\"]"
        },
        "index": {
          "description": "Create primitive text diagram from the given string with the origin set to be on the baseline at the beginning although not bounding This is the reference point of showText in the Cairo graphics library Note that it takes up no space",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "baselineText",
          "normalized": "String-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "Text",
          "signature": "String-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:baselineText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet all text using a bold font weight.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Text\",\"Diagrams.TwoD\"]",
          "name": "bold",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Text.html#bold",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:bold\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:bold\"]"
        },
        "index": {
          "description": "Set all text using bold font weight",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "bold",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:bold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify a font family to be used for all text within a diagram.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Text\",\"Diagrams.TwoD\"]",
          "name": "font",
          "package": "diagrams-lib",
          "signature": "String -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Text.html#font",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:font\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:font\"]"
        },
        "index": {
          "description": "Specify font family to be used for all text within diagram",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "font",
          "normalized": "String-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "String-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:font"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the font size, that is, the size of the font's em-square as\n   measured within the current local vector space.  The default size\n   is \u003ccode\u003e1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Text\",\"Diagrams.TwoD\"]",
          "name": "fontSize",
          "package": "diagrams-lib",
          "signature": "Double -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Text.html#fontSize",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:fontSize\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:fontSize\"]"
        },
        "index": {
          "description": "Set the font size that is the size of the font em-square as measured within the current local vector space The default size is",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "fontSize",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Size",
          "signature": "Double-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:fontSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a \u003ccode\u003e\u003ca\u003eFontSize\u003c/a\u003e\u003c/code\u003e attribute.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Text",
          "name": "fontSizeA",
          "package": "diagrams-lib",
          "signature": "FontSize -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Text.html#fontSizeA",
          "type": "function"
        },
        "index": {
          "description": "Apply FontSize attribute",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "fontSizeA",
          "normalized": "FontSize-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Size",
          "signature": "FontSize-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:fontSizeA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify the slant (normal, italic, or oblique) that should be\n   used for all text within a diagram.  See also \u003ccode\u003e\u003ca\u003eitalic\u003c/a\u003e\u003c/code\u003e and\n   \u003ccode\u003e\u003ca\u003eoblique\u003c/a\u003e\u003c/code\u003e for useful special cases.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Text",
          "name": "fontSlant",
          "package": "diagrams-lib",
          "signature": "FontSlant -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Text.html#fontSlant",
          "type": "function"
        },
        "index": {
          "description": "Specify the slant normal italic or oblique that should be used for all text within diagram See also italic and oblique for useful special cases",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "fontSlant",
          "normalized": "FontSlant-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Slant",
          "signature": "FontSlant-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:fontSlant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify the weight (normal or bold) that should be\n   used for all text within a diagram.  See also \u003ccode\u003e\u003ca\u003ebold\u003c/a\u003e\u003c/code\u003e\n   for a useful special case.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Text",
          "name": "fontWeight",
          "package": "diagrams-lib",
          "signature": "FontWeight -\u003e a -\u003e a",
          "source": "src/Diagrams-TwoD-Text.html#fontWeight",
          "type": "function"
        },
        "index": {
          "description": "Specify the weight normal or bold that should be used for all text within diagram See also bold for useful special case",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "fontWeight",
          "normalized": "FontWeight-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "Weight",
          "signature": "FontWeight-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:fontWeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the font family name from a \u003ccode\u003eFont\u003c/code\u003e attribute.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Text",
          "name": "getFont",
          "package": "diagrams-lib",
          "signature": "Font -\u003e String",
          "source": "src/Diagrams-TwoD-Text.html#getFont",
          "type": "function"
        },
        "index": {
          "description": "Extract the font family name from Font attribute",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "getFont",
          "normalized": "Font-\u003eString",
          "package": "diagrams-lib",
          "partial": "Font",
          "signature": "Font-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:getFont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the size from a \u003ccode\u003eFontSize\u003c/code\u003e attribute.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Text",
          "name": "getFontSize",
          "package": "diagrams-lib",
          "signature": "FontSize -\u003e Double",
          "source": "src/Diagrams-TwoD-Text.html#getFontSize",
          "type": "function"
        },
        "index": {
          "description": "Extract the size from FontSize attribute",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "getFontSize",
          "normalized": "FontSize-\u003eDouble",
          "package": "diagrams-lib",
          "partial": "Font Size",
          "signature": "FontSize-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:getFontSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the font slant from a \u003ccode\u003e\u003ca\u003eFontSlantA\u003c/a\u003e\u003c/code\u003e attribute.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Text",
          "name": "getFontSlant",
          "package": "diagrams-lib",
          "signature": "FontSlantA -\u003e FontSlant",
          "source": "src/Diagrams-TwoD-Text.html#getFontSlant",
          "type": "function"
        },
        "index": {
          "description": "Extract the font slant from FontSlantA attribute",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "getFontSlant",
          "normalized": "FontSlantA-\u003eFontSlant",
          "package": "diagrams-lib",
          "partial": "Font Slant",
          "signature": "FontSlantA-\u003eFontSlant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:getFontSlant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the font weight from a \u003ccode\u003e\u003ca\u003eFontWeightA\u003c/a\u003e\u003c/code\u003e attribute.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Text",
          "name": "getFontWeight",
          "package": "diagrams-lib",
          "signature": "FontWeightA -\u003e FontWeight",
          "source": "src/Diagrams-TwoD-Text.html#getFontWeight",
          "type": "function"
        },
        "index": {
          "description": "Extract the font weight from FontWeightA attribute",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "getFontWeight",
          "normalized": "FontWeightA-\u003eFontWeight",
          "package": "diagrams-lib",
          "partial": "Font Weight",
          "signature": "FontWeightA-\u003eFontWeight",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:getFontWeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet all text in italics.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Text\",\"Diagrams.TwoD\"]",
          "name": "italic",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Text.html#italic",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:italic\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:italic\"]"
        },
        "index": {
          "description": "Set all text in italics",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "italic",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:italic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet all text using an oblique slant.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Text\",\"Diagrams.TwoD\"]",
          "name": "oblique",
          "package": "diagrams-lib",
          "signature": "a -\u003e a",
          "source": "src/Diagrams-TwoD-Text.html#oblique",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:oblique\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:oblique\"]"
        },
        "index": {
          "description": "Set all text using an oblique slant",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "oblique",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:oblique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a primitive text diagram from the given string, with center\n   alignment, equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003ealignedText\u003c/a\u003e\u003c/code\u003e 0.5 0.5\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that it \u003cem\u003etakes up no space\u003c/em\u003e, as text size information is not\n   available.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Text\",\"Diagrams.TwoD\"]",
          "name": "text",
          "package": "diagrams-lib",
          "signature": "String -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Text.html#text",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:text\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:text\"]"
        },
        "index": {
          "description": "Create primitive text diagram from the given string with center alignment equivalent to alignedText Note that it takes up no space as text size information is not available",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "text",
          "normalized": "String-\u003eDiagram a R",
          "package": "diagrams-lib",
          "signature": "String-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a primitive text diagram from the given string, origin at\n   the top left corner of the text's bounding box, equivalent to\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003ealignedText\u003c/a\u003e\u003c/code\u003e 0 1\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that it \u003cem\u003etakes up no space\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Text\",\"Diagrams.TwoD\"]",
          "name": "topLeftText",
          "package": "diagrams-lib",
          "signature": "String -\u003e Diagram b R2",
          "source": "src/Diagrams-TwoD-Text.html#topLeftText",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:topLeftText\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:topLeftText\"]"
        },
        "index": {
          "description": "Create primitive text diagram from the given string origin at the top left corner of the text bounding box equivalent to alignedText Note that it takes up no space",
          "hierarchy": "Diagrams TwoD Text",
          "module": "Diagrams.TwoD.Text",
          "name": "topLeftText",
          "normalized": "String-\u003eDiagram a R",
          "package": "diagrams-lib",
          "partial": "Left Text",
          "signature": "String-\u003eDiagram b R",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Text.html#v:topLeftText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eWrapper for creating scale-invariant objects in two dimensions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "ScaleInv",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Transform-ScaleInv.html",
          "type": "module"
        },
        "index": {
          "description": "Wrapper for creating scale-invariant objects in two dimensions",
          "hierarchy": "Diagrams TwoD Transform ScaleInv",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "ScaleInv",
          "package": "diagrams-lib",
          "partial": "Scale Inv",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform-ScaleInv.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003eScaleInv\u003c/code\u003e wrapper creates two-dimensional \u003cem\u003escale-invariant\u003c/em\u003e\n   objects.  Intuitively, a scale-invariant object is affected by\n   transformations like translations and rotations, but not by scales.\n\u003c/p\u003e\u003cp\u003eHowever, this is problematic when it comes to \u003cem\u003enon-uniform\u003c/em\u003e\n   scales (\u003cem\u003ee.g.\u003c/em\u003e \u003ccode\u003escaleX 2 . scaleY 3\u003c/code\u003e) since they can introduce a\n   perceived rotational component.  The prototypical example is an\n   arrowhead on the end of a path, which should be scale-invariant.\n   However, applying a non-uniform scale to the path but not the\n   arrowhead would leave the arrowhead pointing in the wrong\n   direction.\n\u003c/p\u003e\u003cp\u003eMoreover, for objects whose local origin is not at the local\n   origin of the parent diagram, any scale can result in a\n   translational component as well.\n\u003c/p\u003e\u003cp\u003eThe solution is to also store a point (indicating the location,\n   \u003cem\u003ei.e.\u003c/em\u003e the local origin) and a unit vector (indicating the\n   \u003cem\u003edirection\u003c/em\u003e) along with a scale-invariant object.  A\n   transformation to be applied is decomposed into rotational and\n   translational components as follows:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The transformation is applied to the direction vector, and the\n   difference in angle between the original direction vector and its\n   image under the transformation determines the rotational\n   component.  The rotation is applied with respect to the stored\n   location, rather than the global origin.\n\u003c/li\u003e\u003cli\u003e The vector from the location to the image of the location under\n   the transformation determines the translational component.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "ScaleInv",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Transform-ScaleInv.html#ScaleInv",
          "type": "data"
        },
        "index": {
          "description": "The ScaleInv wrapper creates two-dimensional scale-invariant objects Intuitively scale-invariant object is affected by transformations like translations and rotations but not by scales However this is problematic when it comes to non-uniform scales e.g scaleX scaleY since they can introduce perceived rotational component The prototypical example is an arrowhead on the end of path which should be scale-invariant However applying non-uniform scale to the path but not the arrowhead would leave the arrowhead pointing in the wrong direction Moreover for objects whose local origin is not at the local origin of the parent diagram any scale can result in translational component as well The solution is to also store point indicating the location i.e the local origin and unit vector indicating the direction along with scale-invariant object transformation to be applied is decomposed into rotational and translational components as follows The transformation is applied to the direction vector and the difference in angle between the original direction vector and its image under the transformation determines the rotational component The rotation is applied with respect to the stored location rather than the global origin The vector from the location to the image of the location under the transformation determines the translational component",
          "hierarchy": "Diagrams TwoD Transform ScaleInv",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "ScaleInv",
          "package": "diagrams-lib",
          "partial": "Scale Inv",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform-ScaleInv.html#t:ScaleInv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "ScaleInv",
          "package": "diagrams-lib",
          "signature": "ScaleInv",
          "source": "src/Diagrams-TwoD-Transform-ScaleInv.html#ScaleInv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Transform ScaleInv",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "ScaleInv",
          "package": "diagrams-lib",
          "partial": "Scale Inv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform-ScaleInv.html#v:ScaleInv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "_scaleInvDir",
          "package": "diagrams-lib",
          "signature": "R2",
          "source": "src/Diagrams-TwoD-Transform-ScaleInv.html#ScaleInv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Transform ScaleInv",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "_scaleInvDir",
          "package": "diagrams-lib",
          "partial": "Inv Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform-ScaleInv.html#v:_scaleInvDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "_scaleInvLoc",
          "package": "diagrams-lib",
          "signature": "P2",
          "source": "src/Diagrams-TwoD-Transform-ScaleInv.html#ScaleInv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Transform ScaleInv",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "_scaleInvLoc",
          "package": "diagrams-lib",
          "partial": "Inv Loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform-ScaleInv.html#v:_scaleInvLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "_scaleInvObj",
          "package": "diagrams-lib",
          "signature": "t",
          "source": "src/Diagrams-TwoD-Transform-ScaleInv.html#ScaleInv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Transform ScaleInv",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "_scaleInvObj",
          "package": "diagrams-lib",
          "partial": "Inv Obj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform-ScaleInv.html#v:_scaleInvObj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a scale-invariant object pointing in the given direction,\n   located at the origin.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "scaleInv",
          "package": "diagrams-lib",
          "signature": "t -\u003e R2 -\u003e ScaleInv t",
          "source": "src/Diagrams-TwoD-Transform-ScaleInv.html#scaleInv",
          "type": "function"
        },
        "index": {
          "description": "Create scale-invariant object pointing in the given direction located at the origin",
          "hierarchy": "Diagrams TwoD Transform ScaleInv",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "scaleInv",
          "normalized": "a-\u003eR-\u003eScaleInv a",
          "package": "diagrams-lib",
          "partial": "Inv",
          "signature": "t-\u003eR-\u003eScaleInv t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform-ScaleInv.html#v:scaleInv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "scaleInvDir",
          "package": "diagrams-lib",
          "signature": "forall t.  Lens' (ScaleInv t) R2",
          "source": "src/Diagrams-TwoD-Transform-ScaleInv.html#scaleInvDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Transform ScaleInv",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "scaleInvDir",
          "package": "diagrams-lib",
          "partial": "Inv Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform-ScaleInv.html#v:scaleInvDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "scaleInvLoc",
          "package": "diagrams-lib",
          "signature": "forall t.  Lens' (ScaleInv t) P2",
          "source": "src/Diagrams-TwoD-Transform-ScaleInv.html#scaleInvLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Transform ScaleInv",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "scaleInvLoc",
          "package": "diagrams-lib",
          "partial": "Inv Loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform-ScaleInv.html#v:scaleInvLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "scaleInvObj",
          "package": "diagrams-lib",
          "signature": "forall t t.  Lens (ScaleInv t) (ScaleInv t) t t",
          "source": "src/Diagrams-TwoD-Transform-ScaleInv.html#scaleInvObj",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Transform ScaleInv",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "scaleInvObj",
          "package": "diagrams-lib",
          "partial": "Inv Obj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform-ScaleInv.html#v:scaleInvObj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a diagram from a single scale-invariant primitive.  The\n   vector argument specifies the direction in which the primitive is\n   \"pointing\" (for the purpose of keeping it rotated correctly\n   under non-uniform scaling).  The primitive is assumed to be\n   \"located\" at the origin (for the purpose of translating it\n   correctly under scaling).\n\u003c/p\u003e\u003cp\u003eNote that the resulting diagram will have an \u003cem\u003eempty\u003c/em\u003e envelope,\n   trace, and query.  The reason is that the envelope, trace, and\n   query cannot be cached---applying a transformation would cause\n   the cached envelope, etc. to get \"out of sync\" with the\n   scale-invariant object.  The intention, at any rate, is that\n   scale-invariant things will be used only as \"decorations\" (\u003cem\u003ee.g.\u003c/em\u003e\n   arrowheads) which should not affect the envelope, trace, and\n   query.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "scaleInvPrim",
          "package": "diagrams-lib",
          "signature": "t -\u003e R2 -\u003e QDiagram b R2 m",
          "source": "src/Diagrams-TwoD-Transform-ScaleInv.html#scaleInvPrim",
          "type": "function"
        },
        "index": {
          "description": "Create diagram from single scale-invariant primitive The vector argument specifies the direction in which the primitive is pointing for the purpose of keeping it rotated correctly under non-uniform scaling The primitive is assumed to be located at the origin for the purpose of translating it correctly under scaling Note that the resulting diagram will have an empty envelope trace and query The reason is that the envelope trace and query cannot be cached---applying transformation would cause the cached envelope etc to get out of sync with the scale-invariant object The intention at any rate is that scale-invariant things will be used only as decorations e.g arrowheads which should not affect the envelope trace and query",
          "hierarchy": "Diagrams TwoD Transform ScaleInv",
          "module": "Diagrams.TwoD.Transform.ScaleInv",
          "name": "scaleInvPrim",
          "normalized": "a-\u003eR-\u003eQDiagram b R c",
          "package": "diagrams-lib",
          "partial": "Inv Prim",
          "signature": "t-\u003eR-\u003eQDiagram b R m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform-ScaleInv.html#v:scaleInvPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTransformations specific to two dimensions, with a few generic\n transformations (uniform scaling, translation) also re-exported for\n convenience.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Transform",
          "name": "Transform",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Transform.html",
          "type": "module"
        },
        "index": {
          "description": "Transformations specific to two dimensions with few generic transformations uniform scaling translation also re-exported for convenience",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "Transform",
          "package": "diagrams-lib",
          "partial": "Transform",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the \"average\" amount of scaling performed by a\n   transformation.  Satisfies the properties\n\u003c/p\u003e\u003cpre\u003e\n   avgScale (scaling k) == k\n   avgScale (t1 \u003ca/\u003e t2)  == avgScale t1 * avgScale t2\n\u003c/pre\u003e\u003cp\u003eBackends which do not support stroking in the context of an\n   arbitrary transformation may instead call \u003ccode\u003e\u003ca\u003eavgScale\u003c/a\u003e\u003c/code\u003e on\n   \"frozen\" transformations and multiply the line width by the\n   resulting value.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Transform",
          "name": "avgScale",
          "package": "diagrams-lib",
          "signature": "T2 -\u003e Double",
          "source": "src/Diagrams-TwoD-Transform.html#avgScale",
          "type": "function"
        },
        "index": {
          "description": "Compute the average amount of scaling performed by transformation Satisfies the properties avgScale scaling avgScale t1 t2 avgScale t1 avgScale t2 Backends which do not support stroking in the context of an arbitrary transformation may instead call avgScale on frozen transformations and multiply the line width by the resulting value",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "avgScale",
          "normalized": "T-\u003eDouble",
          "package": "diagrams-lib",
          "partial": "Scale",
          "signature": "T-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:avgScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the matrix equivalent of the linear transform,\n   (as a pair of columns) and the translation vector.  This\n   is mostly useful for implementing backends.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Transform",
          "name": "onBasis",
          "package": "diagrams-lib",
          "signature": "Transformation R2 -\u003e ((R2, R2), R2)",
          "source": "src/Diagrams-TwoD-Transform.html#onBasis",
          "type": "function"
        },
        "index": {
          "description": "Get the matrix equivalent of the linear transform as pair of columns and the translation vector This is mostly useful for implementing backends",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "onBasis",
          "normalized": "Transformation R-\u003e((R,R),R)",
          "package": "diagrams-lib",
          "partial": "Basis",
          "signature": "Transformation R-\u003e((R,R),R)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:onBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ereflectAbout p v\u003c/code\u003e reflects a diagram in the line determined by\n   the point \u003ccode\u003ep\u003c/code\u003e and the vector \u003ccode\u003ev\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "reflectAbout",
          "package": "diagrams-lib",
          "signature": "P2 -\u003e R2 -\u003e t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#reflectAbout",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:reflectAbout\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:reflectAbout\"]"
        },
        "index": {
          "description": "reflectAbout reflects diagram in the line determined by the point and the vector",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "reflectAbout",
          "normalized": "P-\u003eR-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "About",
          "signature": "P-\u003eR-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:reflectAbout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlip a diagram from left to right, i.e. send the point (x,y) to\n   (-x,y).\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "reflectX",
          "package": "diagrams-lib",
          "signature": "t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#reflectX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:reflectX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:reflectX\"]"
        },
        "index": {
          "description": "Flip diagram from left to right i.e send the point to",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "reflectX",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:reflectX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlip a diagram from top to bottom, i.e. send the point (x,y) to\n   (x,-y).\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "reflectY",
          "package": "diagrams-lib",
          "signature": "t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#reflectY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:reflectY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:reflectY\"]"
        },
        "index": {
          "description": "Flip diagram from top to bottom i.e send the point to",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "reflectY",
          "normalized": "a-\u003ea",
          "package": "diagrams-lib",
          "signature": "t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:reflectY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ereflectionAbout p v\u003c/code\u003e is a reflection in the line determined by\n   the point \u003ccode\u003ep\u003c/code\u003e and vector \u003ccode\u003ev\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "reflectionAbout",
          "package": "diagrams-lib",
          "signature": "P2 -\u003e R2 -\u003e T2",
          "source": "src/Diagrams-TwoD-Transform.html#reflectionAbout",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:reflectionAbout\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:reflectionAbout\"]"
        },
        "index": {
          "description": "reflectionAbout is reflection in the line determined by the point and vector",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "reflectionAbout",
          "normalized": "P-\u003eR-\u003eT",
          "package": "diagrams-lib",
          "partial": "About",
          "signature": "P-\u003eR-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:reflectionAbout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a transformation which flips a diagram from left to\n   right, i.e. sends the point (x,y) to (-x,y).\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "reflectionX",
          "package": "diagrams-lib",
          "signature": "T2",
          "source": "src/Diagrams-TwoD-Transform.html#reflectionX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:reflectionX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:reflectionX\"]"
        },
        "index": {
          "description": "Construct transformation which flips diagram from left to right i.e sends the point to",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "reflectionX",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:reflectionX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a transformation which flips a diagram from top to\n   bottom, i.e. sends the point (x,y) to (x,-y).\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "reflectionY",
          "package": "diagrams-lib",
          "signature": "T2",
          "source": "src/Diagrams-TwoD-Transform.html#reflectionY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:reflectionY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:reflectionY\"]"
        },
        "index": {
          "description": "Construct transformation which flips diagram from top to bottom i.e sends the point to",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "reflectionY",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:reflectionY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotate about the local origin by the given angle. Positive angles\n   correspond to counterclockwise rotation, negative to\n   clockwise. The angle can be expressed using any type which is an\n   instance of \u003ccode\u003e\u003ca\u003eAngle\u003c/a\u003e\u003c/code\u003e.  For example, \u003ccode\u003erotate (1/4 ::\n   \u003ccode\u003e\u003ca\u003eTurn\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e, \u003ccode\u003erotate (tau/4 :: \u003ccode\u003e\u003ca\u003eRad\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e, and \u003ccode\u003erotate (90 ::\n   \u003ccode\u003e\u003ca\u003eDeg\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e all represent the same transformation, namely, a\n   counterclockwise rotation by a right angle.  To rotate about some\n   point other than the local origin, see \u003ccode\u003e\u003ca\u003erotateAbout\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that writing \u003ccode\u003erotate (1/4)\u003c/code\u003e, with no type annotation, will\n   yield an error since GHC cannot figure out which sort of angle\n   you want to use.  In this common situation you can use\n   \u003ccode\u003e\u003ca\u003erotateBy\u003c/a\u003e\u003c/code\u003e, which is specialized to take a \u003ccode\u003e\u003ca\u003eTurn\u003c/a\u003e\u003c/code\u003e argument.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "rotate",
          "package": "diagrams-lib",
          "signature": "a -\u003e t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#rotate",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:rotate\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:rotate\"]"
        },
        "index": {
          "description": "Rotate about the local origin by the given angle Positive angles correspond to counterclockwise rotation negative to clockwise The angle can be expressed using any type which is an instance of Angle For example rotate Turn rotate tau Rad and rotate Deg all represent the same transformation namely counterclockwise rotation by right angle To rotate about some point other than the local origin see rotateAbout Note that writing rotate with no type annotation will yield an error since GHC cannot figure out which sort of angle you want to use In this common situation you can use rotateBy which is specialized to take Turn argument",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "rotate",
          "normalized": "a-\u003eb-\u003eb",
          "package": "diagrams-lib",
          "signature": "a-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:rotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erotateAbout p\u003c/code\u003e is like \u003ccode\u003e\u003ca\u003erotate\u003c/a\u003e\u003c/code\u003e, except it rotates around the\n   point \u003ccode\u003ep\u003c/code\u003e instead of around the local origin.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "rotateAbout",
          "package": "diagrams-lib",
          "signature": "P2 -\u003e a -\u003e t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#rotateAbout",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:rotateAbout\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:rotateAbout\"]"
        },
        "index": {
          "description": "rotateAbout is like rotate except it rotates around the point instead of around the local origin",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "rotateAbout",
          "normalized": "P-\u003ea-\u003eb-\u003eb",
          "package": "diagrams-lib",
          "partial": "About",
          "signature": "P-\u003ea-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:rotateAbout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003erotate\u003c/a\u003e\u003c/code\u003e, specialized to only work with\n   \u003ccode\u003eTurn\u003c/code\u003e arguments; it can be more convenient to write\n   \u003ccode\u003erotateBy (1/4)\u003c/code\u003e than \u003ccode\u003e\u003ccode\u003e\u003ca\u003erotate\u003c/a\u003e\u003c/code\u003e (1/4 :: \u003ccode\u003e\u003ca\u003eTurn\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "rotateBy",
          "package": "diagrams-lib",
          "signature": "Turn -\u003e t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#rotateBy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:rotateBy\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:rotateBy\"]"
        },
        "index": {
          "description": "synonym for rotate specialized to only work with Turn arguments it can be more convenient to write rotateBy than rotate Turn",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "rotateBy",
          "normalized": "Turn-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "By",
          "signature": "Turn-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:rotateBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a transformation which performs a rotation about the local\n   origin by the given angle.  See also \u003ccode\u003e\u003ca\u003erotate\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "rotation",
          "package": "diagrams-lib",
          "signature": "a -\u003e T2",
          "source": "src/Diagrams-TwoD-Transform.html#rotation",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:rotation\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:rotation\"]"
        },
        "index": {
          "description": "Create transformation which performs rotation about the local origin by the given angle See also rotate",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "rotation",
          "normalized": "a-\u003eT",
          "package": "diagrams-lib",
          "signature": "a-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:rotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erotationAbout p\u003c/code\u003e is a rotation about the point \u003ccode\u003ep\u003c/code\u003e (instead of\n   around the local origin).\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "rotationAbout",
          "package": "diagrams-lib",
          "signature": "P2 -\u003e a -\u003e T2",
          "source": "src/Diagrams-TwoD-Transform.html#rotationAbout",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:rotationAbout\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:rotationAbout\"]"
        },
        "index": {
          "description": "rotationAbout is rotation about the point instead of around the local origin",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "rotationAbout",
          "normalized": "P-\u003ea-\u003eT",
          "package": "diagrams-lib",
          "partial": "About",
          "signature": "P-\u003ea-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:rotationAbout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003escaleToX w\u003c/code\u003e scales a diagram in the x (horizontal) direction by\n   whatever factor required to make its width \u003ccode\u003ew\u003c/code\u003e.  \u003ccode\u003escaleToX\u003c/code\u003e\n   should not be applied to diagrams with a width of 0, such as\n   \u003ccode\u003evrule\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "scaleToX",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#scaleToX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scaleToX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:scaleToX\"]"
        },
        "index": {
          "description": "scaleToX scales diagram in the horizontal direction by whatever factor required to make its width scaleToX should not be applied to diagrams with width of such as vrule",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "scaleToX",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "To",
          "signature": "Double-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scaleToX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003escaleToY h\u003c/code\u003e scales a diagram in the y (vertical) direction by\n   whatever factor required to make its height \u003ccode\u003eh\u003c/code\u003e.  \u003ccode\u003escaleToY\u003c/code\u003e\n   should not be applied to diagrams with a height of 0, such as\n   \u003ccode\u003ehrule\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "scaleToY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#scaleToY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scaleToY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:scaleToY\"]"
        },
        "index": {
          "description": "scaleToY scales diagram in the vertical direction by whatever factor required to make its height scaleToY should not be applied to diagrams with height of such as hrule",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "scaleToY",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "To",
          "signature": "Double-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scaleToY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003escaleUToX w\u003c/code\u003e scales a diagram \u003cem\u003euniformly\u003c/em\u003e by whatever factor\n   required to make its width \u003ccode\u003ew\u003c/code\u003e.  \u003ccode\u003escaleUToX\u003c/code\u003e should not be\n   applied to diagrams with a width of 0, such as \u003ccode\u003evrule\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "scaleUToX",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#scaleUToX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scaleUToX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:scaleUToX\"]"
        },
        "index": {
          "description": "scaleUToX scales diagram uniformly by whatever factor required to make its width scaleUToX should not be applied to diagrams with width of such as vrule",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "scaleUToX",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "UTo",
          "signature": "Double-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scaleUToX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003escaleUToY h\u003c/code\u003e scales a diagram \u003cem\u003euniformly\u003c/em\u003e by whatever factor\n   required to make its height \u003ccode\u003eh\u003c/code\u003e.  \u003ccode\u003escaleUToY\u003c/code\u003e should not be applied\n   to diagrams with a height of 0, such as \u003ccode\u003ehrule\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "scaleUToY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#scaleUToY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scaleUToY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:scaleUToY\"]"
        },
        "index": {
          "description": "scaleUToY scales diagram uniformly by whatever factor required to make its height scaleUToY should not be applied to diagrams with height of such as hrule",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "scaleUToY",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "UTo",
          "signature": "Double-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scaleUToY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale a diagram by the given factor in the x (horizontal)\n   direction.  To scale uniformly, use \u003ccode\u003e\u003ca\u003escale\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "scaleX",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#scaleX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scaleX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:scaleX\"]"
        },
        "index": {
          "description": "Scale diagram by the given factor in the horizontal direction To scale uniformly use scale",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "scaleX",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scaleX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale a diagram by the given factor in the y (vertical)\n   direction.  To scale uniformly, use \u003ccode\u003e\u003ca\u003escale\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "scaleY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#scaleY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scaleY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:scaleY\"]"
        },
        "index": {
          "description": "Scale diagram by the given factor in the vertical direction To scale uniformly use scale",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "scaleY",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scaleY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a transformation which scales by the given factor in\n   the x (horizontal) direction.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "scalingX",
          "package": "diagrams-lib",
          "signature": "Double -\u003e T2",
          "source": "src/Diagrams-TwoD-Transform.html#scalingX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scalingX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:scalingX\"]"
        },
        "index": {
          "description": "Construct transformation which scales by the given factor in the horizontal direction",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "scalingX",
          "normalized": "Double-\u003eT",
          "package": "diagrams-lib",
          "signature": "Double-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scalingX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a transformation which scales by the given factor in\n   the y (vertical) direction.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "scalingY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e T2",
          "source": "src/Diagrams-TwoD-Transform.html#scalingY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scalingY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:scalingY\"]"
        },
        "index": {
          "description": "Construct transformation which scales by the given factor in the vertical direction",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "scalingY",
          "normalized": "Double-\u003eT",
          "package": "diagrams-lib",
          "signature": "Double-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:scalingY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eshearX d\u003c/code\u003e performs a shear in the x-direction which sends\n   \u003ccode\u003e(0,1)\u003c/code\u003e to \u003ccode\u003e(d,1)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "shearX",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#shearX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:shearX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:shearX\"]"
        },
        "index": {
          "description": "shearX performs shear in the x-direction which sends to",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "shearX",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:shearX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eshearY d\u003c/code\u003e performs a shear in the y-direction which sends\n   \u003ccode\u003e(1,0)\u003c/code\u003e to \u003ccode\u003e(1,d)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "shearY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#shearY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:shearY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:shearY\"]"
        },
        "index": {
          "description": "shearY performs shear in the y-direction which sends to",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "shearY",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:shearY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eshearingX d\u003c/code\u003e is the linear transformation which is the identity on\n   y coordinates and sends \u003ccode\u003e(0,1)\u003c/code\u003e to \u003ccode\u003e(d,1)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "shearingX",
          "package": "diagrams-lib",
          "signature": "Double -\u003e T2",
          "source": "src/Diagrams-TwoD-Transform.html#shearingX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:shearingX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:shearingX\"]"
        },
        "index": {
          "description": "shearingX is the linear transformation which is the identity on coordinates and sends to",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "shearingX",
          "normalized": "Double-\u003eT",
          "package": "diagrams-lib",
          "signature": "Double-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:shearingX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eshearingY d\u003c/code\u003e is the linear transformation which is the identity on\n   x coordinates and sends \u003ccode\u003e(1,0)\u003c/code\u003e to \u003ccode\u003e(1,d)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "shearingY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e T2",
          "source": "src/Diagrams-TwoD-Transform.html#shearingY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:shearingY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:shearingY\"]"
        },
        "index": {
          "description": "shearingY is the linear transformation which is the identity on coordinates and sends to",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "shearingY",
          "normalized": "Double-\u003eT",
          "package": "diagrams-lib",
          "signature": "Double-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:shearingY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslate a diagram by the given distance in the x (horizontal)\n   direction.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "translateX",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#translateX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:translateX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:translateX\"]"
        },
        "index": {
          "description": "Translate diagram by the given distance in the horizontal direction",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "translateX",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:translateX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslate a diagram by the given distance in the y (vertical)\n   direction.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "translateY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e t -\u003e t",
          "source": "src/Diagrams-TwoD-Transform.html#translateY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:translateY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:translateY\"]"
        },
        "index": {
          "description": "Translate diagram by the given distance in the vertical direction",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "translateY",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "signature": "Double-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:translateY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a transformation which translates by the given distance\n   in the x (horizontal) direction.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "translationX",
          "package": "diagrams-lib",
          "signature": "Double -\u003e T2",
          "source": "src/Diagrams-TwoD-Transform.html#translationX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:translationX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:translationX\"]"
        },
        "index": {
          "description": "Construct transformation which translates by the given distance in the horizontal direction",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "translationX",
          "normalized": "Double-\u003eT",
          "package": "diagrams-lib",
          "signature": "Double-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:translationX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a transformation which translates by the given distance\n   in the y (vertical) direction.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Transform\",\"Diagrams.TwoD\"]",
          "name": "translationY",
          "package": "diagrams-lib",
          "signature": "Double -\u003e T2",
          "source": "src/Diagrams-TwoD-Transform.html#translationY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:translationY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:translationY\"]"
        },
        "index": {
          "description": "Construct transformation which translates by the given distance in the vertical direction",
          "hierarchy": "Diagrams TwoD Transform",
          "module": "Diagrams.TwoD.Transform",
          "name": "translationY",
          "normalized": "Double-\u003eT",
          "package": "diagrams-lib",
          "signature": "Double-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Transform.html#v:translationY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic types for two-dimensional Euclidean space.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Types",
          "name": "Types",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html",
          "type": "module"
        },
        "index": {
          "description": "Basic types for two-dimensional Euclidean space",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "Types",
          "package": "diagrams-lib",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class for types that measure angles.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Types",
          "name": "Angle",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#Angle",
          "type": "class"
        },
        "index": {
          "description": "Type class for types that measure angles",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "Angle",
          "package": "diagrams-lib",
          "partial": "Angle",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#t:Angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated synonym for \u003ccode\u003e\u003ca\u003eTurn\u003c/a\u003e\u003c/code\u003e, retained for backwards compatibility.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Types",
          "name": "CircleFrac",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#CircleFrac",
          "type": "type"
        },
        "index": {
          "description": "Deprecated synonym for Turn retained for backwards compatibility",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "CircleFrac",
          "package": "diagrams-lib",
          "partial": "Circle Frac",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#t:CircleFrac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNewtype wrapper for representing angles in degrees.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Types",
          "name": "Deg",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#Deg",
          "type": "newtype"
        },
        "index": {
          "description": "Newtype wrapper for representing angles in degrees",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "Deg",
          "package": "diagrams-lib",
          "partial": "Deg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#t:Deg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePoints in R^2.  This type is intentionally abstract.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e To construct a point, use \u003ccode\u003e\u003ca\u003ep2\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003e^&\u003c/a\u003e\u003c/code\u003e (see\n     \u003ca\u003eDiagrams.Coordinates\u003c/a\u003e):\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\n p2 (3,4)  :: P2\n 3 ^& 4    :: P2\n\u003c/pre\u003e\u003cul\u003e\u003cli\u003e To construct a point from a vector \u003ccode\u003ev\u003c/code\u003e, use \u003ccode\u003e\u003ccode\u003e\u003ca\u003eorigin\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.+^\u003c/a\u003e\u003c/code\u003e v\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e To convert a point \u003ccode\u003ep\u003c/code\u003e into the vector from the origin to \u003ccode\u003ep\u003c/code\u003e,\n   use \u003ccode\u003ep \u003ccode\u003e\u003ca\u003e.-.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eorigin\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e To convert a point back into a pair of coordinates, use \u003ccode\u003e\u003ca\u003eunp2\u003c/a\u003e\u003c/code\u003e,\n     or \u003ccode\u003e\u003ca\u003ecoords\u003c/a\u003e\u003c/code\u003e (from \u003ca\u003eDiagrams.Coordinates\u003c/a\u003e).  It's common to use\n     these in conjunction with the \u003ccode\u003eViewPatterns\u003c/code\u003e extension:\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\n foo (unp2 -\u003e (x,y)) = ...\n foo (coords -\u003e x :& y) = ...\n\u003c/pre\u003e",
          "module": "Diagrams.TwoD.Types",
          "name": "P2",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#P2",
          "type": "type"
        },
        "index": {
          "description": "Points in This type is intentionally abstract To construct point use p2 or see Diagrams.Coordinates p2 P2 P2 To construct point from vector use origin To convert point into the vector from the origin to use origin To convert point back into pair of coordinates use unp2 or coords from Diagrams.Coordinates It common to use these in conjunction with the ViewPatterns extension foo unp2 foo coords",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "P2",
          "package": "diagrams-lib",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#t:P2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe two-dimensional Euclidean vector space R^2.  This type is\n   intentionally abstract.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e To construct a vector, use \u003ccode\u003e\u003ca\u003er2\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003e^&\u003c/a\u003e\u003c/code\u003e (from \u003ca\u003eDiagrams.Coordinates\u003c/a\u003e):\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\n r2 (3,4) :: R2\n 3 ^& 4    :: R2\n\u003c/pre\u003e\u003cp\u003eNote that \u003ca\u003eDiagrams.Coordinates\u003c/a\u003e is not re-exported by\n     \u003ca\u003eDiagrams.Prelude\u003c/a\u003e and must be explicitly imported.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e To construct the vector from the origin to a point \u003ccode\u003ep\u003c/code\u003e, use\n     \u003ccode\u003ep \u003ccode\u003e\u003ca\u003e.-.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eorigin\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e To convert a vector \u003ccode\u003ev\u003c/code\u003e into the point obtained by following\n     \u003ccode\u003ev\u003c/code\u003e from the origin, use \u003ccode\u003e\u003ccode\u003e\u003ca\u003eorigin\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.+^\u003c/a\u003e\u003c/code\u003e v\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e To convert a vector back into a pair of components, use \u003ccode\u003eunv2\u003c/code\u003e\n     or \u003ccode\u003e\u003ca\u003ecoords\u003c/a\u003e\u003c/code\u003e (from \u003ca\u003eDiagrams.Coordinates\u003c/a\u003e).  These are typically\n     used in conjunction with the \u003ccode\u003eViewPatterns\u003c/code\u003e extension:\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\n foo (unr2 -\u003e (x,y)) = ...\n foo (coords -\u003e x :& y) = ...\n\u003c/pre\u003e",
          "module": "Diagrams.TwoD.Types",
          "name": "R2",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#R2",
          "type": "data"
        },
        "index": {
          "description": "The two-dimensional Euclidean vector space This type is intentionally abstract To construct vector use r2 or from Diagrams.Coordinates r2 R2 R2 Note that Diagrams.Coordinates is not re-exported by Diagrams.Prelude and must be explicitly imported To construct the vector from the origin to point use origin To convert vector into the point obtained by following from the origin use origin To convert vector back into pair of components use unv2 or coords from Diagrams.Coordinates These are typically used in conjunction with the ViewPatterns extension foo unr2 foo coords",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "R2",
          "package": "diagrams-lib",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#t:R2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNewtype wrapper for representing angles in radians.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Types",
          "name": "Rad",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#Rad",
          "type": "newtype"
        },
        "index": {
          "description": "Newtype wrapper for representing angles in radians",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "Rad",
          "package": "diagrams-lib",
          "partial": "Rad",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#t:Rad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransformations in R^2.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Types",
          "name": "T2",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#T2",
          "type": "type"
        },
        "index": {
          "description": "Transformations in",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "T2",
          "package": "diagrams-lib",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#t:T2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNewtype wrapper used to represent angles as fractions of a\n   circle.  For example, 1/3 turn = tau/3 radians = 120 degrees.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Types",
          "name": "Turn",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#Turn",
          "type": "newtype"
        },
        "index": {
          "description": "Newtype wrapper used to represent angles as fractions of circle For example turn tau radians degrees",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "Turn",
          "package": "diagrams-lib",
          "partial": "Turn",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#t:Turn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Types",
          "name": "R2",
          "package": "diagrams-lib",
          "signature": "R2 !Double !Double",
          "source": "src/Diagrams-TwoD-Types.html#R2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "R2",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:R2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from a turn, \u003cem\u003ei.e.\u003c/em\u003e a fraction of a circle.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Types",
          "name": "fromTurn",
          "package": "diagrams-lib",
          "signature": "Turn -\u003e a",
          "source": "src/Diagrams-TwoD-Types.html#fromTurn",
          "type": "method"
        },
        "index": {
          "description": "Convert from turn i.e fraction of circle",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "fromTurn",
          "normalized": "Turn-\u003ea",
          "package": "diagrams-lib",
          "partial": "Turn",
          "signature": "Turn-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:fromTurn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated synonym for \u003ccode\u003e\u003ca\u003efullTurn\u003c/a\u003e\u003c/code\u003e, retained for backwards compatibility.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "fullCircle",
          "package": "diagrams-lib",
          "signature": "a",
          "source": "src/Diagrams-TwoD-Types.html#fullCircle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:fullCircle\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:fullCircle\"]"
        },
        "index": {
          "description": "Deprecated synonym for fullTurn retained for backwards compatibility",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "fullCircle",
          "package": "diagrams-lib",
          "partial": "Circle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:fullCircle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurried form of \u003ccode\u003e\u003ca\u003ep2\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "mkP2",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Double -\u003e P2",
          "source": "src/Diagrams-TwoD-Types.html#mkP2",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:mkP2\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:mkP2\"]"
        },
        "index": {
          "description": "Curried form of p2",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "mkP2",
          "normalized": "Double-\u003eDouble-\u003eP",
          "package": "diagrams-lib",
          "signature": "Double-\u003eDouble-\u003eP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:mkP2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurried form of \u003ccode\u003e\u003ca\u003er2\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "mkR2",
          "package": "diagrams-lib",
          "signature": "Double -\u003e Double -\u003e R2",
          "source": "src/Diagrams-TwoD-Types.html#mkR2",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:mkR2\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:mkR2\"]"
        },
        "index": {
          "description": "Curried form of r2",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "mkR2",
          "normalized": "Double-\u003eDouble-\u003eR",
          "package": "diagrams-lib",
          "signature": "Double-\u003eDouble-\u003eR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:mkR2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a 2D point from a pair of coordinates.  See also \u003ccode\u003e\u003ca\u003e^&\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "p2",
          "package": "diagrams-lib",
          "signature": "(Double, Double) -\u003e P2",
          "source": "src/Diagrams-TwoD-Types.html#p2",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:p2\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:p2\"]"
        },
        "index": {
          "description": "Construct point from pair of coordinates See also",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "p2",
          "normalized": "(Double,Double)-\u003eP",
          "package": "diagrams-lib",
          "signature": "(Double,Double)-\u003eP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:p2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Types",
          "name": "p2Iso",
          "package": "diagrams-lib",
          "signature": "Iso' P2 (Double, Double)",
          "source": "src/Diagrams-TwoD-Types.html#p2Iso",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "p2Iso",
          "normalized": "Iso' P(Double,Double)",
          "package": "diagrams-lib",
          "partial": "Iso",
          "signature": "Iso' P(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:p2Iso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a 2D vector from a pair of components.  See also \u003ccode\u003e&\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "r2",
          "package": "diagrams-lib",
          "signature": "(Double, Double) -\u003e R2",
          "source": "src/Diagrams-TwoD-Types.html#r2",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:r2\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:r2\"]"
        },
        "index": {
          "description": "Construct vector from pair of components See also",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "r2",
          "normalized": "(Double,Double)-\u003eR",
          "package": "diagrams-lib",
          "signature": "(Double,Double)-\u003eR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:r2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD.Types",
          "name": "r2Iso",
          "package": "diagrams-lib",
          "signature": "Iso' R2 (Double, Double)",
          "source": "src/Diagrams-TwoD-Types.html#r2Iso",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "r2Iso",
          "normalized": "Iso' R(Double,Double)",
          "package": "diagrams-lib",
          "partial": "Iso",
          "signature": "Iso' R(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:r2Iso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert to a turn, \u003cem\u003ei.e.\u003c/em\u003e a fraction of a circle.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Types",
          "name": "toTurn",
          "package": "diagrams-lib",
          "signature": "a -\u003e Turn",
          "source": "src/Diagrams-TwoD-Types.html#toTurn",
          "type": "method"
        },
        "index": {
          "description": "Convert to turn i.e fraction of circle",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "toTurn",
          "normalized": "a-\u003eTurn",
          "package": "diagrams-lib",
          "partial": "Turn",
          "signature": "a-\u003eTurn",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:toTurn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a 2D point back into a pair of coordinates.  See also \u003ccode\u003e\u003ca\u003ecoords\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "unp2",
          "package": "diagrams-lib",
          "signature": "P2 -\u003e (Double, Double)",
          "source": "src/Diagrams-TwoD-Types.html#unp2",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:unp2\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:unp2\"]"
        },
        "index": {
          "description": "Convert point back into pair of coordinates See also coords",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "unp2",
          "normalized": "P-\u003e(Double,Double)",
          "package": "diagrams-lib",
          "signature": "P-\u003e(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:unp2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a 2D vector back into a pair of components.  See also \u003ccode\u003e\u003ca\u003ecoords\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Types\",\"Diagrams.TwoD\"]",
          "name": "unr2",
          "package": "diagrams-lib",
          "signature": "R2 -\u003e (Double, Double)",
          "source": "src/Diagrams-TwoD-Types.html#unr2",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:unr2\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:unr2\"]"
        },
        "index": {
          "description": "Convert vector back into pair of components See also coords",
          "hierarchy": "Diagrams TwoD Types",
          "module": "Diagrams.TwoD.Types",
          "name": "unr2",
          "normalized": "R-\u003e(Double,Double)",
          "package": "diagrams-lib",
          "signature": "R-\u003e(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Types.html#v:unr2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTwo-dimensional vectors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD.Vector",
          "name": "Vector",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Vector.html",
          "type": "module"
        },
        "index": {
          "description": "Two-dimensional vectors",
          "hierarchy": "Diagrams TwoD Vector",
          "module": "Diagrams.TwoD.Vector",
          "name": "Vector",
          "package": "diagrams-lib",
          "partial": "Vector",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the counterclockwise angle from the first vector to the second.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Vector\",\"Diagrams.TwoD\"]",
          "name": "angleBetween",
          "package": "diagrams-lib",
          "signature": "R2 -\u003e R2 -\u003e a",
          "source": "src/Diagrams-TwoD-Vector.html#angleBetween",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:angleBetween\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:angleBetween\"]"
        },
        "index": {
          "description": "Compute the counterclockwise angle from the first vector to the second",
          "hierarchy": "Diagrams TwoD Vector",
          "module": "Diagrams.TwoD.Vector",
          "name": "angleBetween",
          "normalized": "R-\u003eR-\u003ea",
          "package": "diagrams-lib",
          "partial": "Between",
          "signature": "R-\u003eR-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:angleBetween"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the direction of a vector, measured counterclockwise from\n   the positive x-axis as a fraction of a full turn.  The zero\n   vector is arbitrarily assigned the direction 0.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Vector\",\"Diagrams.TwoD\"]",
          "name": "direction",
          "package": "diagrams-lib",
          "signature": "R2 -\u003e a",
          "source": "src/Diagrams-TwoD-Vector.html#direction",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:direction\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:direction\"]"
        },
        "index": {
          "description": "Compute the direction of vector measured counterclockwise from the positive x-axis as fraction of full turn The zero vector is arbitrarily assigned the direction",
          "hierarchy": "Diagrams TwoD Vector",
          "module": "Diagrams.TwoD.Vector",
          "name": "direction",
          "normalized": "R-\u003ea",
          "package": "diagrams-lib",
          "signature": "R-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:direction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenient synonym for \u003ccode\u003e\u003ca\u003efromDirection\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Vector",
          "name": "e",
          "package": "diagrams-lib",
          "signature": "a -\u003e R2",
          "source": "src/Diagrams-TwoD-Vector.html#e",
          "type": "function"
        },
        "index": {
          "description": "convenient synonym for fromDirection",
          "hierarchy": "Diagrams TwoD Vector",
          "module": "Diagrams.TwoD.Vector",
          "name": "e",
          "normalized": "a-\u003eR",
          "package": "diagrams-lib",
          "signature": "a-\u003eR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:e"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an angle into a unit vector pointing in that direction.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Vector\",\"Diagrams.TwoD\"]",
          "name": "fromDirection",
          "package": "diagrams-lib",
          "signature": "a -\u003e R2",
          "source": "src/Diagrams-TwoD-Vector.html#fromDirection",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:fromDirection\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:fromDirection\"]"
        },
        "index": {
          "description": "Convert an angle into unit vector pointing in that direction",
          "hierarchy": "Diagrams TwoD Vector",
          "module": "Diagrams.TwoD.Vector",
          "name": "fromDirection",
          "normalized": "a-\u003eR",
          "package": "diagrams-lib",
          "partial": "Direction",
          "signature": "a-\u003eR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:fromDirection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eleftTurn v1 v2\u003c/code\u003e tests whether the direction of \u003ccode\u003ev2\u003c/code\u003e is a left\n   turn from \u003ccode\u003ev1\u003c/code\u003e (that is, if the direction of \u003ccode\u003ev2\u003c/code\u003e can be obtained\n   from that of \u003ccode\u003ev1\u003c/code\u003e by adding an angle 0 \u003c= theta \u003c= tau/2).\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Vector",
          "name": "leftTurn",
          "package": "diagrams-lib",
          "signature": "R2 -\u003e R2 -\u003e Bool",
          "source": "src/Diagrams-TwoD-Vector.html#leftTurn",
          "type": "function"
        },
        "index": {
          "description": "leftTurn v1 v2 tests whether the direction of v2 is left turn from v1 that is if the direction of v2 can be obtained from that of v1 by adding an angle theta tau",
          "hierarchy": "Diagrams TwoD Vector",
          "module": "Diagrams.TwoD.Vector",
          "name": "leftTurn",
          "normalized": "R-\u003eR-\u003eBool",
          "package": "diagrams-lib",
          "partial": "Turn",
          "signature": "R-\u003eR-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:leftTurn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eperp v\u003c/code\u003e is perpendicular to and has the same magnitude as \u003ccode\u003ev\u003c/code\u003e.\n   In particular \u003ccode\u003eperp v == rotateBy (1/4) v\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD.Vector",
          "name": "perp",
          "package": "diagrams-lib",
          "signature": "R2 -\u003e R2",
          "source": "src/Diagrams-TwoD-Vector.html#perp",
          "type": "function"
        },
        "index": {
          "description": "perp is perpendicular to and has the same magnitude as In particular perp rotateBy",
          "hierarchy": "Diagrams TwoD Vector",
          "module": "Diagrams.TwoD.Vector",
          "name": "perp",
          "normalized": "R-\u003eR",
          "package": "diagrams-lib",
          "signature": "R-\u003eR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:perp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit vector in the positive X direction.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Vector\",\"Diagrams.TwoD\"]",
          "name": "unitX",
          "package": "diagrams-lib",
          "signature": "R2",
          "source": "src/Diagrams-TwoD-Vector.html#unitX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:unitX\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:unitX\"]"
        },
        "index": {
          "description": "The unit vector in the positive direction",
          "hierarchy": "Diagrams TwoD Vector",
          "module": "Diagrams.TwoD.Vector",
          "name": "unitX",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:unitX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit vector in the positive Y direction.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Vector\",\"Diagrams.TwoD\"]",
          "name": "unitY",
          "package": "diagrams-lib",
          "signature": "R2",
          "source": "src/Diagrams-TwoD-Vector.html#unitY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:unitY\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:unitY\"]"
        },
        "index": {
          "description": "The unit vector in the positive direction",
          "hierarchy": "Diagrams TwoD Vector",
          "module": "Diagrams.TwoD.Vector",
          "name": "unitY",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:unitY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit vector in the negative X direction.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Vector\",\"Diagrams.TwoD\"]",
          "name": "unit_X",
          "package": "diagrams-lib",
          "signature": "R2",
          "source": "src/Diagrams-TwoD-Vector.html#unit_X",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:unit_X\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:unit_X\"]"
        },
        "index": {
          "description": "The unit vector in the negative direction",
          "hierarchy": "Diagrams TwoD Vector",
          "module": "Diagrams.TwoD.Vector",
          "name": "unit_X",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:unit_X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit vector in the negative Y direction.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD.Vector\",\"Diagrams.TwoD\"]",
          "name": "unit_Y",
          "package": "diagrams-lib",
          "signature": "R2",
          "source": "src/Diagrams-TwoD-Vector.html#unit_Y",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:unit_Y\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:unit_Y\"]"
        },
        "index": {
          "description": "The unit vector in the negative direction",
          "hierarchy": "Diagrams TwoD Vector",
          "module": "Diagrams.TwoD.Vector",
          "name": "unit_Y",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD-Vector.html#v:unit_Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the two-dimensional vector space R^2,\n two-dimensional transformations, and various predefined\n two-dimensional shapes.  This module re-exports useful\n functionality from a group of more specific modules:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Types\u003c/a\u003e defines basic types for two-dimensional\n     diagrams, including types representing the 2D Euclidean vector\n     space and various systems of angle measurement.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Align\u003c/a\u003e defines alignment combinators specialized\n     to two dimensions (see \u003ca\u003eDiagrams.Align\u003c/a\u003e for more general\n     alignment).\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Combinators\u003c/a\u003e defines ways of combining diagrams\n     specialized to two dimensions (see also \u003ca\u003eDiagrams.Combinators\u003c/a\u003e\n     for more general combining).\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Transform\u003c/a\u003e defines R^2-specific transformations\n     such as rotation by an angle, and scaling, translation, and\n     reflection in the X and Y directions.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Ellipse\u003c/a\u003e defines circles and ellipses.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Arc\u003c/a\u003e defines circular arcs.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Path\u003c/a\u003e exports various operations on\n     two-dimensional paths when viewed as regions of the plane.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Polygons\u003c/a\u003e defines general algorithms for drawing\n     various types of polygons.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Shapes\u003c/a\u003e defines other two-dimensional shapes,\n     e.g. various polygons.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Arrow\u003c/a\u003e contains tools for drawing arrows between\n     things.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Text\u003c/a\u003e defines primitive text diagrams.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Image\u003c/a\u003e allows importing external images into diagrams.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Vector\u003c/a\u003e defines some special 2D vectors and\n     functions for converting between vectors and angles.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Size\u003c/a\u003e defines functions for working with the\n     size of 2D objects.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eDiagrams.TwoD.Model\u003c/a\u003e defines some aids for visualizing\n     diagrams' internal model (local origins, envelopes, etc.)\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Diagrams.TwoD",
          "name": "TwoD",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the two-dimensional vector space two-dimensional transformations and various predefined two-dimensional shapes This module re-exports useful functionality from group of more specific modules Diagrams.TwoD.Types defines basic types for two-dimensional diagrams including types representing the Euclidean vector space and various systems of angle measurement Diagrams.TwoD.Align defines alignment combinators specialized to two dimensions see Diagrams.Align for more general alignment Diagrams.TwoD.Combinators defines ways of combining diagrams specialized to two dimensions see also Diagrams.Combinators for more general combining Diagrams.TwoD.Transform defines specific transformations such as rotation by an angle and scaling translation and reflection in the and directions Diagrams.TwoD.Ellipse defines circles and ellipses Diagrams.TwoD.Arc defines circular arcs Diagrams.TwoD.Path exports various operations on two-dimensional paths when viewed as regions of the plane Diagrams.TwoD.Polygons defines general algorithms for drawing various types of polygons Diagrams.TwoD.Shapes defines other two-dimensional shapes e.g various polygons Diagrams.TwoD.Arrow contains tools for drawing arrows between things Diagrams.TwoD.Text defines primitive text diagrams Diagrams.TwoD.Image allows importing external images into diagrams Diagrams.TwoD.Vector defines some special vectors and functions for converting between vectors and angles Diagrams.TwoD.Size defines functions for working with the size of objects Diagrams.TwoD.Model defines some aids for visualizing diagrams internal model local origins envelopes etc",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "TwoD",
          "package": "diagrams-lib",
          "partial": "Two",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class for types that measure angles.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "Angle",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#Angle",
          "type": "class"
        },
        "index": {
          "description": "Type class for types that measure angles",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "Angle",
          "package": "diagrams-lib",
          "partial": "Angle",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:Angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD",
          "name": "ArrowOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Arrow.html#ArrowOpts",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "ArrowOpts",
          "package": "diagrams-lib",
          "partial": "Arrow Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:ArrowOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated synonym for \u003ccode\u003e\u003ca\u003eTurn\u003c/a\u003e\u003c/code\u003e, retained for backwards compatibility.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "CircleFrac",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#CircleFrac",
          "type": "type"
        },
        "index": {
          "description": "Deprecated synonym for Turn retained for backwards compatibility",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "CircleFrac",
          "package": "diagrams-lib",
          "partial": "Circle Frac",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:CircleFrac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNewtype wrapper for representing angles in degrees.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "Deg",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#Deg",
          "type": "newtype"
        },
        "index": {
          "description": "Newtype wrapper for representing angles in degrees",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "Deg",
          "package": "diagrams-lib",
          "partial": "Deg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:Deg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumeration of algorithms or \"rules\" for determining which\n   points lie in the interior of a (possibly self-intersecting)\n   closed path.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "FillRule",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Path.html#FillRule",
          "type": "data"
        },
        "index": {
          "description": "Enumeration of algorithms or rules for determining which points lie in the interior of possibly self-intersecting closed path",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "FillRule",
          "package": "diagrams-lib",
          "partial": "Fill Rule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:FillRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn external image primitive, representing an image the backend\n   should import from another file when rendering.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "Image",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Image.html#Image",
          "type": "data"
        },
        "index": {
          "description": "An external image primitive representing an image the backend should import from another file when rendering",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "Image",
          "package": "diagrams-lib",
          "partial": "Image",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:Image"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD",
          "name": "OriginOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Model.html#OriginOpts",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "OriginOpts",
          "package": "diagrams-lib",
          "partial": "Origin Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:OriginOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePoints in R^2.  This type is intentionally abstract.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e To construct a point, use \u003ccode\u003e\u003ca\u003ep2\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003e^&\u003c/a\u003e\u003c/code\u003e (see\n     \u003ca\u003eDiagrams.Coordinates\u003c/a\u003e):\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\n p2 (3,4)  :: P2\n 3 ^& 4    :: P2\n\u003c/pre\u003e\u003cul\u003e\u003cli\u003e To construct a point from a vector \u003ccode\u003ev\u003c/code\u003e, use \u003ccode\u003e\u003ccode\u003e\u003ca\u003eorigin\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.+^\u003c/a\u003e\u003c/code\u003e v\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e To convert a point \u003ccode\u003ep\u003c/code\u003e into the vector from the origin to \u003ccode\u003ep\u003c/code\u003e,\n   use \u003ccode\u003ep \u003ccode\u003e\u003ca\u003e.-.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eorigin\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e To convert a point back into a pair of coordinates, use \u003ccode\u003e\u003ca\u003eunp2\u003c/a\u003e\u003c/code\u003e,\n     or \u003ccode\u003e\u003ca\u003ecoords\u003c/a\u003e\u003c/code\u003e (from \u003ca\u003eDiagrams.Coordinates\u003c/a\u003e).  It's common to use\n     these in conjunction with the \u003ccode\u003eViewPatterns\u003c/code\u003e extension:\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\n foo (unp2 -\u003e (x,y)) = ...\n foo (coords -\u003e x :& y) = ...\n\u003c/pre\u003e",
          "module": "Diagrams.TwoD",
          "name": "P2",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#P2",
          "type": "type"
        },
        "index": {
          "description": "Points in This type is intentionally abstract To construct point use p2 or see Diagrams.Coordinates p2 P2 P2 To construct point from vector use origin To convert point into the vector from the origin to use origin To convert point back into pair of coordinates use unp2 or coords from Diagrams.Coordinates It common to use these in conjunction with the ViewPatterns extension foo unp2 foo coords",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "P2",
          "package": "diagrams-lib",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:P2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine how a polygon should be oriented.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "PolyOrientation",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Polygons.html#PolyOrientation",
          "type": "data"
        },
        "index": {
          "description": "Determine how polygon should be oriented",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "PolyOrientation",
          "package": "diagrams-lib",
          "partial": "Poly Orientation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:PolyOrientation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMethod used to determine the vertices of a polygon.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "PolyType",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Polygons.html#PolyType",
          "type": "data"
        },
        "index": {
          "description": "Method used to determine the vertices of polygon",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "PolyType",
          "package": "diagrams-lib",
          "partial": "Poly Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:PolyType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptions for specifying a polygon.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "PolygonOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Polygons.html#PolygonOpts",
          "type": "data"
        },
        "index": {
          "description": "Options for specifying polygon",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "PolygonOpts",
          "package": "diagrams-lib",
          "partial": "Polygon Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:PolygonOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe two-dimensional Euclidean vector space R^2.  This type is\n   intentionally abstract.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e To construct a vector, use \u003ccode\u003e\u003ca\u003er2\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003e^&\u003c/a\u003e\u003c/code\u003e (from \u003ca\u003eDiagrams.Coordinates\u003c/a\u003e):\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\n r2 (3,4) :: R2\n 3 ^& 4    :: R2\n\u003c/pre\u003e\u003cp\u003eNote that \u003ca\u003eDiagrams.Coordinates\u003c/a\u003e is not re-exported by\n     \u003ca\u003eDiagrams.Prelude\u003c/a\u003e and must be explicitly imported.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e To construct the vector from the origin to a point \u003ccode\u003ep\u003c/code\u003e, use\n     \u003ccode\u003ep \u003ccode\u003e\u003ca\u003e.-.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eorigin\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e To convert a vector \u003ccode\u003ev\u003c/code\u003e into the point obtained by following\n     \u003ccode\u003ev\u003c/code\u003e from the origin, use \u003ccode\u003e\u003ccode\u003e\u003ca\u003eorigin\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.+^\u003c/a\u003e\u003c/code\u003e v\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e To convert a vector back into a pair of components, use \u003ccode\u003eunv2\u003c/code\u003e\n     or \u003ccode\u003e\u003ca\u003ecoords\u003c/a\u003e\u003c/code\u003e (from \u003ca\u003eDiagrams.Coordinates\u003c/a\u003e).  These are typically\n     used in conjunction with the \u003ccode\u003eViewPatterns\u003c/code\u003e extension:\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\n foo (unr2 -\u003e (x,y)) = ...\n foo (coords -\u003e x :& y) = ...\n\u003c/pre\u003e",
          "module": "Diagrams.TwoD",
          "name": "R2",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#R2",
          "type": "data"
        },
        "index": {
          "description": "The two-dimensional Euclidean vector space This type is intentionally abstract To construct vector use r2 or from Diagrams.Coordinates r2 R2 R2 Note that Diagrams.Coordinates is not re-exported by Diagrams.Prelude and must be explicitly imported To construct the vector from the origin to point use origin To convert vector into the point obtained by following from the origin use origin To convert vector back into pair of components use unv2 or coords from Diagrams.Coordinates These are typically used in conjunction with the ViewPatterns extension foo unr2 foo coords",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "R2",
          "package": "diagrams-lib",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:R2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNewtype wrapper for representing angles in radians.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "Rad",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#Rad",
          "type": "newtype"
        },
        "index": {
          "description": "Newtype wrapper for representing angles in radians",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "Rad",
          "package": "diagrams-lib",
          "partial": "Rad",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:Rad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.TwoD",
          "name": "RoundedRectOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Shapes.html#RoundedRectOpts",
          "type": "data"
        },
        "index": {
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "RoundedRectOpts",
          "package": "diagrams-lib",
          "partial": "Rounded Rect Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:RoundedRectOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA specification of a (requested) rectangular size.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "SizeSpec2D",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Size.html#SizeSpec2D",
          "type": "data"
        },
        "index": {
          "description": "specification of requested rectangular size",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "SizeSpec2D",
          "package": "diagrams-lib",
          "partial": "Size Spec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:SizeSpec2D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptions for creating \"star\" polygons, where the edges connect\n   possibly non-adjacent vertices.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "StarOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Polygons.html#StarOpts",
          "type": "data"
        },
        "index": {
          "description": "Options for creating star polygons where the edges connect possibly non-adjacent vertices",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "StarOpts",
          "package": "diagrams-lib",
          "partial": "Star Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:StarOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA record of options that control how a path is stroked.\n   \u003ccode\u003eStrokeOpts\u003c/code\u003e is an instance of \u003ccode\u003e\u003ca\u003eDefault\u003c/a\u003e\u003c/code\u003e, so a \u003ccode\u003eStrokeOpts\u003c/code\u003e\n   records can be created using \u003ccode\u003e\u003ccode\u003ewith\u003c/code\u003e { ... }\u003c/code\u003e notation.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "StrokeOpts",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Path.html#StrokeOpts",
          "type": "data"
        },
        "index": {
          "description": "record of options that control how path is stroked StrokeOpts is an instance of Default so StrokeOpts records can be created using with notation",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "StrokeOpts",
          "package": "diagrams-lib",
          "partial": "Stroke Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:StrokeOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransformations in R^2.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "T2",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#T2",
          "type": "type"
        },
        "index": {
          "description": "Transformations in",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "T2",
          "package": "diagrams-lib",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:T2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNewtype wrapper used to represent angles as fractions of a\n   circle.  For example, 1/3 turn = tau/3 radians = 120 degrees.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "Turn",
          "package": "diagrams-lib",
          "source": "src/Diagrams-TwoD-Types.html#Turn",
          "type": "newtype"
        },
        "index": {
          "description": "Newtype wrapper used to represent angles as fractions of circle For example turn tau radians degrees",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "Turn",
          "package": "diagrams-lib",
          "partial": "Turn",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#t:Turn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from a turn, \u003cem\u003ei.e.\u003c/em\u003e a fraction of a circle.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "fromTurn",
          "package": "diagrams-lib",
          "signature": "Turn -\u003e a",
          "source": "src/Diagrams-TwoD-Types.html#fromTurn",
          "type": "method"
        },
        "index": {
          "description": "Convert from turn i.e fraction of circle",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "fromTurn",
          "normalized": "Turn-\u003ea",
          "package": "diagrams-lib",
          "partial": "Turn",
          "signature": "Turn-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:fromTurn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe circle constant, the ratio of a circle's circumference to its\n   \u003cem\u003eradius\u003c/em\u003e.  Note that \u003ccode\u003epi = tau/2\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor more information and a well-reasoned argument why we should\n   all be using tau instead of pi, see \u003cem\u003eThe Tau Manifesto\u003c/em\u003e,\n   \u003ca\u003ehttp://tauday.com/\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eTo hear what it sounds like (and to easily memorize the first 30\n   digits or so), try \u003ca\u003ehttp://youtu.be/3174T-3-59Q\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.TwoD\",\"Diagrams.Util\"]",
          "name": "tau",
          "package": "diagrams-lib",
          "signature": "a",
          "source": "src/Diagrams-Util.html#tau",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:tau\",\"http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Util.html#v:tau\"]"
        },
        "index": {
          "description": "The circle constant the ratio of circle circumference to its radius Note that pi tau For more information and well-reasoned argument why we should all be using tau instead of pi see The Tau Manifesto http tauday.com To hear what it sounds like and to easily memorize the first digits or so try http youtu.be T-3-59Q",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "tau",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:tau"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert to a turn, \u003cem\u003ei.e.\u003c/em\u003e a fraction of a circle.\n\u003c/p\u003e",
          "module": "Diagrams.TwoD",
          "name": "toTurn",
          "package": "diagrams-lib",
          "signature": "a -\u003e Turn",
          "source": "src/Diagrams-TwoD-Types.html#toTurn",
          "type": "method"
        },
        "index": {
          "description": "Convert to turn i.e fraction of circle",
          "hierarchy": "Diagrams TwoD",
          "module": "Diagrams.TwoD",
          "name": "toTurn",
          "normalized": "a-\u003eTurn",
          "package": "diagrams-lib",
          "partial": "Turn",
          "signature": "a-\u003eTurn",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-TwoD.html#v:toTurn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSome miscellaneous utilities provided by the diagrams-lib package.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Util",
          "name": "Util",
          "package": "diagrams-lib",
          "source": "src/Diagrams-Util.html",
          "type": "module"
        },
        "index": {
          "description": "Some miscellaneous utilities provided by the diagrams-lib package",
          "hierarchy": "Diagrams Util",
          "module": "Diagrams.Util",
          "name": "Util",
          "package": "diagrams-lib",
          "partial": "Util",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Util.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePostfix function application, for conveniently applying\n   attributes.  Unlike \u003ccode\u003e($)\u003c/code\u003e, \u003ccode\u003e(#)\u003c/code\u003e has a high precedence (8), so \u003ccode\u003ed\n   # foo # bar\u003c/code\u003e can be combined with other things using operators\n   like \u003ccode\u003e(|||)\u003c/code\u003e or \u003ccode\u003e(\u003c\u003e)\u003c/code\u003e without needing parentheses.\n\u003c/p\u003e",
          "module": "Diagrams.Util",
          "name": "(#)",
          "package": "diagrams-lib",
          "signature": "a -\u003e (a -\u003e b) -\u003e b",
          "source": "src/Diagrams-Util.html#%23",
          "type": "function"
        },
        "index": {
          "description": "Postfix function application for conveniently applying attributes Unlike has high precedence so foo bar can be combined with other things using operators like or without needing parentheses",
          "hierarchy": "Diagrams Util",
          "module": "Diagrams.Util",
          "name": "(#) #",
          "normalized": "a-\u003e(a-\u003eb)-\u003eb",
          "package": "diagrams-lib",
          "signature": "a-\u003e(a-\u003eb)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Util.html#v:-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eapplyAll\u003c/code\u003e takes a list of functions and applies them all to a\n   value, in sequence from the last function in the list to the first.\n   For example, \u003ccode\u003eapplyAll [f1, f2, f3] a == f1 . f2 . f3 $ a\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Util",
          "name": "applyAll",
          "package": "diagrams-lib",
          "signature": "[a -\u003e a] -\u003e a -\u003e a",
          "source": "src/Diagrams-Util.html#applyAll",
          "type": "function"
        },
        "index": {
          "description": "applyAll takes list of functions and applies them all to value in sequence from the last function in the list to the first For example applyAll f1 f2 f3 f1 f2 f3",
          "hierarchy": "Diagrams Util",
          "module": "Diagrams.Util",
          "name": "applyAll",
          "normalized": "[a-\u003ea]-\u003ea-\u003ea",
          "package": "diagrams-lib",
          "partial": "All",
          "signature": "[a-\u003ea]-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Util.html#v:applyAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven an associative binary operation and a default value to use\n   in the case of an empty list, perform a \u003cem\u003ebalanced\u003c/em\u003e fold over a\n   list.  For example,\n\u003c/p\u003e\u003cpre\u003e\n   foldB (+) z [a,b,c,d,e,f] == ((a+b) + (c+d)) + (e+f)\n\u003c/pre\u003e",
          "module": "Diagrams.Util",
          "name": "foldB",
          "package": "diagrams-lib",
          "signature": "(a -\u003e a -\u003e a) -\u003e a -\u003e [a] -\u003e a",
          "source": "src/Diagrams-Util.html#foldB",
          "type": "function"
        },
        "index": {
          "description": "Given an associative binary operation and default value to use in the case of an empty list perform balanced fold over list For example foldB",
          "hierarchy": "Diagrams Util",
          "module": "Diagrams.Util",
          "name": "foldB",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003e[a]-\u003ea",
          "package": "diagrams-lib",
          "signature": "(a-\u003ea-\u003ea)-\u003ea-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Util.html#v:foldB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eiterateN n f x\u003c/code\u003e returns the list of the first \u003ccode\u003en\u003c/code\u003e iterates of\n   \u003ccode\u003ef\u003c/code\u003e starting at \u003ccode\u003ex\u003c/code\u003e, that is, the list \u003ccode\u003e[x, f x, f (f x), ...]\u003c/code\u003e\n   of length \u003ccode\u003en\u003c/code\u003e. (Note that the last element of the list will be\n   \u003ccode\u003ef\u003c/code\u003e applied to \u003ccode\u003ex\u003c/code\u003e \u003ccode\u003e(n-1)\u003c/code\u003e times.)\n\u003c/p\u003e",
          "module": "Diagrams.Util",
          "name": "iterateN",
          "package": "diagrams-lib",
          "signature": "Int -\u003e (a -\u003e a) -\u003e a -\u003e [a]",
          "source": "src/Diagrams-Util.html#iterateN",
          "type": "function"
        },
        "index": {
          "description": "iterateN returns the list of the first iterates of starting at that is the list of length Note that the last element of the list will be applied to n-1 times",
          "hierarchy": "Diagrams Util",
          "module": "Diagrams.Util",
          "name": "iterateN",
          "normalized": "Int-\u003e(a-\u003ea)-\u003ea-\u003e[a]",
          "package": "diagrams-lib",
          "signature": "Int-\u003e(a-\u003ea)-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Util.html#v:iterateN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSeveral functions exported by the diagrams library take a number\n   of arguments giving the user control to \"tweak\" various aspects\n   of their behavior.  Rather than give such functions a long list\n   of arguments, and to make it possible for the user to selectively\n   override only certain arguments and use default values for\n   others, such sets of arguments are collected into a record with\n   named fields (see \u003ccode\u003ePolygonOpts\u003c/code\u003e in \u003ca\u003eDiagrams.TwoD.Shapes\u003c/a\u003e for an\n   example).  Such record types are made instances of the \u003ccode\u003e\u003ca\u003eDefault\u003c/a\u003e\u003c/code\u003e\n   class, which provides a single record structure (\u003ccode\u003e\u003ca\u003edef\u003c/a\u003e\u003c/code\u003e)\n   collecting the \"default\" arguments to the function.  \u003ccode\u003ewith\u003c/code\u003e is\n   a synonym for \u003ccode\u003e\u003ca\u003edef\u003c/a\u003e\u003c/code\u003e, which provides nice-looking syntax for\n   simulating optional, named arguments in Haskell.  For example,\n\u003c/p\u003e\u003cpre\u003e\n   polygon with {sides = 7, edgeSkip = 2}\n\u003c/pre\u003e\u003cp\u003ecalls the \u003ccode\u003epolygon\u003c/code\u003e function with a single argument (note that\n   record update binds more tightly than function application!),\n   namely, \u003ccode\u003e\u003ca\u003ewith\u003c/a\u003e\u003c/code\u003e (the record of default arguments) where the\n   \u003ccode\u003esides\u003c/code\u003e and \u003ccode\u003eedgeSkip\u003c/code\u003e fields have been updated.\n\u003c/p\u003e",
          "module": "Diagrams.Util",
          "name": "with",
          "package": "diagrams-lib",
          "signature": "d",
          "source": "src/Diagrams-Util.html#with",
          "type": "function"
        },
        "index": {
          "description": "Several functions exported by the diagrams library take number of arguments giving the user control to tweak various aspects of their behavior Rather than give such functions long list of arguments and to make it possible for the user to selectively override only certain arguments and use default values for others such sets of arguments are collected into record with named fields see PolygonOpts in Diagrams.TwoD.Shapes for an example Such record types are made instances of the Default class which provides single record structure def collecting the default arguments to the function with is synonym for def which provides nice-looking syntax for simulating optional named arguments in Haskell For example polygon with sides edgeSkip calls the polygon function with single argument note that record update binds more tightly than function application namely with the record of default arguments where the sides and edgeSkip fields have been updated",
          "hierarchy": "Diagrams Util",
          "module": "Diagrams.Util",
          "name": "with",
          "package": "diagrams-lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Util.html#v:with"
      }
    }
  ]
]