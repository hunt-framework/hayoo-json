[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "vector-space"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGroups: zero, addition, and negation (additive inverse)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.AdditiveGroup",
          "name": "AdditiveGroup",
          "package": "vector-space",
          "source": "src/Data-AdditiveGroup.html",
          "type": "module"
        },
        "index": {
          "description": "Groups zero addition and negation additive inverse",
          "hierarchy": "Data AdditiveGroup",
          "module": "Data.AdditiveGroup",
          "name": "AdditiveGroup",
          "package": "vector-space",
          "partial": "Additive Group",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdditive group \u003ccode\u003ev\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.AdditiveGroup",
          "name": "AdditiveGroup",
          "package": "vector-space",
          "source": "src/Data-AdditiveGroup.html#AdditiveGroup",
          "type": "class"
        },
        "index": {
          "description": "Additive group",
          "hierarchy": "Data AdditiveGroup",
          "module": "Data.AdditiveGroup",
          "name": "AdditiveGroup",
          "package": "vector-space",
          "partial": "Additive Group",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#t:AdditiveGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonoid under group addition.  Alternative to the \u003ccode\u003eSum\u003c/code\u003e in\n \u003ca\u003eData.Monoid\u003c/a\u003e, which uses \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e instead of \u003ccode\u003e\u003ca\u003eAdditiveGroup\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.AdditiveGroup",
          "name": "Sum",
          "package": "vector-space",
          "source": "src/Data-AdditiveGroup.html#Sum",
          "type": "newtype"
        },
        "index": {
          "description": "Monoid under group addition Alternative to the Sum in Data.Monoid which uses Num instead of AdditiveGroup",
          "hierarchy": "Data AdditiveGroup",
          "module": "Data.AdditiveGroup",
          "name": "Sum",
          "package": "vector-space",
          "partial": "Sum",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#t:Sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd vectors\n\u003c/p\u003e",
          "module": "Data.AdditiveGroup",
          "name": "(^+^)",
          "package": "vector-space",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-AdditiveGroup.html#%5E%2B%5E",
          "type": "method"
        },
        "index": {
          "description": "Add vectors",
          "hierarchy": "Data AdditiveGroup",
          "module": "Data.AdditiveGroup",
          "name": "(^+^) ^+^",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vector-space",
          "signature": "v-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:-94--43--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGroup subtraction\n\u003c/p\u003e",
          "module": "Data.AdditiveGroup",
          "name": "(^-^)",
          "package": "vector-space",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-AdditiveGroup.html#%5E-%5E",
          "type": "function"
        },
        "index": {
          "description": "Group subtraction",
          "hierarchy": "Data AdditiveGroup",
          "module": "Data.AdditiveGroup",
          "name": "(^-^) ^-^",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vector-space",
          "signature": "v-\u003ev-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:-94--45--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AdditiveGroup",
          "name": "Sum",
          "package": "vector-space",
          "signature": "Sum",
          "source": "src/Data-AdditiveGroup.html#Sum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AdditiveGroup",
          "module": "Data.AdditiveGroup",
          "name": "Sum",
          "package": "vector-space",
          "partial": "Sum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:Sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AdditiveGroup",
          "name": "getSum",
          "package": "vector-space",
          "signature": "a",
          "source": "src/Data-AdditiveGroup.html#Sum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AdditiveGroup",
          "module": "Data.AdditiveGroup",
          "name": "getSum",
          "package": "vector-space",
          "partial": "Sum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:getSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplication a unary function inside a \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.AdditiveGroup",
          "name": "inSum",
          "package": "vector-space",
          "signature": "(a -\u003e b) -\u003e Sum a -\u003e Sum b",
          "source": "src/Data-AdditiveGroup.html#inSum",
          "type": "function"
        },
        "index": {
          "description": "Application unary function inside Sum",
          "hierarchy": "Data AdditiveGroup",
          "module": "Data.AdditiveGroup",
          "name": "inSum",
          "normalized": "(a-\u003eb)-\u003eSum a-\u003eSum b",
          "package": "vector-space",
          "partial": "Sum",
          "signature": "(a-\u003eb)-\u003eSum a-\u003eSum b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:inSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplication a binary function inside a \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.AdditiveGroup",
          "name": "inSum2",
          "package": "vector-space",
          "signature": "(a -\u003e b -\u003e c) -\u003e Sum a -\u003e Sum b -\u003e Sum c",
          "source": "src/Data-AdditiveGroup.html#inSum2",
          "type": "function"
        },
        "index": {
          "description": "Application binary function inside Sum",
          "hierarchy": "Data AdditiveGroup",
          "module": "Data.AdditiveGroup",
          "name": "inSum2",
          "normalized": "(a-\u003eb-\u003ec)-\u003eSum a-\u003eSum b-\u003eSum c",
          "package": "vector-space",
          "partial": "Sum",
          "signature": "(a-\u003eb-\u003ec)-\u003eSum a-\u003eSum b-\u003eSum c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:inSum2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdditive inverse\n\u003c/p\u003e",
          "module": "Data.AdditiveGroup",
          "name": "negateV",
          "package": "vector-space",
          "signature": "v -\u003e v",
          "source": "src/Data-AdditiveGroup.html#negateV",
          "type": "method"
        },
        "index": {
          "description": "Additive inverse",
          "hierarchy": "Data AdditiveGroup",
          "module": "Data.AdditiveGroup",
          "name": "negateV",
          "normalized": "a-\u003ea",
          "package": "vector-space",
          "signature": "v-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:negateV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum over several vectors\n\u003c/p\u003e",
          "module": "Data.AdditiveGroup",
          "name": "sumV",
          "package": "vector-space",
          "signature": "f v -\u003e v",
          "source": "src/Data-AdditiveGroup.html#sumV",
          "type": "function"
        },
        "index": {
          "description": "Sum over several vectors",
          "hierarchy": "Data AdditiveGroup",
          "module": "Data.AdditiveGroup",
          "name": "sumV",
          "normalized": "a b-\u003eb",
          "package": "vector-space",
          "signature": "f v-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:sumV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe zero element: identity for '(^+^)'\n\u003c/p\u003e",
          "module": "Data.AdditiveGroup",
          "name": "zeroV",
          "package": "vector-space",
          "signature": "v",
          "source": "src/Data-AdditiveGroup.html#zeroV",
          "type": "method"
        },
        "index": {
          "description": "The zero element identity for",
          "hierarchy": "Data AdditiveGroup",
          "module": "Data.AdditiveGroup",
          "name": "zeroV",
          "package": "vector-space",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:zeroV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAffine spaces.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.AffineSpace",
          "name": "AffineSpace",
          "package": "vector-space",
          "source": "src/Data-AffineSpace.html",
          "type": "module"
        },
        "index": {
          "description": "Affine spaces",
          "hierarchy": "Data AffineSpace",
          "module": "Data.AffineSpace",
          "name": "AffineSpace",
          "package": "vector-space",
          "partial": "Affine Space",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AffineSpace",
          "name": "AffineSpace",
          "package": "vector-space",
          "source": "src/Data-AffineSpace.html#AffineSpace",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data AffineSpace",
          "module": "Data.AffineSpace",
          "name": "AffineSpace",
          "package": "vector-space",
          "partial": "Affine Space",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#t:AffineSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePoint plus vector\n\u003c/p\u003e",
          "module": "Data.AffineSpace",
          "name": "(.+^)",
          "package": "vector-space",
          "signature": "p -\u003e Diff p -\u003e p",
          "source": "src/Data-AffineSpace.html#.%2B%5E",
          "type": "method"
        },
        "index": {
          "description": "Point plus vector",
          "hierarchy": "Data AffineSpace",
          "module": "Data.AffineSpace",
          "name": "(.+^) .+^",
          "normalized": "a-\u003eDiff a-\u003ea",
          "package": "vector-space",
          "signature": "p-\u003eDiff p-\u003ep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#v:.-43--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePoint minus vector\n\u003c/p\u003e",
          "module": "Data.AffineSpace",
          "name": "(.-^)",
          "package": "vector-space",
          "signature": "p -\u003e Diff p -\u003e p",
          "source": "src/Data-AffineSpace.html#.-%5E",
          "type": "function"
        },
        "index": {
          "description": "Point minus vector",
          "hierarchy": "Data AffineSpace",
          "module": "Data.AffineSpace",
          "name": "(.-^) .-^",
          "normalized": "a-\u003eDiff a-\u003ea",
          "package": "vector-space",
          "signature": "p-\u003eDiff p-\u003ep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#v:.-45--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubtract points\n\u003c/p\u003e",
          "module": "Data.AffineSpace",
          "name": "(.-.)",
          "package": "vector-space",
          "signature": "p -\u003e p -\u003e Diff p",
          "source": "src/Data-AffineSpace.html#.-.",
          "type": "method"
        },
        "index": {
          "description": "Subtract points",
          "hierarchy": "Data AffineSpace",
          "module": "Data.AffineSpace",
          "name": "(.-.) .-.",
          "normalized": "a-\u003ea-\u003eDiff a",
          "package": "vector-space",
          "signature": "p-\u003ep-\u003eDiff p",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#v:.-45-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAffine linear interpolation.  Varies from \u003ccode\u003ep\u003c/code\u003e to \u003ccode\u003ep'\u003c/code\u003e as \u003ccode\u003es\u003c/code\u003e varies\n from 0 to 1.  See also \u003ccode\u003e\u003ca\u003elerp\u003c/a\u003e\u003c/code\u003e (on vector spaces).\n\u003c/p\u003e",
          "module": "Data.AffineSpace",
          "name": "alerp",
          "package": "vector-space",
          "signature": "p -\u003e p -\u003e Scalar (Diff p) -\u003e p",
          "source": "src/Data-AffineSpace.html#alerp",
          "type": "function"
        },
        "index": {
          "description": "Affine linear interpolation Varies from to as varies from to See also lerp on vector spaces",
          "hierarchy": "Data AffineSpace",
          "module": "Data.AffineSpace",
          "name": "alerp",
          "normalized": "a-\u003ea-\u003eScalar(Diff a)-\u003ea",
          "package": "vector-space",
          "signature": "p-\u003ep-\u003eScalar(Diff p)-\u003ep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#v:alerp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDistance between two points.  See also \u003ccode\u003e\u003ca\u003edistanceSq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.AffineSpace",
          "name": "distance",
          "package": "vector-space",
          "signature": "p -\u003e p -\u003e s",
          "source": "src/Data-AffineSpace.html#distance",
          "type": "function"
        },
        "index": {
          "description": "Distance between two points See also distanceSq",
          "hierarchy": "Data AffineSpace",
          "module": "Data.AffineSpace",
          "name": "distance",
          "normalized": "a-\u003ea-\u003eb",
          "package": "vector-space",
          "signature": "p-\u003ep-\u003es",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#v:distance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSquare of the distance between two points.  Sometimes useful for\n efficiency.  See also \u003ccode\u003e\u003ca\u003edistance\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.AffineSpace",
          "name": "distanceSq",
          "package": "vector-space",
          "signature": "p -\u003e p -\u003e Scalar v",
          "source": "src/Data-AffineSpace.html#distanceSq",
          "type": "function"
        },
        "index": {
          "description": "Square of the distance between two points Sometimes useful for efficiency See also distance",
          "hierarchy": "Data AffineSpace",
          "module": "Data.AffineSpace",
          "name": "distanceSq",
          "normalized": "a-\u003ea-\u003eScalar b",
          "package": "vector-space",
          "partial": "Sq",
          "signature": "p-\u003ep-\u003eScalar v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#v:distanceSq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasis of a vector space, as an associated type\n This module requires ghc-6.10 or later\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Basis",
          "name": "Basis",
          "package": "vector-space",
          "source": "src/Data-Basis.html",
          "type": "module"
        },
        "index": {
          "description": "Basis of vector space as an associated type This module requires ghc-6.10 or later",
          "hierarchy": "Data Basis",
          "module": "Data.Basis",
          "name": "Basis",
          "package": "vector-space",
          "partial": "Basis",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Basis.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Basis",
          "name": "HasBasis",
          "package": "vector-space",
          "source": "src/Data-Basis.html#HasBasis",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Basis",
          "module": "Data.Basis",
          "name": "HasBasis",
          "package": "vector-space",
          "partial": "Has Basis",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Basis.html#t:HasBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterpret basis rep as a vector\n\u003c/p\u003e",
          "module": "Data.Basis",
          "name": "basisValue",
          "package": "vector-space",
          "signature": "Basis v -\u003e v",
          "source": "src/Data-Basis.html#basisValue",
          "type": "method"
        },
        "index": {
          "description": "Interpret basis rep as vector",
          "hierarchy": "Data Basis",
          "module": "Data.Basis",
          "name": "basisValue",
          "normalized": "Basis a-\u003ea",
          "package": "vector-space",
          "partial": "Value",
          "signature": "Basis v-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Basis.html#v:basisValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract coordinates\n\u003c/p\u003e",
          "module": "Data.Basis",
          "name": "decompose",
          "package": "vector-space",
          "signature": "v -\u003e [(Basis v, Scalar v)]",
          "source": "src/Data-Basis.html#decompose",
          "type": "method"
        },
        "index": {
          "description": "Extract coordinates",
          "hierarchy": "Data Basis",
          "module": "Data.Basis",
          "name": "decompose",
          "normalized": "a-\u003e[(Basis a,Scalar a)]",
          "package": "vector-space",
          "signature": "v-\u003e[(Basis v,Scalar v)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Basis.html#v:decompose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExperimental version.  More elegant definitions, and friendly to\n infinite-dimensional vector spaces.\n\u003c/p\u003e",
          "module": "Data.Basis",
          "name": "decompose'",
          "package": "vector-space",
          "signature": "v -\u003e Basis v -\u003e Scalar v",
          "source": "src/Data-Basis.html#decompose%27",
          "type": "method"
        },
        "index": {
          "description": "Experimental version More elegant definitions and friendly to infinite-dimensional vector spaces",
          "hierarchy": "Data Basis",
          "module": "Data.Basis",
          "name": "decompose'",
          "normalized": "a-\u003eBasis a-\u003eScalar a",
          "package": "vector-space",
          "signature": "v-\u003eBasis v-\u003eScalar v",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Basis.html#v:decompose-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLinear combination\n\u003c/p\u003e",
          "module": "Data.Basis",
          "name": "linearCombo",
          "package": "vector-space",
          "signature": "[(v, Scalar v)] -\u003e v",
          "source": "src/Data-Basis.html#linearCombo",
          "type": "function"
        },
        "index": {
          "description": "Linear combination",
          "hierarchy": "Data Basis",
          "module": "Data.Basis",
          "name": "linearCombo",
          "normalized": "[(a,Scalar a)]-\u003ea",
          "package": "vector-space",
          "partial": "Combo",
          "signature": "[(v,Scalar v)]-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Basis.html#v:linearCombo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Basis",
          "name": "recompose",
          "package": "vector-space",
          "signature": "[(Basis v, Scalar v)] -\u003e v",
          "source": "src/Data-Basis.html#recompose",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Basis",
          "module": "Data.Basis",
          "name": "recompose",
          "normalized": "[(Basis a,Scalar a)]-\u003ea",
          "package": "vector-space",
          "signature": "[(Basis v,Scalar v)]-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Basis.html#v:recompose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCross products and normals\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Cross",
          "name": "Cross",
          "package": "vector-space",
          "source": "src/Data-Cross.html",
          "type": "module"
        },
        "index": {
          "description": "Cross products and normals",
          "hierarchy": "Data Cross",
          "module": "Data.Cross",
          "name": "Cross",
          "package": "vector-space",
          "partial": "Cross",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCross product of various forms of 2D vectors\n\u003c/p\u003e",
          "module": "Data.Cross",
          "name": "HasCross2",
          "package": "vector-space",
          "source": "src/Data-Cross.html#HasCross2",
          "type": "class"
        },
        "index": {
          "description": "Cross product of various forms of vectors",
          "hierarchy": "Data Cross",
          "module": "Data.Cross",
          "name": "HasCross2",
          "package": "vector-space",
          "partial": "Has Cross",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#t:HasCross2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCross product of various forms of 3D vectors\n\u003c/p\u003e",
          "module": "Data.Cross",
          "name": "HasCross3",
          "package": "vector-space",
          "source": "src/Data-Cross.html#HasCross3",
          "type": "class"
        },
        "index": {
          "description": "Cross product of various forms of vectors",
          "hierarchy": "Data Cross",
          "module": "Data.Cross",
          "name": "HasCross3",
          "package": "vector-space",
          "partial": "Has Cross",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#t:HasCross3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThing with a normal vector (not necessarily normalized).\n\u003c/p\u003e",
          "module": "Data.Cross",
          "name": "HasNormal",
          "package": "vector-space",
          "source": "src/Data-Cross.html#HasNormal",
          "type": "class"
        },
        "index": {
          "description": "Thing with normal vector not necessarily normalized",
          "hierarchy": "Data Cross",
          "module": "Data.Cross",
          "name": "HasNormal",
          "package": "vector-space",
          "partial": "Has Normal",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#t:HasNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingleton\n\u003c/p\u003e",
          "module": "Data.Cross",
          "name": "One",
          "package": "vector-space",
          "source": "src/Data-Cross.html#One",
          "type": "type"
        },
        "index": {
          "description": "Singleton",
          "hierarchy": "Data Cross",
          "module": "Data.Cross",
          "name": "One",
          "package": "vector-space",
          "partial": "One",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#t:One"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHomogeneous triple\n\u003c/p\u003e",
          "module": "Data.Cross",
          "name": "Three",
          "package": "vector-space",
          "source": "src/Data-Cross.html#Three",
          "type": "type"
        },
        "index": {
          "description": "Homogeneous triple",
          "hierarchy": "Data Cross",
          "module": "Data.Cross",
          "name": "Three",
          "package": "vector-space",
          "partial": "Three",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#t:Three"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHomogeneous pair\n\u003c/p\u003e",
          "module": "Data.Cross",
          "name": "Two",
          "package": "vector-space",
          "source": "src/Data-Cross.html#Two",
          "type": "type"
        },
        "index": {
          "description": "Homogeneous pair",
          "hierarchy": "Data Cross",
          "module": "Data.Cross",
          "name": "Two",
          "package": "vector-space",
          "partial": "Two",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#t:Two"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cross",
          "name": "cross2",
          "package": "vector-space",
          "signature": "v -\u003e v",
          "source": "src/Data-Cross.html#cross2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Cross",
          "module": "Data.Cross",
          "name": "cross2",
          "normalized": "a-\u003ea",
          "package": "vector-space",
          "signature": "v-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#v:cross2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cross",
          "name": "cross3",
          "package": "vector-space",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-Cross.html#cross3",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Cross",
          "module": "Data.Cross",
          "name": "cross3",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vector-space",
          "signature": "v-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#v:cross3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormalized normal vector.  See also \u003ccode\u003ecross\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Cross",
          "name": "normal",
          "package": "vector-space",
          "signature": "v -\u003e v",
          "source": "src/Data-Cross.html#normal",
          "type": "function"
        },
        "index": {
          "description": "Normalized normal vector See also cross",
          "hierarchy": "Data Cross",
          "module": "Data.Cross",
          "name": "normal",
          "normalized": "a-\u003ea",
          "package": "vector-space",
          "signature": "v-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#v:normal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Cross",
          "name": "normalVec",
          "package": "vector-space",
          "signature": "v -\u003e v",
          "source": "src/Data-Cross.html#normalVec",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Cross",
          "module": "Data.Cross",
          "name": "normalVec",
          "normalized": "a-\u003ea",
          "package": "vector-space",
          "partial": "Vec",
          "signature": "v-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#v:normalVec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eModule indirection module.  For Maclaurin- vs Horner-based derivative\n towers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derivative",
          "name": "Derivative",
          "package": "vector-space",
          "source": "src/Data-Derivative.html",
          "type": "module"
        },
        "index": {
          "description": "Module indirection module For Maclaurin vs Horner-based derivative towers",
          "hierarchy": "Data Derivative",
          "module": "Data.Derivative",
          "name": "Derivative",
          "package": "vector-space",
          "partial": "Derivative",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Derivative.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLinear maps\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.LinearMap",
          "name": "LinearMap",
          "package": "vector-space",
          "source": "src/Data-LinearMap.html",
          "type": "module"
        },
        "index": {
          "description": "Linear maps",
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "LinearMap",
          "package": "vector-space",
          "partial": "Linear Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLinear map, represented as an optional memo-trie from basis to\n values, where \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e means the zero map (an optimization).\n\u003c/p\u003e",
          "module": "Data.LinearMap",
          "name": ":-*",
          "package": "vector-space",
          "source": "src/Data-LinearMap.html#%3A-%2A",
          "type": "data"
        },
        "index": {
          "description": "Linear map represented as an optional memo-trie from basis to values where Nothing means the zero map an optimization",
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": ":-*",
          "package": "vector-space",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#t::-45--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose linear maps\n\u003c/p\u003e",
          "module": "Data.LinearMap",
          "name": "(*.*)",
          "package": "vector-space",
          "signature": "(v :-* w) -\u003e (u :-* v) -\u003e u :-* w",
          "source": "src/Data-LinearMap.html#%2A.%2A",
          "type": "function"
        },
        "index": {
          "description": "Compose linear maps",
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "(*.*) *.*",
          "normalized": "(a*b)-\u003e(c*a)-\u003ec*b",
          "package": "vector-space",
          "signature": "(v*w)-\u003e(u*v)-\u003eu*w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:-42-.-42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate a linear map on a basis element.\n\u003c/p\u003e",
          "module": "Data.LinearMap",
          "name": "atBasis",
          "package": "vector-space",
          "signature": "(u :-* v) -\u003e Basis u -\u003e v",
          "source": "src/Data-LinearMap.html#atBasis",
          "type": "function"
        },
        "index": {
          "description": "Evaluate linear map on basis element",
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "atBasis",
          "normalized": "(a*b)-\u003eBasis a-\u003eb",
          "package": "vector-space",
          "partial": "Basis",
          "signature": "(u*v)-\u003eBasis u-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:atBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LinearMap",
          "name": "firstL",
          "package": "vector-space",
          "signature": "(u :-* u') -\u003e (u, v) :-* (u', v)",
          "source": "src/Data-LinearMap.html#firstL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "firstL",
          "normalized": "(a*b)-\u003e(a,c)*(b,c)",
          "package": "vector-space",
          "signature": "(u*u')-\u003e(u,v)*(u',v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:firstL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentity linear map\n\u003c/p\u003e",
          "module": "Data.LinearMap",
          "name": "idL",
          "package": "vector-space",
          "signature": "u :-* u",
          "source": "src/Data-LinearMap.html#idL",
          "type": "function"
        },
        "index": {
          "description": "Identity linear map",
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "idL",
          "package": "vector-space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:idL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LinearMap",
          "name": "inLMap",
          "package": "vector-space",
          "signature": "(LMap' r s -\u003e LMap' t u) -\u003e (r :-* s) -\u003e t :-* u",
          "source": "src/Data-LinearMap.html#inLMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "inLMap",
          "normalized": "(LMap' a b-\u003eLMap' c d)-\u003e(a*b)-\u003ec*d",
          "package": "vector-space",
          "partial": "LMap",
          "signature": "(LMap' r s-\u003eLMap' t u)-\u003e(r*s)-\u003et*u",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:inLMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LinearMap",
          "name": "inLMap2",
          "package": "vector-space",
          "signature": "(LMap' r s -\u003e LMap' t u -\u003e LMap' v w) -\u003e (r :-* s) -\u003e (t :-* u) -\u003e v :-* w",
          "source": "src/Data-LinearMap.html#inLMap2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "inLMap2",
          "normalized": "(LMap' a b-\u003eLMap' c d-\u003eLMap' e f)-\u003e(a*b)-\u003e(c*d)-\u003ee*f",
          "package": "vector-space",
          "partial": "LMap",
          "signature": "(LMap' r s-\u003eLMap' t u-\u003eLMap' v w)-\u003e(r*s)-\u003e(t*u)-\u003ev*w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:inLMap2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LinearMap",
          "name": "inLMap3",
          "package": "vector-space",
          "signature": "(LMap' r s -\u003e LMap' t u -\u003e LMap' v w -\u003e LMap' x y) -\u003e (r :-* s) -\u003e (t :-* u) -\u003e (v :-* w) -\u003e x :-* y",
          "source": "src/Data-LinearMap.html#inLMap3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "inLMap3",
          "normalized": "(LMap' a b-\u003eLMap' c d-\u003eLMap' e f-\u003eLMap' g h)-\u003e(a*b)-\u003e(c*d)-\u003e(e*f)-\u003eg*h",
          "package": "vector-space",
          "partial": "LMap",
          "signature": "(LMap' r s-\u003eLMap' t u-\u003eLMap' v w-\u003eLMap' x y)-\u003e(r*s)-\u003e(t*u)-\u003e(v*w)-\u003ex*y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:inLMap3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a linear map to a vector.\n\u003c/p\u003e",
          "module": "Data.LinearMap",
          "name": "lapply",
          "package": "vector-space",
          "signature": "(u :-* v) -\u003e u -\u003e v",
          "source": "src/Data-LinearMap.html#lapply",
          "type": "function"
        },
        "index": {
          "description": "Apply linear map to vector",
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "lapply",
          "normalized": "(a*b)-\u003ea-\u003eb",
          "package": "vector-space",
          "signature": "(u*v)-\u003eu-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:lapply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a linear function to each element of a linear map.\n \u003ccode\u003eliftL f l == linear f *.* l\u003c/code\u003e, but works more efficiently.\n\u003c/p\u003e",
          "module": "Data.LinearMap",
          "name": "liftL",
          "package": "vector-space",
          "signature": "(a -\u003e b) -\u003e MSum (f a) -\u003e MSum (f b)",
          "source": "src/Data-LinearMap.html#liftL",
          "type": "function"
        },
        "index": {
          "description": "Apply linear function to each element of linear map liftL linear but works more efficiently",
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "liftL",
          "normalized": "(a-\u003eb)-\u003eMSum(c a)-\u003eMSum(c b)",
          "package": "vector-space",
          "signature": "(a-\u003eb)-\u003eMSum(f a)-\u003eMSum(f b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:liftL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a linear binary function (not to be confused with a bilinear\n function) to each element of a linear map.\n\u003c/p\u003e",
          "module": "Data.LinearMap",
          "name": "liftL2",
          "package": "vector-space",
          "signature": "(a -\u003e b -\u003e c) -\u003e MSum (f a) -\u003e MSum (f b) -\u003e MSum (f c)",
          "source": "src/Data-LinearMap.html#liftL2",
          "type": "function"
        },
        "index": {
          "description": "Apply linear binary function not to be confused with bilinear function to each element of linear map",
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "liftL2",
          "normalized": "(a-\u003eb-\u003ec)-\u003eMSum(d a)-\u003eMSum(d b)-\u003eMSum(d c)",
          "package": "vector-space",
          "signature": "(a-\u003eb-\u003ec)-\u003eMSum(f a)-\u003eMSum(f b)-\u003eMSum(f c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:liftL2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a linear ternary function (not to be confused with a trilinear\n function) to each element of a linear map.\n\u003c/p\u003e",
          "module": "Data.LinearMap",
          "name": "liftL3",
          "package": "vector-space",
          "signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e MSum (f a) -\u003e MSum (f b) -\u003e MSum (f c) -\u003e MSum (f d)",
          "source": "src/Data-LinearMap.html#liftL3",
          "type": "function"
        },
        "index": {
          "description": "Apply linear ternary function not to be confused with trilinear function to each element of linear map",
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "liftL3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eMSum(e a)-\u003eMSum(e b)-\u003eMSum(e c)-\u003eMSum(e d)",
          "package": "vector-space",
          "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eMSum(f a)-\u003eMSum(f b)-\u003eMSum(f c)-\u003eMSum(f d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:liftL3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LinearMap",
          "name": "liftMS",
          "package": "vector-space",
          "signature": "(a -\u003e b) -\u003e MSum a -\u003e MSum b",
          "source": "src/Data-LinearMap.html#liftMS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "liftMS",
          "normalized": "(a-\u003eb)-\u003eMSum a-\u003eMSum b",
          "package": "vector-space",
          "partial": "MS",
          "signature": "(a-\u003eb)-\u003eMSum a-\u003eMSum b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:liftMS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LinearMap",
          "name": "liftMS2",
          "package": "vector-space",
          "signature": "(a -\u003e b -\u003e c) -\u003e MSum a -\u003e MSum b -\u003e MSum c",
          "source": "src/Data-LinearMap.html#liftMS2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "liftMS2",
          "normalized": "(a-\u003eb-\u003ec)-\u003eMSum a-\u003eMSum b-\u003eMSum c",
          "package": "vector-space",
          "partial": "MS",
          "signature": "(a-\u003eb-\u003ec)-\u003eMSum a-\u003eMSum b-\u003eMSum c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:liftMS2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.LinearMap",
          "name": "liftMS3",
          "package": "vector-space",
          "signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e MSum a -\u003e MSum b -\u003e MSum c -\u003e MSum d",
          "source": "src/Data-LinearMap.html#liftMS3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "liftMS3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eMSum a-\u003eMSum b-\u003eMSum c-\u003eMSum d",
          "package": "vector-space",
          "partial": "MS",
          "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eMSum a-\u003eMSum b-\u003eMSum c-\u003eMSum d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:liftMS3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction (assumed linear) as linear map.\n\u003c/p\u003e",
          "module": "Data.LinearMap",
          "name": "linear",
          "package": "vector-space",
          "signature": "(u -\u003e v) -\u003e u :-* v",
          "source": "src/Data-LinearMap.html#linear",
          "type": "function"
        },
        "index": {
          "description": "Function assumed linear as linear map",
          "hierarchy": "Data LinearMap",
          "module": "Data.LinearMap",
          "name": "linear",
          "normalized": "(a-\u003eb)-\u003ea*b",
          "package": "vector-space",
          "signature": "(u-\u003ev)-\u003eu*v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInfinite derivative towers via linear maps, using the Maclaurin\n representation.  See blog posts \u003ca\u003ehttp://conal.net/blog/tag/derivatives/\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Maclaurin",
          "name": "Maclaurin",
          "package": "vector-space",
          "source": "src/Data-Maclaurin.html",
          "type": "module"
        },
        "index": {
          "description": "Infinite derivative towers via linear maps using the Maclaurin representation See blog posts http conal.net blog tag derivatives",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "Maclaurin",
          "package": "vector-space",
          "partial": "Maclaurin",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInfinitely differentiable functions\n\u003c/p\u003e",
          "module": "Data.Maclaurin",
          "name": ":~\u003e",
          "package": "vector-space",
          "source": "src/Data-Maclaurin.html#%3A~%3E",
          "type": "type"
        },
        "index": {
          "description": "Infinitely differentiable functions",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": ":~\u003e",
          "package": "vector-space",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#t::-126--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTower of derivatives.\n\u003c/p\u003e",
          "module": "Data.Maclaurin",
          "name": ":\u003e",
          "package": "vector-space",
          "source": "src/Data-Maclaurin.html#%3A%3E",
          "type": "data"
        },
        "index": {
          "description": "Tower of derivatives",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": ":\u003e",
          "package": "vector-space",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#t::-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap a \u003cem\u003elinear\u003c/em\u003e function over a derivative tower.\n\u003c/p\u003e",
          "module": "Data.Maclaurin",
          "name": "(\u003c$\u003e\u003e)",
          "package": "vector-space",
          "signature": "(b -\u003e c) -\u003e (a :\u003e b) -\u003e a :\u003e c",
          "source": "src/Data-Maclaurin.html#%3C%24%3E%3E",
          "type": "function"
        },
        "index": {
          "description": "Map linear function over derivative tower",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "(\u003c$\u003e\u003e) \u003c$\u003e\u003e",
          "normalized": "(a-\u003eb)-\u003e(c a)-\u003ec b",
          "package": "vector-space",
          "signature": "(b-\u003ec)-\u003e(a b)-\u003ea c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:-60--36--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecialized chain rule.  See also '(@.)'\n\u003c/p\u003e",
          "module": "Data.Maclaurin",
          "name": "(\u003e-\u003c)",
          "package": "vector-space",
          "signature": "(u -\u003e u) -\u003e ((a :\u003e u) -\u003e a :\u003e Scalar u) -\u003e (a :\u003e u) -\u003e a :\u003e u",
          "source": "src/Data-Maclaurin.html#%3E-%3C",
          "type": "function"
        },
        "index": {
          "description": "Specialized chain rule See also",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "(\u003e-\u003c) \u003e-\u003c",
          "normalized": "(a-\u003ea)-\u003e((b a)-\u003eb Scalar a)-\u003e(b a)-\u003eb a",
          "package": "vector-space",
          "signature": "(u-\u003eu)-\u003e((a u)-\u003ea Scalar u)-\u003e(a u)-\u003ea u",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:-62--45--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Maclaurin",
          "name": "D",
          "package": "vector-space",
          "signature": "D",
          "source": "src/Data-Maclaurin.html#%3A%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "D",
          "package": "vector-space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSample the derivative at a basis element.  Optimized for partial\n application to save work for non-scalar derivatives.\n\u003c/p\u003e",
          "module": "Data.Maclaurin",
          "name": "derivAtBasis",
          "package": "vector-space",
          "signature": "(a :\u003e b) -\u003e Basis a -\u003e a :\u003e b",
          "source": "src/Data-Maclaurin.html#derivAtBasis",
          "type": "function"
        },
        "index": {
          "description": "Sample the derivative at basis element Optimized for partial application to save work for non-scalar derivatives",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "derivAtBasis",
          "normalized": "(a b)-\u003eBasis a-\u003ea b",
          "package": "vector-space",
          "partial": "At Basis",
          "signature": "(a b)-\u003eBasis a-\u003ea b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:derivAtBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Maclaurin",
          "name": "derivative",
          "package": "vector-space",
          "signature": "a :-* (a :\u003e b)",
          "source": "src/Data-Maclaurin.html#%3A%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "derivative",
          "package": "vector-space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:derivative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerivative tower for applying a binary function that distributes over\n addition, such as multiplication.  A bit weaker assumption than\n bilinearity.  Is bilinearity necessary for correctness here?\n\u003c/p\u003e",
          "module": "Data.Maclaurin",
          "name": "distrib",
          "package": "vector-space",
          "signature": "(b -\u003e c -\u003e u) -\u003e (a :\u003e b) -\u003e (a :\u003e c) -\u003e a :\u003e u",
          "source": "src/Data-Maclaurin.html#distrib",
          "type": "function"
        },
        "index": {
          "description": "Derivative tower for applying binary function that distributes over addition such as multiplication bit weaker assumption than bilinearity Is bilinearity necessary for correctness here",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "distrib",
          "normalized": "(a-\u003eb-\u003ec)-\u003e(d a)-\u003e(d b)-\u003ed c",
          "package": "vector-space",
          "signature": "(b-\u003ec-\u003eu)-\u003e(a b)-\u003e(a c)-\u003ea u",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:distrib"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap a \u003cem\u003elinear\u003c/em\u003e function over a derivative tower.\n\u003c/p\u003e",
          "module": "Data.Maclaurin",
          "name": "fmapD",
          "package": "vector-space",
          "signature": "(b -\u003e c) -\u003e (a :\u003e b) -\u003e a :\u003e c",
          "source": "src/Data-Maclaurin.html#fmapD",
          "type": "function"
        },
        "index": {
          "description": "Map linear function over derivative tower",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "fmapD",
          "normalized": "(a-\u003eb)-\u003e(c a)-\u003ec b",
          "package": "vector-space",
          "signature": "(b-\u003ec)-\u003e(a b)-\u003ea c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:fmapD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDifferentiable version of \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Maclaurin",
          "name": "fstD",
          "package": "vector-space",
          "signature": "(a, b) :~\u003e a",
          "source": "src/Data-Maclaurin.html#fstD",
          "type": "function"
        },
        "index": {
          "description": "Differentiable version of fst",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "fstD",
          "normalized": "(a,b)a",
          "package": "vector-space",
          "signature": "(a,b)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:fstD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDifferentiable identity function.  Sometimes called \u003ca\u003ethe\n derivation variable\u003c/a\u003e or similar, but it's not really a variable.\n\u003c/p\u003e",
          "module": "Data.Maclaurin",
          "name": "idD",
          "package": "vector-space",
          "signature": "u :~\u003e u",
          "source": "src/Data-Maclaurin.html#idD",
          "type": "function"
        },
        "index": {
          "description": "Differentiable identity function Sometimes called the derivation variable or similar but it not really variable",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "idD",
          "package": "vector-space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:idD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a \u003cem\u003elinear\u003c/em\u003e binary function over derivative towers.\n\u003c/p\u003e",
          "module": "Data.Maclaurin",
          "name": "liftD2",
          "package": "vector-space",
          "signature": "(b -\u003e c -\u003e d) -\u003e (a :\u003e b) -\u003e (a :\u003e c) -\u003e a :\u003e d",
          "source": "src/Data-Maclaurin.html#liftD2",
          "type": "function"
        },
        "index": {
          "description": "Apply linear binary function over derivative towers",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "liftD2",
          "normalized": "(a-\u003eb-\u003ec)-\u003e(d a)-\u003e(d b)-\u003ed c",
          "package": "vector-space",
          "signature": "(b-\u003ec-\u003ed)-\u003e(a b)-\u003e(a c)-\u003ea d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:liftD2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a \u003cem\u003elinear\u003c/em\u003e ternary function over derivative towers.\n\u003c/p\u003e",
          "module": "Data.Maclaurin",
          "name": "liftD3",
          "package": "vector-space",
          "signature": "(b -\u003e c -\u003e d -\u003e e) -\u003e (a :\u003e b) -\u003e (a :\u003e c) -\u003e (a :\u003e d) -\u003e a :\u003e e",
          "source": "src/Data-Maclaurin.html#liftD3",
          "type": "function"
        },
        "index": {
          "description": "Apply linear ternary function over derivative towers",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "liftD3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003e(e a)-\u003e(e b)-\u003e(e c)-\u003ee d",
          "package": "vector-space",
          "signature": "(b-\u003ec-\u003ed-\u003ee)-\u003e(a b)-\u003e(a c)-\u003e(a d)-\u003ea e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:liftD3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery linear function has a constant derivative equal to the function\n itself (as a linear map).\n\u003c/p\u003e",
          "module": "Data.Maclaurin",
          "name": "linearD",
          "package": "vector-space",
          "signature": "(u -\u003e v) -\u003e u :~\u003e v",
          "source": "src/Data-Maclaurin.html#linearD",
          "type": "function"
        },
        "index": {
          "description": "Every linear function has constant derivative equal to the function itself as linear map",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "linearD",
          "normalized": "(a-\u003eb)-\u003ea b",
          "package": "vector-space",
          "signature": "(u-\u003ev)-\u003eu v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:linearD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Maclaurin",
          "name": "pairD",
          "package": "vector-space",
          "signature": "(a :\u003e b, a :\u003e c) -\u003e a :\u003e (b, c)",
          "source": "src/Data-Maclaurin.html#pairD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "pairD",
          "normalized": "(a b,a c)-\u003ea(b,c)",
          "package": "vector-space",
          "signature": "(a b,a c)-\u003ea(b,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:pairD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Maclaurin",
          "name": "powVal",
          "package": "vector-space",
          "signature": "b",
          "source": "src/Data-Maclaurin.html#%3A%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "powVal",
          "package": "vector-space",
          "partial": "Val",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:powVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstant derivative tower.\n\u003c/p\u003e",
          "module": "Data.Maclaurin",
          "name": "pureD",
          "package": "vector-space",
          "signature": "b -\u003e a :\u003e b",
          "source": "src/Data-Maclaurin.html#pureD",
          "type": "function"
        },
        "index": {
          "description": "Constant derivative tower",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "pureD",
          "normalized": "a-\u003eb a",
          "package": "vector-space",
          "signature": "b-\u003ea b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:pureD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDifferentiable version of \u003ccode\u003e\u003ca\u003esnd\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Maclaurin",
          "name": "sndD",
          "package": "vector-space",
          "signature": "(a, b) :~\u003e b",
          "source": "src/Data-Maclaurin.html#sndD",
          "type": "function"
        },
        "index": {
          "description": "Differentiable version of snd",
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "sndD",
          "normalized": "(a,b)b",
          "package": "vector-space",
          "signature": "(a,b)b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:sndD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Maclaurin",
          "name": "tripleD",
          "package": "vector-space",
          "signature": "(a :\u003e b, a :\u003e c, a :\u003e d) -\u003e a :\u003e (b, c, d)",
          "source": "src/Data-Maclaurin.html#tripleD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "tripleD",
          "normalized": "(a b,a c,a d)-\u003ea(b,c,d)",
          "package": "vector-space",
          "signature": "(a b,a c,a d)-\u003ea(b,c,d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:tripleD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Maclaurin",
          "name": "unpairD",
          "package": "vector-space",
          "signature": "(a :\u003e (b, c)) -\u003e (a :\u003e b, a :\u003e c)",
          "source": "src/Data-Maclaurin.html#unpairD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "unpairD",
          "normalized": "(a(b,c))-\u003e(a b,a c)",
          "package": "vector-space",
          "signature": "(a(b,c))-\u003e(a b,a c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:unpairD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Maclaurin",
          "name": "untripleD",
          "package": "vector-space",
          "signature": "(a :\u003e (b, c, d)) -\u003e (a :\u003e b, a :\u003e c, a :\u003e d)",
          "source": "src/Data-Maclaurin.html#untripleD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Maclaurin",
          "module": "Data.Maclaurin",
          "name": "untripleD",
          "normalized": "(a(b,c,d))-\u003e(a b,a c,a d)",
          "package": "vector-space",
          "signature": "(a(b,c,d))-\u003e(a b,a c,a d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:untripleD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVector spaces\n\u003c/p\u003e\u003cp\u003eThis version uses associated types instead of fundeps and\n requires ghc-6.10 or later\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.VectorSpace",
          "name": "VectorSpace",
          "package": "vector-space",
          "source": "src/Data-VectorSpace.html",
          "type": "module"
        },
        "index": {
          "description": "Vector spaces This version uses associated types instead of fundeps and requires ghc-6.10 or later",
          "hierarchy": "Data VectorSpace",
          "module": "Data.VectorSpace",
          "name": "VectorSpace",
          "package": "vector-space",
          "partial": "Vector Space",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdds inner (dot) products.\n\u003c/p\u003e",
          "module": "Data.VectorSpace",
          "name": "InnerSpace",
          "package": "vector-space",
          "source": "src/Data-VectorSpace.html#InnerSpace",
          "type": "class"
        },
        "index": {
          "description": "Adds inner dot products",
          "hierarchy": "Data VectorSpace",
          "module": "Data.VectorSpace",
          "name": "InnerSpace",
          "package": "vector-space",
          "partial": "Inner Space",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#t:InnerSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVector space \u003ccode\u003ev\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.VectorSpace",
          "name": "VectorSpace",
          "package": "vector-space",
          "source": "src/Data-VectorSpace.html#VectorSpace",
          "type": "class"
        },
        "index": {
          "description": "Vector space",
          "hierarchy": "Data VectorSpace",
          "module": "Data.VectorSpace",
          "name": "VectorSpace",
          "package": "vector-space",
          "partial": "Vector Space",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#t:VectorSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale a vector\n\u003c/p\u003e",
          "module": "Data.VectorSpace",
          "name": "(*^)",
          "package": "vector-space",
          "signature": "Scalar v -\u003e v -\u003e v",
          "source": "src/Data-VectorSpace.html#%2A%5E",
          "type": "method"
        },
        "index": {
          "description": "Scale vector",
          "hierarchy": "Data VectorSpace",
          "module": "Data.VectorSpace",
          "name": "(*^) *^",
          "normalized": "Scalar a-\u003ea-\u003ea",
          "package": "vector-space",
          "signature": "Scalar v-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:-42--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInner/dot product\n\u003c/p\u003e",
          "module": "Data.VectorSpace",
          "name": "(\u003c.\u003e)",
          "package": "vector-space",
          "signature": "v -\u003e v -\u003e Scalar v",
          "source": "src/Data-VectorSpace.html#%3C.%3E",
          "type": "method"
        },
        "index": {
          "description": "Inner dot product",
          "hierarchy": "Data VectorSpace",
          "module": "Data.VectorSpace",
          "name": "(\u003c.\u003e) \u003c.\u003e",
          "normalized": "a-\u003ea-\u003eScalar a",
          "package": "vector-space",
          "signature": "v-\u003ev-\u003eScalar v",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:-60-.-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVector multiplied by scalar\n\u003c/p\u003e",
          "module": "Data.VectorSpace",
          "name": "(^*)",
          "package": "vector-space",
          "signature": "v -\u003e s -\u003e v",
          "source": "src/Data-VectorSpace.html#%5E%2A",
          "type": "function"
        },
        "index": {
          "description": "Vector multiplied by scalar",
          "hierarchy": "Data VectorSpace",
          "module": "Data.VectorSpace",
          "name": "(^*) ^*",
          "normalized": "a-\u003eb-\u003ea",
          "package": "vector-space",
          "signature": "v-\u003es-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:-94--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVector divided by scalar\n\u003c/p\u003e",
          "module": "Data.VectorSpace",
          "name": "(^/)",
          "package": "vector-space",
          "signature": "v -\u003e s -\u003e v",
          "source": "src/Data-VectorSpace.html#%5E%2F",
          "type": "function"
        },
        "index": {
          "description": "Vector divided by scalar",
          "hierarchy": "Data VectorSpace",
          "module": "Data.VectorSpace",
          "name": "(^/) ^/",
          "normalized": "a-\u003eb-\u003ea",
          "package": "vector-space",
          "signature": "v-\u003es-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:-94--47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLinear interpolation between \u003ccode\u003ea\u003c/code\u003e (when \u003ccode\u003et==0\u003c/code\u003e) and \u003ccode\u003eb\u003c/code\u003e (when \u003ccode\u003et==1\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Data.VectorSpace",
          "name": "lerp",
          "package": "vector-space",
          "signature": "v -\u003e v -\u003e Scalar v -\u003e v",
          "source": "src/Data-VectorSpace.html#lerp",
          "type": "function"
        },
        "index": {
          "description": "Linear interpolation between when and when",
          "hierarchy": "Data VectorSpace",
          "module": "Data.VectorSpace",
          "name": "lerp",
          "normalized": "a-\u003ea-\u003eScalar a-\u003ea",
          "package": "vector-space",
          "signature": "v-\u003ev-\u003eScalar v-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:lerp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLength of a vector.   See also \u003ccode\u003e\u003ca\u003emagnitudeSq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.VectorSpace",
          "name": "magnitude",
          "package": "vector-space",
          "signature": "v -\u003e s",
          "source": "src/Data-VectorSpace.html#magnitude",
          "type": "function"
        },
        "index": {
          "description": "Length of vector See also magnitudeSq",
          "hierarchy": "Data VectorSpace",
          "module": "Data.VectorSpace",
          "name": "magnitude",
          "normalized": "a-\u003eb",
          "package": "vector-space",
          "signature": "v-\u003es",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:magnitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSquare of the length of a vector.  Sometimes useful for efficiency.\n See also \u003ccode\u003e\u003ca\u003emagnitude\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.VectorSpace",
          "name": "magnitudeSq",
          "package": "vector-space",
          "signature": "v -\u003e s",
          "source": "src/Data-VectorSpace.html#magnitudeSq",
          "type": "function"
        },
        "index": {
          "description": "Square of the length of vector Sometimes useful for efficiency See also magnitude",
          "hierarchy": "Data VectorSpace",
          "module": "Data.VectorSpace",
          "name": "magnitudeSq",
          "normalized": "a-\u003eb",
          "package": "vector-space",
          "partial": "Sq",
          "signature": "v-\u003es",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:magnitudeSq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVector in same direction as given one but with length of one.  If\n given the zero vector, then return it.\n\u003c/p\u003e",
          "module": "Data.VectorSpace",
          "name": "normalized",
          "package": "vector-space",
          "signature": "v -\u003e v",
          "source": "src/Data-VectorSpace.html#normalized",
          "type": "function"
        },
        "index": {
          "description": "Vector in same direction as given one but with length of one If given the zero vector then return it",
          "hierarchy": "Data VectorSpace",
          "module": "Data.VectorSpace",
          "name": "normalized",
          "normalized": "a-\u003ea",
          "package": "vector-space",
          "signature": "v-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:normalized"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eproject u v\u003c/code\u003e computes the projection of \u003ccode\u003ev\u003c/code\u003e onto \u003ccode\u003eu\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.VectorSpace",
          "name": "project",
          "package": "vector-space",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-VectorSpace.html#project",
          "type": "function"
        },
        "index": {
          "description": "project computes the projection of onto",
          "hierarchy": "Data VectorSpace",
          "module": "Data.VectorSpace",
          "name": "project",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vector-space",
          "signature": "v-\u003ev-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:project"
      }
    }
  ]
]