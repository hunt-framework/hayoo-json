[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "inflist"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList.Arbitrary",
          "name": "Arbitrary",
          "package": "inflist",
          "source": "src/Data-InfList-Arbitrary.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data InfList Arbitrary",
          "module": "Data.InfList.Arbitrary",
          "name": "Arbitrary",
          "package": "inflist",
          "partial": "Arbitrary",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-Arbitrary.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList.Common",
          "name": "Common",
          "package": "inflist",
          "source": "src/Data-InfList-Common.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data InfList Common",
          "module": "Data.InfList.Common",
          "name": "Common",
          "package": "inflist",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList.Common",
          "name": "bells",
          "package": "inflist",
          "signature": "InfList Integer",
          "source": "src/Data-InfList-Common.html#bells",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data InfList Common",
          "module": "Data.InfList.Common",
          "name": "bells",
          "package": "inflist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-Common.html#v:bells"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList.Common",
          "name": "collatz",
          "package": "inflist",
          "signature": "Integer -\u003e InfList Integer",
          "source": "src/Data-InfList-Common.html#collatz",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data InfList Common",
          "module": "Data.InfList.Common",
          "name": "collatz",
          "normalized": "Integer-\u003eInfList Integer",
          "package": "inflist",
          "signature": "Integer-\u003eInfList Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-Common.html#v:collatz"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList.Common",
          "name": "evens",
          "package": "inflist",
          "signature": "InfList Integer",
          "source": "src/Data-InfList-Common.html#evens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data InfList Common",
          "module": "Data.InfList.Common",
          "name": "evens",
          "package": "inflist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-Common.html#v:evens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList.Common",
          "name": "facts",
          "package": "inflist",
          "signature": "InfList Integer",
          "source": "src/Data-InfList-Common.html#facts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data InfList Common",
          "module": "Data.InfList.Common",
          "name": "facts",
          "package": "inflist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-Common.html#v:facts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList.Common",
          "name": "fibs",
          "package": "inflist",
          "signature": "InfList Integer",
          "source": "src/Data-InfList-Common.html#fibs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data InfList Common",
          "module": "Data.InfList.Common",
          "name": "fibs",
          "package": "inflist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-Common.html#v:fibs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList.Common",
          "name": "lucas",
          "package": "inflist",
          "signature": "InfList Integer",
          "source": "src/Data-InfList-Common.html#lucas",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data InfList Common",
          "module": "Data.InfList.Common",
          "name": "lucas",
          "package": "inflist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-Common.html#v:lucas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList.Common",
          "name": "nats",
          "package": "inflist",
          "signature": "InfList Integer",
          "source": "src/Data-InfList-Common.html#nats",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data InfList Common",
          "module": "Data.InfList.Common",
          "name": "nats",
          "package": "inflist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-Common.html#v:nats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList.Common",
          "name": "nats1",
          "package": "inflist",
          "signature": "InfList Integer",
          "source": "src/Data-InfList-Common.html#nats1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data InfList Common",
          "module": "Data.InfList.Common",
          "name": "nats1",
          "package": "inflist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-Common.html#v:nats1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList.Common",
          "name": "odds",
          "package": "inflist",
          "signature": "InfList Integer",
          "source": "src/Data-InfList-Common.html#odds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data InfList Common",
          "module": "Data.InfList.Common",
          "name": "odds",
          "package": "inflist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-Common.html#v:odds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList.Common",
          "name": "pascalTriangle",
          "package": "inflist",
          "signature": "InfList [Integer]",
          "source": "src/Data-InfList-Common.html#pascalTriangle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data InfList Common",
          "module": "Data.InfList.Common",
          "name": "pascalTriangle",
          "normalized": "InfList[Integer]",
          "package": "inflist",
          "partial": "Triangle",
          "signature": "InfList[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-Common.html#v:pascalTriangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList.InfString",
          "name": "InfString",
          "package": "inflist",
          "source": "src/Data-InfList-InfString.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data InfList InfString",
          "module": "Data.InfList.InfString",
          "name": "InfString",
          "package": "inflist",
          "partial": "Inf String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-InfString.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnalogous to the \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e data type.\n\u003c/p\u003e",
          "module": "Data.InfList.InfString",
          "name": "InfString",
          "package": "inflist",
          "source": "src/Data-InfList-InfString.html#InfString",
          "type": "type"
        },
        "index": {
          "description": "Analogous to the String data type",
          "hierarchy": "Data InfList InfString",
          "module": "Data.InfList.InfString",
          "name": "InfString",
          "package": "inflist",
          "partial": "Inf String",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-InfString.html#t:InfString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit an \u003ccode\u003e\u003ca\u003eInfString\u003c/a\u003e\u003c/code\u003e into an infinite list of lines.\n\u003c/p\u003e",
          "module": "Data.InfList.InfString",
          "name": "lines",
          "package": "inflist",
          "signature": "InfString-\u003e InfList String",
          "type": "function"
        },
        "index": {
          "description": "Split an InfString into an infinite list of lines",
          "hierarchy": "Data InfList InfString",
          "module": "Data.InfList.InfString",
          "name": "lines",
          "normalized": "InfString-\u003eInfList String",
          "package": "inflist",
          "signature": "InfString-\u003eInfList String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-InfString.html#v:lines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclaring \u003ccode\u003e\u003ca\u003eInfString\u003c/a\u003e\u003c/code\u003e an instance of \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e results in overlapping\n typeclasses.  We instead use a simple function that converts an \u003ccode\u003e\u003ca\u003eInfString\u003c/a\u003e\u003c/code\u003e\n to an infinite \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.InfList.InfString",
          "name": "showInfString",
          "package": "inflist",
          "signature": "InfString-\u003e String",
          "type": "function"
        },
        "index": {
          "description": "Declaring InfString an instance of Show results in overlapping typeclasses We instead use simple function that converts an InfString to an infinite String",
          "hierarchy": "Data InfList InfString",
          "module": "Data.InfList.InfString",
          "name": "showInfString",
          "normalized": "InfString-\u003eString",
          "package": "inflist",
          "partial": "Inf String",
          "signature": "InfString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-InfString.html#v:showInfString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an \u003ccode\u003e\u003ca\u003eInfString\u003c/a\u003e\u003c/code\u003e to the equivalent infinite \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.InfList.InfString",
          "name": "toString",
          "package": "inflist",
          "signature": "InfString-\u003e String",
          "type": "function"
        },
        "index": {
          "description": "Convert an InfString to the equivalent infinite String",
          "hierarchy": "Data InfList InfString",
          "module": "Data.InfList.InfString",
          "name": "toString",
          "normalized": "InfString-\u003eString",
          "package": "inflist",
          "partial": "String",
          "signature": "InfString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-InfString.html#v:toString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJoin an infinite list of lines into an infinite string.\n\u003c/p\u003e",
          "module": "Data.InfList.InfString",
          "name": "unlines",
          "package": "inflist",
          "signature": "InfList String-\u003e InfString",
          "type": "function"
        },
        "index": {
          "description": "Join an infinite list of lines into an infinite string",
          "hierarchy": "Data InfList InfString",
          "module": "Data.InfList.InfString",
          "name": "unlines",
          "normalized": "InfList String-\u003eInfString",
          "package": "inflist",
          "signature": "InfList String-\u003eInfString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-InfString.html#v:unlines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJoin an infinite list of words into an infinite string.\n A space is inserted between each word.\n\u003c/p\u003e",
          "module": "Data.InfList.InfString",
          "name": "unwords",
          "package": "inflist",
          "signature": "InfList String-\u003e InfString",
          "type": "function"
        },
        "index": {
          "description": "Join an infinite list of words into an infinite string space is inserted between each word",
          "hierarchy": "Data InfList InfString",
          "module": "Data.InfList.InfString",
          "name": "unwords",
          "normalized": "InfList String-\u003eInfString",
          "package": "inflist",
          "signature": "InfList String-\u003eInfString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-InfString.html#v:unwords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit an infinite string by whitespace.\n\u003c/p\u003e",
          "module": "Data.InfList.InfString",
          "name": "words",
          "package": "inflist",
          "signature": "InfString-\u003e InfList String",
          "type": "function"
        },
        "index": {
          "description": "Split an infinite string by whitespace",
          "hierarchy": "Data InfList InfString",
          "module": "Data.InfList.InfString",
          "name": "words",
          "normalized": "InfString-\u003eInfList String",
          "package": "inflist",
          "signature": "InfString-\u003eInfList String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList-InfString.html#v:words"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides an infinite list type and operations thereon.\n\u003c/p\u003e\u003cp\u003eHaskell has two outstanding features:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e laziness, which in particular allows infinite data structures;\n\u003c/li\u003e\u003cli\u003e a very strong type system.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIn that light, it's a bit embarrassing that its default libraries do not allow\n one to express the infinitude of, say, a list.  For example, \u003ccode\u003e\u003ca\u003erepeat\u003c/a\u003e\u003c/code\u003e\n has type \u003ccode\u003ea &#8594; [a]\u003c/code\u003e, when it of course should not return a finite list.\n\u003c/p\u003e\u003cp\u003eThis module defines an infinite list data structure and provides all the\n standard list-manipulating functions that make sense on them.\n The advantages of using this over a standard list are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003cem\u003eType safety and clarity.\u003c/em\u003e\n   We are prevented from using nonsensical functions on infinite lists.\n   These include the functions: \u003ccode\u003e\u003ca\u003elast\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003einit\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003enull\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003escanr\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003eany\u003c/a\u003e\u003c/code\u003e (etc.), \u003ccode\u003e\u003ca\u003eisSuffixOf\u003c/a\u003e\u003c/code\u003e, 'Data.List.(\\)',\n   \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eunionBy\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eintersect\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003eintersectBy\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003etranspose\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003edeleteFirstsBy\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003esubsequences\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003enonEmptySubsequences\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003epermutations\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003esort\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003esortBy\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003esum\u003c/a\u003e\u003c/code\u003e (etc.), \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e (etc.), \u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eelemIndex\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eisInfixOf\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003enub\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eNo pattern-matching on nil\u003c/em\u003e.\n   Where you can identify that \u003ccode\u003e[]\u003c/code\u003e will never be present,\n   using a list forces you to either write clunky error-generating pattern matches,\n   or alternatively put up with compiler warnings about incompete pattern matches.\n   Code is simplified.\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eFaster code.\u003c/em\u003e\n   We do not need or want runtime pattern-matches on a data constructor which\n   will never occur.  Haskell compilers love single-constructor datatypes:\n   \u003ca\u003ehttp://www.haskell.org/haskellwiki/Performance/Data_types#Single-constructor_datatypes\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSee for comparison the \u003ccode\u003e\u003ca\u003eList\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eList\u003c/a\u003e\u003c/code\u003e modules.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.InfList",
          "name": "InfList",
          "package": "inflist",
          "source": "src/Data-InfList.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides an infinite list type and operations thereon Haskell has two outstanding features laziness which in particular allows infinite data structures very strong type system In that light it bit embarrassing that its default libraries do not allow one to express the infinitude of say list For example repeat has type when it of course should not return finite list This module defines an infinite list data structure and provides all the standard list-manipulating functions that make sense on them The advantages of using this over standard list are Type safety and clarity We are prevented from using nonsensical functions on infinite lists These include the functions last init null length foldl scanr scanl replicate reverse any etc isSuffixOf Data.List union unionBy intersect intersectBy transpose deleteFirstsBy subsequences nonEmptySubsequences permutations sort sortBy sum etc elem etc lookup findIndex elemIndex isInfixOf nub No pattern-matching on nil Where you can identify that will never be present using list forces you to either write clunky error-generating pattern matches or alternatively put up with compiler warnings about incompete pattern matches Code is simplified Faster code We do not need or want runtime pattern-matches on data constructor which will never occur Haskell compilers love single-constructor datatypes http www.haskell.org haskellwiki Performance Data types Single-constructor datatypes See for comparison the List and List modules",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "InfList",
          "package": "inflist",
          "partial": "Inf List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe infinite list data type.\n This is identical to the normal list data type\n with the sole exception that it lacks the \u003ccode\u003e[]\u003c/code\u003e constructor.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "InfList",
          "package": "inflist",
          "source": "src/Data-InfList.html#InfList",
          "type": "data"
        },
        "index": {
          "description": "The infinite list data type This is identical to the normal list data type with the sole exception that it lacks the constructor",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "InfList",
          "package": "inflist",
          "partial": "Inf List",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#t:InfList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA simple type synonym for predicates.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "Pred",
          "package": "inflist",
          "source": "src/Data-InfList.html#Pred",
          "type": "type"
        },
        "index": {
          "description": "simple type synonym for predicates",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "Pred",
          "package": "inflist",
          "partial": "Pred",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#t:Pred"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a natural number, get that the element at that index of a given\n infinite list.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "(!!!)",
          "package": "inflist",
          "signature": "InfList a-\u003e Int-\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Given natural number get that the element at that index of given infinite list",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "(!!!) !!!",
          "normalized": "InfList a-\u003eInt-\u003ea",
          "package": "inflist",
          "signature": "InfList a-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:-33--33--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrepend a finite list to a infinite list\n yielding a new infinite list.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "(+++)",
          "package": "inflist",
          "signature": "[a]-\u003e InfList a-\u003e InfList a",
          "type": "function"
        },
        "index": {
          "description": "Prepend finite list to infinite list yielding new infinite list",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "(+++) +++",
          "normalized": "[a]-\u003eInfList a-\u003eInfList a",
          "package": "inflist",
          "signature": "[a]-\u003eInfList a-\u003eInfList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:-43--43--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCons an element onto an infinite list to yield another infinite list.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": ":::",
          "package": "inflist",
          "signature": "(InfList a)",
          "source": "src/Data-InfList.html#InfList",
          "type": "function"
        },
        "index": {
          "description": "Cons an element onto an infinite list to yield another infinite list",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": ":::",
          "package": "inflist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v::::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit an infinite list into a longest prefix such that all the elements of it\n do not satisfy a given predicate, and the rest of the list following them.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "break",
          "package": "inflist",
          "signature": "Pred a-\u003e InfList a-\u003e ([a], InfList a)",
          "type": "function"
        },
        "index": {
          "description": "Split an infinite list into longest prefix such that all the elements of it do not satisfy given predicate and the rest of the list following them",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "break",
          "normalized": "Pred a-\u003eInfList a-\u003e([a],InfList a)",
          "package": "inflist",
          "signature": "Pred a-\u003eInfList a-\u003e([a],InfList a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:break"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConcatenate an infinite list of finite lists into an infinite list of\n elements. That is, remove one level of nesting.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "concat",
          "package": "inflist",
          "signature": "InfList [a]-\u003e InfList a",
          "type": "function"
        },
        "index": {
          "description": "Concatenate an infinite list of finite lists into an infinite list of elements That is remove one level of nesting",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "concat",
          "normalized": "InfList[a]-\u003eInfList a",
          "package": "inflist",
          "signature": "InfList[a]-\u003eInfList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpand all elements of an infinite list into finite lists and concatenate them.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "concatMap",
          "package": "inflist",
          "signature": "(a -\u003e [b])-\u003e InfList a-\u003e InfList b",
          "type": "function"
        },
        "index": {
          "description": "Expand all elements of an infinite list into finite lists and concatenate them",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "concatMap",
          "normalized": "(a-\u003e[b])-\u003eInfList a-\u003eInfList b",
          "package": "inflist",
          "partial": "Map",
          "signature": "(a-\u003e[b])-\u003eInfList a-\u003eInfList b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:concatMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepeat the elements of a non-empty finite list.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "cycle",
          "package": "inflist",
          "signature": "[a]-\u003e InfList a",
          "type": "function"
        },
        "index": {
          "description": "Repeat the elements of non-empty finite list",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "cycle",
          "normalized": "[a]-\u003eInfList a",
          "package": "inflist",
          "signature": "[a]-\u003eInfList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete the first element equal to a given element.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "delete",
          "package": "inflist",
          "signature": "a-\u003e InfList a-\u003e InfList a",
          "type": "function"
        },
        "index": {
          "description": "Delete the first element equal to given element",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "delete",
          "normalized": "a-\u003eInfList a-\u003eInfList a",
          "package": "inflist",
          "signature": "a-\u003eInfList a-\u003eInfList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete the first element satisfying a given predicate.\n Notice that this is not the same as \u003ccode\u003e\u003ca\u003edeleteBy\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "deleteBy",
          "package": "inflist",
          "signature": "Pred a-\u003e InfList a-\u003e InfList a",
          "type": "function"
        },
        "index": {
          "description": "Delete the first element satisfying given predicate Notice that this is not the same as deleteBy",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "deleteBy",
          "normalized": "Pred a-\u003eInfList a-\u003eInfList a",
          "package": "inflist",
          "partial": "By",
          "signature": "Pred a-\u003eInfList a-\u003eInfList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:deleteBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a natural number, drop that many elements from the start of an infinite list.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "drop",
          "package": "inflist",
          "signature": "Int-\u003e InfList a-\u003e InfList a",
          "type": "function"
        },
        "index": {
          "description": "Given natural number drop that many elements from the start of an infinite list",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "drop",
          "normalized": "Int-\u003eInfList a-\u003eInfList a",
          "package": "inflist",
          "signature": "Int-\u003eInfList a-\u003eInfList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove the longest prefix of an infinite list\n where all elements of that prefix satisfy a given predicate.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "dropWhile",
          "package": "inflist",
          "signature": "Pred a-\u003e InfList a-\u003e InfList a",
          "type": "function"
        },
        "index": {
          "description": "Remove the longest prefix of an infinite list where all elements of that prefix satisfy given predicate",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "dropWhile",
          "normalized": "Pred a-\u003eInfList a-\u003eInfList a",
          "package": "inflist",
          "partial": "While",
          "signature": "Pred a-\u003eInfList a-\u003eInfList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:dropWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the indices into an infinite list where each element at that index\n is equal to the given element.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "elemIndices",
          "package": "inflist",
          "signature": "a-\u003e InfList a-\u003e InfList Int",
          "type": "function"
        },
        "index": {
          "description": "Get the indices into an infinite list where each element at that index is equal to the given element",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "elemIndices",
          "normalized": "a-\u003eInfList a-\u003eInfList Int",
          "package": "inflist",
          "partial": "Indices",
          "signature": "a-\u003eInfList a-\u003eInfList Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:elemIndices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect the elements of a list that satisfy a predicate.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "filter",
          "package": "inflist",
          "signature": "Pred a-\u003e InfList a-\u003e InfList a",
          "type": "function"
        },
        "index": {
          "description": "Select the elements of list that satisfy predicate",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "filter",
          "normalized": "Pred a-\u003eInfList a-\u003eInfList a",
          "package": "inflist",
          "signature": "Pred a-\u003eInfList a-\u003eInfList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the indices into an infinite list where each element at that index\n satisfies a given predicate.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "findIndices",
          "package": "inflist",
          "signature": "Pred a-\u003e InfList a-\u003e InfList Int",
          "type": "function"
        },
        "index": {
          "description": "Get the indices into an infinite list where each element at that index satisfies given predicate",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "findIndices",
          "normalized": "Pred a-\u003eInfList a-\u003eInfList Int",
          "package": "inflist",
          "partial": "Indices",
          "signature": "Pred a-\u003eInfList a-\u003eInfList Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:findIndices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCatamorphism.\n This is not the same as \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e on lists,\n as it contains no base value.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "foldr",
          "package": "inflist",
          "signature": "(a -\u003e b -\u003e b)-\u003e InfList a-\u003e b",
          "type": "function"
        },
        "index": {
          "description": "Catamorphism This is not the same as foldr on lists as it contains no base value",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "foldr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eInfList a-\u003eb",
          "package": "inflist",
          "signature": "(a-\u003eb-\u003eb)-\u003eInfList a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:foldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an infinite list to an \u003ccode\u003e\u003ca\u003eInfList\u003c/a\u003e\u003c/code\u003e.\n Throws an error if the given list runs out of elements.\n Use sparingly.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "fromList",
          "package": "inflist",
          "signature": "[a]-\u003e InfList a",
          "type": "function"
        },
        "index": {
          "description": "Convert an infinite list to an InfList Throws an error if the given list runs out of elements Use sparingly",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "fromList",
          "normalized": "[a]-\u003eInfList a",
          "package": "inflist",
          "partial": "List",
          "signature": "[a]-\u003eInfList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven an infinite list, split it into maximal-length finite lists where\n every element in each list is equal.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "group",
          "package": "inflist",
          "signature": "InfList a-\u003e InfList [a]",
          "type": "function"
        },
        "index": {
          "description": "Given an infinite list split it into maximal-length finite lists where every element in each list is equal",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "group",
          "normalized": "InfList a-\u003eInfList[a]",
          "package": "inflist",
          "signature": "InfList a-\u003eInfList[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:group"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a predicate over two elements, split an infinite list of elements\n of that type into maximal-length finite lists where each adjacent pair of\n elements in each list satisfies the predicate in that order.\n\u003c/p\u003e\u003cp\u003eIn practise, the predicate is associative and commutative, e.g. an equality\n relation, as used in the \u003ccode\u003e\u003ca\u003egroup\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "groupBy",
          "package": "inflist",
          "signature": "(a -\u003e a -\u003e Bool)-\u003e InfList a-\u003e InfList [a]",
          "type": "function"
        },
        "index": {
          "description": "Given predicate over two elements split an infinite list of elements of that type into maximal-length finite lists where each adjacent pair of elements in each list satisfies the predicate in that order In practise the predicate is associative and commutative e.g an equality relation as used in the group function",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "groupBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eInfList a-\u003eInfList[a]",
          "package": "inflist",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003eInfList a-\u003eInfList[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:groupBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the first element of a list.\n This is guaranteed to exist.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "head",
          "package": "inflist",
          "signature": "InfList a-\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Get the first element of list This is guaranteed to exist",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "head",
          "normalized": "InfList a-\u003ea",
          "package": "inflist",
          "signature": "InfList a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList the prefixes of an infinite list in ascending order of length.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "inits",
          "package": "inflist",
          "signature": "InfList a-\u003e InfList [a]",
          "type": "function"
        },
        "index": {
          "description": "List the prefixes of an infinite list in ascending order of length",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "inits",
          "normalized": "InfList a-\u003eInfList[a]",
          "package": "inflist",
          "signature": "InfList a-\u003eInfList[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:inits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven an infinite list of finite lists, intersperse the infinite list with\n a given finite list, and concatenate it.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "intercalate",
          "package": "inflist",
          "signature": "[a]-\u003e InfList [a]-\u003e InfList a",
          "type": "function"
        },
        "index": {
          "description": "Given an infinite list of finite lists intersperse the infinite list with given finite list and concatenate it",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "intercalate",
          "normalized": "[a]-\u003eInfList[a]-\u003eInfList a",
          "package": "inflist",
          "signature": "[a]-\u003eInfList[a]-\u003eInfList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:intercalate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePlace a given element between every adjacent two elements of a given\n infinite list.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "intersperse",
          "package": "inflist",
          "signature": "a-\u003e InfList a-\u003e InfList a",
          "type": "function"
        },
        "index": {
          "description": "Place given element between every adjacent two elements of given infinite list",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "intersperse",
          "normalized": "a-\u003eInfList a-\u003eInfList a",
          "package": "inflist",
          "signature": "a-\u003eInfList a-\u003eInfList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:intersperse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs a given finite list a prefix of a given infinite list?\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "isPrefixOf",
          "package": "inflist",
          "signature": "[a]-\u003e InfList a-\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "Is given finite list prefix of given infinite list",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "isPrefixOf",
          "normalized": "[a]-\u003eInfList a-\u003eBool",
          "package": "inflist",
          "partial": "Prefix Of",
          "signature": "[a]-\u003eInfList a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:isPrefixOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepeatedly apply a generating function on an initial value,\n generating an infinite list.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "iterate",
          "package": "inflist",
          "signature": "(a -\u003e a)-\u003e a-\u003e InfList a",
          "type": "function"
        },
        "index": {
          "description": "Repeatedly apply generating function on an initial value generating an infinite list",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "iterate",
          "normalized": "(a-\u003ea)-\u003ea-\u003eInfList a",
          "package": "inflist",
          "signature": "(a-\u003ea)-\u003ea-\u003eInfList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:iterate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a function to each element of the list,\n yielding a new list of the results.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "map",
          "package": "inflist",
          "signature": "(a -\u003e b)-\u003e InfList a-\u003e InfList b",
          "type": "function"
        },
        "index": {
          "description": "Apply function to each element of the list yielding new list of the results",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003eInfList a-\u003eInfList b",
          "package": "inflist",
          "signature": "(a-\u003eb)-\u003eInfList a-\u003eInfList b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplies a function to each element of a list, passing an accumulating\n parameter from left to right, returning a new list.\n This is not quite the same as \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e: there is no final\n accumulator returned.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "mapAccumL",
          "package": "inflist",
          "signature": "(acc -\u003e a -\u003e (acc, b))-\u003e acc-\u003e InfList a-\u003e InfList b",
          "type": "function"
        },
        "index": {
          "description": "Applies function to each element of list passing an accumulating parameter from left to right returning new list This is not quite the same as mapAccumL there is no final accumulator returned",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "mapAccumL",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eInfList b-\u003eInfList c",
          "package": "inflist",
          "partial": "Accum",
          "signature": "(acc-\u003ea-\u003e(acc,b))-\u003eacc-\u003eInfList a-\u003eInfList b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:mapAccumL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a predicate and an infinite list, return a pair of\n infinite lists of elements which do and do not satisfy the\n predicate, respectively.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "partition",
          "package": "inflist",
          "signature": "Pred a-\u003e InfList a-\u003e (InfList a, InfList a)",
          "type": "function"
        },
        "index": {
          "description": "Given predicate and an infinite list return pair of infinite lists of elements which do and do not satisfy the predicate respectively",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "partition",
          "normalized": "Pred a-\u003eInfList a-\u003e(InfList a,InfList a)",
          "package": "inflist",
          "signature": "Pred a-\u003eInfList a-\u003e(InfList a,InfList a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:partition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list element, use that as every element in an infinite list.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "repeat",
          "package": "inflist",
          "signature": "a-\u003e InfList a",
          "type": "function"
        },
        "index": {
          "description": "Given list element use that as every element in an infinite list",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "repeat",
          "normalized": "a-\u003eInfList a",
          "package": "inflist",
          "signature": "a-\u003eInfList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit an infinite list into a longest prefix such that all the elements of it\n satisfy a given predicate, and the rest of the list following them.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "span",
          "package": "inflist",
          "signature": "Pred a-\u003e InfList a-\u003e ([a], InfList a)",
          "type": "function"
        },
        "index": {
          "description": "Split an infinite list into longest prefix such that all the elements of it satisfy given predicate and the rest of the list following them",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "span",
          "normalized": "Pred a-\u003eInfList a-\u003e([a],InfList a)",
          "package": "inflist",
          "signature": "Pred a-\u003eInfList a-\u003e([a],InfList a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:span"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a natural number, get a two-tuple of the finite list of that many elements\n from the start of a given infinite list, and the infinite list that follows them.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "splitAt",
          "package": "inflist",
          "signature": "Int-\u003e InfList a-\u003e ([a], InfList a)",
          "type": "function"
        },
        "index": {
          "description": "Given natural number get two-tuple of the finite list of that many elements from the start of given infinite list and the infinite list that follows them",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "splitAt",
          "normalized": "Int-\u003eInfList a-\u003e([a],InfList a)",
          "package": "inflist",
          "partial": "At",
          "signature": "Int-\u003eInfList a-\u003e([a],InfList a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:splitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a potential prefix of an infinite list, if the infinite list has\n that prefix, return just the rest of the infinite list; otherwise,\n return \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "stripPrefix",
          "package": "inflist",
          "signature": "[a]-\u003e InfList a-\u003e Maybe (InfList a)",
          "type": "function"
        },
        "index": {
          "description": "Given potential prefix of an infinite list if the infinite list has that prefix return just the rest of the infinite list otherwise return Nothing",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "stripPrefix",
          "normalized": "[a]-\u003eInfList a-\u003eMaybe(InfList a)",
          "package": "inflist",
          "partial": "Prefix",
          "signature": "[a]-\u003eInfList a-\u003eMaybe(InfList a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:stripPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the tail of a list.\n This is guaranteed to exist.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "tail",
          "package": "inflist",
          "signature": "InfList a-\u003e InfList a",
          "type": "function"
        },
        "index": {
          "description": "Get the tail of list This is guaranteed to exist",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "tail",
          "normalized": "InfList a-\u003eInfList a",
          "package": "inflist",
          "signature": "InfList a-\u003eInfList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:tail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList the tails of an infinite list in ascending order of distance from\n the head of the list.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "tails",
          "package": "inflist",
          "signature": "InfList a-\u003e InfList (InfList a)",
          "type": "function"
        },
        "index": {
          "description": "List the tails of an infinite list in ascending order of distance from the head of the list",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "tails",
          "normalized": "InfList a-\u003eInfList(InfList a)",
          "package": "inflist",
          "signature": "InfList a-\u003eInfList(InfList a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:tails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a natural number, return that many elements from the start of an infinite list.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "take",
          "package": "inflist",
          "signature": "Int-\u003e InfList a-\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "Given natural number return that many elements from the start of an infinite list",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "take",
          "normalized": "Int-\u003eInfList a-\u003e[a]",
          "package": "inflist",
          "signature": "Int-\u003eInfList a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe longest prefix of an infinite list\n such that all elements of that prefix satisfy a given predicate.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "takeWhile",
          "package": "inflist",
          "signature": "Pred a-\u003e InfList a-\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "The longest prefix of an infinite list such that all elements of that prefix satisfy given predicate",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "takeWhile",
          "normalized": "Pred a-\u003eInfList a-\u003e[a]",
          "package": "inflist",
          "partial": "While",
          "signature": "Pred a-\u003eInfList a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:takeWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an \u003ccode\u003e\u003ca\u003eInfList\u003c/a\u003e\u003c/code\u003e to an infinite list.\n Use sparingly.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "toList",
          "package": "inflist",
          "signature": "InfList a-\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "Convert an InfList to an infinite list Use sparingly",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "toList",
          "normalized": "InfList a-\u003e[a]",
          "package": "inflist",
          "partial": "List",
          "signature": "InfList a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a list from a seed value.  The iterating function takes\n the seed value and produces the next element in the list along with\n a new seed value to use for the next element.\n Not the same as \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "unfoldr",
          "package": "inflist",
          "signature": "(a -\u003e (b, a))-\u003e a-\u003e InfList b",
          "type": "function"
        },
        "index": {
          "description": "Build list from seed value The iterating function takes the seed value and produces the next element in the list along with new seed value to use for the next element Not the same as unfoldr",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "unfoldr",
          "normalized": "(a-\u003e(b,a))-\u003ea-\u003eInfList b",
          "package": "inflist",
          "signature": "(a-\u003e(b,a))-\u003ea-\u003eInfList b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:unfoldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse the operation of \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e.  That is, given an infinite list of\n two-tuples, return a two-tuple of infinite lists where the nth element\n of the first list in the result is the first element of the nth tuple of the\n first list, and correspondingly for the second list in the result tuple.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "unzip",
          "package": "inflist",
          "signature": "InfList (a, b)-\u003e (InfList a, InfList b)",
          "type": "function"
        },
        "index": {
          "description": "Reverse the operation of zip That is given an infinite list of two-tuples return two-tuple of infinite lists where the nth element of the first list in the result is the first element of the nth tuple of the first list and correspondingly for the second list in the result tuple",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "unzip",
          "normalized": "InfList(a,b)-\u003e(InfList a,InfList b)",
          "package": "inflist",
          "signature": "InfList(a,b)-\u003e(InfList a,InfList b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:unzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList",
          "name": "unzip3",
          "package": "inflist",
          "signature": "InfList (a, b, c) -\u003e (InfList a, InfList b, InfList c)",
          "source": "src/Data-InfList.html#unzip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "unzip3",
          "normalized": "InfList(a,b,c)-\u003e(InfList a,InfList b,InfList c)",
          "package": "inflist",
          "signature": "InfList(a,b,c)-\u003e(InfList a,InfList b,InfList c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:unzip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZip two infinite lists into an infinite list of two-tuples,\n where `(a,b)` in the nth tuple are the nth elements of the first and second\n list respectively.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "zip",
          "package": "inflist",
          "signature": "InfList a-\u003e InfList b-\u003e InfList (a, b)",
          "type": "function"
        },
        "index": {
          "description": "Zip two infinite lists into an infinite list of two-tuples where in the nth tuple are the nth elements of the first and second list respectively",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "zip",
          "normalized": "InfList a-\u003eInfList b-\u003eInfList(a,b)",
          "package": "inflist",
          "signature": "InfList a-\u003eInfList b-\u003eInfList(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:zip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList",
          "name": "zip3",
          "package": "inflist",
          "signature": "InfList a -\u003e InfList b -\u003e InfList c -\u003e InfList (a, b, c)",
          "source": "src/Data-InfList.html#zip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "zip3",
          "normalized": "InfList a-\u003eInfList b-\u003eInfList c-\u003eInfList(a,b,c)",
          "package": "inflist",
          "signature": "InfList a-\u003eInfList b-\u003eInfList c-\u003eInfList(a,b,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:zip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZip two infinite lists into a third list where the nth element of the third\n list is the result of applying a given function to the nth elements of the\n first and second lists.\n\u003c/p\u003e",
          "module": "Data.InfList",
          "name": "zipWith",
          "package": "inflist",
          "signature": "(a -\u003e b -\u003e c)-\u003e InfList a-\u003e InfList b-\u003e InfList c",
          "type": "function"
        },
        "index": {
          "description": "Zip two infinite lists into third list where the nth element of the third list is the result of applying given function to the nth elements of the first and second lists",
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eInfList a-\u003eInfList b-\u003eInfList c",
          "package": "inflist",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003eInfList a-\u003eInfList b-\u003eInfList c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.InfList",
          "name": "zipWith3",
          "package": "inflist",
          "signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e InfList a -\u003e InfList b -\u003e InfList c -\u003e InfList d",
          "source": "src/Data-InfList.html#zipWith3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data InfList",
          "module": "Data.InfList",
          "name": "zipWith3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eInfList a-\u003eInfList b-\u003eInfList c-\u003eInfList d",
          "package": "inflist",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eInfList a-\u003eInfList b-\u003eInfList c-\u003eInfList d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/inflist/docs/Data-InfList.html#v:zipWith3"
      }
    }
  ]
]