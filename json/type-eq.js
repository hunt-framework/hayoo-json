[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "type-eq"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher.Unsafe",
          "name": "Unsafe",
          "package": "type-eq",
          "source": "src/Type-Eq-Higher-Unsafe.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Type Eq Higher Unsafe",
          "module": "Type.Eq.Higher.Unsafe",
          "name": "Unsafe",
          "package": "type-eq",
          "partial": "Unsafe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher-Unsafe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVery unsafe! The same rules apply as for \u003ccode\u003e\u003ca\u003eunsafeCoerce\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Type.Eq.Higher.Unsafe",
          "name": "unsafeCoercion1",
          "package": "type-eq",
          "signature": "g",
          "source": "src/Type-Eq-Higher-Unsafe.html#unsafeCoercion1",
          "type": "function"
        },
        "index": {
          "description": "Very unsafe The same rules apply as for unsafeCoerce",
          "hierarchy": "Type Eq Higher Unsafe",
          "module": "Type.Eq.Higher.Unsafe",
          "name": "unsafeCoercion1",
          "package": "type-eq",
          "partial": "Coercion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher-Unsafe.html#v:unsafeCoercion1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVery unsafe! The same rules apply as for \u003ccode\u003e\u003ca\u003eunsafeCoerce\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Type.Eq.Higher.Unsafe",
          "name": "unsafeCoercion2",
          "package": "type-eq",
          "signature": "n",
          "source": "src/Type-Eq-Higher-Unsafe.html#unsafeCoercion2",
          "type": "function"
        },
        "index": {
          "description": "Very unsafe The same rules apply as for unsafeCoerce",
          "hierarchy": "Type Eq Higher Unsafe",
          "module": "Type.Eq.Higher.Unsafe",
          "name": "unsafeCoercion2",
          "package": "type-eq",
          "partial": "Coercion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher-Unsafe.html#v:unsafeCoercion2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVery unsafe!\n\u003c/p\u003e",
          "module": "Type.Eq.Higher.Unsafe",
          "name": "unsafeInnerEq1",
          "package": "type-eq",
          "signature": "InnerEq1 a f",
          "source": "src/Type-Eq-Higher-Unsafe.html#unsafeInnerEq1",
          "type": "function"
        },
        "index": {
          "description": "Very unsafe",
          "hierarchy": "Type Eq Higher Unsafe",
          "module": "Type.Eq.Higher.Unsafe",
          "name": "unsafeInnerEq1",
          "package": "type-eq",
          "partial": "Inner Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher-Unsafe.html#v:unsafeInnerEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVery unsafe!\n\u003c/p\u003e",
          "module": "Type.Eq.Higher.Unsafe",
          "name": "unsafeOuterEq1",
          "package": "type-eq",
          "signature": "OuterEq1 m f",
          "source": "src/Type-Eq-Higher-Unsafe.html#unsafeOuterEq1",
          "type": "function"
        },
        "index": {
          "description": "Very unsafe",
          "hierarchy": "Type Eq Higher Unsafe",
          "module": "Type.Eq.Higher.Unsafe",
          "name": "unsafeOuterEq1",
          "package": "type-eq",
          "partial": "Outer Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher-Unsafe.html#v:unsafeOuterEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTypes and functions for storing and manipulating evidence of equality between types of higher kind.\n\u003c/p\u003e\u003cp\u003eAvailable up to \u003ccode\u003e* -\u003e * -\u003e *\u003c/code\u003e. Yell if you need more.\n\u003c/p\u003e\u003cp\u003eIn GHC 7.8, this module uses \u003ccode\u003eData.OldTypeable\u003c/code\u003e. Future uncertain.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Type.Eq.Higher",
          "name": "Higher",
          "package": "type-eq",
          "source": "src/Type-Eq-Higher.html",
          "type": "module"
        },
        "index": {
          "description": "Types and functions for storing and manipulating evidence of equality between types of higher kind Available up to Yell if you need more In GHC this module uses Data.OldTypeable Future uncertain",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "Higher",
          "package": "type-eq",
          "partial": "Higher",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "::~::",
          "package": "type-eq",
          "source": "src/Type-Eq-Higher.html#%3A%3A~%3A%3A",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "::~::",
          "package": "type-eq",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#t:::-126-::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": ":::~:::",
          "package": "type-eq",
          "source": "src/Type-Eq-Higher.html#%3A%3A%3A~%3A%3A%3A",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": ":::~:::",
          "package": "type-eq",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#t::::-126-:::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "InnerEq1",
          "package": "type-eq",
          "source": "src/Type-Eq-Higher.html#InnerEq1",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "InnerEq1",
          "package": "type-eq",
          "partial": "Inner Eq",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#t:InnerEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "OuterEq1",
          "package": "type-eq",
          "source": "src/Type-Eq-Higher.html#OuterEq1",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "OuterEq1",
          "package": "type-eq",
          "partial": "Outer Eq",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#t:OuterEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCongruence?\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "(||$||)",
          "package": "type-eq",
          "signature": "n b",
          "source": "src/Type-Eq-Higher.html#%7C%7C%24%7C%7C",
          "type": "function"
        },
        "index": {
          "description": "Congruence",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "(||$||) ||$||",
          "package": "type-eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:-124--124--36--124--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransitivity\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "(||.||)",
          "package": "type-eq",
          "signature": "o",
          "source": "src/Type-Eq-Higher.html#%7C%7C.%7C%7C",
          "type": "function"
        },
        "index": {
          "description": "Transitivity",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "(||.||) ||.||",
          "package": "type-eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:-124--124-.-124--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCongruence?\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "(|$|)",
          "package": "type-eq",
          "signature": "g) -\u003e (a :~: b) -\u003e f a :~: g b",
          "source": "src/Type-Eq-Higher.html#%7C%24%7C",
          "type": "function"
        },
        "index": {
          "description": "Congruence",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "(|$|) |$|",
          "normalized": "a)-\u003e(b c)-\u003ed b a c",
          "package": "type-eq",
          "signature": "g)-\u003e(a b)-\u003ef a g b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:-124--36--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransitivity\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "(|.|)",
          "package": "type-eq",
          "signature": "h",
          "source": "src/Type-Eq-Higher.html#%7C.%7C",
          "type": "function"
        },
        "index": {
          "description": "Transitivity",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "(|.|) |.|",
          "package": "type-eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:-124-.-124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "Eq1",
          "package": "type-eq",
          "signature": "g",
          "source": "src/Type-Eq-Higher.html#%3A%3A~%3A%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "Eq1",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:Eq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "Eq2",
          "package": "type-eq",
          "signature": "n",
          "source": "src/Type-Eq-Higher.html#%3A%3A%3A~%3A%3A%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "Eq2",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:Eq2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "InnerEq1",
          "package": "type-eq",
          "signature": "InnerEq1 a f",
          "source": "src/Type-Eq-Higher.html#InnerEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "InnerEq1",
          "package": "type-eq",
          "partial": "Inner Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:InnerEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "OuterEq1",
          "package": "type-eq",
          "signature": "OuterEq1 m f",
          "source": "src/Type-Eq-Higher.html#OuterEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "OuterEq1",
          "package": "type-eq",
          "partial": "Outer Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:OuterEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCongruence?\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "applyEq1",
          "package": "type-eq",
          "signature": "g) -\u003e (a :~: b) -\u003e f a :~: g b",
          "source": "src/Type-Eq-Higher.html#applyEq1",
          "type": "function"
        },
        "index": {
          "description": "Congruence",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "applyEq1",
          "normalized": "a)-\u003e(b c)-\u003ed b a c",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "g)-\u003e(a b)-\u003ef a g b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:applyEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCongruence?\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "applyEq2",
          "package": "type-eq",
          "signature": "n b",
          "source": "src/Type-Eq-Higher.html#applyEq2",
          "type": "function"
        },
        "index": {
          "description": "Congruence",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "applyEq2",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:applyEq2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType constructors are injective\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "argumentEq1",
          "package": "type-eq",
          "signature": "n b) -\u003e a :~: b",
          "source": "src/Type-Eq-Higher.html#argumentEq1",
          "type": "function"
        },
        "index": {
          "description": "Type constructors are injective",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "argumentEq1",
          "normalized": "a b)-\u003ec b",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "n b)-\u003ea b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:argumentEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "assembleEq1",
          "package": "type-eq",
          "signature": "f",
          "source": "src/Type-Eq-Higher.html#assembleEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "assembleEq1",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:assembleEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransitivity\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "composeEq1",
          "package": "type-eq",
          "signature": "h",
          "source": "src/Type-Eq-Higher.html#composeEq1",
          "type": "function"
        },
        "index": {
          "description": "Transitivity",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "composeEq1",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:composeEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransitivity\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "composeEq2",
          "package": "type-eq",
          "signature": "o",
          "source": "src/Type-Eq-Higher.html#composeEq2",
          "type": "function"
        },
        "index": {
          "description": "Transitivity",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "composeEq2",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:composeEq2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType constructors are generative\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "constructorEq",
          "package": "type-eq",
          "signature": "g",
          "source": "src/Type-Eq-Higher.html#constructorEq",
          "type": "function"
        },
        "index": {
          "description": "Type constructors are generative",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "constructorEq",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:constructorEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType constructors are generative\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "constructorEq1",
          "package": "type-eq",
          "signature": "n",
          "source": "src/Type-Eq-Higher.html#constructorEq1",
          "type": "function"
        },
        "index": {
          "description": "Type constructors are generative",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "constructorEq1",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:constructorEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuntime type equality evidence from \u003ccode\u003eTypeable1\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "dynamicEq1",
          "package": "type-eq",
          "signature": "g)",
          "source": "src/Type-Eq-Higher.html#dynamicEq1",
          "type": "function"
        },
        "index": {
          "description": "Runtime type equality evidence from Typeable1",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "dynamicEq1",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:dynamicEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuntime type equality evidence from \u003ccode\u003eTypeable2\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "dynamicEq2",
          "package": "type-eq",
          "signature": "m)",
          "source": "src/Type-Eq-Higher.html#dynamicEq2",
          "type": "function"
        },
        "index": {
          "description": "Runtime type equality evidence from Typeable2",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "dynamicEq2",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:dynamicEq2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSymmetry\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "flipEq1",
          "package": "type-eq",
          "signature": "f",
          "source": "src/Type-Eq-Higher.html#flipEq1",
          "type": "function"
        },
        "index": {
          "description": "Symmetry",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "flipEq1",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:flipEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSymmetry\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "flipEq2",
          "package": "type-eq",
          "signature": "m",
          "source": "src/Type-Eq-Higher.html#flipEq2",
          "type": "function"
        },
        "index": {
          "description": "Symmetry",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "flipEq2",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:flipEq2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReflexivity\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "idEq1",
          "package": "type-eq",
          "signature": "f",
          "source": "src/Type-Eq-Higher.html#idEq1",
          "type": "function"
        },
        "index": {
          "description": "Reflexivity",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "idEq1",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:idEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReflexivity\n\u003c/p\u003e",
          "module": "Type.Eq.Higher",
          "name": "idEq2",
          "package": "type-eq",
          "signature": "m",
          "source": "src/Type-Eq-Higher.html#idEq2",
          "type": "function"
        },
        "index": {
          "description": "Reflexivity",
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "idEq2",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:idEq2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "innerEq1",
          "package": "type-eq",
          "signature": "f) -\u003e InnerEq1 a f",
          "source": "src/Type-Eq-Higher.html#innerEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "innerEq1",
          "normalized": "a)-\u003eInnerEq b a",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "f)-\u003eInnerEq a f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:innerEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "outerEq1",
          "package": "type-eq",
          "signature": "f) -\u003e OuterEq1 m f",
          "source": "src/Type-Eq-Higher.html#outerEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "outerEq1",
          "normalized": "a)-\u003eOuterEq b a",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "f)-\u003eOuterEq m f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:outerEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "sameInnerEq1",
          "package": "type-eq",
          "signature": "InnerEq1 a f -\u003e InnerEq1 b f -\u003e a :~: b",
          "source": "src/Type-Eq-Higher.html#sameInnerEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "sameInnerEq1",
          "normalized": "InnerEq a b-\u003eInnerEq c b-\u003ea c",
          "package": "type-eq",
          "partial": "Inner Eq",
          "signature": "InnerEq a f-\u003eInnerEq b f-\u003ea b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:sameInnerEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "sameOuterEq",
          "package": "type-eq",
          "signature": "g",
          "source": "src/Type-Eq-Higher.html#sameOuterEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "sameOuterEq",
          "package": "type-eq",
          "partial": "Outer Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:sameOuterEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "sameOuterEq1",
          "package": "type-eq",
          "signature": "n",
          "source": "src/Type-Eq-Higher.html#sameOuterEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "sameOuterEq1",
          "package": "type-eq",
          "partial": "Outer Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:sameOuterEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "withEq1",
          "package": "type-eq",
          "signature": "g) -\u003e r",
          "source": "src/Type-Eq-Higher.html#withEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "withEq1",
          "normalized": "a)-\u003eb",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "g)-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:withEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "withEq2",
          "package": "type-eq",
          "signature": "n) -\u003e r",
          "source": "src/Type-Eq-Higher.html#withEq2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "withEq2",
          "normalized": "a)-\u003eb",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "n)-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:withEq2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "withInnerEq1",
          "package": "type-eq",
          "signature": "r) -\u003e InnerEq1 a f -\u003e r",
          "source": "src/Type-Eq-Higher.html#withInnerEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "withInnerEq1",
          "normalized": "a)-\u003eInnerEq b c-\u003ea",
          "package": "type-eq",
          "partial": "Inner Eq",
          "signature": "r)-\u003eInnerEq a f-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:withInnerEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Higher",
          "name": "withOuterEq1",
          "package": "type-eq",
          "signature": "r) -\u003e OuterEq1 m f -\u003e r",
          "source": "src/Type-Eq-Higher.html#withOuterEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Higher",
          "module": "Type.Eq.Higher",
          "name": "withOuterEq1",
          "normalized": "a)-\u003eOuterEq b c-\u003ea",
          "package": "type-eq",
          "partial": "Outer Eq",
          "signature": "r)-\u003eOuterEq m f-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Higher.html#v:withOuterEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eKind-polymorphic functions for manipulating type equality evidence.\n\u003c/p\u003e\u003cp\u003eThis module is available only if \u003ccode\u003ePolyKinds\u003c/code\u003e are available (GHC 7.6+).\n\u003c/p\u003e\u003cp\u003eIn GHC 7.8, this module uses \u003ccode\u003eData.OldTypeable\u003c/code\u003e. Future uncertain.\n\u003c/p\u003e\u003cp\u003eFor kind-polymorphic \u003ccode\u003eData.Typeable\u003c/code\u003e, use \u003ccode\u003e\u003ca\u003edynamicEq\u003c/a\u003e\u003c/code\u003e from the \u003ca\u003eType.Eq\u003c/a\u003e module.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Type.Eq.Poly",
          "name": "Poly",
          "package": "type-eq",
          "source": "src/Type-Eq-Poly.html",
          "type": "module"
        },
        "index": {
          "description": "Kind-polymorphic functions for manipulating type equality evidence This module is available only if PolyKinds are available GHC In GHC this module uses Data.OldTypeable Future uncertain For kind-polymorphic Data.Typeable use dynamicEq from the Type.Eq module",
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "Poly",
          "package": "type-eq",
          "partial": "Poly",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCongruence?\n\u003c/p\u003e",
          "module": "Type.Eq.Poly",
          "name": "(|$|)",
          "package": "type-eq",
          "signature": "(f :~: g) -\u003e (a :~: b) -\u003e f a :~: g b",
          "source": "src/Type-Eq-Poly.html#%7C%24%7C",
          "type": "function"
        },
        "index": {
          "description": "Congruence",
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "(|$|) |$|",
          "normalized": "(a b)-\u003e(c d)-\u003ea c b d",
          "package": "type-eq",
          "signature": "(f g)-\u003e(a b)-\u003ef a g b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:-124--36--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for \u003ccode\u003e\u003ccode\u003e\u003ca\u003ecomposeEq\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e. Kind-polymorphic, unlike \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Type.Eq.Poly",
          "name": "(|.|)",
          "package": "type-eq",
          "signature": "(b :~: c) -\u003e (a :~: b) -\u003e a :~: c",
          "source": "src/Type-Eq-Poly.html#%7C.%7C",
          "type": "function"
        },
        "index": {
          "description": "Synonym for composeEq Kind-polymorphic unlike",
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "(|.|) |.|",
          "normalized": "(a b)-\u003e(c a)-\u003ec b",
          "package": "type-eq",
          "signature": "(b c)-\u003e(a b)-\u003ea c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:-124-.-124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCongruence?\n\u003c/p\u003e",
          "module": "Type.Eq.Poly",
          "name": "applyEq",
          "package": "type-eq",
          "signature": "(f :~: g) -\u003e (a :~: b) -\u003e f a :~: g b",
          "source": "src/Type-Eq-Poly.html#applyEq",
          "type": "function"
        },
        "index": {
          "description": "Congruence",
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "applyEq",
          "normalized": "(a b)-\u003e(c d)-\u003ea c b d",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "(f g)-\u003e(a b)-\u003ef a g b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:applyEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType constructors are generative\n\u003c/p\u003e",
          "module": "Type.Eq.Poly",
          "name": "constructorEq",
          "package": "type-eq",
          "signature": "(f a :~: g b) -\u003e f :~: g",
          "source": "src/Type-Eq-Poly.html#constructorEq",
          "type": "function"
        },
        "index": {
          "description": "Type constructors are generative",
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "constructorEq",
          "normalized": "(a b c d)-\u003ea c",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "(f a g b)-\u003ef g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:constructorEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuntime type equality evidence from \u003ccode\u003eTypeable1\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Type.Eq.Poly",
          "name": "dynamicEq1",
          "package": "type-eq",
          "signature": "Maybe (f :~: g)",
          "source": "src/Type-Eq-Poly.html#dynamicEq1",
          "type": "function"
        },
        "index": {
          "description": "Runtime type equality evidence from Typeable1",
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "dynamicEq1",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:dynamicEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuntime type equality evidence from \u003ccode\u003eTypeable2\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Type.Eq.Poly",
          "name": "dynamicEq2",
          "package": "type-eq",
          "signature": "Maybe (n :~: m)",
          "source": "src/Type-Eq-Poly.html#dynamicEq2",
          "type": "function"
        },
        "index": {
          "description": "Runtime type equality evidence from Typeable2",
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "dynamicEq2",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:dynamicEq2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuntime type equality evidence from \u003ccode\u003eTypeable3\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Type.Eq.Poly",
          "name": "dynamicEq3",
          "package": "type-eq",
          "signature": "Maybe (x :~: y)",
          "source": "src/Type-Eq-Poly.html#dynamicEq3",
          "type": "function"
        },
        "index": {
          "description": "Runtime type equality evidence from Typeable3",
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "dynamicEq3",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:dynamicEq3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuntime type equality evidence from \u003ccode\u003eTypeable4\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Type.Eq.Poly",
          "name": "dynamicEq4",
          "package": "type-eq",
          "signature": "Maybe (x :~: y)",
          "source": "src/Type-Eq-Poly.html#dynamicEq4",
          "type": "function"
        },
        "index": {
          "description": "Runtime type equality evidence from Typeable4",
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "dynamicEq4",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:dynamicEq4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuntime type equality evidence from \u003ccode\u003eTypeable5\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Type.Eq.Poly",
          "name": "dynamicEq5",
          "package": "type-eq",
          "signature": "Maybe (x :~: y)",
          "source": "src/Type-Eq-Poly.html#dynamicEq5",
          "type": "function"
        },
        "index": {
          "description": "Runtime type equality evidence from Typeable5",
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "dynamicEq5",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:dynamicEq5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuntime type equality evidence from \u003ccode\u003eTypeable6\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Type.Eq.Poly",
          "name": "dynamicEq6",
          "package": "type-eq",
          "signature": "Maybe (x :~: y)",
          "source": "src/Type-Eq-Poly.html#dynamicEq6",
          "type": "function"
        },
        "index": {
          "description": "Runtime type equality evidence from Typeable6",
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "dynamicEq6",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:dynamicEq6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuntime type equality evidence from \u003ccode\u003eTypeable7\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Type.Eq.Poly",
          "name": "dynamicEq7",
          "package": "type-eq",
          "signature": "Maybe (x :~: y)",
          "source": "src/Type-Eq-Poly.html#dynamicEq7",
          "type": "function"
        },
        "index": {
          "description": "Runtime type equality evidence from Typeable7",
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "dynamicEq7",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:dynamicEq7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Poly",
          "name": "fromEq1",
          "package": "type-eq",
          "signature": "g) -\u003e f :~: g",
          "source": "src/Type-Eq-Poly.html#fromEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "fromEq1",
          "normalized": "a)-\u003eb a",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "g)-\u003ef g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:fromEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Poly",
          "name": "fromEq2",
          "package": "type-eq",
          "signature": "m) -\u003e n :~: m",
          "source": "src/Type-Eq-Poly.html#fromEq2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "fromEq2",
          "normalized": "a)-\u003eb a",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "m)-\u003en m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:fromEq2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Poly",
          "name": "fromInnerEq1",
          "package": "type-eq",
          "signature": "InnerEq1 a f -\u003e InnerEq a f",
          "source": "src/Type-Eq-Poly.html#fromInnerEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "fromInnerEq1",
          "normalized": "InnerEq a b-\u003eInnerEq a b",
          "package": "type-eq",
          "partial": "Inner Eq",
          "signature": "InnerEq a f-\u003eInnerEq a f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:fromInnerEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Poly",
          "name": "fromOuterEq1",
          "package": "type-eq",
          "signature": "OuterEq1 m f -\u003e OuterEq m f",
          "source": "src/Type-Eq-Poly.html#fromOuterEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "fromOuterEq1",
          "normalized": "OuterEq a b-\u003eOuterEq a b",
          "package": "type-eq",
          "partial": "Outer Eq",
          "signature": "OuterEq m f-\u003eOuterEq m f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:fromOuterEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Poly",
          "name": "sameOuterEq",
          "package": "type-eq",
          "signature": "OuterEq f a -\u003e OuterEq g a -\u003e f :~: g",
          "source": "src/Type-Eq-Poly.html#sameOuterEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "sameOuterEq",
          "normalized": "OuterEq a b-\u003eOuterEq c b-\u003ea c",
          "package": "type-eq",
          "partial": "Outer Eq",
          "signature": "OuterEq f a-\u003eOuterEq g a-\u003ef g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:sameOuterEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Poly",
          "name": "toEq1",
          "package": "type-eq",
          "signature": "g",
          "source": "src/Type-Eq-Poly.html#toEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "toEq1",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:toEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Poly",
          "name": "toEq2",
          "package": "type-eq",
          "signature": "m",
          "source": "src/Type-Eq-Poly.html#toEq2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "toEq2",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:toEq2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Poly",
          "name": "toInnerEq1",
          "package": "type-eq",
          "signature": "InnerEq a f -\u003e InnerEq1 a f",
          "source": "src/Type-Eq-Poly.html#toInnerEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "toInnerEq1",
          "normalized": "InnerEq a b-\u003eInnerEq a b",
          "package": "type-eq",
          "partial": "Inner Eq",
          "signature": "InnerEq a f-\u003eInnerEq a f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:toInnerEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq.Poly",
          "name": "toOuterEq1",
          "package": "type-eq",
          "signature": "OuterEq m f -\u003e OuterEq1 m f",
          "source": "src/Type-Eq-Poly.html#toOuterEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq Poly",
          "module": "Type.Eq.Poly",
          "name": "toOuterEq1",
          "normalized": "OuterEq a b-\u003eOuterEq a b",
          "package": "type-eq",
          "partial": "Outer Eq",
          "signature": "OuterEq m f-\u003eOuterEq m f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Poly.html#v:toOuterEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module is kind-polymorphic if \u003ccode\u003ePolyKinds\u003c/code\u003e are available (GHC 7.6+).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Type.Eq.Unsafe",
          "name": "Unsafe",
          "package": "type-eq",
          "source": "src/Type-Eq-Unsafe.html",
          "type": "module"
        },
        "index": {
          "description": "This module is kind-polymorphic if PolyKinds are available GHC",
          "hierarchy": "Type Eq Unsafe",
          "module": "Type.Eq.Unsafe",
          "name": "Unsafe",
          "package": "type-eq",
          "partial": "Unsafe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Unsafe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVery unsafe! The same rules apply as for \u003ccode\u003e\u003ca\u003eunsafeCoerce\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Type.Eq.Unsafe",
          "name": "unsafeCoercion",
          "package": "type-eq",
          "signature": "a :~: b",
          "source": "src/Type-Eq-Unsafe.html#unsafeCoercion",
          "type": "function"
        },
        "index": {
          "description": "Very unsafe The same rules apply as for unsafeCoerce",
          "hierarchy": "Type Eq Unsafe",
          "module": "Type.Eq.Unsafe",
          "name": "unsafeCoercion",
          "package": "type-eq",
          "partial": "Coercion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Unsafe.html#v:unsafeCoercion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVery unsafe!\n\u003c/p\u003e",
          "module": "Type.Eq.Unsafe",
          "name": "unsafeInnerEq",
          "package": "type-eq",
          "signature": "InnerEq i a",
          "source": "src/Type-Eq-Unsafe.html#unsafeInnerEq",
          "type": "function"
        },
        "index": {
          "description": "Very unsafe",
          "hierarchy": "Type Eq Unsafe",
          "module": "Type.Eq.Unsafe",
          "name": "unsafeInnerEq",
          "package": "type-eq",
          "partial": "Inner Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Unsafe.html#v:unsafeInnerEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVery unsafe!\n\u003c/p\u003e",
          "module": "Type.Eq.Unsafe",
          "name": "unsafeOuterEq",
          "package": "type-eq",
          "signature": "OuterEq f a",
          "source": "src/Type-Eq-Unsafe.html#unsafeOuterEq",
          "type": "function"
        },
        "index": {
          "description": "Very unsafe",
          "hierarchy": "Type Eq Unsafe",
          "module": "Type.Eq.Unsafe",
          "name": "unsafeOuterEq",
          "package": "type-eq",
          "partial": "Outer Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq-Unsafe.html#v:unsafeOuterEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTypes and functions for storing and manipulating type equality evidence.\n\u003c/p\u003e\u003cp\u003eThis module is kind-polymorphic if \u003ccode\u003ePolyKinds\u003c/code\u003e are available (GHC 7.6+).\n\u003c/p\u003e\u003cp\u003eNotable functions missing from this module include \u003ccode\u003eapplyEq\u003c/code\u003e, \u003ccode\u003econstructorEq\u003c/code\u003e, and \u003ccode\u003esameOuterEq\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSee also \u003ccode\u003e\u003ca\u003eType.Eq.Higher\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eType.Eq.Poly\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Type.Eq",
          "name": "Eq",
          "package": "type-eq",
          "source": "src/Type-Eq.html",
          "type": "module"
        },
        "index": {
          "description": "Types and functions for storing and manipulating type equality evidence This module is kind-polymorphic if PolyKinds are available GHC Notable functions missing from this module include applyEq constructorEq and sameOuterEq See also Type.Eq.Higher and Type.Eq.Poly",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "Eq",
          "package": "type-eq",
          "partial": "Eq",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvidence that \u003ccode\u003ea\u003c/code\u003e is the same type as \u003ccode\u003eb\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e instances of \u003ccode\u003eMaybe\u003c/code\u003e\n   are very useful for working with values of type \u003ccode\u003eMaybe (a :~: b)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Type.Eq",
          "name": ":~:",
          "package": "type-eq",
          "source": "src/Type-Eq.html#%3A~%3A",
          "type": "data"
        },
        "index": {
          "description": "Evidence that is the same type as The Functor Applicative and Monad instances of Maybe are very useful for working with values of type Maybe",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": ":~:",
          "package": "type-eq",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#t::-126-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvidence that \u003ccode\u003ei\u003c/code\u003e is the argument type of the outermost type constructor of \u003ccode\u003ea\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Type.Eq",
          "name": "InnerEq",
          "package": "type-eq",
          "source": "src/Type-Eq.html#InnerEq",
          "type": "data"
        },
        "index": {
          "description": "Evidence that is the argument type of the outermost type constructor of",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "InnerEq",
          "package": "type-eq",
          "partial": "Inner Eq",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#t:InnerEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvidence that \u003ccode\u003ef\u003c/code\u003e is the outermost type constructor of \u003ccode\u003ea\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Type.Eq",
          "name": "OuterEq",
          "package": "type-eq",
          "source": "src/Type-Eq.html#OuterEq",
          "type": "data"
        },
        "index": {
          "description": "Evidence that is the outermost type constructor of",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "OuterEq",
          "package": "type-eq",
          "partial": "Outer Eq",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#t:OuterEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCan be implemented by types storing evidence of type equalities, i.e. GADTs.\n\u003c/p\u003e\u003cp\u003eA return value of \u003ccode\u003eNothing\u003c/code\u003e can mean any of definite inequality, impossible arguments, or insufficient information.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003emaybeEq\u003c/code\u003e or \u003ccode\u003e(~~)\u003c/code\u003e, plus either:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003epiecewiseMaybeEq\u003c/code\u003e, or\n\u003c/li\u003e\u003cli\u003e both \u003ccode\u003emaybeOuterEq\u003c/code\u003e and \u003ccode\u003emaybeInnerEq\u003c/code\u003e. or\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e(\u003c~\u003e)\u003c/code\u003e, or\n\u003c/li\u003e\u003cli\u003e both \u003ccode\u003e(~\u003e)\u003c/code\u003e and \u003ccode\u003e(\u003c~)\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eDue to \u003ca\u003ehttp://hackage.haskell.org/trac/ghc/ticket/5591\u003c/a\u003e you may have to use \u003ccode\u003e\u003ca\u003eunsafeOuterEq\u003c/a\u003e\u003c/code\u003e and/or \u003ccode\u003e\u003ca\u003eunsafeInnerEq\u003c/a\u003e\u003c/code\u003e to define some of these.\n\u003c/p\u003e",
          "module": "Type.Eq",
          "name": "TypeCompare",
          "package": "type-eq",
          "source": "src/Type-Eq.html#TypeCompare",
          "type": "class"
        },
        "index": {
          "description": "Can be implemented by types storing evidence of type equalities i.e GADTs return value of Nothing can mean any of definite inequality impossible arguments or insufficient information Minimal complete definition maybeEq or plus either piecewiseMaybeEq or both maybeOuterEq and maybeInnerEq or or both and Due to http hackage.haskell.org trac ghc ticket you may have to use unsafeOuterEq and or unsafeInnerEq to define some of these",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "TypeCompare",
          "package": "type-eq",
          "partial": "Type Compare",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#t:TypeCompare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse equality evidence to cast between types\n\u003c/p\u003e",
          "module": "Type.Eq",
          "name": "(|\u003e)",
          "package": "type-eq",
          "signature": "a -\u003e (a :~: b) -\u003e b",
          "source": "src/Type-Eq.html#%7C%3E",
          "type": "function"
        },
        "index": {
          "description": "Use equality evidence to cast between types",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "(|\u003e) |\u003e",
          "normalized": "a-\u003e(a b)-\u003eb",
          "package": "type-eq",
          "signature": "a-\u003e(a b)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:-124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq",
          "name": "Eq",
          "package": "type-eq",
          "signature": "a :~: b",
          "source": "src/Type-Eq.html#%3A~%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "Eq",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:Eq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq",
          "name": "InnerEq",
          "package": "type-eq",
          "signature": "InnerEq i a",
          "source": "src/Type-Eq.html#InnerEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "InnerEq",
          "package": "type-eq",
          "partial": "Inner Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:InnerEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq",
          "name": "OuterEq",
          "package": "type-eq",
          "signature": "OuterEq f a",
          "source": "src/Type-Eq.html#OuterEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "OuterEq",
          "package": "type-eq",
          "partial": "Outer Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:OuterEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType constructors are injective\n\u003c/p\u003e",
          "module": "Type.Eq",
          "name": "argumentEq",
          "package": "type-eq",
          "signature": "(f a :~: g b) -\u003e a :~: b",
          "source": "src/Type-Eq.html#argumentEq",
          "type": "function"
        },
        "index": {
          "description": "Type constructors are injective",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "argumentEq",
          "normalized": "(a b c d)-\u003eb d",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "(f a g b)-\u003ea b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:argumentEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq",
          "name": "assembleEq",
          "package": "type-eq",
          "signature": "OuterEq f a -\u003e InnerEq i a -\u003e f i :~: a",
          "source": "src/Type-Eq.html#assembleEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "assembleEq",
          "normalized": "OuterEq a b-\u003eInnerEq c b-\u003ea c b",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "OuterEq f a-\u003eInnerEq i a-\u003ef i a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:assembleEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse equality evidence to cast between types\n\u003c/p\u003e",
          "module": "Type.Eq",
          "name": "cast",
          "package": "type-eq",
          "signature": "a -\u003e (a :~: b) -\u003e b",
          "source": "src/Type-Eq.html#cast",
          "type": "function"
        },
        "index": {
          "description": "Use equality evidence to cast between types",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "cast",
          "normalized": "a-\u003e(a b)-\u003eb",
          "package": "type-eq",
          "signature": "a-\u003e(a b)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:cast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransitivity\n\u003c/p\u003e",
          "module": "Type.Eq",
          "name": "composeEq",
          "package": "type-eq",
          "signature": "(b :~: c) -\u003e (a :~: b) -\u003e a :~: c",
          "source": "src/Type-Eq.html#composeEq",
          "type": "function"
        },
        "index": {
          "description": "Transitivity",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "composeEq",
          "normalized": "(a b)-\u003e(c a)-\u003ec b",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "(b c)-\u003e(a b)-\u003ea c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:composeEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq",
          "name": "dynamicEq",
          "package": "type-eq",
          "signature": "Maybe (a :~: b)",
          "source": "src/Type-Eq.html#dynamicEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "dynamicEq",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:dynamicEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSymmetry\n\u003c/p\u003e",
          "module": "Type.Eq",
          "name": "flipEq",
          "package": "type-eq",
          "signature": "(a :~: b) -\u003e b :~: a",
          "source": "src/Type-Eq.html#flipEq",
          "type": "function"
        },
        "index": {
          "description": "Symmetry",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "flipEq",
          "normalized": "(a b)-\u003eb a",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "(a b)-\u003eb a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:flipEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReflexivity\n\u003c/p\u003e",
          "module": "Type.Eq",
          "name": "idEq",
          "package": "type-eq",
          "signature": "a :~: a",
          "source": "src/Type-Eq.html#idEq",
          "type": "function"
        },
        "index": {
          "description": "Reflexivity",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "idEq",
          "package": "type-eq",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:idEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq",
          "name": "innerEq",
          "package": "type-eq",
          "signature": "(f i :~: a) -\u003e InnerEq i a",
          "source": "src/Type-Eq.html#innerEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "innerEq",
          "normalized": "(a b c)-\u003eInnerEq b c",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "(f i a)-\u003eInnerEq i a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:innerEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq",
          "name": "maybeEq",
          "package": "type-eq",
          "signature": "t a -\u003e t b -\u003e Maybe (a :~: b)",
          "source": "src/Type-Eq.html#maybeEq",
          "type": "method"
        },
        "index": {
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "maybeEq",
          "normalized": "a b-\u003ea c-\u003eMaybe(b c)",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "t a-\u003et b-\u003eMaybe(a b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:maybeEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq",
          "name": "maybeInnerEq",
          "package": "type-eq",
          "signature": "t (f i) -\u003e t a -\u003e Maybe (InnerEq i a)",
          "source": "src/Type-Eq.html#maybeInnerEq",
          "type": "method"
        },
        "index": {
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "maybeInnerEq",
          "normalized": "a(b c)-\u003ea d-\u003eMaybe(InnerEq c d)",
          "package": "type-eq",
          "partial": "Inner Eq",
          "signature": "t(f i)-\u003et a-\u003eMaybe(InnerEq i a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:maybeInnerEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq",
          "name": "maybeOuterEq",
          "package": "type-eq",
          "signature": "t (f i) -\u003e t a -\u003e Maybe (OuterEq f a)",
          "source": "src/Type-Eq.html#maybeOuterEq",
          "type": "method"
        },
        "index": {
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "maybeOuterEq",
          "normalized": "a(b c)-\u003ea d-\u003eMaybe(OuterEq b d)",
          "package": "type-eq",
          "partial": "Outer Eq",
          "signature": "t(f i)-\u003et a-\u003eMaybe(OuterEq f a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:maybeOuterEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq",
          "name": "outerEq",
          "package": "type-eq",
          "signature": "(f i :~: a) -\u003e OuterEq f a",
          "source": "src/Type-Eq.html#outerEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "outerEq",
          "normalized": "(a b c)-\u003eOuterEq a c",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "(f i a)-\u003eOuterEq f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:outerEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e uncurry (liftA2 assembleEq) (a \u003c~\u003e b) = a ~~ b\n\u003c/pre\u003e",
          "module": "Type.Eq",
          "name": "piecewiseMaybeEq",
          "package": "type-eq",
          "signature": "t (f i) -\u003e t a -\u003e (Maybe (OuterEq f a), Maybe (InnerEq i a))",
          "source": "src/Type-Eq.html#piecewiseMaybeEq",
          "type": "method"
        },
        "index": {
          "description": "uncurry liftA2 assembleEq",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "piecewiseMaybeEq",
          "normalized": "a(b c)-\u003ea d-\u003e(Maybe(OuterEq b d),Maybe(InnerEq c d))",
          "package": "type-eq",
          "partial": "Maybe Eq",
          "signature": "t(f i)-\u003et a-\u003e(Maybe(OuterEq f a),Maybe(InnerEq i a))",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:piecewiseMaybeEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Eq",
          "name": "sameInnerEq",
          "package": "type-eq",
          "signature": "InnerEq i a -\u003e InnerEq j a -\u003e i :~: j",
          "source": "src/Type-Eq.html#sameInnerEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "sameInnerEq",
          "normalized": "InnerEq a b-\u003eInnerEq c b-\u003ea c",
          "package": "type-eq",
          "partial": "Inner Eq",
          "signature": "InnerEq i a-\u003eInnerEq j a-\u003ei j",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:sameInnerEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnpack equality evidence and use it.\n\u003c/p\u003e\u003cp\u003eThis function compiles with GHC 6.10, but doesn't work.\n\u003c/p\u003e",
          "module": "Type.Eq",
          "name": "withEq",
          "package": "type-eq",
          "signature": "r) -\u003e (a :~: b) -\u003e r",
          "source": "src/Type-Eq.html#withEq",
          "type": "function"
        },
        "index": {
          "description": "Unpack equality evidence and use it This function compiles with GHC but doesn work",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "withEq",
          "normalized": "a)-\u003e(b c)-\u003ea",
          "package": "type-eq",
          "partial": "Eq",
          "signature": "r)-\u003e(a b)-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:withEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnpack partial equality evidence and use it.\n\u003c/p\u003e\u003cp\u003eThis function compiles with GHC 6.10, but doesn't work.\n\u003c/p\u003e",
          "module": "Type.Eq",
          "name": "withInnerEq",
          "package": "type-eq",
          "signature": "r) -\u003e InnerEq i a -\u003e r",
          "source": "src/Type-Eq.html#withInnerEq",
          "type": "function"
        },
        "index": {
          "description": "Unpack partial equality evidence and use it This function compiles with GHC but doesn work",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "withInnerEq",
          "normalized": "a)-\u003eInnerEq b c-\u003ea",
          "package": "type-eq",
          "partial": "Inner Eq",
          "signature": "r)-\u003eInnerEq i a-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:withInnerEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnpack partial equality evidence and use it.\n\u003c/p\u003e\u003cp\u003eThis function compiles with GHC 6.10, but doesn't work.\n\u003c/p\u003e",
          "module": "Type.Eq",
          "name": "withOuterEq",
          "package": "type-eq",
          "signature": "r) -\u003e OuterEq f a -\u003e r",
          "source": "src/Type-Eq.html#withOuterEq",
          "type": "function"
        },
        "index": {
          "description": "Unpack partial equality evidence and use it This function compiles with GHC but doesn work",
          "hierarchy": "Type Eq",
          "module": "Type.Eq",
          "name": "withOuterEq",
          "normalized": "a)-\u003eOuterEq b c-\u003ea",
          "package": "type-eq",
          "partial": "Outer Eq",
          "signature": "r)-\u003eOuterEq f a-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-eq/docs/Type-Eq.html#v:withOuterEq"
      }
    }
  ]
]