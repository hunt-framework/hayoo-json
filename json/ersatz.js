[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "ersatz"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bit",
          "name": "Bit",
          "package": "ersatz",
          "source": "src/Ersatz-Bit.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "Bit",
          "package": "ersatz",
          "partial": "Bit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003e provides a reference to a possibly indeterminate boolean\n value that can be determined by an external SAT solver.\n\u003c/p\u003e",
          "module": "Ersatz.Bit",
          "name": "Bit",
          "package": "ersatz",
          "source": "src/Ersatz-Bit.html#Bit",
          "type": "data"
        },
        "index": {
          "description": "Bit provides reference to possibly indeterminate boolean value that can be determined by an external SAT solver",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "Bit",
          "package": "ersatz",
          "partial": "Bit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#t:Bit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe normal \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e operators in Haskell are not overloaded. This\n provides a richer set that are.\n\u003c/p\u003e\u003cp\u003eInstances for this class for product-like types can be automatically derived\n for any type that is an instance of \u003ccode\u003e\u003ca\u003eGeneric\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ersatz.Bit",
          "name": "Boolean",
          "package": "ersatz",
          "source": "src/Ersatz-Bit.html#Boolean",
          "type": "class"
        },
        "index": {
          "description": "The normal Bool operators in Haskell are not overloaded This provides richer set that are Instances for this class for product-like types can be automatically derived for any type that is an instance of Generic",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "Boolean",
          "package": "ersatz",
          "partial": "Boolean",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#t:Boolean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogical disjunction (inclusive or).\n\u003c/p\u003e",
          "module": "Ersatz.Bit",
          "name": "(||)",
          "package": "ersatz",
          "signature": "b -\u003e b -\u003e b",
          "source": "src/Ersatz-Bit.html#%7C%7C",
          "type": "method"
        },
        "index": {
          "description": "Logical disjunction inclusive or",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "(||) ||",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ersatz",
          "signature": "b-\u003eb-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:-124--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogical conjunction.\n\u003c/p\u003e",
          "module": "Ersatz.Bit",
          "name": "(&&)",
          "package": "ersatz",
          "signature": "b -\u003e b -\u003e b",
          "source": "src/Ersatz-Bit.html#%26%26",
          "type": "method"
        },
        "index": {
          "description": "Logical conjunction",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "(&&) &&",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ersatz",
          "signature": "b-\u003eb-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:-38--38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogical implication.\n\u003c/p\u003e",
          "module": "Ersatz.Bit",
          "name": "(==\u003e)",
          "package": "ersatz",
          "signature": "b -\u003e b -\u003e b",
          "source": "src/Ersatz-Bit.html#%3D%3D%3E",
          "type": "method"
        },
        "index": {
          "description": "Logical implication",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "(==\u003e) ==\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ersatz",
          "signature": "b-\u003eb-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:-61--61--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bit",
          "name": "And",
          "package": "ersatz",
          "signature": "And (Seq Bit)",
          "source": "src/Ersatz-Bit.html#Bit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "And",
          "package": "ersatz",
          "partial": "And",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:And"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bit",
          "name": "Mux",
          "package": "ersatz",
          "signature": "Mux Bit Bit Bit",
          "source": "src/Ersatz-Bit.html#Bit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "Mux",
          "package": "ersatz",
          "partial": "Mux",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:Mux"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bit",
          "name": "Not",
          "package": "ersatz",
          "signature": "Not Bit",
          "source": "src/Ersatz-Bit.html#Bit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "Not",
          "package": "ersatz",
          "partial": "Not",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:Not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bit",
          "name": "Or",
          "package": "ersatz",
          "signature": "Or (Seq Bit)",
          "source": "src/Ersatz-Bit.html#Bit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "Or",
          "package": "ersatz",
          "partial": "Or",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:Or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bit",
          "name": "Var",
          "package": "ersatz",
          "signature": "Var !Literal",
          "source": "src/Ersatz-Bit.html#Bit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "Var",
          "package": "ersatz",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bit",
          "name": "Xor",
          "package": "ersatz",
          "signature": "Xor Bit Bit",
          "source": "src/Ersatz-Bit.html#Bit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "Xor",
          "package": "ersatz",
          "partial": "Xor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:Xor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe logical conjunction of the mapping of a function over several values.\n\u003c/p\u003e",
          "module": "Ersatz.Bit",
          "name": "all",
          "package": "ersatz",
          "signature": "(a -\u003e b) -\u003e t a -\u003e b",
          "source": "src/Ersatz-Bit.html#all",
          "type": "method"
        },
        "index": {
          "description": "The logical conjunction of the mapping of function over several values",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "all",
          "normalized": "(a-\u003eb)-\u003ec a-\u003eb",
          "package": "ersatz",
          "signature": "(a-\u003eb)-\u003et a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:all"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe logical conjunction of several values.\n\u003c/p\u003e",
          "module": "Ersatz.Bit",
          "name": "and",
          "package": "ersatz",
          "signature": "t b -\u003e b",
          "source": "src/Ersatz-Bit.html#and",
          "type": "method"
        },
        "index": {
          "description": "The logical conjunction of several values",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "and",
          "normalized": "a b-\u003eb",
          "package": "ersatz",
          "signature": "t b-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:and"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe logical disjunction of the mapping of a function over several values.\n\u003c/p\u003e",
          "module": "Ersatz.Bit",
          "name": "any",
          "package": "ersatz",
          "signature": "(a -\u003e b) -\u003e t a -\u003e b",
          "source": "src/Ersatz-Bit.html#any",
          "type": "method"
        },
        "index": {
          "description": "The logical disjunction of the mapping of function over several values",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "any",
          "normalized": "(a-\u003eb)-\u003ec a-\u003eb",
          "package": "ersatz",
          "signature": "(a-\u003eb)-\u003et a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:any"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAssert claims that \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003e must be \u003ccode\u003e\u003ca\u003etrue\u003c/a\u003e\u003c/code\u003e in any satisfying interpretation\n of the current problem.\n\u003c/p\u003e",
          "module": "Ersatz.Bit",
          "name": "assert",
          "package": "ersatz",
          "signature": "Bit -\u003e m ()",
          "source": "src/Ersatz-Bit.html#assert",
          "type": "function"
        },
        "index": {
          "description": "Assert claims that Bit must be true in any satisfying interpretation of the current problem",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "assert",
          "normalized": "Bit-\u003ea()",
          "package": "ersatz",
          "signature": "Bit-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:assert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ersatz.Bit",
          "name": "bool",
          "package": "ersatz",
          "signature": "Bool -\u003e b",
          "source": "src/Ersatz-Bit.html#bool",
          "type": "method"
        },
        "index": {
          "description": "Lift Bool",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "bool",
          "normalized": "Bool-\u003ea",
          "package": "ersatz",
          "signature": "Bool-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:bool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChoose between two alternatives based on a selector bit.\n\u003c/p\u003e",
          "module": "Ersatz.Bit",
          "name": "choose",
          "package": "ersatz",
          "signature": "choose",
          "source": "src/Ersatz-Bit.html#choose",
          "type": "method"
        },
        "index": {
          "description": "Choose between two alternatives based on selector bit",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "choose",
          "package": "ersatz",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:choose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\u003ccode\u003e\u003ca\u003efalse\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ebool\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Ersatz.Bit",
          "name": "false",
          "package": "ersatz",
          "signature": "b",
          "source": "src/Ersatz-Bit.html#false",
          "type": "method"
        },
        "index": {
          "description": "false bool False",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "false",
          "package": "ersatz",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:false"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe negated logical conjunction of several values.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003enand\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eand\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Ersatz.Bit",
          "name": "nand",
          "package": "ersatz",
          "signature": "t b -\u003e b",
          "source": "src/Ersatz-Bit.html#nand",
          "type": "method"
        },
        "index": {
          "description": "The negated logical conjunction of several values nand not and",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "nand",
          "normalized": "a b-\u003eb",
          "package": "ersatz",
          "signature": "t b-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:nand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe negated logical disjunction of several values.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003enor\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eor\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Ersatz.Bit",
          "name": "nor",
          "package": "ersatz",
          "signature": "t b -\u003e b",
          "source": "src/Ersatz-Bit.html#nor",
          "type": "method"
        },
        "index": {
          "description": "The negated logical disjunction of several values nor not or",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "nor",
          "normalized": "a b-\u003eb",
          "package": "ersatz",
          "signature": "t b-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:nor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogical negation\n\u003c/p\u003e",
          "module": "Ersatz.Bit",
          "name": "not",
          "package": "ersatz",
          "signature": "b -\u003e b",
          "source": "src/Ersatz-Bit.html#not",
          "type": "method"
        },
        "index": {
          "description": "Logical negation",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "not",
          "normalized": "a-\u003ea",
          "package": "ersatz",
          "signature": "b-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe logical disjunction of several values.\n\u003c/p\u003e",
          "module": "Ersatz.Bit",
          "name": "or",
          "package": "ersatz",
          "signature": "t b -\u003e b",
          "source": "src/Ersatz-Bit.html#or",
          "type": "method"
        },
        "index": {
          "description": "The logical disjunction of several values",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "or",
          "normalized": "a b-\u003eb",
          "package": "ersatz",
          "signature": "t b-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\u003ccode\u003e\u003ca\u003etrue\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ebool\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Ersatz.Bit",
          "name": "true",
          "package": "ersatz",
          "signature": "b",
          "source": "src/Ersatz-Bit.html#true",
          "type": "method"
        },
        "index": {
          "description": "true bool True",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "true",
          "package": "ersatz",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:true"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExclusive-or\n\u003c/p\u003e",
          "module": "Ersatz.Bit",
          "name": "xor",
          "package": "ersatz",
          "signature": "b -\u003e b -\u003e b",
          "source": "src/Ersatz-Bit.html#xor",
          "type": "method"
        },
        "index": {
          "description": "Exclusive-or",
          "hierarchy": "Ersatz Bit",
          "module": "Ersatz.Bit",
          "name": "xor",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ersatz",
          "signature": "b-\u003eb-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:xor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bits",
          "name": "Bits",
          "package": "ersatz",
          "source": "src/Ersatz-Bits.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bits",
          "package": "ersatz",
          "partial": "Bits",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA container of 1 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003e that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ersatz.Bits",
          "name": "Bit1",
          "package": "ersatz",
          "source": "src/Ersatz-Bits.html#Bit1",
          "type": "newtype"
        },
        "index": {
          "description": "container of Bit that encode from and decode to Word8",
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit1",
          "package": "ersatz",
          "partial": "Bit",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA container of 2 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ersatz.Bits",
          "name": "Bit2",
          "package": "ersatz",
          "source": "src/Ersatz-Bits.html#Bit2",
          "type": "data"
        },
        "index": {
          "description": "container of Bit that encode from and decode to Word8",
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit2",
          "package": "ersatz",
          "partial": "Bit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA container of 3 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ersatz.Bits",
          "name": "Bit3",
          "package": "ersatz",
          "source": "src/Ersatz-Bits.html#Bit3",
          "type": "data"
        },
        "index": {
          "description": "container of Bit that encode from and decode to Word8",
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit3",
          "package": "ersatz",
          "partial": "Bit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA container of 4 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ersatz.Bits",
          "name": "Bit4",
          "package": "ersatz",
          "source": "src/Ersatz-Bits.html#Bit4",
          "type": "data"
        },
        "index": {
          "description": "container of Bit that encode from and decode to Word8",
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit4",
          "package": "ersatz",
          "partial": "Bit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA container of 5 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ersatz.Bits",
          "name": "Bit5",
          "package": "ersatz",
          "source": "src/Ersatz-Bits.html#Bit5",
          "type": "data"
        },
        "index": {
          "description": "container of Bit that encode from and decode to Word8",
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit5",
          "package": "ersatz",
          "partial": "Bit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA container of 6 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ersatz.Bits",
          "name": "Bit6",
          "package": "ersatz",
          "source": "src/Ersatz-Bits.html#Bit6",
          "type": "data"
        },
        "index": {
          "description": "container of Bit that encode from and decode to Word8",
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit6",
          "package": "ersatz",
          "partial": "Bit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA container of 7 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ersatz.Bits",
          "name": "Bit7",
          "package": "ersatz",
          "source": "src/Ersatz-Bits.html#Bit7",
          "type": "data"
        },
        "index": {
          "description": "container of Bit that encode from and decode to Word8",
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit7",
          "package": "ersatz",
          "partial": "Bit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA container of 8 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ersatz.Bits",
          "name": "Bit8",
          "package": "ersatz",
          "source": "src/Ersatz-Bits.html#Bit8",
          "type": "data"
        },
        "index": {
          "description": "container of Bit that encode from and decode to Word8",
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit8",
          "package": "ersatz",
          "partial": "Bit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bits",
          "name": "Bit1",
          "package": "ersatz",
          "signature": "Bit1 Bit",
          "source": "src/Ersatz-Bits.html#Bit1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit1",
          "package": "ersatz",
          "partial": "Bit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bits",
          "name": "Bit2",
          "package": "ersatz",
          "signature": "Bit2 !Bit !Bit",
          "source": "src/Ersatz-Bits.html#Bit2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit2",
          "package": "ersatz",
          "partial": "Bit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bits",
          "name": "Bit3",
          "package": "ersatz",
          "signature": "Bit3 !Bit !Bit !Bit",
          "source": "src/Ersatz-Bits.html#Bit3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit3",
          "package": "ersatz",
          "partial": "Bit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bits",
          "name": "Bit4",
          "package": "ersatz",
          "signature": "Bit4 !Bit !Bit !Bit !Bit",
          "source": "src/Ersatz-Bits.html#Bit4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit4",
          "package": "ersatz",
          "partial": "Bit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bits",
          "name": "Bit5",
          "package": "ersatz",
          "signature": "Bit5 !Bit !Bit !Bit !Bit !Bit",
          "source": "src/Ersatz-Bits.html#Bit5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit5",
          "package": "ersatz",
          "partial": "Bit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bits",
          "name": "Bit6",
          "package": "ersatz",
          "signature": "Bit6 !Bit !Bit !Bit !Bit !Bit !Bit",
          "source": "src/Ersatz-Bits.html#Bit6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit6",
          "package": "ersatz",
          "partial": "Bit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bits",
          "name": "Bit7",
          "package": "ersatz",
          "signature": "Bit7 !Bit !Bit !Bit !Bit !Bit !Bit !Bit",
          "source": "src/Ersatz-Bits.html#Bit7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit7",
          "package": "ersatz",
          "partial": "Bit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Bits",
          "name": "Bit8",
          "package": "ersatz",
          "signature": "Bit8 !Bit !Bit !Bit !Bit !Bit !Bit !Bit !Bit",
          "source": "src/Ersatz-Bits.html#Bit8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Bits",
          "module": "Ersatz.Bits",
          "name": "Bit8",
          "package": "ersatz",
          "partial": "Bit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Decoding",
          "name": "Decoding",
          "package": "ersatz",
          "source": "src/Ersatz-Decoding.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ersatz Decoding",
          "module": "Ersatz.Decoding",
          "name": "Decoding",
          "package": "ersatz",
          "partial": "Decoding",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Decoding.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Decoding",
          "name": "Decoding",
          "package": "ersatz",
          "source": "src/Ersatz-Decoding.html#Decoding",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ersatz Decoding",
          "module": "Ersatz.Decoding",
          "name": "Decoding",
          "package": "ersatz",
          "partial": "Decoding",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Decoding.html#t:Decoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a value based on the solution if one can be determined.\n\u003c/p\u003e",
          "module": "Ersatz.Decoding",
          "name": "decode",
          "package": "ersatz",
          "signature": "Solution -\u003e a -\u003e Maybe (Decoded a)",
          "source": "src/Ersatz-Decoding.html#decode",
          "type": "method"
        },
        "index": {
          "description": "Return value based on the solution if one can be determined",
          "hierarchy": "Ersatz Decoding",
          "module": "Ersatz.Decoding",
          "name": "decode",
          "normalized": "Solution-\u003ea-\u003eMaybe(Decoded a)",
          "package": "ersatz",
          "signature": "Solution-\u003ea-\u003eMaybe(Decoded a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Decoding.html#v:decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Encoding",
          "name": "Encoding",
          "package": "ersatz",
          "source": "src/Ersatz-Encoding.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ersatz Encoding",
          "module": "Ersatz.Encoding",
          "name": "Encoding",
          "package": "ersatz",
          "partial": "Encoding",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Encoding.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Encoding",
          "name": "Encoding",
          "package": "ersatz",
          "source": "src/Ersatz-Encoding.html#Encoding",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ersatz Encoding",
          "module": "Ersatz.Encoding",
          "name": "Encoding",
          "package": "ersatz",
          "partial": "Encoding",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Encoding.html#t:Encoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA counterpart to \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003e. Can encode e.g. a \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e as a\n \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003e, a \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e as a \u003ccode\u003e\u003ca\u003eBit8\u003c/a\u003e\u003c/code\u003e, or a\n \u003ccode\u003e[Word8]\u003c/code\u003e as a \u003ccode\u003e[Bit8]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Ersatz.Encoding",
          "name": "encode",
          "package": "ersatz",
          "signature": "Encoded a -\u003e a",
          "source": "src/Ersatz-Encoding.html#encode",
          "type": "method"
        },
        "index": {
          "description": "counterpart to decode Can encode e.g Bool as Bit Word8 as Bit8 or Word8 as Bit8",
          "hierarchy": "Ersatz Encoding",
          "module": "Ersatz.Encoding",
          "name": "encode",
          "normalized": "Encoded a-\u003ea",
          "package": "ersatz",
          "signature": "Encoded a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Encoding.html#v:encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Equatable",
          "name": "Equatable",
          "package": "ersatz",
          "source": "src/Ersatz-Equatable.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ersatz Equatable",
          "module": "Ersatz.Equatable",
          "name": "Equatable",
          "package": "ersatz",
          "partial": "Equatable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Equatable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInstances for this class for arbitrary types can be automatically derived from \u003ccode\u003e\u003ca\u003eGeneric\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Ersatz.Equatable",
          "name": "Equatable",
          "package": "ersatz",
          "source": "src/Ersatz-Equatable.html#Equatable",
          "type": "class"
        },
        "index": {
          "description": "Instances for this class for arbitrary types can be automatically derived from Generic",
          "hierarchy": "Ersatz Equatable",
          "module": "Ersatz.Equatable",
          "name": "Equatable",
          "package": "ersatz",
          "partial": "Equatable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Equatable.html#t:Equatable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompare for inequality within the SAT problem.\n\u003c/p\u003e",
          "module": "Ersatz.Equatable",
          "name": "(/==)",
          "package": "ersatz",
          "signature": "t -\u003e t -\u003e Bit",
          "source": "src/Ersatz-Equatable.html#%2F%3D%3D",
          "type": "method"
        },
        "index": {
          "description": "Compare for inequality within the SAT problem",
          "hierarchy": "Ersatz Equatable",
          "module": "Ersatz.Equatable",
          "name": "(/==) /==",
          "normalized": "a-\u003ea-\u003eBit",
          "package": "ersatz",
          "signature": "t-\u003et-\u003eBit",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Equatable.html#v:-47--61--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompare for equality within the SAT problem.\n\u003c/p\u003e",
          "module": "Ersatz.Equatable",
          "name": "(===)",
          "package": "ersatz",
          "signature": "t -\u003e t -\u003e Bit",
          "source": "src/Ersatz-Equatable.html#%3D%3D%3D",
          "type": "method"
        },
        "index": {
          "description": "Compare for equality within the SAT problem",
          "hierarchy": "Ersatz Equatable",
          "module": "Ersatz.Equatable",
          "name": "(===) ===",
          "normalized": "a-\u003ea-\u003eBit",
          "package": "ersatz",
          "signature": "t-\u003et-\u003eBit",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Equatable.html#v:-61--61--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Internal.Formula",
          "name": "Formula",
          "package": "ersatz",
          "source": "src/Ersatz-Internal-Formula.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "Formula",
          "package": "ersatz",
          "partial": "Formula",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA disjunction of possibly negated atoms. Negated atoms are represented\n by negating the identifier.\n\u003c/p\u003e",
          "module": "Ersatz.Internal.Formula",
          "name": "Clause",
          "package": "ersatz",
          "source": "src/Ersatz-Internal-Formula.html#Clause",
          "type": "newtype"
        },
        "index": {
          "description": "disjunction of possibly negated atoms Negated atoms are represented by negating the identifier",
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "Clause",
          "package": "ersatz",
          "partial": "Clause",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#t:Clause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA conjunction of clauses\n\u003c/p\u003e",
          "module": "Ersatz.Internal.Formula",
          "name": "Formula",
          "package": "ersatz",
          "source": "src/Ersatz-Internal-Formula.html#Formula",
          "type": "newtype"
        },
        "index": {
          "description": "conjunction of clauses",
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "Formula",
          "package": "ersatz",
          "partial": "Formula",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#t:Formula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Internal.Formula",
          "name": "Clause",
          "package": "ersatz",
          "signature": "Clause",
          "source": "src/Ersatz-Internal-Formula.html#Clause",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "Clause",
          "package": "ersatz",
          "partial": "Clause",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:Clause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Internal.Formula",
          "name": "Formula",
          "package": "ersatz",
          "signature": "Formula",
          "source": "src/Ersatz-Internal-Formula.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "Formula",
          "package": "ersatz",
          "partial": "Formula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:Formula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the (possibly negated) atoms referenced by a \u003ccode\u003e\u003ca\u003eClause\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Ersatz.Internal.Formula",
          "name": "clauseLiterals",
          "package": "ersatz",
          "signature": "Clause -\u003e [Literal]",
          "source": "src/Ersatz-Internal-Formula.html#clauseLiterals",
          "type": "function"
        },
        "index": {
          "description": "Extract the possibly negated atoms referenced by Clause",
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "clauseLiterals",
          "normalized": "Clause-\u003e[Literal]",
          "package": "ersatz",
          "partial": "Literals",
          "signature": "Clause-\u003e[Literal]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:clauseLiterals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Internal.Formula",
          "name": "clauseSet",
          "package": "ersatz",
          "signature": "IntSet",
          "source": "src/Ersatz-Internal-Formula.html#Clause",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "clauseSet",
          "package": "ersatz",
          "partial": "Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:clauseSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe boolean \u003cem\u003eand\u003c/em\u003e operation\n\u003c/p\u003e\u003cp\u003eDerivation of the Tseitin transformation:\n\u003c/p\u003e\u003cpre\u003e\n O &#8801; (A & B & C)\n (O &#8594; (A& B & C)) & (&#172;O &#8594; &#172;& B & C))\n (&#172;O | (A& B & C)) & (O | &#172;(A& B & C))\n (&#172;O | A)& (&#172;O | B)& (&#172;O | C)& (O | &#172;A | &#172;B | &#172;\u003c/pre\u003e",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaAnd",
          "package": "ersatz",
          "signature": "Literal-\u003e [Literal]-\u003e Formula",
          "type": "function"
        },
        "index": {
          "description": "The boolean and operation Derivation of the Tseitin transformation",
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaAnd",
          "normalized": "Literal-\u003e[Literal]-\u003eFormula",
          "package": "ersatz",
          "partial": "And",
          "signature": "Literal-\u003e[Literal]-\u003eFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaAnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA formula with no clauses\n\u003c/p\u003e",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaEmpty",
          "package": "ersatz",
          "signature": "Formula",
          "source": "src/Ersatz-Internal-Formula.html#formulaEmpty",
          "type": "function"
        },
        "index": {
          "description": "formula with no clauses",
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaEmpty",
          "package": "ersatz",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAssert a literal\n\u003c/p\u003e",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaLiteral",
          "package": "ersatz",
          "signature": "Literal -\u003e Formula",
          "source": "src/Ersatz-Internal-Formula.html#formulaLiteral",
          "type": "function"
        },
        "index": {
          "description": "Assert literal",
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaLiteral",
          "normalized": "Literal-\u003eFormula",
          "package": "ersatz",
          "partial": "Literal",
          "signature": "Literal-\u003eFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe boolean \u003cem\u003eelse-then-if\u003c/em\u003e or \u003cem\u003emux\u003c/em\u003e operation\n\u003c/p\u003e\u003cp\u003eDerivation of the Tseitin transformation:\n\u003c/p\u003e\u003cpre\u003e\n O &#8801; (F & &#172;P) | (T& P)\n (O &#8594; ((F& &#172;P) | (T& P))) & (&#172;O &#8594; &#172;(& &#172;P) | (T& P)))\n\u003c/pre\u003e\u003cp\u003eLeft hand side:\n\u003c/p\u003e\u003cpre\u003e\n O &#8594; ((F& &#172;P) | (T& P))\n &#172;O | ((F& &#172;P) | (T& P))\n &#172;O | ((F | T)& (F | P) & (T | &#172;P)& (&#172;P | P)) &#172;O | ((F | T)& (F | P) & (T | &#172;P)) (&#172;O | F | T)& (&#172;O | F | P)& (&#172;O | T | &#172;P\u003c/pre\u003e\u003cp\u003eRight hand side:\n\u003c/p\u003e\u003cpre\u003e\n &#172;O &#8594; &#172;(& &#172;P) | (T& P))\n O | &#172;((F& &#172;P) | (T& P))\n O | (&#172;(F& &#172;P)& &#172;(T& P))\n O | ((&#172;F | P)& (&#172;T | &#172;P) (O | &#172;F | P)& (O | &#172;T | &#172;P\u003c/pre\u003e\u003cp\u003eResult:\n\u003c/p\u003e\u003cpre\u003e\n (&#172;O | F | T)& (&#172;O | F | P)& (&#172;O | T | &#172;P& (O | &#172;F | P)& (O | &#172;T | &#172;P\u003c/pre\u003e",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaMux",
          "package": "ersatz",
          "signature": "Literal-\u003e Literal-\u003e Literal-\u003e Literal-\u003e Formula",
          "type": "function"
        },
        "index": {
          "description": "The boolean else-then-if or mux operation Derivation of the Tseitin transformation Left hand side Right hand side Result",
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaMux",
          "normalized": "Literal-\u003eLiteral-\u003eLiteral-\u003eLiteral-\u003eFormula",
          "package": "ersatz",
          "partial": "Mux",
          "signature": "Literal-\u003eLiteral-\u003eLiteral-\u003eLiteral-\u003eFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaMux"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe boolean \u003cem\u003enot\u003c/em\u003e operation\n\u003c/p\u003e\u003cp\u003eDerivation of the Tseitin transformation:\n\u003c/p\u003e\u003cpre\u003e\n O &#8801; &#172;A (O &#8594; &#172;A& (&#172;O &#8594; A (&#172;O | &#172;A& (O | A)\n\u003c/pre\u003e",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaNot",
          "package": "ersatz",
          "signature": "Literal-\u003e Literal-\u003e Formula",
          "type": "function"
        },
        "index": {
          "description": "The boolean not operation Derivation of the Tseitin transformation",
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaNot",
          "normalized": "Literal-\u003eLiteral-\u003eFormula",
          "package": "ersatz",
          "partial": "Not",
          "signature": "Literal-\u003eLiteral-\u003eFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaNot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe boolean \u003cem\u003eor\u003c/em\u003e operation\n\u003c/p\u003e\u003cp\u003eDerivation of the Tseitin transformation:\n\u003c/p\u003e\u003cpre\u003e\n O &#8801; (A | B | C)\n (O &#8594; (A | B | C))& (&#172;O &#8594; &#172;(A | B | C (&#172;O | (A | B | C))& (O | &#172;(A | B | C)) (&#172;O | A | B | C)& (O | (&#172;A& &#172;B& &#172;C)) (&#172;O | A | B | C)& (O | &#172;A)& (O | &#172;B)& (O | &#172;C)\u003c/pre\u003e",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaOr",
          "package": "ersatz",
          "signature": "Literal-\u003e [Literal]-\u003e Formula",
          "type": "function"
        },
        "index": {
          "description": "The boolean or operation Derivation of the Tseitin transformation",
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaOr",
          "normalized": "Literal-\u003e[Literal]-\u003eFormula",
          "package": "ersatz",
          "partial": "Or",
          "signature": "Literal-\u003e[Literal]-\u003eFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaOr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Internal.Formula",
          "name": "formulaSet",
          "package": "ersatz",
          "signature": "Set Clause",
          "source": "src/Ersatz-Internal-Formula.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaSet",
          "package": "ersatz",
          "partial": "Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe boolean \u003cem\u003exor\u003c/em\u003e operation\n\u003c/p\u003e\u003cp\u003eDerivation of the Tseitin transformation:\n\u003c/p\u003e\u003cpre\u003e\n O &#8801; A &#8853; B O &#8801; ((&#172;A& B) | (A & &#172;B)) (O &#8594; ((&#172;& B) | (A & &#172;B)))& (&#172;O &#8594; &#172;(& B) | (A & &#172;B)))\u003c/pre\u003e\u003cp\u003eLeft hand side:\n\u003c/p\u003e\u003cpre\u003e\n O &#8594; ((&#172;& B) | (A & &#172;B)) &#172;O | ((&#172;& B) | (A & &#172;B)) &#172;O | ((&#172;A | A& (&#172;A | &#172;B& (A | B) & (&#172;B | B)) &#172;O | ((&#172;A | &#172;& (A | B))\n (&#172;O | &#172;A | &#172;& (&#172;O | A | B)\u003c/pre\u003e\u003cp\u003eRight hand side:\n\u003c/p\u003e\u003cpre\u003e\n &#172;O &#8594; &#172;(& B) | (A & &#172;B)) O | &#172;((&#172;& B) | (A & &#172;B)) O | (&#172;(&#172;& B) & &#172;(A& &#172;B)) O | ((A | &#172;B)& (&#172;A | B)) (O | &#172;A | B)& (O | A | &#172;B)\u003c/pre\u003e\u003cp\u003eResult:\n\u003c/p\u003e\u003cpre\u003e\n (&#172;O | &#172;A | &#172;& (&#172;O | A | B)& (O | &#172;A | B)& (O | A | &#172;B)\u003c/pre\u003e",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaXor",
          "package": "ersatz",
          "signature": "Literal-\u003e Literal-\u003e Literal-\u003e Formula",
          "type": "function"
        },
        "index": {
          "description": "The boolean xor operation Derivation of the Tseitin transformation Left hand side Right hand side Result",
          "hierarchy": "Ersatz Internal Formula",
          "module": "Ersatz.Internal.Formula",
          "name": "formulaXor",
          "normalized": "Literal-\u003eLiteral-\u003eLiteral-\u003eFormula",
          "package": "ersatz",
          "partial": "Xor",
          "signature": "Literal-\u003eLiteral-\u003eLiteral-\u003eFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaXor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Internal.Literal",
          "name": "Literal",
          "package": "ersatz",
          "source": "src/Ersatz-Internal-Literal.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ersatz Internal Literal",
          "module": "Ersatz.Internal.Literal",
          "name": "Literal",
          "package": "ersatz",
          "partial": "Literal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Literal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA naked possibly-negated Atom, present in the target \u003ccode\u003e\u003ca\u003eSolver\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe literals \u003ccode\u003e-1\u003c/code\u003e and \u003ccode\u003e1\u003c/code\u003e are dedicated for the constant \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e and the\n constant \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e respectively.\n\u003c/p\u003e",
          "module": "Ersatz.Internal.Literal",
          "name": "Literal",
          "package": "ersatz",
          "source": "src/Ersatz-Internal-Literal.html#Literal",
          "type": "newtype"
        },
        "index": {
          "description": "naked possibly-negated Atom present in the target Solver The literals and are dedicated for the constant False and the constant True respectively",
          "hierarchy": "Ersatz Internal Literal",
          "module": "Ersatz.Internal.Literal",
          "name": "Literal",
          "package": "ersatz",
          "partial": "Literal",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Literal.html#t:Literal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Internal.Literal",
          "name": "Literal",
          "package": "ersatz",
          "signature": "Literal",
          "source": "src/Ersatz-Internal-Literal.html#Literal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Internal Literal",
          "module": "Ersatz.Internal.Literal",
          "name": "Literal",
          "package": "ersatz",
          "partial": "Literal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Literal.html#v:Literal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e constant. The literal \u003ccode\u003e-1\u003c/code\u003e is dedicated for it.\n\u003c/p\u003e",
          "module": "Ersatz.Internal.Literal",
          "name": "literalFalse",
          "package": "ersatz",
          "signature": "Literal",
          "source": "src/Ersatz-Internal-Literal.html#literalFalse",
          "type": "function"
        },
        "index": {
          "description": "The False constant The literal is dedicated for it",
          "hierarchy": "Ersatz Internal Literal",
          "module": "Ersatz.Internal.Literal",
          "name": "literalFalse",
          "package": "ersatz",
          "partial": "False",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Literal.html#v:literalFalse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Internal.Literal",
          "name": "literalId",
          "package": "ersatz",
          "signature": "Int",
          "source": "src/Ersatz-Internal-Literal.html#Literal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Internal Literal",
          "module": "Ersatz.Internal.Literal",
          "name": "literalId",
          "package": "ersatz",
          "partial": "Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Literal.html#v:literalId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e constant. The literal \u003ccode\u003e1\u003c/code\u003e is dedicated for it.\n\u003c/p\u003e",
          "module": "Ersatz.Internal.Literal",
          "name": "literalTrue",
          "package": "ersatz",
          "signature": "Literal",
          "source": "src/Ersatz-Internal-Literal.html#literalTrue",
          "type": "function"
        },
        "index": {
          "description": "The True constant The literal is dedicated for it",
          "hierarchy": "Ersatz Internal Literal",
          "module": "Ersatz.Internal.Literal",
          "name": "literalTrue",
          "package": "ersatz",
          "partial": "True",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Literal.html#v:literalTrue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Internal.Literal",
          "name": "negateLiteral",
          "package": "ersatz",
          "signature": "Literal -\u003e Literal",
          "source": "src/Ersatz-Internal-Literal.html#negateLiteral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Internal Literal",
          "module": "Ersatz.Internal.Literal",
          "name": "negateLiteral",
          "normalized": "Literal-\u003eLiteral",
          "package": "ersatz",
          "partial": "Literal",
          "signature": "Literal-\u003eLiteral",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Literal.html#v:negateLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "Problem",
          "package": "ersatz",
          "source": "src/Ersatz-Problem.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "Problem",
          "package": "ersatz",
          "partial": "Problem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDIMACS file format pretty printer\n\u003c/p\u003e\u003cp\u003eThis is used to generate the problem statement for a given \u003ccode\u003e\u003ca\u003eSAT\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSolver\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Ersatz.Problem",
          "name": "DIMACS",
          "package": "ersatz",
          "source": "src/Ersatz-Problem.html#DIMACS",
          "type": "class"
        },
        "index": {
          "description": "DIMACS file format pretty printer This is used to generate the problem statement for given SAT Solver",
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "DIMACS",
          "package": "ersatz",
          "partial": "DIMACS",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#t:DIMACS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "HasQSAT",
          "package": "ersatz",
          "source": "src/Ersatz-Problem.html#HasQSAT",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "HasQSAT",
          "package": "ersatz",
          "partial": "Has QSAT",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#t:HasQSAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "HasSAT",
          "package": "ersatz",
          "source": "src/Ersatz-Problem.html#HasSAT",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "HasSAT",
          "package": "ersatz",
          "partial": "Has SAT",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#t:HasSAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQDIMACS file format pretty printer\n\u003c/p\u003e\u003cp\u003eThis is used to generate the problem statement for a given \u003ccode\u003e\u003ca\u003eQSAT\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSolver\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Ersatz.Problem",
          "name": "QDIMACS",
          "package": "ersatz",
          "source": "src/Ersatz-Problem.html#QDIMACS",
          "type": "class"
        },
        "index": {
          "description": "QDIMACS file format pretty printer This is used to generate the problem statement for given QSAT Solver",
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "QDIMACS",
          "package": "ersatz",
          "partial": "QDIMACS",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#t:QDIMACS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA (quantified) boolean formula.\n\u003c/p\u003e",
          "module": "Ersatz.Problem",
          "name": "QSAT",
          "package": "ersatz",
          "source": "src/Ersatz-Problem.html#QSAT",
          "type": "data"
        },
        "index": {
          "description": "quantified boolean formula",
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "QSAT",
          "package": "ersatz",
          "partial": "QSAT",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#t:QSAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "SAT",
          "package": "ersatz",
          "source": "src/Ersatz-Problem.html#SAT",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "SAT",
          "package": "ersatz",
          "partial": "SAT",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#t:SAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWDIMACS file format pretty printer\n\u003c/p\u003e\u003cp\u003eThis is used to generate the problem statement for a given \u003ccode\u003eMaxSAT\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSolver\u003c/a\u003e\u003c/code\u003e (TODO).\n\u003c/p\u003e",
          "module": "Ersatz.Problem",
          "name": "WDIMACS",
          "package": "ersatz",
          "source": "src/Ersatz-Problem.html#WDIMACS",
          "type": "class"
        },
        "index": {
          "description": "WDIMACS file format pretty printer This is used to generate the problem statement for given MaxSAT Solver TODO",
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "WDIMACS",
          "package": "ersatz",
          "partial": "WDIMACS",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#t:WDIMACS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "QSAT",
          "package": "ersatz",
          "signature": "QSAT !IntSet SAT",
          "source": "src/Ersatz-Problem.html#QSAT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "QSAT",
          "package": "ersatz",
          "partial": "QSAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:QSAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "SAT",
          "package": "ersatz",
          "signature": "SAT !Int !Formula !(HashMap (StableName ()) Literal)",
          "source": "src/Ersatz-Problem.html#SAT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "SAT",
          "normalized": "SAT Int Formula(HashMap(StableName())Literal)",
          "package": "ersatz",
          "partial": "SAT",
          "signature": "SAT Int Formula(HashMap(StableName())Literal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:SAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "assertFormula",
          "package": "ersatz",
          "signature": "Formula -\u003e m ()",
          "source": "src/Ersatz-Problem.html#assertFormula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "assertFormula",
          "normalized": "Formula-\u003ea()",
          "package": "ersatz",
          "partial": "Formula",
          "signature": "Formula-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:assertFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a \u003ccode\u003e\u003ca\u003eBuilder\u003c/a\u003e\u003c/code\u003e out of a \u003ccode\u003e\u003ca\u003eDIMACS\u003c/a\u003e\u003c/code\u003e problem.\n\u003c/p\u003e",
          "module": "Ersatz.Problem",
          "name": "dimacs",
          "package": "ersatz",
          "signature": "t -\u003e Builder",
          "source": "src/Ersatz-Problem.html#dimacs",
          "type": "function"
        },
        "index": {
          "description": "Generate Builder out of DIMACS problem",
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "dimacs",
          "normalized": "a-\u003eBuilder",
          "package": "ersatz",
          "signature": "t-\u003eBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:dimacs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "dimacsClauses",
          "package": "ersatz",
          "signature": "t -\u003e Set IntSet",
          "source": "src/Ersatz-Problem.html#dimacsClauses",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "dimacsClauses",
          "normalized": "a-\u003eSet IntSet",
          "package": "ersatz",
          "partial": "Clauses",
          "signature": "t-\u003eSet IntSet",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:dimacsClauses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "dimacsComments",
          "package": "ersatz",
          "signature": "t -\u003e [ByteString]",
          "source": "src/Ersatz-Problem.html#dimacsComments",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "dimacsComments",
          "normalized": "a-\u003e[ByteString]",
          "package": "ersatz",
          "partial": "Comments",
          "signature": "t-\u003e[ByteString]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:dimacsComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "dimacsNumVariables",
          "package": "ersatz",
          "signature": "t -\u003e Int",
          "source": "src/Ersatz-Problem.html#dimacsNumVariables",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "dimacsNumVariables",
          "normalized": "a-\u003eInt",
          "package": "ersatz",
          "partial": "Num Variables",
          "signature": "t-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:dimacsNumVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eSAT\u003c/a\u003e\u003c/code\u003e-generating state computation and return the respective\n \u003ccode\u003e\u003ca\u003eDIMACS\u003c/a\u003e\u003c/code\u003e output. Useful for testing and debugging.\n\u003c/p\u003e",
          "module": "Ersatz.Problem",
          "name": "dimacsSAT",
          "package": "ersatz",
          "signature": "StateT SAT Identity a -\u003e ByteString",
          "source": "src/Ersatz-Problem.html#dimacsSAT",
          "type": "function"
        },
        "index": {
          "description": "Run SAT generating state computation and return the respective DIMACS output Useful for testing and debugging",
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "dimacsSAT",
          "normalized": "StateT SAT Identity a-\u003eByteString",
          "package": "ersatz",
          "partial": "SAT",
          "signature": "StateT SAT Identity a-\u003eByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:dimacsSAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "formula",
          "package": "ersatz",
          "signature": "Lens' t Formula",
          "source": "src/Ersatz-Problem.html#formula",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "formula",
          "package": "ersatz",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:formula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "generateLiteral",
          "package": "ersatz",
          "signature": "a -\u003e (Literal -\u003e m ()) -\u003e m Literal",
          "source": "src/Ersatz-Problem.html#generateLiteral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "generateLiteral",
          "normalized": "a-\u003e(Literal-\u003eb())-\u003eb Literal",
          "package": "ersatz",
          "partial": "Literal",
          "signature": "a-\u003e(Literal-\u003em())-\u003em Literal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:generateLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "lastAtom",
          "package": "ersatz",
          "signature": "Lens' t Int",
          "source": "src/Ersatz-Problem.html#lastAtom",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "lastAtom",
          "package": "ersatz",
          "partial": "Atom",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:lastAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "literalExists",
          "package": "ersatz",
          "signature": "m Literal",
          "source": "src/Ersatz-Problem.html#literalExists",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "literalExists",
          "package": "ersatz",
          "partial": "Exists",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:literalExists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "literalForall",
          "package": "ersatz",
          "signature": "m Literal",
          "source": "src/Ersatz-Problem.html#literalForall",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "literalForall",
          "package": "ersatz",
          "partial": "Forall",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:literalForall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a \u003ccode\u003e\u003ca\u003eBuilder\u003c/a\u003e\u003c/code\u003e out of a \u003ccode\u003e\u003ca\u003eQDIMACS\u003c/a\u003e\u003c/code\u003e problem.\n\u003c/p\u003e",
          "module": "Ersatz.Problem",
          "name": "qdimacs",
          "package": "ersatz",
          "signature": "t -\u003e Builder",
          "source": "src/Ersatz-Problem.html#qdimacs",
          "type": "function"
        },
        "index": {
          "description": "Generate Builder out of QDIMACS problem",
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "qdimacs",
          "normalized": "a-\u003eBuilder",
          "package": "ersatz",
          "signature": "t-\u003eBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:qdimacs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "qdimacsClauses",
          "package": "ersatz",
          "signature": "t -\u003e Set IntSet",
          "source": "src/Ersatz-Problem.html#qdimacsClauses",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "qdimacsClauses",
          "normalized": "a-\u003eSet IntSet",
          "package": "ersatz",
          "partial": "Clauses",
          "signature": "t-\u003eSet IntSet",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:qdimacsClauses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "qdimacsComments",
          "package": "ersatz",
          "signature": "t -\u003e [ByteString]",
          "source": "src/Ersatz-Problem.html#qdimacsComments",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "qdimacsComments",
          "normalized": "a-\u003e[ByteString]",
          "package": "ersatz",
          "partial": "Comments",
          "signature": "t-\u003e[ByteString]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:qdimacsComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "qdimacsNumVariables",
          "package": "ersatz",
          "signature": "t -\u003e Int",
          "source": "src/Ersatz-Problem.html#qdimacsNumVariables",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "qdimacsNumVariables",
          "normalized": "a-\u003eInt",
          "package": "ersatz",
          "partial": "Num Variables",
          "signature": "t-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:qdimacsNumVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eQSAT\u003c/a\u003e\u003c/code\u003e-generating state computation and return the respective\n \u003ccode\u003e\u003ca\u003eQDIMACS\u003c/a\u003e\u003c/code\u003e output. Useful for testing and debugging.\n\u003c/p\u003e",
          "module": "Ersatz.Problem",
          "name": "qdimacsQSAT",
          "package": "ersatz",
          "signature": "StateT QSAT Identity a -\u003e ByteString",
          "source": "src/Ersatz-Problem.html#qdimacsQSAT",
          "type": "function"
        },
        "index": {
          "description": "Run QSAT generating state computation and return the respective QDIMACS output Useful for testing and debugging",
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "qdimacsQSAT",
          "normalized": "StateT QSAT Identity a-\u003eByteString",
          "package": "ersatz",
          "partial": "QSAT",
          "signature": "StateT QSAT Identity a-\u003eByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:qdimacsQSAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "qdimacsQuantified",
          "package": "ersatz",
          "signature": "t -\u003e [Quant]",
          "source": "src/Ersatz-Problem.html#qdimacsQuantified",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "qdimacsQuantified",
          "normalized": "a-\u003e[Quant]",
          "package": "ersatz",
          "partial": "Quantified",
          "signature": "t-\u003e[Quant]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:qdimacsQuantified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "qsat",
          "package": "ersatz",
          "signature": "Lens' t QSAT",
          "source": "src/Ersatz-Problem.html#qsat",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "qsat",
          "package": "ersatz",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:qsat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eQSAT\u003c/a\u003e\u003c/code\u003e-generating state computation. Useful e.g. in ghci for\n disambiguating the type of a \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eHasQSAT\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e",
          "module": "Ersatz.Problem",
          "name": "runQSAT",
          "package": "ersatz",
          "signature": "StateT QSAT m a -\u003e m (a, QSAT)",
          "source": "src/Ersatz-Problem.html#runQSAT",
          "type": "function"
        },
        "index": {
          "description": "Run QSAT generating state computation Useful e.g in ghci for disambiguating the type of MonadState HasQSAT value",
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "runQSAT",
          "normalized": "StateT QSAT a b-\u003ea(b,QSAT)",
          "package": "ersatz",
          "partial": "QSAT",
          "signature": "StateT QSAT m a-\u003em(a,QSAT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:runQSAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eQSAT\u003c/a\u003e\u003c/code\u003e-generating state computation in the \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e monad. Useful\n e.g. in ghci for disambiguating the type of a \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eHasQSAT\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e",
          "module": "Ersatz.Problem",
          "name": "runQSAT'",
          "package": "ersatz",
          "signature": "StateT QSAT Identity a -\u003e (a, QSAT)",
          "source": "src/Ersatz-Problem.html#runQSAT%27",
          "type": "function"
        },
        "index": {
          "description": "Run QSAT generating state computation in the Identity monad Useful e.g in ghci for disambiguating the type of MonadState HasQSAT value",
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "runQSAT'",
          "normalized": "StateT QSAT Identity a-\u003e(a,QSAT)",
          "package": "ersatz",
          "partial": "QSAT'",
          "signature": "StateT QSAT Identity a-\u003e(a,QSAT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:runQSAT-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eSAT\u003c/a\u003e\u003c/code\u003e-generating state computation. Useful e.g. in ghci for\n disambiguating the type of a \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eHasSAT\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e",
          "module": "Ersatz.Problem",
          "name": "runSAT",
          "package": "ersatz",
          "signature": "StateT SAT m a -\u003e m (a, SAT)",
          "source": "src/Ersatz-Problem.html#runSAT",
          "type": "function"
        },
        "index": {
          "description": "Run SAT generating state computation Useful e.g in ghci for disambiguating the type of MonadState HasSAT value",
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "runSAT",
          "normalized": "StateT SAT a b-\u003ea(b,SAT)",
          "package": "ersatz",
          "partial": "SAT",
          "signature": "StateT SAT m a-\u003em(a,SAT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:runSAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eSAT\u003c/a\u003e\u003c/code\u003e-generating state computation in the \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e monad. Useful\n e.g. in ghci for disambiguating the type of a \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eHasSAT\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e",
          "module": "Ersatz.Problem",
          "name": "runSAT'",
          "package": "ersatz",
          "signature": "StateT SAT Identity a -\u003e (a, SAT)",
          "source": "src/Ersatz-Problem.html#runSAT%27",
          "type": "function"
        },
        "index": {
          "description": "Run SAT generating state computation in the Identity monad Useful e.g in ghci for disambiguating the type of MonadState HasSAT value",
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "runSAT'",
          "normalized": "StateT SAT Identity a-\u003e(a,SAT)",
          "package": "ersatz",
          "partial": "SAT'",
          "signature": "StateT SAT Identity a-\u003e(a,SAT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:runSAT-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "sat",
          "package": "ersatz",
          "signature": "Lens' t SAT",
          "source": "src/Ersatz-Problem.html#sat",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "sat",
          "package": "ersatz",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:sat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "stableMap",
          "package": "ersatz",
          "signature": "Lens' t (HashMap (StableName ()) Literal)",
          "source": "src/Ersatz-Problem.html#stableMap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "stableMap",
          "normalized": "Lens' a(HashMap(StableName())Literal)",
          "package": "ersatz",
          "partial": "Map",
          "signature": "Lens' t(HashMap(StableName())Literal)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:stableMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "universals",
          "package": "ersatz",
          "signature": "Lens' t IntSet",
          "source": "src/Ersatz-Problem.html#universals",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "universals",
          "package": "ersatz",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:universals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a \u003ccode\u003e\u003ca\u003eBuilder\u003c/a\u003e\u003c/code\u003e out of a \u003ccode\u003e\u003ca\u003eWDIMACS\u003c/a\u003e\u003c/code\u003e problem.\n\u003c/p\u003e",
          "module": "Ersatz.Problem",
          "name": "wdimacs",
          "package": "ersatz",
          "signature": "t -\u003e Builder",
          "source": "src/Ersatz-Problem.html#wdimacs",
          "type": "function"
        },
        "index": {
          "description": "Generate Builder out of WDIMACS problem",
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "wdimacs",
          "normalized": "a-\u003eBuilder",
          "package": "ersatz",
          "signature": "t-\u003eBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:wdimacs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "wdimacsClauses",
          "package": "ersatz",
          "signature": "t -\u003e Set (Int64, IntSet)",
          "source": "src/Ersatz-Problem.html#wdimacsClauses",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "wdimacsClauses",
          "normalized": "a-\u003eSet(Int,IntSet)",
          "package": "ersatz",
          "partial": "Clauses",
          "signature": "t-\u003eSet(Int,IntSet)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:wdimacsClauses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "wdimacsComments",
          "package": "ersatz",
          "signature": "t -\u003e [ByteString]",
          "source": "src/Ersatz-Problem.html#wdimacsComments",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "wdimacsComments",
          "normalized": "a-\u003e[ByteString]",
          "package": "ersatz",
          "partial": "Comments",
          "signature": "t-\u003e[ByteString]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:wdimacsComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "wdimacsNumVariables",
          "package": "ersatz",
          "signature": "t -\u003e Int",
          "source": "src/Ersatz-Problem.html#wdimacsNumVariables",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "wdimacsNumVariables",
          "normalized": "a-\u003eInt",
          "package": "ersatz",
          "partial": "Num Variables",
          "signature": "t-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:wdimacsNumVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Problem",
          "name": "wdimacsTopWeight",
          "package": "ersatz",
          "signature": "wdimacsTopWeight",
          "source": "src/Ersatz-Problem.html#wdimacsTopWeight",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Problem",
          "module": "Ersatz.Problem",
          "name": "wdimacsTopWeight",
          "package": "ersatz",
          "partial": "Top Weight",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:wdimacsTopWeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solution",
          "name": "Solution",
          "package": "ersatz",
          "source": "src/Ersatz-Solution.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ersatz Solution",
          "module": "Ersatz.Solution",
          "name": "Solution",
          "package": "ersatz",
          "partial": "Solution",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solution",
          "name": "Result",
          "package": "ersatz",
          "source": "src/Ersatz-Solution.html#Result",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ersatz Solution",
          "module": "Ersatz.Solution",
          "name": "Result",
          "package": "ersatz",
          "partial": "Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#t:Result"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solution",
          "name": "Solution",
          "package": "ersatz",
          "source": "src/Ersatz-Solution.html#Solution",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ersatz Solution",
          "module": "Ersatz.Solution",
          "name": "Solution",
          "package": "ersatz",
          "partial": "Solution",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#t:Solution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solution",
          "name": "Solver",
          "package": "ersatz",
          "source": "src/Ersatz-Solution.html#Solver",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ersatz Solution",
          "module": "Ersatz.Solution",
          "name": "Solver",
          "package": "ersatz",
          "partial": "Solver",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#t:Solver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solution",
          "name": "Satisfied",
          "package": "ersatz",
          "signature": "Satisfied",
          "source": "src/Ersatz-Solution.html#Result",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Solution",
          "module": "Ersatz.Solution",
          "name": "Satisfied",
          "package": "ersatz",
          "partial": "Satisfied",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#v:Satisfied"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solution",
          "name": "Solution",
          "package": "ersatz",
          "signature": "Solution",
          "source": "src/Ersatz-Solution.html#Solution",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Solution",
          "module": "Ersatz.Solution",
          "name": "Solution",
          "package": "ersatz",
          "partial": "Solution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#v:Solution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solution",
          "name": "Unsatisfied",
          "package": "ersatz",
          "signature": "Unsatisfied",
          "source": "src/Ersatz-Solution.html#Result",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Solution",
          "module": "Ersatz.Solution",
          "name": "Unsatisfied",
          "package": "ersatz",
          "partial": "Unsatisfied",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#v:Unsatisfied"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solution",
          "name": "Unsolved",
          "package": "ersatz",
          "signature": "Unsolved",
          "source": "src/Ersatz-Solution.html#Result",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Solution",
          "module": "Ersatz.Solution",
          "name": "Unsolved",
          "package": "ersatz",
          "partial": "Unsolved",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#v:Unsolved"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solution",
          "name": "solutionFrom",
          "package": "ersatz",
          "signature": "IntMap Bool -\u003e s -\u003e Solution",
          "source": "src/Ersatz-Solution.html#solutionFrom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Solution",
          "module": "Ersatz.Solution",
          "name": "solutionFrom",
          "normalized": "IntMap Bool-\u003ea-\u003eSolution",
          "package": "ersatz",
          "partial": "From",
          "signature": "IntMap Bool-\u003es-\u003eSolution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#v:solutionFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solution",
          "name": "solutionLiteral",
          "package": "ersatz",
          "signature": "Literal -\u003e Maybe Bool",
          "source": "src/Ersatz-Solution.html#Solution",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Solution",
          "module": "Ersatz.Solution",
          "name": "solutionLiteral",
          "normalized": "Literal-\u003eMaybe Bool",
          "package": "ersatz",
          "partial": "Literal",
          "signature": "Literal-\u003eMaybe Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#v:solutionLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solution",
          "name": "solutionStableName",
          "package": "ersatz",
          "signature": "StableName () -\u003e Maybe Bool",
          "source": "src/Ersatz-Solution.html#Solution",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Solution",
          "module": "Ersatz.Solution",
          "name": "solutionStableName",
          "normalized": "StableName()-\u003eMaybe Bool",
          "package": "ersatz",
          "partial": "Stable Name",
          "signature": "StableName()-\u003eMaybe Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#v:solutionStableName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solver.DepQBF",
          "name": "DepQBF",
          "package": "ersatz",
          "source": "src/Ersatz-Solver-DepQBF.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ersatz Solver DepQBF",
          "module": "Ersatz.Solver.DepQBF",
          "name": "DepQBF",
          "package": "ersatz",
          "partial": "Dep QBF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver-DepQBF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solver.DepQBF",
          "name": "depqbf",
          "package": "ersatz",
          "signature": "Solver QSAT m",
          "source": "src/Ersatz-Solver-DepQBF.html#depqbf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Solver DepQBF",
          "module": "Ersatz.Solver.DepQBF",
          "name": "depqbf",
          "package": "ersatz",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver-DepQBF.html#v:depqbf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solver.DepQBF",
          "name": "depqbfPath",
          "package": "ersatz",
          "signature": "FilePath -\u003e Solver QSAT m",
          "source": "src/Ersatz-Solver-DepQBF.html#depqbfPath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Solver DepQBF",
          "module": "Ersatz.Solver.DepQBF",
          "name": "depqbfPath",
          "normalized": "FilePath-\u003eSolver QSAT a",
          "package": "ersatz",
          "partial": "Path",
          "signature": "FilePath-\u003eSolver QSAT m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver-DepQBF.html#v:depqbfPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solver.Minisat",
          "name": "Minisat",
          "package": "ersatz",
          "source": "src/Ersatz-Solver-Minisat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ersatz Solver Minisat",
          "module": "Ersatz.Solver.Minisat",
          "name": "Minisat",
          "package": "ersatz",
          "partial": "Minisat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver-Minisat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solver.Minisat",
          "name": "cryptominisat",
          "package": "ersatz",
          "signature": "Solver SAT m",
          "source": "src/Ersatz-Solver-Minisat.html#cryptominisat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Solver Minisat",
          "module": "Ersatz.Solver.Minisat",
          "name": "cryptominisat",
          "package": "ersatz",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver-Minisat.html#v:cryptominisat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solver.Minisat",
          "name": "minisat",
          "package": "ersatz",
          "signature": "Solver SAT m",
          "source": "src/Ersatz-Solver-Minisat.html#minisat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Solver Minisat",
          "module": "Ersatz.Solver.Minisat",
          "name": "minisat",
          "package": "ersatz",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver-Minisat.html#v:minisat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solver.Minisat",
          "name": "minisatPath",
          "package": "ersatz",
          "signature": "FilePath -\u003e Solver SAT m",
          "source": "src/Ersatz-Solver-Minisat.html#minisatPath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Solver Minisat",
          "module": "Ersatz.Solver.Minisat",
          "name": "minisatPath",
          "normalized": "FilePath-\u003eSolver SAT a",
          "package": "ersatz",
          "partial": "Path",
          "signature": "FilePath-\u003eSolver SAT m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver-Minisat.html#v:minisatPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solver",
          "name": "Solver",
          "package": "ersatz",
          "source": "src/Ersatz-Solver.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ersatz Solver",
          "module": "Ersatz.Solver",
          "name": "Solver",
          "package": "ersatz",
          "partial": "Solver",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Solver",
          "name": "solveWith",
          "package": "ersatz",
          "signature": "Solver s m -\u003e StateT s m a -\u003e m (Result, Maybe (Decoded a))",
          "source": "src/Ersatz-Solver.html#solveWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ersatz Solver",
          "module": "Ersatz.Solver",
          "name": "solveWith",
          "normalized": "Solver a b-\u003eStateT a b c-\u003eb(Result,Maybe(Decoded c))",
          "package": "ersatz",
          "partial": "With",
          "signature": "Solver s m-\u003eStateT s m a-\u003em(Result,Maybe(Decoded a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver.html#v:solveWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Variable",
          "name": "Variable",
          "package": "ersatz",
          "source": "src/Ersatz-Variable.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ersatz Variable",
          "module": "Ersatz.Variable",
          "name": "Variable",
          "package": "ersatz",
          "partial": "Variable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Variable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInstances for this class for product-like types can be automatically derived\n for any type that is an instance of \u003ccode\u003e\u003ca\u003eGeneric\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Ersatz.Variable",
          "name": "Variable",
          "package": "ersatz",
          "source": "src/Ersatz-Variable.html#Variable",
          "type": "class"
        },
        "index": {
          "description": "Instances for this class for product-like types can be automatically derived for any type that is an instance of Generic",
          "hierarchy": "Ersatz Variable",
          "module": "Ersatz.Variable",
          "name": "Variable",
          "package": "ersatz",
          "partial": "Variable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Variable.html#t:Variable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Variable",
          "name": "exists",
          "package": "ersatz",
          "signature": "m t",
          "source": "src/Ersatz-Variable.html#exists",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Variable",
          "module": "Ersatz.Variable",
          "name": "exists",
          "package": "ersatz",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Variable.html#v:exists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz.Variable",
          "name": "forall",
          "package": "ersatz",
          "signature": "m t",
          "source": "src/Ersatz-Variable.html#forall",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ersatz Variable",
          "module": "Ersatz.Variable",
          "name": "forall",
          "package": "ersatz",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Variable.html#v:forall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ersatz",
          "name": "Ersatz",
          "package": "ersatz",
          "source": "src/Ersatz.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ersatz",
          "module": "Ersatz",
          "name": "Ersatz",
          "package": "ersatz",
          "partial": "Ersatz",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz.html#"
      }
    }
  ]
]