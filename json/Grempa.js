[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "Grempa"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCreate parsers from grammars dynamically (at runtime).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "Dynamic",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Dynamic.html",
          "type": "module"
        },
        "index": {
          "description": "Create parsers from grammars dynamically at runtime",
          "hierarchy": "Data Parser Grempa Dynamic",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "Dynamic",
          "package": "Grempa",
          "partial": "Dynamic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe different kinds of errors that can occur\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "ParseError",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Parser-Result.html#ParseError",
          "type": "data"
        },
        "index": {
          "description": "The different kinds of errors that can occur",
          "hierarchy": "Data Parser Grempa Dynamic",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "ParseError",
          "package": "Grempa",
          "partial": "Parse Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#t:ParseError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe result of running a parser\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "ParseResult",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Parser-Result.html#ParseResult",
          "type": "type"
        },
        "index": {
          "description": "The result of running parser",
          "hierarchy": "Data Parser Grempa Dynamic",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "ParseResult",
          "package": "Grempa",
          "partial": "Parse Result",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#t:ParseResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of a parser generated by Grempa\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "Parser",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Parser-Result.html#Parser",
          "type": "type"
        },
        "index": {
          "description": "The type of parser generated by Grempa",
          "hierarchy": "Data Parser Grempa Dynamic",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "Parser",
          "package": "Grempa",
          "partial": "Parser",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#t:Parser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis should not happen. Please file a bug report if it does.\n\u003c/p\u003e",
          "module": "[\"Data.Parser.Grempa.Dynamic\",\"Data.Parser.Grempa.Static\"]",
          "name": "InternalParserError",
          "package": "Grempa",
          "signature": "InternalParserError",
          "source": "src/Data-Parser-Grempa-Parser-Result.html#ParseError",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:InternalParserError\",\"http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Static.html#v:InternalParserError\"]"
        },
        "index": {
          "description": "This should not happen Please file bug report if it does",
          "hierarchy": "Data Parser Grempa Dynamic",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "InternalParserError",
          "package": "Grempa",
          "partial": "Internal Parser Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:InternalParserError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe parser did not get an accepted string of tokens.\n\u003c/p\u003e",
          "module": "[\"Data.Parser.Grempa.Dynamic\",\"Data.Parser.Grempa.Static\"]",
          "name": "ParseError",
          "package": "Grempa",
          "signature": "ParseError",
          "source": "src/Data-Parser-Grempa-Parser-Result.html#ParseError",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:ParseError\",\"http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Static.html#v:ParseError\"]"
        },
        "index": {
          "description": "The parser did not get an accepted string of tokens",
          "hierarchy": "Data Parser Grempa Dynamic",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "ParseError",
          "package": "Grempa",
          "partial": "Parse Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:ParseError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap the input tokens in the \u003ccode\u003eCTok\u003c/code\u003e datatype, which has \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e\n   instances which only look at the constructors of the input values.\n   This is for use as an argument to \u003ccode\u003e\u003ca\u003emkDynamicParser\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eExample, which will evaluate to \u003ccode\u003eTrue\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e CTok (Just 1) == CTok (Just 2)\n\u003c/pre\u003e\u003cp\u003eThis is useful when using a lexer that may give back a list of something\n   like:\n\u003c/p\u003e\u003cpre\u003e data Token = Ident String | Number Integer | LParen | RParen | Plus | ...\n\u003c/pre\u003e\u003cp\u003eIf you want to specify a grammar that accepts any \u003ccode\u003eIdent\u003c/code\u003e and any \u003ccode\u003eNumber\u003c/code\u003e\n   and not just specific ones, use \u003ccode\u003e\u003ca\u003econstrWrapper\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "constrWrapper",
          "package": "Grempa",
          "signature": "(t -\u003e CTok t, CTok t -\u003e t)",
          "source": "src/Data-Parser-Grempa-Parser-Dynamic.html#constrWrapper",
          "type": "function"
        },
        "index": {
          "description": "Wrap the input tokens in the CTok datatype which has Eq and Ord instances which only look at the constructors of the input values This is for use as an argument to mkDynamicParser Example which will evaluate to True CTok Just CTok Just This is useful when using lexer that may give back list of something like data Token Ident String Number Integer LParen RParen Plus If you want to specify grammar that accepts any Ident and any Number and not just specific ones use constrWrapper",
          "hierarchy": "Data Parser Grempa Dynamic",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "constrWrapper",
          "normalized": "(a-\u003eCTok a,CTok a-\u003ea)",
          "package": "Grempa",
          "partial": "Wrapper",
          "signature": "(t-\u003eCTok t,CTok t-\u003et)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:constrWrapper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list of tokens that would have been\n acceptable inputs when the error occured.\n\u003c/p\u003e",
          "module": "[\"Data.Parser.Grempa.Dynamic\",\"Data.Parser.Grempa.Static\"]",
          "name": "expectedTokens",
          "package": "Grempa",
          "signature": "[Tok t]",
          "source": "src/Data-Parser-Grempa-Parser-Result.html#ParseError",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:expectedTokens\",\"http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Static.html#v:expectedTokens\"]"
        },
        "index": {
          "description": "list of tokens that would have been acceptable inputs when the error occured",
          "hierarchy": "Data Parser Grempa Dynamic",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "expectedTokens",
          "normalized": "[Tok a]",
          "package": "Grempa",
          "partial": "Tokens",
          "signature": "[Tok t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:expectedTokens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDon't wrap the input tokens.\n   This is for use as an argument to \u003ccode\u003e\u003ca\u003emkDynamicParser\u003c/a\u003e\u003c/code\u003e.\n   An example usage of \u003ccode\u003e\u003ca\u003eidWrapper\u003c/a\u003e\u003c/code\u003e is if the parser operates directly on\n   \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "idWrapper",
          "package": "Grempa",
          "signature": "(t -\u003e t, t -\u003e t)",
          "source": "src/Data-Parser-Grempa-Parser-Dynamic.html#idWrapper",
          "type": "function"
        },
        "index": {
          "description": "Don wrap the input tokens This is for use as an argument to mkDynamicParser An example usage of idWrapper is if the parser operates directly on String",
          "hierarchy": "Data Parser Grempa Dynamic",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "idWrapper",
          "normalized": "(a-\u003ea,a-\u003ea)",
          "package": "Grempa",
          "partial": "Wrapper",
          "signature": "(t-\u003et,t-\u003et)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:idWrapper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a parser at runtime given a grammar\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "mkDynamicParser",
          "package": "Grempa",
          "signature": "(t -\u003e t', t' -\u003e t)-\u003e Grammar t a-\u003e Parser t a",
          "type": "function"
        },
        "index": {
          "description": "Make parser at runtime given grammar",
          "hierarchy": "Data Parser Grempa Dynamic",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "mkDynamicParser",
          "normalized": "(a-\u003eb,b-\u003ea)-\u003eGrammar a c-\u003eParser a c",
          "package": "Grempa",
          "partial": "Dynamic Parser",
          "signature": "(t-\u003et',t'-\u003et)-\u003eGrammar t a-\u003eParser t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:mkDynamicParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow away the \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e from the \u003ccode\u003e\u003ca\u003eParseResult\u003c/a\u003e\u003c/code\u003e and throw an exception using\n   \u003ccode\u003e\u003ca\u003eshowError\u003c/a\u003e\u003c/code\u003e if something went wrong.\n\u003c/p\u003e",
          "module": "[\"Data.Parser.Grempa.Dynamic\",\"Data.Parser.Grempa.Static\"]",
          "name": "parse",
          "package": "Grempa",
          "signature": "Parser t a -\u003e [t] -\u003e a",
          "source": "src/Data-Parser-Grempa-Parser-Result.html#parse",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:parse\",\"http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Static.html#v:parse\"]"
        },
        "index": {
          "description": "Throw away the Either from the ParseResult and throw an exception using showError if something went wrong",
          "hierarchy": "Data Parser Grempa Dynamic",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "parse",
          "normalized": "Parser a b-\u003e[a]-\u003eb",
          "package": "Grempa",
          "signature": "Parser t a-\u003e[t]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe position at which something went\n horribly wrong.\n\u003c/p\u003e\u003cp\u003eThe position (index into the input\n token list) at which the error occured.\n\u003c/p\u003e",
          "module": "[\"Data.Parser.Grempa.Dynamic\",\"Data.Parser.Grempa.Static\"]",
          "name": "position",
          "package": "Grempa",
          "signature": "Integer",
          "source": "src/Data-Parser-Grempa-Parser-Result.html#ParseError",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:position\",\"http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Static.html#v:position\"]"
        },
        "index": {
          "description": "The position at which something went horribly wrong The position index into the input token list at which the error occured",
          "hierarchy": "Data Parser Grempa Dynamic",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "position",
          "package": "Grempa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:position"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a prettier error string from a \u003ccode\u003e\u003ca\u003eParseError\u003c/a\u003e\u003c/code\u003e.\n   This shows the position as an index into the input string of tokens, which\n   may not always be preferable, as that position may differ to the position\n   in the input if it is first processed by a lexer.\n   It also shows the expected tokens.\n\u003c/p\u003e",
          "module": "[\"Data.Parser.Grempa.Dynamic\",\"Data.Parser.Grempa.Static\"]",
          "name": "showError",
          "package": "Grempa",
          "signature": "ParseError t -\u003e String",
          "source": "src/Data-Parser-Grempa-Parser-Result.html#showError",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:showError\",\"http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Static.html#v:showError\"]"
        },
        "index": {
          "description": "Make prettier error string from ParseError This shows the position as an index into the input string of tokens which may not always be preferable as that position may differ to the position in the input if it is first processed by lexer It also shows the expected tokens",
          "hierarchy": "Data Parser Grempa Dynamic",
          "module": "Data.Parser.Grempa.Dynamic",
          "name": "showError",
          "normalized": "ParseError a-\u003eString",
          "package": "Grempa",
          "partial": "Error",
          "signature": "ParseError t-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Dynamic.html#v:showError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGrammar construction combinators.\n\u003c/p\u003e\u003cp\u003eA grammar in grempa consists of a number of rules and an entry rule.\n    Constructing a grammar is similar to doing it in BNF, but the grammars\n    also have the information of what semantic action to take when a production\n    has been found, which is used by the parsers that can be generated from the\n    grammars.\n\u003c/p\u003e\u003cp\u003eRules, constructed with the \u003ccode\u003e\u003ca\u003erule\u003c/a\u003e\u003c/code\u003e function, consist of lists of productions.\n\u003c/p\u003e\u003cp\u003eA production in Grempa starts with a function which acts as the semantic\n    action to be taken when that production has been parsed. After the \u003ccode\u003e\u003ca\u003e\u003c@\u003e\u003c/a\u003e\u003c/code\u003e\n    operator follows what the production accepts, which consists of a number of\n    grammar symbols (terminals (tokens) or non-terminals (grammar rules)).\n\u003c/p\u003e\u003cp\u003eThe two combinator functions that construct productions come in two flavours\n    each: One that signals that the result from parsing the symbol to the right\n    of it should be used in the semantic action function and one that signals\n    that it should not:\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eaction \u003ccode\u003e\u003ca\u003e\u003c@\u003e\u003c/a\u003e\u003c/code\u003e symbol =\u003c/code\u003e An action function followed by a symbol\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eaction \u003ccode\u003e\u003ca\u003e\u003c@\u003c/a\u003e\u003c/code\u003e  symbol =\u003c/code\u003e An action function followed by a symbol which will\n                            not be used when taking the semantic action of the\n                            production.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eprod   \u003ccode\u003e\u003ca\u003e\u003c#\u003e\u003c/a\u003e\u003c/code\u003e symbol = \u003c/code\u003eA production followed by a symbol\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eprod   \u003ccode\u003e\u003ca\u003e\u003c#\u003c/a\u003e\u003c/code\u003e  symbol = \u003c/code\u003eA production followed by a symbol which will not be\n                            used when taking the semantic action of the\n                            production.\n    The grammars have the type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eGrammar\u003c/a\u003e\u003c/code\u003e t a\u003c/code\u003e, which tells us that the grammar\n    describes a language operating on \u003ccode\u003e[t]\u003c/code\u003e returning \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eGrammars can be recursively defined by using recursive do-notation.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "Grammar",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Grammar.html",
          "type": "module"
        },
        "index": {
          "description": "Grammar construction combinators grammar in grempa consists of number of rules and an entry rule Constructing grammar is similar to doing it in BNF but the grammars also have the information of what semantic action to take when production has been found which is used by the parsers that can be generated from the grammars Rules constructed with the rule function consist of lists of productions production in Grempa starts with function which acts as the semantic action to be taken when that production has been parsed After the operator follows what the production accepts which consists of number of grammar symbols terminals tokens or non-terminals grammar rules The two combinator functions that construct productions come in two flavours each One that signals that the result from parsing the symbol to the right of it should be used in the semantic action function and one that signals that it should not action symbol An action function followed by symbol action symbol An action function followed by symbol which will not be used when taking the semantic action of the production prod symbol production followed by symbol prod symbol production followed by symbol which will not be used when taking the semantic action of the production The grammars have the type Grammar which tells us that the grammar describes language operating on returning Grammars can be recursively defined by using recursive do-notation",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "Grammar",
          "package": "Grempa",
          "partial": "Grammar",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Parser.Grempa.Grammar",
          "name": "Grammar",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#Grammar",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "Grammar",
          "package": "Grempa",
          "partial": "Grammar",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#t:Grammar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Parser.Grempa.Grammar",
          "name": "GrammarState",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#GrammarState",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "GrammarState",
          "package": "Grempa",
          "partial": "Grammar State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#t:GrammarState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA grammar production\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "Prod",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#Prod",
          "type": "data"
        },
        "index": {
          "description": "grammar production",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "Prod",
          "package": "Grempa",
          "partial": "Prod",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#t:Prod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRule ID\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "RId",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#RId",
          "type": "data"
        },
        "index": {
          "description": "Rule ID",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "RId",
          "package": "Grempa",
          "partial": "RId",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#t:RId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Parser.Grempa.Grammar",
          "name": "Rule",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#Rule",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "Rule",
          "package": "Grempa",
          "partial": "Rule",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#t:Rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA grammar symbol\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "Symbol",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#Symbol",
          "type": "data"
        },
        "index": {
          "description": "grammar symbol",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "Symbol",
          "package": "Grempa",
          "partial": "Symbol",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#t:Symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass for writing grammars in a nicer syntax.\n   This class allows one to use both rules and tokens with the grammar\n   combinator functions. For the grammars to typecheck, it is often necessary\n   to give their type.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "ToSym",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#ToSym",
          "type": "class"
        },
        "index": {
          "description": "Class for writing grammars in nicer syntax This class allows one to use both rules and tokens with the grammar combinator functions For the grammars to typecheck it is often necessary to give their type",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "ToSym",
          "package": "Grempa",
          "partial": "To Sym",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#t:ToSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequence a production and a grammar symbol, where the symbol directly to\n   the right of the operator is not used in the semantic action.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "(\u003c#)",
          "package": "Grempa",
          "signature": "Prod t a -\u003e x -\u003e Prod t a",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#%3C%23",
          "type": "function"
        },
        "index": {
          "description": "Sequence production and grammar symbol where the symbol directly to the right of the operator is not used in the semantic action",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "(\u003c#) \u003c#",
          "normalized": "Prod a b-\u003ec-\u003eProd a b",
          "package": "Grempa",
          "signature": "Prod t a-\u003ex-\u003eProd t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:-60--35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequence a production and a grammar symbol, where the symbol directly to\n   the right of the operator is used in the semantic action.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "(\u003c#\u003e)",
          "package": "Grempa",
          "signature": "Prod t (b -\u003e a) -\u003e x -\u003e Prod t a",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#%3C%23%3E",
          "type": "function"
        },
        "index": {
          "description": "Sequence production and grammar symbol where the symbol directly to the right of the operator is used in the semantic action",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "(\u003c#\u003e) \u003c#\u003e",
          "normalized": "Prod a(b-\u003ec)-\u003ed-\u003eProd a c",
          "package": "Grempa",
          "signature": "Prod t(b-\u003ea)-\u003ex-\u003eProd t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:-60--35--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStart a production, where the symbol directly to the right of the operator\n   is not used in the semantic action.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "(\u003c@)",
          "package": "Grempa",
          "signature": "a-\u003e x-\u003e Prod t a",
          "type": "function"
        },
        "index": {
          "description": "Start production where the symbol directly to the right of the operator is not used in the semantic action",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "(\u003c@) \u003c@",
          "normalized": "a-\u003eb-\u003eProd c a",
          "package": "Grempa",
          "signature": "a-\u003ex-\u003eProd t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:-60--64-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStart a production, where the symbol directly to the right of the operator\n   is used in the semantic action.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "(\u003c@\u003e)",
          "package": "Grempa",
          "signature": "(b -\u003e a)-\u003e x-\u003e Prod t a",
          "type": "function"
        },
        "index": {
          "description": "Start production where the symbol directly to the right of the operator is used in the semantic action",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "(\u003c@\u003e) \u003c@\u003e",
          "normalized": "(a-\u003eb)-\u003ec-\u003eProd d b",
          "package": "Grempa",
          "signature": "(b-\u003ea)-\u003ex-\u003eProd t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:-60--64--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Parser.Grempa.Grammar",
          "name": "PFun",
          "package": "Grempa",
          "signature": "a -\u003e Prod t a",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#Prod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "PFun",
          "normalized": "a-\u003eProd b a",
          "package": "Grempa",
          "partial": "PFun",
          "signature": "a-\u003eProd t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:PFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Parser.Grempa.Grammar",
          "name": "PSeq",
          "package": "Grempa",
          "signature": "Prod t (b -\u003e a) -\u003e Symbol t b -\u003e Prod t a",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#Prod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "PSeq",
          "normalized": "Prod a(b-\u003ec)-\u003eSymbol a b-\u003eProd a c",
          "package": "Grempa",
          "partial": "PSeq",
          "signature": "Prod t(b-\u003ea)-\u003eSymbol t b-\u003eProd t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:PSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Parser.Grempa.Grammar",
          "name": "PSeqN",
          "package": "Grempa",
          "signature": "Prod t a -\u003e Symbol t b -\u003e Prod t a",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#Prod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "PSeqN",
          "normalized": "Prod a b-\u003eSymbol a c-\u003eProd a b",
          "package": "Grempa",
          "partial": "PSeq",
          "signature": "Prod t a-\u003eSymbol t b-\u003eProd t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:PSeqN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Parser.Grempa.Grammar",
          "name": "RId",
          "package": "Grempa",
          "signature": "RuleI -\u003e Rule t a -\u003e RId t a",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#RId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "RId",
          "normalized": "RuleI-\u003eRule a b-\u003eRId a b",
          "package": "Grempa",
          "partial": "RId",
          "signature": "RuleI-\u003eRule t a-\u003eRId t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:RId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Parser.Grempa.Grammar",
          "name": "SRule",
          "package": "Grempa",
          "signature": "RId t a -\u003e Symbol t a",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#Symbol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "SRule",
          "normalized": "RId a b-\u003eSymbol a b",
          "package": "Grempa",
          "partial": "SRule",
          "signature": "RId t a-\u003eSymbol t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:SRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Parser.Grempa.Grammar",
          "name": "STerm",
          "package": "Grempa",
          "signature": "t -\u003e Symbol t t",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#Symbol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "STerm",
          "normalized": "a-\u003eSymbol a a",
          "package": "Grempa",
          "partial": "STerm",
          "signature": "t-\u003eSymbol t t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:STerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an augmented grammar (with a new start symbol)\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "augment",
          "package": "Grempa",
          "signature": "Grammar t a -\u003e Grammar t a",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#augment",
          "type": "function"
        },
        "index": {
          "description": "Create an augmented grammar with new start symbol",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "augment",
          "normalized": "Grammar a b-\u003eGrammar a b",
          "package": "Grempa",
          "signature": "Grammar t a-\u003eGrammar t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:augment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes two symbols and combines them with \u003ccode\u003e(:)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eCreates one new rule.\n\u003c/p\u003e\u003cp\u003eThis can for example be used instead of using both \u003ccode\u003e\u003ca\u003eseveral\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eseveral0\u003c/a\u003e\u003c/code\u003e\n   on the same symbol, as that will create three new rules, whereas the\n   equivalent using \u003ccode\u003e\u003ca\u003econs\u003c/a\u003e\u003c/code\u003e will only create two new rules. Example\n   transformation:\n\u003c/p\u003e\u003cpre\u003e xs0 \u003c- several0 x\n xs  \u003c- several  x\n   ==\u003e\n xs0 \u003c- several0 x\n xs  \u003c- x `cons` xs0\n\u003c/pre\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "cons",
          "package": "Grempa",
          "signature": "x-\u003e xs-\u003e Grammar s [a]",
          "type": "function"
        },
        "index": {
          "description": "Takes two symbols and combines them with Creates one new rule This can for example be used instead of using both several and several0 on the same symbol as that will create three new rules whereas the equivalent using cons will only create two new rules Example transformation xs0 several0 xs several xs0 several0 xs cons xs0",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "cons",
          "normalized": "a-\u003eb-\u003eGrammar c[d]",
          "package": "Grempa",
          "signature": "x-\u003exs-\u003eGrammar s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty production, taking the semantic action (in this case just the\n   value to return) as the argument.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "epsilon",
          "package": "Grempa",
          "signature": "a -\u003e Prod t a",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#epsilon",
          "type": "function"
        },
        "index": {
          "description": "The empty production taking the semantic action in this case just the value to return as the argument",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "epsilon",
          "normalized": "a-\u003eProd b a",
          "package": "Grempa",
          "signature": "a-\u003eProd t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:epsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the result from a Grammar computation\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "evalGrammar",
          "package": "Grempa",
          "signature": "GrammarState t a -\u003e a",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#evalGrammar",
          "type": "function"
        },
        "index": {
          "description": "Get the result from Grammar computation",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "evalGrammar",
          "normalized": "GrammarState a b-\u003eb",
          "package": "Grempa",
          "partial": "Grammar",
          "signature": "GrammarState t a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:evalGrammar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the semantic action from a production\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "getFun",
          "package": "Grempa",
          "signature": "Prod t a -\u003e DynFun",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#getFun",
          "type": "function"
        },
        "index": {
          "description": "Get the semantic action from production",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "getFun",
          "normalized": "Prod a b-\u003eDynFun",
          "package": "Grempa",
          "partial": "Fun",
          "signature": "Prod t a-\u003eDynFun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:getFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStart a levels block. Usage:\n\u003c/p\u003e\u003cpre\u003e expr \u003c- levels $ do\n   rec\n     e \u003c- lrule [ Plus  \u003c@\u003e e \u003c# '+' \u003c#\u003e t ]\n     t \u003c- lrule [ Times \u003c@\u003e t \u003c# '*' \u003c#\u003e f ]\n     f \u003c- lrule [ Var   \u003c@ 'x'\n                , id    \u003c@ '(' \u003c#\u003e e \u003c# ')']\n   return e\n\u003c/pre\u003e\u003cp\u003eis equivalent to\n\u003c/p\u003e\u003cpre\u003e e \u003c- rule [ Plus  \u003c@\u003e e \u003c# '+' \u003c#\u003e t \n           , id    \u003c@\u003e t\n           ]\n t \u003c- rule [ Times \u003c@\u003e t \u003c# '*' \u003c#\u003e f \n           , id    \u003c@\u003e f\n           ]\n f \u003c- rule [ Var   \u003c@ 'x'\n           , id    \u003c@ '(' \u003c#\u003e e \u003c# ')'\n           ]\n\u003c/pre\u003e\u003cp\u003ePut simply, every lrule save for the last one gets an additional identity\n production pointing to the next lrule. This is a common pattern when\n creating grammars with precedence levels.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "levels",
          "package": "Grempa",
          "signature": "RStateT (Maybe a) m r -\u003e m r",
          "source": "src/Data-Parser-Grempa-Grammar-Levels.html#levels",
          "type": "function"
        },
        "index": {
          "description": "Start levels block Usage expr levels do rec lrule Plus lrule Times lrule Var id return is equivalent to rule Plus id rule Times id rule Var id Put simply every lrule save for the last one gets an additional identity production pointing to the next lrule This is common pattern when creating grammars with precedence levels",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "levels",
          "normalized": "RStateT(Maybe a)b c-\u003eb c",
          "package": "Grempa",
          "signature": "RStateT(Maybe a)m r-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:levels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA rule in a levels block\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "lrule",
          "package": "Grempa",
          "signature": "Rule t a -\u003e RStateT (Maybe (RId t a)) (GrammarState t) (RId t a)",
          "source": "src/Data-Parser-Grempa-Grammar-Levels.html#lrule",
          "type": "function"
        },
        "index": {
          "description": "rule in levels block",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "lrule",
          "normalized": "Rule a b-\u003eRStateT(Maybe(RId a b))(GrammarState a)(RId a b)",
          "package": "Grempa",
          "signature": "Rule t a-\u003eRStateT(Maybe(RId t a))(GrammarState t)(RId t a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:lrule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Parser.Grempa.Grammar",
          "name": "rId",
          "package": "Grempa",
          "signature": "RuleI",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#RId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "rId",
          "package": "Grempa",
          "partial": "Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:rId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Parser.Grempa.Grammar",
          "name": "rIdRule",
          "package": "Grempa",
          "signature": "Rule t a",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#RId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "rIdRule",
          "package": "Grempa",
          "partial": "Id Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:rIdRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new rule in a grammar\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "rule",
          "package": "Grempa",
          "signature": "Rule t a -\u003e Grammar t a",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#rule",
          "type": "function"
        },
        "index": {
          "description": "Create new rule in grammar",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "rule",
          "normalized": "Rule a b-\u003eGrammar a b",
          "package": "Grempa",
          "signature": "Rule t a-\u003eGrammar t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a new rule which consists of 1 or more of the argument symbol.\n   Example: \u003ccode\u003eseveral x\u003c/code\u003e matches \u003ccode\u003ex x ... x\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eCreates one new rule.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "several",
          "package": "Grempa",
          "signature": "x -\u003e Grammar s [a]",
          "source": "src/Data-Parser-Grempa-Grammar.html#several",
          "type": "function"
        },
        "index": {
          "description": "Return new rule which consists of or more of the argument symbol Example several matches Creates one new rule",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "several",
          "normalized": "a-\u003eGrammar b[c]",
          "package": "Grempa",
          "signature": "x-\u003eGrammar s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:several"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new rule which consists of 0 or more of the argument symbol.\n   Example: \u003ccode\u003eseveral0 x\u003c/code\u003e matches \u003ccode\u003ex x ... x\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eCreates one new rule.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "several0",
          "package": "Grempa",
          "signature": "x -\u003e Grammar s [a]",
          "source": "src/Data-Parser-Grempa-Grammar.html#several0",
          "type": "function"
        },
        "index": {
          "description": "Create new rule which consists of or more of the argument symbol Example several0 matches Creates one new rule",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "several0",
          "normalized": "a-\u003eGrammar b[c]",
          "package": "Grempa",
          "signature": "x-\u003eGrammar s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:several0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a new rule which consists of a list of size 1 or more interspersed\n   with a symbol.\n   Example: \u003ccode\u003eseveralInter ';' x\u003c/code\u003e matches \u003ccode\u003ex ';' x ';' ... ';' x\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eCreates one new rule.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "severalInter",
          "package": "Grempa",
          "signature": "t -\u003e x -\u003e Grammar s [a]",
          "source": "src/Data-Parser-Grempa-Grammar.html#severalInter",
          "type": "function"
        },
        "index": {
          "description": "Return new rule which consists of list of size or more interspersed with symbol Example severalInter matches Creates one new rule",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "severalInter",
          "normalized": "a-\u003eb-\u003eGrammar c[d]",
          "package": "Grempa",
          "partial": "Inter",
          "signature": "t-\u003ex-\u003eGrammar s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:severalInter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new rule which consists of a list of size 0 or more interspersed\n   with a symbol.\n   Example: \u003ccode\u003eseveralInter0 ';' x\u003c/code\u003e matches \u003ccode\u003ex ';' x ';' ... ';' x\u003c/code\u003e\n   If \u003ccode\u003ex :: a\u003c/code\u003e then the result is of type \u003ccode\u003e[a]\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eCreates two new rules.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "severalInter0",
          "package": "Grempa",
          "signature": "t -\u003e x -\u003e Grammar s [a]",
          "source": "src/Data-Parser-Grempa-Grammar.html#severalInter0",
          "type": "function"
        },
        "index": {
          "description": "Create new rule which consists of list of size or more interspersed with symbol Example severalInter0 matches If then the result is of type Creates two new rules",
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "severalInter0",
          "normalized": "a-\u003eb-\u003eGrammar c[d]",
          "package": "Grempa",
          "partial": "Inter",
          "signature": "t-\u003ex-\u003eGrammar s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:severalInter0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Parser.Grempa.Grammar",
          "name": "toSym",
          "package": "Grempa",
          "signature": "a -\u003e Symbol t (ToSymT t a)",
          "source": "src/Data-Parser-Grempa-Grammar-Typed.html#toSym",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Parser Grempa Grammar",
          "module": "Data.Parser.Grempa.Grammar",
          "name": "toSym",
          "normalized": "a-\u003eSymbol b(ToSymT b a)",
          "package": "Grempa",
          "partial": "Sym",
          "signature": "a-\u003eSymbol t(ToSymT t a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Grammar.html#v:toSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCreate parsers from grammars statically (at compile time).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Parser.Grempa.Static",
          "name": "Static",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Static.html",
          "type": "module"
        },
        "index": {
          "description": "Create parsers from grammars statically at compile time",
          "hierarchy": "Data Parser Grempa Static",
          "module": "Data.Parser.Grempa.Static",
          "name": "Static",
          "package": "Grempa",
          "partial": "Static",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Static.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe different kinds of errors that can occur\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Static",
          "name": "ParseError",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Parser-Result.html#ParseError",
          "type": "data"
        },
        "index": {
          "description": "The different kinds of errors that can occur",
          "hierarchy": "Data Parser Grempa Static",
          "module": "Data.Parser.Grempa.Static",
          "name": "ParseError",
          "package": "Grempa",
          "partial": "Parse Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Static.html#t:ParseError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe result of running a parser\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Static",
          "name": "ParseResult",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Parser-Result.html#ParseResult",
          "type": "type"
        },
        "index": {
          "description": "The result of running parser",
          "hierarchy": "Data Parser Grempa Static",
          "module": "Data.Parser.Grempa.Static",
          "name": "ParseResult",
          "package": "Grempa",
          "partial": "Parse Result",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Static.html#t:ParseResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of a parser generated by Grempa\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Static",
          "name": "Parser",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Parser-Result.html#Parser",
          "type": "type"
        },
        "index": {
          "description": "The type of parser generated by Grempa",
          "hierarchy": "Data Parser Grempa Static",
          "module": "Data.Parser.Grempa.Static",
          "name": "Parser",
          "package": "Grempa",
          "partial": "Parser",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Static.html#t:Parser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a Template Haskell pattern from a value.\n   This is used to create a case expression from a parsing table when using\n   \u003ccode\u003e\u003ca\u003emkStaticParser\u003c/a\u003e\u003c/code\u003e, and it is thus required that the token type that the\n   parser is to operate on is an instance of this class.\n\u003c/p\u003e\u003cp\u003eThe parser will behave differently depending on how its \u003ccode\u003e\u003ca\u003eToPat\u003c/a\u003e\u003c/code\u003e instance\n   works. If only comparing constructors (\u003ccode\u003e\u003ca\u003etoConstrPat\u003c/a\u003e\u003c/code\u003e), it will regard\n   \u003ccode\u003eJust 1\u003c/code\u003e as the same compared to \u003ccode\u003eJust 2\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003etoConstrPat\u003c/a\u003e\u003c/code\u003e and \u003ca\u003eLanguage.Haskell.TH\u003c/a\u003e can help in creating an instance.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Static",
          "name": "ToPat",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Parser-Static.html#ToPat",
          "type": "class"
        },
        "index": {
          "description": "Make Template Haskell pattern from value This is used to create case expression from parsing table when using mkStaticParser and it is thus required that the token type that the parser is to operate on is an instance of this class The parser will behave differently depending on how its ToPat instance works If only comparing constructors toConstrPat it will regard Just as the same compared to Just toConstrPat and Language.Haskell.TH can help in creating an instance",
          "hierarchy": "Data Parser Grempa Static",
          "module": "Data.Parser.Grempa.Static",
          "name": "ToPat",
          "package": "Grempa",
          "partial": "To Pat",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Static.html#t:ToPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a static parser from a grammar.\n\u003c/p\u003e\u003cp\u003eExample usage:\n\u003c/p\u003e\u003cpre\u003e g :: Grammar s a\n gparser = $(mkStaticParser g [|g|])\n\u003c/pre\u003e\u003cp\u003eNote that \u003ccode\u003egparser\u003c/code\u003e must be in a different module than \u003ccode\u003eg\u003c/code\u003e, due to\n   Template Haskell restrictions.\n   The token type of the grammar must also be an instance of \u003ccode\u003e\u003ca\u003eToPat\u003c/a\u003e\u003c/code\u003e, and the\n   result type an instance of \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e (the GHC extension\n   DeriveDataTypeable may be useful for this).\n\u003c/p\u003e\u003cp\u003eIf there are conflicts in the parsing tables, they will be displayed\n   as warnings when compiling the parser.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Static",
          "name": "mkStaticParser",
          "package": "Grempa",
          "signature": "Grammar t a-\u003e ExpQ-\u003e ExpQ",
          "type": "function"
        },
        "index": {
          "description": "Make static parser from grammar Example usage Grammar gparser mkStaticParser Note that gparser must be in different module than due to Template Haskell restrictions The token type of the grammar must also be an instance of ToPat and the result type an instance of Typeable the GHC extension DeriveDataTypeable may be useful for this If there are conflicts in the parsing tables they will be displayed as warnings when compiling the parser",
          "hierarchy": "Data Parser Grempa Static",
          "module": "Data.Parser.Grempa.Static",
          "name": "mkStaticParser",
          "normalized": "Grammar a b-\u003eExpQ-\u003eExpQ",
          "package": "Grempa",
          "partial": "Static Parser",
          "signature": "Grammar t a-\u003eExpQ-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Static.html#v:mkStaticParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAutomatically create a \u003ccode\u003e\u003ca\u003eToPat\u003c/a\u003e\u003c/code\u003e instance which only compares the constructor\n   of the token type. For example, the pattern yielded from using this on the\n   value \u003ccode\u003eJust 3\u003c/code\u003e is the pattern \u003ccode\u003eJust _\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eExample usage:\n\u003c/p\u003e\u003cpre\u003e instance ToPat TokenType where\n     toPat = toConstrPat\n\u003c/pre\u003e",
          "module": "Data.Parser.Grempa.Static",
          "name": "toConstrPat",
          "package": "Grempa",
          "signature": "t -\u003e PatQ",
          "source": "src/Data-Parser-Grempa-Parser-Static.html#toConstrPat",
          "type": "function"
        },
        "index": {
          "description": "Automatically create ToPat instance which only compares the constructor of the token type For example the pattern yielded from using this on the value Just is the pattern Just Example usage instance ToPat TokenType where toPat toConstrPat",
          "hierarchy": "Data Parser Grempa Static",
          "module": "Data.Parser.Grempa.Static",
          "name": "toConstrPat",
          "normalized": "a-\u003ePatQ",
          "package": "Grempa",
          "partial": "Constr Pat",
          "signature": "t-\u003ePatQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Static.html#v:toConstrPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Parser.Grempa.Static",
          "name": "toPat",
          "package": "Grempa",
          "signature": "a -\u003e PatQ",
          "source": "src/Data-Parser-Grempa-Parser-Static.html#toPat",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Parser Grempa Static",
          "module": "Data.Parser.Grempa.Static",
          "name": "toPat",
          "normalized": "a-\u003ePatQ",
          "package": "Grempa",
          "partial": "Pat",
          "signature": "a-\u003ePatQ",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Static.html#v:toPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGenerate arbitrary input strings for a grammar and see that it is\n   able to parse them.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Parser.Grempa.Test",
          "name": "Test",
          "package": "Grempa",
          "source": "src/Data-Parser-Grempa-Test.html",
          "type": "module"
        },
        "index": {
          "description": "Generate arbitrary input strings for grammar and see that it is able to parse them",
          "hierarchy": "Data Parser Grempa Test",
          "module": "Data.Parser.Grempa.Test",
          "name": "Test",
          "package": "Grempa",
          "partial": "Test",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Test.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQuickCheck property for seeing if a parser can parse everything produced\n   by a grammar and get the expected result.\n\u003c/p\u003e\u003cp\u003eThere are cases where the property will fail even though the parser is\n   correct. That can happen when there is an \u003ccode\u003eepsilon\u003c/code\u003e production that makes\n   it valid to make the result tree nest one more level without eating any of\n   the input. The parsers generated will not do this, but the random input\n   generator currently will (this is a bug).\n   An example of this is the following:\n\u003c/p\u003e\u003cpre\u003e data Expr = ... | EApp Expr [Expr]\n grammar = ...\n     expr \u003c- rule [...\n                  , EApp \u003c@\u003e expr \u003c#\u003e exprs\n                  ]\n     exprs \u003c- several expr\n\u003c/pre\u003e\u003cp\u003eHere, the random generator may produce \u003ccode\u003eEApp expr []\u003c/code\u003e for some \u003ccode\u003eexpr\u003c/code\u003e,\n   as the rule \u003ccode\u003eseveral\u003c/code\u003e \u003ccode\u003eexpr\u003c/code\u003e matches 0 or more \u003ccode\u003eexpr\u003c/code\u003es.\n   which will have the same input token string as just \u003ccode\u003eexpr\u003c/code\u003e which is what\n   the parser will parse, so the expected result and the parsed result will\n   differ.\n\u003c/p\u003e",
          "module": "Data.Parser.Grempa.Test",
          "name": "prop_parser",
          "package": "Grempa",
          "signature": "Parser s a-\u003e Grammar s a-\u003e Property",
          "type": "function"
        },
        "index": {
          "description": "QuickCheck property for seeing if parser can parse everything produced by grammar and get the expected result There are cases where the property will fail even though the parser is correct That can happen when there is an epsilon production that makes it valid to make the result tree nest one more level without eating any of the input The parsers generated will not do this but the random input generator currently will this is bug An example of this is the following data Expr EApp Expr Expr grammar expr rule EApp expr exprs exprs several expr Here the random generator may produce EApp expr for some expr as the rule several expr matches or more expr which will have the same input token string as just expr which is what the parser will parse so the expected result and the parsed result will differ",
          "hierarchy": "Data Parser Grempa Test",
          "module": "Data.Parser.Grempa.Test",
          "name": "prop_parser",
          "normalized": "Parser a b-\u003eGrammar a b-\u003eProperty",
          "package": "Grempa",
          "signature": "Parser s a-\u003eGrammar s a-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Grempa/docs/Data-Parser-Grempa-Test.html#v:prop_parser"
      }
    }
  ]
]